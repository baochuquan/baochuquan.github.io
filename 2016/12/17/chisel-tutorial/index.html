<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="硬件描述语言,Chisel," />





  <link rel="alternate" href="/atom.xml" title="楚权的世界" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/chu.ico?v=5.1.2" />






<meta name="description" content="原文链接 介绍Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例">
<meta name="keywords" content="硬件描述语言,Chisel">
<meta property="og:type" content="article">
<meta property="og:title" content="Chisel入门教程">
<meta property="og:url" content="http://chuquan.me/2016/12/17/chisel-tutorial/index.html">
<meta property="og:site_name" content="楚权的世界">
<meta property="og:description" content="原文链接 介绍Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-operators.png">
<meta property="og:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png">
<meta property="og:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png">
<meta property="og:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-for-when.png">
<meta property="og:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-cpu.png">
<meta property="og:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-gongshi.png">
<meta property="og:updated_time" content="2018-02-08T10:23:34.308Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chisel入门教程">
<meta name="twitter:description" content="原文链接 介绍Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例">
<meta name="twitter:image" content="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-operators.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chuquan.me/2016/12/17/chisel-tutorial/"/>





  <title>Chisel入门教程 | 楚权的世界</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?030cf08d5b27d756fa9aeecb1130fe13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
	<a href="https://github.com/baochuquan"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">楚权的世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Seek the wonder of life.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photos">
          <a href="/photos" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-image"></i> <br />
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/12/17/chisel-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bao Chuquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/SlamDunk.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="楚权的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Chisel入门教程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="发表于" itemprop="dateCreated datePublished" datetime="2016-12-17T14:46:37+08:00">
                2016-12-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-02-08T18:23:34+08:00">
                2018-02-08
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/翻译/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/chisel-tutorial.pdf" target="_blank" rel="noopener">原文链接</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例子来说明某些重要的Scala特征，可以让你只使用本文介绍的东西也能完成一些伟大的硬件设计。 当你越来越有经验，希望自己的代码能够更加简化或提高复用性，你会发现有必要了解Scala语言的潜力。 所以，进一步学习Scala会让你变得更加专业。  </p>
<p>Chisel仍处于起步阶段，你可能会遇到一些实现方面的bug，甚至可能会遇到一些概念设计问题。不过，我们正在积极地修改和改进语言，并且对错误报告和建议开放。即使在早期阶段，我们希望Chisel将帮助设计师在构建易于重复使用和维护的设计时更有效率。  </p>
<h1 id="Chisel硬件表达"><a href="#Chisel硬件表达" class="headerlink" title="Chisel硬件表达"></a>Chisel硬件表达</h1><p>此版本的Chisel只支持二进制逻辑，不支持三态信号。  </p>
<blockquote>
<p>我们专注于二进制逻辑设计，因为它们构成了实践中的绝大多数设计。我们忽略对当前Chisel语言中的三态逻辑的支持，因为这在工业环境中也很少支持，并且难以在受控硬宏之外可靠地使用。  </p>
</blockquote>
<h1 id="Chisel数据类型"><a href="#Chisel数据类型" class="headerlink" title="Chisel数据类型"></a>Chisel数据类型</h1><p>Chisel数据类型用于指定状态元素中保存的值或wire上传输的值。虽然硬件设计最终操作的是二进制数值向量，但对于值的其他抽象表示具有更清晰的规范，并且能够帮助工具生成更优化的电路。在Chisel中，原始比特集合可以用Bits类型来表示。带符号和无符号整数被认为是定点数的子集，可以用SInt和UInt来表示。带符号定点整数（包括整数）使用二进制补码格式来表示。布尔值可以用Bool类型表示。注意，这些类型与Scala的内建类型不同，例如Int或Boolean。另外，Chisel定义了Bundle用来将值进行集合（类似于其他语言中的struct），还定义了Vec用来对值的集合进行索引。  </p>
<p>常量或字面值使用Scala整数或传递给构造函数的字符串表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="number">1</span>)			<span class="comment">// decimal 1-bit lit from Scala Int.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"ha"</span>)		<span class="comment">// hexadecimal 4-bit lit from string.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"o12"</span>)		<span class="comment">// octal 4-bit lit from string.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"b1010"</span>) 	<span class="comment">// binary 4-bit lit from string.</span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">5</span>) 		<span class="comment">// signed decimal 4-bit lit from Scala Int. </span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">-8</span>) 		<span class="comment">// negative decimal 4-bit lit from Scala Int. </span></span><br><span class="line"><span class="type">UInt</span>(<span class="number">5</span>) 		<span class="comment">// unsigned decimal 3-bit lit from Scala Int.</span></span><br><span class="line"><span class="type">Bool</span>(<span class="literal">true</span>) 		<span class="comment">// Bool lits from Scala lits. </span></span><br><span class="line"><span class="type">Bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>下划线可以用作长字符串文字中的分隔符，以帮助可读性，但在创建值时会被忽略，例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="string">"h_dead_beef"</span>) <span class="comment">// 32-bit lit of type UInt</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Chisel编译器将每个常量的大小设置为保存常量所需的最小位数，包括带符号类型的符号位。位宽也可以在字面上明确指定，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="string">"ha"</span>, <span class="number">8</span>) 		<span class="comment">// hexadecimal 8-bit lit of type UInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"o12"</span>, <span class="number">6</span>) 		<span class="comment">// octal 6-bit lit of type UInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">"b1010"</span>, <span class="number">12</span>) 	<span class="comment">// binary 12-bit lit of type UInt</span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">5</span>, <span class="number">7</span>) 			<span class="comment">// signed decimal 7-bit lit of type SInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="number">5</span>, <span class="number">8</span>) 			<span class="comment">// unsigned decimal 8-bit lit of type UInt</span></span><br></pre></td></tr></table></figure></p>
<p>对于UInt类型值，值被零扩展到所需的位宽。对于类型为SInt的文字，该值被符号扩展以填充所需的位宽度。如果给定的位宽太小而不能容纳参数值，则会生成Chisel错误。</p>
<h1 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h1><p>在Chisel中，电路会被表示为一张节点图。每个节点是具有零个或多个输入并驱动一个输出的硬件运算符。上面介绍的Uint是一种退化类型的节点，它没有输入，并且在其输出上驱动一个恒定的值。创建和连接节点的一种方法是使用字面表达式。例如，我们可以使用以下表达式来表示简单的组合逻辑电路：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &amp; b) | (~c &amp; d)</span><br></pre></td></tr></table></figure></p>
<p>语法应该看起来很熟悉，用＆和|分别表示按位与和按位或，~表示按位非。a到d表示某些（未指定）宽度的命名导线。<br>任何简单的表达式都可以直接转换成电路树，在叶子处使用命名的导线和操作符形成内部节点。表达式的电路输出取自树根处的运算符，在本示例中是按位或运算。<br>简单表达式可以以树的形式构建电路，但是如果想以任意有向非循环图（DAG）的形式构建电路，我们需要描述扇出。在Chisel中，我们通过命名一根wire来表示一个子表达式，这样我们就可以在后续表达式中多次引用。我们通过声明变量来命名Chisel中的wire。例如，考虑如下示例的select表达式，它在后续的多选器描述中可以多次使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sel = a | b</span><br><span class="line"><span class="keyword">val</span> out = (sel &amp; in1) | (~sel &amp; in0)</span><br></pre></td></tr></table></figure></p>
<p>关键字<strong>val</strong>是Scala的一部分，用于命名具有不会再更改的值的变量。 在上面的例子中它命名了wire类型的sel，保存了第一个按位或运算符的输出，以便输出可在第二个表达式中多次使用。  </p>
<h1 id="内建操作符"><a href="#内建操作符" class="headerlink" title="内建操作符"></a>内建操作符</h1><p>Chisel定义了一组硬件操作符，如下表所示：  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-operators.png" alt=""></div>

<h2 id="位宽接口"><a href="#位宽接口" class="headerlink" title="位宽接口"></a>位宽接口</h2><p>用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png" alt=""></div>  

<p>其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算。</p>
<p>位宽推测过程会持续到没有位宽改变。 除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。 此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。  </p>
<blockquote>
<p>我们选择的运算符名称受到Scala语言的限制。所以我们必须使用===表示等于判断逻辑和=/=表示不等判断逻辑，这样可以保持原生Scala相关运算符可用。  </p>
</blockquote>
<h1 id="功能抽象"><a href="#功能抽象" class="headerlink" title="功能抽象"></a>功能抽象</h1><p>我们可以定义函数来分解一个重复的逻辑，这样可以在后续设计中重复使用。例如，我们可以包装一个简单的组合逻辑块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clb</span></span>(a: <span class="type">UInt</span>, b: <span class="type">UInt</span>, c: <span class="type">UInt</span>, d: <span class="type">UInt</span>): <span class="type">UInt</span> = </span><br><span class="line">	(a &amp; b) | (~c &amp; d)</span><br></pre></td></tr></table></figure></p>
<p>其中clb是表示以a，b，c，d为参数的函数，并返回一个布尔电路的输出。 <strong>def</strong>关键字是Scala的一部分，表示引入了一个函数定义，每个语句后面跟一个冒号，然后是它的类型，函数返回类型在参数列表之后的冒号之后。（=）符号将函数参数列表与函数定义分隔开。<br>然后我们就可以在其他的电路中使用了：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> out = clb(a,b,c,d)</span><br></pre></td></tr></table></figure></p>
<p>我们将在后面介绍许多吊炸天的函数使用方法来构造硬件。  </p>
<h1 id="Bundles-amp-Vecs"><a href="#Bundles-amp-Vecs" class="headerlink" title="Bundles &amp; Vecs"></a>Bundles &amp; Vecs</h1><p>Bundle和Vec是可以允许用户使用其他数据类型来扩展Chisel数据类型集合的类。<br>Bundle可以将一些不同类型的命名字段组合成一个单元，类似于C语言中的struct。用户可以通过将一个类定义为Bundle的子类来定义自己的bundle：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFloat</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> sign = <span class="type">Bool</span>()</span><br><span class="line">	<span class="keyword">val</span> exponent = <span class="type">UInt</span>(width = <span class="number">8</span>) </span><br><span class="line">	<span class="keyword">val</span> significand = <span class="type">UInt</span>(width = <span class="number">23</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">MyFloat</span>()</span><br><span class="line"><span class="keyword">val</span> xs = x.sign</span><br></pre></td></tr></table></figure></p>
<p>scala约定将新类的名称的首字母大写，所以我们建议在Chisel中也遵循这个约定。 UInt构造函数的width命名参数指定类型中的位数。  </p>
<p>Vecs用来创建一个可索引的元素向量，其构造如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector of 5 23-bit signed integers.</span></span><br><span class="line"><span class="keyword">val</span> myVec = <span class="type">Vec</span>.fill(<span class="number">5</span>)&#123; <span class="type">SInt</span>(width = <span class="number">23</span>) &#125; </span><br><span class="line"><span class="comment">// Connect to one element of vector.</span></span><br><span class="line"><span class="keyword">val</span> reg3 = myVec(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>（注意，我们必须在花括号内指定Vec元素的类型，因为我们必须将位宽参数传递给SInt构造器。）<br>原始类（SInt，UInt和Bool）加上聚合类（Bundles和Vecs）都继承自一个公共的超类Data。在电路中，每个最终继承自Data的对象都可以表示为一个位向量。<br>Bundle和Vec可以任意嵌套，从而构建复杂的数据结构：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBundle</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Vector of 5 23-bit signed integers.</span></span><br><span class="line">	<span class="keyword">val</span> myVec = <span class="type">Vec</span>.fill(<span class="number">5</span>) &#123; <span class="type">SInt</span>(width = <span class="number">23</span>) &#125; </span><br><span class="line">	<span class="keyword">val</span> flag = <span class="type">Bool</span>()</span><br><span class="line">	<span class="comment">// Previously defined bundle.</span></span><br><span class="line">	<span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">MyFloat</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>端口用作硬件组件的接口。一个端口可以是任意的Data对象，但它是具有方向的。<br>Chisel提供端口构造函数，以允许在构建时给对象添加（输入或输出）。原始的端口构造函数需要将方向作为第一个参数（方向为INPUT或OUTPUT），将位数作为第二个参数（除了始终为1位的布尔值）。<br>端口的声明如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoupled</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> data = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Decoupled被定义后，它就会变成一个新的类型，可以根据需要用于模块接口或命名的wire集合。<br>对象的方向也可以实例化时确定：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaleIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> in = <span class="keyword">new</span> <span class="type">MyFloat</span>().asInput </span><br><span class="line">	<span class="keyword">val</span> scale = <span class="keyword">new</span> <span class="type">MyFloat</span>().asInput </span><br><span class="line">	<span class="keyword">val</span> out = <span class="keyword">new</span> <span class="type">MyFloat</span>().asOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>asInput和asOutput方法可以强制数据对象的所有模块设置成对应的方向。<br>通过将方向折叠到对象声明中，Chisel能够提供强大的布线能力，稍后会详细介绍。  </p>
<h1 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h1><p>我们现在可以构建电路层次，我们可以从较小的子模块开开始构建更大的模块。例如，我们可以通过将三个2输入多路选择器连接在一起，构建一个4输入多路选择器模块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux4</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in2 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) 	</span><br><span class="line">		<span class="keyword">val</span> in3 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">2</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> m0 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m0.io.sel := io.sel(<span class="number">0</span>)</span><br><span class="line">	m0.io.in0 := io.in0; </span><br><span class="line">	m0.io.in1 := io.in1</span><br><span class="line">	<span class="keyword">val</span> m1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m1.io.sel := io.sel(<span class="number">0</span>)</span><br><span class="line">	m1.io.in0 := io.in2; </span><br><span class="line">	m1.io.in1 := io.in3</span><br><span class="line">	<span class="keyword">val</span> m3 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m3.io.sel := io.sel(<span class="number">1</span>)</span><br><span class="line">	m3.io.in0 := m0.io.out; </span><br><span class="line">	m3.io.in1 := m1.io.out</span><br><span class="line">	io.out := m3.io.out </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="运行和测试"><a href="#运行和测试" class="headerlink" title="运行和测试"></a>运行和测试</h1><p>现在我们已经定义了模块，我们将讨论如何实际运行并测试电路。Chisel代码可以转换为C++或Verilog。 为了编译电路，我们需要调用chiselMain：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">tutorial</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">		chiselMain(args, () =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())) </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试是电路设计的关键部分，因此在Chisel中，我们通过这样一种测试机制：使用Tester类的子类在Scala中提供测试向量：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>[<span class="type">T</span> &lt;: <span class="type">Module</span>] (<span class="params">val c: <span class="type">T</span>, val isTrace: <span class="type">Boolean</span> = true</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">val</span> rnd: <span class="type">Random</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Boolean</span>): <span class="type">BigInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Int</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Bits</span>): <span class="type">BigInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(n: <span class="type">Int</span> = <span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pokeAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>, x: <span class="type">BigInt</span>) </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Bits</span>, x: <span class="type">BigInt</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Aggregate</span>, x: <span class="type">Array</span>[<span class="type">BigInt</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peekAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Aggregate</span>): <span class="type">Array</span>[<span class="type">BigInt</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(good: <span class="type">Boolean</span>, msg: <span class="type">String</span>): <span class="type">Boolean</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(data: <span class="type">Bits</span>, target: <span class="type">BigInt</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户会用到一下这些：  </p>
<ul>
<li><strong>poke</strong>: 设置输入端口以及状态值  </li>
<li><strong>step</strong>: 以一个时间单元执行电路  </li>
<li><strong>peek</strong>: 读取端口和状态值  </li>
<li><strong>expect</strong>: 比较peek获得的值和期望的值  </li>
</ul>
<p>用户使用如下的方式连接tester和模块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMainTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>)( </span><br><span class="line">			tester: <span class="type">T</span> =&gt; <span class="type">Tester</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当- -test作为参数传递给chiselMainTest时，tester实例在独立的进程中运行被测器件（DUT），并连接stdin和stdout，这样调试命令可以发送到DUT，响应也可以从DUT接收，如图所示。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png" alt=""></div>

<p>举例说明：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2Tests</span>(<span class="params">c: <span class="type">Mux2</span></span>) <span class="keyword">extends</span> <span class="title">Tester</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> n = pow(<span class="number">2</span>, <span class="number">3</span>).toInt</span><br><span class="line">	<span class="keyword">for</span> (s &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i0 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123; </span><br><span class="line">			<span class="keyword">for</span> (i1 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">				poke(c.io.sel, s)</span><br><span class="line">				poke(c.io.in1, i1)</span><br><span class="line">				poke(c.io.in0, i0)</span><br><span class="line">				step(<span class="number">1</span>)</span><br><span class="line">				expect(c.io.out, (<span class="keyword">if</span> (s == <span class="number">1</span>) i1 <span class="keyword">else</span> i0))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用poke将Mux2的每个输入的分别设置为合适的值。对于这个例子，我们通过硬编码输入到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块输入，让模拟将这些值分配给我们正在测试的器件c的输入，单步运行电路并对比期望值。最后，简单说明一下如何调用测试器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chiselMainTest(args + <span class="string">"--test"</span>, () =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>()))&#123; </span><br><span class="line">	c =&gt; <span class="keyword">new</span> <span class="type">Mux2Tests</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有其他的一些命令参数：  </p>
<blockquote>
<p>–targetDir    目标路径名前缀<br>–genHarness    生成C++文件<br>–backend v    生成verilog<br>–backend c    生成C++（默认）<br>–vcd            开启vcd打印<br>–debug        把所有的wire放入class文件  </p>
</blockquote>
<h1 id="状态元素"><a href="#状态元素" class="headerlink" title="状态元素"></a>状态元素</h1><p>Chisel支持的状态元素的最简单形式是上升沿触发寄存器，可以实例化为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> reg = <span class="type">Reg</span>(next = in)</span><br></pre></td></tr></table></figure></p>
<p>该电路具有输出，该输出是前一个时钟周期的输入信号产生的值。注意，我们不必指定Reg的类型，因为它会在实例化时从输入开始自动推断。在当前版本的Chisel中，时钟和复位是全局信号，在需要时可以隐式包含。<br>使用寄存器，我们可以快速定义一些有用的电路结构。 例如，当当前值为true且之前的值为false时，上升沿检测器能够获取到布尔信号并输出true，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">risingedge</span></span>(x: <span class="type">Bool</span>) = x &amp;&amp; !<span class="type">Reg</span>(next = x)</span><br></pre></td></tr></table></figure></p>
<p>计数器是一个重要的时序电路。 如果想构建一个向上计数器，计数到最大值max后回到零：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span></span>(max: <span class="type">UInt</span>) = &#123;</span><br><span class="line">	<span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, max.getWidth))</span><br><span class="line">	x := <span class="type">Mux</span>(x === max, <span class="type">UInt</span>(<span class="number">0</span>), x + <span class="type">UInt</span>(<span class="number">1</span>))</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计数器复位值为0（宽度大到足以容纳max），当电路的全局复位置位时，寄存器将初始化为该值。<br>计数器可用于构建很多有用的时序电路。例如，我们可以通过在计数器达到零时输出true来构建脉冲发生器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produce pulse every n cycles.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pulse</span></span>(n: <span class="type">UInt</span>) = counter(n - <span class="type">UInt</span>(<span class="number">1</span>)) === <span class="type">UInt</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过切换方波发生器脉冲序列，在每个脉冲上的true和false之间切换：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flip internal state when input true.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toggle</span></span>(p: <span class="type">Bool</span>) = &#123;</span><br><span class="line">	<span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">Bool</span>(<span class="literal">false</span>)) </span><br><span class="line">	x := <span class="type">Mux</span>(p, !x, x)</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Square wave of a given period.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squareWave</span></span>(period: <span class="type">UInt</span>) = toggle(pulse(period/<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="转发声明"><a href="#转发声明" class="headerlink" title="转发声明"></a>转发声明</h2><p>纯组合电路在节点之间不存在周期，如果检测到这样的周期，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建组合电路，通过添加一些输入从已经定义的节点导出的新节点。时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前输出。因为Scala顺序执行程序语句，所以我们允许数据节点作为wire来提供节点声明，这样可以立即被使用，但其输入将稍后设置。如下例所示，在简单的CPU中，我们需要定义pcPlus4和brTarget的线，以便在定义之前引用它们：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pcPlus4 = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> brTarget = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> pcNext = <span class="type">Mux</span>(io.ctrl.pcSel, brTarget, pcPlus4)</span><br><span class="line"><span class="keyword">val</span> pcReg = <span class="type">Reg</span>(next = pcNext, init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">32</span>)) </span><br><span class="line">pcPlus4 := pcReg + <span class="type">UInt</span>(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">brTarget := addOut</span><br></pre></td></tr></table></figure></p>
<p>接线操作符:=用于在pcReg和addOut定义后连接。  </p>
<h2 id="条件更新"><a href="#条件更新" class="headerlink" title="条件更新"></a>条件更新</h2><p>在前面使用到寄存器的示例中，我们简单地将组合逻辑块连接到寄存器的输入。当描述状态元素的操作时，指定何时将发生寄存器更新并且用几个单独的语句指明这些更新。Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">16</span>)) </span><br><span class="line">when (cond) &#123;</span><br><span class="line">	r := r + <span class="type">UInt</span>(<span class="number">1</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中只有在cond为真时，才在当前时钟周期的结尾更新寄存器r。when的参数是返回Bool值。后面的更新块只能包含使用赋值运算符:=，简单表达式和用val定义的命名引线的更新语句。<br>在条件更新序列中，条件为真的最近条件更新优先。 例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">when (c1) &#123; r := <span class="type">UInt</span>(<span class="number">1</span>) &#125; </span><br><span class="line">when (c2) &#123; r := <span class="type">UInt</span>(<span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述表达式会根据以下真值表更新r：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">c1</th>
<th style="text-align:center">c2</th>
<th style="text-align:center">r</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">r</td>
<td style="text-align:left">r 不变</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:left">c2优先于c1</td>
</tr>
</tbody>
</table>
<p>下图显示了如何将每个条件更新视为在寄存器的输入之前插入mux，根据when选择更新表达式或之前的输入。编译器会把初始化值置于链的开头，以便如果在一个时钟周期内没有条件更新激活，则寄存器的加载使能将被置为无效，寄存器值就不会改变。  </p>
<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-for-when.png" alt=""></div>

<p>Chisel为条件更新的其他常见形式提供了一些语法糖。除非结构与when相同，但否定其条件。也就是说，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unless (c) &#123; body &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (!c) &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>更新块可以操作多个目标寄存器，在不同更新块中的也允许存在寄存器的不同重叠子集。每个寄存器只受其出现的条件的影响。组合电路（更新Wire）也是可能的。注意，所有组合电路需要默认值。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="type">SInt</span>(<span class="number">3</span>); s := <span class="type">SInt</span>(<span class="number">3</span>)</span><br><span class="line">when (c1) &#123; r := <span class="type">SInt</span>(<span class="number">1</span>); s := <span class="type">SInt</span>(<span class="number">1</span>) &#125; </span><br><span class="line">when (c2) &#123; r := <span class="type">SInt</span>(<span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述语句会根据如下真值表更新r和s：  </p>
<table>
<thead>
<tr>
<th style="text-align:center">c1</th>
<th style="text-align:center">c2</th>
<th style="text-align:center">r</th>
<th style="text-align:center">s</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>条件更新结构可以嵌套，任何给定块在所有外嵌套条件的联合下才能执行。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">when (a) &#123; when (b) &#123; body &#125; &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (a &amp;&amp; b) &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>条件可以使用when，.elsewhen，.otherwise来链式表达，对应于Scala中的if, else if, else。例如：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">when (c1) &#123; u1 &#125; </span><br><span class="line">.elsewhen (c2) &#123; u2 &#125; </span><br><span class="line">.otherwise &#123; ud &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (c1) &#123; u1 &#125;</span><br><span class="line">when (!c1 &amp;&amp; c2) &#123; u2 &#125; </span><br><span class="line">when (!(c1 || c2)) &#123; ud &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再介绍关于用于条件更新的switch语句，其涉及针对公共密钥的一系列比较。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch(idx) &#123; </span><br><span class="line">	is(v1) &#123; u1 &#125; </span><br><span class="line">	is(v2) &#123; u2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the same sa</span></span><br><span class="line">when (idx === v1) &#123; u1 &#125; </span><br><span class="line">.elsewhen (idx === v2) &#123; u2 &#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel还允许Wire，即一些组合逻辑的输出，成为条件性更新语句的目标，以允许逐步构建复杂的组合逻辑表达式。Chisel不允许不指定组合输出，并且如果组合输出未遇到无条件更新，则报告错误。  </p>
<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>在数字设计中有限状态机（FSM）是时序电路常用的类型。简单FSM的例子就是奇偶校验生成器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parity</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>) </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_even :: s_odd :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">2</span>) </span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_even)</span><br><span class="line">	when (io.in) &#123;</span><br><span class="line">		when (state === s_even) &#123; state := s_odd &#125;</span><br><span class="line">		when (state === s_odd) &#123; state := s_even &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	io.out := (state === s_odd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Enum(Uint(), 2)生成两个UInt数。当io.in为true时更新状态。需要注意的是，FSM的所有机制都建立在寄存器，线和条件更新的基础上。<br>下面是一个复杂的FSM例子，这是一个自动售货机接收货币的电路：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> nickel = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> dime   = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> valid  = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_idle) </span><br><span class="line">	when (state === s_idle) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_5 &#125;</span><br><span class="line">		when (io.dime) &#123; state := s_10 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_5) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_10 &#125; </span><br><span class="line">		when (io.dime) &#123; state := s_15 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_10) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_15 &#125;</span><br><span class="line">		when (io.dime) &#123; state := s_ok &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_15) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_ok &#125; </span><br><span class="line">		when (io.dime) &#123; state := s_ok &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_ok) &#123;</span><br><span class="line">		state := s_idle</span><br><span class="line">	&#125;</span><br><span class="line">	io.valid := (state === s_ok) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个使用switch语句定义的售货机FSM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> nickle = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> dime   = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> valid  = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_idle) </span><br><span class="line">	switch (state) &#123; </span><br><span class="line">		is (s_idle) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_5 &#125;</span><br><span class="line">			when (io.dime) &#123; state := s_10 &#125; </span><br><span class="line">		&#125; </span><br><span class="line">		is (s_5) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_10 &#125; </span><br><span class="line">			when (io.dime) &#123; state := s_15 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		is (s_10) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_15 &#125;</span><br><span class="line">			when (io.dime) &#123; state := s_ok &#125; </span><br><span class="line">		&#125;</span><br><span class="line">		is (s_ok) &#123;</span><br><span class="line">			state := s_idle</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	io.valid := (state === s_ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>Chisel提供了创建只读和读/写存储器的功能。  </p>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>用户可以使用Vec定义ROM：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vec</span>(inits: <span class="type">Seq</span>[<span class="type">T</span>])</span><br><span class="line"><span class="type">Vec</span>(elt0: <span class="type">T</span>, elts: <span class="type">T</span>*)</span><br></pre></td></tr></table></figure></p>
<p>其中inits是初始化ROM的初始Data序列。例如，用户可以创建一个初始化为1,2,4,8的小型ROM，并使用计数器作为地址生成器循环访问所有值，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="type">Vec</span>(<span class="type">Array</span>(<span class="type">UInt</span>(<span class="number">1</span>), <span class="type">UInt</span>(<span class="number">2</span>), <span class="type">UInt</span>(<span class="number">4</span>), <span class="type">UInt</span>(<span class="number">8</span>))) </span><br><span class="line"><span class="keyword">val</span> r = m(counter(<span class="type">UInt</span>(m.length)))</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用如下初始化的ROM创建n值正弦查找表：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinTable</span> </span>(amp: <span class="type">Double</span>, n: <span class="type">Int</span>) = &#123; </span><br><span class="line">	<span class="keyword">val</span> times = <span class="type">Range</span>(<span class="number">0</span>, n, <span class="number">1</span>).map(i =&gt; (i*<span class="number">2</span>*<span class="type">Pi</span>)/(n.toDouble<span class="number">-1</span>) - <span class="type">Pi</span>) </span><br><span class="line">	<span class="keyword">val</span> inits = times.map(t =&gt; <span class="type">SInt</span>(round(amp * sin(t)), width = <span class="number">32</span>)) </span><br><span class="line">	<span class="type">Vec</span>(inits)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinWave</span> </span>(amp: <span class="type">Double</span>, n: <span class="type">Int</span>) =</span><br><span class="line">	sinTable(amp, n)(counter(<span class="type">UInt</span>(n))</span><br></pre></td></tr></table></figure></p>
<p>其中amp用于缩放存储在ROM中的固定点值。</p>
<h2 id="Mem"><a href="#Mem" class="headerlink" title="Mem"></a>Mem</h2><p>存储器在Chisel中被给予特殊处理，因为存储器的硬件实现具有许多变化，例如，FPGA存储器与ASIC存储实例化的结果完全不同。Chisel定义了一个内存抽象，可以映射到简单的Verilog行为描述，也可以映射到从代工厂或IP厂商提供的外部内存生成器获得的内存模块实例。<br>Chisel通过Mem结构可以支持随机存取存储器。写入Mems是正边沿触发，读取是组合或正边沿触发。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="class"><span class="keyword">type</span></span>: <span class="type">T</span>, depth: <span class="type">Int</span>,</span><br><span class="line">		seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span>, depth: <span class="type">Int</span>, seqRead: <span class="type">Boolean</span> = false</span>)</span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">Updateable</span> </span>&#123; </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32-entry的寄存器堆可以如下表示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rf = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">64</span>), <span class="number">32</span>) </span><br><span class="line">when (wen) &#123; rf(waddr) := wdata &#125; </span><br><span class="line"><span class="keyword">val</span> dout1 = rf(waddr1)</span><br><span class="line"><span class="keyword">val</span> dout2 = rf(waddr2)</span><br></pre></td></tr></table></figure></p>
<p>如果设置了可选参数seqRead，当读地址为Reg时，Chisel将尝试推断顺序读端口。单读端口，单写端口SRAM可以描述如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1r1w = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">1024</span>, seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> reg_raddr = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1r1w(waddr) := wdata &#125; </span><br><span class="line">when (ren) &#123; reg_raddr := raddr &#125;</span><br><span class="line"><span class="keyword">val</span> rdata = ram1r1w(reg_raddr)</span><br></pre></td></tr></table></figure></p>
<p>单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1p = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">1024</span>, seqRead = <span class="literal">true</span>) </span><br><span class="line"><span class="keyword">val</span> reg_raddr = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1p(waddr) := wdata &#125; </span><br><span class="line">.elsewhen (ren) &#123; reg_raddr := raddr &#125;</span><br><span class="line"><span class="keyword">val</span> rdata = ram1p(reg_raddr)</span><br></pre></td></tr></table></figure></p>
<p>如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据为未定义。<br>Mem还支持subword写入的写掩码。如果相应的屏蔽位置1，则写入给定位。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">256</span>)</span><br><span class="line">when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">PLink</span>().flip</span><br><span class="line">	<span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">PLink</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中flip递归地改变Bundle的“性别”，将输入改变为输出和输出。<br>我们现在可以通过定义一个过滤器类扩展模块来定义一个过滤器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; <span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中io包含了FilterIO。  </p>
<h2 id="Bundle-向量"><a href="#Bundle-向量" class="headerlink" title="Bundle 向量"></a>Bundle 向量</h2><p>除了单个元素，元素向量可以形成更丰富的分层接口。例如，创建具有输入向量的交叉开关，产生输出向量，并通过UInt输入选择，我们可以使用Vec构造函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossbarIo</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> in = <span class="type">Vec</span>.fill(n)&#123; <span class="keyword">new</span> <span class="type">PLink</span>().flip() &#125; </span><br><span class="line">	<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, sizeof(n))</span><br><span class="line">	<span class="keyword">val</span> out = <span class="type">Vec</span>.fill(n)&#123; <span class="keyword">new</span> <span class="type">PLink</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Vec用第一个参获取大小，区块返回一个端口作为第二个参数。  </p>
<h2 id="批量连接"><a href="#批量连接" class="headerlink" title="批量连接"></a>批量连接</h2><p>我们现在可以将两个过滤器组成一个过滤器块，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>()</span><br><span class="line">	<span class="keyword">val</span> f1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>()) </span><br><span class="line">	<span class="keyword">val</span> f2 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>())</span><br><span class="line">	f1.io.x &lt;&gt; io.x </span><br><span class="line">	f1.io.y &lt;&gt; f2.io.x </span><br><span class="line">	f2.io.y &lt;&gt; io.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中&lt;&gt;批量连接同级模块之间的相反接口或父/子模块之间的相同接口。批量连接将相同名称的叶子端口彼此连接。在所有连接完成后，Chisel警告用户端口是否只有一个到它们的连接。  </p>
<h2 id="接口视图"><a href="#接口视图" class="headerlink" title="接口视图"></a>接口视图</h2><p>考虑一个由控制逻辑和数据通路子模块以及主机和存储器接口组成的简单CPU，如图所示。在这个CPU中，我们可以看到控制逻辑和数据通路每个只连接到指令和数据存储器接口的一部分。Chisel允许用户通过部分实现接口来实现这一点。用户首先定义到ROM和Mem的完整接口，如下：  </p>
<p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-cpu.png" alt=""></div><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isVal = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> raddr = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> rdata = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RamIo</span> <span class="keyword">extends</span> <span class="title">RomIo</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isWr = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> wdata = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在控制逻辑可以根据这些接口构建接口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CpathIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> imem = <span class="type">RomIo</span>().flip() </span><br><span class="line">	<span class="keyword">val</span> dmem = 	<span class="type">RamIo</span>().flip() </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且控制和数据通路模块可以通过部分地分配来给这个接口来构建，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpath</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">CpathIo</span>();</span><br><span class="line">	...</span><br><span class="line">	io.imem.isVal := ...;</span><br><span class="line">	 io.dmem.isVal := ...; </span><br><span class="line">	 io.dmem.isWr := ...; </span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dpath</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">DpathIo</span>(); </span><br><span class="line">	...</span><br><span class="line">	io.imem.raddr := ...; </span><br><span class="line">	io.dmem.raddr := ...; </span><br><span class="line">	io.dmem.wdata := ...;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在可以使用批量连接来连接CPU，就像使用其他bundle一样：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpu</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">CpuIo</span>()</span><br><span class="line">	<span class="keyword">val</span> c = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">CtlPath</span>()) </span><br><span class="line">	<span class="keyword">val</span> d = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">DatPath</span>()) </span><br><span class="line">	c.io.ctl &lt;&gt; d.io.ctl</span><br><span class="line">	c.io.dat &lt;&gt; d.io.dat </span><br><span class="line">	c.io.imem &lt;&gt; io.imem</span><br><span class="line">	d.io.imem &lt;&gt; io.imem</span><br><span class="line">	c.io.dmem &lt;&gt; io.dmem</span><br><span class="line">	d.io.dmem &lt;&gt; io.dmem</span><br><span class="line">	d.io.host &lt;&gt; io.host</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模块的功能创建"><a href="#模块的功能创建" class="headerlink" title="模块的功能创建"></a>模块的功能创建</h1><p>制造用于模块构造的功能接口也是有用的。例如，我们可以构建一个构造函数，它将多路复用器输入作为参数，并返回多路复用器输出：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mux2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(sel: <span class="type">UInt</span>, in0: <span class="type">UInt</span>, in1: <span class="type">UInt</span>) = &#123;</span><br><span class="line">		<span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">Mux2</span>() </span><br><span class="line">		m.io.in0 := in0 </span><br><span class="line">		m.io.in1 := in1 </span><br><span class="line">		m.io.sel := sel </span><br><span class="line">		m.io.out</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中对象Mux2在Mux2模块类中创建一个Scala单例对象，并且apply定义了创建Mux2实例的方法。有了这个Mux2创建功能，Mux4的规格现在明显更简单。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux4</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in2 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in3 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">2</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	io.out := <span class="type">Mux2</span>(io.sel(<span class="number">1</span>), <span class="type">Mux2</span>(io.sel(<span class="number">0</span>), io.in0, io.in1), <span class="type">Mux2</span>(io.sel(<span class="number">0</span>), io.in2, io.in3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel提供MuxCase，其本质上是一个n-way Mux。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MuxCase</span>(<span class="keyword">default</span>, <span class="type">Array</span>(c1 -&gt; a, c2 -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<p>其中每个条件/值在Scala数组中表示为元组，并且其中MuxCase可以转换为以下Mux表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mux</span>(c1, a, <span class="type">Mux</span>(c2, b, <span class="type">Mux</span>(..., <span class="keyword">default</span>)))</span><br></pre></td></tr></table></figure></p>
<p>Chisel还提供MuxLookup，其本质是一个n-way的可索引多路选择器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MuxLookup</span>(idx, <span class="keyword">default</span>,</span><br><span class="line">	<span class="type">Array</span>(<span class="type">UInt</span>(<span class="number">0</span>) -&gt; a, <span class="type">UInt</span>(<span class="number">1</span>) -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<p>这可以用MuxCase来重写：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MuxCase</span>(<span class="keyword">default</span>,<span class="type">Array</span>((idx === <span class="type">UInt</span>(<span class="number">0</span>)) -&gt; a,(idx === <span class="type">UInt</span>(<span class="number">1</span>)) -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<h1 id="多态性和参数化"><a href="#多态性和参数化" class="headerlink" title="多态性和参数化"></a>多态性和参数化</h1><p>Scala是一种强类型语言，使用参数化类型来指定通用函数和类。 在本节中，我们展示了Chisel用户如何使用参数化类来定义自己的可重用函数和类。  </p>
<h2 id="参数化函数"><a href="#参数化函数" class="headerlink" title="参数化函数"></a>参数化函数</h2><p>前面我们在Bool上定义了Mux2，但现在我们展示如何定义一个通用的多路复用器功能。我们使用一个布尔条件和con和alt参数（对应于then和else表达式）来定义一个T类型的函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](c: <span class="type">Bool</span>, con: <span class="type">T</span>, alt: <span class="type">T</span>): <span class="type">T</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中T需要是Bits的子类。Scala确保在Mux的每个使用中，它可以找到实际的con和alt参数类型的公共超类，否则会导致Scala编译类型错误。例如，<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Mux</span>(c, <span class="type">UInt</span>(<span class="number">10</span>), <span class="type">UInt</span>(<span class="number">11</span>))</span><br></pre></td></tr></table></figure></p>
<p>这会产生一个UInt线，因为con和alt参数都是UInt类型。<br>我们现在提出一个更高级的参数化函数的例子，用于定义一个内积FIR数字滤波器，通常用于Chisel Num。 内积FIR滤波器可以在数学上定义为：  </p>
<p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-gongshi.png" alt=""></div><br>其中x是输入，w是权重向量。在Chisel中，这可以定义为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delays</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](x: <span class="type">T</span>, n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">T</span>] =</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="type">List</span>(x) <span class="keyword">else</span> x :: <span class="type">Delays</span>(<span class="type">RegNext</span>(x), n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FIR</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span> <span class="keyword">with</span> <span class="type">Num</span>[<span class="type">T</span>]](ws: <span class="type">Seq</span>[<span class="type">T</span>], x: <span class="type">T</span>): <span class="type">T</span> = </span><br><span class="line">	(ws, <span class="type">Delays</span>(x, ws.length)).zipped.map( _ * _ ).reduce( _ + _ )</span><br></pre></td></tr></table></figure></p>
<p>其中延迟产生其输入的增量递增延迟的列表，并且reduce构造给出二进制组合器函数f的简化电路。在这种情况下，reduce创建一个求和电路。最后，FIR函数被限制为处理类型Num的输入，其中定义了Chisel乘法和加法。  </p>
<h2 id="参数化类"><a href="#参数化类" class="headerlink" title="参数化类"></a>参数化类</h2><p>与参数化函数一样，我们也可以参数化类，使它们可重用程度更高。例如，我们可以将Filter类概括为可以使用任何类型的链接。我们可以通过参数化FilterIO类和定义构造函数采取零参数类型构造函数来做到这点，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> x = <span class="class"><span class="keyword">type</span>.<span class="title">asInput</span>.<span class="title">flip</span></span></span><br><span class="line"><span class="class">	<span class="title">val</span> <span class="title">y</span> </span>= <span class="class"><span class="keyword">type</span>.<span class="title">asOutput</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在可以通过定义一个模块类来定义Filter，该模块类也接收一个链接类型构造函数参数，并将其传递给FilterIO接口构造器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>(<span class="class"><span class="keyword">type</span>)</span></span><br><span class="line"><span class="class">	...</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们现在可以定义一个基于PLant的过滤器，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>(<span class="keyword">new</span> <span class="type">PLink</span>()))</span><br></pre></td></tr></table></figure></p>
<p>其中大括号{}表示零参数函数（也称为thunk），在这种情况下创建链接类型。<br>通用FIFO可以这样定义，并使用如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBundle</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> <span class="type">A</span> = <span class="type">UInt</span>(width = <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">val</span> <span class="type">B</span> = <span class="type">UInt</span>(width = <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FifoDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>() = <span class="keyword">new</span> <span class="type">Fifo</span>(<span class="keyword">new</span> <span class="type">DataBundle</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifo</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">type: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> enq_val = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> enq_rdy = <span class="type">Bool</span>(<span class="type">OUTPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> deq_val = <span class="type">Bool</span>(<span class="type">OUTPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> deq_rdy = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> enq_dat = <span class="class"><span class="keyword">type</span>.<span class="title">asInput</span> </span></span><br><span class="line"><span class="class">		<span class="title">val</span> <span class="title">deq_dat</span> </span>= <span class="class"><span class="keyword">type</span>.<span class="title">asOutput</span></span></span><br><span class="line"><span class="class">	&#125;</span></span><br><span class="line"><span class="class">	<span class="title">val</span> <span class="title">enq_ptr</span> </span>= <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, sizeof(n)))</span><br><span class="line">	<span class="keyword">val</span> deq_ptr = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, sizeof(n)))</span><br><span class="line">	<span class="keyword">val</span> is_full = <span class="type">Reg</span>(init = <span class="type">Bool</span>(<span class="literal">false</span>))</span><br><span class="line">	<span class="keyword">val</span> do_enq  = io.enq_rdy &amp;&amp; io.enq_val</span><br><span class="line">	<span class="keyword">val</span> do_deq  = io.enq_rdy &amp;&amp; io.deq_val </span><br><span class="line">	<span class="keyword">val</span> is_empty = !is_full &amp;&amp; (enq_ptr === deq_ptr)</span><br><span class="line">	<span class="keyword">val</span> deq_ptr_inc = deq_ptr + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">val</span> enq_ptr_inc = enq_ptr + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">val</span> is_full_next = <span class="type">Mux</span>(do_enq &amp;&amp; ~do_deq &amp;&amp; (enq_ptr_inc === deq_ptr), <span class="type">Bool</span>(<span class="literal">true</span>), <span class="type">Mux</span>(do_deq &amp;&amp; is_full, <span class="type">Bool</span>(<span class="literal">false</span>), is_full)) </span><br><span class="line">	enq_ptr := <span class="type">Mux</span>(do_enq, enq_ptr_inc, enq_ptr) </span><br><span class="line">	deq_ptr := <span class="type">Mux</span>(do_deq, deq_ptr_inc, deq_ptr) </span><br><span class="line">	is_full := is_full_next</span><br><span class="line">	<span class="keyword">val</span> ram = <span class="type">Mem</span>(n) </span><br><span class="line">	when (do_enq) &#123;</span><br><span class="line">		ram(enq_ptr) := io.enq_dat </span><br><span class="line">	&#125;</span><br><span class="line">	io.enq_rdy := !is_full </span><br><span class="line">	io.deq_val := !is_empty </span><br><span class="line">	ram(deq_ptr) &lt;&gt; io.deq_dat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以定义成通用解耦接口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">data: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits = data.clone.asOutput </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以使用该模板向任何信号集添加握手：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledDemo</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">DecoupledIO</span>(<span class="params"></span>)(<span class="params"> new <span class="type">DataBundle</span> </span>)</span></span><br></pre></td></tr></table></figure></p>
<p>FIFO的接口也可以如下进行简化：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifo</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">data: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> enq = <span class="keyword">new</span> <span class="type">DecoupledIO</span>( data ).flip() </span><br><span class="line">		<span class="keyword">val</span> deq = <span class="keyword">new</span> <span class="type">DecoupledIO</span>( data )</span><br><span class="line">	&#125;</span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多时钟域"><a href="#多时钟域" class="headerlink" title="多时钟域"></a>多时钟域</h1><p>Chisel 2.0介绍了对多时钟域的支持。  </p>
<h2 id="创建时钟域"><a href="#创建时钟域" class="headerlink" title="创建时钟域"></a>创建时钟域</h2><p>为了使用多个时钟域，用户必须创建多个时钟。 在Chisel中，时钟是使用复位信号参数创建的第一级节点，定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> (<span class="params">reset: <span class="type">Bool</span></span>) <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>: <span class="type">Bool</span> <span class="comment">// returns reset pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Chisel中有一个内置的隐式时钟，状态元素默认使用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitClock = <span class="keyword">new</span> <span class="type">Clock</span>( implicitReset )</span><br></pre></td></tr></table></figure></p>
<p>状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reg</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Mem</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Module</span>(... clock: <span class="type">Clock</span> = implicitClock)</span><br></pre></td></tr></table></figure></p>
<h2 id="交叉时钟域"><a href="#交叉时钟域" class="headerlink" title="交叉时钟域"></a>交叉时钟域</h2><p>有两种方式可以定义电路在时钟域之间发送数据。第一种也是最原始的方式就是使用由两个寄存器组成的同步器电路，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signalA is in clock domain clockA,</span></span><br><span class="line"><span class="comment">// want a version in clockB as signalB</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB) </span><br><span class="line"><span class="keyword">val</span> s2 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB)</span><br><span class="line">s1 := signalA</span><br><span class="line">s2 := s1;</span><br><span class="line">signalB := s2</span><br></pre></td></tr></table></figure></p>
<p>由于亚稳性问题，该技术只限于在域之间传递一位数据。<br>在域之间发送数据的第二种和更一般的方式是通过使用异步fifo：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncFifo</span>[<span class="type">T</span>&lt;:<span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, enq_clk: <span class="type">Clock</span>, deq_clock:<span class="type">Clock</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure></p>
<p>当通过指定标准fifo参数和两个时钟，然后使用标准解耦就绪/有效信号从时钟域clockA到clockB获取一个版本的signalA时：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fifo = <span class="keyword">new</span> <span class="type">AsyncFifo</span>(<span class="type">Uint</span>(width = <span class="number">32</span>), <span class="number">2</span>, clockA, clockB)</span><br><span class="line">fifo.io..enq.bits	:= signalA</span><br><span class="line">signalB				:= fifo.io.deq.bits</span><br><span class="line">fifo.io.enq.valid	:= condA</span><br><span class="line">fifo.io.deq.ready	:= condB</span><br></pre></td></tr></table></figure></p>
<h2 id="后端特定的多个时钟域"><a href="#后端特定的多个时钟域" class="headerlink" title="后端特定的多个时钟域"></a>后端特定的多个时钟域</h2><p>每个Chisel后端需要用户以后端特定的方式设置和控制多个时钟。为了展示如何驱动一个多时钟设计，考虑这样一个硬件示例，其中两个模块使用Async-Fifo进行通信，每个模块在不同的时钟：fastClock和slowClock。  </p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>在C++后端，对于每个时钟i有：  </p>
<ul>
<li>size_t clk.len域表示时钟i的周期  </li>
<li>clock_lo_i，clock_hi_i</li>
<li>int reset() 函数，可以保证clock_lo和clock_hi的所有函数被立刻调用  </li>
<li>int clock(reset)函数，计算最小增量，调用合适的clock_lo和clock_hi，并返回使用的最小增量。  </li>
</ul>
<p>为了设置一个C++模拟器，用户需要：  </p>
<ul>
<li>将所有周期字段初始化为期望的周期  </li>
<li>将所有计数字段初始化为期望的相位  </li>
<li>调用reset</li>
<li>重复调用时钟来单步模拟  </li>
</ul>
<p>以下是slowClock / fastClock的main函数C++示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123; </span><br><span class="line">	ClkDomainTest_t dut; dut.init(<span class="number">1</span>);</span><br><span class="line">	dut.clk = <span class="number">2</span>;</span><br><span class="line">	dut.clk_cnt = <span class="number">1</span>; </span><br><span class="line">	dut.fastClock = <span class="number">4</span>; </span><br><span class="line">	dut.fastClock_cnt = <span class="number">0</span>; </span><br><span class="line">	dut.slowClock = <span class="number">6</span>; 	</span><br><span class="line">	dut.slowClock_cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++)</span><br><span class="line">	dut.reset();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i ++)</span><br><span class="line">		dut.clock(LIT&lt;<span class="number">1</span>&gt;(<span class="number">0</span>)); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h3><p>在Verilog中：  </p>
<ul>
<li>Chisel为每个时钟/复位创建一个新端口，  </li>
<li>Chisel将所有的时钟连到顶层模块  </li>
<li>用户必须要为每个时钟i创建一个always块时钟驱动  </li>
</ul>
<p>以下是驱动slowClock / fastClock电路的顶层Verilog示例：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> emulator;</span><br><span class="line">	<span class="keyword">reg</span> fastClock = <span class="number">0</span>, slowClock = <span class="number">0</span>, resetFast = <span class="number">1</span>, resetSlow = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] add, mul, test;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">2</span> fastClock = ~fastClock;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">4</span> slowClock = ~slowClock; </span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		# <span class="number">8</span></span><br><span class="line">		resetFast = <span class="number">0</span>; </span><br><span class="line">		resetSlow = <span class="number">0</span>; </span><br><span class="line">		#<span class="number">400</span></span><br><span class="line">	<span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ClkDomainTest dut (</span><br><span class="line">	<span class="variable">.fastClock</span>(fastClock), </span><br><span class="line">	<span class="variable">.slowClock</span>(slowClock), </span><br><span class="line">	<span class="variable">.io_resetFast</span>(resetFast),</span><br><span class="line">	<span class="variable">.io_resetSlow</span>(resetSlow),</span><br><span class="line">	<span class="variable">.io_add</span>(add), </span><br><span class="line">	<span class="variable">.io_mul</span>(mul), </span><br><span class="line">	<span class="variable">.io_test</span>(test));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>（完）</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>欣赏此文？求鼓励，求支持！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpeg" alt="Bao Chuquan WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="Bao Chuquan Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/硬件描述语言/" rel="tag"># 硬件描述语言</a>
          
            <a href="/tags/Chisel/" rel="tag"># Chisel</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/14/computer-boot-process/" rel="next" title="计算机那些事(2)——开机启动过程">
                <i class="fa fa-chevron-left"></i> 计算机那些事(2)——开机启动过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/18/chisel-manual/" rel="prev" title="Chisel手册">
                Chisel手册 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzk2My8xMDQ5OA=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/SlamDunk.png"
               alt="Bao Chuquan" />
          <p class="site-author-name" itemprop="name">Bao Chuquan</p>
           
              <p class="site-description motion-element" itemprop="description">积累，沉淀，吸收，转换</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">119</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/baochuquan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/baochuquan" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100008422440696" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      Facebook
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.instagram.com/baochuquan/" target="_blank" title="Instagram">
                  
                    <i class="fa fa-fw fa-instagram"></i>
                  
                    
                      Instagram
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chisel硬件表达"><span class="nav-number">2.</span> <span class="nav-text">Chisel硬件表达</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chisel数据类型"><span class="nav-number">3.</span> <span class="nav-text">Chisel数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合电路"><span class="nav-number">4.</span> <span class="nav-text">组合电路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内建操作符"><span class="nav-number">5.</span> <span class="nav-text">内建操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#位宽接口"><span class="nav-number">5.1.</span> <span class="nav-text">位宽接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#功能抽象"><span class="nav-number">6.</span> <span class="nav-text">功能抽象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bundles-amp-Vecs"><span class="nav-number">7.</span> <span class="nav-text">Bundles &amp; Vecs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#端口"><span class="nav-number">8.</span> <span class="nav-text">端口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Modules"><span class="nav-number">9.</span> <span class="nav-text">Modules</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运行和测试"><span class="nav-number">10.</span> <span class="nav-text">运行和测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#状态元素"><span class="nav-number">11.</span> <span class="nav-text">状态元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#转发声明"><span class="nav-number">11.1.</span> <span class="nav-text">转发声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件更新"><span class="nav-number">11.2.</span> <span class="nav-text">条件更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有限状态机"><span class="nav-number">11.3.</span> <span class="nav-text">有限状态机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存"><span class="nav-number">12.</span> <span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ROM"><span class="nav-number">12.1.</span> <span class="nav-text">ROM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mem"><span class="nav-number">12.2.</span> <span class="nav-text">Mem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bundle-向量"><span class="nav-number">12.3.</span> <span class="nav-text">Bundle 向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批量连接"><span class="nav-number">12.4.</span> <span class="nav-text">批量连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口视图"><span class="nav-number">12.5.</span> <span class="nav-text">接口视图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块的功能创建"><span class="nav-number">13.</span> <span class="nav-text">模块的功能创建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多态性和参数化"><span class="nav-number">14.</span> <span class="nav-text">多态性和参数化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参数化函数"><span class="nav-number">14.1.</span> <span class="nav-text">参数化函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数化类"><span class="nav-number">14.2.</span> <span class="nav-text">参数化类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多时钟域"><span class="nav-number">15.</span> <span class="nav-text">多时钟域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建时钟域"><span class="nav-number">15.1.</span> <span class="nav-text">创建时钟域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交叉时钟域"><span class="nav-number">15.2.</span> <span class="nav-text">交叉时钟域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后端特定的多个时钟域"><span class="nav-number">15.3.</span> <span class="nav-text">后端特定的多个时钟域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C"><span class="nav-number">15.3.1.</span> <span class="nav-text">C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Verilog"><span class="nav-number">15.3.2.</span> <span class="nav-text">Verilog</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bao Chuquan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>本站总访客
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


  
<div id="hexo-helper-live2d">
  <canvas id="live2dcanvas" width="150" height="300"></canvas>
</div>
<style>
  #live2dcanvas{
    position: fixed;
    width: 150px;
    height: 300px;
    opacity:0.7;
    right: 0px;
    z-index: 999;
    pointer-events: none;
    bottom: -20px;
  }
</style>
<script type="text/javascript" src="/live2d/device.min.js"></script>
<script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    document.getElementById("live2dcanvas").style.width = '75px';
    document.getElementById("live2dcanvas").style.height = '150px';
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/hijiki.model.json", 0.5);});
})();
</script>

</body>
</html>
