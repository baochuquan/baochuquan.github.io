<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/chu.icon">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/chu.icon">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chuquan.me","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="原文链接 Introduce 本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本">
<meta property="og:type" content="article">
<meta property="og:title" content="Chisel手册">
<meta property="og:url" content="http://chuquan.me/2016/12/18/chisel-manual/index.html">
<meta property="og:site_name" content="楚权的世界">
<meta property="og:description" content="原文链接 Introduce 本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-12-18T14:21:03.000Z">
<meta property="article:modified_time" content="2023-09-16T14:05:30.656Z">
<meta property="article:author" content="Bao Chuquan">
<meta property="article:tag" content="硬件描述语言">
<meta property="article:tag" content="Chisel">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://chuquan.me/2016/12/18/chisel-manual/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://chuquan.me/2016/12/18/chisel-manual/","path":"2016/12/18/chisel-manual/","title":"Chisel手册"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Chisel手册 | 楚权的世界</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?030cf08d5b27d756fa9aeecb1130fe13"></script>






<link rel="dns-prefetch" href="https://vercel.chuquan.me">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="楚权的世界" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>
  <a href="https://github.com/baochuquan"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_orange_ff7600.png?resize=149%2C149" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">楚权的世界</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Seek the wonder of life.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#introduce"><span class="nav-number">1.</span> <span class="nav-text">Introduce</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nodes"><span class="nav-number">2.</span> <span class="nav-text">Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lits"><span class="nav-number">3.</span> <span class="nav-text">Lits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ops"><span class="nav-number">4.</span> <span class="nav-text">Ops</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#types"><span class="nav-number">5.</span> <span class="nav-text">Types</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bits"><span class="nav-number">5.1.</span> <span class="nav-text">Bits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bools"><span class="nav-number">5.2.</span> <span class="nav-text">Bools</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nums"><span class="nav-number">5.3.</span> <span class="nav-text">Nums</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bundles"><span class="nav-number">5.4.</span> <span class="nav-text">Bundles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vecs"><span class="nav-number">5.5.</span> <span class="nav-text">Vecs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bit-width-inference"><span class="nav-number">5.6.</span> <span class="nav-text">Bit Width Inference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#updateables"><span class="nav-number">6.</span> <span class="nav-text">Updateables</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#forward-declaration"><span class="nav-number">7.</span> <span class="nav-text">Forward Declaration</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#regs"><span class="nav-number">8.</span> <span class="nav-text">Regs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mems"><span class="nav-number">9.</span> <span class="nav-text">Mems</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ports"><span class="nav-number">10.</span> <span class="nav-text">Ports</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#modules"><span class="nav-number">11.</span> <span class="nav-text">Modules</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#black-box"><span class="nav-number">12.</span> <span class="nav-text">Black Box</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#printf-sprintf"><span class="nav-number">13.</span> <span class="nav-text">Printf &amp; Sprintf</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assert"><span class="nav-number">14.</span> <span class="nav-text">Assert</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#main-testing"><span class="nav-number">15.</span> <span class="nav-text">Main &amp; Testing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-emulator"><span class="nav-number">16.</span> <span class="nav-text">C++ Emulator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#verilog"><span class="nav-number">17.</span> <span class="nav-text">Verilog</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#multiple-clock-domains"><span class="nav-number">18.</span> <span class="nav-text">Multiple Clock Domains</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#creating-clock-domains"><span class="nav-number">18.1.</span> <span class="nav-text">Creating Clock domains</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#crossing-clock-domains"><span class="nav-number">18.2.</span> <span class="nav-text">Crossing Clock Domains</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#backend-specific-multiple-clock-domains"><span class="nav-number">18.3.</span> <span class="nav-text">Backend Specific
Multiple Clock Domains</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c"><span class="nav-number">18.3.1.</span> <span class="nav-text">C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#verilog-1"><span class="nav-number">18.3.2.</span> <span class="nav-text">Verilog</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#extra-stuff"><span class="nav-number">19.</span> <span class="nav-text">Extra Stuff</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#standard-library"><span class="nav-number">20.</span> <span class="nav-text">Standard Library</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#math"><span class="nav-number">20.1.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sequential"><span class="nav-number">20.2.</span> <span class="nav-text">Sequential</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uint"><span class="nav-number">20.3.</span> <span class="nav-text">UInt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decoupled"><span class="nav-number">20.4.</span> <span class="nav-text">Decoupled</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bao Chuquan"
      src="/images/SlamDunk.png">
  <p class="site-author-name" itemprop="name">Bao Chuquan</p>
  <div class="site-description" itemprop="description">积累，沉淀，吸收，转换</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">349</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/baochuquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;baochuquan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:baochuquan@gmail.com" title="E-Mail → mailto:baochuquan@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/baochuquan" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;baochuquan" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Baochuquan" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Baochuquan" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2016/12/18/chisel-manual/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/SlamDunk.png">
      <meta itemprop="name" content="Bao Chuquan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="楚权的世界">
      <meta itemprop="description" content="积累，沉淀，吸收，转换">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Chisel手册 | 楚权的世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Chisel手册
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-12-18 22:21:03" itemprop="dateCreated datePublished" datetime="2016-12-18T22:21:03+08:00">2016-12-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-16 22:05:30" itemprop="dateModified" datetime="2023-09-16T22:05:30+08:00">2023-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2016/12/18/chisel-manual/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2016/12/18/chisel-manual/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><a
href="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/chisel-manual.pdf">原文链接</a></p>
<h1 id="introduce">Introduce</h1>
<p>本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本手册中，我们假设您已经了解了Scala的基础知识。如果你不熟悉Scala，我们建议你参考一本优秀的Scala书。</p>
<span id="more"></span>
<h1 id="nodes">Nodes</h1>
<p>Chisel中任何硬件设计最终都由节点对象的图表表示。Chisel中的用户代码生成此节点图，然后将其传递到Chisel后端以转换为Verilog或C
++代码。节点定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">// name assigned by user or from introspection var name: String = &quot;&quot;</span></span><br><span class="line">	<span class="comment">// incoming graph edges</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inputs</span></span>: <span class="type">ArrayBuffer</span>[<span class="type">Node</span>]</span><br><span class="line">	<span class="comment">// outgoing graph edges</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">consumers</span></span>: <span class="type">ArrayBuffer</span>[<span class="type">Node</span>]</span><br><span class="line">	<span class="comment">// node specific width inference</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inferWidth</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="comment">// get width immediately inferrable</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getWidth</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="comment">// get first raw node</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getRawNode</span></span>: <span class="type">Node</span></span><br><span class="line">	<span class="comment">// convert to raw bits</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBits</span></span>: <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// convert to raw bits</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fromBits</span></span>(x: <span class="type">Bits</span>): <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// return lit value if inferrable else null def litOf: Lit</span></span><br><span class="line">	<span class="comment">// return value of lit if litOf is non null</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">litValue</span></span>(<span class="keyword">default</span>: <span class="type">BigInt</span> = <span class="type">BigInt</span>(<span class="number">-1</span>)): <span class="type">BigInt</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点类层次结构的最高级别如图所示。基本类别是：</p>
<ul>
<li><strong>Lit</strong>: 常量或文本<br />
</li>
<li><strong>Op</strong>: 逻辑或算术操作<br />
</li>
<li><strong>Updateable</strong>: 条件更新节点<br />
</li>
<li><strong>Data</strong>: 具有类型的wire或port<br />
</li>
<li><strong>Reg</strong>: 上升沿触发的寄存器<br />
</li>
<li><strong>Mem</strong>: 存储<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-node.png" />
</div></li>
</ul>
<h1 id="lits">Lits</h1>
<p>原始文本表示为Lit节点，定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lit</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="comment">// original value</span></span><br><span class="line">	<span class="keyword">val</span> inputVal: <span class="type">BigInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始文本包含位的集合。用户不直接创建原始文本，而是使用第Type节中定义的类型构造函数。</p>
<h1 id="ops">Ops</h1>
<p>原始操作表示为如下定义的Op节点：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Op</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">// op name used during emission </span></span><br><span class="line">	<span class="keyword">val</span> op: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Ops计算其输入的组合函数。</p>
<h1 id="types">Types</h1>
表示硬件设计的Chisel图包含原始节点和类型节点。Chisel类型系统与底层Scala类型系统分开维护，因此类型节点散布在原始节点之间，以允许Chisel检查并响应Chisel类型。Chisel类型节点在硬件设计转换为C
++或Verilog之前被擦除。getRawNode运算符定义在基本Node类中，跳过类型节点并返回找到的第一个原始节点。下图显示了内置的Chisel类型层次结构，其中Data为最顶层节点。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-type.png" />
</div>
<p>内置标量类型包括Bool，SInt和UInt和内置聚合类型Bundle和Vec允许用户使用其他类型的集合扩展Chisel数据类型集。<br />
Data自身就是一个节点：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cloneType</span></span>(): <span class="keyword">this</span>.<span class="keyword">type</span> =</span><br><span class="line">		<span class="keyword">this</span>.getClass.newInstance.asInstanceOf[<span class="keyword">this</span>.<span class="keyword">type</span>]</span><br><span class="line">	<span class="comment">// simple conversions</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toSInt</span></span>: <span class="type">SInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toUInt</span></span>: <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBool</span></span>: <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBits</span></span>: <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// flatten out to leaves of tree </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Data</span>)] </span><br><span class="line">	<span class="comment">// port direction if leaf</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dir</span></span>: <span class="type">PortDir</span></span><br><span class="line">	<span class="comment">// change dir to OUTPUT </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asOutput</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span> </span><br><span class="line">	<span class="comment">// change dir to INPUT </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asInput</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// change polarity of dir </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">flip</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// assign to input</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>:=[<span class="type">T</span> &lt;: <span class="type">Data</span>](t: <span class="type">T</span>) </span><br><span class="line">	<span class="comment">// bulk assign to input </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;&gt;</span></span>(t: <span class="type">Data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Data类具有用于在类型之间转换和将端口方法委托给其单个输入的方法。我们将在Port一节讨论端口。最后，用户可以在其自己的类型节点（例如bundle）中覆盖cloneType方法，以便反映克隆所需的构造参数。<br />
Data节点可以用于四种目的：</p>
<ul>
<li><strong>types</strong>: UInt(width = 8),
在指定最小位宽的图中记录中间类型（在本节中描述）<br />
</li>
<li><strong>wires</strong>: UInt(width = 8),
作为数据的前向声明，允许将来的条件更新（在Updateable一节中描述）<br />
</li>
<li><strong>ports</strong>: UInt(dir = OUTPUT, width = 8),
定义模块接口的专用线，还能指定方向（在Ports一节中描述）<br />
</li>
<li><strong>literals</strong>: UInt(1) 或 UInt(1, 8),
可以使类型对象构造函数来构造其值和可选宽度。</li>
</ul>
<h2 id="bits">Bits</h2>
<p>在Chisel中，位的原始集合如下Bits类型定义所示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bits</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// create literal from BigInt or Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// create literal from String using</span></span><br><span class="line">	<span class="comment">// base_char digit+ string format</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bits</span> <span class="keyword">extends</span> <span class="title">Data</span> <span class="keyword">with</span> <span class="title">Updateable</span> </span>&#123; </span><br><span class="line">	<span class="comment">// bitwise-not</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_~</span></span>(): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// bitwise-and</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// bitwise-or</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">|</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// bitwise-xor</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">^</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// and-reduction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">andR</span></span>(): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// or-reduction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">orR</span></span>(): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// xor-reduction def xorR(): Bool </span></span><br><span class="line">	<span class="comment">// logical NOT</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span></span>(): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical AND</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;&amp;</span> </span>(b: <span class="type">Bool</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical OR</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">||</span> </span>(b: <span class="type">Bool</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// equality</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">===</span></span>(b: <span class="type">Bits</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// inequality</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">!=</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical left shift </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;&lt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// logical right shift </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// concatenate</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">##</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// extract single bit, LSB is 0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// extract bit field from end to start bit pos </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(hi: <span class="type">Int</span>, lo: <span class="type">Int</span>): <span class="type">Bits</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cat</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elt: <span class="type">T</span>, elts: <span class="type">T</span>*): <span class="type">Bits</span></span><br></pre></td></tr></table></figure></p>
<p>Bits具有用于简单位操作的方法。注意，##是二进制连接，而Cat是一个正则拼接。为了避免与Scala的内置==冲突，Chisel的按位比较命名为===。<br />
使用Fill可以创建n位宽的域：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fill</span></span>(n: <span class="type">Int</span>, field: <span class="type">Bits</span>): <span class="type">Bits</span></span><br></pre></td></tr></table></figure></p>
<p>一个两输入的选择器可以使用Mux：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Bits</span>, cons: <span class="type">T</span>, alt: <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure></p>
<p>常量或字面值使用Scala整数或传递给构造函数的字符串表示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;ha&quot;</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;o12&quot;</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;b1010&quot;</span>) <span class="comment">// binary 4-bit lit from string.</span></span><br></pre></td></tr></table></figure></p>
如下图所示的最左边子图，可以产生Lit。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-op-lit-graph.png" />
</div>
<p>操作返回一个实际的操作符节点和类型节点组合成输入类型节点。参见上图，了解更复杂的例子。</p>
<h2 id="bools">Bools</h2>
<p>布尔值用Bools表示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">Boolean</span>): <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bool</span> <span class="keyword">extends</span> <span class="title">UInt</span></span></span><br></pre></td></tr></table></figure></p>
<p>Bool与UInt(width = 1)相等。</p>
<h2 id="nums">Nums</h2>
<p>Num是一个类型节点，定义了算术运算：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span> <span class="keyword">extends</span> <span class="title">Bits</span> </span>&#123; </span><br><span class="line">	<span class="comment">// Negation</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_-</span></span>(): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// Addition</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Subtraction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">-</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Multiplication </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Greater than</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// Less than</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// Less than or equal </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// Greater than or equal </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有符号和无符号整数被认为是定点数的子集，并且分别由类型SInt和UInt表示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span></span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SInt</span> <span class="keyword">extends</span> <span class="title">Num</span> <span class="title">object</span> <span class="title">UInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UInt</span> <span class="keyword">extends</span> <span class="title">Num</span> </span>&#123;</span><br><span class="line">	<span class="comment">// arithmetic right shift override </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">SInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 带符号的定点数（包括整数）使用二进制补码格式表示。</p>
<h2 id="bundles">Bundles</h2>
<p>Bundle将几种不同类型的命名字段组合成一个连续单元，非常像C中的struct：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="comment">// shallow named bundle elements</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">elements</span></span>: <span class="type">ArrayBuffer</span>[(<span class="type">String</span>, <span class="type">Data</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用elements方法可以获取Bundle中每个元素的名称和类型，flatten方法返回嵌套聚合的叶子处的元素。
用户可以通过对bundle进行子类化来定义新的bundle，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFloat</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> sign = <span class="type">Bool</span>()</span><br><span class="line">	<span class="keyword">val</span> exponent = <span class="type">UInt</span>(width = <span class="number">8</span>) </span><br><span class="line">	<span class="keyword">val</span> significand = <span class="type">UInt</span>(width = <span class="number">23</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素通过Scala字段访问：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">MyFloat</span>() </span><br><span class="line"><span class="keyword">val</span> xs = x.sign</span><br></pre></td></tr></table></figure></p>
<p>当使用C++或Verilog后端发送时，bundle的元素的名称是从它们的bundle字段名获取的，使用Scala内省。</p>
<h2 id="vecs">Vecs</h2>
<p>Vecs可以创建可索引元素向量：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Vec</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elts: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">Vec</span>[<span class="type">T</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elt0: <span class="type">T</span>, elts: <span class="type">T</span>*): <span class="type">Vec</span>[<span class="type">T</span>] </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fill</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n: <span class="type">Int</span>)	(gen: =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">T</span>] </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tabulate</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n: <span class="type">Int</span>)(gen: (<span class="type">Int</span>) =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">T</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tabulate</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n1: <span class="type">Int</span>, n2: <span class="type">Int</span>) (gen: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">Vec</span>[<span class="type">T</span>]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">n: <span class="type">Int</span>, val gen: (</span>) <span class="title">=&gt;</span> <span class="title">T</span>) <span class="keyword">extends</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">Int</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">forall</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](x: <span class="type">T</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">indexWhere</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastIndexWhere</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中n个元素类型由gen定义。用户可以使用Int索引静态访问元素或使用UInt索引动态访问元素，其中动态访问创建一个虚拟类型节点（表示读取“端口”），该节点使用给定地址记录读取。在任一情况下，用户可以连线到读取的结果如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v(a) := d</span><br></pre></td></tr></table></figure></p>
<p>只读存储器可以使用Vecs来表示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rom = <span class="type">Vec</span>(<span class="type">UInt</span>(<span class="number">3</span>), <span class="type">UInt</span>(<span class="number">7</span>), <span class="type">UInt</span>(<span class="number">4</span>), <span class="type">UInt</span>(<span class="number">0</span>)) &#123; <span class="type">UInt</span>(width=<span class="number">3</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> dout = rom(addr)</span><br></pre></td></tr></table></figure></p>
<h2 id="bit-width-inference">Bit Width Inference</h2>
用户需要设置端口和寄存器的位宽度，否则节点上的位宽度会自动推断，除非用户手动设置（使用Extract或Cat）。位宽推理引擎从图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png" />
</div>
<p>其中例如wz是线z的位宽度，并且＆规则应用于所有按位逻辑运算。</p>
<p>位宽推理过程继续，直到没有位宽改变。除了固定位数的右移之外，位宽度推断规则规定输出位宽不能小于输入位宽度，因此，输出位宽度增长或保持相同。此外，寄存器的宽度必须由用户明确地或从复位值的位宽指定。从这两个要求，我们可以知道位宽推理过程将收敛到一个固定点。</p>
<h1 id="updateables">Updateables</h1>
<p>当描述线和状态节点的操作时，将规范作为输出值的一系列条件更新并且跨多个单独的语句分布这些更新通常是有用的。例如，可以立即引用数据节点的输出，但可以稍后设置其输入。可更新表示一个条件可更新节点，其累积对节点的访问，并且其稍后可以生成多路复用器以在电路中组合这些访问。<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Updateable</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="comment">// conditional reads</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reads</span></span>: <span class="type">Queue</span>[(<span class="type">Bool</span>, <span class="type">UInt</span>)]</span><br><span class="line">	<span class="comment">// conditional writes</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">writes</span></span>: <span class="type">Queue</span>[(<span class="type">Bool</span>, <span class="type">UInt</span>, <span class="type">Node</span>)]</span><br><span class="line">	<span class="comment">// gen mux integrating all conditional writes </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">genMuxes</span></span>(<span class="keyword">default</span>: <span class="type">Node</span>)</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> </span>:= (x: <span class="type">Node</span>): <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">when</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(cond: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>): when</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">when</span> (<span class="params">prevCond: <span class="type">Bool</span></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">elsewhen</span> </span>(cond: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>): when </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">otherwise</span> </span>(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>when操作具有动态作用域的全局条件堆栈。因此，when创建一个在条件函数调用中有效的新条件。例如：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateWhen</span> </span>(c: <span class="type">Bool</span>, d: <span class="type">Data</span>) = </span><br><span class="line">	when (c) &#123; r := d &#125;</span><br><span class="line">when (a) &#123; </span><br><span class="line">	updateWhen(b, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (a) &#123;</span><br><span class="line">	when (b) &#123; r := x &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel为其他常见形式的条件更新提供了一些语法糖：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unless</span></span>(c: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>) = </span><br><span class="line">	when (!c) &#123; block )</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">otherwise</span></span>(block: =&gt; <span class="type">Unit</span>) = </span><br><span class="line">	when (<span class="type">Bool</span>(<span class="literal">true</span>)) &#123; block &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再介绍用于条件更新的switch语句，其涉及对一个公共密钥的一系列比较：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch</span></span>(c: <span class="type">UInt</span>)(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is</span></span>(v: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="forward-declaration">Forward Declaration</h1>
<p>纯组合电路不允许在节点之间有循环，如果检测到这样的循环，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建法向组合电路，通过添加其输入从已经定义的节点导出的新节点。
时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前参考输出线。因为Scala按顺序执行程序语句，所以我们允许数据节点用作提供节点声明的线，可：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pcPlus4 = <span class="type">UInt</span>() </span><br><span class="line"><span class="keyword">val</span> brTarget = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> pcNext	= <span class="type">Mux</span>(pcSel, brTarget, pcPlus4)</span><br><span class="line"><span class="keyword">val</span> pcReg	= <span class="type">RegUpdate</span>(pcNext)</span><br><span class="line">pcPlus4  := pcReg + <span class="type">UInt</span>(<span class="number">4</span>)</span><br><span class="line">... </span><br><span class="line">brTarget := addOut</span><br></pre></td></tr></table></figure></p>
<p>接线操作符：=用于在pcReg和addOut定义之后进行连接。在所有赋值完成后，如果前向声明未分配，则是一个错误。...</p>
<h1 id="regs">Regs</h1>
<p>Chisel支持的状态元素的最简单形式是一个正边沿触发寄存器，定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Reg</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (data: <span class="type">T</span>, next: <span class="type">T</span> = <span class="literal">null</span>, init: <span class="type">T</span> = <span class="literal">null</span>): <span class="type">T</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RegNext</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (next: <span class="type">T</span>, init: <span class="type">T</span> = <span class="literal">null</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RegInit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (init: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reg</span> <span class="keyword">extends</span> <span class="title">Updateable</span></span></span><br></pre></td></tr></table></figure> 可以如下进行构造：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r1 = <span class="type">RegUpdate</span>(io.in)</span><br><span class="line"><span class="keyword">val</span> r2 = <span class="type">RegReset</span>(<span class="type">UInt</span>(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> r3 = <span class="type">RegUpdate</span>(io.in, <span class="type">UInt</span>(<span class="number">1</span>)) </span><br><span class="line"><span class="keyword">val</span> r4 = <span class="type">Reg</span>(<span class="type">UInt</span>(width = <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p>
<p>其中resetVal是reset为ture时用于寄存器的值。</p>
<h1 id="mems">Mems</h1>
<p>Chisel通过Mem结构支持随机存取存储器。写入Mem是正边沿触发，读取是组合或正边沿触发。<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](depth: <span class="type">Int</span>, gen: =&gt; <span class="type">T</span>, seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: (</span>) <span class="title">=&gt;</span> <span class="title">T</span>, <span class="title">depth</span></span>: <span class="type">Int</span>, seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">extends</span> <span class="type">Updateable</span> &#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过应用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32个条目的寄存器文件可以表示如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rf = <span class="type">Mem</span>(<span class="number">32</span>, <span class="type">UInt</span>(width = <span class="number">64</span>)) </span><br><span class="line">when (wen) &#123; rf(waddr) := wdata &#125; </span><br><span class="line"><span class="keyword">val</span> dout1 = rf(waddr1)</span><br><span class="line"><span class="keyword">val</span> dout2 = rf(waddr2)</span><br></pre></td></tr></table></figure></p>
<p>如果设置了可选参数seqRead，当Reg分配了Mem的输出时，Chisel将尝试推断顺序读端口。单读，单写SRAM可以描述如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1r1w = <span class="type">Mem</span>(<span class="number">1024</span>, <span class="type">UInt</span>(width = <span class="number">32</span>), seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> dout = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1r1w(waddr) := wdata &#125; </span><br><span class="line">when (ren) &#123; dout := ram1r1w(raddr) &#125;</span><br></pre></td></tr></table></figure></p>
<p>单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1p =</span><br><span class="line"><span class="type">Mem</span>(<span class="number">1024</span>, <span class="type">UInt</span>(width = <span class="number">32</span>), seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> dout = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1p(waddr) := wdata &#125; </span><br><span class="line">.elsewhen (ren) &#123; dout := ram1p(raddr) &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据是实现定义的。<br />
Mem还支持子字写入的写掩码。如果相应的屏蔽位置1，则写入给定位。<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ram = <span class="type">Mem</span>(<span class="number">256</span>, <span class="type">UInt</span>(width = <span class="number">32</span>))</span><br><span class="line">when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ports">Ports</h1>
<p>端口是用作硬件模块接口的Data派生节点。端口是原始Data对象的定向版本。端口方向定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PortDir</span></span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">INPUT</span> <span class="keyword">extends</span> <span class="title">PortDir</span> </span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OUTPUT</span> <span class="keyword">extends</span> <span class="title">PortDir</span></span></span><br></pre></td></tr></table></figure></p>
<p>聚合端口可以使用vec或bundle的实例作为叶子递归构造。</p>
<h1 id="modules">Modules</h1>
<p>在Chisel中，module与Verilog中的module非常相似，在生成电路中定义了层次结构。分层模块命名空间可在下游工具中访问，以帮助调试和物理布局。用户定义的模块被定义为一个类：<br />
- 继承自Module<br />
- 包含一个接口Bundle，其存储在一个名为io的域中<br />
- 在其构造器中将子电路连接起来</p>
<p>用户通过子类化Module来编写自己的模块，其定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io: <span class="type">Bundle</span></span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compileV</span></span>: <span class="type">Unit</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compileC</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并定义自己的io字段。例如，要定义一个两输入多路复用器，我们将定义一个模块如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>:=赋值运算符，在模块定义的主体中使用，是Chisel中的一个特殊运算符，它将左侧的输入连接到右侧的输出。它通常用于将输出端口连接到其定义。</p>
<p>&lt;&gt;操作符批量连接父对象模型之间的对等相反接口或父/子模块之间相同的接口。批量连接使用路径名匹配连接叶子端口。仅当其中一个端口非空时允许连接，从而允许用户重复地批量连接部分填充的接口。在所有连接完成并且电路正在精心设计后，Chisel警告用户端口是否只有一个到它们的连接。</p>
<p>当使用C++或Verilog后端发送时，存储在模块中的节点和子模块的名称可以使用Scala内省从它们的模块字段名称中获取。使用函数setName()设置节点或子模块的名称。</p>
<h1 id="black-box">Black Box</h1>
<p>黑盒允许用户定义接口到Chisel之外定义的电路。用户定义：</p>
<ul>
<li>一个BlackBox子类的模块<br />
</li>
<li>一个带有接口的io<br />
</li>
<li>可选的VerilogParameters子类</li>
</ul>
<p>例如，可以将简单的ROM黑盒定义为：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isVal = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> raddr = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> rdata = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">32</span>) </span><br><span class="line">	raddr.setName(<span class="string">&quot;RADDR&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomParams</span> <span class="keyword">extends</span> <span class="title">VerilogParameters</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> <span class="type">MY_STR</span> = <span class="string">&quot;Test&quot;</span></span><br><span class="line">	<span class="keyword">val</span> <span class="type">MY_INT</span> = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rom</span> <span class="keyword">extends</span> <span class="title">BlackBox</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">RomIo</span>()</span><br><span class="line">	<span class="keyword">val</span> romParams = <span class="keyword">new</span> <span class="type">RomParams</span>() </span><br><span class="line">	setVerilogParameters(romParams) 	</span><br><span class="line">	renameClock(<span class="type">Driver</span>.implicitClock, <span class="string">&quot;clock_A&quot;</span>)</span><br><span class="line">	renameClock(<span class="string">&quot;my_other_clock&quot;</span>, <span class="string">&quot;test_clock&quot;</span>) </span><br><span class="line">	renameReset(<span class="string">&quot;rst&quot;</span>)</span><br><span class="line">	<span class="comment">// Define how to use in simulation here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数将转换为verilog参数，其中包含类定义中使用的名称和值。setVerilogParameters也可以直接接受一个字符串。函数renameClock可以获取Clock对象或时钟的字符串名称来重命名BlackBox输出时钟。函数renameReset将重命名隐式重置。如果需要命名其他重置，请调用setName()。在io类中显示了使用setName()的示例。而不是被称为io_raddr为黑箱的io，它将是RADDR。黑盒在c模拟中作为一个模块。这意味着您可以使用io实现BlackBox的功能，以便您可以验证您的设计。</p>
<h1 id="printf-sprintf">Printf &amp; Sprintf</h1>
<p>Chisel提供了为调试目的格式化和打印字符串的能力。printf和sprintf结构与它们的C名称类似：它们取一个格式字符串和可变数量的参数，然后分别打印或返回一个字符串。在模拟期间，printf在上升时钟沿将控制字符串打印到控制台。另一方面，sprintf返回格式化的字符串作为位向量。</p>
<p>支持的格式说明符是％b（二进制数），％d（十进制数），％x（十六进制数）和％s（由8位扩展ASCII字符序列组成的字符串）。%%指定文字％。）与C不同，没有宽度修饰符：相应参数的位宽决定了字符串表示中的宽度。</p>
<p>以下示例在c为true时打印“0x4142 16706 AB”行：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Bits</span>(<span class="number">0x4142</span>)</span><br><span class="line"><span class="keyword">val</span> s1 = sprintf(<span class="string">&quot;%x %s&quot;</span>, x, x);</span><br><span class="line">when (c) &#123; printf(<span class="string">&quot;%d %s\n&quot;</span>, x, s1); &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="assert">Assert</h1>
<p>运行时断言由assert结构提供。在仿真期间，如果断言的论点在上升时钟边沿为false，则会打印错误并终止仿真。例如，以下将在十个时钟周期后终止仿真：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">4</span>)) </span><br><span class="line">x := x + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">assert(x &lt; <span class="type">UInt</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="main-testing">Main &amp; Testing</h1>
<p>为了构造一个电路，用户从它们的顶层main函数调用chiselMain：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>): <span class="type">T</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行以上对象会在--targetDir
dir_name参数指定的目录下生成module_name.cpp和module_name.h C++文件。</p>
<p>测试是电路设计的一个关键部分，因此在Chisel中，我们提供了一种测试电路的机制，通过使用Tester类的子类在Scala中提供测试向量：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>[<span class="type">T</span> &lt;: <span class="type">Module</span>] (<span class="params">val c: <span class="type">T</span>, val isTrace: <span class="type">Boolean</span> = true</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> ok: <span class="type">Boolean</span></span><br><span class="line">	<span class="keyword">val</span> rnd: <span class="type">Random</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Boolean</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Int</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(n: <span class="type">Int</span> = <span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pokeAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>, x: <span class="type">BigInt</span>) </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Bits</span>, x: <span class="type">BigInt</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Aggregate</span>, x: <span class="type">Array</span>[<span class="type">BigInt</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peekAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Aggregate</span>): <span class="type">Array</span>[<span class="type">BigInt</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(good: <span class="type">Boolean</span>, msg: <span class="type">String</span>): <span class="type">Boolean</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(data: <span class="type">Bits</span>, target: <span class="type">BigInt</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户利用：<br />
- <strong>poke</strong>: 设置端口和状态值<br />
- <strong>step</strong>: 以一个时间单位执行电路<br />
- <strong>peek</strong>: 读端口和状态值<br />
- <strong>expect</strong>: 比较测试电路的值和预期的值</p>
<p>用户通过如下方式连接tester实例和模块：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMainTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>)( </span><br><span class="line">		tester: <span class="type">T</span> =&gt; <span class="type">Tester</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
当--test作为chiselMain的参数时，tester实例在单独的进程中运行被测设计（DUT），stdin和stdout连接，以便调试命令可以发送到DUT，并且响应可以从DUT如图所示。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png" />
</div>
<p>如下所示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2Tests</span>(<span class="params">c: <span class="type">Mux2</span></span>) <span class="keyword">extends</span> <span class="title">Tester</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> n = pow(<span class="number">2</span>, <span class="number">3</span>).toInt</span><br><span class="line">	<span class="keyword">for</span> (s &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i0 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123; </span><br><span class="line">			<span class="keyword">for</span> (i1 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">				poke(c.io.sel, s)</span><br><span class="line">				poke(c.io.in1, i1)</span><br><span class="line">				poke(c.io.in0, i0)</span><br><span class="line">				step(<span class="number">1</span>)</span><br><span class="line">				expect(c.io.out, (<span class="keyword">if</span> (s == <span class="number">1</span>) i1 <span class="keyword">else</span> i0))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用poke将Mux2的每个输入的分配设置为适当的值。对于这个特定的例子，我们通过将输入硬编码到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块的适当输入，并告诉模拟将这些值分配给我们正在测试的器件的输入c，步骤电路和测试期望值。最后，下面显示了如何调用测试器：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chiselMainTest(args + <span class="string">&quot;--test&quot;</span>, () =&gt; <span class="keyword">new</span> <span class="type">Mux2</span>())&#123; </span><br><span class="line">	c =&gt; <span class="keyword">new</span> <span class="type">Mux2Tests</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，chiselMain*有以下命令参数：<br />
&gt; --targetDir 目标路径前缀<br />
&gt; --genHarness 生成C++文件 &gt; --debug 把所有wire放入C++类文件中
&gt; --compile 编译生成的C++ &gt; --test 使用C++应用运行测试 &gt;
--backend v 产生verilog &gt; --backend c 产生C++（默认） &gt; --vcd
使能vcd打印</p>
<h1 id="c-emulator">C++ Emulator</h1>
<p>C ++仿真器基于使用C ++模板的快速多字库。
单个字由val_t定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef uint64_t val_t; </span><br><span class="line">typedef int64_t sval_t; </span><br><span class="line">typedef uint32_t half_val_t;</span><br></pre></td></tr></table></figure></p>
<p>多字由dat_t定义，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int w&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dat_t</span> </span>&#123;</span><br><span class="line">	public:</span><br><span class="line">		const static int n_words;</span><br><span class="line">		<span class="keyword">inline</span> int width ( void );</span><br><span class="line">		<span class="keyword">inline</span> int n_words_of ( void );</span><br><span class="line">		<span class="keyword">inline</span> bool to_bool ( void );</span><br><span class="line">		<span class="keyword">inline</span> val_t lo_word ( void );</span><br><span class="line">		<span class="keyword">inline</span> unsigned long to_ulong ( void ); </span><br><span class="line">		std::string to_str ();</span><br><span class="line">		dat_t&lt;w&gt; ();</span><br><span class="line">template &lt;int sw&gt;</span><br><span class="line">	dat_t&lt;w&gt; (const dat_t&lt;sw&gt;&amp; src); </span><br><span class="line">	dat_t&lt;w&gt; (const dat_t&lt;w&gt;&amp; src); </span><br><span class="line">	dat_t&lt;w&gt; (val_t <span class="keyword">val</span>);</span><br><span class="line">template &lt;int sw&gt;</span><br><span class="line">	dat_t&lt;w&gt; mask(dat_t&lt;sw&gt; fill, int n);</span><br><span class="line">template &lt;int dw&gt; </span><br><span class="line">	dat_t&lt;dw&gt; mask(int n);</span><br><span class="line">template &lt;int n&gt;</span><br><span class="line">	dat_t&lt;n&gt; mask(void);</span><br><span class="line">	dat_t&lt;w&gt; operator + ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator - ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator - ( );</span><br><span class="line">	dat_t&lt;w+w&gt; operator * ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; fix_times_fix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; ufix_times_fix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; fix_times_ufix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &lt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &gt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &gt;= ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &lt;= ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; gt ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; gte ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; lt ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; lte ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;w&gt; operator ^ ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &amp; ( dat_t&lt;w&gt; o );	</span><br><span class="line">	dat_t&lt;w&gt; operator | ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator ~ ( void);</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator ! ( void );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &amp;&amp; ( dat_t&lt;<span class="number">1</span>&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator || ( dat_t&lt;<span class="number">1</span>&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator == ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator == ( datz_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator != ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &lt;&lt; ( int amount ); </span><br><span class="line">	dat_t&lt;w&gt; operator &lt;&lt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &gt;&gt; ( int amount ); </span><br><span class="line">	dat_t&lt;w&gt; operator &gt;&gt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; rsha ( dat_t&lt;w&gt; o); </span><br><span class="line">	dat_t&lt;w&gt;&amp; operator = ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; fill_bit(val_t bit); </span><br><span class="line">	dat_t&lt;w&gt; fill_byte(val_t byte, int nb, int n);</span><br><span class="line">template &lt;int dw, int n&gt;</span><br><span class="line">	dat_t&lt;dw&gt; fill( void );</span><br><span class="line">template &lt;int dw, int nw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; fill( dat_t&lt;nw&gt; n );</span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(); </span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(val_t e, val_t s); </span><br><span class="line">template &lt;int dw, int iwe, int iws&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s);</span><br><span class="line">template &lt;int sw&gt; </span><br><span class="line">	dat_t&lt;w&gt; inject(dat_t&lt;sw&gt; src, val_t e, val_t s); </span><br><span class="line">template &lt;int sw, int iwe, int iws&gt;</span><br><span class="line">	dat_t&lt;w&gt; inject (dat_t&lt;sw&gt; src, dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s); </span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; log2(); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; bit(val_t b); </span><br><span class="line">	val_t msb();</span><br><span class="line">template &lt;int iw&gt;</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; bit(dat_t&lt;iw&gt; b)</span><br><span class="line">&#125;</span><br><span class="line">template &lt;int w, int sw&gt; </span><br><span class="line">	dat_t&lt;w&gt; <span class="type">DAT</span>(dat_t&lt;sw&gt; dat);</span><br><span class="line">template &lt;int w&gt;</span><br><span class="line">	dat_t&lt;w&gt; <span class="type">LIT</span>(val_t value);</span><br><span class="line">template &lt;int w&gt; dat_t&lt;w&gt;</span><br><span class="line">	mux ( dat_t&lt;<span class="number">1</span>&gt; t, dat_t&lt;w&gt; c, dat_t&lt;w&gt; a )</span><br></pre></td></tr></table></figure></p>
<p>其中w是位宽参数。</p>
<p>Chisel编译器将顶层模块编译为可以创建和执行的单个扁平的mod_t类：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mod_t</span> </span>&#123; </span><br><span class="line">	public:</span><br><span class="line">		<span class="comment">// initialize module</span></span><br><span class="line">		virtual void init (void) &#123; &#125;;</span><br><span class="line">		<span class="comment">// compute all combinational logic</span></span><br><span class="line">		virtual void clock_lo (dat_t&lt;<span class="number">1</span>&gt; reset) &#123; &#125;; </span><br><span class="line">		<span class="comment">// commit state updates</span></span><br><span class="line">		virtual void clock_hi (dat_t&lt;<span class="number">1</span>&gt; reset) &#123; &#125;; </span><br><span class="line">		<span class="comment">// print printer specd node values to stdout </span></span><br><span class="line">		virtual void print (<span class="type">FILE</span>* f) &#123; &#125;;</span><br><span class="line">		<span class="comment">// scan scanner specd node values from stdin </span></span><br><span class="line">		virtual bool scan (<span class="type">FILE</span>* f) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;; </span><br><span class="line">		<span class="comment">// dump vcd file</span></span><br><span class="line">		virtual void dump (<span class="type">FILE</span>* f, int t) &#123; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Chisel编译器可以创建一个线束，或者用户可以自己写一个线束。以下是CPU模块的线束示例：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;cpu.h&quot;</span></span><br><span class="line">int main (int argc, char* argv[]) &#123;</span><br><span class="line">	cpu_t* c = <span class="keyword">new</span> cpu_t();</span><br><span class="line">	int lim = (argc &gt; <span class="number">1</span>) ? atoi(argv[<span class="number">1</span>]) : <span class="number">-1</span>; </span><br><span class="line">	c-&gt;init();</span><br><span class="line">	<span class="keyword">for</span> (int t = <span class="number">0</span>; lim &lt; <span class="number">0</span> || t &lt; lim; t++) &#123;</span><br><span class="line">		dat_t&lt;<span class="number">1</span>&gt; reset = <span class="type">LIT</span>&lt;<span class="number">1</span>&gt;(t == <span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span> (!c-&gt;scan(stdin)) <span class="keyword">break</span>; </span><br><span class="line">		c-&gt;clock_lo(reset); </span><br><span class="line">		c-&gt;clock_hi(reset); </span><br><span class="line">		c-&gt;print(stdout);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="verilog">Verilog</h1>
<p>当-v参数传递到chiselMain时，Chisel生成Verilog。
例如，从SBT，以下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run --v</span><br></pre></td></tr></table></figure></p>
<p>将在目标目录中生成名为module-name.v的单个Verilog文件。该文件将包含一个模块，每个模块定义为在chiselMain中创建的顶层模块的子模块。具有相同接口和主体的模块将被缓存和重用。</p>
<h1 id="multiple-clock-domains">Multiple Clock Domains</h1>
<h2 id="creating-clock-domains">Creating Clock domains</h2>
<p>为了使用多个时钟域，用户必须创建多个时钟。在Chisel中，时钟是用复位信号参数创建的一级节点，并定义如下：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> (<span class="params">reset: <span class="type">Bool</span></span>) <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>: <span class="type">Bool</span> <span class="comment">// returns reset pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Chisel中有一个内置的隐式时钟，状态元素默认使用：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitClock = <span class="keyword">new</span> <span class="type">Clock</span>( implicitReset )</span><br></pre></td></tr></table></figure></p>
<p>状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Reg</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Mem</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Module</span>(... clock: <span class="type">Clock</span> = implicitClock)</span><br></pre></td></tr></table></figure></p>
<h2 id="crossing-clock-domains">Crossing Clock Domains</h2>
<p>有两种方式可以定义电路在时钟域之间发送数据。第一种和最原始的方式是使用由两个寄存器组成的同步电路，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signalA is in clock domain clockA,</span></span><br><span class="line"><span class="comment">// want a version in clockB as signalB</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB) </span><br><span class="line"><span class="keyword">val</span> s2 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB)</span><br><span class="line">s1 := signalA</span><br><span class="line">s2 := s1;</span><br><span class="line">signalB := s2</span><br></pre></td></tr></table></figure></p>
<p>由于亚稳性问题，该技术限于在域之间传递一位数据。</p>
<p>在域之间发送数据的第二种更一般的方式是通过使用异步fifo：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncFifo</span>[<span class="type">T</span>&lt;:<span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, enq_clk: <span class="type">Clock</span>, deq_clock: <span class="type">Clock</span></span>)</span></span><br><span class="line">	<span class="keyword">extends</span> <span class="type">Module</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以通过指定标准fifo参数和两个时钟，然后使用标准去耦就绪/有效信号，从时钟频率A到时钟B获得一个版本的signalA：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fifo = <span class="keyword">new</span> <span class="type">AsyncFifo</span>(<span class="type">Uint</span>(width = <span class="number">32</span>), <span class="number">2</span>, clockA, clockB)</span><br><span class="line">fifo.io.enq.bits := signalA</span><br><span class="line">signalB := fifo.io.deq.bits </span><br><span class="line">fifo.io.enq.valid := condA </span><br><span class="line">fifo.io.deq.ready := condB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="backend-specific-multiple-clock-domains">Backend Specific
Multiple Clock Domains</h2>
<p>时钟域可以以域特定的方式映射到C++和Verilog后端。为了展示如何驱动多时钟设计，考虑硬件示例，其中两个模块使用AsyncFifo进行通信，每个模块在不同的时钟：fastClock和slowClock。</p>
<h3 id="c">C++</h3>
<p>在C ++后端，对于每个时钟i，有一个：<br />
- uint64_t clk_i域表示时钟i的周期<br />
- uint63_t clk_i_cnt域表示时钟i当前计数<br />
- clock_lo_i和clock_hi_i<br />
- int reset()函数，其保证了所有的clock_lo和clock_hi函数被立即调用<br />
- int
clock(reset)函数，其计算最小增量，调用适当的clock_lo和clock_hi，并返回使用的最小增量。</p>
<p>为了建立C++模拟，用户需要：<br />
- 将所有周期字段初始化为所需周期<br />
- 将所有计数字段初始化为期望的相位<br />
- 调用reset<br />
- 重复调用时钟逐步模拟</p>
<p>以下是slowClock / fastClock的main函数C++示例：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123; </span><br><span class="line">	<span class="type">ClkDomainTest_t</span> dut; dut.init(<span class="number">1</span>);</span><br><span class="line">	dut.clk = <span class="number">2</span>;</span><br><span class="line">	dut.clk_cnt = <span class="number">1</span>; </span><br><span class="line">	dut.fastClock = <span class="number">4</span>; </span><br><span class="line">	dut.fastClock_cnt = <span class="number">0</span>; </span><br><span class="line">	dut.slowClock = <span class="number">6</span>; </span><br><span class="line">	dut.slowClock_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++)</span><br><span class="line">		dut.reset();</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i ++)</span><br><span class="line">		dut.clock(<span class="type">LIT</span>&lt;<span class="number">1</span>&gt;(<span class="number">0</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="verilog-1">Verilog</h3>
<p>在verilog中，<br />
- Chisel为每个时钟/复位创建一个新端口<br />
- Chisel将所有时钟连接到顶部模块<br />
- 用户必须为每个时钟i创建一个always块时钟驱动器</p>
<p>以下是驱动slowClock /
fastClock示例电路的顶层线束的Verilog示例：<br />
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module emulator;</span><br><span class="line">	reg fastClock = <span class="number">0</span>, slowClock = <span class="number">0</span>, resetFast = <span class="number">1</span>, resetSlow = <span class="number">1</span>; </span><br><span class="line">	wire [<span class="number">31</span>:<span class="number">0</span>] add, mul, test; </span><br><span class="line">	always #<span class="number">2</span> fastClock = ~fastClock; </span><br><span class="line">	always #<span class="number">4</span> slowClock = ~slowClock; </span><br><span class="line">	initial begin</span><br><span class="line">		#<span class="number">8</span></span><br><span class="line">		resetFast = <span class="number">0</span>; </span><br><span class="line">		resetSlow = <span class="number">0</span>; </span><br><span class="line">		#<span class="number">400</span></span><br><span class="line">		$finish;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="type">ClkDomainTest</span> dut (</span><br><span class="line">	.fastClock(fastClock), </span><br><span class="line">	.slowClock(slowClock), </span><br><span class="line">	.io_resetFast(resetFast), </span><br><span class="line">	.io_resetSlow(resetSlow),</span><br><span class="line">	.io_add(add), </span><br><span class="line">	.io_mul(mul), </span><br><span class="line">	.io_test(test));</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h1 id="extra-stuff">Extra Stuff</h1>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListLookup</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](addr: <span class="type">UInt</span>, <span class="keyword">default</span>: <span class="type">List</span>[<span class="type">T</span>],</span><br><span class="line">	mapping: <span class="type">Array</span>[(<span class="type">UInt</span>, <span class="type">List</span>[<span class="type">T</span>])]): <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lookup</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (addr: <span class="type">UInt</span>, <span class="keyword">default</span>: <span class="type">T</span>,</span><br><span class="line">	mapping: <span class="type">Seq</span>[(<span class="type">UInt</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">// n-way multiplexor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MuxCase</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="keyword">default</span>: <span class="type">T</span>, mapping: <span class="type">Seq</span>[(<span class="type">Bool</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// n-way indexed multiplexer:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MuxLookup</span></span>[<span class="type">S</span> &lt;: <span class="type">UInt</span>, <span class="type">T</span> &lt;: <span class="type">Data</span>](key: <span class="type">S</span>, <span class="keyword">default</span>: <span class="type">T</span>, mapping: <span class="type">Seq</span>[(<span class="type">S</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create n enum values of given type</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](n: <span class="type">Int</span>)(gen: =&gt; <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create enum values of given type and names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](l: <span class="type">Symbol</span> *)(gen: =&gt; <span class="type">T</span>): <span class="type">Map</span>[<span class="type">Symbol</span>, <span class="type">T</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create enum values of given type and names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](l: <span class="type">List</span>[<span class="type">Symbol</span>])(gen: =&gt; <span class="type">T</span>): <span class="type">Map</span>[<span class="type">Symbol</span>, <span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<h1 id="standard-library">Standard Library</h1>
<h2 id="math">Math</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the log base 2 of the input </span></span><br><span class="line"><span class="comment">// Scala Integer rounded up</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2Up</span></span>(in: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="comment">// Returns the log base 2 of the input </span></span><br><span class="line"><span class="comment">// Scala Integer rounded down</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2Down</span></span>(in: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns true if the input Scala Integer </span></span><br><span class="line"><span class="comment">//isapowerof2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPow2</span></span>(in: <span class="type">Int</span>): <span class="type">Boolean</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// linear feedback shift register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LFSR16</span></span>(increment: <span class="type">Bool</span> = <span class="type">Bool</span>(<span class="literal">true</span>)): <span class="type">UInt</span></span><br></pre></td></tr></table></figure>
<h2 id="sequential">Sequential</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the n-cycle delayed version</span></span><br><span class="line"><span class="comment">// of the input signal</span></span><br><span class="line"><span class="comment">// Has an optional enable signal defaulting to true def ShiftRegister[T &lt;: Data (in: T, n: Int, en = </span></span><br><span class="line">	<span class="type">Bool</span>(<span class="literal">true</span>)): <span class="type">T</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Counter</span></span>(cond: <span class="type">Bool</span>, n: <span class="type">Int</span>) = &#123; </span><br><span class="line">	<span class="keyword">val</span> c = <span class="type">RegReset</span>(<span class="type">UInt</span>(<span class="number">0</span>, log2Up(n))) </span><br><span class="line">	<span class="keyword">val</span> wrap = c === <span class="type">UInt</span>(n<span class="number">-1</span>)</span><br><span class="line">	when (cond) &#123;</span><br><span class="line">		c := <span class="type">Mux</span>(<span class="type">Bool</span>(!isPow2(n)) &amp;&amp; wrap, <span class="type">UInt</span>(<span class="number">0</span>), c + <span class="type">UInt</span>(<span class="number">1</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	(c, wrap &amp;&amp; cond) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="uint">UInt</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the number of bits set in the // input signal. Causes an exception if // the input is wider than 32 bits.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PopCount</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the reverse the input signal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// returns the one hot encoding of</span></span><br><span class="line"><span class="comment">// the input UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UIntToOH</span></span>(in: <span class="type">UInt</span>, width: <span class="type">Int</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// does the inverse of UIntToOH</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OHToUInt</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OHToUInt</span></span>(in: <span class="type">Seq</span>[<span class="type">Bool</span>]): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Builds a Mux tree out of the input</span></span><br><span class="line"><span class="comment">// signal vector using a one hot encoded </span></span><br><span class="line"><span class="comment">// select signal. Returns the output of </span></span><br><span class="line"><span class="comment">// the Mux tree</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux1H</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (sel: <span class="type">UInt</span>, in: <span class="type">Vec</span>[<span class="type">T</span>]): <span class="type">T</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux1H</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (sel: <span class="type">Vec</span>[<span class="type">Bool</span>], in: <span class="type">Vec</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Builds a Mux tree under the</span></span><br><span class="line"><span class="comment">// assumption that multiple</span></span><br><span class="line"><span class="comment">// select signals can be enabled.</span></span><br><span class="line"><span class="comment">// Priority is given to the first</span></span><br><span class="line"><span class="comment">// select signal. Returns the output </span></span><br><span class="line"><span class="comment">// of the Mux tree.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityMux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">UInt</span>, in: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">T</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityMux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Seq</span>[<span class="type">UInt</span>], in: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the bit position of the</span></span><br><span class="line"><span class="comment">// trailing 1 in the input vector with </span></span><br><span class="line"><span class="comment">// the assumption that multiple bits of </span></span><br><span class="line"><span class="comment">// the input bit vector can be set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoder</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoder</span></span>(in: <span class="type">Seq</span>[<span class="type">Bool</span>]): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the bit position of the</span></span><br><span class="line"><span class="comment">// trailing 1 in the input vector with</span></span><br><span class="line"><span class="comment">// the assumption that only one bit in</span></span><br><span class="line"><span class="comment">// the input vector can be set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoderOH</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoderOH</span></span>(in: <span class="type">Seq</span>[<span class="type">Boo</span>]): <span class="type">UInt</span></span><br></pre></td></tr></table></figure>
<h2 id="decoupled">Decoupled</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds a ready-valid handshaking </span></span><br><span class="line"><span class="comment">// protocol to any interface. The</span></span><br><span class="line"><span class="comment">// standard used is that the</span></span><br><span class="line"><span class="comment">// consumer uses the fliped interface</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledIO</span>[+<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits  = gen.cloneType.asOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Adds a valid protocol to any</span></span><br><span class="line"><span class="comment">// interface. The standard used is </span></span><br><span class="line"><span class="comment">// that the consumer uses the</span></span><br><span class="line"><span class="comment">// fliped interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidIO</span>[+<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits  = gen.cloneType.asOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hardware module that is used to </span></span><br><span class="line"><span class="comment">// sequence n producers into 1 consumer</span></span><br><span class="line"><span class="comment">// Priority is given to lower</span></span><br><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="comment">// Example usage: </span></span><br><span class="line"><span class="comment">// 		val arb = new Arbiter(UInt(), 2)</span></span><br><span class="line"><span class="comment">//		arb.io.in(0) &lt;&gt; producer0.io.out</span></span><br><span class="line"><span class="comment">// 		arb.io.in(1) &lt;&gt; producer1.io.out</span></span><br><span class="line"><span class="comment">//		consumer.io.in &lt;&gt; arb.io.out</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arbiter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hardware module that is used to</span></span><br><span class="line"><span class="comment">// sequence n producers into 1 consumer.</span></span><br><span class="line"><span class="comment">// Producers are chosen in round robin</span></span><br><span class="line"><span class="comment">// order</span></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">//		val arb = new RRArbiter(UInt(), 2) </span></span><br><span class="line"><span class="comment">//		arb.io.in(0) &lt;&gt; producer0.io.out </span></span><br><span class="line"><span class="comment">//		arb.io.in(1) &lt;&gt; producer1.io.out </span></span><br><span class="line"><span class="comment">//		consumer.io.in &lt;&gt; arb.io.out </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RRArbiter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic hardware queue. Required </span></span><br><span class="line"><span class="comment">// parameter entries controls the</span></span><br><span class="line"><span class="comment">// depth of the queues. The width of</span></span><br><span class="line"><span class="comment">// the queue is determined from the </span></span><br><span class="line"><span class="comment">// inputs.</span></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">// 		val q = new Queue(UInt(), 16)</span></span><br><span class="line"><span class="comment">//		q.io.enq &lt;&gt; producer.io.out</span></span><br><span class="line"><span class="comment">// 		consumer.io.in &lt;&gt; q.io.deq</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, pipe: <span class="type">Boolean</span> = false, flow: <span class="type">Boolean</span> =false</span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A hardware module that delays data </span></span><br><span class="line"><span class="comment">// coming down the pipeline by the </span></span><br><span class="line"><span class="comment">// number of cycles set by the </span></span><br><span class="line"><span class="comment">// latency parameter. Functionality </span></span><br><span class="line"><span class="comment">// is similar to ShiftRegister but </span></span><br><span class="line"><span class="comment">// this exposes a Pipe interface. </span></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">// 		val pipe = new Pipe(UInt()) </span></span><br><span class="line"><span class="comment">//		pipe.io.enq &lt;&gt; produce.io.out </span></span><br><span class="line"><span class="comment">// 		consumer.io.in &lt;&gt; pipe.io.deq</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipe</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, latency: <span class="type">Int</span> = 1</span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure>
<p>（完）</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Bao Chuquan 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="Bao Chuquan 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/" rel="tag"># 硬件描述语言</a>
              <a href="/tags/Chisel/" rel="tag"># Chisel</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/12/17/chisel-tutorial/" rel="prev" title="Chisel入门教程">
                  <i class="fa fa-angle-left"></i> Chisel入门教程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/01/05/read-books/" rel="next" title="【我的阅读轨迹】">
                  【我的阅读轨迹】 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">true</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
  <div>
     <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备16031766号-1</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://vercel.chuquan.me","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"(发表评论)","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"dark":"body.darkmode--activated","visitor":true,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2016/12/18/chisel-manual/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<script src="/live2dwlib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dwassets/tororo.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
