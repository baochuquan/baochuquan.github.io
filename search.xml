<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Testing</tag>
        <tag>AnotherTag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F07%2FHello-World%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向工程——基础篇]]></title>
    <url>%2F2018%2F02%2F06%2Fios-reverse-engineering-basis%2F</url>
    <content type="text"><![CDATA[一、iOS文件系统iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有一套标准的文件系统——Filesystem Hierarchy Standard（FHS），其常用目录结构如下所示： /：根目录 /bin：binary，存放用户级基础功能的二进制文件，如ls、ps等 /boot：存放能使系统成功启动的所有文件。iOS中此目录为空 /dev：device，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备。块设备以块为单位传输数据，如硬盘；字符设备以字符为单位传输数据，如调制解调器 /sbin：system binaries，存放提供系统级基础功的二进制文件，如netstat、reboot等 /etc：法语Et Cetera（and so on的意思），存放系统脚本及配置文件，如passwd、hosts。iOS中，/etc是一个符号链接，实际指向/private/etc /lib：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空 /mnt：mount，存放临时的文件系统挂载点。iOS中此目录为空 /private：存放两个目录，分别是/private/etc和/private/var /tmp：临时目录。iOS中，/tmp是一个符号链接，实际指向/private/var/tmp /usr：包含大多数用户和程序。 /usr/bin：包含那些/bin和/sbin中未出现的基础功能，如nm、killall等 /usr/include：包含所有的标准C头文件 /usr/lib：存放库文件 /var：variable，存放一些经常更改的文件，如日志、用户数据、临时文件等。 /var/mobile：存放了mobile用户的文件。逆向工程重点关注目录 /var/root：存放了root用户的文件 1. iOS独有目录下图所示分别是OSX和iOS的根目录结构，与FHS还是有一定的区别。 对于iOS，其独有的目录如下思维导图所示： /Applications：存放所有的系统App和来自于Cydia的App，不包括StoreApp /Developer：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录 /Developer/Applications /Developer/Library /Developer/Tools /Developer/usr /Library：存放一些提供系统支持的数据 /Library/MobileSubstrate/DynamicLibraries：存放Cydia安装程序的.plist和.dylib文件 /System/Library：iOS文件系统中最重要的目录之一，存放大量系统组件 /System/Library/Frameworks：存放iOS中各种日常使用的framework /System/Library/PrivateFrameworks：存放iOS中未公开的私有framework /System/Library/CoreServices/SpringBoard.app：iOS桌面管理器 /User：用户目录（mobile用户的home目录），实际指向/var/mobile，存放大量用户数据 /var/mobile/Media/DCIM：存放照片 /var/mobile/Media/Recording：存放录音文件 /var/mobile/Library/SMS：存放短信数据库 /var/mobile/Library/Mail：存放邮件数据 /var/mobile/Containers：存放StoreApp。 /var/mobile/Containers/Bundle：存放所有StoreApp的可执行文件和相关资源 /var/mobile/Containers/Data：存放所有StoreApp的数据，沙盒目录的真实目录 2. iOS应用（StoreApp）沙盒出于安全考虑，iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问）。 上图所示为沙盒结构，沙盒在逻辑上包含两个部分：Bundle Container和Data Container，两者在iOS文件系统中的位置是平行的，分别是/var/mobile/Containers/Bundle和/var/mobile/Containers/Data。实际开发中，通过NSHomeDirectory()方法获取到沙盒根目录对应的是Data Container的路径。 I. Bundle Containerbundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。 在正向开发时，我们上传至App Store的ipa（iPhone Application）包，解压后会有一个Payload目录，其内部又包含一个.app目录，这个目录就是一个App的目录结构，也是一个bundle。 Bundle Container位于/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/主要用于存放静态资源，主要包含以下目录和文件： MyApp.app 存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、.plist文件。这个目录不会被iTunes同步。 iTunesArtWork iTunesMetadata.plist II. Data ContainerData Container位于/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/，主要用于存放App运行时产生的动态数据，其主要包含以下目录和文件： Documents 存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录 Library Library/Caches 存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。 Library/Preferences 存放偏好设置。使用NSUserDefaults写的设置数据都会保存在该目录下的一个plist文件中。iTunes或iCloud同步设备时备份该目录。 tmp 存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。 在正向开发时，沙盒目录路径均有相应的获取方式，具体如下所示：123456789101112131415161718// 沙盒目录NSLog(@&quot;%@&quot;,NSHomeDirectory()); // MyApp.appNSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]); // DocumentsNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docPath = [paths objectAtIndex:0];NSLog(@&quot;%@&quot;,docPath); // LibraryNSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);NSString *libPath = [paths objectAtIndex:0];NSLog(@&quot;%@&quot;,libPath); // tmpNSLog(@&quot;%@&quot;,NSTemporaryDirectory()); 在逆向工程中，可以通过以下方式获取相关的目录：123456// 获取App的Bundle路径iphone: root# ps -e | grep appname // 获取App的Data路径iphone: root# cycript -p appnamecy# directory = NSHomeDirectory() 二、iOS二进制文件类型iOS逆向的目标主要包含三类二进制文件：Application、Dynamic Library、Daemon。 1. ApplicationApplication，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要： Info.plist Info.plist记录了App的基本信息，如：bundle identifier、可执行文件名、图标文件名等。 可执行文件 查看Info.plist，即可定位可执行文件 lproj目录 lproj目录下存放的是各种本地化的字符串。 I. 系统App VS. StoreApp/Applications/目录下存放系统App（包括CydiaApp）；/var/mobile/Containers/目录下存放StoreApp。其区别在于： 目录结构 两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在/var/mobile/Containers/Data/下，以mobile权限运行的系统App的数据目录在/var/mobile/下，以root权限运行的系统App的数据目录在/var/root/下。 安装格式和权限 Cydia App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。 2. Dynamic LibraryDynamic Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。 在iOS中，lib分为static和dynamic两种，其中static lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。 dylib是逆向工程的重要目标类型，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。 越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。 3. DaemoniOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查/System/Library/LaunchDaemons和/Library/LaunchDaemons下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的Info.plist文件作用类似，即记录Daemon的基本信息。 (完) 参考 《iOS应用逆向工程（第2版）》 File System Programming Guide iOS底层基础知识-文件目录结构 iOS APP沙盒目录 Mac OS X 术语表 了解iOS上的可执行文件和Mach-O格式 由App的启动说起 Mach-O 可执行文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代浏览器工作原理（一）]]></title>
    <url>%2F2018%2F01%2F21%2Fbrowser-architecture-overview%2F</url>
    <content type="text"><![CDATA[序这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了…框架？不是针对特定需求的框架，介绍起来感觉也没有太大的意义… 恍惚间，想起之前@展哥在调高考真题Hybrid页面时，似乎在前端代码方面遇到一些麻烦。于是，我就想到了UIWebView。就此进行思维发散，感觉可以介绍一下浏览器的工作原理。毕竟，iOS和前端同属于大客户端。对于iOS的同学，也算是对知识面的扩展吧。 于是，我查阅了一些与浏览器原理相关的资料。在这个过程中，找到很多优秀的资料。但是，大多数资料的组织结构，不是特别清晰。因此，我想借此机会，结合参考资料，来重新梳理一下浏览器的原理。由于浏览器的结构非常复杂，一篇文章想介绍清楚，真的太难。本文将使用总-分-总的形式，使用一系列文章来进行介绍。如有纰漏，欢迎纠正。 浏览器历史1990年，蒂姆·伯纳斯·李开发了第一个网页浏览器WorldWideWeb，后改名为Nexus。WorldWideWeb浏览器支持早期的HTML标记语言，功能比较简单，只能支持文本、简单的样式表、电影、声音、图片等资源的显示。 1993年，马克·安德森领导的团开发了一个真正有影响力的浏览器Mosaic，这就是后来世界上最流行的浏览器Netscape Navigator。 1995年，微软推出了闻名于世的浏览器Internet Explorer。 1998年，Netscape公司开放Netscape Navigator源代码，成立了Mozilla基金会。 2003年，苹果公司发布了Safari浏览器。 2004年，Netscape公司发布了著名的开源浏览器Mozilla Firefox 2005年，苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目WebKit（Safari浏览器的内核）。 2008年， Google公司已WebKit为内核，创建了一个新的浏览器项目Chromium。以Chromium为基础，谷歌发布了Chrome浏览器。至于这两者的关系，可以简单地理解为：Chromium为实验版，具有众多新特性；Chrome为稳定版。 浏览器特性现代浏览器的特性主要包含如下几部分： 网络 浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。 资源管理 浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。 网页浏览 浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。 多页面管理 浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。 插件和扩展 现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。 账户和同步 现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。 安全机制 现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。 开发者工具 开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。 浏览器结构目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构： 浏览器的抽象分层结构图中将浏览器分成了以下8个子系统： 用户界面（User Interface） 用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。 用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。 浏览器引擎（Browser Engine） 浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。 浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。 浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。 浏览器引擎还允许查询/修改渲染引擎设置。 渲染引擎（Rendering Engine） 渲染引擎为指定的URI生成可视化的表示。 渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。 渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。 渲染引擎内部包含HTML解析器。 网络（Networking） 网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。 JavaScript解释器（JavaScript Interpreter） JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。 XML解析器（XML Parser） XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。 显示后端（Display Backend） 显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。 数据持久层（Data Persistence） 数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。 这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。 渲染引擎浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用： 渲染引擎 浏览器 Trident IE、Edge Gecko Firefox WebKit Safari、Chromium/Chrome 渲染引擎工作流程如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。 Parsing HTML to Construct DOM Tree渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。 Render Tree construction渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 Layout of Render Tree渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 Painting Render Tree渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。 渲染引擎组成模块下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 从图中可以看出，渲染引擎主要包含（或调用）的模块有： HTML（XML）解析器 解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。 CSS解析器 将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。 JavaScript解释器 使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。 布局 DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。 绘图 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。 总结本文介绍了浏览器的主要特性以及抽象结构，并选择其中最为核心的渲染引擎进行了介绍。渲染引擎是浏览器中最为复杂的部件，后续将对渲染引擎中的各个模块依次进行介绍。 （完） 参考 Web Browser-Wikipedia Adam Barth, Collin Jackson, Charles Reis, Google Chrome Team. The Security Architecture of the Chromium Browser. Andre Campos, Bryan Lane, Neal Clark, Sunpreet Jassal, Stephen Hitchner. Conceptual Architecture of Firefox. Alan Grosskurth and Michael Godfrey. A case study in architectural analysis: The evolution of the modern web browser. 主流浏览器内核介绍（前端开发值得了解的浏览器内核历史） 朱永盛. 《WebKit技术内幕》. 浏览器的工作原理：新式网络浏览器幕后揭秘 Alan Grosskurth, Michael W.Godfrey. A Reference Architecture for Web Browsers.]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年总结]]></title>
    <url>%2F2018%2F01%2F02%2F2017-summary%2F</url>
    <content type="text"><![CDATA[这几天，脉脉上有一个年度总结的活动。2017年，我对自己的总结便是一个字——变。 关于论文毕设2017的上半年是我硕士生涯，也是我学生生涯的最后一个学期。这半年真的是一直处于焦虑中，毕业总是令人如鲠在喉。有人可能会问硕士毕业有这么难吗？如果我说我们是在毕业答辩前两个月才开的题你信吗？ 关于毕业论文，我是经历过换题的。研二期间，一直在做碳纳米管计算机项目。然而，到了毕业选题的时候，才发现这个项目根本没有可深入研究的、与计算机体系结构相关的东西。不得已，只能换题。此时，恰逢2016年的10月，校招还在如火如荼地进行。而我已经没有心情继续找工作了。 2017年年初，@易老师给了我一个毕业选题的大方向——RISC-V &amp; TLB &amp; 安全。参考往年类似的毕业选题（如：@天一师兄、@翁东旭师兄的毕业论文），我大致规划出了毕业论文的框架。然而，往年论文的相关实验都是基于完整的项目平台，研究及评测环境相对来说都是比较完备的。我的毕业选题采用的实验平台则是基于RISC-V的开源处理器生成器——Rocket Chip Generator，该平台是2014年由UCB推出的，其研究及评测环境都还不完善，不足以提供标准且完整的论述、验证、评估的能力。 为了让论文能有更多的干货，我还去探索了TLB/MMU在安全方面研究的可能性。不过，这个想法在后来的预开题中被否决了。好在，预开题时，@佟老师给了我很多的建设性的意见，比如：研究Generator自动化生成硬件的原理、Chisel原理等。我能够在6月份顺利毕业，真的要感谢我的导师@佟老师、@易老师，在毕设期间予以我的帮助和建议。 关于科研项目2月底春季的开学阶段，我提前了一周回了学校。因为，在做毕业的同时，我还要和物理电子所的同学对接碳纳米管项目。为了能让项目顺利结题，春节前后和@海涛师兄、@司佳师姐、@东维师弟一起忙活了一段时间。项目最后顺利结题，也算是了却了一桩心事。在4月份左右，@彭老师、@程老大又来了一次巨头会议，要在北大120周年献礼。也就是说，碳纳米管项目继续进行。当然，我知道自己不能继续跟进，便把工作交接了@李宁师妹和@东维师弟了。希望明年的五四，能给大家带来一个惊喜。 关于毕业答辩3月底，实验室进行了开题答辩会。这个开题时间放眼整个北大，也算是晚的了。不知道@老大作何感想，可能真的是日理万机吧。不过，从开题答辩会上老大的表述，能看出@老大对于我们这一届还是抱有歉意，希望我们都能顺利毕业。 6月2日，毕业答辩会如期进行。答辩会上有校外专家，当我们有遇到答不上的问题或被专家刁难的时候，@老大能够及时救场，果然护犊子！手动点赞！结果是显而易见的，所有人都顺利毕业。 答辩过后，和@小威威、@大帅、@赵璐、@昊泽去了南门翅客吃了烧烤，果然是前所未有的轻松。 关于毕业旅行6月3日是我们的发出时间，一个月前订机票时也是非常忐忑，毕竟答辩时间是6月2日，就怕答辩时间更改。关于毕业旅行的详细内容，可以看这里。 关于毕业典礼毕业旅行回来，能感受到浓厚的离别气息。拍毕业照、毕业典礼、谢师宴…从今往后，同窗同门都要各奔东西。 关于工作校招时，我投递的岗位是前端开发工程师，后来HR跟我沟通有没有转岗iOS开发工程师的意愿。在考虑了几天后，我选择了转岗。我当时的想法是这样的： 前端的门槛比较低，从业人员比较很多，想真正脱颖而出还是比较困难的，感觉硕士毕业从事前端的优势并不大。 前端的技术更新迭代速度太快，没有一个统一的行业标准，不同的公司可能采用完全不同的技术栈。所以，前端岗需要不断地学习，一旦松懈，可能就会被淘汰，压力比较大。 程序员都知道所谓的“程序员鄙视链”，前端是处于“鄙视链”的下游的。虽然前端已经今非昔比了，但是总的来说，职业天花板比较低。 出于这些考虑，我选择了转岗。 7月初，办完了毕业手续，我和@撸神便搬家到了我们的整租房。在学校呆了20年，离开时真的很不习惯。 7月10日，在紧张和期待中办理了入职手续。期间，遇到了校友@家骏、@仲雪。中午，我的mentor@展哥接待了我，然后便组织大家在云海肴来了一波TB。 @展哥已经有7年的工作经验了，作为小猿搜题iOS端负责人，他的技术能力的确是很强的。作为mentor，他也是尽心尽力，真的非常nice。相比于我在某度的mentor，真是不知道高到哪里去了，无论是技术能力，还是个人修养。然而，没想到@展哥年后要离职，真的有点不舍啊。 我工位的右边是@展哥，左边是@琳洁——一位iOS程序媛。她虽然话不多，但是只要有问题，她都能悉心指导我。而且做事特别细致，从code review就能看出来。 我的leader@邱瑞，也是我的校友师兄。为人非常nice，说话语气很平和，平时分配任务、交谈时完全没有一种上下级的感觉。对于产品需求的评估、事务的处理都是非常到位。 有人说：想要在职场上快速成长，可以尝试学习你领导的做事方式。我个人非常赞同这种观点，希望新的一年，我能够像@展哥、@邱瑞、@琳洁他们一样做人做事。 关于技术上半年写的代码基本都是服务于毕业设计，都是与硬件相关。下半年学的都是工程相关： 在编程语言方面，学习了两门新的语言：Objective-C、Swift。 在版本管理方面，能够熟练使用git的各种常用命令。 在项目管理方面，了解了公司的项目管理流程以及敏捷开发模式，自己还搭建了Gerrit代码审核服务器。 关于阅读2017年1月1日，我计划开始记录自己的阅读轨迹，其实主要原因是希望能够督促自己保持阅读（阅读轨迹在这里）。2017年总共阅读了不到10本书。希望新的一年，在阅读时能够有更多的自我思考，尽可能产出一些读书笔记。虽然，我读书的时候喜欢使用有道云来做笔记，但是缺少整理、总结和发布。 展望对于公司来说，都会有年度目标，这样公司才能够健康成长。对于个人也是一样，给自己定一个目标，希望能够激励自己成长。2018年伊始，我也想给自己定一些小目标。 至少看完两个iOS开源框架源代码（向大神靠拢） 至少看12本书，非工具类的书，需要有读书笔记（向@巧叔学习） 在技术方面，能够hold住产品经理提出来的所有需求（向@琳洁@展哥学习 在业务方面，了解小猿搜题的所有业务代码（向@邱瑞@琳洁@展哥学习）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH 协议实践]]></title>
    <url>%2F2017%2F12%2F27%2Fssh-protocol-practice%2F</url>
    <content type="text"><![CDATA[一、SSH概述类似于HTTP，SSH（Secure Shell）是一种加密的网络传输协议，常用于加密远程登录。 1995年，芬兰赫尔辛基理工大学的塔图·于勒宁因为发现自己学校存在嗅探密码的网络攻击，设计了一套保护信息传输的程序，即Secure Shell（简称SSH），其目标是取代先前的rlogin、Telnet、FTP、rsh等安全性不足的协议。如今，最为广泛使用的OpenSSH便是SSH协议的一种免费开源实现。 二、基本原理SSH使用非对称加密算法实现身份验证，即采用公钥-私钥对来进行加密网络连接。私钥由用户（本地主机）自行保管，公钥由远程主机（如：服务器）保管。 三、应用实践下面使用OpenSSH进行具体实践。 1. SSH协议语法格式SSH主要用于远程登录，如下所示为SSH协议的语法格式。1ssh [&lt;username&gt;@]&lt;server&gt;[:&lt;port&gt;] 2. 关于SSH公钥认证为实现公钥认证，作为认证的客户端一方需要拥有两个文件，即公钥-私钥对。一般公钥-私钥对文件创建在用户的主目录下的.ssh目录中。如果用户主目录下不存在.ssh目录，说明SSH公钥-私钥对尚未创建。 （1）创建公钥-私钥对1$ ssh-keygen 该命令会在用户主目录下创建.ssh目录，并在其中创建两个文件： id_rsa：私钥文件。是基于RSA算法创建的。 id_rsa.pub：公钥文件。 （2）分发公钥创建了公钥-私钥对后，需要将公钥交给远程主机保管，这样才能在之后的登录实现无口令登录。如下命令，会将.ssh目录下指定的公钥文件拷贝至远程服务器。1$ ssh-copy-id -i .ssh/id_rsa.pub &lt;user&gt;@&lt;server&gt; 该命令会提示输入用户user在server上的SSH登录口令 此命令执行成功后，再以user用户用ssh命令登录server远程主机时，不必输入口令可直接登录 该命令实际上是.ssh/id_rsa.pub公钥文件拷贝到远程主机server的user主目录下的.ssh/authorized_keys文件中，内容类似如下：1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHJu4oVxIbLS2LBH5wI7htvDxuIMZ5IFUaZjbWI8z...M4yGEWcr7OVPdQa4DIEbrrl8MzsAZ baochuquan@baochuquandeMacBoo k-Pro.local 3. 关于SSH主机别名在实际应用中，有时需要使用多套公钥/私钥对。然而，上述创建公钥-私钥对的命令只会生成默认名为id_rsa的密钥对。 （1）创建公钥-私钥对为了创建不同的公钥/私钥对，在使用ssh-keygen命令时就需要通过-f参数指定不同的私钥名称。用法如下：1$ ssh-keygen -f ~/.ssh/&lt;filename&gt; 命令会在.ssh/目录下创建指定的公钥/私钥对：文件&lt;filename&gt;是私钥，文件&lt;filename&gt;.pub是公钥。 （2）分发公钥将新生成的公钥添加到远程主机登录用户主目录下的.ssh/authorized_keys文件中，就可以使用新创建的公钥建立到远程主机的账户的无口令登录：1$ ssh-copy-id -i .ssh/&lt;filename&gt;.pub &lt;user&gt;@&lt;server&gt; 在有多个公钥/私钥对时，默认使用~/.ssh/id_rsa.pub。那么如何使用新建的公钥连接server呢？ （3）管理本地私钥SSH的客户端配置文件~/.ssh/config可以通过创建主机别名，连接主机时选择用指定的私钥。例如/.ssh/config文件中的下列配置12345678910111213141516171819# 使用默认的id_rsa私钥Host gerrit.zhenguanyu.com Hostname gerrit.zhenguanyu.com Port 29418 User baocq # 使用指定的chuquan01私钥Host chuquan user root hostname 115.28.167.128 port 22 identityfile ~/.ssh/chuquan01 # 使用指定的gerrit01私钥Host gerrit user gerrit hostname 115.28.167.128 port 22 identityfile ~/.ssh/gerrit01 （4）无口令远程登录执行下面的SSH登录命令，即可登录Host为chuquan的主机：1$ ssh chuquan （完） 参考[1] Secure Shell[2] SSH原理与运用（一）：远程登录[3] SSH原理与运用（二）：远程操作与端口转发[4] 《Git权威指南》，蒋鑫]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu + Gerrit + Apache 搭建代码审核服务器]]></title>
    <url>%2F2017%2F12%2F12%2Fubuntu-gerrit-apache%2F</url>
    <content type="text"><![CDATA[我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容… 一、Gerrit介绍Gerrit的目的是提供一个轻量级的框架来review每一个commit，review通过之后，commit会被合入代码库。 Gerrit是一个中间区域，可以看到提交至Gerrit上的代码相对于服务器代码仓库中代码的差异，从而便于检查代码的改动。Gerrit也是整个代码review的推动者。 任何拥有多个成员的团队都应该有一个中央代码仓库。 Git在理论上可以在没有这样的中心位置的情况下工作，但实际上通常有一个中央仓库库作为项目实际内容的权威副本。 开发者从该中央仓库fetch和push Gerrit被部署在上图的中央仓库的位置，并增加一个新的概念：a store of pending changes（未决的修改）。每个人仍然可以从中央仓库fetch，但是push操作则有所变化，push操作会直接push到中央仓库，而是push到了pending changes location，以供review。只有在commit通过了review之后，才会被submit到中央仓库。如下图所示。 Gerrit具有强大的访问控制模型。用户可以被授予访问权限，绕过review，直接推送到中央仓库。Gerrit甚至可以在没有代码review的情况下使用，只用于托管仓库和访问控制。 二、应用场景在安装gerrit之前，我使用node在服务器上部署了一个站点，也就是本博客，其占用了80端口。 在安装gerrit之后，我的服务器又将多出一个站点，用户该如何访问？我又该如何部署呢？这时候，我们就需要了解一下反向代理和端口转发了。 1. 正向代理与反向代理如下所示为正向代理和反向代理的示意图。一般来说，我们会把正向代理是与客户端划为一体，把反向代理和服务器划为一体。 此时，重新思考一下我们的应用场景：博客是一个web服务器，gerrit是一个web服务器，apache作为反向代理，这样就可以满足我们的需求了。 那么反向代理到底是如何做到的呢？答案就是端口转发。 我们知道在浏览器输入网址后，它会在解析后的IP地址之后加上一个默认的端口号80。所以，我们访问chuquan.me时就不需要输入完整的地址chuquan.me:80了。正因为如此，绝大多数服务器软件（包括apache）的默认监听端口也是80。 在安装了apache之后，80端口被apache占用了。因此，gerrit和博客都不能使用80端口了。这时候，我们需要给这两个站点配置使用其他的端口号，如：gerrit的HTTP协议使用8081端口，博客使用8082端口。它们与apache之间使用端口转发来实现反向代理。 三、开发环境 Ubuntu 14.04.5 LTS Java 1.8.0_151 Git 1.9.1 Apache/2.4.7 四、安装Gerrit1. 新建专用用户新建一个用户来专门管理Gerrit相关内容。在root用户下新建一个gerrit用户。12$ adduser gerrit$ su gerrit 2. 下载Gerrit安装包Gerrit下载地址：https://www.gerritcodereview.com/releases/2.14.md 我安装的Gerrit版本是2.14.6。在Linux环境下使用wget进行下载，最终得到一个war包，位于/home/gerrit/目录下。1$ wget https://gerrit-releases.storage.googleapis.com/gerrit-2.14.6.war 3. 安装Gerrit在/home/gerrit/目录下，进行安装：1$ java -jar gerrit-2.14.6.war init -d review_site 上述命令会在当前目录下创建一个review_site目录。接下来就开始进行对话式安装，我们可以直接回车，表示采用默认安装选项。之后还可以通过配置文件进行详细配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*** Gerrit Code Review 2.14.6****** Git Repositories *** Location of Git repositories [git]: *** SQL Database *** Database server type [h2]: *** User Authentication *** Authentication method [OPENID/?]: http Get username from custom HTTP header [y/N]? SSO logout URL : *** Email Delivery *** SMTP server hostname [localhost]: SMTP server port [(default)]: SMTP encryption [NONE/?]: SMTP username : *** Container Process *** Run as [gerrit]: Java runtime [/usr/lib/jvm/java-7-openjdk-amd64/jre]: Copy gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war [Y/n]? Copying gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war *** SSH Daemon *** Listen on address [*]: Listen on port [29418]: *** HTTP Daemon *** Behind reverse proxy [y/N]? Proxy uses SSL (https://) [y/N]? Subdirectory on proxy server [/]: Listen on address [*]: Listen on port [8080]:*** Plugins *** Installing plugins. Install plugin download-commands version v2.11 [y/N]? Install plugin reviewnotes version v2.11 [y/N]? Install plugin singleusergroup version v2.11 [y/N]? Install plugin replication version v2.11 [y/N]? Install plugin commit-message-length-validator version v2.11 [y/N]? Initializing plugins. No plugins found with init steps. Initialized /home/gerrit/review_site... 安装完毕，Gerrit会自动启动，不过我们大概率会启动失败，因为默认的配置并不一定与你当前的环境相匹配。不过，没关系，我们可以根据系统环境对gerrit进行配置。 4. Gerrit配置Gerrit安装完成后，会在review_site目录下生成多个目录。123456789101112131415$ ll review_site./../bin/cache/data/db/etc/git/index/lib/logs/plugins/static/tmp/ 其中etc/目录下存放着gerrit的配置文件gerrit.config，其中已有的内容是根据安装时的选择生成的。我们可以编辑gerrit.config来进行配置更改。其中115.28.168.118是服务器的公网IP地址。123456789101112131415161718192021222324[gerrit] basePath = git serverId = 084efaf9-3bf6-401c-a4b1-8778c998bde2 canonicalWebUrl = http://115.28.168.118 # 指定web访问Gerrit的网址或IP地址[database] type = h2 database = /home/gerrit/review_site/db/ReviewDB[index] type = LUCENE[auth] type = HTTP # 默认是OPENID，改成HTTP后，才能通过浏览器进行访问[receive] enableSignedPush = true[sendemail] smtpServer = localhost[container] user = gerrit javaHome = /usr/lib/jvm/java-8-oracle/jre[sshd] listenAddress = *:29418[httpd] listenUrl = proxy-http://115.28.168.118:8081/ # HTTP代理地址及端口，这里我们配置成8081[cache] directory = cache 四、配置Apache不同系统以及不同版本的Apache的配置文件可能会不一样，无外乎两种：httpd.conf、apache2.conf。本环境的配置文件是apache2.conf。12$ cd /etc/apache2/$ vim apache2.conf 在配置文件的末尾添加apache的端口转发配置。如下所示1234567891011121314151617181920212223242526272829...# Blog相关配置&lt;VirtualHost *:80&gt; ServerName www.chuquan.me # 用于Apache过滤检测的域名 ServerAlias chuquan.me ProxyPass / http://115.28.168.118:8082/ # Blog正向代理转发的端口 ProxyPassReverse / http://localhost:8082/ # Blog反向代理转发的端口&lt;/VirtualHost&gt;# Gerrit相关配置&lt;VirtualHost *:80&gt; ServerName gerrit.chuquan.me # 用户Apache过滤检测的域名 ProxyRequests Off ProxyVia Off ProxyPreserveHost On &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; &lt;Location /login/&gt; AuthType Basic AuthName &quot;Gerrit Code Review&quot; Require valid-user AuthBasicProvider file AuthUserFile /home/gerrit/review_site/etc/passwords &lt;/Location&gt; AllowEncodedSlashes On ProxyPass / http://115.28.168.118:8081/ # Gerrit正向代理转发的端口 ProxyPassReverse / http://115.28.168.118:8081/ # Gerrit反向代理转发端口，应该与ProxyPass一致&lt;/VirtualHost&gt; 五、服务重启Apache和Gerrit配置（当然也包括blog的端口）完之后，我们需要重启服务，包括apache、gerrit，其重启命令分别如下：1$ /etc/init.d/apache2 restart 12$ cd /home/gerrit/$ ./bin/gerrit.sh restart 1. Gerrit启动失败在执行重启Gerrit的命令后，shell很可能会出现如下的信息：1Starting Gerrit Code Review: FAILED 我在安装过程中页出现了这个问题，于是，我通过在./bin/gerrit.sh脚本中的首行添加了一个-x选项，以打印脚本执行的相关信息。12#!/bin/sh -x... 然后再执行该脚本，发现打印信息是一组循环信息。其中，当TIMEOUT的值递减至0时，启动失败。 经过调研发现： Gerrit启动慢是因为java程序启动慢，导致Gerrit启动非常慢，大概需要10分钟左右，而默认的超时时间（TIMEOUT）是90秒，导致一直提示“Starting Gerrit Code Review: FAILEDStarting Gerrit Code Review: FAILED”。对此有如下两种解决方案。 第一种解决方案是：修改java的java.security文件。首先，根据gerrit.config中配置javaHome = /user/lib/jvm/java-8-oracle/jre，找到并进入该目录，然后再进入lib/security/目录，修改java.security文件。将securerandom.source=file:/dev/random改为securerandom.source=file:/dev/urandom。由此，解决gerrit启动慢的问题。 第二种解决方案是：在gerrit.conf文件中的[container]字段下增加`startupTimeout = 900。 2. 反向代理异常当我们配置结束并重启之后，在浏览器中访问很有可能会得到如下的页面： 这个页面在安装过程中，出现次数不下于10次。主要是两种情况，一种是Gerrit配置文件和Apache配置文件可能配置有误。另一种情况是配置没有生效，需要多试试重启。 3. 创建第一个Gerrit账户当所有问题解决完之后，通过浏览器访问Gerrit，将不会出现上面的Error界面，而是会弹出输入对话框，需要你填写账户和密码。 这时候，我们需要为Gerrit创建一个账户，默认第一个创建的账户是管理员。12345$ touch /home/gerrit/review_site/etc/passwords$ htpasswd /home/gerrit/review_site/etc/passwords &quot;admin&quot;New password:Re-type new password:Adding password for user root 重启服务后，再用浏览器打开，登录后就出现久违的界面了！ （完）]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git rebase与merge的区别]]></title>
    <url>%2F2017%2F10%2F10%2Fgit-rebase-merge%2F</url>
    <content type="text"><![CDATA[Git场景在基于Git版本控制的团队协作开发中，当同伴先于自己将新的提交push到远程分支上时，如果要想将自己新的提交push的远程分支，则需要先执行git pull来获取同伴的提交，如果有冲突则先处理完冲突，然后才能将自己的提交push到远程分支。这种情形是非常常见的。 然而执行git pull，在默认情况下，如果远程分支与本地分支的提交线图有分叉（即不是fast-forward，如上述这种情形），git会执行一次merge操作（即相当于执行了git pull --merge），而这会产生一次没有意义的提交记录。久而久之，项目的提交线图会非常混乱，其中会有很多由merge生成的无意义提交。 解决方案为了避免这种情况的出现，在将提交push到远程分支之前，我们一般会执行如下命令：1$ git pull --rebase 通过上述命令，Git会采用rebase策略来代替默认的merge策略。从而避免生成无意义的提交。 分析对比这时候，我们可能就会想：既然merge操作会生成无意义的提交，那它是不是没有什么价值了呢？是不是任何场景下都应该使用rebase操作？ 所以，我们对rebase和merge进行分析和对比。了解清楚了两者的区别，我们才能更好地运用这两个策略。 场景设想假设在执行pull之前的提交线图如下所示： Merge操作如果执行git pull（git默认会执行git pull --merge），提交线图会变成如下所示： 分析提交线图中多出了一个没有必要的提交H Rebase操作如果执行git pull --rebase，提交线图会变成如下所示： 分析提交线图中，本地的新提交F，G变成了两个新的提交F&#39;，G&#39;，拼接在了C后面，多余的分叉也删除了。提交线变得非常清晰。 小结从上述对比可以看出，rebase操作会将本分支的新提交删除并生成新的提交。所以rebase操作比较适用于将一些零碎的提交进行合并清理。比如：在push之前进行整理。 那么merge操作意义何在呢？ merge操作与rebase操作相反，它可以保留了提交线图的分叉，并生成一个新的提交。这种场景适合用于大的分支合并。这样，我们可以在提交线图中看到项目开发迭代过程中经历过哪些feature分支等等。 注意如果执行merge操作之前，提交线图是分叉的（即不是fast-forward，如场景设想的情形），执行git merge操作，是会达保留分支的目的。 但是执行merge操作之前，提交线图不是分叉的（即是fast-forward，如下上图所示），此时执行git merge操作的效果如下下图所示，分支是不会保留的。 在fast-forward情况下进行合并，我们需要执行如下命令来保留分支。执行后的提交线图如下所示。1$ git merge --no-ff （完）]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在入职两个月之际]]></title>
    <url>%2F2017%2F09%2F17%2Fgraduated-for-two-month%2F</url>
    <content type="text"><![CDATA[学生生涯结束至今已有两月有余，偶尔还是会念想在北大那些瞬间，好在入职的公司在各方面都非常令我满意，不至于用怀念来解忧生活。 关于工作 说说现在的公司吧，一家处于成长期的K12在线教育创业公司——猿辅导，坐落在阜通站旁的利星行中心。公司主要有粉笔网、猿题库、猿辅导、小猿搜题等几款在线教育App。 7月10日刚入职，我被安排到小猿搜题研发部的iOS开发岗。作为一名无任何iOS开发经验的应届毕业生，我的压力还是蛮大的，毕竟这对我来说是一个全新的挑战。好在我的同事们都非常nice，尤其是我的mentor——展哥，还有坐我旁边的元老级程序媛——琳洁。每每我在学习以及开发过程中有任何问题，他们都会不厌其烦地给我讲解，真的非常感谢他们！相比我之前实习的那家公司（某度），就同事间的关系来说，真是不知道高到哪里去了。 我们研发部研发人员大概不到20人，4个iOS，3个安卓，5个后台，3个前端，3个测试，当然其中也有些人前后端都做，小组内同事大都是硕士以上学历。研发部内部分为三个小团体：产品、客户端、服务器端。iOS、安卓、测试共同组成一个客户端，组内气氛每天都很欢乐，不至于每天工作得很压抑。 公司的工作制度也是比较和谐的。朝十晚七，不打卡，无KPI，不提倡加班。每天上午会有一个几分钟的站会，每个人说一下自己前一天的任务完成情况，以及当天的任务安排。我们平时也没有那么多的会，除非PM有新的产品需求，并且不提倡大家携带笔记本开会，从而提高开会效率。在某度，几乎每天都有各种会议，开会的时候大家基本都会携带笔记本，自己干自己的事。过多的会议真的会严重碎片会工作时间，降低工作效率。在某度实习期间，一个月的代码量都不如我现在一个星期的代码量。 周二下午我们小组会对PM提出的产品需求汇集、拆分，并进行难度评分，最后予以分配。站会也是就是对这些任务进展的汇报及安排。如此一套Scrum开发流程，可以极大地提高我们的工作效率。工作效率高了，也就没有必要加班了，生活也不是那么枯燥乏味了。 入职两个月以来，我能感受到自己的成长非常大。真正的项目实践总是能让你对一些东西有更深入的理解，比如git、gerrit等。公司对于项目管理使用了很多开源的工具，并进行了重组。希望在之后的日子里，我能对这些工具平台也有更深一步的了解。 关于生活 女票家给她在塘溪津门买了一套房，首付30%，2.2w/平米。接下来由我们两来还房贷，我每个月还贷1w，房租3k多，虽说生活还没到捉襟见肘的地步，但是能省则省吧。公积金也准备提出来了，只有这样，生活还能够多出一些积蓄来。当自身背负了如此沉重的房贷后，事业的发展总是会受到一定的影响，在面临选择的时候，会变得格外谨慎、犹豫，未来的我也许也会面临这样的情境。 该吐槽的还是要得吐槽。政府现在真的是把人往绝境里逼，虽说出台了一套又一套的房价抑制政策，然而所谓的政策只不过是稳定人心的幌子，韭菜该割还是要割，房价只是减速增长而已。房价的增长比工资的增长还快，买不起房的人永远都买不起房。 今年北京市的高考状元接受采访时的言论真的是一针见血。在教育方面上，他们享受着农村孩子无法想象的资源优势，进入名校对他们来说只是水到渠成的问题。事实上，在北大求学期间，我也意识到这个问题：周围的同学，尤其是本科生，大多数的家庭要么是高识分子，要么是高收入家庭，农村而来学生真的很少。现在社会频频出现学生入学如调查家庭背景的案例，很明显，学校在区分学生家庭所处的社会阶级，这样的情况在未来还会继续蔓延。富人越富，穷人愈穷，下一代亦是如此，阶级的固化正在酝酿。也许我们这一代还有不少能从底层往上爬，但后来的人真的将越来越难… （完）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 分支模型]]></title>
    <url>%2F2017%2F09%2F10%2Fgit-branching-model%2F</url>
    <content type="text"><![CDATA[我们公司的软件产品迭代采用的是scrum敏捷开发流程，代码使用git进行版本管理。在新人最初的几次开发任务中，我对于git的使用也仅限于一些基本的命令，包括：add、commit、rebase、cherry-pick、push、checkout等等。直到有一天，我发现远程分支上存在着一些历史feature分支，这对于我这个初入职场的小白来说还是有些好奇：feature分支在本地建立不就行了吗？为何还需要推送到远程仓库？带着这一些列的疑问，我仔细研究了一些我们基于gerrit的code review流程，终于明白了为何会有feature远程分支。这一切都与git的分支模型有关。期间，我在一个英文博客上看到了一篇关于git分支模型的介绍，看完后觉得不错，对其进行简要地整理，以呈现给大家。 分权集中下图中心的仓库，是我们建立并在使用的仓库，具有分支模型，其通常会被认为是“真正的中心仓库”。然而，事实上，其仅仅是被认为是中心仓库而已，因为git作为一个分布式版本控制系统（DVCS），在技术层面并不存在哪个仓库是中心仓库。而这个被认为是“中心”的仓库，我们更愿意称之为origin，这个名字对于所有git用户都是很熟悉的。 每个开发者都会从origin进行pull或向其进行push操作。但是除了与origin具有push-pull关系之外，开发者们还可能从其他同级的伙伴那里pull最新的改动，从而形成一个sub team。比如，对于两个以上的开发者，在过早地向origin推送开发进展之前，其可以开辟一个新的feature分支来共同工作。如上图所示，存在着这样几个开发小组：Alice &amp; Bob，Alice &amp; David，Clair &amp; David。 从技术角度而言，这仅仅意味着Alice定义了一个远程仓库，名字是Bob，其指向了Bob的仓库，反之亦然，仅此而已。 主分支归根到底，开发模型也受到了上述思想的影响。在中心仓库中，在其无限的生命周期中，始终存在着两条主分支： master develop 大家对origin上的master分支应该并不陌生。而另一个与之平行的分支，我们称之为develop分支。 origin/master：在这个分支上，源代码的HEAD指针的指向始终都是就绪/可发布的产品状态。 origin/develop：在这个分支上，源代码的HEAD指针的指向始终都是下一个版本的产品状态。 当develop分支的源代码到达某一个可发布的稳定点时，所有的改动都应该合并到master分支，然后打上版本的tag标签。 因此，每次将改动合并至master分支时，意味着一个新版本的诞生。我们往往对这个过程控制得非常严格。所以每次master分支上有commit时，我们都应该使用git hook脚本来自动编译、发布软件至产品服务器上。 支持分支与主分支master、develop相邻的则是各种支持分支，用于帮助团队成员之间进行平行开发，跟踪功能，准备产品发布以及帮助修复在线产品的一些Bug。与主分支不同，这些分支总是具有有限的生命周期，因为它们最终都是要被删除的。 我们可能用到的几种不同的支持分支： Feature分支 Release分支 Hotfix分支 上述的每一个分支都具有特定的目的，并且必须遵守严格的规则。比如：哪些分支可以是它们的源头分支，哪些分支必须是它们的合并目标。 当然，从技术角度来说，这些分支并没有什么特殊之处。所谓的分支类型只是我们根据如何使用它们而进行分类的。 Feature分支规则： 可以源自develop分支必须合并到develop分支命名：除master，develop，release-*，hotfix-*之外 Feature分支（也称：topic分支）用来为即将发布的版本或更远的版本开发新的feature。当开发一个新的功能的时候，我们不知道这个功能会被纳入哪个目标版本。Feature分支的本质就是，只要该功能处于开发阶段，feature分支就会存在，并最终会被合并至develop分支（以确保将新功能添加到即将发布的版本中）或者丢弃（在实验失败的情况下）。 Feature分支通常只存在与开发者自己的仓库中，而不是origin。 创建feature分支当开始开发一个新的功能时，需要从develop主分支中开辟一个新分支。1$ git checkout -b myfeature develop //表示切换到一个新的分支“myfeature” 将完成的功能纳入develop完成的功能可以合并至develop分支，以加入即将发布的版本之中。1234$ git checkout develop //切换至develop分支$ git merge --no-ff myfeature //$ git branch -d myfeature //删除myfeature分支$ git push origin develop –no-ff选项会在合并分支时创建一个新的commit对象，即使合并可以是一次fast-forward操作。这可以避免丢失feature分支的历史存在信息，并将该feature分支上的所有commit放在在一起。 如上图所示，相比较而言，后面一种情况是不可能从git历史记录中看到哪些提交对象一起实现了一个功能，你必须手动读取所有日志信息。在后一种情况下，恢复整个功能（即一组提交）是非常困难的，而如果使用了–no-ff选项，则很容易实现。 当然，这会创建一些空的commit对象，但收益远大于成本。 Release分支规则 可以源自develop分支必须合并到develop分支和master分支命名：release-* Release分支用于支持准备新的产品版本，它们允许对版本进行小错误修复和元数据准备（版本号，构建日期等）。通过在Release分支上进行所有这些工作，develop分支会被清理以接收下一个大版本的功能。 当develop分支达到了新版本的期望状态时，即可从develop分支开辟新的release分支。当然，必须要等到所有待发布的功能合并至develop分支之后才可以。 正是在release分支的开始，即将发布的版本会被分配版本号。直到这一刻起，develop分支“下一个版本”的改动。但是“下一个版本”会变为0.3还是1.0，需要等到release分支开始才知道。这是在release分支开始时，由版本规则决定的。 创release分支Release分支从develop分支创建而来。例如，1.1.5版本是当前的产品版本，我们即将有一个大的版本。develop已经为“下一个版本”准备就绪了，并且我们已经决定这将成为1.2版本（而不是1.1.6或2.0）。所以我们开辟一个分支，并予以相应的版本号。123$ git checkout -b release-1.2 develop å$ ./bump-version.sh 1.2 $ git commit -a -m "Bumped version number to 1.2" 结束release分支当release分支的状态已经准备好成为y一个真正的版本，需要完成一些操作。首先，将release分支合并至master分支（master上的每一个commit都是一个新的版本）。然后，master上的commit必须被打上标签，以便参考历史版本。最后，将在release分支上作出的改动合并到develop分支上，以便未来的版本还包含这些错误修复。 12345678910// step 1$ git checkout master å$ git merge --no-ff release-1.2// step 2$ git tag -a 1.2// step 3$ git checkout develop$ git merge --no-ff release-1.2// 完成后，我们可以将release分支删除$ git branch -d release-1.2 Hotfix分支规则 可以源自develop分支必须合并到develop分支和master分支命名：hotfix-* Hotfix分支与release分支非常相似，其也是用于为新的产品版本做准备，尽管是计划之外的。它们是对发布版本的不良状态作出的回应。当产品版本中的一个关键bug必须要被修复时，可以从master分支上相应的tag标签中开辟一个hotfix分支。 Hotfix分支的本质是可以使develop分支上的工作得以继续，而另外有人进行bug修复。 创建hotfix分支Hotfix分支从master分支创建而来。例如，1.2版本是当前产品的版本号，正在在线运行，由于服务器bug出现了一些问题。但是develop分支上的改动还不稳定。我们需要开辟一个hotfix分支来进行bug修复。 12345$ git checkout -b hotfix-1.2.1 master$ ./bump-version.sh$ git commit -a m "Bumped version number to 1.2.1"// 修复bug并commit$ git commit -m "Fixed server production problem" 结束hotfix分支当完成bug修复之后，hotfix分支需要合并到master分支，当然也需要合并至develop分支，这与release分支是非常相似的。 123456789// step 1: 合并至master，打上版本标签$ git checkout master$ git merge --no-ff hotfix-1.2.1$ git tag -a 1.2.1// step 2: 合并至develop$ git checkout develop$ git merge --no-ff hotfix-1.2.1// step 3: 删除hotfix分支$ git branch -d hotfix-1.2.1 这里有一个例外需要注意，当一个release分支当前还存在时，hotfix分支的修改应该合并至release分支，而不是develop分支。因为release分支完成后，需要合并至develop分支。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS View Controller概览]]></title>
    <url>%2F2017%2F08%2F27%2Fios-viewcontroller-introduce%2F</url>
    <content type="text"><![CDATA[引用 在斯坦福CS193p课程中，白胡子老教授首先介绍了iOS开发中的MVC软件设计模式，这是因为iOS应用即采用此种设计模式。如下图所示，MVC模式将软件分为三个部分： Model：数据存储层 View：视图展示层 Controller：逻辑控制层 MVC模式隔离了视图层和数据层，两者必须以控制层作为中介实现交互和通信。实际的iOS应用一般都是MVC模式的嵌套组合实现，如下图所示。其中，控制层是由UIViewController类及其子类（如：UITableViewController、UINavigationController、UITabBarController）的实例实现的。UIViewController自带一个根视图层（即view属性），以便添加和操作用户自定义的视图层。当然，我们也可以在UIViewController中定义数据层。这是因为UIViewController需要这样的接口来连通并控制M和V。但是，好的设计会尽量将数据层和视图层从UIViewController中解耦分离出来。 视图控制器 分类前面说到，实际的app采用MVC嵌套组合的设计模式，以此为据，app中至少包含一个视图控制器。这些视图控制器管理着app中所有的事务，包括：视图管理、事件处理、视图控制器之间的调度等等。 既然视图控制器具有可以嵌套和组合，那么肯定有部分视图控制器可以充当视图控制器的容器。事实上，视图控制器的确可以分为以下两种： 内容视图控制器（Content View Controller）：用于管理app内容的视图控制器，也是最常用的视图控制器。 容器视图控制器（Container View Controller）：作为其他视图控制器的容器，并以某种方式呈现这些视图控制器及其内容。 内容视图控制器内容视图控制器是最常用的元素，常见的有三种（后两者是前者的子类）： UIViewController UITableViewController UICollectionViewController 常用的在大多数情况下，app上的一个页面就是由一个视图控制器所展现的。内容视图控制器的主要任务包含： 更新视图内容，通常是响应底层数据的变化 响应用户与视图的交互 缩放视图、管理布局 容器视图控制器容器视图控制器使用属性viewcontrollers来存储对视图控制器的引用，并且不对容器中视图控制器的数量作限制。最常见容器视图控制器的有两种（两者均是UIViewController的子类）： UINavigationController UITabBarController 关于viewcontrollers属性，UINavigationController采用的是stack结构，UITabBarController采用的是array结构。不同的数据结构，对视图控制器的调度形式也不同。 下图所示为UINavigationController的应用示例，UINavigationController采用stack的方式调度页面（即视图控制器）。 三个视图控制器视图的顶部是UINavigationController的导航栏，当切换到某个内容视图控制器时，导航栏的样式可以由该视图控制器进行配置。 下图所示为UITabBarController的应用示例，其对页面的调度和操作array一样灵活，视图的底部有四个标签，对应着4个独立的视图控制器，可任意切换。 视图管理视图管理器，顾名思义，其有一个重要的作用就是：管理视图的层次结构。每个视图控制器都有一个根视图，其中包含了视图控制器的所有内容，可通过view属性获取。通过该属性，我们可以添加更多视图。内容视图管理器自身管理其所有的视图；容器视图管理器则采用分治的方式，通过子视图控制器来进行视图管理。下图所示，代表性地展示了内容视图控制器及其视图之间的关系。 数据管理在MVC设计模式中，视图控制器作为承担着数据和视图通信的中介角色。通过UIViewController的内置及自定义的属性和方法，可以完成控制器需要承担的任务。如下图所示，为视图控制器与数据、视图的关系示意图。 在实际开发中，我们始终应该清晰地分离视图控制器和数据对象。视图控制器应该扮演逻辑控制的角色，而应该减少数据管理的角色。 为了处理数据管理，很多设计使用了MVVM的设计模式，这种设计添加了一个View Model层来对来自Model层的原始数据进行处理，从而提供给Controller，使其可以直接使用。 生命周期如下图所示为视图控制器的生命周期，其中与视图view相关的步骤较多。 init init阶段，通常只初始化比较关键的数据，而不会在该阶段对view进行初始化。 loadView loadView阶段，通常只初始化view viewDidLoad 此时view不在为nil，适合创建一些附加的view及控件。 viewWillAppear 该阶段view即将被添加到app的window对象之上。 viewDidAppear 该阶段view已经被添加到app的window对象之上，用户可以看到软件的视图，此时可以进行动画操作。 为了进一步了解添加到根视图view上的用户附加视图，我分别在loadView和viewDidLoad阶段添加了一个视图，以观察视图控制器的生命周期，如下所示，为部分代码示例。123456789101112131415161718- (void)loadView &#123; [super loadView]; NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd)); UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(100, 400, 100, 50)]; button.backgroundColor = [UIColor blueColor]; [button addTarget:self action:@selector(buttonPressed) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd)); self.testView = [[TestView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)]; self.testView.backgroundColor = [UIColor grayColor]; [self.view addSubview:self.testView];&#125; 下图为UINavigationController中的一个视图控制器生命周期执行情况。生命周期符合前面的描述，此外还可以发现，在视图控制器中添加自定义的视图，则生命周期中还会多出两个步骤： viewWillLayoutSubviews viewDidLayoutSubviews 仔细观察，还可以发现: viewWillLayoutSubviews和viewDidLayoutSubviews均出现在viewWillAppear之后。在添加视图的时候，每添加一个视图就会执行这两个步骤，而移除视图时直接移除根视图直接移除根视图。 (完)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[毕业旅行——泰国]]></title>
    <url>%2F2017%2F06%2F16%2Ftailand%2F</url>
    <content type="text"><![CDATA[游记 Day 06月3日，周六昨天下午顺利通过硕士论文答辩，必须得感谢各位老师和同学们这三年的关照才得以顺利毕业，和大家相处的三年是非常快乐的。 今天是辩结束后的第一天，三年来从未像此刻一样如此轻松。遂准备本次泰国之行最后的相关事项，即如何去机场啊、酒店机票的订单截图啊之类的。 机票的时间是21:55，晚饭过后在未名湖畔小散了一会儿步，便启程出发，差不多8点多达到首都T2航站楼。 我们在淘宝上订了泰国的7天Happy电话卡，发货方式是机场自取。自取的地点是在国际航班出发点的某个柜台，然而我们去泰国的航班并不是直达，而是从昆明转机至清迈，显然首次航班是国内航班。电话给淘宝客服，居然还不能送出来，也罢，取消了订单，到当地再买happy卡吧。 接下来又发生了一件意想不到的事情：取机票时，柜台说妹纸机票的订票姓名拼音与护照不符，WTF？！打开东航APP上的订单，居然还真拼错了！尴尬！遂致电客服，客服说会尽快修改，但不保证在确定时间内完成。没办法，只能等。离办理值机只剩不到二十分钟了，心情自然也是极度忐忑。遂再次致电客服，客服确认了好几便，说姓名的拼音是正确的，看来是改好了。最终也是有惊无险地办理了值机，顺利登上了飞机。有了这次遭遇，下次应该就长心眼儿了吧。 Day 16月4日，周日首趟航班差不多凌晨1点达到昆明，下机后先找值机柜台，这个点柜台都已经下班了，需要等到凌晨五点。我们航班的时间是6:30，按照值机时间是来得及的。于是便寻找游客休息室，然而大厅中已经全是游客，更气的是不少人一个人占了多个座位在睡觉，不少人席地而坐，素质啊素质。 席地打盹，好不容易熬到5点，便去值机柜台办理值机。没想到办理国际航班的值机服务，不仅要查看护照、签证，还要查找在目的国的酒店订单信息，返程机票以及钱包里的现金。所幸除了现金还需再取，其他的我们都符合要求。昆明机场的确也是非常大的，据说是东航的大本营，果不其然，机场上一排排的飞机基本都是东航的。 第二趟航班差不多经历两个多小时，抵达清迈。刚下飞机没多久，手机时间便自动调整为了泰国时间，比北京时间早1个小时整。清迈机场真心非常小，国内随便找个机场都不知道要比它高几个档次。机场大厅里各个角落的指示牌居然同时有三种语言：泰语、英语、汉语，中国游客对于清迈旅游产业的影响可见一斑。 出了机场，便致电给平那科酒店，以寻求接机服务。学了那么多年的英语，从这一刻开始初见成效了。大约十分钟，接机小哥便来到了机场，下车便用很流利的中文跟我确认身份，我们一度以为他是中国人。地图上，平那科酒店与机场的直线距离只有几公里，然而实际却拐了很多弯才到达酒店，这是因为泰国的很多道路是单行道，正是这单行道后面也让我们吃了不少苦。 抵达平那科酒店大概是在泰国时间的上午8点多，由于一晚都没睡，总感觉现在是下午。Check in的时候，前台小哥便用流利的中文和我们交谈，说房间需要等到12点才会有，可以让我们先把行李寄存在前台，出去玩一会儿。遂即我们便出门去找711超市买happy卡。 由于时间还非常早，我们便打算打乱一下计划，逛一逛宁曼路街区。泰国的环境真的非常好，空气里透露着一股泥土的气息，蓝天和云彩的配合简直完美。 差不多到了中午，我们就近找了一家餐馆就餐，点了心心念念的芒果糯米饭和泰式酸辣海鲜河粉。第一次吃到芒果糯米饭的时候，汗毛都竖了起来，这糯米真的是入口即化！事实证明，这家店的芒果糯米饭是我们在泰国吃过的所有芒果糯米饭中最赞的！唯一遗憾，没记住店名… 饭后便回酒店准备办理入住。环顾酒店大厅，其装潢还是相当不错的。 前台告诉我们行李都已经搬进了房间，对此我是震惊的。在这一方面，国内同样价格的酒店可没这个待遇。我们订的房间大约200多一晚，房间的设施非常完备，吹风机、冰箱、热水壶、电视、衣柜什么都有，性价比非常高。房间的空间很大，装修也是简约大方，不多说，推荐推荐！ 这一天真实特别漫长，当然也是非常累，回房便是洗澡睡觉。恰好老天爷眷顾，外面开始下起了阵雨，等到三点左右我们醒来，雨也停了，气温也降了，给力呀！ 遂即按照计划步行去古城，路上遇到些水果摊显然是管不住自己的手的，榴莲、芒果、红毛丹，买买买。 酒店到古城西门大约2公里，期间我们还晃悠进了一个公园，似乎是个马戏团，外面还摆着演出广告。就这样边吃边看边走，最终大概花了1个小时才到达古城。 今天是周日，古城内会有周日夜市，这也是我们今晚来古城的原因。我们到古城内的街道时，小贩们已经开始陆续占领街道，支帐篷，挂吊灯，备战夜市。 显然小吃是我们此行的重要任务。 穿着拖鞋从酒店走到古城，着实累脚。路中央，一位马杀鸡小哥在盛情揽客，于是就此躺了半小时，腿脚也是满血复活。不吹不黑，马杀鸡，好牛逼！ 夜幕降临之前，我们尽可能地多逛逛古城。最后来到一个广场，这似乎是古城的行政中心。 夜市的吊灯陆续被点亮，游客也越积越多。我们沿着夜市，边吃边逛，挑选购买看上眼的异国小商品。差不多到7点半，我们回到了夜市的入口，搭了辆Tuk-Tuk，回到了平那科。 Day 26月5日，周一平那科酒店是提供早餐的，从8点提供至10点。酒店的一楼大厅便是自助餐厅，餐厅的布局很漂亮，有室内餐桌和室外餐桌。食物也非常丰盛，主要以西餐和泰式菜为主。 安静地享受完早餐，便托前台小哥帮忙租辆摩托车。五分钟后，租车小哥便风尘仆仆地赶来了。用蹩脚的英语与小哥聊了聊，签了合同，抵押了护照，然后预支了一天的租金300B。小哥还提醒我，归还摩托车时需要加满油，need be full，need be full。第一次开摩托，既兴奋又紧张，戴好头盔，便以每小时30公里的速度飞奔古城，游览泰国的知名寺庙。 我们在古城内依次逛了帕辛寺、清迈寺、契迪龙寺等寺庙。说实话，这些寺庙的风格基本上是一致的，只是规模和颜色稍有差别。 很快就到了中午，借着谷歌地图我们来到了大众点评上口碑不错的Mogo Tango餐厅。该餐厅以甜食和冰淇淋为主，平嘴而论，口味对得起评分，可以可以。 因为我们预定了下午一点半去素贴山玩，所以没在餐厅久留，吃完便回酒店睡午觉。 大概一点半左右，导游和司机便来接我们。导游的中文很不错，长得很像张家辉，很可惜没和他合影。 此趟行程的第一站是位于素贴山最高峰的蒲屏皇宫。蒲屏皇宫有点类似于国内的承德避暑山庄，都是皇室避暑的行宫。蒲屏皇宫里面种满了各种花草，环境也是相当的静谧，显然是个避暑好去处。 素贴山的下一站便是双龙寺，这里导游给我们讲了讲双龙寺的来历，并参观了里面的一个舍利塔。在这里可以鸟瞰整个清迈，是一个非常值得推荐的旅游景点。 半日游结束后，导游便送我们回来。我们在宁曼路的玛雅购物中心下了车。玛雅购物中心应该是清迈最大的购物商场，有6层，内部设施非常现代化。我们在这里找了一家游客较多的餐厅就餐。在这里，第一次品尝了正宗的泰国菜。泰国菜，特别是汤类菜肴，基本都会放香茅。这玩意儿味道很重，吃起来就像在吃化妆品，真心不符合中国人的口味。 Day 36月6日，周二7点起床，早早地便在餐厅吃完了早餐，然后就是等待导游来接我们去拜县一日游。拜县位于清迈西北方向100多公里，地处山区，一趟行程就要经历700多个弯道。对此，我们不仅准备了晕车药，还有晕车贴。一路上，不仅上下颠，还左右晃，难受得无法形容。没多久，minivan里就有游客交代了早餐。在车上煎熬了40分钟平地和2小时山路，终于抵达拜县。 此次拜县之旅一共有8个景点，我们去了其中的7个。首先是小树屋。 其次是二战桥。 二战桥之后便是草莓园。 随后抵达小黄屋，据说是《爱在拜城》的取景地，我表示没看过… 午饭前终于达到了期待已久的大树秋千。 等大家都排完队与大树秋千合影之后，便来到了“中华饭店”就餐，肘子、青菜豆腐汤、醋溜土豆丝…几道菜而已。据说此地是云南村，此地大量土著都是华裔，解放时期国共内战，很多人逃离至此。导游本人也是在泰国的华裔二代，所以中文说得溜也是有原因的。 午饭过后在饭店附近玩了玩土著的射箭。稍事休息，便再次踏上旅程。之后依次游览了粉色房子、倒立屋、农场。 差不多下午两点，景点游玩到此结束。然后便是回清迈，又是经历700多个弯。在我看来，拜县就是那种去一次再也不想去的地方，来回1400多个弯！。在快离开山区时，我们在路边买了芒果。半斤重的一个大芒果，折合成人民币仅需1元！买不了吃亏，买不了上当！ 差不多四点多，我们到达玛雅购物中心。从玛雅购物中心步行至平那科酒店大概需要20分钟，在回酒店的路上，看到街边有家店叫“我爱冬阴功”，看着似乎还不错，便进去点了餐。 Day 46月7日，周二在清迈这几天每天都是起早，今天准备放松一下，自由发挥。吃完早餐便租了摩托车，准备从古城西边出发，经过北部，再至东部，最后从古城东门穿越古城返回。清迈的道路真的令人很痛苦，大量的单行单，我们从古城东北角南下时基本都是在单行道上逆行。 好不容易在中午抵达古城，在一个寺庙对面找了家餐馆就餐，一份芒果糯米饭，一份冬阴功汤。期间，又下起了太阳雨。好在我们吃完，雨也停了。 清迈的下午艳阳高照，我们还是决定回酒店等到傍晚再出来。待到6点多，我们赶到古城北部的凤飞飞猪脚饭餐馆，毕竟这家店也算是名声在外。 Day 56月8日，周三凌晨4点起床，因为要赶6点50的航班，飞往甲米。在前台刚刚退完房，门口的送机小哥就迎了上来，非常准时，靠谱！为了感激小哥半夜起床给我们送机，我们也给了他20B，以示感激。 出了甲米机场之后，便步行了大概300米，来到minivan的候车点。大约1点半，minivan准时出现在候车的凉亭前面。Minivan中已经是满满一车人了，我们坐在最后面，虽然长途奔波很是难受，但是相比于拜县的旅程真的无比轻松了。行车1个半小时后便来到了兰塔岛的海峡入口处，经历半小时的车船联运后，抵达兰塔岛。司机依次运送乘客，我们车船联运后20分钟抵达CoCo Lanta Resort。 到达酒店，前台便是热情招待，递上两杯橙汁。CoCo Lanta的房间都是一个个的独栋小别墅。我们入住时发现只有很少的游客入住了，也许是淡季的原因吧。说实话，我们当时是有些后悔来到兰塔岛的。因为与清迈相比，这里显得十分凄凉，酒店附属的酒吧处于休业中，泳池边的遮阳伞都是收着的，躺椅、泳池也没有人。 经过一天的奔波，再加上心理预期上的落差，当时的心情是非常低落的，晚饭也没不想去那个酒店的餐厅去吃，转而去了附近的一家711超市买了泡面，零食等。傍晚，在海边稍许逛了一会，心情也有所复苏。 Day 66月9日，周四早晨9点匆忙来到前台大厅，等待今天出海一日游的minivan。上了车之后没多久便来到了汽艇停靠的港口。港口中泊着一艘红色汽艇，汽艇上的工作人员都很酷，黑皮肤（当然是亚洲人）、黑墨镜、反鸭舌。 汽艇在驶出海湾过程中经过静谧美丽的兰塔红树林，导游说红树林里有猴子，但是我们运气不够好，没遇到。 大约10点，到达Talabeng岛。汽艇靠近海蚀洞穴，以便大家游至洞穴中去。 探索完海蚀洞穴后，汽艇来到了BUBU岛。在BUBU岛沙滩自由浮潜20分钟。 之后便前往奈岛，奈岛是这几个岛中最美的岛屿。 靠近奈岛近海处，导游便带领我们下海浮潜。浮潜了大约半小时，便上岸就餐。 午餐过后便是1个半小时的海滩休闲时光。 1点多，我们离开美丽的奈岛，前往MA岛和CHUEK岛，在汽艇上欣赏海岛屿风光。 汽艇在海上漂游时，偶然发现一片海域的水特别清澈，于是导游带领我们下海浮潜。这里的珊瑚礁特别美丽，由各种色彩斑斓的海鱼，还有海胆。可惜没有租用GoPro进行水下摄影。 一段美妙的浮潜之旅结束了本次出海。早晨汽艇从兰塔岛的东岸南下，返程从兰塔岛的西岸飞驰回港。 Day 76月10日，周五今天的计划是环岛游。早晨睡个懒觉起床，然后到海滩吹了一下海风。 到了10点半左右，从酒店租了辆摩托车，价格要比清迈便宜，只要200B一天。我们的目的是前往老镇吃海鲜。 CoCo Lanta Resort在兰塔岛的西岸中部，老镇则在兰塔岛的东岸南部。摩托一路狂奔，花了一个小时抵达老镇。我们寻找昨天同行游客推荐的Fresh Restaurant。餐厅很不错，架在海上。我们选了一个临海的餐桌就座。服务员递上菜单，菜单上菜品的价格相对北京的海鲜价位而言是比较便宜的。显然，来到海岛当然是点海鲜咯。 饭后，我们来到了餐厅旁边的小港口转了转。之后便前往兰塔岛最南部的灯塔，一路上的山路蜿蜒陡峭，并且道路边树林密布。随着行程的深入，道路原来越窄，车辆也没了。后来开到大路的尽头，还没到达灯塔，我们便掉头回去。昨天那位游客也说路上很阴森很可怕，的确属实。 傍晚照例先去了711超市，然后回来煮泡面。不同的是，今晚是在海边吃的泡面。看着日落，迎着海风，惬意的傍晚。 夜色渐浓，想到远离灯火的海边是绝佳的观星地点。于是，下载了一个“星空”APP，对照着星空寻找星座，狮子座、半人马座、室女座、天平座、大熊座（含北斗七星）、天蝎座… Day 86月11日，周六这是在岛上最后完整的一天，准备在海边度过。 早上来到海边，躺椅上有个五六十岁大爷主动与我们搭话：是中国人吗？之后便与他侃了起来，大爷还给我散烟，我委婉地拒绝了，后来便跟他推荐一些岛上的景点。直到11点，大爷包的车来了，海边这块地便被我占领了。 午饭过后，一直在海滩边躺着，期间还打了个盹儿。 直到下午4点多，海水逐渐退去，近海的礁石都显露了出来。此时是在浅海中玩耍的好时机。 临近黄昏，我们在酒店的餐厅点了一份冬阴功面、炒饭、炸软壳蟹，靠着栏杆，欣赏落日的余晖。 落日之后，便躺在海滩边的吊床中享受在兰塔最后的休暇时光。 Day 96月12日，周日今天将离开兰塔岛，早上去海滩看了最后一眼清晨的大海，将要离开时总会不舍，希望我们还能再见。 再见，CoCo。再见，Lanta。再见，Tailand。 (完)]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20个强大的Sublime Text插件]]></title>
    <url>%2F2017%2F05%2F12%2Fpowerful-sublimetext-pulgin%2F</url>
    <content type="text"><![CDATA[原文链接SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。这些非常棒的特性包括： 任意跳转（Goto Anything） 多重选择（multiple selections） 指令面板（command palette） 免打扰模式（distraction free mode） 分区编辑（split editing） 快速项目切换（instant project switch） …此外，你还可以随意地自定义更多功能。更重要的是，Sublime支持Mac、Windows和Linux等多种系统平台。 SublimeText本身已经非常强大，但是更棒的是还有大量的插件支持它，给它带来更强大的功能，这就是本文要讨论的内容。不多废话，让我们看看20个强大的SublimeText插件。 20 FTPsync 默认情况下SublimeText不具备FTP功能，如果你正在寻找能在你的SublimeText应用程序中使用的免费易用的FTP工具，你可以考虑FTPSync。这是一个非常简单的FTP同步工具，它可以控制上传目标的多重命名。 19 SASS Build SASS Build 是一个编写CSS的预处理器。这个插件可以帮助你妥善构建包括压缩选项在内的SASS文件。一旦你安装了这个插件，你可以很容易地通过按Ctrl+ B（MAC系统是 Command +B）来启动它。 18 Package Control 简而言之，这个是你在完成安装SublimeText后必须安装的东西。因为有了这个特殊的“插件”，你可以很容易地安装、升级、删除，甚至非常方便地查看你已经安装在SublimeText中的包或插件的列表。它通过菜单和对应的行为使这些过程变得非常容易和有组织。 17 Emmet Emmet（前身是大名鼎鼎的Zen Coding）是一个可以让你更快更高效地编写HTML和CSS，节省你大量时间的插件。你只需按约定的缩写形式书写而不用写整个代码，然后按“扩展”键，这些缩写就会自动扩展为对应的代码内容。 比如，你只需要输入 ((h4&gt;a[rel=external])+p&gt;img[width=500 height=320])*12 ，然后它会被扩展转换成12个列表项和紧随其后的图像。然后你就可以在此基础上再填写内容，就这么简单。 16 SublimeLinter 这个插件最近才为SublimeText3重建和发布。新版本带来了很多新的功能，而不是简单地把所有的Linter放在一个包中，开发者允许用户在升级时选择并安装自己经常使用的Linter。很明显，这可以节省磁盘空间。“更多的定制”，这对用户是很友好的。 15 SublimeEnhancements 这个插件可以给SublimeText的边栏菜单带来扩充的功能，包括：在当前工程文件夹中新建文件，移动文件或文件夹，产生文件或文件夹的副本，在新窗口或浏览器中打开，刷新等。这只是概括地说，安装后探索它更多的功能吧。 14 PackageResourceViewer 通过这个特殊的插件，会给你查看和编辑SublimeText附带的不同的包带来很多方便。你也可以提取任何给定的包。这一行动将其复制到用户文件夹，以便你可以安全地对其进行编辑。 13 Git 虽然名字看上去并不友好，但作为开发者的你肯定一眼就能明白它是干什么的。这个插件会将Git整合进你的SublimeText，使的你可以在SublimeText中运行Git命令，包括添加，提交文件，查看日志，文件注解以及其它Git功能。 12 Terminal 这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。 11 CSSComb 这是用来给CSS属性进行排序的格式化插件。如果你想保持的代码干净整洁，并且希望按一定的顺序排列，那么这个插件是一种有效解决的方案。特别是当你和其他有自己代码编写风格的开发者一同协作的时候。 10 CanIUse 如果你想检查浏览器是否支持你包括在你的代码中的CSS和HTML元素，那么这是你需要的插件。所有你需要做的就是选择有疑问的元素，插件将为你做其余的事情。 9 Alignment 这个插件让你能对齐你的代码，包括 PHP、CSS 和 Javascript。代码看起来更简洁和可读，便于编辑。您可以查看下面的图片来明白我说的意思。 8 Trimmer 你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格。 7 ColorPicker 如果你经常要查看或设置颜色值，这个插件可以很方便地调用你本机的调色板应用。这是一个双向的功能，你既可以在调色板中选择一个颜色，然后按“确定”按钮把该值填写到 SublimeText 中活动文档的当前位置，也可以在活动文档中选择一个颜色的值，按此插件的快捷键就会在显示的调色板中定位到该值所对应的颜色。 6 MarkdownEditing SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。 5 FileDiffs 这个插件允许你看到SublimeText中两个不同文件的差异。你可以比较的对象可以是从剪贴板中复制的数据，或工程中的文件，当前打开的文件等。 4 DocBlock DocBlockr 可以使你很方便地对代码建立文档。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。 3 定制主题 拥有不同的主题可以触发创意和想法，你可能想使用这些插件来实现不同的主题，带来更好的和令人兴奋的前景。 SpaceGray Centurion 2 Snippets Snippets，你一定已经听说了，可以帮你快速书写代码。但它不是像上面提到的插件那样使用缩写，它是重用代码块以节省您的时间。你甚至可以创建自己的代码段，这完全取决于你自己。 1 语法支持 如果有一个SublimeText本身所带语言包不包含的语言，它就无法显示适当的语法高亮。这些语言包括LESS，Sass，SCSS，Styls和Jade（或其它）。如果您正在使用这些语言，你可能要安装它们的语法插件。 LESS Sass SCSS Stylus Jade]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(5)——前端综合]]></title>
    <url>%2F2017%2F05%2F01%2Fit-interviews005%2F</url>
    <content type="text"><![CDATA[XSS攻击 原理: 攻击者往web页面里插入恶意html标签或者javascript代码 示例: 攻击者在论坛中放一个看似安全的连接，骗取用户点击后，窃取cookie中用户私密信息； 防范: (1) 对用户输入的地方和变量要检查长度、对”&lt;”, “&gt;”, “;”, “‘“等字符过滤 (2) 任何内容写入页面之前必须加以encode，避免不小心把html tag弄出来 (3) 避免直接在cookie中泄漏用户隐私，如email、密码等 (4) 通过cookie和系统ip绑定来降低cookir泄漏后的风险 (5) 尽量采用POST而非GET提交表单 CSRF攻击 原理: XSS是CSRF的一种实现方式。但XSS是获取信息，不用提前知道用户的页面代码和数据包；CSRF是代替用户完成指定的动作，需要知道用户页面的代码和数据包 示例: 1. 登陆受信任网站A，并在本地生成cookie；2. 在不登出A的情况下访问危险网站B 防范: (1) 在客户端增加伪随机数 (2) 使用验证码 SQL注入 AJAX (1) 创建XMLHttpRequest对象，即异步调用对象(2) 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL以及验证信息(3) 设置响应HTTP请求状态变化的函数(4) 发送HTTP请求(5) 获取异步调用返回的数据(6) 使用Javascript和DOM实现局部刷新 JSONP 原理 利用script标签没有跨域限制的”漏洞”来达到与第三方通信的目的。当本站需要通信时，本站脚本创建一个script元素，地址指向第三方的API，形如: 1&lt;script src="http://www.example.net/api?param1=1&amp;param2=2"&gt;&lt;/script&gt; 并提供了一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装(json with padding)，形如： 1callback(&#123;"name": "baochuquan", "gender": "male"&#125;); 这样浏览器就会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 CORS CORS与同源AJAX通信没有差别。关键是需要服务器支持CORS接口。 简单请求 条件 (1) 请求方法- HEAD - GET - POST (2) HTTP头信息超出以下几种字段- Accept - Accept-Language - Content-Language - Last-Event-ID - Content-Type: (只限于application/x-www-form-urlencodeed、multipart/formdata、text/plain) 请求 浏览器发现此次跨域AJAX请求是简单请求，自动在头信息中添加Origin字段。 响应 (1) Access-Control-Allow-Origin: 必须(*或请求时Origin字段的值) (2) Access-Control-Allow-Credentials: 可选(是否允许发送cookie) (3) Access-Control-Expose-Headers: 可选(cache, ) 跨域的方法【参考】 二级域名不同 (1) Cookie 两个网页一级域名相同，二级域名不同，浏览器允许通过设置document.domain共享cookie。服务器可设置cookie所属域名 document.domain = &apos;example.com&apos; document.cookie = &apos;key=value&apos; (2) iframe 类似cookie, 一级域名相同，二级域名不同，可以通过浏览器设置document.domain共享相互获取DOM 父窗口获取子窗口: document.getElementById(&quot;iframe&quot;) 子窗口获取父窗口: window.parent.document.body 完全非同源 (1) 片段标识符(URL#之后的部分) 父窗口写子窗口: document.getElementById(&apos;iframe&apos;).src = originURL +&apos;#&apos; + data; 子窗口写父窗口: parent.location.href = target + &apos;#&apos; + data; (2) window.name 同一个标签页 window.name = data location = &apos;http://newurl.com&apos; windodw.name / var data = document.getElementById(&apos;iframe&apos;).contentWindow.name (3) window.postMessage var popup = window.open(url); popup.postMessge(data, url); (4) localStorage 通过window.postMessage来操作localStorage (5) JSONP(只能是GET请求) 网页通过添加一个&lt;script&gt;元素向服务器请求JSON数据；服务器收到请求后将数据放在一个指定名的回调函数中传回来 (6) WebSocket WebSocket是一种通信协议，使用ws://(非加密)和wss://(加密)作为协议前缀，不实行同源策略，只要服务器支持即可进行跨域通信。服务器根据请求中的Origin字段判断请求源。 (7) CORS(可以是任何请求类型) 和同源的AJAX一样。关键是需要服务器实现CORS接口。 (8) 设置服务器代理页面 cookie、session cookie数据存放在浏览器上；session数据存放在服务器上； cookie安全性低；session相对安全； 单个cookie保存的数据不能超过4KB，很多浏览器会限制一个站点只能保存20个cookie session会在一定时间内保存在服务器上。当访问增多，会占用服务器的性能 cookie、sessionStorage、localStorage 特性 cookie localStorage sesstionStorage 数据生命周期 可设置失效时间，默认关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话（当前标签页）下有效，关闭页面或浏览器后被清除 数据容量大小 4KB左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中 仅在客户端中保存 仅在客户端中保存 如何实现浏览器内多个标签页之间的通信 cookie、locaStorage sessionStorage只能在一个标签页内传值 Get、Post的区别 GET: 向服务器请求数据，请求可在url中；长度有限(2KB)POST: 向服务器提交数据，每次刷新或后退会重新提交，Post请求数据封装在http请求的首部里 viewport JS延迟加载的方式 defer、async、动态创建DOM方式（JSONP）、AJAX JS阻塞特性 所有浏览器在下载JS时，会阻止一切活动，如其他资源的下载、内容的呈现等。直到JS下载、解析、执行完毕才开始继续并行下载其他资源并呈现内容。 JS无阻塞加载具体方式 (1) 将脚本放在底部 link放在head中；script标签放在/body前(2) 成组脚本 限制页面的script总数。是用于内嵌脚本和外部脚本(3) 非阻塞脚本 等页面加载完后，再加载JS代码 XML、JSON的区别 特性 XML JSON 数据体积 大 小 数据交互 较复杂 易解析 数据描述 好 差 传输速度 慢 快 减少页面加载时间的方法 (1) 优化图片(2) 图像格式的选择（GIF: 提供的颜色少，可用在一些对颜色要求不高的地方）(3) 优化CSS（压缩合并CSS）(4) 网址后加斜杠（www.example.com/目录，会判断）(5) 表明高度和宽度(6) 减少HTTP请求（合并文件、合并图片） WebSocket 一种新的协议(ws)，允许服务器和浏览器端进行全双工通信 SSE 一种轻量级的协议，基于HTTP，浏览器向服务器发送一个HTTP请求，然后 服务器不断单向地向浏览器推送信息 Comet【参考】 定义: 基于HTTP长连接的“服务器推”技术 实现模型 (1) 基于AJAX的长轮询方式1. 服务器会阻塞请求直到有数据传递或超时才返回 2. 客户端JS响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接 3. 当客户端处理接收的数据、重新建立连接时，服务器端可能有新数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端一次取回当前服务器端所有的信息 (2) 基于iframe以及htmlfile的流方式1. 在HTML中嵌入一个隐藏的iframe，将其src属性设为对一个长连接的请求，服务器就能源源不断地往客户端输入数据 2. 服务器端返回对客户端JS函数的调用，类似于JSONP 缺点：某些浏览器下端的进度栏显示加载未完成，且标签页图标旋转——采用htmlfile解决 服务器推送的方式 (1) Comet：基于HTTP长连接的服务器推送技术(2) 基于WebSocket的推送方案(3) SSE：服务器推送数据新方式 预加载、懒加载（延迟加载）【参考】 懒加载（延迟加载） 原理: 延迟加载图片或符合某些条件时才加载某些图片 意义: 作为服务器前端的优化，减少请求数或延迟请求数 实现方式 (1) 纯粹的延迟加载，使用setTimeout或setInterval进行加载延迟 (2) 条件加载，符合某些条件，或触发了某些事件才开始异步下载 (3) 可视区加载，即仅加载用户可以看见的区域，一般会在距用户看到某些图片前一定距离就开始加载 预加载 原理: 提前加载图片，当用户需要查看时可以直接从本地缓存中渲染 意义: 牺牲服务器前端性能，换取更好的用户体验 实现方式 (1) CSS(background) (2) JS(image) (3) HTML() 渐进增强、优雅降级 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级: 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 浏览器缓存【参考01】【参考02】 定义: 浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器可以直接从本地磁盘加载文档。 优点 (1) 减少了冗余的数据传输 (2) 减少了服务器的负担 (3) 加快了客户端加载网页的速度 分类 缓存协商(协商缓存) 彻底缓存(强缓存) 缓存启动过程(当浏览器在第一次请求发生之后，再次请求时) (1) 浏览器先获取该资源缓存的header信息，根据其中的expires和cache-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信； (2) 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息(Last-Modified/IF-Modified-Since、Etag/IF-None-Match)，由服务器根据请求中的相关header字段信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中对应的header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 强缓存 原理: 利用http返回头中的Expires或者Cache-Control两个字段来控制，用来表示资源的缓存时间 Expires: 值为一个绝对时间的GMT格式的时间字符串。缺点在于浏览器端和服务器端的时间可能不一致 Cache-Control: 利用该字段的max-age值进行判断，即相对时间 max-age=3600 no-cache: 不使用本地缓存。需要使用协商缓存 no-store: 直接禁止浏览器缓存数据，每次用户请求资源都是新下载 public: 可以被所有用户缓存，包括终端用户和CDN等中间代理服务器 private: 只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器缓存 协商缓存 原理: 由服务器来确定缓存资源是否可用，所以需要标识来进行通信。第一次请求的响应头带上某个字段(Last-Modified货Etag)，后续请求会带上对应的请求字段(If-Modified-Since货If-None-Match) Last-Modified: 一个时间标识该资源的最后修改时间 If-Modified-Since: 值为Lst-Modified ETag: 检验码，保证每个资源都是唯一的 移动端性能陷阱和硬件加速【参考】 (1) 减少或避免回流、重绘(2) 尽量缓存所有可以缓存的数据(3) 使用CSS3 transform代替DOM操作(4) 不要给非static元素增加CSS3动画，浏览器的性能开销会成倍增加(5) 适当使用硬件加速，如: canvas, transform 前端优化规则【参考】 尽可能的减少 HTTP 的请求数 使用CDN（内容分发网络） 添加Expire/Cache-Control 头 启用Gzip压缩 将css放在页面最上面 将script放在页面最下面 避免在CSS中使用Expressions 把javascript和css都放到外部文件中 减少DNS查询 压缩 JavaScript 和 CSS 避免重定向 移除重复的脚本 配置实体标签 使 AJAX 缓存 性能优化方式 (1) 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。(2) 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数(3) 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。(4) 当需要设置的样式很多时设置className而不是直接操作style。(5) 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。(6) 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。(7) 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 移动端性能优化 (1) 尽量使用CSS3动画，开启硬件加速；(2) 适当使用touch事件代替click事件(3) 避免使用CSS3渐变阴影效果(4) 尽可能少的使用box-shadow和gradient————性能杀手 前端兼容性问题【参考1】【参考2】 (1) XMLHttpRequest、ActiveXObject(2) W3C盒子模型、IE盒子模型(3) 不同浏览器的标签默认margin和padding不同 - 解决方案: * { margin: 0; padding: 0; } (4) 块属性标签float后，又有横向的margin情况下，IE6显示margin比设置的大 - 解决方案: 在float的标签样式控制中加入display: inline，将其转换为行内属性 (5) 设置较小高度标签(一般小于10px)，在IE6中，IE7，遨游中高度超出自己设置的高度 - 解决方案: 给超出高度的标签设置overflow: hidden; 或者设置行高line-height小于你设置的高度 (6) 行内属性标签，设置display: block后采用float布局，又有横向margin的情况，IE6间距BUG - 解决方案: 在display: block;后面加入display:inline;display:table (7) 图片默认有间距 - 解决方案: 使用float属性为img布局 (8) 标签最低高度设置min-height - 解决方案: 如果要设置一个标签的最小高度为200px，需要进行的设置为: {min-height:200px; height:auto !important; height: 200px; overflow: visible; } (9) 透明度的兼容CSS设置 - 解决方案: CSS hack - 如: height: 300px; *height: 200px; _height: 100px; - IE6认识的hacker: _, *；IE7、遨游认识的hacker: * (10) var e = e || window.event;(11) document.documentElement.clientWidth || document.body.clientWidth(12) var target = e.target || e.srcElement(13) cursor: hand, cursor.pointer//firefox不支持hand viewport【参考】 定义: 设备的屏幕上能用来显示网页的那一块区域。viewport不局限于浏览器可视区域的大小，可以比浏览器的可视区域大，也可以比浏览器的可视区域小。默认情况下，移动设备上的viewport大于浏览器可视区域。 CSS中的像素是一个抽象的单位，在不同的设备或不同的环境中，css中的1px代表的物理像素是不同的。 window.devicePixelRatio属性: 设备物理像素和设备独立像素的比例，即devicePixelRatio = 物理像素/独立像素。 三个viewport理论 (1) layout viewport: 浏览器默认的viewport，可通过document.documentElement.clientWidth获取，默认大于浏览器可视区域的宽度 (2) visual viewport: 代表浏览器的可视区域，可通过window.innerWidth获取，但在Android 2, Opera mini, UC无法获取 (3) ideal viewport: 没有固定的尺寸，不同的设备具有不同的ideal viewport。所有的iphone的ideal viewport都是320px，无论屏幕宽度是320还是640，css中320px就代表iphone屏幕的宽度 利用meta标签对viewport进行控制 meta viewport的6个属性 (1) width: 设置layout viewport的宽度，为一个正整数，或字符串”width-device” (2) initial-scale: 设置页面初始缩放值，为一个数字，可以带小数，相对于ideal viewport进行缩放 (3) minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数 (4) maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数 (5) height: 设置layout viewport的高度，很少使用 (6) user-scalable: 是否允许用户进行缩放，值为“no”或“yes”，no代表不允许，yes代表允许 把当前的viewport宽度设置为ideal viewport的宽度 visual viewport宽度 = ideal viewport宽度 / 当前缩放值 浏览器输入URL后发生了什么 (1) 输入URL(2) 浏览器查找域名的IP地址（DNS具体查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存）(3) 浏览器web服务器发送一个HTTP请求(4) 服务器的永久重定向响应（从http://example.com到http://www.example.com）(5) 浏览器跟踪重定向地址(6) 服务器处理请求(7) 服务器返回一个HTTP响应(8) 浏览器显示HTML(9) 浏览器发送请求获取嵌入在HTML中的资源（如图片、视频、音频、CSS、JS等）(10) 浏览器发送异步请求 浏览器结构 (1) User Interface 用户界面 如：顶部(前进、后退、刷新、停止、地址栏、书签栏、状态栏、工具栏等) 侧栏(滚动条)、底栏（滚动条）、开发工具、下拉菜单、下载管理等(2) Browser Engine 浏览器引擎 作用: 向上连接用户界面，向下连接渲染引擎，向右连接数据持久层(3) Rendering Engine 渲染引擎（浏览器内核） - 作用: 能显示HTML、XML和图片，并且通过一个插件可以显示其他类型资源，如PDF view显示PDF格式 - 常见的渲染引擎 - webkit: Safari、Chrome - gecko: Firefox - 流程: - 从网络层获取请求文档的内容，解析HTML/SVG/XHTML，形成DOM树 ； - 解析CSS形成CSS规则树； - 两者结合构成渲染树； - 通过JS解释器解析脚本 - 最后通过UI后盾提供的接口绘出效果 (4) Networking - 作用: 用于网络调用，如HTTP、HTTPS (5) Javascript Interpreter JS解释器 - 作用: 解析和运行JS (6) UI Backend UI后端 - 作用: 用于绘制基本的部件 (7) DATA Persistence 数据持久层 - 作用: 浏览器需要保存各种分类的数据在硬盘，例如cookies和HTML5的本地数据库等，都是通过这层来实现的 浏览器的内核有哪些 Trident IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape8、 Gecko Firefox、Netscape6-9 Webkit Safari、chrome Presto Opera JS引擎]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(4)——Javascript]]></title>
    <url>%2F2017%2F04%2F27%2Fit-interviews004%2F</url>
    <content type="text"><![CDATA[网页、屏幕宽度、高度的获取 屏幕分辨率的宽度: window.screen.width 屏幕分辨率的高度: window.screen.height 屏幕可用工作区宽度: window.screen.availWidth 屏幕可用工作区高度: window.screen.availHeight 网页被卷起的高度: document.body.scrollTop 网页被卷起的左边: document.body.scrollLeft 网页正文的全文宽: document.body.scrollWidth 网页正文的全文高: document.body.scrollHeight 网页可见区域宽度: document.body.offsetWidth, document.body.clientWidth; 网页可见区域高度: document.body.offsetHeight, document.body.clientHeight; 元素宽度、高度的获取【参考】 clientWidth: 标准盒模型的宽度(包含border) offsetWidth: 对象的宽度(width+padding+border) style.width: 行内式才能获取，包含px, % offsetLeft: 距离上层左边的距离 style.left: 可设置 property、attribute的区别 相同之处 标准的DOM properties与attributes是同步。 公认的（非自定义）特性被以属性的形式添加到DOM对象中，如: id, align, style 不同之处 对于有些标准的特性的操作，getAttribute()与点号(.)获取的值存在差异，如href、src、value、style、onclick等 property(属性): property的值不会出现在html中，只保存在js中 attribute(特性): 只能是字符串，大小写不敏感，出现在innerHTML中 typeof string number boolean undefined function object Javascript、Nodejs的区别 Javascript ECMAScript: 语言基础，如：语法、数据类型结构、内置对象 DOM: 操作页面元素的方法 BOM: 操作浏览器的方法 Nodejs ECMAScript: 语言基础，如：语法、数据类型结构、内置对象 os: 操作系统 file: 文件系统 net: 网络系统 database: 数据库 escape、encodeURI、encodeURIComponent escape: 将字符的unicode编码转换成为16进制序列，不编码字符有69个 如: *，+，-，.，/，@，_，0-9，a-z，A-Z encodeURI: 将字符的unicode编码转换成为UTF-8，不编码的字符有82个 如: !，#，$，&amp;，’，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z encodeURIComponent: 将字符的unicode编码转换成为UTF-8，不编码的字符有71个 如: !， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z stopropagtion(), stopImmediatePropagation() stopPropagation(): 阻止事件在DOM中继续传播 stopImmediatePropagation(): 阻止同一个事件的其他监听函数被调用 DOMContentLoaded事件, readstatechange事件** DOMContentLoaded事件: 比load事件早，文档下载并解析完成(DOM生成)，所有外部资源可能还没下载结束 readystatechange事件: 发生在Document对象和XMLHttpRequest对象，当其readyState属性发生变化时触发 Javascript前缀命名规范 s: 表示字符串。如：sName，sHtml； n: 表示数字。例如：nPage，nTotal； b: 表示逻辑。例如：bChecked，bHasLogin； a: 表示数组。例如：aList，aGroup； r: 表示正则表达式。例如：rDomain，rEmail； f: 表示函数。例如：fGetHtml，fInit； o: 表示以上未涉及到的其他对象，例如：oButton，oDate； g: 表示全局变量，例如：gUserName，gLoginTime； 闭包 原理: 当某个函数调用时会创建一个执行环境以及作用域链，然后根据arguments和其他命名参数初始化形成活动对象。当外部函数调用结束后，其执行环境与作用域链被销毁，但是其活动对象保存在了闭包之中，最后在闭包函数调用结束后才销毁。 实现: 在函数中定义函数，并且内部函数引用了外部函数的变量，最后内部函数被返回 特性 (1) 函数嵌套函数 (2) 函数内部可以引用外部的参数和变量 (3) 参数和变量不会被垃圾回收机制回收 Javascript垃圾回收原理 (1) 如果一个对象不再被引用，那么对象会被GC回收(2) 如果两个对象相互引用，且不被第三者引用，那么这两个对象会被回收 call、apply 其作用是可以改变其this的指向，其调用方式有所不同。 call传递参数；apply传递数组 Javascript数据类型 基本数据类型 string number boolean 引用数据类型 object array 特殊数据类型 null undefined 原型、原型链 原型: 一个普通的对象，自带隐式的proto属性，原型也有自己的原型原型链: 有一些用来继承和共享属性的对象组成的（有限的）对象链 null、undefined null: 一个表示“无”的对象，转为数值时为0；undefined: 一个表示“无”的原始值，转为数值时为NaN this指针 arguments ES6新特性【参考】 箭头操作符：=&gt; 类的支持：class 增强的对象字面量： 可以再对象字面量里定义原型 可以直接调用父类方法 定义方法可以不用function关键字 字符串模板：·your name is ${num}· 解构：自动解析数组或对象中的值 默认参数、不定参数、拓展参数 let、const关键字 for of：值遍历 模块：module Map、Set、WeakMap、WeakSet Proxies Symbols Math、Number、String、Object的新API Promises Promise Promise的四种状态 (1) pending: 初始状态，非fulfilled或rejected (2) fulfilled: 成功的操作 (3) rejected: 失败的操作 (4) settled: Promise已经被fulfilled或rejected，且不是pending 严格模式 目的 (1) 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 (2) 消除代码运行的一些不安全之处，保证代码运行的安全； (3) 提高编译器效率，增加运行速度； (4) 为未来新版本的Javascript做好铺垫。 缺点 (1) 与未采用严格模式的文件一起压缩，反而会浪费字节 DOM操作 创建 createDocumentFragment() createElement() createTextNode() 添加、移除、替换、插入 appendChild() removeChild() replaeChild() insertBefor() 查找 getElementsByTagName() getElementsByName() getElementById() document.write、innerHTML的区别 document.write: 只能重绘整个页面innerHTML: 可以重绘部分页面 Javascript对象创建的几种方式 (1) 工厂模式(2) 构造函数模式(3) 原型模式(4) 混合构造模式和原型模式(5) 动态原型模式(6) 寄生构造函数模式(7) 稳妥构造函数模式 Javascript继承的6中方法 (1) 原型链继承(2) 借用构造函数继承(3) 组合继承（原型+借用构造）(4) 原型式继承(5) 寄生式继承(6) 寄生组合式继承 如何获取UA 12345678&lt;script&gt; function whatBrowser()&#123; document.Browser.Name.value = navigator.appName; document.Browser.Version.value = navigator.appVersion; document.Browser.Code.value = navigator.appCodeName; document.Browser.Agent.value = navigator.userAgent; &#125;&lt;/script&gt; slice()、substr()、substring()的区别 slice(start, [end])：参数可为负 substr(start, length) substring(start, [end]): 参数不可为负 Array方法 转换方法 valueOf() toString() toLocaleString() join() 堆栈方法 push() pop() 队列方法 push() shift() unshift(item1, item2, …) 排序方法 reverse() sort() 操作方法 concat(arr1, arr2, …) slice() splice() 位置方法 indexOf() lastIndexOf() 迭代方法 every() filter() forEach() map() some() 合并方法 reduce() reduceRight() String方法 字符方法 charAt(index): 返回指定位置的字符 charCodeAt(): 返回指定位置的字符的unicode编码 操作方法 concat() slice() substring() substr() 位置方法 indexOf() lastIndexOf() trim方法 trim() trimLeft() trimRight() 大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 模式匹配方法 match(string/reg)： string: 返回匹配结果的数组 reg(g): 返回所有的匹配子串 reg: 返回一个数组：元素0存放的是匹配文本；其余元素存放与正则表达式的子表达式匹配的文本；input属性表示匹配文本的起始字符的位置；input属性表示输入字符串 search() replace() split() 其他方法 localeCompare() fromCharCode() 正则表达式 定义方法 直接定义: var r = /pattern/flags; 构造函数: var r = new RegExp(‘pattern’, ‘flags’); 元字符: ( ) [ ] { } \ ^ $ | ? * + . 特殊元字符 .: 查找单个字符 \w: 查找字母数字下划线 \W: 查找非字母数字下划线 \d: 查找数字 \D: 查找非数字字符 \s: 查找空白字符 \S: 查找非空白字符 \b: 匹配单词边界 \B: 匹配非单词边界 \0: 查找NULL字符 \n: 查找换行符 \f: 查找换页符 \t: 查找回车符 \v: 查找垂直制表符 \xxx: 查找以8进制xxx规定的字符 \xdd: 查找以16进制dd规定的字符 \uxxxx: 查找以16进制xxxx规定的unicode字符 […]: 匹配括号中的任何一个字符 [^…]: 匹配不在括号中的任何一个字符 {m,n}: 最少匹配前面表达式m次，最多n次 {m,}: 最少匹配前面表达式m次 {m}: 正好匹配前面表达式m次 ?: 匹配前面表达式0或1次 +: 最少匹配前面表达式1次 *: 最少匹配前面表达式0次 |: 匹配前面表达式或后面表达式 (…): 组合项目 ^: 匹配字符串的开头 $: 匹配字符串的结尾 正则表达式方法 test(): 返回一个布尔值，表示传入的 字符串是否匹配（从lastIndex属性指示的地方开始） exec(): 返回一个包含了匹配结果的数组（额外具有两个属性: input表示本次搜索的目标字符串；index表示匹配结果在目标字符串内的位置） 常见的正则表达式 匹配中文: [u4e00-u9fa5] 匹配URL /http(s)?:\/\/([\w-]+.)+[\w-]+(\/[\w-.\/\?%&amp;=]*)?/ 匹配Email: /^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$/ JS函数调用的方法【参考】 (1) 方法调用模式(2) 函数调用模式(3) 构造器调用模式(4) apply调用模式 setTimeout 随机打乱数组顺序123function randomArr(arr)&#123; arr.sort(function()&#123; return Math.random() - 0.5; &#125;)&#125; 实现duplicate12345678910111213141516171819function duplicate(obj)&#123; var buf; if(obj instanceof Array)&#123; buf = []; var i = obj.length(); while(i--)&#123; buf[i] = duplicate(obj[i]); &#125; return buf; &#125; else if(obj instanceof Object)&#123; buf = &#123;&#125;; for(var k in obj)&#123; buf[k] = duplicate(obj[k]); &#125; return buf; &#125; else &#123; return obj; &#125;&#125; 实现数组去重12345function distinct(arr)&#123; return arr.filter(function (elem, index)&#123; return arr.indexOf(elem, index+1) === -1; &#125;);&#125; 获取元素到页面顶部和左边的距离123456789101112function getDistance(el)&#123; var x = el.offsetLeft; var y = el.ofsetTop; while(el = el.offsetParent)&#123; x += el.offsetLeft; y += el.offsetTop; &#125; return &#123; 'x': x, 'y': y &#125;;&#125; 实现bind方法123456Function.prototype.bind = function(context)&#123; self = this; return function()&#123; self.apply(context, arguments); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(3)——CSS]]></title>
    <url>%2F2017%2F03%2F17%2Fit-interviews003%2F</url>
    <content type="text"><![CDATA[盒子模型【参考】 组成: content、padding、border、margin 标准盒模型 width/height = content IE盒模型 width/height = content + padding + border 行级元素、块级元素的区别 块级元素: margin、padding可设置 行级元素: margin、padding水平方向可设置；竖直方向不可设置 浮动及其原理 脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留 缺点 (1) 父元素的高度无法被撑开，影响与父元素同级的元素 (2) 与浮动元素同级的非浮动元素（内联元素）会跟随其后 (3) 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 清除方法 (1) clear:both清除浮动 (2) 父级div定义overflow:autooverflow有三个值: hidden, auto, visible; hidden, auto可用来清除浮动, auto对SEO更友好 (3) :after方法 line-height CSS hack 定义: 针对不同浏览器/版本而写CSS的过程叫做CSS hack 三种方法 (1) IE条件注释法: 即在正常代码之外添加判断IE浏览器或对应版本的条件注释，符合条件的浏览器或版本号才会执行里面的代码。- &lt;!-- [if IE]&gt;要执行的代码&lt;![endif]--&gt; - &lt;!-- [if lt LE 8]&gt;要执行的代码&lt;![endif]--&gt; - &lt;!-- [if ! IE 8]&gt;要执行的代码&lt;![endif]--&gt; (2) CSS属性前缀法: 即给CSS的属性添加前缀。比如: 可以被IE6/IE7识别，_只能被IE6识别，”\9”可以被IE6-IE10识别，IE6不能识别!important，Firefox不能识别,_,\9- #example{ color: #111; color: #222\9; *color: #333; _color: #444; } (3) 选择器前缀法: 即给选择器加上前缀- *div{ color: red; } - *+div{ color: red; } background-属性 background-color: 规定要使用的背景颜色 color-name hex-number rgb-number transparent inherit background-position: 规定背景图像的位置 top/left/bottom/right/center x% y% xpos ypos background-size: 规定背景图片尺寸 length percentage cover contain background-repeat: 规定如何重复背景图像 repeat repeat-x repeat-y no-repeat inherit background-origin: 规定背景的定位区域 padding-box border-box content-box background-clip: 规定背景的绘制区域 border-box padding-box content-box background-attachment: 规定背景图像是否固定或者随着页面的其余部分滚动 scroll fixed inherit background-image: 规定要使用的背景图像 url(‘URL’) none inherit display:none和visibility: hidden的区别 display: none 隐藏对应的元素，在文档布局中不分配空间； visibility: hidden 隐藏对应的元素，但是在文档布局中仍然保留员阿里的空间 link、@import link属于HTML标签；而@import是CSS提供的 页面被加载时，link会被同时加载，而@import引用的CSS会等到页面被加载完再加载 link方式的样式的权重高于@import的权重 position: absolute和float的区别 共同点: 对内联元素float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高 不同点: float仍会占据位置，position会覆盖文档流中的其他元素 relative、absolute、fixed、static absolute: 生成绝对定位的元素，相对于最近一级的定位不是static的父元素来进行定位fixed: 生成绝对定位的元素，相对于浏览器窗口进行定位relative: 生成相对定位的元素，相对于其在普通流中的位置进行定位static: 默认值。没有定位，元素出现在正常的流中 box-sizing content-box: 让元素维持W3C的标准盒模型border-box: 让元素位置IE传统盒模型 CSS选择器 (1) id选择器(#myId)(2) 类选择器(.myclassname)(3) 标签选择器(div, h1, p)(4) 相邻选择器(h1 + p)(5) 子选择器(ul &gt; li)(6) 后代选择器(li a)(7) 通配符选择器(*)(8) 属性选择器(a[rel=”external”])(9) 伪类选择器(a: hover, li:nth-child) CSS选择器【参考】CSS伪类、伪元素 伪类 定义: 基于当前元素所处的状态，或者说元素所具有的特性，而不是元素的id、class、属性等静态的标志。 :link :visited :hover :active :focus :first-child :lang 伪元素 定义: 目的是获取诸如元素内容第一个字、第一行，获取某些内容前面或后面这种普通的选择器无法完成的工作。 :first-letter :first-line :before :after CSS可被继承、不可被继承的样式 可继承: font-size, font-family, color, text-indent不可继承: border, padding, margin, width, height CSS优先级 !important &gt; 内联 &gt; id &gt; class &gt; tag &gt; 默认样式 class属性覆盖 当存在多个类名时，类名的位置不会对属性的渲染产生影响。只有在style中定义的位置才会有影响，同一条属性，后面的定义会覆盖前面的定义 CSS选择器权重 通用选择器: 0-0-0 标签选择器，伪元素: 0-0-1 类选择器，属性选择器，伪类: 0-1-0 ID选择器: 1-0-0 em, rem, px【参考】 px: 像素。相对长度单位。像素px是相对显示器屏幕分辨率而言的 em: 相对长度单位。相对于当前对象内文本的字体尺寸。如果当前对内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 rem: 相对长度单位。相对于HTML根元素。既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应 CSS3新特性 边框：border-radius、box-shadow、border-image 背景：background-size、background-origin 文本：text-shadow、word-wrap 字体：@font-face 2D转换：transform、translate()、rotate()、scale()、skew()、matrix() 3D转换：rotateX()、rotateY() 过度：transition 动画：@keyframes、animation水平垂直居中【参考】 (1) 绝对定位 + 负margin - 优点: 兼容性好 - 缺点: 需要知道宽高，不够灵活 (2) 绝对定位 + Transform - 优点: 不需要知道宽高，灵活 - 缺点: 兼容性不好，在移动设备上建议使用 (3) 绝对定位 + 自动margin - 优点: 灵活性兼容性好 - 缺点: 适用于本身有尺寸的元素，如图片，对于段落等必须显示设置其宽高 (4) CSS3 flexbox - 优点: 不需要知道宽高 - 缺点: 兼容性不好，在移动设备上建议使用 (5) table display - 优点: 兼容性好 - 缺点: 增加了无用的html结构 两列布局 (1) 左浮动 + 右margin(2) 左绝对定位 + 右margin(3) flex实现两列布局: 设置为flex布局后，子元素的float、clear、 vertical-align属性将失效(4) calc实现两列布局: 使用百分比、em、px、rem单位值计算出其宽度或者高度。通过对右div设置width: calc(100%-100px)来实现自适应布局(5) float + margin负值 - 给右边的div外面套上一个父div，然后让父div的宽度设为100%。对父div的宽度设为100% 水平居中【参考】 行内元素 对父元素设置文本居中，如: text-align: center 适用于inline, inline-block, inline-table, inline-flex 块级元素 margin: 0 auto 浮动元素 Box、Formatting Context【参考】 Box: CSS布局的基本单位，一个页面由多个Box组成。元素的类型和display属性，决定了Box的类型。不同类型的Box，会参与不同的Formatting Context（一个决定如何渲染文档的容器），即Box内的元素会以不同的方式渲染。 (1) block-level box: display属性为block、list-item、table的元素 (2) inline-level box: display属性为inline、inline-block、inline-table的元素 (3) run-in box: CSS3存在 Formatting context: 页面中的一块渲染区域，并且有一套渲染规则，其决定了其子元素将如何定位，以及和其他元素的 关系和相互作用 (1) BFC: Block Formatting Context (2) IFC: Inline Formatting Context (3) GFC: CSS3 (4) FFC: CSS3 BFC【参考】 定义: 块级格式化上下文。一个独立的渲染区域，只有block-level box参与，规定了内部的 block-level box如何布局。 BFC布局规则 (1) 内部的box会在垂直方向一个个进行放置 (2) box垂直方向的距离由margin决定。属于同一个BFC的两个相邻box的margin会发生重叠 (3) 每个元素的margin box的左边，与包含块border box的左边相接触。即使存在浮动也是如此。 (4) BFC的区域不会与float box重叠 (5) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 (6) 计算BFC的高度时，浮动元素也参与计算 生成BFC的元素 根元素 float属性不为none position为absolute或fixed display为 inline-block，table-cell，table-caption，flex，inline-flex overflow不为visible 边界塌陷 &amp; 边界重叠 定义: CSS中存在一个margin collapse， 即边界塌陷或边界重叠。对于上下两个并列的div，上面的div的margin-bottom和下面的div的margin-top会塌陷，取两者margin的最大值 CSS sprite 把网页中的一些背景图片整合到一张图片中，再利用CSS的background-repeat,background-image,background-position的组合进行定位 CSS 媒体查询【参考】 作用: @media可以针对不同的屏幕尺寸设置不同的样式，特别是设置响应式的页面 语法 @media mediatype and|not|only (mediafeature){ CSS-Code; } 如: @media screen and (max-width: 300px) { … }, @media mediatype all: 用于所有设备 print: 用于打印机和打印预览 screen: 用于电脑屏幕，平板电脑，智能手机等 speech: 应用于屏幕阅读器等发声设备 mediafeature aspect-ratio: 定义输出设备中的页面可见区域宽度和高度的比率 color: 定义输出设备每一组彩色原件的个数 color-index device-aspect-ratio device-height device-width grid height max-aspect-ratio max-color max-device-s … @font-face【参考】 语法: @font-face { font-properties } font-properties font-family: 定义字体的名称(必须) src: 定义字体的下载地址(必须) font-stretch: 定义字体该如何被拉长 font-style: 定义字体该是怎样的样式 font-weight: 定义字体的粗细 unicode-range: 定义字体支持Unicode字符的范围 CSS3画一个旋转的3/4的圆环123456789101112.circle &#123; height: 100px; width: 100px; border-radius: 50%; border: 20px solid black; border-left-color: transparent; -webkit-animation: mycircle 1s infinite linear;&#125;@keyframes mycircle &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(-360deg); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(2)——HTML]]></title>
    <url>%2F2017%2F03%2F07%2Fit-interviews002%2F</url>
    <content type="text"><![CDATA[Doctype 作用 (1) 对文档进行有效性验证： 告诉用户代理和校验器该文档的DTD (2) 决定浏览器的呈现模式：通知浏览器读取文档时采用何种解析算法。浏览器有三种方式解析HTML文档(标准模式、怪异模式、部分怪异模式) 种类 (1) HTML 4.01: Strict, Transitional, Framset (2) XHTML 1.0: Strict, Transitional, Framset 标准模式、怪异模式 标准模式：页面按照HTML与CSS的定义渲染 怪异模式：浏览器为了了兼容很早之前针对旧版本浏览器设计、并未严格遵循W3C标准的网页而产生的一种页面渲染模式 语义化 (1) 去掉或丢失样式时能够让页面呈现出清晰的结构(2) 有利于SEO：爬虫依赖于标签来确定上下文和各个关键字的权重(3) 方便其他设备解析以意义的方式来渲染网页(4) 可读性更好，方便团队开发 XHTML (1) 所有的标记都必须要有一个相应的结束标记(2) 所有标签的元素和属性的名字都必须使用小写(3) 所有的XML标记都必须合理嵌套(4) 所有的属性必须用引号””括起来(5) 把所有&lt;和&amp;特殊符号用编码表示(6) 给所有属性赋一个值(7) 不要在注释内容中使“–”(8) 图片必须有说明文字 data-属性 自定义属性，可通过对象的dataset属性获取，或通过getAttribute方法获取：1&lt;div data-author="baochuquan" data-time="2016-06-20" data-comment="10"&gt;&lt;/div&gt; 1div.dataset.commentNum;//10 input的type属性【参考】 button checkbox color date datetime datetime-local month week time email file hidden image number password radio range reset search submit tel text url iframe的优缺点 优点(1) 解决加载缓慢的第三方内容(如图标和广告等)的加载问题(2) Security sandbox(3) 并行加载脚本 缺点(1) iframe会阻塞主页面的onload事件(2) 即使内容为空，加载也需要时间(3) 没有语义 HTML表单元素【参考】 input select option textarea button HTMl5表单元素【参考】 datalist: datalist元素规定输入域的选项列表，列表是通过datalist内的option元素创建的 keygen: keygen元素的作用是提供一种验证用户的可靠方法 output: output元素用于不同类型的输出，如计算或脚本输出 head标签及其内容【参考】 作用: 描述了文档的各种属性和信息，包括文档的标题、在web中的位置以及和其它文档的关系等 内容 title: 定义文档的标题，是head部分中唯一必需的元素 base: 为页面上的所有链接规定默认地址或默认目标 必选: href 可选: target meta: 可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词 必选: content 可选 http-equiv(Content-Type, expires, Refresh, set-cookie) name: author, description, keywords, generator, revised, others link: 链接一个外部样式表 rel, href, type, charset script: 直接包含脚本，或者通过src属性指向外部脚本文件 style: 为HTML文档定义样式信息 块级元素、行内元素、空元素 块级元素 div、dl、dt、dd、ul、li、ol、p、h1-6、table、fieldset、form 行内元素 a、em、strong、i、img、b、label、select、textarea、sub、sup、q 空元素 br、hr 自闭合元素 自闭合标签不加斜杠，如: br, link HTML5新特性 新的文档类型：&lt;!DOCTYPR html&gt; 脚本和链接不需要type： 语义标签：header、footer hgroup 标记元素：mark 图形元素：figure 必要属性：require 音频视频：video, audio 正则表达式：pattern属性 canvas API：栅格图形API SVG：矢量图形API Geolocation API Communication API WebSockets API Form API Web Works API Web Storage API 置换元素、不可置换元素 置换元素 定义：浏览器根据元素的标签和属性，来决定元素的具体显示内容 如：imt, input, textarea, select, object 不可替换元素 定义：其内容直接呈现给用户 meta标签【参考】 作用 通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie； 可以用于鉴别作者，设定页面格式，标注内容提要和关键字； 可以设置页面使其可以根据自己定义的时间间隔刷新自己 设置RASC内容等级 分类 (1) http-equiv: HTTP标题信息- Content-Type、Content-Language - 说明: 设定页面使用的字符集，用以说明主页只做所使用的文字及语言 - 用法 - &lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; Charset=gb2312&quot;&gt; - &lt;meta http-equiv=&quot;Content-Language&quot; Content=&quot;zh-CN&quot;&gt; - Refresh - 说明: 让网页多长时间刷新自己，或在多长时间后让网页自动链接到其他网页 - 用法 - &lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;30&quot;&gt; - &lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;5;Url=&quot;http://www.baidu.com&quot;&gt; - Expires - 说明: 指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调整 - &lt;meta http-equiv=&quot;Expires&quot; Content=&quot;0&quot;&gt; - &lt;meta http-equiv=&quot;Expires&quot; Content=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;&gt; - Pragma(cache模式) - 说明: 禁止浏览器从本地机的缓存中调阅页面内容 - Set-Cookie(cookie设定) (2) name: 页面描述信息]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(1)——网络]]></title>
    <url>%2F2017%2F03%2F02%2Fit-interviews001%2F</url>
    <content type="text"><![CDATA[网络体系结构 OSI五层模型 应用层 传输层 网络层 数据链路层 物理层 OSI七层模型 应用层: 文件传输，电子邮件，文件服务，虚拟终端 （协议族: FTP,HTTP,SMTP,DNS,Telnet,SNMP） 表示层: 数据格式化，代码转换，数据加密。对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 会话层: 解除或建立与别的节点的联系。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 传输层: 提供端到端的接口。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层处理端到端的差错控制和流量控制问题。 （协议族: TCP, UDP） 网络层: 为数据包选择路由。还可以实现拥塞控制、网际互连等功能 （协议族: IP, ICMP, RIP, OSPF, BGP, IGMP） 数据链路层: 传输有地址的帧以及错误检测功能。在不可靠的物理介质上提供可靠的传输，该层的作用包括：物理地址寻址、数据的成帧、流量控制、 数据的检错、重发等 （协议族: SLIP, CSLIP, PPP, ARP, RARP, MTU） 物理层: 以二进制数据形式在物理媒介上传输数据。激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性 （协议族: ISO2110, IEEE802, IEEE802.2） 地址解析协议 原理: 适用于局域网，主机在发送帧前将目标IP地址转换成目标MAC地址的过程 工作过程 (1) 当主机A向本局域网上主机B发送IP数据报时，先在自己的ARP缓冲表中查看有无主机B的IP地址； (2) 如果有，查出对应的硬件地址，并将此硬件地址写入MAC帧，然后通过以太网将数据包发送到目的主机中 (3) 如果查不到主机B的IP地址的表项，高速缓存表可能是空的。主机A就自动运行ARP协议 ARP进程在本局域网上广播一个ARP请求分组。ARP请求分组的主要内容表明：我的IP地址是192.168.0.2，我的硬件地址是00-C0-15-AD-18，我想知道IP地址为192.168.0.4的主机的硬件地址 本局域网上的所有主机上运行的AR进程都接收此ARP请求分组 主机B在ARP请求分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址 主机A收到主机B的ARP响应分组后，在其ARP高速缓存中写入主机B的IP地址硬件地址的映射 路由选择协议 RIP协议 底层是Bellmanford算法，其选择路由的度量标准是跳数，最大跳数是15跳，如果大于15跳，则丢弃数据包 OSPF协议 底层是Dijskra算法，是链状状态路由选择协议，其选择路由的度量标准是带宽、延迟 NAT协议、DHCP议、DNS协议 NAT协议 网络地址转换协议: 一种将私有地址转换成合法IP地址的转换技术，完美解决了IP地址不足的问题，还能有效避免来自网络外部的攻击 DHCP协议 动态主机配置协议: 一种局域网的网络协议，使用UDP协议工作，主要用途: (1) 给内部网络或者网络供应商自动分配IP地址 (2) 给用户或者内部网络管理员作为对所有计算机作中央管理的手段 DNS协议 将域名和IP地址相互映射的一个分布式数据库 实现可靠传输的协议 (1) 停止等待协议 每发完一帧就停止发送，直到收到接收确认信号再发送下一帧，如果没有收到接收确认信号，则通过设定的定时器 超时后重传上一帧，通过序号判断之前的帧是否被接收 (2) 连续ARQ协议 发送窗口大于1，接收窗口等于1。如果发送窗口已经发送到了序号为5的帧，但是接收端收到序号为3的帧出错，那么3以后的帧都需重传。为了避免后面的帧重传，可以使用缓存 (3) 选择重传协议 TCP拥塞控制 【参考】 定义: 防止过多的数据注入网络中，可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是指点对点通信量的控制 方法: (1) 慢开始与拥塞避免 慢开始： 先探测网络的拥塞程度，从小到大逐渐增加拥塞窗口的大小 拥塞避免: 让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1 (2) 快重传与快恢复 (3) 随机早起检测RED 网络设备及其相关层 网关: 网络层以上的设备 网络层: 路由器 数据链路层: 网桥、交换机 物理层: 中继器、集线器 HTTPS 【参考】 在HTTP和TCP协议之间建立一层TLS/SSL协议 HTTP头 【参考】 报文格式 报文首部 空行 报文主体 请求报文首部 请求行（GET /index.html/ HTTP/1.1） 请求首部字段 请求信息性首部字段 From: 请求来自何方，格式是客户端用户的有效电子邮件地址 Host: 服务器的主机名和端口号 Referer: 这次请求的URL是从哪里获得的 User-Agent: 客户端的浏览器或代理信息 Accept首部字段 Accept: 客户端通过该首部字段告诉服务器自己可以接收哪些媒体类型，如text/html。此外，还有可以权重系数（q值）来表示媒体类型的优先级。 Accept-Charset: 客户端可以接收哪些字符集，也可以有q值 Accept-Encoding: 客户端支持的内容编码及内容编码的优先级顺序。 Accept-Language: 客户端能够处理的自然语言集（中文、英文等） TE: 客户端能够处理的传输编码，还可以指定伴随trailer字段的分块传输编码方式 条件请求首部字段 Expect: 客户端通过该首部字段告知服务器它们需求某种行为，现在该首部与响应码100 Continue紧密相关。如果服务器无法理解该首部的值，就应该返回417 Expectation Failed If-Match: 服务器会比对该字段的值和资源的ETag值，仅当两者一致时，才会执行请求，否则，返回412 Precondition Failed。该字段值为*时，会忽略ETag值 If-Modified-Since: 该字段值应该是一个日期，如果服务器上资源的更新时间较该字段值新则处理该请求，否则，返回304 Not Modified If-None-Match: 与If-Match相反，该字段的值与请求资源的ETag不一致时，处理该请求 If-Range: 该字段的值（ETag或时间）与资源的ETag或时间一致时，作为范围请求处理（参加首部字段Range）。否则，返回全体资源 If-Unmodified-Since: 与If-Modified-Since相反，服务器上资源的更新时间早于该字段值时处理请求，否则，返回412 Precondition Failed Range: 范围请求，只获取部分资源。如Range: bytes=5001-10000，表示获取从第5001字节至10000字节的资源。成功处理范围请求时返回206 Partial Content响应，无法处理范围请求时返回200 OK响应及全部资源 安全请求首部字段 Authorization: 向服务器回应自己的身份验证信息。客户端收到来自服务器的401 Authentication Required响应后，要在其请求中包含这个首部 Cookie: HTTP/1.1中没有定义，用于客户端识别和跟踪的扩展首部 代理请求首部字段 Max-Forwards: 只能和TRACE方法一起使用，指定经过代理或其他中间节点的最大数目。每个收到带此首部的TRACE请求的应用程序，在请求转发之前都要将这个值减1；如果应用程序收到请求时，该首部值为0，则立即回应一条200 OK响应 Proxy-Authorization: 与Authorization类似，用于客户端与代理服务器之间的身份验证 通用首部字段 实体首部字段 其他 响应报文首部 状态行（HTTP/1.1 200 OK） 响应首部字段 响应信息性首部字段 - Age: 响应已经产生了多长时间。HTTP/1.1规定缓存服务器在创建响应时必须包含Age首部 Location: 客户端应重定向到指定URI，基本配合响应出现 Retry-After: 告诉客户端多久之后再次发送请求。主要配合503 Service Unavailable使用，或与3**响应一起使用 Server: HTTP服务器的应用程序信息 Warning: 协商首部字段 Accept-Ranges: 服务器是否能处理范围请求，bytes表示能，none表示不能 Vary: 安全响应首部字段 Proxy-Authorizate: 与WWW-Authenticate类似，用于代理与客户端之间的认证，407 Proxy Authentication Required响应必须包含该首部 Set-Cookie: 非HTTP/1.1标准首部 WWW-Authenticate: 告诉客户端访问所请求资源的认证方案，401 Unauthorized响应中肯定有该首 通用首部字段 通用信息性首部字段 Connection: 两个作用 控制不再转发给代理的首部字段 管理持久连接 Date: 创建HTTP报文的时间和日期 Trailer: 说明在报文主体后记录了哪些首部字段 Transfer-Encoding: 传输报文主体时采用的编码方式 Upgrade: 用于检测HTTP协议及其他协议是否可使用更高的版本进行通信 Via: 追踪客户端与服务器之前的请求和响应报文的传输路径 通用缓存首部字段 Cache-Control: 管理缓存信息，是HTTP/1.1引入的一个复杂首部 Pragma: HTTP/1.1以前的遗留字段Pargma: no-cache与Cache-Control: no-cache功能一致，只用在客户端发送请求时 实体首部字段 实体信息性首部字段 Allow: 通知客户端可以对特定资源使用那些HTTP方法。405 Method Not Allowed响应中必须包含该首部 内容首部字段 Content-Encoding: 告诉客户端实体的主体部分选用的内容编码方式。具体方式参见Accept-Encoding Content-Language: 告诉客户端实体主体使用的自然语言（中文、英文等） Content-Length: 表明实体主体部分的大小（单位：字节）。对实体主体进行内容编码传输时，不能再使用该首部字段 Content-Location: 报文主体部分相对应的URI Content-MD5: 一串由MD5算法生成的值。对于检查在传输过程中数据是否被无意的修改非常有用，但不能用于安全目的，因为报文如果被有意的修改，该字段的值也可以计算后作相应修改 Content-Range: 针对范围请求，提供了请求实体在原始实体内的位置（范围），还给出了整个实体的长度 Content-Type: 响应报文中对象的媒体类型 实体缓存首部字段 ETag: 实体标记，就是一种标识资源的方式 Expires: 资源失效日期，当Cache-Control有指定max-age指令时，会优先处理max-age Last-Modified: 资源最终修改时间 其他 HTTP请求方法 GET: 最常见，向服务器请求某个资源 POST: 起初用于向服务器输入数据。实际上，通常用于HTML表单数据的提交 HEAD: 与GET的行为类似，但服务器返回的响应中只包含首部，不会返回主体部分 PUT: 向服务器写入文档 DELETE: 删除指定资源 TRACE: 服务器回送收到的请求信息给客户端，主要用于诊断 ONNECT OPTIONS: 查询服务器支持的方法（通用或针对指定资源） HTTP状态码 100 Continue: 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK: 正常返回信息 201 Created: 请求成功并且服务器创建了新的资源 202 Accepted: 服务器已接受请求，但尚未处理 301 Moved Permanently: 请求的网页已永久移动到新位置。 302 Found: 临时性重定向。 303 See Other: 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified: 自从上次请求后，请求的网页未修改过。 400 Bad Request: 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized: 请求未授权。 403 Forbidden: 禁止访问。 404 Not Found: 找不到如何与 URI 相匹配的资源。 500 Internal Server Error: 最常见的服务器端错误。 503 Service Unavailable: 服务器端暂时无法处理请求（可能是过载或维护）。 域名劫持 原理: 通过攻击域名解析服务器或者伪造域名解析服务器的方法，把目标网站域名解析到错误的地址。 Content-Type 含义: 用于指定请求和响应的HTTP内容类型。如果未指定，默认为text/html 格式: [type]/[subtype];parameter type text: 用于标准化地表示文本信息，文本消息可以是多种字符集或多种格式的 multipart: 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据 application: 用于传输应用程序数据或二进制数据 message: 用于包装一个email消息 image: 用于传输静态图片数据 audio: 用于传输音频数据 video: 用于传输动态影像数据，可以是与音频编辑在一起的视频格式的数据 q subtype patameter 常见值 text/html text/plain text/css text/javascript application/x-www-form-urlencoded: 常用的表单发包方式，POST发包方式 multipart/form-data: 发送文件的POST包 application/json application/xml Etag cache-control private: 默认值。内容只缓存到私有缓存中（仅客户端可以换成，代理服务器不可缓存） public: 所用内容都可以被缓存（客户端和代理服务器都可缓存）cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载 no-store: 所有内容都不会被缓存到缓存或Internet临时文件中 max-age: 缓存的内容将在xxx秒后失效 must-revalidate/proxy-revalidation: 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 三次握手、四次挥手 三次握手 Client端发送连接请求报文 Server端接收连接请求，并回复ACK报文，并为此次连接分配资源 Client端接收ACK报文，向Server端发送ACK报文，并分配资源 四次挥手 Client端发送中断请求，即FIN报文 Server端收到FIN报文，发送ACK报文，并继续发送数据 Client端收到ACK报文，进入FIN_WAIT状态 Server端数据发送完毕，发送FIN报文 Client端收到FIN报文，发送ACK报文，等待2MSL IP地址 特殊的IP地址 网络地址 IP地址由网络号和主机号组成，网络地址的主机号为全0，网络地址代表整个网络 广播地址（直接广播地址） IP地址主机号全为1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息 既可本地广播，也可跨网段广播 组播地址 D类即主播地址 255.255.255.255（受限广播地址） 受限广播地址，只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组 0.0.0.0 表示整个网络。它的作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去。 回环地址 表示本机地址 A、B、C类私有地址 A类私有地址: 10.0.0.0/8, 范围: 10.0.0.0~10.255.255.255 B类私有地址: 172.16.0.0/12, 范围: 172.16.0.0~172.31.255.255 C类私有地址: 182.168.0.0/16, 范围: 192.168.0.0~192.168.255.255 IP地址分类 A类地址: 0开头，8位网络号 B类地址: 10开头，16位网络号 C类地址: 110开头，24位网络号 D类地址: 1110开头，用于多播 E类地址: 1111开头 子网 原理: 从二级IP地址到三级IP地址 二级IP地址: &lt;网络号&gt;&lt;主机号&gt;，默认子网掩码为网络号的长度 三级IP地址: &lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;，默认子网掩码为网络号+子网号的长度 超网 原理: 变长子网掩码，无分类编址CIDR IP地址: &lt;网络前缀&gt;&lt;主机号&gt; 特点: TCP、UDP 【参考】 报文格式 共有字段: 源端口和目的端口号 数据长度 校验和 数据域 TCP特有字段 序列号和确认号 接收窗口 TCP首部 标识字段 区别 TCP 面向连接的协议，提供可靠的数据传输 当数据接收方收到数据发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在收到确认消息之后才会继续发送其他信息； 报文最大长度允许超过512字节 UDP 用户数据报协议，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 报文最大长度为512字节 TCP对应的协议和UDP对应的协议 TCP FTP: 定义了文件传输协议，使用21端口 Telnet: 一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DO S模式下的通信服务，使用23端口 SMTP: 定义了简单邮件传送协议，使用25端口 POP3: 和SMTP对应，POP3用于接收邮件，使用110端口 HTTP: 从web服务器传输超文本到本地浏览器的传送协议 UDP DNS: 用于域名解析服务，将域名地址转换为IP地址，使用53端口 SNMP: 简单网络管理协议，用来管理网络设备，使用161端口 TFTP: 简单文件传输协议，使用69端口 Socket 套接字 是支持TCP/IP协议的网络通信的基本操作单元，是网络通信过程中端点的抽象表示，包含进行 套接字 = 连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口 HTTP2.0 特性 入服务器端推: 允许服务器端在客户端需要数据之前就主动地将数据发送到客户端缓存 提供更多加密技术 使用多路技术，允许多个消息在一个连接上同时交叉 增加了头压缩，即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2017%2F02%2F08%2Fcharacter-code%2F</url>
    <content type="text"><![CDATA[概念 字符是一个信息单位，在计算机中，一个中文汉字是一个字符，一个英文字母是一个字符，一个阿拉伯数字是一个字符，一个标点符号也是一个字符。 字符集是字符组成的集合，通常以二维表的形式存在于每一台计算机本地，二维表的内容和大小是由使用者的语言而定的，可以是英语、汉语、希腊语等等。 字符编码是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。编码方式一般是对二维表的横纵坐标进行变换的算法。一般都比较简单，直接把横纵坐标拼一起。后来随着字符集的不断扩大，为了节省存储空间，才出现了各种编码算法。 字符集和字符编码一般是成对出现的，如ASCII、IOS-8859-1、GB2312、GBK等，都是既表示了字符集又表示了对应的字符编码，下文统称编码。Unicode比较特殊，后面细说。 发展 ASCII计算机是美国人发明的，由于他们的语言的是美式英语，字符比较少，所以一开始就设计了一个不大的二维表，128个字符，取名ASCII（American Standard Code for Information Interchange）。128个码位（包括32个不能打印出来的控制符号）只占用了一个字节的后面7位，最前面的1位统一规定为0，其表示范围为00000000-01111111或0x00-0x7F。 后来美国人发现128个字符不够用，于是在原来的二维表的基础上进行了扩展，利用ASCII编码字节中闲置的最高位，从而编入新的符号。这种扩展后的编码被称为EASCII（Extended ASCII）。256个码位正好可以使用一个字节表示，其表示范围为00000000-11111111或0x00-0xFF。 当计算机技术传递到欧洲后，美国的编码标准就不适用了，但是改改还能凑合。于是国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，跟EASCII类似，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，如ISO-8859-1、ISO-8859-2、ISO-8859-3，……，ISO-8859-16等等。 非ASCII单个字节表示256个字符的ASCII系编码，对于欧洲各国的语言尚可表示，然而，对于亚洲地区的语言来说则远远不够，中国的汉字就多达10万左右。因此，就必须使用多个字节表示一个字符。为此在，亚洲地区又出现了很多编码，大陆的GB2312和GBK（GB2312的扩展，Kuozhan）、港台的BIG5、日本的Shift JIS等等。例如，GB2312编码使用两个字节表示一个汉字，所以理论上最多可以表示65536个汉字。 Unicode当互联网席卷了全球，地域限制被打破了，不同国家和地区的计算机在交换数据的过程中，一旦使用不同的字符编码就会出现乱码的问题。要彻底解决这个问题，就必须使用一个通用的字符集UCS（Universal Character Set）和一个通用的字符编码Unicode。 Unicode 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么就可以彻底解决乱码问题。这就是Unicode，就像它的名字一样，这是一种所有符号的编码。 Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 Unicode只是一个符号集，只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 问题事实上，Unicode在实现上存在两个需要解决的问题： (1) 如果采用多字节定长存储，则面临着极大的存储空间浪费以及字符集扩展问题。如：单字节的ASCII编码将浪费大量存储空间。(2) 如果采用多字节非定长存储，则面临着不定长编码的识别问题。即，如何知道一个编码使用了多少字节。 目前，有三种被广泛认知的Unicode实现方式：UTF-8，UTF-16（字符用两个字节或四个字节表示），UTF-32（字符用四个字节表示）。然而只有UTF-8有效地解决了上述两个问题，使得其成为目前最广泛的Unicode实现方式。 UTF-8UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有二条： (1) 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。(2) 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 下表总结了UTF-8编码规则，字母x表示可用编码的位。 Unicode符号范围(十六进制) UTF-8编码方式(二进制) 0000-0000-0000-007F 0xxxxxxx 0000-0080-0000-07FF 110xxxxx 10xxxxxx 0000-0800-0000-FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001-0000-0010-FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx UTF-8的编码规则：如果第一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字符。 下面，还是以汉字”严”为例，演示如何实现UTF-8编码。已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 历史 ASCII 1960 开发 1963 发布 1986 最后一次更新 ISO-8859-1 1998 发布 GB2312 1980 发布 GBK 1993 发布 UCS-2 In the late 1980s Unicode 1987 开发 1991 发布 1996 实现代理机制（UTF-16） 2015 最新版8.0 UTF-8 1993 发布 2008 流行 UTF-16 1996 开发 2000 发布 根据以上各个编码发展的一些时间节点，再配合下图UTF-8制霸互联网过程，会有一个比较清晰的了解。 (完) 参考[1] 字符，字符集，字符编码[2] 字符编码笔记：ASCII，Unicode和UTF-8[3] The Unicode Consortium[4] 字体编辑用中日韩Unicode编码表]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《兄弟连》观影有感]]></title>
    <url>%2F2017%2F01%2F15%2Fband-of-brothers%2F</url>
    <content type="text"><![CDATA[电影《血战钢锯岭》的上映获得了极大的反响，战争题材的电影时隔多年又重新焕发光彩。我本人也对这类电影颇感兴趣，可能是我内心的确很想了解数十年前人类历史上最惨烈的两场大规模战争的真实面目。 然而，国产抗战剧没有多少部让我能够真正予以赞许。国产抗战剧永远都是对战争胜利一方歌功颂德，将己方士兵都描绘成类似于董成瑞、邱少云一样的置之生死于度外的英雄式人物，将对方士兵极致丑化。当然，我深信那段时期我们有着大量敢于英勇就义的战士，也不否认敌方士兵的穷凶极恶。但我想说的是，我们的抗战剧总是缺少类似纪录片一样的客观、公正的态度，无法真实地呈现出战争的惨烈，参战士兵、人民的真实感受。战争片的意义是在于让观影者能够身临其境地感受这一切，进而能够珍惜、维护这来之不易的和平。 很庆幸，《太平洋战争》、《兄弟连》等作品都是以最底层、最前线的士兵的经历和回忆来还原这一切，所以在《兄弟连》中甚至从未出现过高级军官的指点江山的场景。 《兄弟连》是根据美国101陆军空降师部队E连的真实事迹改编，描述的是第二次世界大战的尾声，也是战况最为惨烈的时节。1944年6月6日，美国101空降师506团E连奉命空降登陆诺曼底，此后一年多经历了高密集度的战斗，从法国的卡朗唐镇到荷兰的埃因霍温，再到比利时的巴斯托尼，德国的海格纳镇，到最后的纳粹德军最高首领的大本营贝希特斯加登，所到之处皆留下了E连兄弟们的身影和鲜血。 这里我不想具体述说影片的内容，只想回顾那几幕令我为之动容的场景。 第一幕温特斯中尉率领士兵在荷兰的堤防上展开了一次危险任务，结果获得了空前的胜利，他也因此被晋升为步兵营的执行官。然而，在这次任务中，温特斯在带头侧翼攻击时，他一个人冲到了堤坝上，结果一个俯身在草丛中的德军士兵发现了他，而那个德军士兵只是个少年，温特斯举枪对准他的那一刻，他的表情经历了惊讶到恐惧的。然而，为了完成战斗任务，温特斯还是果断开了枪。而此后，这一场景成为了温特斯脑海中挥之不去的一幕。也是他至此之后再也没开过枪的原因。 第二幕而在新一轮轰炸中，乔治·鲁兹未来得及回到散兵坑，他在炮火中疯狂地向散兵坑爬去，散兵坑里穆克和潘卡拉也是大喊着快点，然而即将爬进坑时，一枚炮弹掉入了他眼前的这个散兵坑。那一瞬间，鲁兹整个人都懵了。 第三幕鲁兹清醒后又立刻爬到了卡伍德·李普顿所在的散兵坑。然而，又一枚炮弹调到他们散兵坑的边缘处，庆幸的是，炮弹一直冒着烟，但没有爆炸。死里逃生的两人盯着炮弹很久，然后鲁兹点起了一根烟，而李普顿作为一个从来不抽烟的人却主动抢了过来抽了起来。难以想象，两人的内心是怎样一种感受。 第四幕在严寒的冬季中，饥寒交迫的E连于比利时巴斯托尼市外的森林中孤军奋战，死守同盟军的防线，仅有少量的补给品与弹药抵达，但是御寒的冬衣却一件也没有。在德军一轮轮的炮轰之中，多名弟兄阵亡。其中有一幕就是，乔·托伊被炮弹炸断了腿，哭着喊着要站起来，那时他的内心已经到了崩溃的边缘。 第六幕炮轰过后，听到乔·托伊的呼救，好友比尔·葛奈瑞立马去营救他，一路上，乔·托伊还喊着要自己的钢盔。然而，在快到散兵坑的时候，又一轮炮轰开始，一枚炮弹不幸落在他们身边。然而，这一幕发生在刚从散兵坑跳出来准备帮忙的巴克·康普顿眼前。自此之后，他的心理发生了巨大变化。 第七幕E连进入德国后，一个小分队在邻近的森林中，发现了一个被遗弃的纳粹集中营，里面还充满了饱受折磨的俘虏。令人惊奇的是，当地居民竟否认这个集中营的存在。而就在此时，欧洲各地都纷纷传来发现死亡集中营的消息。看到那一幕，我的心情很沉重，我并不明白希特勒为什么要搞种族屠杀。而这仅仅只是其中一个纳粹集中营，难以想象奥斯维辛集中营是如何人间地狱一般地存在。战争总是会让无辜的人民成为战争的牺牲品。 第八幕影片的最后，温特斯少校老年的的回忆，有一天他的孙子问了他一个问题,“爷爷，你是战争中的英雄吗？”，他说：“不是，可是我和英雄们一起战斗。”。说完，温特斯老爷爷哽咽了，我能感受到他内心那种复杂的心情。 无论是哪一方的士兵，都只是在执行上级的命令，战场上你死我活，然而在战争之前，他们也许和你我一样拥有着相似的爱好，从事着相似的工作，甚至能够彼此建立起友谊。我想，从他们返回战场那一刻，没有人不希望和平的到来。 现在，中日一旦出现紧张关系，总有人叫嚣着要开战，也许他们看惯例国产抗战剧、看惯了祖国的各种军演，总以为我们无需伤亡即可碾压对手。对这种一时图快，看不清战争危害的言行，我只想说：Naive！ 最后，我想以德军投降前，一位纳粹将军对自己的士兵们说的简短的几句话结尾： 这是一场漫长的战争，也是一场艰苦的战争，你们英勇并骄傲地为祖国作战，你们是一群特别的人，你中有我，我中有你，只有在战斗中会有这样的友谊，在兄弟之间共同使用散兵坑，在最需要的时刻相互扶持，你们见证过死亡，一起接受磨难，我很自豪能与你们每个人共同服役，你们有权利享受永远的快乐和平的生活… (完)]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS原理]]></title>
    <url>%2F2017%2F01%2F08%2Fhttps-principle%2F</url>
    <content type="text"><![CDATA[HTTPS概述 在互联网领域，安全永远是一个重点关注的方向。现阶段HTTPS的安全指数显然要比HTTP高很多，前者也是互联网发展的必然趋势。为了鼓励全球网站的HTTPS实现，Google甚至调整了其搜索引擎算法，提升HTTPS网站的搜索排名。那HTTPS和HTTP到底有什么区别呢？简单而言，HTTPS可以认为是HTTP+TLS/SSL。 SSL/TLS 作用我们都知道不使用SSL/TLS的HTTP通信，即不加密的通信。其具有以下几个潜在的风险： (1) 窃听风险（eavesdropping）：第三方可获知通信内容。(2) 篡改风险（tampering）：第三方可以修改通信内容。(3) 冒充风险（pretending）：第三方可以冒充他人进行通信。 而SSL/TLS的作用就是解决上述几个潜在的风险： (1) 所有信息都是加密传播，第三方无法窃听。(2) 具备校验机制，一旦被篡改，通信双方会立刻发现。(3) 配备身份整数，防止身份被冒充。 历史互联网加密通信协议的历史，几乎与互联网的历史一样长。 1994年，NetScape公司设计了SSL协议（Secure Socket Layer）的1.0版本，但是未发布。1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。1996年，SSL 3.0版本问世，得到大规模应用。1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版本。2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版本和TLS 1.2版本。最新的变动是2011年TLS 1.2的修订版 目前，应用最广泛的是TLS 1.0，然后是SSL 3.0。不过，主流浏览器都已经实现了对TLS 1.2的支持。通常，TLS 1.0会被标示为SSL 3.1，TLS 1.1会被标示为TLS 1.2会被标示为SSL 3.3。 原理SSL/TLS协议的基本思路是采用公钥加密法，即：客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，使用私钥解密。而这个过程中需要解决两个问题：(1) 如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 (2) 公钥加密法作为一种非对称加密算法，计算量比对称加密算法大很多，如何减少耗费时间？ 解决方法：每次会话（session），客户端和服务器端都生成一个”会话密钥“（session key），用它来加密信息。这里，客户端仅用公钥加密”会话密钥”，而通信过程中的大量信息则用”会话密钥”来加密，由于大量使用对称加密算法，所以可以大幅减少加密运算的时间。 因此，SSL/TLS协议的基本过程如下： (1) 客户端向服务器索取并验证公钥。(2) 双方协商生成”会话密钥”。(3) 双方采用”会话密钥”进行加密通信。 其中，(1)(2)又称为”握手阶段“（handshake）。 握手阶段 如上图所示，”握手阶段”包含4次通信。而”握手阶段”的所用通信都是明文的。下面分别介绍”握手阶段”的4次通信过程。 客户端发出请求(ClientHello)ClientHello请求: 客户端（通常是浏览器）先向服务器发出加密通信的请求。在这一步，客户端主要向服务器提供以下信息： (1) 支持的协议版本，如TLS 1.0版本。(2) 一个客户端生成的随机数，稍后用于生成”会话密钥”。(3) 支持的加密方法，如RSA公钥加密。(4) 支持的压缩方法。 需要注意的是，客户端发送的信息之中不包括服务器的域名。即理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。 但是，这对于虚拟主机用户来说，极为不便。为此，2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。 服务器回应(ServerHello)ServerHello: 服务器收到客户端请求后，向客户端发出回应。在这一步，服务器端的回应包含以下内容： (1) 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。(2) 一个服务器生成的随机数，稍后用于生成”会话密钥”。(3) 确认使用的加密方法，如RSA公钥加密。(4) 服务器证书。 除了以上信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 (1) 一个随机数。该随机数用服务器公钥加密，防止被窃听。(2) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。(3) 客户端握手结束通知，表示客户端的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。 此过程中出现的随机数是整个握手阶段出现的第三个随机数，又称”premaster secret“。经过这个过程之后，服务器端和客户端就同时拥有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥“。 但是为什么一定要用三个随机数来生成”会话密钥”呢？CSDN的dog250给出如下解释： “不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，premaster secret本身就是一个随机数，再加上hello消息中的随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。Premaster secret的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么premaster secret就有可能被才出来，那么仅适用premaster secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上premaster secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机数可能完全不随机，可是三个伪随机数就十分接近随机了。” 此外，如果前一步，服务器要求客户端提供证书，客户端会在这一步发送证书及其相关信息。 服务器回应服务器收到客户端的第三个随机数premaster secret之后，计算本次会话所需的”会话密钥”。然后，向客户端发送以下信息： (1) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。(2) 服务器握手结束通知，表示服务器的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。 数字签名和数字证书我们回顾一下SSL/TLS握手阶段的整个过程的一些关键点，来看看其中是否还有潜在的风险。 (1) 客户端产生一个随机数A，以明文方式发给服务器。(2) 服务器产生一个随机数B，以明文方式发给客户端。此外，服务器还将公钥放入证书中发送给客户端。(3) 此时客户端拥有随机数A，B以及证书（公钥）。服务器拥有随机数A，B以及其私钥。(4) 客户端产生一个随机数C，使用公钥加密，发送给服务器，服务器以私钥解密，得到随机数C。此过程使用公钥加密法（非对称加密）。(5) 此时客户端和服务器使用三个随机数A，B，C，生成相同的成对的”会话密钥”。(6) 此后，客户端和服务器端进行通信采用”会话密钥”进行加密通信（对称加密），可以减少加解密时间，提高通信速度。 那么问题来了，步骤(2)中的证书是如何防止被窃听和篡改的呢？这个过程中似乎没有采用任何算法对其进行加密保护。我们知道随机数A，B作为明文可以被窃听，而如果证书也被篡改，恶意的第三方甚至就可以向用户提供自己的证书（公钥），将自己伪装成客户端想要通信的对象。最终可以获取用户的信息，达到其进一步的目的。 因此，客户端需要一种机制来确认其请求的服务器是否伪造的。而数字证书就像身份证一样可以证明服务器的真伪。 数字证书数字证书由专门的机构”证书中心“（Certificate authority，简称CA）颁发。证书中心用自己的私钥，将服务器的公钥及其相关信息进行加密，生成”数字证书“（Digital Certificate）。 客户端（浏览器）的”证书管理器“，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发，浏览器会发出另一种警告。 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，从而进行后续的通信加密相关操作。 数字签名除了数字证书以外，我们经常还能看到的”数字签名“（Digital signature）又是什么呢？ 数字签名是将公钥密码反过来使用。签名者将信息用私钥加密（这是一种反用，因为通常私钥是用于解密）；验证者使用公钥解密信息。也就是说，客户端向服务器端发送消息是一种正向的公钥加密法（公钥加密，私钥解密）；而服务器端向客户端发送消息则是一种公钥加密法的反向实现（私钥加密，公钥解密）。 数字签名的目的是为了防止通信内容被修改。通信过程中，信息发送方对通信内容进行hash，并将产生hash值作为通信内容的摘要（digest）。 然后，使用私钥将摘要进行加密，得到数字签名。而接收端使用公钥即可解密得到摘要。 最终，客户端将通信内容进行hash，并与解密后得到的摘要进行比对，如果一致则表示内容未被篡改。 （完） 参考[1] SSL/TLS协议运行机制的概述[2] SSL协议中的DH算法的pre-master-secret[3] 数字签名是什么？[4] 数字签名[5] 图解SSL/TLS]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【我的阅读轨迹】]]></title>
    <url>%2F2017%2F01%2F05%2Fread-books%2F</url>
    <content type="text"><![CDATA[回看过去三个月，从10月中旬开始毕设换题，到现在2017年初，自己一直忙于毕设相关事宜，几乎没有挤出一些时间来提升自己。为了能够改变现在的生活状态，写下这篇博文以长期记录自己的阅读轨迹，希望能够以此鞭策自己不断地阅读、学习、思考、成长。 2017《黑客与画家》 时间: 1月3日至1月16日，一遍完 简评: 硅谷创业之父Paul Graham的散文集，描述了作者对社会现象、人生、技术、创业等方面的一些自己独特的见解。虽然本书并没有围绕具体某个主题展开，但是作者不时地传达出“Think Different”的思想，非常好的一本书。 《Webkit技术内幕》 时间: 1月17日至今，未读完 《启示录 打造用户喜爱的产品》 时间: 2月9日至2月19日，一遍完 简评: 本书分为三大部分：人员，流程，产品。人员部分主要介绍了围绕一款产生的设计、开发、发布、管理需要进行的人员配置，这方面非常适合类似相管理等职位的人来阅读；流程部分则介绍了产品诞生的过程中，以产品经理为中心，如何处理和协调整个过程；产品部分则是关于作者根据自己30年从业经验给产品经理的一些意见和建议。总体来说，本书对于产品经理是一本非常有价值的指导手册。希望有时间能够再次拜读此书，汲取其精华，写一点自己的得心体会。 《从0到1 开启商业与未来的秘密》 时间: 2月19日至5月1日 简评: 作者是Paypal的创始人之一，本文与《黑客与画家》类似，每一章都一个主题，但整本书始终围绕着如何创业、如何打造一个成功的企业来阐述作者的观点。 《Objective-C编程》 时间: 7月11日至7月13日 简评: 入职后转岗iOS开发，Mentor指引了一条学习路线，首先看《Object-C编程》这本书。此书非常适于iOS开发入门，主要介绍Object-C的语法及相关概念。题外话：不得不说人的潜能真的是难以置信，三天看完了一本380页的技术书，还撸了一遍示例代码。 《iOS编程》 时间: 7月22日至7月30 简评: 一本非常好的开发指南，初学如果不看斯坦福的视频，对于里面的介绍各种东西可能会比较陌生。本书覆盖的知识面比较广，但并不深入，总体来说是一本非常好的iOS入门书籍。 《iOS开发进阶》 时间: 9月10日~9月12日 简评: 花了三天空余时间过了一遍这本书，主要介绍了作者根据自身多年iOS开发经验总结出的一些开发经验，包括对使用工具提高开发、应用发布的注意事项等等。 《iOS Core Animation：Advanced Techniques》 时间: 9月12日~10月24日 简评: 主要介绍Core Animation框架的关键原理以及相关应用，值得二刷。 《Swift 3.0 官方教程中文版》 时间: 10月24日~10月30日 简评: 官方教程，详细全面地介绍了swift 3.0的特性。语言类的官方教程阅读起来还是比较枯燥的，希望以后能够多多锻炼。 《Swift编程入门》 时间：10月31日~11月12日 简评：此书是对Swift官方教程进行了简化，整理得出的一般语言教程，很不错，值得向初学者推荐。 2018《iOS应用逆向工程》 时间：1月14日~至今 （未完待续）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel手册]]></title>
    <url>%2F2016%2F12%2F18%2Fchisel-manual%2F</url>
    <content type="text"><![CDATA[原文链接 Introduce本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本手册中，我们假设您已经了解了Scala的基础知识。如果你不熟悉Scala，我们建议你参考一本优秀的Scala书。 NodesChisel中任何硬件设计最终都由节点对象的图表表示。Chisel中的用户代码生成此节点图，然后将其传递到Chisel后端以转换为Verilog或C ++代码。节点定义如下：1234567891011121314151617181920class Node &#123; // name assigned by user or from introspection var name: String = "" // incoming graph edges def inputs: ArrayBuffer[Node] // outgoing graph edges def consumers: ArrayBuffer[Node] // node specific width inference def inferWidth: Int // get width immediately inferrable def getWidth: Int // get first raw node def getRawNode: Node // convert to raw bits def toBits: Bits // convert to raw bits def fromBits(x: Bits): this.type // return lit value if inferrable else null def litOf: Lit // return value of lit if litOf is non null def litValue(default: BigInt = BigInt(-1)): BigInt &#125; 节点类层次结构的最高级别如图所示。基本类别是： Lit: 常量或文本 Op: 逻辑或算术操作 Updateable: 条件更新节点 Data: 具有类型的wire或port Reg: 上升沿触发的寄存器 Mem: 存储 Lits原始文本表示为Lit节点，定义如下：1234class Lit extends Node &#123; // original value val inputVal: BigInt&#125; 原始文本包含位的集合。用户不直接创建原始文本，而是使用第Type节中定义的类型构造函数。 Ops原始操作表示为如下定义的Op节点：1234class Op extends Node &#123; // op name used during emission val op: String&#125; Ops计算其输入的组合函数。 Types表示硬件设计的Chisel图包含原始节点和类型节点。Chisel类型系统与底层Scala类型系统分开维护，因此类型节点散布在原始节点之间，以允许Chisel检查并响应Chisel类型。Chisel类型节点在硬件设计转换为C ++或Verilog之前被擦除。getRawNode运算符定义在基本Node类中，跳过类型节点并返回找到的第一个原始节点。下图显示了内置的Chisel类型层次结构，其中Data为最顶层节点。 内置标量类型包括Bool，SInt和UInt和内置聚合类型Bundle和Vec允许用户使用其他类型的集合扩展Chisel数据类型集。Data自身就是一个节点：1234567891011121314151617181920212223abstract class Data extends Node &#123; override def cloneType(): this.type = this.getClass.newInstance.asInstanceOf[this.type] // simple conversions def toSInt: SInt def toUInt: UInt def toBool: Bool def toBits: Bits // flatten out to leaves of tree def flatten: Array[(String, Data)] // port direction if leaf def dir: PortDir // change dir to OUTPUT def asOutput: this.type // change dir to INPUT def asInput: this.type // change polarity of dir def flip: this.type // assign to input def :=[T &lt;: Data](t: T) // bulk assign to input def &lt;&gt;(t: Data)&#125; Data类具有用于在类型之间转换和将端口方法委托给其单个输入的方法。我们将在Port一节讨论端口。最后，用户可以在其自己的类型节点（例如bundle）中覆盖cloneType方法，以便反映克隆所需的构造参数。Data节点可以用于四种目的： types: UInt(width = 8), 在指定最小位宽的图中记录中间类型（在本节中描述） wires: UInt(width = 8), 作为数据的前向声明，允许将来的条件更新（在Updateable一节中描述） ports: UInt(dir = OUTPUT, width = 8), 定义模块接口的专用线，还能指定方向（在Ports一节中描述） literals: UInt(1) 或 UInt(1, 8), 可以使类型对象构造函数来构造其值和可选宽度。 Bits在Chisel中，位的原始集合如下Bits类型定义所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344object Bits &#123; def apply(dir: PortDir = null, width: Int = -1): Bits // create literal from BigInt or Int def apply(value: BigInt, width: Int = -1): Bits // create literal from String using // base_char digit+ string format def apply(value: String, width: Int = -1): Bits &#125;class Bits extends Data with Updateable &#123; // bitwise-not def unary_~(): Bits // bitwise-and def &amp; (b: Bits): Bits // bitwise-or def | (b: Bits): Bits // bitwise-xor def ^ (b: Bits): Bits // and-reduction def andR(): Bool // or-reduction def orR(): Bool // xor-reduction def xorR(): Bool // logical NOT def unary_!(): Bool // logical AND def &amp;&amp; (b: Bool): Bool // logical OR def || (b: Bool): Bool // equality def ===(b: Bits): Bool // inequality def != (b: Bits): Bool // logical left shift def &lt;&lt; (b: UInt): Bits // logical right shift def &gt;&gt; (b: UInt): Bits // concatenate def ## (b: Bits): Bits // extract single bit, LSB is 0 def apply(x: Int): Bits // extract bit field from end to start bit pos def apply(hi: Int, lo: Int): Bits&#125;def Cat[T &lt;: Data](elt: T, elts: T*): Bits Bits具有用于简单位操作的方法。注意，##是二进制连接，而Cat是一个正则拼接。为了避免与Scala的内置==冲突，Chisel的按位比较命名为===。使用Fill可以创建n位宽的域：1def Fill(n: Int, field: Bits): Bits 一个两输入的选择器可以使用Mux：1def Mux[T &lt;: Data](sel: Bits, cons: T, alt: T): T 常量或字面值使用Scala整数或传递给构造函数的字符串表示：1234UInt(1)UInt("ha")UInt("o12")UInt("b1010") // binary 4-bit lit from string. 如下图所示的最左边子图，可以产生Lit。 操作返回一个实际的操作符节点和类型节点组合成输入类型节点。参见上图，了解更复杂的例子。 Bools布尔值用Bools表示：123456object Bool &#123; def apply(dir: PortDir = null): Bool // create literal def apply(value: Boolean): Bool&#125;class Bool extends UInt Bool与UInt(width = 1)相等。 NumsNum是一个类型节点，定义了算术运算：123456789101112131415161718class Num extends Bits &#123; // Negation def unary_-(): Bits // Addition def +(b: Num): Num // Subtraction def -(b: Num): Num // Multiplication def *(b: Num): Num // Greater than def &gt;(b: Num): Bool // Less than def &lt;(b: Num): Bool // Less than or equal def &lt;=(b: Num): Bool // Greater than or equal def &gt;=(b: Num): Bool&#125; 有符号和无符号整数被认为是定点数的子集，并且分别由类型SInt和UInt表示：12345678910111213141516object SInt &#123; def apply (dir: PortDir = null, width: Int = -1): SInt // create literal def apply (value: BigInt, width: Int = -1): SInt def apply (value: String, width: Int = -1): SInt &#125;class SInt extends Num object UInt &#123; def apply(dir: PortDir = null, width: Int = -1): UInt // create literal def apply(value: BigInt, width: Int = -1): UInt def apply(value: String, width: Int = -1): UInt&#125;class UInt extends Num &#123; // arithmetic right shift override def &gt;&gt; (b: UInt): SInt&#125; 带符号的定点数（包括整数）使用二进制补码格式表示。 BundlesBundle将几种不同类型的命名字段组合成一个连续单元，非常像C中的struct：1234class Bundle extends Data &#123; // shallow named bundle elements def elements: ArrayBuffer[(String, Data)]&#125; 使用elements方法可以获取Bundle中每个元素的名称和类型，flatten方法返回嵌套聚合的叶子处的元素。 用户可以通过对bundle进行子类化来定义新的bundle，如下所示：12345class MyFloat extends Bundle &#123; val sign = Bool() val exponent = UInt(width = 8) val significand = UInt(width = 23)&#125; 元素通过Scala字段访问：12val x = new MyFloat() val xs = x.sign 当使用C++或Verilog后端发送时，bundle的元素的名称是从它们的bundle字段名获取的，使用Scala内省。 VecsVecs可以创建可索引元素向量：1234567891011121314151617object Vec &#123; def apply[T &lt;: Data](elts: Seq[T]): Vec[T] def apply[T &lt;: Data](elt0: T, elts: T*): Vec[T] def fill[T &lt;: Data](n: Int) (gen: =&gt; T): Vec[T] def tabulate[T &lt;: Data](n: Int)(gen: (Int) =&gt; T): Vec[T] def tabulate[T &lt;: Data](n1: Int, n2: Int) (gen: (Int, Int) =&gt; T): Vec[Vec[T]]&#125;class Vec[T &lt;: Data](n: Int, val gen: () =&gt; T) extends Data &#123; def apply(idx: UInt): T def apply(idx: Int): T def forall(p: T =&gt; Bool): Bool def exists(p: T =&gt; Bool): Bool def contains[T &lt;: Bits](x: T): Bool def count(p: T =&gt; Bool): UInt def indexWhere(p: T =&gt; Bool): UInt def lastIndexWhere(p: T =&gt; Bool): UInt&#125; 其中n个元素类型由gen定义。用户可以使用Int索引静态访问元素或使用UInt索引动态访问元素，其中动态访问创建一个虚拟类型节点（表示读取“端口”），该节点使用给定地址记录读取。在任一情况下，用户可以连线到读取的结果如下：1v(a) := d 只读存储器可以使用Vecs来表示：12val rom = Vec(UInt(3), UInt(7), UInt(4), UInt(0)) &#123; UInt(width=3) &#125;val dout = rom(addr) Bit Width Inference用户需要设置端口和寄存器的位宽度，否则节点上的位宽度会自动推断，除非用户手动设置（使用Extract或Cat）。位宽推理引擎从图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度： 其中例如wz是线z的位宽度，并且＆规则应用于所有按位逻辑运算。 位宽推理过程继续，直到没有位宽改变。除了固定位数的右移之外，位宽度推断规则规定输出位宽不能小于输入位宽度，因此，输出位宽度增长或保持相同。此外，寄存器的宽度必须由用户明确地或从复位值的位宽指定。从这两个要求，我们可以知道位宽推理过程将收敛到一个固定点。 Updateables当描述线和状态节点的操作时，将规范作为输出值的一系列条件更新并且跨多个单独的语句分布这些更新通常是有用的。例如，可以立即引用数据节点的输出，但可以稍后设置其输入。可更新表示一个条件可更新节点，其累积对节点的访问，并且其稍后可以生成多路复用器以在电路中组合这些访问。123456789abstract class Updateable extends Node &#123; // conditional reads def reads: Queue[(Bool, UInt)] // conditional writes def writes: Queue[(Bool, UInt, Node)] // gen mux integrating all conditional writes def genMuxes(default: Node) override def := (x: Node): this.type&#125; Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格：1234567object when &#123; def apply(cond: Bool)(block: =&gt; Unit): when&#125;class when (prevCond: Bool) &#123; def elsewhen (cond: Bool)(block: =&gt; Unit): when def otherwise (block: =&gt; Unit): Unit&#125; when操作具有动态作用域的全局条件堆栈。因此，when创建一个在条件函数调用中有效的新条件。例如：123456789def updateWhen (c: Bool, d: Data) = when (c) &#123; r := d &#125;when (a) &#123; updateWhen(b, x)&#125;// the same aswhen (a) &#123; when (b) &#123; r := x &#125;&#125; Chisel为其他常见形式的条件更新提供了一些语法糖：1234def unless(c: Bool)(block: =&gt; Unit) = when (!c) &#123; block )def otherwise(block: =&gt; Unit) = when (Bool(true)) &#123; block &#125; 我们再介绍用于条件更新的switch语句，其涉及对一个公共密钥的一系列比较：12def switch(c: UInt)(block: =&gt; Unit): Unit def is(v: Bool)(block: =&gt; Unit) Forward Declaration纯组合电路不允许在节点之间有循环，如果检测到这样的循环，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建法向组合电路，通过添加其输入从已经定义的节点导出的新节点。 时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前参考输出线。因为Scala按顺序执行程序语句，所以我们允许数据节点用作提供节点声明的线，可：1234567val pcPlus4 = UInt() val brTarget = UInt()val pcNext = Mux(pcSel, brTarget, pcPlus4)val pcReg = RegUpdate(pcNext)pcPlus4 := pcReg + UInt(4)... brTarget := addOut 接线操作符：=用于在pcReg和addOut定义之后进行连接。在所有赋值完成后，如果前向声明未分配，则是一个错误。… RegsChisel支持的状态元素的最简单形式是一个正边沿触发寄存器，定义如下：12345678910object Reg &#123; def apply[T &lt;: Data] (data: T, next: T = null, init: T = null): T &#125;object RegNext &#123; def apply[T &lt;: Data] (next: T, init: T = null): T&#125;object RegInit &#123; def apply[T &lt;: Data] (init: T): T&#125;class Reg extends Updateable 可以如下进行构造：1234val r1 = RegUpdate(io.in)val r2 = RegReset(UInt(1, 8))val r3 = RegUpdate(io.in, UInt(1)) val r4 = Reg(UInt(width = 8)) 其中resetVal是reset为ture时用于寄存器的值。 MemsChisel通过Mem结构支持随机存取存储器。写入Mem是正边沿触发，读取是组合或正边沿触发。1234567object Mem &#123; def apply[T &lt;: Data](depth: Int, gen: =&gt; T, seqRead: Boolean = false): Mem&#125;class Mem[T &lt;: Data](gen: () =&gt; T, depth: Int, seqRead: Boolean = false) extends Updateable &#123; def apply(idx: UInt): T&#125; 通过应用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32个条目的寄存器文件可以表示如下：1234val rf = Mem(32, UInt(width = 64)) when (wen) &#123; rf(waddr) := wdata &#125; val dout1 = rf(waddr1)val dout2 = rf(waddr2) 如果设置了可选参数seqRead，当Reg分配了Mem的输出时，Chisel将尝试推断顺序读端口。单读，单写SRAM可以描述如下：1234val ram1r1w = Mem(1024, UInt(width = 32), seqRead = true)val dout = Reg(UInt())when (wen) &#123; ram1r1w(waddr) := wdata &#125; when (ren) &#123; dout := ram1r1w(raddr) &#125; 单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：12345val ram1p =Mem(1024, UInt(width = 32), seqRead = true)val dout = Reg(UInt())when (wen) &#123; ram1p(waddr) := wdata &#125; .elsewhen (ren) &#123; dout := ram1p(raddr) &#125; 如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据是实现定义的。Mem还支持子字写入的写掩码。如果相应的屏蔽位置1，则写入给定位。12val ram = Mem(256, UInt(width = 32))when (wen) &#123; ram.write(waddr, wdata, wmask) &#125; Ports端口是用作硬件模块接口的Data派生节点。端口是原始Data对象的定向版本。端口方向定义如下：123trait PortDirobject INPUT extends PortDir object OUTPUT extends PortDir 聚合端口可以使用vec或bundle的实例作为叶子递归构造。 Modules在Chisel中，module与Verilog中的module非常相似，在生成电路中定义了层次结构。分层模块命名空间可在下游工具中访问，以帮助调试和物理布局。用户定义的模块被定义为一个类： 继承自Module 包含一个接口Bundle，其存储在一个名为io的域中 在其构造器中将子电路连接起来 用户通过子类化Module来编写自己的模块，其定义如下：123456abstract class Module &#123; val io: Bundle var name: String = "" def compileV: Unit def compileC: Unit&#125; 并定义自己的io字段。例如，要定义一个两输入多路复用器，我们将定义一个模块如下：123456789class Mux2 extends Module &#123; val io = new Bundle&#123; val sel = Bool(INPUT) val in0 = Bool(INPUT) val in1 = Bool(INPUT) val out = Bool(OUTPUT) &#125; io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)&#125; :=赋值运算符，在模块定义的主体中使用，是Chisel中的一个特殊运算符，它将左侧的输入连接到右侧的输出。它通常用于将输出端口连接到其定义。 &lt;&gt;操作符批量连接父对象模型之间的对等相反接口或父/子模块之间相同的接口。批量连接使用路径名匹配连接叶子端口。仅当其中一个端口非空时允许连接，从而允许用户重复地批量连接部分填充的接口。在所有连接完成并且电路正在精心设计后，Chisel警告用户端口是否只有一个到它们的连接。 当使用C++或Verilog后端发送时，存储在模块中的节点和子模块的名称可以使用Scala内省从它们的模块字段名称中获取。使用函数setName()设置节点或子模块的名称。 Black Box黑盒允许用户定义接口到Chisel之外定义的电路。用户定义： 一个BlackBox子类的模块 一个带有接口的io 可选的VerilogParameters子类 例如，可以将简单的ROM黑盒定义为：12345678910111213141516171819class RomIo extends Bundle &#123; val isVal = Bool(INPUT) val raddr = UInt(INPUT, 32) val rdata = UInt(OUTPUT, 32) raddr.setName("RADDR")&#125;class RomParams extends VerilogParameters &#123; val MY_STR = "Test" val MY_INT = 5&#125;class Rom extends BlackBox &#123; val io = new RomIo() val romParams = new RomParams() setVerilogParameters(romParams) renameClock(Driver.implicitClock, "clock_A") renameClock("my_other_clock", "test_clock") renameReset("rst") // Define how to use in simulation here&#125; 参数将转换为verilog参数，其中包含类定义中使用的名称和值。setVerilogParameters也可以直接接受一个字符串。函数renameClock可以获取Clock对象或时钟的字符串名称来重命名BlackBox输出时钟。函数renameReset将重命名隐式重置。如果需要命名其他重置，请调用setName()。在io类中显示了使用setName()的示例。而不是被称为io_raddr为黑箱的io，它将是RADDR。黑盒在c模拟中作为一个模块。这意味着您可以使用io实现BlackBox的功能，以便您可以验证您的设计。 Printf &amp; SprintfChisel提供了为调试目的格式化和打印字符串的能力。printf和sprintf结构与它们的C名称类似：它们取一个格式字符串和可变数量的参数，然后分别打印或返回一个字符串。在模拟期间，printf在上升时钟沿将控制字符串打印到控制台。另一方面，sprintf返回格式化的字符串作为位向量。 支持的格式说明符是％b（二进制数），％d（十进制数），％x（十六进制数）和％s（由8位扩展ASCII字符序列组成的字符串）。%%指定文字％。）与C不同，没有宽度修饰符：相应参数的位宽决定了字符串表示中的宽度。 以下示例在c为true时打印“0x4142 16706 AB”行：123val x = Bits(0x4142)val s1 = sprintf("%x %s", x, x);when (c) &#123; printf("%d %s\n", x, s1); &#125; Assert运行时断言由assert结构提供。在仿真期间，如果断言的论点在上升时钟边沿为false，则会打印错误并终止仿真。例如，以下将在十个时钟周期后终止仿真：123val x = Reg(init = UInt(0, 4)) x := x + UInt(1)assert(x &lt; UInt(10)) Main &amp; Testing为了构造一个电路，用户从它们的顶层main函数调用chiselMain：1234object chiselMain &#123; def apply[T &lt;: Module] (args: Array[String], comp: () =&gt; T): T &#125; 运行以上对象会在–targetDir dir_name参数指定的目录下生成module_name.cpp和module_name.h C++文件。 测试是电路设计的一个关键部分，因此在Chisel中，我们提供了一种测试电路的机制，通过使用Tester类的子类在Scala中提供测试向量：123456789101112131415161718class Tester[T &lt;: Module] (val c: T, val isTrace: Boolean = true) &#123; var t: Int var ok: Boolean val rnd: Random def int(x: Boolean): BigInt def int(x: Int): BigInt def int(x: Bits): BigInt def reset(n: Int = 1) def step(n: Int): Int def pokeAt(data: Mem[T], index: Int, x: BigInt) def poke(data: Bits, x: BigInt) def poke(data: Aggregate, x: Array[BigInt]) def peekAt(data: Mem[T], index: Int) def peek(data: Bits): BigInt def peek(data: Aggregate): Array[BigInt] def expect (good: Boolean, msg: String): Boolean def expect (data: Bits, target: BigInt): Boolean&#125; 它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户利用： poke: 设置端口和状态值 step: 以一个时间单位执行电路 peek: 读端口和状态值 expect: 比较测试电路的值和预期的值 用户通过如下方式连接tester实例和模块：12345object chiselMainTest &#123; def apply[T &lt;: Module] (args: Array[String], comp: () =&gt; T)( tester: T =&gt; Tester[T]): T&#125; 当–test作为chiselMain的参数时，tester实例在单独的进程中运行被测设计（DUT），stdin和stdout连接，以便调试命令可以发送到DUT，并且响应可以从DUT如图所示。 如下所示：1234567891011121314class Mux2Tests(c: Mux2) extends Tester(c) &#123; val n = pow(2, 3).toInt for (s &lt;- 0 until 2) &#123; for (i0 &lt;- 0 until 2) &#123; for (i1 &lt;- 0 until 2) &#123; poke(c.io.sel, s) poke(c.io.in1, i1) poke(c.io.in0, i0) step(1) expect(c.io.out, (if (s == 1) i1 else i0)) &#125; &#125; &#125; &#125; 使用poke将Mux2的每个输入的分配设置为适当的值。对于这个特定的例子，我们通过将输入硬编码到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块的适当输入，并告诉模拟将这些值分配给我们正在测试的器件的输入c，步骤电路和测试期望值。最后，下面显示了如何调用测试器：123chiselMainTest(args + "--test", () =&gt; new Mux2())&#123; c =&gt; new Mux2Tests(c)&#125; 最后，chiselMain*有以下命令参数： –targetDir 目标路径前缀–genHarness 生成C++文件–debug 把所有wire放入C++类文件中–compile 编译生成的C++–test 使用C++应用运行测试–backend v 产生verilog–backend c 产生C++（默认）–vcd 使能vcd打印 C++ EmulatorC ++仿真器基于使用C ++模板的快速多字库。 单个字由val_t定义如下：123typedef uint64_t val_t; typedef int64_t sval_t; typedef uint32_t half_val_t; 多字由dat_t定义，如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081template &lt;int w&gt; class dat_t &#123; public: const static int n_words; inline int width ( void ); inline int n_words_of ( void ); inline bool to_bool ( void ); inline val_t lo_word ( void ); inline unsigned long to_ulong ( void ); std::string to_str (); dat_t&lt;w&gt; ();template &lt;int sw&gt; dat_t&lt;w&gt; (const dat_t&lt;sw&gt;&amp; src); dat_t&lt;w&gt; (const dat_t&lt;w&gt;&amp; src); dat_t&lt;w&gt; (val_t val);template &lt;int sw&gt; dat_t&lt;w&gt; mask(dat_t&lt;sw&gt; fill, int n);template &lt;int dw&gt; dat_t&lt;dw&gt; mask(int n);template &lt;int n&gt; dat_t&lt;n&gt; mask(void); dat_t&lt;w&gt; operator + ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator - ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator - ( ); dat_t&lt;w+w&gt; operator * ( dat_t&lt;w&gt; o ); dat_t&lt;w+w&gt; fix_times_fix( dat_t&lt;w&gt; o ); dat_t&lt;w+w&gt; ufix_times_fix( dat_t&lt;w&gt; o ); dat_t&lt;w+w&gt; fix_times_ufix( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &lt; ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &gt; ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &gt;= ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &lt;= ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; gt ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; gte ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; lt ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; lte ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator ^ ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator &amp; ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator | ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator ~ ( void); dat_t&lt;1&gt; operator ! ( void ); dat_t&lt;1&gt; operator &amp;&amp; ( dat_t&lt;1&gt; o ); dat_t&lt;1&gt; operator || ( dat_t&lt;1&gt; o ); dat_t&lt;1&gt; operator == ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator == ( datz_t&lt;w&gt; o ); dat_t&lt;1&gt; operator != ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator &lt;&lt; ( int amount ); dat_t&lt;w&gt; operator &lt;&lt; ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator &gt;&gt; ( int amount ); dat_t&lt;w&gt; operator &gt;&gt; ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; rsha ( dat_t&lt;w&gt; o); dat_t&lt;w&gt;&amp; operator = ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; fill_bit(val_t bit); dat_t&lt;w&gt; fill_byte(val_t byte, int nb, int n);template &lt;int dw, int n&gt; dat_t&lt;dw&gt; fill( void );template &lt;int dw, int nw&gt; dat_t&lt;dw&gt; fill( dat_t&lt;nw&gt; n );template &lt;int dw&gt; dat_t&lt;dw&gt; extract(); template &lt;int dw&gt; dat_t&lt;dw&gt; extract(val_t e, val_t s); template &lt;int dw, int iwe, int iws&gt; dat_t&lt;dw&gt; extract(dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s);template &lt;int sw&gt; dat_t&lt;w&gt; inject(dat_t&lt;sw&gt; src, val_t e, val_t s); template &lt;int sw, int iwe, int iws&gt; dat_t&lt;w&gt; inject (dat_t&lt;sw&gt; src, dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s); template &lt;int dw&gt; dat_t&lt;dw&gt; log2(); dat_t&lt;1&gt; bit(val_t b); val_t msb();template &lt;int iw&gt; dat_t&lt;1&gt; bit(dat_t&lt;iw&gt; b)&#125;template &lt;int w, int sw&gt; dat_t&lt;w&gt; DAT(dat_t&lt;sw&gt; dat);template &lt;int w&gt; dat_t&lt;w&gt; LIT(val_t value);template &lt;int w&gt; dat_t&lt;w&gt; mux ( dat_t&lt;1&gt; t, dat_t&lt;w&gt; c, dat_t&lt;w&gt; a ) 其中w是位宽参数。 Chisel编译器将顶层模块编译为可以创建和执行的单个扁平的mod_t类：123456789101112131415class mod_t &#123; public: // initialize module virtual void init (void) &#123; &#125;; // compute all combinational logic virtual void clock_lo (dat_t&lt;1&gt; reset) &#123; &#125;; // commit state updates virtual void clock_hi (dat_t&lt;1&gt; reset) &#123; &#125;; // print printer specd node values to stdout virtual void print (FILE* f) &#123; &#125;; // scan scanner specd node values from stdin virtual bool scan (FILE* f) &#123; return true; &#125;; // dump vcd file virtual void dump (FILE* f, int t) &#123; &#125;;&#125;; Chisel编译器可以创建一个线束，或者用户可以自己写一个线束。以下是CPU模块的线束示例：12345678910111213#include "cpu.h"int main (int argc, char* argv[]) &#123; cpu_t* c = new cpu_t(); int lim = (argc &gt; 1) ? atoi(argv[1]) : -1; c-&gt;init(); for (int t = 0; lim &lt; 0 || t &lt; lim; t++) &#123; dat_t&lt;1&gt; reset = LIT&lt;1&gt;(t == 0); if (!c-&gt;scan(stdin)) break; c-&gt;clock_lo(reset); c-&gt;clock_hi(reset); c-&gt;print(stdout); &#125; &#125; Verilog当-v参数传递到chiselMain时，Chisel生成Verilog。 例如，从SBT，以下：1run --v 将在目标目录中生成名为module-name.v的单个Verilog文件。该文件将包含一个模块，每个模块定义为在chiselMain中创建的顶层模块的子模块。具有相同接口和主体的模块将被缓存和重用。 Multiple Clock DomainsCreating Clock domains为了使用多个时钟域，用户必须创建多个时钟。在Chisel中，时钟是用复位信号参数创建的一级节点，并定义如下：123class Clock (reset: Bool) extends Node &#123; def reset: Bool // returns reset pin&#125; 在Chisel中有一个内置的隐式时钟，状态元素默认使用：1var implicitClock = new Clock( implicitReset ) 状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：123Reg(... clock: Clock = implicitClock) Mem(... clock: Clock = implicitClock) Module(... clock: Clock = implicitClock) Crossing Clock Domains有两种方式可以定义电路在时钟域之间发送数据。第一种和最原始的方式是使用由两个寄存器组成的同步电路，如下所示：1234567// signalA is in clock domain clockA,// want a version in clockB as signalBval s1 = Reg(init = UInt(0), clock = clockB) val s2 = Reg(init = UInt(0), clock = clockB)s1 := signalAs2 := s1;signalB := s2 由于亚稳性问题，该技术限于在域之间传递一位数据。 在域之间发送数据的第二种更一般的方式是通过使用异步fifo：12class AsyncFifo[T&lt;:Data](gen: T, entries: Int, enq_clk: Clock, deq_clock: Clock) extends Module 然后，我们可以通过指定标准fifo参数和两个时钟，然后使用标准去耦就绪/有效信号，从时钟频率A到时钟B获得一个版本的signalA：123456val fifo = new AsyncFifo(Uint(width = 32), 2, clockA, clockB)fifo.io.enq.bits := signalAsignalB := fifo.io.deq.bits fifo.io.enq.valid := condA fifo.io.deq.ready := condB... Backend Specific Multiple Clock Domains时钟域可以以域特定的方式映射到C++和Verilog后端。为了展示如何驱动多时钟设计，考虑硬件示例，其中两个模块使用AsyncFifo进行通信，每个模块在不同的时钟：fastClock和slowClock。 C++在C ++后端，对于每个时钟i，有一个： uint64_t clk_i域表示时钟i的周期 uint63_t clk_i_cnt域表示时钟i当前计数 clock_lo_i和clock_hi_i int reset()函数，其保证了所有的clock_lo和clock_hi函数被立即调用 int clock(reset)函数，其计算最小增量，调用适当的clock_lo和clock_hi，并返回使用的最小增量。 为了建立C++模拟，用户需要： 将所有周期字段初始化为所需周期 将所有计数字段初始化为期望的相位 调用reset 重复调用时钟逐步模拟 以下是slowClock / fastClock的main函数C++示例：12345678910111213int main(int argc, char** argv) &#123; ClkDomainTest_t dut; dut.init(1); dut.clk = 2; dut.clk_cnt = 1; dut.fastClock = 4; dut.fastClock_cnt = 0; dut.slowClock = 6; dut.slowClock_cnt = 0; for (int i = 0; i &lt; 12; i ++) dut.reset(); for (int i = 0; i &lt; 96; i ++) dut.clock(LIT&lt;1&gt;(0)); &#125; Verilog在verilog中， Chisel为每个时钟/复位创建一个新端口 Chisel将所有时钟连接到顶部模块 用户必须为每个时钟i创建一个always块时钟驱动器 以下是驱动slowClock / fastClock示例电路的顶层线束的Verilog示例：123456789101112131415161718192021module emulator; reg fastClock = 0, slowClock = 0, resetFast = 1, resetSlow = 1; wire [31:0] add, mul, test; always #2 fastClock = ~fastClock; always #4 slowClock = ~slowClock; initial begin #8 resetFast = 0; resetSlow = 0; #400 $finish; endClkDomainTest dut ( .fastClock(fastClock), .slowClock(slowClock), .io_resetFast(resetFast), .io_resetSlow(resetSlow), .io_add(add), .io_mul(mul), .io_test(test));endmodule Extra Stuff1234567891011121314151617181920def ListLookup[T &lt;: Bits](addr: UInt, default: List[T], mapping: Array[(UInt, List[T])]): List[T]// def Lookup[T &lt;: Data] (addr: UInt, default: T, mapping: Seq[(UInt, T)]): T// // n-way multiplexordef MuxCase[T &lt;: Data](default: T, mapping: Seq[(Bool, T)]): T//// n-way indexed multiplexer:def MuxLookup[S &lt;: UInt, T &lt;: Data](key: S, default: T, mapping: Seq[(S, T)]): T//// create n enum values of given typedef Enum[T &lt;: UInt](n: Int)(gen: =&gt; T): List[T]//// create enum values of given type and namesdef Enum[T &lt;: UInt](l: Symbol *)(gen: =&gt; T): Map[Symbol, T]//// create enum values of given type and namesdef Enum[T &lt;: UInt](l: List[Symbol])(gen: =&gt; T): Map[Symbol, T] Standard LibraryMath123456789101112131415// Returns the log base 2 of the input // Scala Integer rounded updef log2Up(in: Int): Int// Returns the log base 2 of the input // Scala Integer rounded downdef log2Down(in: Int): Int////// Returns true if the input Scala Integer //isapowerof2def isPow2(in: Int): Boolean////// linear feedback shift registerdef LFSR16(increment: Bool = Bool(true)): UInt Sequential123456789101112// Returns the n-cycle delayed version// of the input signal// Has an optional enable signal defaulting to true def ShiftRegister[T &lt;: Data (in: T, n: Int, en = Bool(true)): T def Counter(cond: Bool, n: Int) = &#123; val c = RegReset(UInt(0, log2Up(n))) val wrap = c === UInt(n-1) when (cond) &#123; c := Mux(Bool(!isPow2(n)) &amp;&amp; wrap, UInt(0), c + UInt(1)) &#125; (c, wrap &amp;&amp; cond) &#125; UInt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Returns the number of bits set in the // input signal. Causes an exception if // the input is wider than 32 bits.def PopCount(in: UInt): UInt////// Returns the reverse the input signaldef Reverse(in: UInt): UInt////// returns the one hot encoding of// the input UIntdef UIntToOH(in: UInt, width: Int): UInt////// does the inverse of UIntToOHdef OHToUInt(in: UInt): UIntdef OHToUInt(in: Seq[Bool]): UInt////// Builds a Mux tree out of the input// signal vector using a one hot encoded // select signal. Returns the output of // the Mux treedef Mux1H[T &lt;: Data] (sel: UInt, in: Vec[T]): T def Mux1H[T &lt;: Data] (sel: Vec[Bool], in: Vec[T]): T//// Builds a Mux tree under the// assumption that multiple// select signals can be enabled.// Priority is given to the first// select signal. Returns the output // of the Mux tree.def PriorityMux[T &lt;: Data](sel: UInt, in: Seq[T]): T def PriorityMux[T &lt;: Data](sel: Seq[UInt], in: Seq[T]): T//// Returns the bit position of the// trailing 1 in the input vector with // the assumption that multiple bits of // the input bit vector can be setdef PriorityEncoder(in: UInt): UIntdef PriorityEncoder(in: Seq[Bool]): UInt////// Returns the bit position of the// trailing 1 in the input vector with// the assumption that only one bit in// the input vector can be setdef PriorityEncoderOH(in: UInt): UIntdef PriorityEncoderOH(in: Seq[Boo]): UInt Decoupled123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Adds a ready-valid handshaking // protocol to any interface. The// standard used is that the// consumer uses the fliped interface//class DecoupledIO[+T &lt;: Data](gen: T) extends Bundle &#123; val ready = Bool(INPUT) val valid = Bool(OUTPUT) val bits = gen.cloneType.asOutput&#125;////// Adds a valid protocol to any// interface. The standard used is // that the consumer uses the// fliped interface.class ValidIO[+T &lt;: Data](gen: T) extends Bundle &#123; val valid = Bool(OUTPUT) val bits = gen.cloneType.asOutput&#125;////// Hardware module that is used to // sequence n producers into 1 consumer// Priority is given to lower// producer// Example usage: // val arb = new Arbiter(UInt(), 2)// arb.io.in(0) &lt;&gt; producer0.io.out// arb.io.in(1) &lt;&gt; producer1.io.out// consumer.io.in &lt;&gt; arb.io.outclass Arbiter[T &lt;: Data](gen: T, n: Int) extends Module// Hardware module that is used to// sequence n producers into 1 consumer.// Producers are chosen in round robin// order// Example usage:// val arb = new RRArbiter(UInt(), 2) // arb.io.in(0) &lt;&gt; producer0.io.out // arb.io.in(1) &lt;&gt; producer1.io.out // consumer.io.in &lt;&gt; arb.io.out class RRArbiter[T &lt;: Data](gen: T, n: Int) extends Module// Generic hardware queue. Required // parameter entries controls the// depth of the queues. The width of// the queue is determined from the // inputs.// Example usage:// val q = new Queue(UInt(), 16)// q.io.enq &lt;&gt; producer.io.out// consumer.io.in &lt;&gt; q.io.deqclass Queue[T &lt;: Data] (gen: T, entries: Int, pipe: Boolean = false, flow: Boolean =false) extends Module//// A hardware module that delays data // coming down the pipeline by the // number of cycles set by the // latency parameter. Functionality // is similar to ShiftRegister but // this exposes a Pipe interface. // Example usage:// val pipe = new Pipe(UInt()) // pipe.io.enq &lt;&gt; produce.io.out // consumer.io.in &lt;&gt; pipe.io.deqclass Pipe[T &lt;: Data](gen: T, latency: Int = 1) extends Module （完）]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel入门教程]]></title>
    <url>%2F2016%2F12%2F17%2Fchisel-tutorial%2F</url>
    <content type="text"><![CDATA[原文链接 介绍Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例子来说明某些重要的Scala特征，可以让你只使用本文介绍的东西也能完成一些伟大的硬件设计。 当你越来越有经验，希望自己的代码能够更加简化或提高复用性，你会发现有必要了解Scala语言的潜力。 所以，进一步学习Scala会让你变得更加专业。 Chisel仍处于起步阶段，你可能会遇到一些实现方面的bug，甚至可能会遇到一些概念设计问题。不过，我们正在积极地修改和改进语言，并且对错误报告和建议开放。即使在早期阶段，我们希望Chisel将帮助设计师在构建易于重复使用和维护的设计时更有效率。 Chisel硬件表达此版本的Chisel只支持二进制逻辑，不支持三态信号。 我们专注于二进制逻辑设计，因为它们构成了实践中的绝大多数设计。我们忽略对当前Chisel语言中的三态逻辑的支持，因为这在工业环境中也很少支持，并且难以在受控硬宏之外可靠地使用。 Chisel数据类型Chisel数据类型用于指定状态元素中保存的值或wire上传输的值。虽然硬件设计最终操作的是二进制数值向量，但对于值的其他抽象表示具有更清晰的规范，并且能够帮助工具生成更优化的电路。在Chisel中，原始比特集合可以用Bits类型来表示。带符号和无符号整数被认为是定点数的子集，可以用SInt和UInt来表示。带符号定点整数（包括整数）使用二进制补码格式来表示。布尔值可以用Bool类型表示。注意，这些类型与Scala的内建类型不同，例如Int或Boolean。另外，Chisel定义了Bundle用来将值进行集合（类似于其他语言中的struct），还定义了Vec用来对值的集合进行索引。 常量或字面值使用Scala整数或传递给构造函数的字符串表示：123456789UInt(1) // decimal 1-bit lit from Scala Int.UInt("ha") // hexadecimal 4-bit lit from string.UInt("o12") // octal 4-bit lit from string.UInt("b1010") // binary 4-bit lit from string.SInt(5) // signed decimal 4-bit lit from Scala Int. SInt(-8) // negative decimal 4-bit lit from Scala Int. UInt(5) // unsigned decimal 3-bit lit from Scala Int.Bool(true) // Bool lits from Scala lits. Bool(false) 下划线可以用作长字符串文字中的分隔符，以帮助可读性，但在创建值时会被忽略，例如：1UInt("h_dead_beef") // 32-bit lit of type UInt 默认情况下，Chisel编译器将每个常量的大小设置为保存常量所需的最小位数，包括带符号类型的符号位。位宽也可以在字面上明确指定，如下所示：12345UInt("ha", 8) // hexadecimal 8-bit lit of type UInt UInt("o12", 6) // octal 6-bit lit of type UInt UInt("b1010", 12) // binary 12-bit lit of type UIntSInt(5, 7) // signed decimal 7-bit lit of type SInt UInt(5, 8) // unsigned decimal 8-bit lit of type UInt 对于UInt类型值，值被零扩展到所需的位宽。对于类型为SInt的文字，该值被符号扩展以填充所需的位宽度。如果给定的位宽太小而不能容纳参数值，则会生成Chisel错误。 组合电路在Chisel中，电路会被表示为一张节点图。每个节点是具有零个或多个输入并驱动一个输出的硬件运算符。上面介绍的Uint是一种退化类型的节点，它没有输入，并且在其输出上驱动一个恒定的值。创建和连接节点的一种方法是使用字面表达式。例如，我们可以使用以下表达式来表示简单的组合逻辑电路：1(a &amp; b) | (~c &amp; d) 语法应该看起来很熟悉，用＆和|分别表示按位与和按位或，~表示按位非。a到d表示某些（未指定）宽度的命名导线。任何简单的表达式都可以直接转换成电路树，在叶子处使用命名的导线和操作符形成内部节点。表达式的电路输出取自树根处的运算符，在本示例中是按位或运算。简单表达式可以以树的形式构建电路，但是如果想以任意有向非循环图（DAG）的形式构建电路，我们需要描述扇出。在Chisel中，我们通过命名一根wire来表示一个子表达式，这样我们就可以在后续表达式中多次引用。我们通过声明变量来命名Chisel中的wire。例如，考虑如下示例的select表达式，它在后续的多选器描述中可以多次使用：12val sel = a | bval out = (sel &amp; in1) | (~sel &amp; in0) 关键字val是Scala的一部分，用于命名具有不会再更改的值的变量。 在上面的例子中它命名了wire类型的sel，保存了第一个按位或运算符的输出，以便输出可在第二个表达式中多次使用。 内建操作符Chisel定义了一组硬件操作符，如下表所示： 位宽接口用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度： 其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算。 位宽推测过程会持续到没有位宽改变。 除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。 此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。 我们选择的运算符名称受到Scala语言的限制。所以我们必须使用===表示等于判断逻辑和=/=表示不等判断逻辑，这样可以保持原生Scala相关运算符可用。 功能抽象我们可以定义函数来分解一个重复的逻辑，这样可以在后续设计中重复使用。例如，我们可以包装一个简单的组合逻辑块：12def clb(a: UInt, b: UInt, c: UInt, d: UInt): UInt = (a &amp; b) | (~c &amp; d) 其中clb是表示以a，b，c，d为参数的函数，并返回一个布尔电路的输出。 def关键字是Scala的一部分，表示引入了一个函数定义，每个语句后面跟一个冒号，然后是它的类型，函数返回类型在参数列表之后的冒号之后。（=）符号将函数参数列表与函数定义分隔开。然后我们就可以在其他的电路中使用了：1val out = clb(a,b,c,d) 我们将在后面介绍许多吊炸天的函数使用方法来构造硬件。 Bundles &amp; VecsBundle和Vec是可以允许用户使用其他数据类型来扩展Chisel数据类型集合的类。Bundle可以将一些不同类型的命名字段组合成一个单元，类似于C语言中的struct。用户可以通过将一个类定义为Bundle的子类来定义自己的bundle：1234567class MyFloat extends Bundle &#123; val sign = Bool() val exponent = UInt(width = 8) val significand = UInt(width = 23)&#125;val x = new MyFloat()val xs = x.sign scala约定将新类的名称的首字母大写，所以我们建议在Chisel中也遵循这个约定。 UInt构造函数的width命名参数指定类型中的位数。 Vecs用来创建一个可索引的元素向量，其构造如下所示：1234// Vector of 5 23-bit signed integers.val myVec = Vec.fill(5)&#123; SInt(width = 23) &#125; // Connect to one element of vector.val reg3 = myVec(3) （注意，我们必须在花括号内指定Vec元素的类型，因为我们必须将位宽参数传递给SInt构造器。）原始类（SInt，UInt和Bool）加上聚合类（Bundles和Vecs）都继承自一个公共的超类Data。在电路中，每个最终继承自Data的对象都可以表示为一个位向量。Bundle和Vec可以任意嵌套，从而构建复杂的数据结构：1234567class BigBundle extends Bundle &#123; // Vector of 5 23-bit signed integers. val myVec = Vec.fill(5) &#123; SInt(width = 23) &#125; val flag = Bool() // Previously defined bundle. val f = new MyFloat()&#125; 端口端口用作硬件组件的接口。一个端口可以是任意的Data对象，但它是具有方向的。Chisel提供端口构造函数，以允许在构建时给对象添加（输入或输出）。原始的端口构造函数需要将方向作为第一个参数（方向为INPUT或OUTPUT），将位数作为第二个参数（除了始终为1位的布尔值）。端口的声明如下所示：12345class Decoupled extends Bundle &#123; val ready = Bool(OUTPUT) val data = UInt(INPUT, 32) val valid = Bool(INPUT)&#125; Decoupled被定义后，它就会变成一个新的类型，可以根据需要用于模块接口或命名的wire集合。对象的方向也可以实例化时确定：12345class ScaleIO extends Bundle &#123; val in = new MyFloat().asInput val scale = new MyFloat().asInput val out = new MyFloat().asOutput&#125; asInput和asOutput方法可以强制数据对象的所有模块设置成对应的方向。通过将方向折叠到对象声明中，Chisel能够提供强大的布线能力，稍后会详细介绍。 Modules我们现在可以构建电路层次，我们可以从较小的子模块开开始构建更大的模块。例如，我们可以通过将三个2输入多路选择器连接在一起，构建一个4输入多路选择器模块：1234567891011121314151617181920212223class Mux4 extends Module &#123; val io = new Bundle &#123; val in0 = UInt(INPUT, 1) val in1 = UInt(INPUT, 1) val in2 = UInt(INPUT, 1) val in3 = UInt(INPUT, 1) val sel = UInt(INPUT, 2) val out = UInt(OUTPUT, 1) &#125; val m0 = Module(new Mux2()) m0.io.sel := io.sel(0) m0.io.in0 := io.in0; m0.io.in1 := io.in1 val m1 = Module(new Mux2()) m1.io.sel := io.sel(0) m1.io.in0 := io.in2; m1.io.in1 := io.in3 val m3 = Module(new Mux2()) m3.io.sel := io.sel(1) m3.io.in0 := m0.io.out; m3.io.in1 := m1.io.out io.out := m3.io.out &#125; 运行和测试现在我们已经定义了模块，我们将讨论如何实际运行并测试电路。Chisel代码可以转换为C++或Verilog。 为了编译电路，我们需要调用chiselMain：12345object tutorial &#123; def main(args: Array[String]) = &#123; chiselMain(args, () =&gt; Module(new Mux2())) &#125; &#125; 测试是电路设计的关键部分，因此在Chisel中，我们通过这样一种测试机制：使用Tester类的子类在Scala中提供测试向量：1234567891011121314151617class Tester[T &lt;: Module] (val c: T, val isTrace: Boolean = true) &#123; var t: Int val rnd: Random def int(x: Boolean): BigInt def int(x: Int): BigInt def int(x: Bits): BigInt def reset(n: Int = 1) def step(n: Int): Int def pokeAt(data: Mem[T], index: Int, x: BigInt) def poke(data: Bits, x: BigInt) def poke(data: Aggregate, x: Array[BigInt]) def peekAt(data: Mem[T], index: Int) def peek(data: Bits): BigInt def peek(data: Aggregate): Array[BigInt] def expect (good: Boolean, msg: String): Boolean def expect (data: Bits, target: BigInt): Boolean&#125; 它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户会用到一下这些： poke: 设置输入端口以及状态值 step: 以一个时间单元执行电路 peek: 读取端口和状态值 expect: 比较peek获得的值和期望的值 用户使用如下的方式连接tester和模块：12345object chiselMainTest &#123; def apply[T &lt;: Module] (args: Array[String], comp: () =&gt; T)( tester: T =&gt; Tester[T]): T&#125; 当- -test作为参数传递给chiselMainTest时，tester实例在独立的进程中运行被测器件（DUT），并连接stdin和stdout，这样调试命令可以发送到DUT，响应也可以从DUT接收，如图所示。 举例说明：1234567891011121314class Mux2Tests(c: Mux2) extends Tester(c) &#123; val n = pow(2, 3).toInt for (s &lt;- 0 until 2) &#123; for (i0 &lt;- 0 until 2) &#123; for (i1 &lt;- 0 until 2) &#123; poke(c.io.sel, s) poke(c.io.in1, i1) poke(c.io.in0, i0) step(1) expect(c.io.out, (if (s == 1) i1 else i0)) &#125; &#125; &#125;&#125; 使用poke将Mux2的每个输入的分别设置为合适的值。对于这个例子，我们通过硬编码输入到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块输入，让模拟将这些值分配给我们正在测试的器件c的输入，单步运行电路并对比期望值。最后，简单说明一下如何调用测试器：123chiselMainTest(args + "--test", () =&gt; Module(new Mux2()))&#123; c =&gt; new Mux2Tests(c)&#125; 还有其他的一些命令参数： –targetDir 目标路径名前缀–genHarness 生成C++文件–backend v 生成verilog–backend c 生成C++（默认）–vcd 开启vcd打印–debug 把所有的wire放入class文件 状态元素Chisel支持的状态元素的最简单形式是上升沿触发寄存器，可以实例化为：1val reg = Reg(next = in) 该电路具有输出，该输出是前一个时钟周期的输入信号产生的值。注意，我们不必指定Reg的类型，因为它会在实例化时从输入开始自动推断。在当前版本的Chisel中，时钟和复位是全局信号，在需要时可以隐式包含。使用寄存器，我们可以快速定义一些有用的电路结构。 例如，当当前值为true且之前的值为false时，上升沿检测器能够获取到布尔信号并输出true，如下所示：1def risingedge(x: Bool) = x &amp;&amp; !Reg(next = x) 计数器是一个重要的时序电路。 如果想构建一个向上计数器，计数到最大值max后回到零：12345def counter(max: UInt) = &#123; val x = Reg(init = UInt(0, max.getWidth)) x := Mux(x === max, UInt(0), x + UInt(1)) x&#125; 计数器复位值为0（宽度大到足以容纳max），当电路的全局复位置位时，寄存器将初始化为该值。计数器可用于构建很多有用的时序电路。例如，我们可以通过在计数器达到零时输出true来构建脉冲发生器：12// Produce pulse every n cycles.def pulse(n: UInt) = counter(n - UInt(1)) === UInt(0) 然后可以通过切换方波发生器脉冲序列，在每个脉冲上的true和false之间切换：12345678// Flip internal state when input true.def toggle(p: Bool) = &#123; val x = Reg(init = Bool(false)) x := Mux(p, !x, x) x&#125;// Square wave of a given period.def squareWave(period: UInt) = toggle(pulse(period/2)) 转发声明纯组合电路在节点之间不存在周期，如果检测到这样的周期，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建组合电路，通过添加一些输入从已经定义的节点导出的新节点。时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前输出。因为Scala顺序执行程序语句，所以我们允许数据节点作为wire来提供节点声明，这样可以立即被使用，但其输入将稍后设置。如下例所示，在简单的CPU中，我们需要定义pcPlus4和brTarget的线，以便在定义之前引用它们：1234567val pcPlus4 = UInt()val brTarget = UInt()val pcNext = Mux(io.ctrl.pcSel, brTarget, pcPlus4)val pcReg = Reg(next = pcNext, init = UInt(0, 32)) pcPlus4 := pcReg + UInt(4)...brTarget := addOut 接线操作符:=用于在pcReg和addOut定义后连接。 条件更新在前面使用到寄存器的示例中，我们简单地将组合逻辑块连接到寄存器的输入。当描述状态元素的操作时，指定何时将发生寄存器更新并且用几个单独的语句指明这些更新。Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格。例如，1234val r = Reg(init = UInt(0, 16)) when (cond) &#123; r := r + UInt(1) &#125; 其中只有在cond为真时，才在当前时钟周期的结尾更新寄存器r。when的参数是返回Bool值。后面的更新块只能包含使用赋值运算符:=，简单表达式和用val定义的命名引线的更新语句。在条件更新序列中，条件为真的最近条件更新优先。 例如：12when (c1) &#123; r := UInt(1) &#125; when (c2) &#123; r := UInt(2) &#125; 上述表达式会根据以下真值表更新r： c1 c2 r 0 0 r r 不变 0 1 2 1 0 1 1 1 2 c2优先于c1 下图显示了如何将每个条件更新视为在寄存器的输入之前插入mux，根据when选择更新表达式或之前的输入。编译器会把初始化值置于链的开头，以便如果在一个时钟周期内没有条件更新激活，则寄存器的加载使能将被置为无效，寄存器值就不会改变。 Chisel为条件更新的其他常见形式提供了一些语法糖。除非结构与when相同，但否定其条件。也就是说，123unless (c) &#123; body &#125;// the same aswhen (!c) &#123; body &#125; 更新块可以操作多个目标寄存器，在不同更新块中的也允许存在寄存器的不同重叠子集。每个寄存器只受其出现的条件的影响。组合电路（更新Wire）也是可能的。注意，所有组合电路需要默认值。例如：123r := SInt(3); s := SInt(3)when (c1) &#123; r := SInt(1); s := SInt(1) &#125; when (c2) &#123; r := SInt(2) &#125; 上述语句会根据如下真值表更新r和s： c1 c2 r s 0 0 3 3 0 1 2 3 1 0 1 1 1 1 2 1 条件更新结构可以嵌套，任何给定块在所有外嵌套条件的联合下才能执行。例如，123when (a) &#123; when (b) &#123; body &#125; &#125;// the same aswhen (a &amp;&amp; b) &#123; body &#125; 条件可以使用when，.elsewhen，.otherwise来链式表达，对应于Scala中的if, else if, else。例如：1234567when (c1) &#123; u1 &#125; .elsewhen (c2) &#123; u2 &#125; .otherwise &#123; ud &#125;// the same aswhen (c1) &#123; u1 &#125;when (!c1 &amp;&amp; c2) &#123; u2 &#125; when (!(c1 || c2)) &#123; ud &#125; 我们再介绍关于用于条件更新的switch语句，其涉及针对公共密钥的一系列比较。例如，1234567switch(idx) &#123; is(v1) &#123; u1 &#125; is(v2) &#123; u2 &#125;&#125;// the same sawhen (idx === v1) &#123; u1 &#125; .elsewhen (idx === v2) &#123; u2 &#125; Chisel还允许Wire，即一些组合逻辑的输出，成为条件性更新语句的目标，以允许逐步构建复杂的组合逻辑表达式。Chisel不允许不指定组合输出，并且如果组合输出未遇到无条件更新，则报告错误。 有限状态机在数字设计中有限状态机（FSM）是时序电路常用的类型。简单FSM的例子就是奇偶校验生成器：12345678910111213class Parity extends Module &#123; val io = new Bundle &#123; val in = Bool(dir = INPUT) val out = Bool(dir = OUTPUT) &#125; val s_even :: s_odd :: Nil = Enum(UInt(), 2) val state = Reg(init = s_even) when (io.in) &#123; when (state === s_even) &#123; state := s_odd &#125; when (state === s_odd) &#123; state := s_even &#125; &#125; io.out := (state === s_odd)&#125; 其中Enum(Uint(), 2)生成两个UInt数。当io.in为true时更新状态。需要注意的是，FSM的所有机制都建立在寄存器，线和条件更新的基础上。下面是一个复杂的FSM例子，这是一个自动售货机接收货币的电路：1234567891011121314151617181920212223242526272829class VendingMachine extends Module &#123; val io = new Bundle &#123; val nickel = Bool(dir = INPUT) val dime = Bool(dir = INPUT) val valid = Bool(dir = OUTPUT) &#125; val s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: Nil = Enum(UInt(), 5) val state = Reg(init = s_idle) when (state === s_idle) &#123; when (io.nickel) &#123; state := s_5 &#125; when (io.dime) &#123; state := s_10 &#125; &#125; when (state === s_5) &#123; when (io.nickel) &#123; state := s_10 &#125; when (io.dime) &#123; state := s_15 &#125; &#125; when (state === s_10) &#123; when (io.nickel) &#123; state := s_15 &#125; when (io.dime) &#123; state := s_ok &#125; &#125; when (state === s_15) &#123; when (io.nickel) &#123; state := s_ok &#125; when (io.dime) &#123; state := s_ok &#125; &#125; when (state === s_ok) &#123; state := s_idle &#125; io.valid := (state === s_ok) &#125; 下面是一个使用switch语句定义的售货机FSM：123456789101112131415161718192021222324252627class VendingMachine extends Module &#123; val io = new Bundle &#123; val nickle = Bool(dir = INPUT) val dime = Bool(dir = INPUT) val valid = Bool(dir = OUTPUT) &#125; val s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: Nil = Enum(UInt(), 5) val state = Reg(init = s_idle) switch (state) &#123; is (s_idle) &#123; when (io.nickel) &#123; state := s_5 &#125; when (io.dime) &#123; state := s_10 &#125; &#125; is (s_5) &#123; when (io.nickel) &#123; state := s_10 &#125; when (io.dime) &#123; state := s_15 &#125; &#125; is (s_10) &#123; when (io.nickel) &#123; state := s_15 &#125; when (io.dime) &#123; state := s_ok &#125; &#125; is (s_ok) &#123; state := s_idle &#125; &#125; io.valid := (state === s_ok)&#125; 内存Chisel提供了创建只读和读/写存储器的功能。 ROM用户可以使用Vec定义ROM：12Vec(inits: Seq[T])Vec(elt0: T, elts: T*) 其中inits是初始化ROM的初始Data序列。例如，用户可以创建一个初始化为1,2,4,8的小型ROM，并使用计数器作为地址生成器循环访问所有值，如下所示：12val m = Vec(Array(UInt(1), UInt(2), UInt(4), UInt(8))) val r = m(counter(UInt(m.length))) 我们可以使用如下初始化的ROM创建n值正弦查找表：1234567def sinTable (amp: Double, n: Int) = &#123; val times = Range(0, n, 1).map(i =&gt; (i*2*Pi)/(n.toDouble-1) - Pi) val inits = times.map(t =&gt; SInt(round(amp * sin(t)), width = 32)) Vec(inits)&#125;def sinWave (amp: Double, n: Int) = sinTable(amp, n)(counter(UInt(n)) 其中amp用于缩放存储在ROM中的固定点值。 Mem存储器在Chisel中被给予特殊处理，因为存储器的硬件实现具有许多变化，例如，FPGA存储器与ASIC存储实例化的结果完全不同。Chisel定义了一个内存抽象，可以映射到简单的Verilog行为描述，也可以映射到从代工厂或IP厂商提供的外部内存生成器获得的内存模块实例。Chisel通过Mem结构可以支持随机存取存储器。写入Mems是正边沿触发，读取是组合或正边沿触发。12345678object Mem &#123; def apply[T &lt;: Data](type: T, depth: Int, seqRead: Boolean = false): Mem&#125;class Mem[T &lt;: Data](type: T, depth: Int, seqRead: Boolean = false) extends Updateable &#123; def apply(idx: UInt): T &#125; 通过使用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32-entry的寄存器堆可以如下表示：1234val rf = Mem(UInt(width = 64), 32) when (wen) &#123; rf(waddr) := wdata &#125; val dout1 = rf(waddr1)val dout2 = rf(waddr2) 如果设置了可选参数seqRead，当读地址为Reg时，Chisel将尝试推断顺序读端口。单读端口，单写端口SRAM可以描述如下：12345val ram1r1w = Mem(UInt(width = 32), 1024, seqRead = true)val reg_raddr = Reg(UInt())when (wen) &#123; ram1r1w(waddr) := wdata &#125; when (ren) &#123; reg_raddr := raddr &#125;val rdata = ram1r1w(reg_raddr) 单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：12345val ram1p = Mem(UInt(width = 32), 1024, seqRead = true) val reg_raddr = Reg(UInt())when (wen) &#123; ram1p(waddr) := wdata &#125; .elsewhen (ren) &#123; reg_raddr := raddr &#125;val rdata = ram1p(reg_raddr) 如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据为未定义。Mem还支持subword写入的写掩码。如果相应的屏蔽位置1，则写入给定位。123456val ram = Mem(UInt(width = 32), 256)when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;class FilterIO extends Bundle &#123; val x = new PLink().flip val y = new PLink()&#125; 其中flip递归地改变Bundle的“性别”，将输入改变为输出和输出。我们现在可以通过定义一个过滤器类扩展模块来定义一个过滤器：123class Filter extends Module &#123; val io = new FilterIO() ...&#125; 其中io包含了FilterIO。 Bundle 向量除了单个元素，元素向量可以形成更丰富的分层接口。例如，创建具有输入向量的交叉开关，产生输出向量，并通过UInt输入选择，我们可以使用Vec构造函数：12345class CrossbarIo(n: Int) extends Bundle &#123; val in = Vec.fill(n)&#123; new PLink().flip() &#125; val sel = UInt(INPUT, sizeof(n)) val out = Vec.fill(n)&#123; new PLink() &#125;&#125; 其中Vec用第一个参获取大小，区块返回一个端口作为第二个参数。 批量连接我们现在可以将两个过滤器组成一个过滤器块，如下所示：12345678class Block extends Module &#123; val io = new FilterIO() val f1 = Module(new Filter()) val f2 = Module(new Filter()) f1.io.x &lt;&gt; io.x f1.io.y &lt;&gt; f2.io.x f2.io.y &lt;&gt; io.y&#125; 其中&lt;&gt;批量连接同级模块之间的相反接口或父/子模块之间的相同接口。批量连接将相同名称的叶子端口彼此连接。在所有连接完成后，Chisel警告用户端口是否只有一个到它们的连接。 接口视图考虑一个由控制逻辑和数据通路子模块以及主机和存储器接口组成的简单CPU，如图所示。在这个CPU中，我们可以看到控制逻辑和数据通路每个只连接到指令和数据存储器接口的一部分。Chisel允许用户通过部分实现接口来实现这一点。用户首先定义到ROM和Mem的完整接口，如下： 123456789class RomIo extends Bundle &#123; val isVal = Bool(INPUT) val raddr = UInt(INPUT, 32) val rdata = UInt(OUTPUT, 32)&#125;class RamIo extends RomIo &#123; val isWr = Bool(INPUT) val wdata = UInt(INPUT, 32)&#125; 现在控制逻辑可以根据这些接口构建接口：12345class CpathIo extends Bundle &#123; val imem = RomIo().flip() val dmem = RamIo().flip() ...&#125; 而且控制和数据通路模块可以通过部分地分配来给这个接口来构建，如下所示：12345678910111213141516class Cpath extends Module &#123; val io = new CpathIo(); ... io.imem.isVal := ...; io.dmem.isVal := ...; io.dmem.isWr := ...; ...&#125;class Dpath extends Module &#123; val io = new DpathIo(); ... io.imem.raddr := ...; io.dmem.raddr := ...; io.dmem.wdata := ...; ...&#125; 我们现在可以使用批量连接来连接CPU，就像使用其他bundle一样：123456789101112class Cpu extends Module &#123; val io = new CpuIo() val c = Module(new CtlPath()) val d = Module(new DatPath()) c.io.ctl &lt;&gt; d.io.ctl c.io.dat &lt;&gt; d.io.dat c.io.imem &lt;&gt; io.imem d.io.imem &lt;&gt; io.imem c.io.dmem &lt;&gt; io.dmem d.io.dmem &lt;&gt; io.dmem d.io.host &lt;&gt; io.host&#125; 模块的功能创建制造用于模块构造的功能接口也是有用的。例如，我们可以构建一个构造函数，它将多路复用器输入作为参数，并返回多路复用器输出：123456789object Mux2 &#123; def apply (sel: UInt, in0: UInt, in1: UInt) = &#123; val m = new Mux2() m.io.in0 := in0 m.io.in1 := in1 m.io.sel := sel m.io.out &#125;&#125; 其中对象Mux2在Mux2模块类中创建一个Scala单例对象，并且apply定义了创建Mux2实例的方法。有了这个Mux2创建功能，Mux4的规格现在明显更简单。1234567891011class Mux4 extends Module &#123; val io = new Bundle &#123; val in0 = UInt(INPUT, 1) val in1 = UInt(INPUT, 1) val in2 = UInt(INPUT, 1) val in3 = UInt(INPUT, 1) val sel = UInt(INPUT, 2) val out = UInt(OUTPUT, 1) &#125; io.out := Mux2(io.sel(1), Mux2(io.sel(0), io.in0, io.in1), Mux2(io.sel(0), io.in2, io.in3))&#125; Chisel提供MuxCase，其本质上是一个n-way Mux。1MuxCase(default, Array(c1 -&gt; a, c2 -&gt; b, ...)) 其中每个条件/值在Scala数组中表示为元组，并且其中MuxCase可以转换为以下Mux表达式：1Mux(c1, a, Mux(c2, b, Mux(..., default))) Chisel还提供MuxLookup，其本质是一个n-way的可索引多路选择器：12MuxLookup(idx, default, Array(UInt(0) -&gt; a, UInt(1) -&gt; b, ...)) 这可以用MuxCase来重写：1MuxCase(default,Array((idx === UInt(0)) -&gt; a,(idx === UInt(1)) -&gt; b, ...)) 多态性和参数化Scala是一种强类型语言，使用参数化类型来指定通用函数和类。 在本节中，我们展示了Chisel用户如何使用参数化类来定义自己的可重用函数和类。 参数化函数前面我们在Bool上定义了Mux2，但现在我们展示如何定义一个通用的多路复用器功能。我们使用一个布尔条件和con和alt参数（对应于then和else表达式）来定义一个T类型的函数：1def Mux[T &lt;: Bits](c: Bool, con: T, alt: T): T &#123; ... &#125; 其中T需要是Bits的子类。Scala确保在Mux的每个使用中，它可以找到实际的con和alt参数类型的公共超类，否则会导致Scala编译类型错误。例如，1Mux(c, UInt(10), UInt(11)) 这会产生一个UInt线，因为con和alt参数都是UInt类型。我们现在提出一个更高级的参数化函数的例子，用于定义一个内积FIR数字滤波器，通常用于Chisel Num。 内积FIR滤波器可以在数学上定义为： 其中x是输入，w是权重向量。在Chisel中，这可以定义为：12345def delays[T &lt;: Data](x: T, n: Int): List[T] = if (n &lt;= 1) List(x) else x :: Delays(RegNext(x), n-1)def FIR[T &lt;: Data with Num[T]](ws: Seq[T], x: T): T = (ws, Delays(x, ws.length)).zipped.map( _ * _ ).reduce( _ + _ ) 其中延迟产生其输入的增量递增延迟的列表，并且reduce构造给出二进制组合器函数f的简化电路。在这种情况下，reduce创建一个求和电路。最后，FIR函数被限制为处理类型Num的输入，其中定义了Chisel乘法和加法。 参数化类与参数化函数一样，我们也可以参数化类，使它们可重用程度更高。例如，我们可以将Filter类概括为可以使用任何类型的链接。我们可以通过参数化FilterIO类和定义构造函数采取零参数类型构造函数来做到这点，如下所示：1234class FilterIO[T &lt;: Data](type: T) extends Bundle &#123; val x = type.asInput.flip val y = type.asOutput&#125; 我们现在可以通过定义一个模块类来定义Filter，该模块类也接收一个链接类型构造函数参数，并将其传递给FilterIO接口构造器：1234class Filter[T &lt;: Data](type: T) extends Module &#123; val io = new FilterIO(type) ...&#125; 我们现在可以定义一个基于PLant的过滤器，如下所示：1val f = Module(new Filter(new PLink())) 其中大括号{}表示零参数函数（也称为thunk），在这种情况下创建链接类型。通用FIFO可以这样定义，并使用如下：12345678910111213141516171819202122232425262728293031323334353637class DataBundle extends Bundle &#123; val A = UInt(width = 32) val B = UInt(width = 32)&#125;object FifoDemo &#123; def apply () = new Fifo(new DataBundle, 32)&#125;class Fifo[T &lt;: Data] (type: T, n: Int) extends Module &#123; val io = new Bundle &#123; val enq_val = Bool(INPUT) val enq_rdy = Bool(OUTPUT) val deq_val = Bool(OUTPUT) val deq_rdy = Bool(INPUT) val enq_dat = type.asInput val deq_dat = type.asOutput &#125; val enq_ptr = Reg(init = UInt(0, sizeof(n))) val deq_ptr = Reg(init = UInt(0, sizeof(n))) val is_full = Reg(init = Bool(false)) val do_enq = io.enq_rdy &amp;&amp; io.enq_val val do_deq = io.enq_rdy &amp;&amp; io.deq_val val is_empty = !is_full &amp;&amp; (enq_ptr === deq_ptr) val deq_ptr_inc = deq_ptr + UInt(1) val enq_ptr_inc = enq_ptr + UInt(1) val is_full_next = Mux(do_enq &amp;&amp; ~do_deq &amp;&amp; (enq_ptr_inc === deq_ptr), Bool(true), Mux(do_deq &amp;&amp; is_full, Bool(false), is_full)) enq_ptr := Mux(do_enq, enq_ptr_inc, enq_ptr) deq_ptr := Mux(do_deq, deq_ptr_inc, deq_ptr) is_full := is_full_next val ram = Mem(n) when (do_enq) &#123; ram(enq_ptr) := io.enq_dat &#125; io.enq_rdy := !is_full io.deq_val := !is_empty ram(deq_ptr) &lt;&gt; io.deq_dat&#125; 也可以定义成通用解耦接口：12345class DecoupledIO[T &lt;: Data](data: T) extends Bundle &#123; val ready = Bool(INPUT) val valid = Bool(OUTPUT) val bits = data.clone.asOutput &#125; 然后可以使用该模板向任何信号集添加握手：12class DecoupledDemoextends DecoupledIO()( new DataBundle ) FIFO的接口也可以如下进行简化：1234567class Fifo[T &lt;: Data] (data: T, n: Int) extends Module &#123; val io = new Bundle &#123; val enq = new DecoupledIO( data ).flip() val deq = new DecoupledIO( data ) &#125; ... &#125; 多时钟域Chisel 2.0介绍了对多时钟域的支持。 创建时钟域为了使用多个时钟域，用户必须创建多个时钟。 在Chisel中，时钟是使用复位信号参数创建的第一级节点，定义如下：123class Clock (reset: Bool) extends Node &#123; def reset: Bool // returns reset pin&#125; 在Chisel中有一个内置的隐式时钟，状态元素默认使用：1var implicitClock = new Clock( implicitReset ) 状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：123Reg(... clock: Clock = implicitClock) Mem(... clock: Clock = implicitClock) Module(... clock: Clock = implicitClock) 交叉时钟域有两种方式可以定义电路在时钟域之间发送数据。第一种也是最原始的方式就是使用由两个寄存器组成的同步器电路，如下所示：1234567// signalA is in clock domain clockA,// want a version in clockB as signalBval s1 = Reg(init = UInt(0), clock = clockB) val s2 = Reg(init = UInt(0), clock = clockB)s1 := signalAs2 := s1;signalB := s2 由于亚稳性问题，该技术只限于在域之间传递一位数据。在域之间发送数据的第二种和更一般的方式是通过使用异步fifo：1class AsyncFifo[T&lt;:Data](gen: T, entries: Int, enq_clk: Clock, deq_clock:Clock) extends Module 当通过指定标准fifo参数和两个时钟，然后使用标准解耦就绪/有效信号从时钟域clockA到clockB获取一个版本的signalA时：12345val fifo = new AsyncFifo(Uint(width = 32), 2, clockA, clockB)fifo.io..enq.bits := signalAsignalB := fifo.io.deq.bitsfifo.io.enq.valid := condAfifo.io.deq.ready := condB 后端特定的多个时钟域每个Chisel后端需要用户以后端特定的方式设置和控制多个时钟。为了展示如何驱动一个多时钟设计，考虑这样一个硬件示例，其中两个模块使用Async-Fifo进行通信，每个模块在不同的时钟：fastClock和slowClock。 C++在C++后端，对于每个时钟i有： size_t clk.len域表示时钟i的周期 clock_lo_i，clock_hi_i int reset() 函数，可以保证clock_lo和clock_hi的所有函数被立刻调用 int clock(reset)函数，计算最小增量，调用合适的clock_lo和clock_hi，并返回使用的最小增量。 为了设置一个C++模拟器，用户需要： 将所有周期字段初始化为期望的周期 将所有计数字段初始化为期望的相位 调用reset 重复调用时钟来单步模拟 以下是slowClock / fastClock的main函数C++示例：123456789101112int main(int argc, char** argv) &#123; ClkDomainTest_t dut; dut.init(1); dut.clk = 2; dut.clk_cnt = 1; dut.fastClock = 4; dut.fastClock_cnt = 0; dut.slowClock = 6; dut.slowClock_cnt = 0; for (int i = 0; i &lt; 12; i ++) dut.reset(); for (int i = 0; i &lt; 96; i ++) dut.clock(LIT&lt;1&gt;(0)); &#125; Verilog在Verilog中： Chisel为每个时钟/复位创建一个新端口， Chisel将所有的时钟连到顶层模块 用户必须要为每个时钟i创建一个always块时钟驱动 以下是驱动slowClock / fastClock电路的顶层Verilog示例：123456789101112131415161718192021module emulator; reg fastClock = 0, slowClock = 0, resetFast = 1, resetSlow = 1; wire [31:0] add, mul, test; always #2 fastClock = ~fastClock; always #4 slowClock = ~slowClock; initial begin # 8 resetFast = 0; resetSlow = 0; #400 $finish;endClkDomainTest dut ( .fastClock(fastClock), .slowClock(slowClock), .io_resetFast(resetFast), .io_resetSlow(resetSlow), .io_add(add), .io_mul(mul), .io_test(test));endmodule （完）]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(1)——开机启动过程]]></title>
    <url>%2F2016%2F12%2F14%2Fcomputer-boot-process%2F</url>
    <content type="text"><![CDATA[首先用一张图来大致了解一下计算机启动的整个过程。 上电按下主机的电源键后，计算机开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动CPU。如果启动失败（例如CPU坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。 如果前一个阶段未出错，就开始加电工作，在多CPU或多核CPU情况下，某一个CPU会被随机选取作为启动CPU（bootstrap processor，BSP）运行BIOS内部的程序。其余的CPU（application processor，AP）保持停机直到操作系统内核显式地使用它们。 2000年以前的计算机主板上均使用BIOS，如今绝大多数计算机采用的是EFI（Mac用的就是EFI）或UEFI，BIOS正在逐步被淘汰。基于EFI、UEFI的开机过程与传统的BIOS不尽相同，本文将以传统的BIOS，Intel CPU为例介绍开机过程。 此时CPU工作模式为实模式，该模式下地址总线是20位，寻址范围是0x00000~0xFFFFF的1M范围。这也就解释了为什么BIOS的容量只有1MB。 Intel CPU用三种运行模式: 实模式、32位保护模式、64位保护模式。实模式: Intel 8086的寻址方案，为了商业连续性，兼容了这古老的方案；保护模式: 采用了虚实地址转换方案。 BIOS启动之初，内存是空的。此时CPU处于实模式，内存的地址映射均为硬连接的设备。内存映射图如下图所示: 重置向量CPU启动后其大多数寄存器会被初始化为预定的值，包括指令寄存器（instruction pointer, EIP），它保存着CPU将要执行指令的内存地址。此时CPU会有一个特殊行为，其会对EIP的初始值加上一个基址寄存器的值，生成一个32位的地址0xFFFFFFF0。之所以称为特殊行为，是因为实模式下CPU只能寻址1MB地址空间，而这个32位地址已经大于1MB的内存限制。因此，0xFFFFFFF0也被称为重置向量（reset vector），参考上图0xFFFFFFF0处的标识。 于是，CPU开始执行0xFFFFFFF0地址处的指令，该地址处是一条JUMP指令，这条指令清空了基址寄存器的值，并让指令跳回到BIOS开始处（物理地址为0xF0000，参考上图0xF0000处的标识）以执行BIOS。 BIOS内部可以分成两个区块: code block（普通程序）、boot block（引导程序）。上电后，boot block会先被执行，它会检查code block的代码是否正确，如果正确，就会转到code block继续执行下去。 BIOS初始化0xF0000地址实际上是BIOS中的boot block的开始处。在这个阶段，会初始化部分硬件。系统的CPU、USB只有部分被初始化。 BIOS POST（加电自检）初始化完成后，CPU跳转到0xA0000地址处（参考上图640KB处）进行BIOS加电自检（power on self test, POST）。这个过程会检查计算机的各项组件，如CPU、显卡、内存、鼠标、键盘等。如果找不到内存或者键盘都有可能让BIOS停止工作并且打印一些相关的错误信息，如果找不到显卡BIOS会发出蜂鸣警告（因为无法显示画面）当CPU执行到0xC0000地址处（参考上图768KB处），开始寻找其他设备的ROM，如果找到任何其他设备的BIOS，它们也会被执行。下一步，显卡就会显示BIOS界面，并进行更深入的检查。 BIOS记录系统设定值检查完成后，BIOS会根据自己的“系统资源表”，对系统进行进一步确认，从而确定计算机配有哪些资源或设备。例如BIOS支持随插即用，它会检测并配置随插即用设备。然后BIOS会遵循高级配置电源接口（Advanced Configuration Power Interface，ACPI）在内存中设置好一系列的数据来描述硬件信息，以便被操作系统内核利用。 搜索MBR到这一步，BIOS开始尝试加载操作系统。它会从硬盘，光驱，软驱，网络等几个地方依次寻找操作系统（用户可以在BIOS设定中修改查找的优先级）。如果找不到操作系统，BIOS会停机并给出错误信息。 假设在硬盘上找到了操作系统，它会首先读取硬盘上的大小为512B的0号扇区，这个扇区被称为主引导记录（master boot record，MBR），其包含三部分：(1) 启动代码(2) 硬盘分区表(3) 结束标志字 BIOS读完磁盘上的MBR之后会把它拷贝到内存0x7C00地址处，然后CPU跳转到该内存地址执行MBR里的指令。下图可以帮助大家理解MBR的结构。 启动代码中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（Windows里面是Windows MBR Loader，Linux的话可能是LILO或者GRUB）。磁盘分区表是固定的，一个64字节的区域，每16字节为一个条目，描述硬盘的分区信息（这样就可以在同一磁盘的不同分区上安装不同的操作系统）。所以采用了MBR格式分区表的文件系统最多能安装四个操作系统。 引导操作系统执行MBR内部启动代码中的引导程序可以引导操作系统。Linux的引导程序LILO和GRUB可以处理各种不同的操作系统，文件系统和引导配置。 根据MBR启动代码中的引导程序加载包含了额外引导代码的其他扇区。这些扇区可能是一个分区的引导扇区，也可能是MBR安装时硬编码到MBR代码中的某个扇区。 执行步骤1载入的引导代码读取配置文件（例如，GRUB中是grub.conf，windows中是boot.ini）。然后它会显示启动选项，或直接启动操作系统 此时引导程序开始引导操作系统内核。它必须能够识别内核所在引导分区的文件系统。在Linux中，这一步是读取一个类似“vmlinuz”的文件，加载至内存中并跳转到内核启动代码。 此时我们回头再看第一张图，从引导程序到早期的内核初始化过程，此时内核解压开始了。 （完） 参考[1] How Computers Boot Up[2] 即将换掉传统BIOS的UEFI]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RISC-V——针对SoC的一套开放标准]]></title>
    <url>%2F2016%2F12%2F01%2Friscv-brief-introduction%2F</url>
    <content type="text"><![CDATA[对于大多数计算设备来说Linux已经成为了标准的操作系统，伯克利的研究者希望RISC-V也能够像Linux一样成为所有计算设备的标准ISA 片上系统（systems-on-a-chip, SoCs)，集成了处理器和cache，如今已经被越来越广泛的运用到各个领域之中。因此有越来越多的公司加入到了芯片制造这个领域之中。鉴于业界已经通过开放标准和开源软件进行了革命——如TCP/IP和Linux。那么作为最重要的接口之一的指令系统（instruction set architecture，ISA）为什么不对所有人开放呢？ 尽管指令系统由于历史或商业原因变得专利化了，但是从技术角度来看，必须要有免费的、开放的ISA。 这并不是一个遗漏的错误。一些拥有很成功ISA的公司，如ARM，IBM，Intel，MIPS都拥有针对他们自己的ISA的专利，而这使得我们这些没有license的学术机构和小公司根本无法使用这些ISA，除非付出巨额的费用。 而ARM的license甚至还不允许你设计自己的ARM核；而是只能使用其设计。目前世界上大约只有10家大公司才拥有修改其设计自己的ARM核的license。这就是商业，通过阻止别人进行设计改造从而扼杀了竞争和创新。 也不是因为公司做大部分的软件开发。虽然围绕这些流行ISA的软件生态系统有着非常高价值，但这几乎都是外人构建了所有的软件。 并不只有公司具备设计合格的ISA的能力。虽然设计ISA涉及到大量工作，但是今天有很多机构或公司有能力设计ISA。 最流行的ISA并不见得是完美的ISA。ARM和80x86不被视为完美的ISA。 也不是只有设计ISA的公司才能验证它们。很久以前，开放组织开发了可以确保与诸如浮点单元（IEEE 754），网络芯片和交换机（以太网）和I/O总线（PCIe）的硬件标准兼容的机制。如果没有这样的组织，开放的IT标准也不会那么受欢迎。 最后，专有ISA不能保证永远存活下去。如果一个公司倒闭了，它的ISA也会随之消亡。Digital Equipment公司的消亡导致Alpha和VAX ISA也一起终结了。注意，ISA实际上是一个接口规范，而不是实现。 其实有应该三种类型的ISA实现：(1) 私有的闭源，如AppleiOS(2) 许可的开源，如Wind River VxWorks(3) 免费的开源，用户可以修改、共享，如Linux 拥有专利的ISA实际上允许前两种类型，但是我们还需要一种免费开放的ISA。 我们的结论是，业界将受益于可行的，免费开放的ISA，就像它从免费开放的软件栈中获益。例如，它将实现一个真正的，自由，开放的处理器设计市场，拥有专利的ISA阻止了这样一个市场的诞生。这样的市场会具有： 更强大的创新能力: 通过源自更多设计师的自由市场竞争，包括开放ISA与专有的ISA的竞争。 共享的、开放的核心设计: 这意味着更短的上市时间，更低的成本（由于重复使用），更少的错误（因为有更多人的关注），比如这将使政府机构加入涉密后门更困难。 负担得起的处理器: 更多的设备能够负担得起处理器的费用，这将有助于扩大物联网，其目标成本可能只有1美元。 要想让开源社区拥抱如此的开源ISA，我们认为它需要一个可靠的商业记录。第一个问题是，哪种风格的ISA有成功的历史？ 在30年来没有这样的成功的ISA。除了DSP市场的一部分，VLIW已经失败了：Multiflow也不行，Itanium破产了，尽管惠普和英特尔投资了数十亿美元。没有新的CISC ISA可以成功数十年。幸存的CISC从复杂的ISA转换为更容易执行的ISA，这对于制定有价值的遗留代码基础是非常有意义的。 一套新的ISA不会有任何遗留代码，所以额外的硬件成本和翻译的开销成本很难证明：为什么不是只使用易于执行的ISA在第一位？ RISC风格load-store ISA可以追溯到至少50年到Seymour Cray的CDC 6600.虽然80x86赢得了PC战争，RISC主导后PC时代的平板电脑和智能手机; 在2013年超过100亿基于ARM的SoC出货，相比之下，80x86芯片只有3亿。 鉴于ISA可以存活数十年，我们预测未来的技术景观，看看哪些功能对于基于RISC的免费开放ISA可能是重要的。 三个平台可能占据主导地位：物联网，个人移动设备和仓库规模计算机（WSC）。 这个蓝图式的建议有四个关键要求：(1) 基本、扩展ISA: 为了匹配SoC的需求，同时保持稳定的软件基础，自由的，开放的ISA应该具有： 编译器和操作系统可以依赖的一小组核心指令 标准且可扩展的ISA，可以为应用程序定制SoC 可调用特定应用程序加速器的全新操作码的空间这符合当今SoC经常使用自定义应用程序特定加速器的做法。 (2) 紧凑指令集编码: 考虑到IoT的成本敏感性和对小容量存储器的期望，较小代码是可取的。(3) 四精度（QP）以及单精度和双精度浮点: 在WSC中运行的一些应用程序处理这样的大数据集，这依靠软件库进行QP运算。(4) 128位寻址以及32位和64位: 物联网上的节点的有限内存大小意味着32位寻址在未来几十年将是非常重要的，而64位寻址是更高要求的标准。尽管WSC行业不需要128位的运算，但是在十年内，WSC可能需要超过64位（16艾字节）来寻址所有的固态，非易失性存储器。 这些都是需要很多年才能确认是否正确的细节，所以似乎使用现有的ISA起步是更聪明的做法，而不是成立委员会，从头开始。 RISC ISAs都很相似，所以其中很多都可能是很好的选择。好消息是，已经有三个开源RISC ISA：SPARC，OpenRISC和RISC-V。 只有RISC-V满足上述所有四个要求（见下表）。 RISC-V也是10到20岁的年轻人，所以我们可以从以前的RISC ISA的错误中学习和修复——例如，SPARC和OpenRISC延迟分支——这就是为什么RISC-V是如此简单和干净。 此外，SPARC（V9）的64位地址版本是专有的，而OpenRISC可能失去了动力。 RISC-V有很大的发展势头，到目前为止，它有来自Berkeley的8个芯片实现，以及在印度，英国和美国的外部项目。 由于开源Chisel硬件设计系统，一个64位RISC-V核要比类似过程制造的32位ARM内核快，且功耗和速度均为后者的一半。 虽然很难摒弃我们的偏见，但我们认为RISC-V是自由，开放RISC ISA的最好的、最安全的选择。为了扩大这个免费的，开放的ISA的社区，我们将提供研讨会和创建一个非营利基础，以验证实施和维护和发展RISC-V。 虽然RISC-V的第一个首要目标是物联网，但我们有着更为远大的目标：正如Linux已成为大多数计算设备的标准操作系统一样，我们设想RISC-V成为所有计算设备的标准ISA。 目前已经有大量公司和机构加入并关注着RISC-V的发展。 （完） 参考[1] RISC-V: An Open Standard for SoCs]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel高级参数化详解]]></title>
    <url>%2F2016%2F11%2F10%2Fadvanced-chisel%2F</url>
    <content type="text"><![CDATA[1. 介绍本文为Chisel高级参数库手册。关于Chisel更多通用信息请参考Getting Started文档。随着硬件设计的复杂度的不断提高，模块化对于验证和复用都是非常重要的。Chisel的主要应用案例就是描述各种高度可配置的硬件生成器，我们很快意识到传统的参数化方式迫使设计的源代码非常脆弱，并且限制了组件的重用。 2. 高级参数化每个Chisel Module有一个Parameters类的成员参数，其提供在模块之间传递参数的机制。本节描述以下这些特征:(1) Parameters类及其相关的方法/成员；(2) 基本使用模型；(3) 语法糖；(4) 向外部用户/程序暴露参数的模板代码；(5) Views(site, here, up)的高级功能； 2.1 类和方法Parameters有以下这些基本方法:12345678class Parameters &#123; // 返回类型T的一个值 def apply[T](key:Any):T // 返回一个新的Parameters类 def alter(mask:(Any,View,View,View)=&gt;Any):Paramters // 返回一个模块的Parameters实例 def params:Parameters&#125; View是一个只包含一个基本方法的类:1234class View &#123; // 返回类型T的一个值 def apply[T](key:Any):T&#125; Parameters有一个工厂对象，其包含一个基本的方法:1234object Parameters &#123; // 返回一个空的Parameters实例 def empty:Parameters&#125; Module工厂对象有一个附加的apply方法:1234object Module &#123; // 返回一个新的类型T的Module，如果_p!=None，则由一个Parameters实例初始化 def apply[T&lt;:Module](C: =&gt; T)(implicit _p: Option[Parameters] = None):T&#125; 2.2 基本使用模型这个例子示范了最简单的用法: (1)查询参数; (2) 改变Parameters对象; (3) 传递一个Parameters对象到一个Module。12345678910class Tile extends Module &#123; val width = params[Int]('width')&#125;object Top &#123; val parameters = Parameters.empty val tile_parameters = parameters.alter((key, site, here, up) =&gt; &#123;case 'width' =&gt; 64&#125;) def main(args: Array[String]) = &#123; chiselMain(args,()=&gt;Module(new Tile)(Some(tile_paramters))) &#125;&#125; 在Module Tile中，params成员被查询，通过调用Parameters.apply传递key并返回value类型。在Top中，通过调用Parameters.empty创建了一个空的parameters；然后通过(Any, View, View, View) =&gt; Any函数修改参数值并返回一个新的Parameters实例，并赋值给tile_parameters。将tile_parameters包装在Some:Option[Parameters]之后，当其被传递给chiselMain时，它会被作为第二个参数传递给Module对象。 2.3 语法糖: Field[T]一个简单的例子: 要求返回类型Int必须作为参数传给apply方法；否则Scala编译器会抛出错误:123class Tile extends Module &#123; val width = params[Int]('width')&#125; 如上所示的代码示例为一种参数查询的方式，还有一种方式如下所示，可以为每个key创建一个case object，该对象继承自Field[T]，并直接传递给params的apply方法。由于Field包含了返回类型信息，所以类型并不需要被传递:1234case object Width extends Field[Int]class Tile extends Module &#123; val width = params(Width)&#125; 文档的剩下内容，假设每个查询的key都是一个继承自Field[T]的case类。 2.4 语法糖: Passing &amp; Altering当具有模块层级结构时，这些Parameters对象会在父模块和子模块之间传递。如果程序员指定，这些对象可以在实例化子对象之前被拷贝，修改。当发生修改时，Chisel会在内部拷贝存在的key/value映射链，并将提供的key/value映射添加到链的底部（译者注: 类似于JS中的原型链）。 当进行一次查询时，会首先查询链的底部key/value映射。如果没有匹配，则会查询链上的下一级key/value映射，以此类推。如果查询达到链的顶部还没有匹配，则Chisel会触发一个ParameterUndefinedExpection。当实例化一个子模块时，父模块可以以两种方式传递它的Parameters对象: 给Module工厂方法传递第二个参数，即包装在Option[Parameters]，显式地传递其Parameters对象至子模块: 12345class Tile extends Module &#123; val width = params(Width) val core = Module(new Core)(Some(params)) // 显示地传递Tile的参数给Core&#125; 隐式地将其Parameters对象传递给子模块: 12345class Tile extends Module &#123; val width = params(Width) val core = Module(new Core) // 隐式地传递Tile的参数给Core&#125; 如果父模块想要拷贝或修改子模块的字典，父模块有两种方法来完成: 向Module工厂方法提供一个偏函数映射作为一个参数。内部地，Chisel会拷贝父模块的Parameters对象并进行修改: 12345class Tile extends Module &#123; val width = params(Width) val core = Module(new Core, &#123;case Width =&gt; 32&#125;) // 向Module工厂方法提供偏函数来改变Core的code&#123;Parameters&#125;对象&#125; 调用Parameters.alter方法，该方法会返回一个新的Parameters对象。这种方法让程序员可以访问新的Parameters对象，还能够使用site，here，up，请看2.6，2.7，2.8: 123456class Tile extends Module &#123; val width = params(Width) val core_params = params.alter((pname, site, here, up) =&gt; pname match &#123;case Width =&gt; 32&#125;) val core = Module(new Core)(Some(core_params)) // 使用Parameters.alter方法来返回一个修改过的Parameters对象。只有当需要site，here或up等机制时才使用。&#125; 下图所示是一个更加复杂的修改链的示例: 12345678910111213141516171819class Tile extends Module &#123; ... val core = Module(new Core, &#123; case FPU =&gt; true; case QDepth =&gt; 20; case Width =&gt; 64 &#125;)&#125;class Core extends Module&#123; val fpu = params(FPU) val width = params(Width) val depth = params(Depth) val quete = Module(new Queue, &#123;case Depth =&gt; depth*2; case Width =&gt; 32&#125;)&#125;class Queue extends Module &#123; val depth = params(Depth) val width = params(Width) val mem = Module(new Memory, &#123;case Size =&gt; depth * width&#125;)&#125;class Memory extends Module &#123; val size = params(Size) val width = params(Width)&#125; 2.5 ChiseConfig &amp; BoilerplateChisel配置顶层参数的机制是通过一个ChiselConfig对象实现的。ChiselConfig.topDefinitions包含最高层的参数定义，如下所示:1234case object Width extends Field[Int]class DefaultConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123;(pname,site,here) =&gt; pname match &#123;case Width =&gt; 32&#125;&#125;&#125; 通常，设计会调用chiselMain.apply来实例化一个设计。为了使用Chisel的参数化机制并正确地配置ChiselConfig，应该调用chiselMain.run，且设计不能用Module工厂方法包裹起来。这样的原因是为了针对已经存在的设计而保留的向后兼容性，未来我们会修复这个问题的。如下就是一个调用chiselMain.run的例子:12345object Run &#123; def main(args: Array[String]): Unit = &#123; chiselMain.run(args, () =&gt; new Tile()) &#125;&#125; 为了用特定的ChiselConfig来实例化设计，可以简单地在调用Chisel编译器时使用–configInstance project_name.configClass_name参数。 2.6 使用site为了帮助设计者表达参数之间传递的关系，我们添加了site机制。为了理解它的功能，从概念上记住，一个被查询的Module的参数成员首先会查看其所在的key/value映射链的最底部的key/value映射。如果不匹配，查询会向上寻找。假设我们有一些如下形式的模块:12345678class Core extends Module &#123; val data_width = params(Width) ...&#125;class Cache extends Module &#123; val line_width = params(Width) ...&#125; 这里有两个相同的查询参数Width，但是对于这个例子，它们有不同的语义。在Core中，Width表示字长，而在Cache中，Width表示cache line的宽度。我们希望能够简单地做一个参数查询响应机制。site机制允许链中间位置的key/value映射可以从链的底部开始进行查询。看下面的例子:1234567891011121314class DefaultConfig extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,size,here) =&gt; pname match &#123; case With =&gt; site(Location) match&#123; case 'core' =&gt; 64 // data width case 'cache' =&gt; 128 // cache line width &#125; &#125; &#125;&#125;class Tile extends Module &#123; val core = Module(new Core, &#123;case Location =&gt; 'core'&#125;) val cache = Module(new Cache, &#123;case Location =&gt; 'cache'&#125;)&#125; 如下图所示，顶层key/value映射使用site为Location查询链的底部。顶层的key/value映射产生不同的值，这依赖于Location返回的值(“core”或”cache”)。 2.7 使用here如下图所示，如果参数是同一级key/value映射链中其他参数的函数表达式，该参数并不想复制一个值，因为赋予一个新值需要多处变化。那么，它可以通过使用here机制来查询同一层级的key/value映射: 12345678910class Tile extends Module &#123; val cache_params = param.alter( (pname, site, here, up) =&gt; pname match &#123; case Sets =&gt; 128 case Ways =&gt; 4 case Size =&gt; here(Sets)*here(Ways) &#125; ) val cache = Module(new Cache)(cache_params)&#125; 2.8 使用upup机制允许用户查询父级key/value映射。这等同于直接调用Parameters.apply，但可以在Parameters.alter中完成。具体请看3.6节。 3 示例所有参数化方案都需要遵循以下三个准则:(1) 所有可查找到的参数暴露在顶层；(2) 评估不同节点时源代码绝对不能改变；(3) 添加新的参数时尽量不用改变源代码。本章在介绍完每个例子之后，我们会提出最简单的参数化方案以支持期望的设计空间，且不违反三个准则中的任意一个。随着例子的复杂性提高，最简单的设计方案也会随着改变，直到我们使用这里介绍的高级参数化方案。 3.1 简单参数 在这个设计中，我们只改变core和cache的参数。最直接的参数化方案就是通过Tile构造函数参数来传递所有的参数。这些值然后会被传递给Core和Cache，通过它们各自的构造函数完成传递:12345678class Tile(val fpu:Boolean, val ic_set:Int, val ic_way:Int, val dc_sets:Int, val dc_ways:Int) extends Module &#123; val core = Module(new Core(fpu)) val icache = Module(new Cache(ic_sets, ic_ways)) val dcache = Module(new Cache(dc_sets, dc_ways)) ...&#125;class Core (val fpu:Boolean) &#123;...&#125;class Cache(val sets:Int, val ways:Int) extends Module &#123;...&#125; 当探索我们的参数空间时，没有源代码被修改，并且所有的可查找参数暴露在顶层。此外，添加一个新的参数，由于这个例子简单，我们的代码只需要很少的改动。 3.2 不相交参数集合 在下一个设计中，我们设计一个芯片，其可以实例化不同的core，每个core有自己的一组参数。如果我们使用简单的解决方案，Tile的构造函数的参数会非常多，因为它必须为所有可能的core包含所有的参数。有一个更好的办法就是把参数集合成一个配置对象。比如，我们可以把所有的BigCore参数集合到一个BigCoreConfig的case class中，把所有的SmallCore的参数集合到一个SmallCoreConfig的case类中，它们都继承自CoreConfig。此外，我们让Cache和Tile在它们的构造函数中分别接受CacheConfig和TileConfig。1234567891011121314abstract class CoreConfig &#123;&#125;case class BigCoreConfig(iq_depth:Int, lsq_depth:Int) extends CoreConfigcase class SmallCoreConfig(fpu:Boolean) extends CoreConfigcase class CacheConfig(sets:Int, ways:Int)case class TileConfig(cc:CoreConfig, icc:CacheConfig, dcc:CacheConfig)class TIle (val tc:TileConfig) extends Module &#123; val core = tc.cc match &#123; case bcc:BigCoreConfig =&gt; Module(new BigCore(tc.bcc)) case scc:SmallCoreConfig =&gt; Module(new SmallCore(tc.scc)) &#125; val icache = Module(new Cache(tc.icc)) val dcache = Module(new Cache(tc.dcc)) ...&#125; 3.3 位置无关参数 嵌套配置对象是非常脆弱的，这是因为嵌入配置对象的结构与模块的层次结构强相关。给定一个如上图所示的设计，我们假设其中包含BigCore的IQ和LSQ，以及icache和dcache，实例化一个Memory模块。Memory模块包含一个width参数，为了能让设计符合正确的预期功能，所有的Memory宽度必须设为同样的值。为了确保这个要求，代码可能会这样写:123456789101112131415161718case class MemConfig(size:Int, banks:Int, width:Int)case class CacheConfig(sets:Int, ways:Int, mc:MemConfig)case class QueueConfig(depth:Int, mc:MemConfig)case class BigCoreConfig(iqc:QueeuConfig, lsqc:QueueConfig, mc:MemConfig)case class TileConfig(cc:CoreConfig, icc:CacheConfig, dcc:CacheConfig)class Tile(val tc:TileConfig) extends Module &#123; val core = tc.cc match &#123; case bcc:BigCoreConfig =&gt; Module(new BigCore(tc.bcc)) case scc:SmallCoreConfig =&gt; Module(new SmallCore(tc.scc)) &#125; val icache = Module(new Cache(tc.icc)) val dcache = Module(new Cache(tc.dcc)) require(tc.dcc.mc.width == td.icc.mc.width) require(tc.bcc.iqc.mc.width == tc.bcc.lsqc.mc.width) require(tc.dcc.mc.width == tc.bcc.lsqc.mc.width) ...&#125;... 这一系列的require声明是非常脆弱的，因为我们设计的层次结构发生任何变化都需要大量重写这些声明。忽略这些require声明并不是可行的方法；这些声明对于强制基础设计要求是非常重要的。配置对象的这个缺点引领我们向用户参数化方案靠近，即Parameters类型字典的拷贝/修改。我们使用这种key-value结构来存储模块的参数。为了参数化上图的设计，我们隐式地传递Parameters对象，如果需要修改，则向Module工厂方法提供偏函数。回顾前面的ChiselConfig那一节，MyConfig类(继承自ChiselConfig)必须被传递给Chisel编译器，通过–configInstance选项来配置顶层参数:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname, site, here) =&gt; pname match &#123; case IQ_depth =&gt; 10 case LSQ_depth =&gt; 10 case Ic_sets =&gt; 128 case Ic_ways =&gt; 2 case Dc_sets =&gt; 512 case Dc_ways =&gt; 4 case Width =&gt; 64 // 因为任何模块查询Width都会返回64，所以它的名字不应该对模块是唯一的 &#125; &#125;&#125;class Tile extends Module &#123; val core = Module(new Core)(params) val ic_sets = params(Ic_sets) val ic_ways = params(Ic_ways) val icache = Module(new Cache, &#123;case Sets =&gt; ic_sets; case Ways =&gt; ic_ways&#125;) // we can rename Ic_sets to Sets, effectively isolating Cache’s query keys from any design hierarchy dependence val dc_sets = params(Dc_sets) val dc_ways = params(Dc_ways) val dcache = Module(new Cache, &#123;case Sets =&gt; dc_sets; case Ways =&gt; dc_ways&#125;) // similarly we rename Dc_sets to Sets and Dc_ways to Ways&#125; class Core extends Module &#123; val iqdepth = params(IQ_depth) val iq = Module(new Queue, &#123;case Depth =&gt; iqdepth&#125;) val lsqdepth = params(LSQ_depth) val lsq = Module(new Queue, &#123;case Depth =&gt; lsqdepth&#125;) ... &#125; class Queue extends Module &#123; val depth = params(Depth) val mem = Module(new Memory,&#123;case Size =&gt; depth&#125;) ... &#125; class Cache extends Module &#123; val sets = params(Sets) val ways = params(Ways) val mem = Module(new Memory,&#123;case Size =&gt; sets*ways&#125;) &#125; class Memory extends Module &#123; val size = params(Size) val width = params(Width) &#125;&#125; 尽管这种参数化方法相当冗长，但是它在添加参数时能表现出较好的扩展性，也不需要改变源代码，并允许单个参数，如Width改变所有的叶子模块。 3.4 特定位置参数我们在前一节看到拷贝并修改一个Parameters对象会非常冗长。如果我们想要添加一个ECC参数到我们的Memory模块，而这个参数取决于Memory实例化的位置，这时候我们需要修改多个父模块的中的代码来重命名每个参数(如: ECC_icache =&gt; ECC) 如上图所示，我们采用Parameters对象的site功能来获取特定位置信息，从而定制我们想要返回给特定位置值的值。在添加了特定位置信息之后，我们彻底减少了必须要改动的代码的数量:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case Depth =&gt; site(Queue_type) match &#123; case 'iq' =&gt; 20 case 'lsq' =&gt; 10 &#125; case Sets =&gt; site(Cache_type) match &#123; case 'i' =&gt; 128 case 'd' =&gt; 512 &#125; case Ways =&gt; site(Cache_type) match &#123; case 'i' =&gt; 2 case 'd' =&gt; 4 &#125; case Width =&gt; 64 // since any module querying Width should return 64, the name should NOT be unique to modules case ECC =&gt; site(Location) match &#123; 'incore' =&gt; false 'incache' =&gt; true &#125; &#125; &#125;&#125; class Tile (val params:Parameters) extends Module &#123; val core = Module(new Core,&#123;Location =&gt; ’incore’&#125;) // we can give core and its child modules a location identifier val cacheparams = params.alter(&#123;Location =&gt; ’incache’&#125;) // we can give both caches and all their child modules a location identifier val icache = Module(new ICache)(cacheparams) val dcache = Module(new DCache)(cacheparams)&#125;class Core extends Module &#123; val iq = Module(new IQ) val lsq = Module(new LSQ) ... &#125; class IQ extends Module &#123; val depth = params(Depth) val mem = Module(new Memory, &#123;Size = depth&#125;) // in some cases, using copy/alter is preferred instead of \code&#123;site&#125; (see Design Heuristics for more details) ... &#125; class LSQ extends Module &#123; val depth = params(Depth) val mem = Module(new Memory, &#123;Size = depth&#125;) ... &#125; class ICache extends Module &#123; val sets = params(Sets) val ways = params(Ways) val mem = Module(new Memory,&#123;Size =&gt; sets*ways&#125;) &#125; class DCache extends Module &#123; val sets = params(Sets) val ways = params(Ways) val mem = Module(new Memory, &#123;Size =&gt; sets*ways&#125;) &#125; class Memory extends Module &#123; val size = params(Size) val ecc = params(ECC) &#125; 3.5 派生参数 如上图所示，我们总是希望我们的ROB可以是物理寄存器数量和体系结构寄存器数量差异的大小的4/3。如果我们在MyConfig.top中写明，可能就是这样的:123456789101112case object NUM_arch_reg extends Field[Int] case object NUM_phy_reg extends Field[Int] case object ROB_size extends Field[Int] class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NUM_arch_reg =&gt; 32 case NUM_phy_reg =&gt; 64 case ROB_size =&gt; 4*(64-32)/3 &#125; &#125;&#125; 然而，如果我们之后增加了物理寄存器的数量，我们需要记得更新在ROB尺寸中的派生值。为了避免这种潜在的出错，可以使用here功能来查询同级的参数:12345678910class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NUM_arch_reg =&gt; 32 case NUM_phy_reg =&gt; 64 case ROB_size =&gt; 4*(here(NUM_phy_reg) here(NUM_arch_reg))/3 &#125; &#125;&#125; 3.6 重命名参数 上图所示，两个cache模块查询一个sets参数。然而，Tile有ic_sets和dc_sets参数。为了重命名这些参数，我们可以读取父模块的值并修改子模块中的Parameters对象:1234567class Tile extends Module &#123; val ic_sets = params(Ic_sets) val ic = Module(new Cache,&#123;case Sets =&gt; ic_sets&#125;) val dc_sets = params(Ic_sets) val dc = Module(new Cache,&#123;case Sets =&gt; dc_sets&#125;) ...&#125; 还有一种方法就是，我们可以在Parameters.alter方法中使用up机制来查询父模块的Parameters对象:123456789class Tile extends Module &#123; val ic_params = params.alter( (pname,site,here,up) =&gt; pname match &#123; case Sets =&gt; up(Ic_sets) &#125; ) val ic = Module(new Cache)(ic_params) ... &#125; 通常一般不使用up机制，因为它会变得更加冗余。但是，如果父模块对子模块的Parameters对象做了非常大的改动时，up机制会非常有用，因为所有的改变会包含在Parameters.alter方法中，这个方法可以访问所有三种机制(up, site, here). 4 外部接口到目前为止，本文只描述了一些在顶层类(ChiselConfig)操作参数的机制。但是，为了能够实际生成多个C++或Verilog设计，我们需要手动改变这些参数。我们还要明确设计的约束(参数范围，依赖，约束)以及把一个特定设计的实际实例从有效设计空间表达中分离出来。带着这些动机，Chisel具一个额外的特征，其基于一个叫做Knobs的概念或者用于探索设计空间的特定参数。这一节将会介绍Knobs以及其使用方法，Dump对象，参数和Knob的约束添加，以及运行Chisel编译器的两种模式: -configCollect和-configInstance. 4.1 Knobs生成器会有一些参数是固定的，其他的则指示了生成的特定设计节点。这些生成器级的参数，称之为Knobs，其具有一个额外的key-value映射以允许外部程序和用户来轻易地重写它们的值。Knobs只能在ChiselConfig的子类TopDefinitions中被实例化:12345678910111213package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NTiles =&gt; Knob('NTILES') case .... =&gt; .... // other non-generator parameters go here &#125; &#125; override val knobValues:Any=&gt;Any = &#123; case NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; 当查询NTiles在topDefinitions中匹配时，Knob(‘NTLES’)会被返回。内部地，Chisel会在MyConfig.knobValues中查找并返回1。2.5节所示，执行生成器时需要指定特定的config:1sbt run ... --configInstance example.MyConfig 假设我们想要实例化一个新的设计，该设计有两个tile: 可以简单地使用Scala的类继承并重写knobValues的值:1234567package example class MyConfig2 extends MyConfig &#123; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 2 // will generate new design with 2 tiles &#125; &#125; 注意，两个类都可以存在于源代码中，因此两个设计都可以通过命令行被实例化。对于有两个tile的新设计:1sbt run --configInstance exmaple.MyConfig2 4.2 Dump顺着Chisel而下，其他的工具可能需要知道特定的参数/Knob赋值。如果需要，只要将Knob/value传给Dump对象，该对象会把name和value写入一个文件，然后返回Knob/value:123456789101112131415package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case Width =&gt; Dump('Width',64) // will return 64. Requires naming the parameter as the 1st argument case NTiles =&gt; Dump(Knob('NTILES')) // will return Knob('NTILES'), no name needed &#125; &#125; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; 每个废弃的参数的name和value会被重写到一个.knb文件，文件在*–targetDir path指定的目录中。 4.3 约束现在外部程序/用户可以很容易地重写一个配置的knobValue方法，我们提供了一种机制可以定义合法的Knobs范围。在ChiselConfig中，可以重写另一个称为topConstraint的方法:1234567891011121314package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NTiles =&gt; Knob(’NTILES’) &#125; &#125; override val topConstraints:List[ViewSym=&gt;Ex[Boolean]] = List( &#123; ex =&gt; ex(NTiles) &gt; 0 &#125;, &#123; ex =&gt; ex(NTiles) &lt;= 4 &#125;) override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; 现在，如果有人想要用以下的配置和命令实例化我们的设计，会无法通过:1234567package example class BadConfig extends ChiselConfig &#123; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 5 // would violate our constraint, throws an error &#125; &#125; 12// throws 'Constriant failed' error sbt run ... --configInstance example.BadConfig 约束可以在设计中的任何位置声明，并不只是在顶层，通过调用Parameters的constant方法:123456789101112131415161718192021package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NTiles =&gt; Knob('NTILES') &#125; &#125; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; class Tile extends Module &#123; params.constrain( ex =&gt; ex(NTiles) &gt; 0 ) params.constrain( ex =&gt; ex(NTiles) &lt;= 4 ) &#125; object Run &#123; def main(args: Array[String]): Unit = &#123; chiselMain.run(args, () =&gt; new Tile()) &#125;&#125; 1sbt runMain example.Run ... --configInstance example.MyConfig 最后，如果设计者想要知道设计约束，他们可以执行Chisel，用–configCollect project_name.config_name选项，这会把一系列约束打印到一个.cst文件中，该文件的位置由*–targetDir path指定: 1sbt runMain example.Run ... --configCollect example.MyConfig --targetDir &lt;path&gt; （完） [参考][1] Bachrach,J.,Vo,H.,Richards,B.,Lee,Y.,Waterman, A., Avižienis, Wawrzynek, J., Asanovic´ Chisel: Constructing Hardware in a Scala Embedded Language in DAC ’12.[2] Odersky, M., Spoon, L., Venners, B. Programming in Scala by Artima.[3] Payne, A., Wampler, D. Programming Scala by O’Reilly books.]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【美食北京】]]></title>
    <url>%2F2016%2F10%2F15%2Ffood-in-beijing%2F</url>
    <content type="text"><![CDATA[博客的目的就是为了记录自己的生活和成长。本篇博文将会持续更新以记录我在北京所探索并尝试的美食，当然曾经也发现过不少美食，虽然饱了口福，却没有充实记忆。 江边城外烤 连锁(五道口店)2016-10-15之前就来过两次，这次来体验一下五道口店。不愧是名声在外，每一次光顾江边城外，门口都是排满了顾客。排号的时候，也可先点菜，毕竟从活鱼到处理完毕再到烹饪完成还是需要比较久的时间的。和妹子两个人，点了份香辣烤鱼(一个香辣盘底和一条2.8斤的清江鱼)，外加几个辅助菜: 乌笋，腐竹。鱼很新鲜，汤汁浓郁鲜美，鱼肉蘸着吃，入口就是一种正宗的重庆味道。评分: 4.5 小吊梨汤 连锁(畅春园店)2016-10-16京城官府菜的代表，每次来都需要排号，受欢迎程度可见一斑。店内装饰别具一格，无论是桌椅还是墙纸灯饰都非常具有古韵，置身店内就有一种神游古都的感觉。深秋，夜幕降至，和女神一起来体验一回京城官府菜。招牌传统小吊梨汤是每次必点饮品，小煎仔鸡、原汤西红柿焖牛腩、椒麻排骨作为热菜，以甜食果粒蜂窝煤为主食，足矣。事实证明，这几个菜对两个人来说稍略显多。小吊梨汤：非常适合寒冷的季节饮用，就像寒冬饮热酒一般。梨汤虽然不是很甜，但是正是这样，喝一壶也不腻。小煎仔鸡：青椒片煎鸡柳，酱汁不错，味道鲜美。 原汤西红柿焖牛腩：土豆和萝卜炖得非常入味，牛肉的味道自然不必多说。 椒麻排骨：排骨中渗透着花椒的味道，感觉还不够入味。 果粒蜂窝煤：甜食，用杂粮做成煤球的形状，内掺火龙果，什锦等果粒。评分: 4.5 金谷园 连锁(北邮南门)2016-10-22周五傍晚永远都是一周中最轻松愉悦、充满期待的一段时光，显然，用美食来消遣这段时光是最佳选择之一。小雨夜，女神带我穿街走巷来到北邮门的一个小胡同。虽说是个连锁店，但却像个小作坊，门面很小。不过里面的空间还是挺大的，特别是屋内的装饰，令人耳目一新，像个咖啡厅，甚至还有长条沙发作座椅。皮蛋瘦肉粥：我人生中喝过的最好的皮蛋瘦肉粥。日式土豆泥沙拉：土豆泥很细，掺和着沙拉，对于深秋季节还是有点凉。葱麻鸡：葱油鸡上浇了层麻酱，鸡肉的味道不够足，总体还是满意的。孜然羊肉饺子：肉馅的分量很足，羊肉磨的很细，饺子皮内还有羊肉汤汁，味道鲜美。鲅鱼饺子：毕竟招牌饺子，饺子皮很劲道，饺子馅鲜美多汁，美味无需多言。评分: 4.5 东来顺 连锁(中关村)2016-11-26在中国的冬季，想必绝大多数人都会把火锅列为好友聚会兄弟小酌的首选之一。而在北方，涮肉的地位等同于南方人心中的火锅。今天就来体验一下，北京大名鼎鼎的东来顺。铜锅的造型就是影视作品里的经典形象，里面有一堆碳木用以保持外面的水沸腾。我们两个人，点了羊肚、蔬菜拼盘、肥牛、肥羊、菌菇拼盘还有两个小烧饼。说实话，实际品尝后心里落差还是蛮大的。关于羊肚，羊肚的劲道和牛肚完全不是一个档次，食材选择的失误直接导致我放弃好评。蔬菜拼盘、菌菇用清水烫，味道中规中矩。肥牛和肥羊只需要稍微涮一下就可出锅，实际上效果和火锅是一样的。唯一值得称赞的也许就是涮肉必备的麻酱了。以前吃过各式各样的麻酱，不过东来顺的麻酱可能是最香的。麻酱浓厚可以掩盖锅底味道的不足。建议吃火锅的时候还是应该选择人多的时候比较合适，能够品尝到各类食材，这样才能达到最高的性价比。评分: 3.8 牛十一海鲜馆 连锁(交大店)2016-11-26“吃”一直都是一个难以抉择的问题。和女神在交大附近游玩，好不容易在大众点评上看到一个距离又近，评分也不错的馆子，随即决定以身试分。辣炒花蛤: 花蛤肉很饱满，味道微辣，属于来店推荐一档。碳烤羊肉串: 属于羊肉串中的上等，价格良心，值得一试。烤大鱿鱼: 切开大鱿鱼绝对是提高用户体验的一道手续。牛十三特色生串: 这个绝对是本店特色，生肉的品相和嚼劲，难以描述的特别味道。克服心理障碍后此处应点赞。烤茄子: 茄子上的微辣细腻的蒜泥绝对能改变有些人对大蒜的偏见。铺在茄子的上层，蒜泥和茄子充分融合，这是爱茄人士的福利。事实上这家店还有一道特色菜——海鲜大拼盘，但由于这次下馆子只有两个人，点海鲜大拼盘绝对是不理智的选择，希望有机会和更多朋友来试试这道菜。评分: 4.3 南京大排档 连锁(中关村)2016-12-4以前在合肥经常吃重庆大排档，来北京两年多了没吃过一次大排档。今天来美嘉看新海诚新作《你的名字》，突然发现这里有家南京大排档，果断来店品尝。店里的装饰和工作人员的服饰都是精心设计的，以营造一种年代感。街坊炒螺蛳: 久违的家乡味道，如何能让一个水乡游子不予以赞许？家乡臭豆腐: 并不是长沙臭豆腐的烹饪方法制作而成，而是用烂咸菜汁做的。小时候家里也做过这种咸菜，那时的我却是非常讨厌吃这种咸菜，而如今却只是慢慢的回忆。江南水乡一同鲜: 里面的食材有大闸蟹，鱼丸子，明虾，花蛤，豆皮。所谓的“鲜”味还有所欠缺。鸭血粉丝砂锅: 切碎的小块鸭血和少许鸭肝、鸭胗，加上香菜和粉丝煲成的砂锅。味道不错，可惜这个砂锅在我心中还是没有超越回味的鸭血粉丝汤。评分: 4.3 重八牛府 连锁(之初入江湖店)2017-1-7女神快要放假回家了，为了庆祝寒假的到来，我们一个星期前就预想着来重八牛府吃一次火锅。周六下午三点开始预约，三点刚过几分钟，已有六桌已预约，火爆程度可见一斑。来到双榆树店，数十米外就能闻到浓郁开胃的火锅飘香。门面是一套木质古风的装饰，迈进门槛，入眼就是十张八仙桌，所幸我们预约得早，很快就排上了座。与我之前吃过的火锅都不一样，这里有专门的服务员为我们配置火锅酱，而且不同的食材会有不同的蘸酱，比如：火锅面就有专门的一碗类似炸酱面的拌酱，对于肥牛肥羊之类的褶皱较多的食材则有对应的酱汁。一个大铜锅盛满清汤锅底，相较于其他火锅也算是独具一格。至于火锅的味道，两点令我印象深刻：酱料、飘香。尽管我没去过火锅之都重庆，但是好歹我也吃过不少火锅：海底捞、澳门豆捞、傣妹…对于重八牛府，我能出给的评价是：这是我迄今为止吃过最好吃的火锅。听朋友说重庆还有更好吃的火锅，因此我们已经盘算着上半年去重庆旅游，毕竟美食对于吃货来说是旅游的最大动力。这次的照片数量有点少，因为这次光顾着吃而没有拍下多少照片，囧…评分: 4.8 （未完待续）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【我的绘画作品】]]></title>
    <url>%2F2016%2F08%2F29%2Fmy-paintings%2F</url>
    <content type="text"><![CDATA[小时候，我的梦想是成为一个画家。在幼儿园之前，曾经有机会接触绘画教育，很遗憾却因为一些小意外而错失了。不过，这并不能阻止我热爱绘画。我的画作其实并不多，现在一年能画一幅已然是奢侈。用一篇持续更新的博文来展示我的画作其实也足够了。 20162月和bluestory风格类似，不过符合我的口味。 20152月非常喜欢DJ Okawarri的flowerdance专辑以及专辑封面。 20142月百无聊赖。 1月想画画，但不知道画什么，突然想到好友喜欢海贼王，那就来个路飞吧。 2013一天时间重新回味了一遍《变形金刚》三部曲，心血来潮的作品。 （未完待续）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码解读——Matrix-Code-Rain]]></title>
    <url>%2F2016%2F08%2F26%2Fmatrix-code-rain%2F</url>
    <content type="text"><![CDATA[最近自己的博客刚刚建起来，想好好经营一下。内容比较少，另外希望能产出一些高质量的文章，所以不想将CSDN博客上的文章迁移过来。那么就得自己发点干货了。废话不多说，转入正题。 数个月前在github上阅读过一个小项目的源码——Matrix-code-rain。其效果是黑客帝国中代码在屏幕上从上至下滑落。DEMO见此链接。如下截图所示即代码雨效果图: 首先观察效果图，大致分为三个部分: 左上角的帧频监测模块、左下角的快照工具栏、代码雨主体。 项目的index.html文件中的body部分包含了两个主要的元素: id=”info”的div元素 id=”canvas”的画布前者提供了快照功能，以旋转方式显示/隐藏的特效（该效果是以CSS3实现的）；后者实现了帧频检测功能以及主效果代码雨。 下面先把JS主干代码贴出，并做简要解读。 主干代码这里仅标出代码主干，具体细节请查看源码。代码的主干很简单，如下所示: 123456789101112131415var stats = new Stats();stats.domElement.style.position = 'absolute';stats.domElement.style.left = '0px';stats.domElement.style.top = '0px';document.body.appendChild( stats.domElement );var M = &#123;...&#125;;function eventListenerz()&#123;...&#125;window.onload = function()&#123; M.init(); eventListenerz();&#125;; 先简单分析一下主干代码，然后再分析具体细节:开头五行代码，引用了一个外部JS文件(stats.min.js)定义的一个构造函数Stats()，然后初始化一个对象，这个对象的功能就是帧频检测，最后把它放到左上角。接着初始化一个对象M，这个对象内部定义了很多属性和方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var M = &#123; // 属性 // 关于每一栏canvas的属性设置 setting: &#123; COL_WIDTH: 15, // 每一栏的宽度 COL_HEIGHT: 25, // 每一栏的高度 VELOCITY_PARAMS: &#123; min: 4, // 代码雨的最小速度 max: 8 // 代码雨的最大速度 &#125;, CODE_LENGTH_PARAMS: &#123; min: 20,// 代码雨的最小长度 max: 40 // 代码雨的最大长度 &#125; &#125;, animation: null, c: null, ctx: null, lineC: null, ctx2: null, video: null, WIDTH: window.innerWidth, HEIGHT: window.innerHeight, COLUMNS: null, // canvas列数 canvii: [], font: '30px matrix-code', letters: ['a', 'b', 'c', ...], codes: [], createCodeLoop: null, codesCounter: 0, // 方法 init(), loop(), draw(), createCode(), createCanvii(), createLines(), assignColumn(), randomFromInterval(), snapshot() &#125;; 然后定义一个添加事件监听的函数eventListenerz。 当页面加载后执行如下代码:1234window.onload = &#123; M.init(); // 初始化M eventListenerz(); //添加事件监听&#125;; M.init()做了以下这些事: 将canvas元素赋值给M.c； 获取画布上的绘图环境，并赋值给M.ctx（后面称之为画布）； 获取页面的高度、宽度并设置画布的高度和宽度，让画布充满整个页面； 设置画布背景色为黑色； 设置画布的字体为30px matrix-code； 创造屏幕质感，画一条条的横线。这里动态创建了一个canvas元素，并设置画布的宽高与页面一致，通过调用M.createLines()方法来绘制满屏的横线，其实为了效果更好每条横线下面紧挨一条颜色更淡的横线，达到色差缓冲的效果； 根据网页的宽度、预设的canvas宽度，计算网页横向能放多少个canvas； 针对每一栏canvas初始化一个codes数组，数组的0索引的值是一个对象: 12345&#123; 'open': true, 'position': &#123;'x', 0, 'y': 0&#125;, 'strength': 0&#125; 调用M.loop()方法，该方法内部调用了requestAnimationFrame，并把其任务ID赋值给M.animation。然后是loop方法的主体，调用M.draw()——想必就是绘制代码雨的效果。此外，同时更新帧频检测器的数据状态，达到循环动画的效果。 调用M.createCode()方法，该方法什么作用？请继续往下阅读。 这时候，代码的大体流程已经知道了，我们只要了解M.draw()是如何绘制代码雨，以及M.createCode()是如何初始化的即可。 代码雨先来看我绘制的一张图，改图简要的介绍了代码雨的组成，在看具体分析之前大家可以先自己想想其实现方式。 要了解代码雨原理，首先了解M.draw()是如何工作的。 M.draw()M.draw()做了以下工作: 清理画布，避免之前绘制的图像遗留在画布上产生重影； 设置如何将新图像绘制到已有图像之上，默认为source-over； 对每一canvas进行处理。 1). 当其codes[0]包含canvas属性时，获取其速度值、canvas的高度，x、y坐标，canvas元素，canvas画布。然后根据其位置将这个canvas添加到主canvas上。 a. 当y坐标小于网页高度时（即canvas的y坐标还在网页范围内），更新y坐标(y减去速度值)； b. 否则，将y坐标设为0，这就达到了同一列不停的循环的效果。 看到第3步，对比代码主干一节中第8步，我们发现：M.draw()阶段时每一栏的canvas的codes数组根本没有canvas属性。这种情况下，第3步中的处理条件根本无法达到。所以肯定缺少初始化的一步，这肯定包含在M.createCode()中，其实看方法名也能看出来。 M.createCode()M.createCode()做了以下工作: 判断M.codesCounter是否大于canvas列数。如果是，清除M.createCodeLoop的定时任务，并返回。否则，继续往下执行。推断一下：毕竟网页横向被分解成了很多个canvas，有多少个canvas，M.createCode()就会被调用多少次吧。 给局部变量randomInterval赋值为M.randomFromInterval(0,100)的执行结果。直接跳到这段代码看看，哦，生成一个0到100之间的随机数。 给局部变量colum赋值为M.assignColumn()的执行结果。直接跳到这段代码看看：随机获取一个canvas的索引，如果该canvas的codes[0]的open属性为true，则置为false，并返回canvas的索引；否则直接返回false。仔细想想，这段代码把open置为false后，并没有还原成true。 根据column索引值，对对应一列的canvas进行处理。 1). 随机获取一个代码雨长度值，并赋值给codeLength； 2). 随机获取一个代码雨速度值，并赋值给codeVelocity； 3). 获取代码雨字符表的长度，并赋值给lettersLength； 4). 设置该canvas的codes[0].position属性，起始的x坐标与列索引有关，y坐标都为0； 5). 设置该canvas的codes[0].velocity属性，为随机获取的速度值； 6). 设置该canvas的codes[0].strength属性，为其速度/速度上限值，这个到底什么作用呢？先放着继续往下看； 7). 根据代码雨长度值，获取相应数量的字符，这是通过在字符表中随机获取的，并将字符依次赋值给该canvas的codes[1], codes[2]… 8). 调用M.createCanvii(column)。这里把canvas的列索引值传递进去了，想必就是进行绘制操作了。 9). M.codesCount++，这一步验证了第1步的猜想。 根据局部变量randomInterval来设置另一列canvas的初始化。 M.createCanvii()上面一节第8步对M.createCanvii(col)的作用进行了猜想，下面我们来看看是不是符合我们的猜想。M.createCanvii(col)做了以下工作: 获取该列canvas要显示的字符数，赋值给codeLen； 获取该列canvas的高度，通过字符数*每个字符的高度即可得到； 获取该列canvas的速度，通过codes[0].velocity即可得到； 获取该列canvas的strength，此时我们还是不知道这是个什么参数； 创建一个canvas元素，并获取其画布环境，并设置其宽度和高度； 根据codeLen，绘制所有字符，这里并不是单纯的绘制。前5个和最后4个不太一样，哪里不一样呢？之前不明白其含义的strength出现了，原来是为了让两端的颜色变淡一些。 绘制完毕后，将该列canvas的codes[0].canvas的值赋为这里绘创建的canvas元素。哦，这时候，M.draw()一节的第3步的条件就成立了，就可以把这个创建的canvas添加到网页的主canvas了。 现在一切就明了了，接下来有兴趣的话可以看看快照工具栏的效果实现。 快照工具栏先来看看CSS3提供的几个动画方法和特性: transform: none | transform-functions123456matrix(): /*定义转换*/ translate(): /*原点坐标偏移*/scale(): /*缩放*/ rotate(): /*沿轴旋转*/ skew(): /*沿轴倾斜*/ perspective(): /*定义透视*/ transition: property duration timing-function delay123transition-property: none|all|property; transition-duration: time(s/ms); transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n) transform属性的是transform-function，上述只列出了6类方法，每一类方法对应还有针对2D, 3D的方法。 很明显，快照工具栏的旋转显示/隐藏方式是以tramsform分别对显示时定义一个状态，隐藏时定义一个状态，然后通过CSS3的transition属性来进行状态切换设置。 果然代码中也是以这种方式实现的:显示状态123transform-origin: bottom center;transform: rotate(0deg);transition: transform 1s ease-in-out; 隐藏状态1transform: rotate(180deg); 状态转移方式1transition: transform 1s ease-in-out; 两个状态、转移方式都定义好了，那么就可以通过事件了切换这两者的状态了。用toggle的方法来添加/删除类来达到状态切换的效果。果然，JS代码中有一个函数eventListenerz()就包含了状态切换的处理。此外，快照工具栏还有一个主要功能: 快照。还是在上面那个函数里面，包含了这两行代码:12var snapshotBtn = document.getElementById('snapshot');snapshotBtn.addEventListener('click', M.snapshot, false); 第一行代码获取了快照按钮的buttn元素；第二行代码则是对该按钮添加了一个click事件监听以及相应的回调函数。M.snapshot是其内部定义的一个方法。其源码如下:1234snapshot: function()&#123; M.createLines(M.ctx); window.open(M.c.toDataURL());&#125; M.c为页面的主canvas，对其调用toDataURL()方法，该方法将canvas进行转化成一个特定格式的图片（默认PNG），并返回一个data URI。最后新开一个窗口显示该图片。 （完）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于此博客]]></title>
    <url>%2F2016%2F08%2F14%2Fblog-introduce%2F</url>
    <content type="text"><![CDATA[为何建这个博客互联网在国内兴起的时候我还很小，那时候依稀记得QQ，博客，上网这些字眼儿。等到稍微大一点的时候才知道原来博客其实也是一类网站，那时就希望未来能有一个自己的网站。 如今，作为一个计算机系的学生，身边不乏有很多大神都拥有着自己的网站（博客），分享着自己的生活，技术以及其他各方面的收获。我也希望自己能够向这些大神们迈进，同时也能记录身边的点点滴滴。或许，待到某一天，你回首往事，那一刻的真实感受会从字里行间再次涌现。 之前，看到一篇文章，文章里说：真正优秀的程序员，往往都有着非常好的逻辑思维能力和语言表达能力，而经常撰写对外公开博文会让你不断提炼自己的语言文字，锻炼你的总结能力和表述能力，这显然有利于这些能力的培养。 平常的看书的时候我会记一些笔记，而那些笔记总是那么索然无味，或者缺少自己总结和见解。希望此博客的诞生能够为我的学习提供更大的帮助。 关于博客的域名查询注册域名的时候，很高兴发现我的全名的.com域名（www.baochuquan.com）居然没有被注册。不过，身为一名前端，用户体验之上的理念始终贯穿我心，太长的域名显然不利于用户体验。就这样，亲切易记的chuquan.me成为了我的首选。 （完）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业旅行——厦门]]></title>
    <url>%2F2014%2F05%2F27%2Fxiamen%2F</url>
    <content type="text"><![CDATA[清理照片时，看到了我们毕业旅行去厦门的照片，满满的都是回忆。想着好久都没写过博文了，就写一篇旅游回忆吧~ Day 15月18日启程，普快卧铺。从合肥站上车，目的地是厦门站。妹纸人生第一次坐火车，我却是第一次吃康师傅的新款泡面——爱鲜大餐。 这是我们的床铺~ Day 2在火车进入福建境内后，开始在山区中曲折前行，路边的植物也开始热带化了，滴水观音什么的随处可见。抵达目的地已经是下午5点左右了，我们到来之前的厦门刚刚经历一场阵雨，空气中弥漫着浓厚的湿气。下车后，我们在车站关于坐公交还是打的去旅馆纠结了一会儿，最终还是上了黑的。我们住的第一家旅馆是在曾厝垵，不过当时根本没发现这里居然离芙蓉隧道非常近。品尝了当地的大青芒和路边摊~ Day 3计划去鼓浪屿，清晨的时候下着大雨，我们等到雨停了出发。到达码头后坐船进发鼓浪屿，抵达鼓浪屿的三丘田码头。三丘田码头~ 导游图~鼓浪屿一眼望去都是些西洋楼，完整地保留着大使馆的样式。我们选了一条路线，这条路线的开始便是一道小巷子，有一侧是石墙，墙内红杏出墙，哈哈。转过小巷子便是一片文艺清新的民宅。每家宅子里都装饰的非常漂亮，花草满院。再往深处走便是各种古树与建筑交叠。我们的目的是先把行李放到岛上旅馆————程程家旮旯。旅馆是在岛上，网上评分还挺高的，院子内的装饰布置都是很清新的。行李放下后，可以肆意地潇洒了。尝了尝当地的果子，好像叫奇异果，忘记叫什么名字了，有点酸~随后我们到了鼓浪屿著名的商业区，各种文艺小店铺依次呈现。闽台地区的肠粉~豆来豆去的土豆卷儿然后就是各种奇葩小店铺。、我们在来玩之前看了不少攻略推荐，美式什么的啥都少不了，挨个儿品尝。林氏鱼丸马拉桑——有些桑果的味道沙茶面海蛎煎后来到了一个环形的建筑内，顶部是敞空的，还有人在拍婚纱。接着就转悠到了海边。虾扯蛋——有点像章鱼小丸子旅游怎么能没有自拍呢麻糍——感觉像是糯米团子一逛就是一下午，来海边看一下日落。我也来个自拍吧天很快进入夜色，我们海边找了家馆子，吃了些海瓜子什么的。打开QQ，封面是520，因为这天正好是520，我们算好这天登陆鼓浪屿。 Day 4今天要离岛，我们出门便退了房，背上了行李，告别前，妹纸在墙上贴了留言。 我们继续游览鼓浪屿，首先就是路经安献堂。安献堂门口是一条通幽曲径。然后，我们径直向日光岩出发，日光岩是鼓浪屿的制高点，在顶峰可以一览鼓浪屿全貌。下一个目的地是郑成功纪念馆。我把你拍的那么美，你把我拍成一团黑~然后就是漫无目的的逛岛。大约中午，我们乘船离开了鼓浪屿。回到第一天住的地方后，我们就去曾厝垵找传说中的亚尖大排档，不过并没有传说中那么好吃。饭后，曾厝垵必须逛一逛。 Day 5清晨，下着小雨，我们启程去南普陀和厦大。 南普陀的旁边就是厦大，和清北很像，厦大也是有很多人排队参观。芙蓉湖里好多鲶鱼前方便是芙蓉隧道，隧道有一公里长，在里面时间太久会有缺氧感，我们没有久留。 Day 6这天，天有小雨，我们逛了中山街，类似于各个城市的步行街，然后晚上去了湖里区，因为那里离机场比较近。 Day 7在烟雨蒙蒙的清晨告别厦门。果然计划赶不上变化，我们有好多地方没有去玩，当然天气也是有原因的。如果是晴天，便可以允许骑行环岛路，游白城沙滩。童话村也没来得及去等等。以后有机会，我们还会再来的。 （完）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
</search>
