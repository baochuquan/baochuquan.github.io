<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OSI 模型与 TCP-IP 协议详解]]></title>
    <url>%2F2019%2F03%2F02%2Fosi-tcp-ip-introduce%2F</url>
    <content type="text"><![CDATA[OSI 参考模型在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着异构机型之间通信的需求不断增加，通信技术的标准化也随之展开。于是，ISO（International Organization for Standard）制定了一个国际标准 OSI（Open System Interconnection），即广为人知的 OSI 参考模型，作为标准化通信技术的设计准则。 OSI 参考模型将通信协议中必要的功能分层了 7 层。每个分层接收下一层提供的特定服务，并负责为上一层提供特定的服务。这些功能上相对独立的分层可以构造一个扩展性和灵活性都较强的系统。 下表所示为 OSI 参考模型及其各个分层的职责。 应用层：主要负责为应用程序提供服务并规定应用程序中通信相关的细节。在该层实现的协议有：文件传输、电子邮件、远程登录等协议。 表示层：主要负责数据格式的转换。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。 会话层：主要负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。 传输层：主要负责进行可靠传输。只在通信双方节点上进行处理，而无需在路由器上处理。 网络层：主要负责寻址和路由选择，从而将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某个地址。 数据链路层：主要负责物理层面上互连的、节点之间的通信传输。将 0、1 序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。如与 1 个以太网相连的 2 个节点之间的通信。 物理层：主要负责 0、1 比特流（0、1 序列）与电压的高低、光的闪灭之间的互换。 OSI 参考模型通信示例下面举例说明 OSI 参考模型的功能。假设使用主机 A 的用户向使用主机 B 的用户发送一封邮件。 应用层用户 A 在主机 A 上新建一封邮件，指定收件人为 B，并输入邮件内容为 “早上好”。用户确认发送时，开始进入应用层协议的处理。该协议在传送数据的前端附加一个首部信息。主机 B 在收到主机 A 发送至的数据后，分析其数据首部与数据正文，并将邮件存入本地。 表示层表示层会将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复成“该计算机特有的数据格式”，然后在进行相应的处理。 此例中，“早上好”这段文字根据编码格式被转换成了“统一的网络数据格式”。由于文字的编码格式非常多，如：UTF-8、UTF-16、Unicode 等，如果未能按照特定格式编码，那么在接收端收到的邮件可能就是乱码。 会话层假如用户 A 新建了 5 封邮件准备发送给用户 B。这 5 封邮件的发送顺序可以有多种： 每发一封邮件时建立一次连接，随后断开连接 一旦建立连接后，将 5 封邮件连续发送给对方 同时建立 5 个连接，将 5 封邮件同时发送给对方 会话层的主要责任就是决定采用何种连接方式。 类似应用层、表示层，会话层在其收到的数据前端附加首部之后再转发给下一层。这些首部中 记录着数据传送顺序的信息。 传输层会话层只对何时建立连接、何时发送数据等问题进行管理，并不具备实际传输数据的功能。真正负责在网络上传输数据的是会话层以下的分层。 主机 A 确保与主机 B 之间的通信并准备发送数据。该过程称为“建立连接”。连接建立后即可使主机 A 发送的邮件到达主机 B。传输结束之后，有必要将连接断开。 上述两个主机之间创建逻辑上的通信连接是传输层的主要作用。此外，传输层为确保数据到达目标地址，会在通信两端的主机之间进行确认，如果数据没有到达，则负责进行重发。 示例中，如果主机 A 将“早上好”发送给主机 B，由于网络异常等原因导致只有部分数据到达目标地址。假设主机 B 只收到“早上”这部分数据，那么它会将没有收到“早上”之后那部分数据的事实告诉主机 A，主机 A 得知后会将“好”重新发送给主机 B，并再次确认对端是否收到。 因此，保证数据传输的可靠性是传输层的一个重要作用。为了确保可靠性，传输层也会对所要传输的数据附加首部以识别这一分层的数据。然而，实际上将数据传输给对端的处理是由网络层完成的。 网络层网络层的作用是在网络与网络互连的环境中，将数据从发送端主机发送到接收端主机。如图所示，两端主机之间虽然有众多数据链路，但是能够将数据从主机 A 发送到主机 B 也都是网络层的功劳。 网络层的数据发送通过目标地址选择对应的计算机，因此目标地址是网络中唯一指定的序号，类似于电话号码。 数据链路层、物理层通信传输本质上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过介质互连的设备之间进行数据处理。 物理层则将数据的 0、1 转换为电压和脉冲光传输给物理的传输介质，而相互直连的设备之间使用地址实现传输。这种地址被称为 MAC 地址。采用 MAC 地址，目的是为了识别连接同一传输介质上的设备。物理层会将包含 MAC 地址的信息的首部附加到同网络层转发过来的数据上，并将其发送到网络中。 网络层与数据链路层都是基于目标地址将数据发送给接收端，其区别在于： 网络层负责将整个数据发送给最终的目标地址 数据链路层只负责发送一个分段内的数据 详见上图。 TCP/IP 协议分层模型TCP/IP 的含义从字面上看，有人可能会认为 TCP/IP 是指 TCP 与 IP 两种协议。虽然实际中的确有这两种协议，但是在很多情况下，它泛指 IP、ICMP、TCP、UDP、TELNET、FTP、HTTP 等协议群，所以有时也称 TCP/IP 为 网际协议族。 数据包包、帧、数据报、段、消息 等五个术语都用来表述数据的单位，其区别在于： 包：全能性术语 帧：表示数据链路层中包的单位 数据报：表示 IP 和 UDP 等网络层以上分层中包的单位 段：表示 TCP 数据流中的信息 消息：表示应用层中数据的单位 网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上层传来的数据。在数据包的首部，明确标明了协议应该如何读取数据。通过解析首部，能够了解该协议必要的信息以及要处理的内容。 TCP/IP 与 OSI 参考模型关于 TCP/IP 与 OSI 参考模型的关系，我们可以认为 TCP/IP 是对 OSI 参考模型的一种具体实现。 硬件（物理层） TCP/IP 的最底层是负责数据传输的硬件，如以太网或电话线路等物理层的设备。物理层所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等都会有所不同。 网络接口层（数据链路层） 网络接口层利用以太网中的数据链路层进行通信，因此属于接口层，可认为是让 NIC（网卡）正常工作的驱动程序。 互联网层（网络层） 互联网层使用 IP 协议，对应 OSI 模型中的第 3 层网络层。IP 协议基于 IP 地址转发分组数据包。 TCP/IP 分层中的互联网层与传输层的功能通常由操作系统实现。尤其是路由器，它必须实现通过互联网曾转发分组数据包的功能。连接互联网的所有主机和路由器都必须实现 IP 的功能。 为什么要分组？首先需要明确一个事实：一台计算机在收发数据时会独占其所在的整条通信线路。如果一条线路上连接了多台计算机，当计算机相互之间进行数据传输时，则需要等待线路中没有其他计算机占用时才能进行数据传输。如果某台计算机占用线路之后传输大量数据，则其他计算机始终保持等待状态。极端情况下根本无法进行通信。采用分组（交换）技术，数据会被分成更小的单元，所有的计算机就可以并发收发数据，从而提高了通信线路的利用率。 IPIP 是跨越网络传送数据包，使整个互联网都能收到数据的协议，这个过程中使用 IP 地址作为主机的标识。IP 还隐含着数据链路的功能。通过 IP，相互通信的主机之间无论经过怎样的底层数据链路都能够实现通信。IP 是分组交换的一种协议，但其并不具备重发机制。即使分组数据包未能达到对端主机也不会重发，属于非可靠传输协议。 ICMPIP 数据包在发送途中一旦出现异常导致无法到达对端目标地址时，需要向发送端发送一个异常通知。ICMP 就是为这一功能而定制的，常用于 诊断网络的健康状况。 ARP从分组数据包的 IP 地址中解析出物理地址（MAC 地址）的一种协议。 传输层 传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同时运行着多个程序。为了识 别哪些程序之间在进行通信，使用 端口号 进行区分。 TCPTCP 是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP 能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP 还能够有效利用带宽，缓解网络拥堵。 为了建立和断开连接，TCP 需要进行 3 次握手，4 次挥手，从而会导致网络流量的浪费。 UDPUDP 是一种面向无连接的传输层协议。UDP 不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。UDP 常用语分组数据较少或多播、广播通信以及视频通信等多媒体领域。 应用层（会话层以上分层） TCP/IP 协议分层模型将 OSI 参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。 TCP/IP 协议分层模型通信示例这里继续以上述电子邮件收发的示例来介绍 TCP/IP 协议分层模型的通信过程。 邮件收发过程可分为个主要步骤： 发送数据包（发送端） 接收数据包（接收端） 发送数据包应用程序处理应用程序在发送邮件那一刻建立 TCP 连接，从而利用该 TCP 连接发送数据。该过程首先将应用层发来的数据发送至下一层的 TCP，再做实际的转发处理。 TCP 模块处理TCP 根据应用程序的指示，负责建立连接、发送数据、断开连接。TCP 会在应用层数据前端附加一个 TCP 首部，其中包括：源端口号 和 目标端口号（用以识别发送主机和接收主机上的应用）、序号（用以标识发送包中哪部分是数据）、校验和（用以判断数据是否被损坏）。 IP 模块处理IP 将 TCP 传来的 TCP 首部和 TCP 数据合起来作为自己的数据，并在数据前端附加一个 IP 首部，其中包括：接收端 IP 地址和发送端 IP 地址。 IP 包生成后，根据路由控制表决定接收此 IP 包的路由器或主机。随后，IP 包将被发送给连接到这些路由器或主机网络接口的驱动程序，以实现真正发送数据。 如果尚且不知道接收端的 MAC 地址，可利用 ARP 查找。只要知道了对端的 MAC 地址，就可将 MAC 地址和 IP 地址交给以太网的驱动程序，实现数据传输。 网络接口（以太网驱动）处理以太网驱动会将 IP 传来的 IP 包的前端附加上以太网首部并进行发送处理。以太网首部包含：接收端 MAC 地址、发送端 MAC 地址、标志以太网类型的以太网数据的协议。由此产生的以太网数据包将被发送至物理层传输给接收端。 接收数据包数据包的接收流程是发送流程的逆序过程。 网络接口（以太网驱动）处理主机收到以太网包后，先从以太网包首部找到 MAC 地址判断是否为发给自己的包。如果不是则丢弃。 如果确认是发给自己的包，则查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。示例中数据的协议类型是 IP，因此将数据传送给处理 IP 的子程序（如果是 ARP，则把数据传给处理 ARP 的子程序）。如果无法识别协议类型，则丢弃数据。 IP 模块处理IP 模块收到 IP 包首部以数据部分后，也做类似处理。如果判断首部中的 IP 地址与自己的 IP 地址匹配，则接收数据并从中查找上一层的协议。如果上一层协议为 TCP，则传给 TCP 处理；如果上一层协议为 UDP，则传给 UDP 处理；对于路由器，接收端 IP 地址往往不是自己的 IP 地址，此时会根据路由控制表，查询应送达的主机或路由器以后再转发数据。 TCP 模块处理TCP 模块会先计算校验和以确认数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。 数据接收完毕后，接收端则发送一个“确认回执”给发送端。如果回执消息未能达到发送端，发送端会认为接收端没有接收到数据而一直重复发送。 数据被完整接收后，会传给由端口号识别的应用程序。 应用程序处理接收端应用程序通过解析数据可最终获取到邮件的具体内容。 参考 OSI 模型-维基百科 《图解 TCP/IP》 《TCP/IP 详解》]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年总结]]></title>
    <url>%2F2018%2F12%2F31%2F2018-summary%2F</url>
    <content type="text"><![CDATA[又到了年末总结的时候了…回望年初立下的 Flag，不知道倒下了多少，扶都扶不起来。 简单总结一下这一年吧.. 关于运动从 7 月份至 10 月份，在这 4 个月期间，每周末去自学游泳。从旱鸭子状态开始，依次掌握了蛙泳，狗刨，自由泳，仰泳，蝶泳。目前，蝶泳还不是非常协调，有待进一步强化练习。毕竟，蝶泳是所用泳姿中门槛最高的一种，无论是在力量方面还是协调性方面。 当然，完全靠自己摸索来学习游泳是一个很漫长的过程。为了加快我的学习进入，在学游泳期间，我坚持观看 YouTube 上易梦觉教练的一些游泳教学视频，学习一些游泳的技巧。 年底的时候，开始教妹子学游泳，目前蛙泳差不多已经会了。 除了游泳，今年在周末的时间还有一部分给了篮球。自从 3 月份那会儿在高家园附近的社科院里发现了一个室外篮球场后，在 7 月份之前几乎每周末都会去打一次球。 总体来说，今年的运动量增加了不少，同时掌握了游泳这个新技能。 关于旅行今年 10 月底，随公司一起去俄罗斯玩了一周。游记传送门 关于工作年初的时候，刚刚开始接手模块级的 iOS 开发任务，那时候还不是非常娴熟。经过这一年的锻炼，已经能够 carry 任何需求了。 这一年里，公司的工作节奏依然比较快的，毕竟走的是 Scrum 的项目管理模式，需求迭代很快，并且研发人员相对产品经理较少。为了解决研发人员不足的问题，从年初就开始不停地招人。到年底，我们整个研发组从原来的 15 人左右增至 30 多人。公司整体的人员也增涨了不少，去年入职时只有 500 人左右，此刻已经有了 2800 多人了。在全球经济如此不景气，各个公司都不断裁员的背景下，我司还在不断地扩招，不禁感慨教育行业的优越性[手动捂脸]。 6 月份，公司给我们调了一次薪水，发了期权，虽然不是很多，但符合预期。 关于技术今年来了几位有着丰富工作经验的同事，在他们的积极推动下，我们的搜题和口算的项目也开始引入了一些新的技术框架。口算目前基本已经在使用 Swift 进行开发了，并已经在使用函数响应式编程框架 RxSwift。搜题方面由于历史原因，虽然引入了 RxSwift，但还没有开始全面使用。 去年立下的关于阅读开源框架的 Flag，今年只是阅读了一些公司内部的框架，如：YTKFrog、YTKRouterManager、YTKResourceSync 等，关于阅读开源框架这个 Flag，希望明年能够重视。 关于阅读今年上半年，我又重新看了一遍《程序员的自我修养——装载、链接与库》，然后写了几篇博客。从中我发现了一种相比以前更加高效的吸收知识、提高阅读效率的方法——写博客。为什么呢？因为我们看完一本书时，其实有效的知识吸收程度并不高，写博客能够让我们加强对关心的主题的理解。写博客的过程中，需要我们不断地重新翻看书中的一些要点，甚至查阅其他书籍、博客，从而加强我们对它的理解。后来我写的几篇博客：《计算机那些事(7)——图形图像渲染原理》、iOS 图像渲染原理 都是按照同样的方式做的，受益匪浅。后一篇文章甚至被 CocoaChina 社区转载了，虽然没有稿费，但还是非常开心。 年末的时候，我开始对编程语言、编程范式起了兴趣。依次看了几本书：《七周七语言》、《函数式编程思维》、《函数式 Swift》。希望新的一年能够继续深入研究编程语言，能够产出几篇博文。 FlagFlag 还是要立起来的，毕竟明年年底要是要给自己打打脸，清醒地认清自我。 深入研究编程语言，包括编程范式、实现模式、DSL 等。先列一些书单： 《类型和程序设计语言》 《自制编程语言》 《领域特定语言》 《编程语言实现模式》 … 掌握一些其他的编程语言。 副业搞起来，通过专利代理人资格考试 横向发展，学习 Android 开发。 提升 Linux 基本技能 做一个全栈项目]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO 原理详解]]></title>
    <url>%2F2018%2F12%2F12%2Fkvo-principle%2F</url>
    <content type="text"><![CDATA[KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。源码地址 示例源码12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; [self setupSubviews]; BAOPerson *p1 = [[BAOPerson alloc] init]; BAOPerson *p2 = [[BAOPerson alloc] init]; p1.age = 1; p1.age = 2; p2.age = 2; // self 监听 p1 的 age 属性 NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil]; p1.age = 10; [p1 removeObserver:self forKeyPath:@&quot;age&quot;];&#125;- (void)setupSubviews &#123; [self setupHeaderView];&#125;- (void)setupHeaderView &#123; self.headerView.title = @&quot;KVO&quot;;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@&quot;监听到 %@ 的 %@ 改变了 %@&quot;, object, keyPath,change);&#125; 示例对 p1 进行了 KVO 监听，当 p1 发生改变，即调用 observeValueForKeyPath 方法，从而打印以下信息。12345监听到 &lt;BAOPerson: 0x600003750200&gt; 的 age 改变了 &#123; kind = 1; new = 10; old = 2;&#125; KVO 实现原理通过上述代码可以发现，一旦 age 属性的值发生改变，就会通知到监听者。我们知道赋值操作都是调用 set 方法，我们可以重写 BAOPerson 类中 age 的 set 方法，观察 KVO 是否是在 set 方法内部做了一些操作来通知监听者。 1234- (void)setAge:(NSInteger)age &#123; NSLog(@&quot;override setAge&quot;); _age = age;&#125; 我们发现即使重写了 set 方法，p1 除了调用 set 方法之外还会执行监听者的 observeValueForKeyPath 方法。 根据上述实验推测：KVO 在运行时对 p1 对象进行了改动，使 p1 对象在调用 setAge 方法时做了一些额外的操作。所以问题出在对象身上，两个对象可能本质上并不一样。下面我们来探索一下 KVO 内部是如何实现的。 KVO 实现分析首先分别在添加 KVO 前后打上断点，以观察添加 KVO 前后 p1 对象有何不同。 通过打印对象的 isa 指针，我们发现，p1 对象的 isa 指针由之前的指向类对象 BAOPerson 变成了指向类对象 NSKVONotifying_BAOPerson。相应地，p2 对象没有改变。因此我们可以推测，p1 对象的 isa 发生改变后，其执行的 setAge 也发生了改变。 我们知道，p2 在调用 setAge 方法时，首先会通过 p2 对象的 isa 指针找到 BAOPerson 类对象，然后在类对象中找到 setAge 方法，最终找到方法对应的实现。如下图所示： 但是，p1 对象的 isa 在添加 KVO 之后已经指向了 NSKVONotifying_BAOPerson 类对象，NSKVONotifying_BAOPerson 则是 BAOPerson 的子类。NSKVONotifying_BAOPerson 是 runtime 在运行时生成的。因此，p1 对象在调用 setAge 方法时必然会根据 p1 的 isa 找到 NSKVONotifying_BAOPerson，并在 NSKVONotifying_BAOPerson 中找到 setAge 方法及其实现。 经查阅资料了解到，NSKVONotifying_BAOPerson 中的 setAge 方法中其实调用了 Foundation 框架中 C 语言函数 _NSsetIntValueAndNotify，_NSsetIntValueAndNotify 内部的操作大致是：首先调用 willChangeValueForKey 方法，然后调用父类的 setAge 方法对成员变量赋值，最后调用 didChangeValueForKey 方法。didChangeValueForKey 方法中会调用监听者的监听方法，最终调用监听者的 observeValueForKeyPath 方法。 KVO 原理验证前面我们已经通过断点打印 isa 指针的方式验证了：p1 对象在添加 KVO 后，其 isa 指针会指向一个通过 runtime 创建的 BAOPerson 的子类 NSKVONotifying_BAOPerson。 下面我们可以通过打印方法实现的地址来看一下 p1 和 p2 的 setAge 方法实现的地址在添加 KVO 前后有什么变化。 1234567// 通过methodForSelector找到方法实现的地址NSLog(@&quot;添加 KVO 之前 - p1 = %p, p2 = %p&quot;, [p1 methodForSelector: @selector(setAge:)], [p2 methodForSelector: @selector(setAge:)]); NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];NSLog(@&quot;添加 KVO 之后 - p1 = %p, p2 = %p&quot;, [p1 methodForSelector: @selector(setAge:)], [p2 methodForSelector: @selector(setAge:)]); 执行上述代码，可以发现：在添加 KVO 之前，p1 和 p2 的 setAge 方法实现的地址是相同的；在添加 KVO 之后， p1 的 setAge 方法实现的地址发生了改变。通过打印方法实现可以证明，p1 的 setAge 方法的实现由 BAOPerson 类方法中的 setAge 方法转换成了 Foundation 框架中的 C 函数 _NSSetIntValueAndNotify。 事实上，Foundation 框架中很多例如 _NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify 等函数。 为了查看 Foundation 框架中的相关函数，我们找到 Foundation 文件，通过命令行查询：1nm Foundation | grep ValueAndNotify 中间类内部结构NSKVONotifying_BAOPerson 作为 BAOPerson 的子类，其 superclass 指针指向 BAOPerson 类，其内部对 setAge 方法做了单独的实现，那么 NSKVONotifying_BAOPerson 同 BAOPerson 类的差别可能就在于其内存储的对象方法及实现不同。我们通过 runtime 分别打印 BAOPerson 类对象和 NSKVONotifying_BAOPerson 类对象内存储的对象方法。 12345678910111213141516171819202122232425262728293031323334353637- (void)viewDidLoad &#123; [super viewDidLoad]; BAOPerson *p1 = [[BAOPerson alloc] init]; BAOPerson *p2 = [[BAOPerson alloc] init]; p1.age = 1; p1.age = 2; p2.age = 2; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil]; [self printMethods: object_getClass(p2)]; [self printMethods: object_getClass(p1)]; p1.age = 10; [p1 removeObserver:self forKeyPath:@&quot;age&quot;];&#125;- (void)printMethods:(Class)cls &#123; unsigned int count; Method *methods = class_copyMethodList(cls, &amp;count); NSMutableString *methodNames = [NSMutableString string]; [methodNames appendFormat:@&quot;%@ - &quot;, cls]; for (int i = 0 ; i &lt; count; i++) &#123; Method method = methods[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); [methodNames appendString:methodName]; [methodNames appendString:@&quot; &quot;]; &#125; NSLog(@&quot;%@&quot;, methodNames); free(methods);&#125; 上述代码的打印结果如下： 可以发现，NSKVONotifying_BAOPerson 中有 4 个对象方法，分别是:1234setAge:classdealloc_isKVOA NSKVONotifying_BAOPerson 重写 class 方法是为了隐藏 NSKVONotifying_BAOPerson 不被外界看到。我们在 p1 添加 KVO 之后，分别打印 p1 和 p2 对象的 class，可以发现它们都返回 BAOPerson。 12NSLog(@&quot;%@, %@&quot;, [p1 class], [p2 class]);// 打印结果 BAOPerson, BAOPerson 综上，我们可以画出 NSKVONotifying_BAOPerson 的内部结构及方法调用顺序。 验证 didChangeValueForKey: 内部调用 observeValueForKeyPath:ofObject:change:context: 方法在 BAOPerson 类中重写 willChangeValueForKey: 和 didChangeValueForKey: 方法，模拟它们的实现。 1234567891011121314151617- (void)setAge:(NSInteger)age&#123; NSLog(@&quot;override setAge&quot;); _age = age;&#125;- (void)willChangeValueForKey:(NSString *)key &#123; NSLog(@&quot;willChangeValueForKey: - begin&quot;); [super willChangeValueForKey:key]; NSLog(@&quot;willChangeValueForKey: - end&quot;);&#125;- (void)didChangeValueForKey:(NSString *)key &#123; NSLog(@&quot;didChangeValueForKey: - begin&quot;); [super didChangeValueForKey:key]; NSLog(@&quot;didChangeValueForKey: - end&quot;);&#125; 通过运行上述代码，可以确定是在 didChangeValueForKey: 方法内部调用了监听者的 observeValueForKeyPath:ofObject:change:context: 方法。 根据上述原理，可以通过调用 willChangeValueForKey: 和 didChangeValueForKey: 来手动触发 KVO。 参考 iOS底层原理总结 - 探寻KVO本质]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD 原理详解]]></title>
    <url>%2F2018%2F12%2F01%2Fgcd-introduce%2F</url>
    <content type="text"><![CDATA[GCD 简介GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。 GCD 基本概念GCD 主要包含两个核心概念：任务 和 队列。 任务任务：即要在线程中执行的那段代码。GCD 将任务定义在 block 中。 任务的执行主要有两种方式：同步执行（sync） 和 异步执行（async）。两者的主要区别是：是否等待队列中的任务执行结束，是否具备开启新线程的能力。因此，根据任务的执行方式可以将任务分成两种类型： 同步任务（sync） 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。 只能在当前线程中执行任务，不具备开启新线程的能力。 异步任务（async） 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。 可以在新的线程中执行任务，具备开启新线程的能力。 注意： 异步任务（async） 虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。 队列队列（Dispatch Queue）：即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构如下图所示： 在 GCD 中有两种队列：串行队列 和 并发队列。两者的主要区别是：执行顺序不同，开启线程数不同。 串行队列 每次只有一个任务被执行。（只开启一个线程，一个任务执行完毕后，在执行下一个任务） 并发队列 允许多个任务（同时）执行。（可以开启多个线程，并同时执行任务） 注意：并发队列 的并发功能只有在异步（dispatch_async）函数下才有效。 GCD 使用方法GCD 的使用主要包含两个步骤： 创建一个队列（串行队列或并发队列） 将任务追加到任务的等待队列中，然后系统会根据任务类型执行任务（同步执行或异步执行） 队列的创建/获取123dispatch_queue_tdispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr) 参数说明： label：表示队列的唯一标识符，用于 DEBUG，可为空。 attr：表示队列的类型。DISPATCH_QUEUE_SERIAL 表示串行队列；DISPATCH_QUEUE_CONCURRENT 表示并发队列。 1234// 串行队列的创建方法dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);// 并发队列的创建方法dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); 对于串行队列，GCD 提供了一种特殊的串行队列：主队列（Main Dispatch Queue）。 所有放在主队列的任务，都会在主线程执行。 可使用 dispatch_get_main_queue() 获取主队列。12// 主队列的获取方法dispatch_queue_t queue = dispatch_get_main_queue(); 对于并发队列，GCD 默认提供了 全局并发队列（Global Dispatch Queue）。 可使用 dispatch_get_global_queue 获取全局并发队列。12// 全局并发队列的获取方法dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); GCD 提供了 4 个 全局并发队列，分别对应不同的优先级。 DISPATCH_QUEUE_PRIORITY_HIGH DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW DISPATCH_QUEUE_PRIORITY_BACKGROUND：后台队列 任务的创建GCD 提供了同步执行任务的创建方法 dispatch_sync 和异步执行任务创建方法 dispatch_async。 12345678// 同步任务创建方法dispatch_sync(queue, ^&#123; // 这里放同步执行任务代码&#125;);// 异步任务创建方法dispatch_async(queue, ^&#123; // 这里放异步执行任务代码&#125;); GCD 使用组合GCD 有两种队列（串行队列/并发队列），两种任务（同步任务/异步任务），可以得到 4 种不同的使用组合。 同步任务 + 并发队列 异步任务 + 并发队列 同步任务 + 串行队列 异步任务 + 串行队列 实际上，前文还提到两种特殊的队列：全局并发队列、主队列。全局并发队列可作为普通并发队列使用。但是主队列比较特殊，因此又得到 2 种组合： 同步任务 + 主队列 异步任务 + 主队列 同步执行 + 并发队列123456789101112131415161718192021222324252627282930313233343536/** * 同步任务 + 并发队列 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。 */- (void)syncConcurrent &#123; NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;syncConcurrent---end&quot;);&#125; 上图所示为 同步任务 + 并发队列 的工作原理。 syncConcurrent 被添加至主队列中，在主线程执行。 同步任务被添加至并行队列，并行队列允许多任务同时执行，但由于加入的队列是同步任务，不会开启新线程，在主线程执行。 syncConcurrent 会被同步任务阻塞。 执行结果：123456789currentThread---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;syncConcurrent---begin1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;syncConcurrent---end 异步任务 + 并发队列123456789101112131415161718192021222324252627282930313233343536/** * 异步任务 + 并发队列 * 特点：可以开启多个线程，任务交替（同时）执行。 */- (void)asyncConcurrent &#123; NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncConcurrent---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;asyncConcurrent---end&quot;);&#125; 上图所示为 异步任务 + 并行队列 的工作原理。 asyncConcurrent 被添加至主队列中，在主线程执行。 异步任务被添加至并行队列，并行队列允许多任务同时执行，且异步任务可以开启新线程，因此每个异步任务都能启动一个独立的线程执行。 asyncConcurrent 不会被异步任务阻塞。 执行结果123456789currentThread---&lt;NSThread: 0x600003e6d580&gt;&#123;number = 1, name = main&#125;asyncConcurrent---beginasyncConcurrent---end1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125; 同步任务 + 串行队列12345678910111213141516171819202122232425262728293031323334/** * 同步任务 + 串行队列 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。 */- (void)syncSerial &#123; NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;syncSerial---end&quot;);&#125; 上图所示为 同步任务 + 串行队列 的工作原理。 syncSerial 被添加至主队列中，在主线程执行。 同步任务被添加至串行队列，串行队列不允许多任务同时执行，因此同步任务在当前线程执行（主线程）。 syncSerial 会被同步任务阻塞。 异步任务 + 串行队列12345678910111213141516171819202122232425262728293031323334/** * 异步任务 + 串行队列 * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。 */- (void)asyncSerial &#123; NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncSerial---begin&quot;); dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;asyncSerial---end&quot;);&#125; 上图所示为 异步任务 + 串行队列 的工作原理。 asyncSerial 被添加至主队列中，在主线程执行。 异步任务被添加至串行队列，异步任务能开启新线程，但是串行队列不允许多任务，所以只能开启一条新线程。 asyncSerial 不会被异步任务阻塞。 执行结果123456789currentThread---&lt;NSThread: 0x600001ef5d00&gt;&#123;number = 1, name = main&#125;asyncSerial---beginasyncSerial---end1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125; 同步任务 + 主队列12345678910111213141516171819202122232425262728293031323334353637/** * 同步任务 + 主队列 * 特点(主线程调用)：互等卡主不执行。 * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。 */- (void)syncMain &#123; NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]); // 打印当前线程 NSLog(@&quot;syncMain---begin&quot;); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;syncMain---end&quot;);&#125; 上图所示为 同步任务 + 主队列 的工作原理。 syncMain 被添加至主队列中，在主线程执行。 同步任务被添加至主队列，同步任务不会开启新线程，且主队列（属于串行队列）中的任务只能在主线程执行。 syncMain 会被同步任务阻塞。但是需要注意的是 syncMain 和同步任务均在主队列中，同步任务需要等待 syncMain 执行完毕，因此产生死锁。 执行结果1崩溃 对于这种情况，可以将 syncMain 放置新线程执行以避免产生死锁：1[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil]; 异步任务 + 主队列123456789101112131415161718192021222324252627282930313233343536/** * 异步任务 + 主队列 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务 */- (void)asyncMain &#123; NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]); // 打印当前线程 NSLog(@&quot;asyncMain---begin&quot;); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@&quot;asyncMain---end&quot;);&#125; 上图所示为 异步任务 + 主队列 的工作原理。 asyncMain 被添加至主队列中，在主线程执行。 异步任务被添加至主队列，异步任务能开启新线程，但是主队列（属于串行队列）中的任务只能在主线程执行。 asyncMain 不会被异步任务阻塞。 执行结果123456789currentThread---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;asyncMain---beginasyncMain---end1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125; GCD 应用线程间通信123456789101112131415161718192021222324/** * 线程间通信 */- (void)communication &#123; // 获取全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; // 异步追加任务 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; // 回到主线程 dispatch_async(mainQueue, ^&#123; // 追加在主线程中执行的任务 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;); &#125;);&#125; 上图所示为线程间通信的工作原理。 communication 被添加至主队列中，在主线程执行。 异步任务被添加至全局队列（并行队列），异步任务能开启新线程，因此异步任务在新线程执行。 communication 不会被异步任务阻塞。 当异步任务执行完成后，再将一个异步任务添加至主队列，主队列中的任务都在主线程执行，所以该异步任务在主线程执行。从而达到线程间通信的目的。 执行结果1231---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x6000022ddd00&gt;&#123;number = 1, name = main&#125; 参考 iOS多线程：『GCD』详尽总结 细说GCD（Grand Central Dispatch）如何用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 关联对象与 Method Swizzling]]></title>
    <url>%2F2018%2F11%2F23%2Foc-associate-object-and-method-swizzling%2F</url>
    <content type="text"><![CDATA[关联对象关联对象，顾名思义，即通过唯一键（key）连接（关联）至某个类的实例上的对象。 那么什么时候会用到关联对象呢？ 比如，我们需要对内置类 NSArray 添加一个属性（不使用继承）。如何解决？分类似乎只能添加方法。当我们了解关联对象后，就可以轻松实现。 关联对象基础设置关联对象1void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) 参数说明： object: 与谁关联，通常是 self key: 唯一键，在获取值时通过该键获取，通常是使用 static const void * 来声明 value: 关联所设置的值 policy: 内存管理策略 内存管理策略1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123; OBJC_ASSOCIATION_ASSIGN = 0, // 表示弱引用关联，通常是基本数据类型 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 表示强引用关联对象，是线程安全的 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 表示关联对象copy，是线程安全的 OBJC_ASSOCIATION_RETAIN = 01401, // 表示强引用关联对象，不是线程安全的 OBJC_ASSOCIATION_COPY = 01403 // 表示关联对象copy，不是线程安全的&#125;; 当对象释放时，会根据设置关联对象时采用的策略来决定是否释放关联对象。当策略为 RETAIN/COPY 时，释放关联对象。当策略为 ASSIGN 时，不释放关联对象。 获取关联对象1id objc_getAssociatedObject(id object, const void *key) 参数说明： object: 与谁关联，通常是传 self，在设置关联时所指定的与哪个对象关联的那个对象 key: 唯一键，在设置关联值所指定的键 取消关联对象1void objc_removeAssociatedObjects(id object) 取消对象的所有关联对象。如果要取消指定的关联对象，可使用 setAssociatedObject 设置为 nil 来实现。 关联对象应用给 UIViewController 添加一个是否需要登录的属性。12345@interface UIViewController (Extension)@property (nonatomic, assign) BOOL needToLogin;@end 123456789static const char *ViewControllerNeedToLoginKey = &quot;ViewControllerNeedToLoginKey&quot;;- (void)setNeedToLogin:(BOOL)needToLogin &#123; objc_setAssociatedObject(self, ViewControllerNeedToLoginKey, @(needToLogin), OBJC_ASSOCIATION_ASSIGN);&#125;- (BOOL)needToLogin &#123; return [objc_getAssociatedObject(self, ViewControllerNeedToLoginKey) boolValue];&#125; Method SwizzlingMethod Swizzling，顾名思义，就是将两个方法的实现交换。 那么什么时候会用到 Method Swizzling 呢？ 比如，在开发中，我们可能会遇到系统提供的 API 不能满足实际需求。我们希望能够修改它以达到期望的效果。 Method Swizzling 原理Method Swizzling 的实现充分利用了 Objective-C runtime 动态绑定机制。 在 Objective-C 中调用方法，其实是向一个对象发送消息，而查找消息的唯一依据是方法名 selector。每个类都有一个方法列表 objc_method_list，存放着其所有的方法 objc_method。 1234567typedef struct objc_method *Methodstruct objc_method&#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; 每个方法 objc_method 保存了方法名（SEL）和方法实现（IMP）的映射关系。Method Swizzling 其实就是重置了 SEL 和 IMP 的映射关系。如下图所示： Method Swizzling 基础获取方法1Method _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name) 参数说明： cls: 目标类 name: 方法名 获取方法实现1IMP _Nonnull class_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name) 添加方法1BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 参数说明： cls: 目标类 name: 要添加方法的方法名 imp: 要添加方法的方法实现 types: 方法实现的编码类型 替换方法1IMP _Nullable class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) 参数说明： cls: 目标类 name: 目标方法的方法名 imp: 方法的新方法实现 types: 方法实现的编码类型 交换方法实现1void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) 获取方法的编码类型1const char * _Nullable method_getTypeEncoding(Method _Nonnull m) Method Swizzling 应用通过分类允许 NSObject 对任意两个方法进行 Method Swizzling。 123456@interface NSObject (Swizzle)+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;@end 123456789101112131415161718192021222324@implementation NSObject (Swizzle)+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123; Method originalMethod = class_getInstanceMethod(self, originalSEL); if (originalMethod == nil) &#123; return NO; &#125; Method targetMethod = class_getInstanceMethod(self, targetSEL); if (targetMethod == nil) &#123; return NO; &#125; class_addMethod(self, originalSEL, class_getMethodImplementation(self, originalSEL), method_getTypeEncoding(originalMethod)); class_addMethod(self, targetSEL, class_getMethodImplementation(self, targetSEL), method_getTypeEncoding(targetMethod)); method_exchangeImplementations(class_getInstanceMethod(self, originalSEL), class_getInstanceMethod(self, targetSEL)); return YES;&#125;+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123; Class metaClass = object_getClass((id)self); return [metaClass swizzleMethod:originalSEL withMethod:targetSEL error:error];&#125; 参考 iOS runtime实战应用：Method Swizzling iOS runtime实战应用：关联对象 iOS runtime实战应用：Method Swizzling iOS运行时(Runtime)详解+Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>关联对象</tag>
        <tag>Method Swizzling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯·圣彼得堡之旅]]></title>
    <url>%2F2018%2F11%2F03%2Fst-petersburg%2F</url>
    <content type="text"><![CDATA[盼了一年，终于盼来了公司的年度旅行。经过两轮的投票角逐，圣彼得堡众望所归！旅行时间计划是 10 月 27 日~ 11 月1 日，总共 6 天。我们此次行程总共 29 人，走团签，使用公司的旅行基金，每个人额外补贴 1020 元。 出发前两天，我花了两个晚上做了一下圣彼得堡的旅行攻略。首先，定位各个推荐景点和餐厅的位置，做到心里有点逼数。 然后，综合日期、天气、距离、开/闭馆等情况（圣彼得堡有不少景点会周期性地选择闭馆），做了一个大致的行程计划。 Day 1（周六）前一天周五，我们照常上班，部分人（包括我）选择在公司一直待到凌晨，然后一起打车去机场。服务器一帮人去附近的网吧开黑，客户端则在公司打升级，玩任天堂游戏。我在 B 站上看了几个关于圣彼得堡的纪录片。对我来说，旅行中很大一部分乐趣是源自于旅行前的准备工作。 北京时间凌晨五点，我们从 T3 航站楼启程飞往新西伯利亚。 经过四个半小时的飞行，飞越了数千公里的冰川，最终抵达新西伯利亚。降落前，从新西伯利亚上空俯瞰整个城市，第一感觉便是衰败。这与我的预期完全不符，心里难免有一些失落。 在新西伯利亚机场转机等待了近2个小时，我们踏上了飞往圣彼得堡的行程。经历四个半小时，飞机成功降落于圣彼得堡普尔科沃机场，机舱里响起来热烈的掌声。 导游和大巴早已在机场等候多时，安置好行李后，我们从机场出发。沿着机场高速，经过跨海大桥，最终抵达我们位于瓦西里岛上的 Park inn 酒店。安排完入住后已经差不多下午2点多了。 在客房稍事休息，洗漱一下，我们（@大龙哥，@邱老师，@张成）便出门去逛附近的超市。买了烤鸡、黄瓜、香蕉、面包、啤酒、果汁，然后便是回酒店嗨。 来圣彼得堡之前，我听说酒店有游泳池。于是晚上一闲下来，便在酒店一楼大厅瞎转，找游泳池。大厅绕了一圈，一对青年毛子情侣看到了我，小哥立马过来跟我尬聊了起来。小哥用带卷舌的英语，我用蹩脚的 Chinglish。聊了二十分钟，我还是没明白他到底想表达什么。。。 Day 2（周日）一大早起来，打开窗帘，外面已然是白茫茫一片。天气与预期一样，那么计划也是一样。今天行程是冬宫。 来圣彼得堡之前，我们便以在飞猪上购买了电子票。冬宫早上10点半开放，我们分了好几拨，早早便抵达了冬宫快速通道门口。 我们差不多画了5个小时的时间走马观花地逛了一遍冬宫。一楼是古埃及相关的展厅，我没怎么逛。二楼是沙俄以及西方中世纪的一些展品。三楼主要东方的一些展品。二楼的展品尤为绚烂，其中包括两幅达芬奇的真迹（世界仅存14副真迹）。果然不愧为世界四大博物馆，不禁感慨如果圆明园未毁，也许可以与其相媲美。 逛完冬宫差不多已经下午三点半了，早已饥渴难耐，我们打车去附近一家小餐厅Varvara。 简餐过后，我们沿着涅瓦大街闲逛，欣赏一下沿途的风景。 Day3（周一）今天计划的第一站是圣以撒大教堂。刚刚抵达圣以撒大教堂，便遇到一群当地的小孩，冲着我们喊“你好”。尴尬的是我们居然不知道“你好”用俄语怎么说，只能也挥手喊着“你好”予以回应。 圣以撒大教堂可以允许游客登顶观光，俯瞰整个圣彼得堡。 与圣以撒大教堂合完影之后，我们便步行向北前往十二月党人广场，广场的中央是彼得大帝青铜骑士像。 在广场逗留了一会儿，大家分头行动，我们（@邱老师，@大龙哥，@刘杨）决定去救世主滴血大教堂。抵达滴血大教堂，有一些一行，教堂的洋葱头正在维修，据说从去年至今一直在维修。不过教堂的内饰真的是美轮美奂，所有的壁画都是用指甲大小的马赛克拼接而成的。 救世主滴血大教堂参观完毕，我们（@吴迪，@海侠，@大龙哥，@邱老师，@刘杨）来到了涅瓦大街吃午餐。 吃完饭，我们在旁边的纪念品店里逛了一会儿，然后他们准备去商场购物。而我则打算去马路对面的喀山大教堂去拍照。 拍完照，我便独自向我们约定的商场步行而去，与大家汇合。 Day4（周二）雪后第一天尤其寒冷，今天的计划则是去彼得保罗要塞观光。彼得堡罗要塞其实就是一个小岛，岛上有监狱（曾关押过高尔基）、教堂（埋葬了历代沙皇）、博物馆，我们也是挨个儿参观了一遍。 差不多下午一点参观完各个景点，我们在一个小博物馆里逗留了一会儿，然后决定去岛上的一家推荐餐厅。餐厅位于小岛的西边，迎着涅瓦河。 餐后，大家决定一起去看阿芙乐尔号巡洋舰。在路上顶着寒风大概走了半个小时终于到了阿芙乐尔号巡洋舰的地址。参观的总体感觉是比较坑，门票大约70元人民币，比冬宫还贵。里面只有一个小小的博物馆而已。 Day5（周三）昨天在去往阿芙乐尔号的路上简直被吹成了傻逼，对于今天去叶卡捷琳娜宫的计划我有些犹豫。“既然都来了，就去看看吧”这样的念头促成我又做了一次傻逼的决定。叶卡捷琳娜宫只在下午一点后对散客开放，并且每15分钟放入20来人。我们上午到叶宫，在前面的花园里逛了一圈。差不多下午一点，到叶宫入口排队。寒风中吹了近两个小时才进入叶宫。 说实话，叶宫真心无法与冬宫相比，除了琥珀宫，里面基本都是些宴会大厅。另外，加上这几天的行程，基本已经属于审美疲劳状态。 Day5（周四）早上10:20在酒店大厅集合去机场。第一次来俄罗斯，并且是有如此浓厚艺术气息的圣彼得堡，虽然旅程很短暂，但是内心很满足。 （完）]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>自由行</tag>
        <tag>俄罗斯</tag>
        <tag>圣彼得堡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C Runtime 消息传递与转发]]></title>
    <url>%2F2018%2F10%2F20%2Fios-runtime-message-sending-and-forwarding%2F</url>
    <content type="text"><![CDATA[概述Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，在 C 语言的基础上实现了面向对象的功能。在 runtime 中，对象用结构体表示，方法用函数表示。 C 语言是一门静态语言，其在编译时决定调用哪个函数。而 Objective-C 则是一门动态语言，其在编译时不能决定最终执行时调用哪个函数（Objective-C 中函数调用称为消息传递）。Objective-C 的这种动态绑定机制正是通过 runtime 这样一个中间层实现的。 为了分析 runtime 是如何进行动态绑定，我们首先需要了解一下 Objective-C 中类与对象等基本结构在 C 语言层面是如何实现的。 数据结构Objective-C 类Objective-C 类是由 Class 类型表示的，它本质上是一个指向 objc_class 结构体的指针。如下所示为 objc/runtime.h 中关于类的定义：1234567891011121314151617typedef struct object_class *Classstruct object_class&#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list *methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ Objective-C 对象Objective-C 对象是由 id 类型表示的，它本质上是一个指向 objc_object 结构体的指针。如下所示为 objc/objc.h 中关于对象的定义：12345typedef struct objc_object *id;struct objc_object&#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; objc_object 结构体中只有一个成员，即指向其类的 isa 指针。当向一个 Objective-C 对象发送消息时，runtime 会根据实例对象的 isa 指针找到其所属的类。Runtime 会在类的方法列表以及父类的方法列表中去寻找与消息对应的 selector 指向的方法，找到后即运行该方法。 Objective-C 元类（meta class）meta-class 是一个类对象的类。在 Objective-C 中，所有的类本身也是一个对象。事实上，在很多原型编程语言也采用这种“万物皆对象”的设计思想，如：Io。 通过向该对象发送消息，即可实现对类方法的调用。前提是类的 isa 指针必须指向一个包含这些类方法的 objc_class 结构体。meta-class 中存储着一个类的所有类方法。所以，类对象的 isa 指针指向的就是 meta-class。 当向一个对象发送消息时，runtime 会在这个对象所属的类的方法列表中查找方法。 当向一个类发送消息时，runtime 会在这个类的 meta-class 的方法列表中查找。 思考一下，meta-class 也是一个类，也可以向它发送一个消息，那么它的 isa 又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C 的设计者让所有的 meta-class 的 isa 指向基类的 meta-class，以此作为它们的所属类。 下图所示，为 Objective-C 对象在内存中的引用关系图。 Objective-C 方法方法实际上是一个指向 objc_method 结构体的指针。如下所示为 objc/runtime.h 中关于方法的定义：1234567typedef struct objc_method *Methodstruct objc_method&#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; 结构体中包含成员 SEL 和 IMP，两者将方法的名字与实现进行了绑定。通过 SEL，可以找到对应的 IMP，从而调用方法的具体实现。 SELSEL 又称选择器，是一个指向 objc_selector 结构体的指针。 1typedef struct objc_selector *SEL; 方法的 selector 用于表示运行时方法的名字。Objective-C 在编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ Int 类型的地址），即 SEL。 由于一个类的方法列表中不能存在两个相同的 SEL，所以 Objective-C 不支持重载。但是不同类之间可以存在相同的 SEL，因为不同类的实例对象执行相同的 selector 时，会在各自的方法列表中去根据 selector 去寻找自己对应的 IMP。 通过下面三种方法可以获取 SEL： sel_registerName 函数 Objective-C 编译器提供的 @selector() 方法 NSSeletorFromString() 方法 IMPIMP 本质上就是一个函数指针，指向方法实现的地址。 1typedef id (*IMP)(id, SEL,...); 参数说明 id：指向 self 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针） SEL：方法选择器 ...：方法的参数列表 SEL 与 IMP 的关系类似于哈希表中 key 与 value 的关系。采用这种哈希映射的方式可以加快方法的查找速度。 消息传递（方法调用）在 Objective-C 中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式 [receiver message] 转化为一个消息函数的调用，即 objc_msgSend。这个函数将消息接收者和方法名作为主要参数，如下所示： 12objc_msgSend(receiver, selector) // 不带参数objc_msgSend(receiver, selector, arg1, arg2,...) // 带参数 objc_msgSend 通过以下几个步骤实现了动态绑定机制。 首先，获取 selector 指向的方法实现。由于相同的方法可能在不同的类中有着不同的实现，因此根据 receiver 所属的类进行判断。 其次，传递 receiver 对象、方法指定的参数来调用方法实现。 最后，返回方法实现的返回值。 消息传递的关键在于前文讨论过的 objc_class 结构体，其有两个关键的字段： isa：指向父类的指针 methodLists: 类的方法分发表（dispatch table） 当创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 isa 指针也会被初始化，让对象可以访问类及类的继承链。 下图所示为消息传递过程的示意图。 当消息传递给一个对象时，首先从运行时系统缓存 objc_cache 中进行查找。如果找到，则执行。否则，继续执行下面步骤。 objc_msgSend 通过对象的 isa 指针获取到类的结构体，然后在方法分发表 methodLists 中查找方法的 selector。如果未找到，将沿着类的 isa 找到其父类，并在父类的分发表 methodLists 中继续查找。 以此类推，一直沿着类的继承链追溯至 NSObject 类。一旦找到 selector，传入相应的参数来执行方法的具体实现，并将该方法加入缓存 objc_cache 。如果最后仍然没有找到 selector，则会进入消息转发流程（下文将进行介绍）。 消息转发当一个对象能接收一个消息时，会走正常的消息传递流程。当一个对象无法接收某一消息时，会发生什么呢？默认情况下，如果以 [object message] 的形式调用方法，如果 object 无法响应 message 消息时，编译器会报错。如果是以 performSeletor: 的形式调用方法，则需要等到运行时才能确定 object 是否能接收 message 消息。如果不能，则程序崩溃。 对于后者，当不确定一个对象是否能接收某个消息时，可以调用 respondsToSelector: 来进行判断。 123if ([self respondsToSelector:@selector(method)]) &#123; [self performSelector:@selector(method)];&#125; 事实上，当一个对象无法接收某一消息时，就会启动所谓“消息转发（message forwarding）”机制。通过消息转发机制，我们可以告诉对象如何处理未知的消息。 消息转发机制大致可分为三个步骤： 动态方法解析（Dynamic Method Resolution） 备用接收者 完整消息转发 下图所示为消息转发过程的示意图。 动态消息解析对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveClassMethod: 或实例方法 +resolveInstanceMethod:。 在这两个方法中，我们可以为未知消息新增一个“处理方法”，通过运行时 class_addMethod 函数动态添加到类中。比如：1234567891011void dynamicMethodIMP(id self, SEL _cmd) &#123; // 方法实现&#125;+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125; 这种方案更多的是为了实现@dynamic属性。 备用接收者如果在上一步无法处理消息，则 runtime 会继续调用 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。 如果一个对象实现了这个方法，并返回一个非 nil（也不能是 self） 的对象，则这个对象会称为消息的新接收者，消息会被分发到这个对象。比如： 1234567- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSString * selString = NSStringFromSelector(aSelector); if ([selString isEqualToString:@&quot;walk&quot;]) &#123; return self.otherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。 完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil，则说明消息无法处理并报错 unrecognized selector sent to instance。123456- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123; return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector: aSelector];&#125; 如果返回 methodSignature，则进入 forwardInvocation。对象会创建一个表示消息的 NSInvocation 对象，把与尚未处理的消息有关的全部细节都封装在 anInvocation 中，包括 selector，target，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 unrecognized selector sent to instance。12345- (void)forwardInvovation:(NSInvocation)anInvocation &#123; [anInvocation invokeWithTarget:_helper]; [anInvocation setSelector:@selector(run)]; [anInvocation invokeWithTarget:self];&#125; 可以利用备用接受者和完整消息转发实现对接受消息对象的转移，可以实现“多重继承”的效果。 参考 Objective-C Runtime Programming Guide Objective-C Runtime · 笔试面试知识整理 iOS运行时(Runtime)详解+Demo iOS内功篇：runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Run Loop 原理详解]]></title>
    <url>%2F2018%2F10%2F06%2Funderstand-ios-runloop%2F</url>
    <content type="text"><![CDATA[Event Loop通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或框架中，需要实现一种这样机制：线程能够随时处理事件或消息，并且不会在执行完成后退出。这种机制称为 Event Loop，其一般逻辑吐下所示： 1234567function main initialize() while message != quit message := get_next_message() process_message(message) end whileend function Event Loop 在很多系统或框架中都有对应的实现，如 Node.js 的事件处理，Windows 程序的消息循环，OSX/iOS 中的 RunLoop。实现这种机制的关键在于：如何管理事件/消息，如何让线程在没有处理任务时休眠以避免资源占用，如何在事件/消息到来时唤醒。 Run LoopRun Loop 是 OSX/iOS 平台下对 Event Loop 机制的一种实现。当没有事件/消息时，Run Loop 进入休眠状态。当有事件/消息时，Run Loop 调用对应的 Handler 进行处理。如下图所示为 Run Loop 的工作模式示意图。 由上图可知，Run Loop 从 Input sources 和 Timer sources 接收事件，然后在线程中处理。 Run Loop 本质上就是一个对象，其管理需要处理的事件/消息，并提供一个入口函数来执行上面 Event Loop 的逻辑。线程执行该函数后，会一直处于其内部的“接受消息-&gt;等待-&gt;处理”循环中，直到循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 中提供了两种 Run Loop 的实现： CFRunLoopRef：CoreFoundation 框架对于 Run Loop 的实现，其提供纯 C 函数的 API（线程安全）。 NSRunLoop：基于 CFRunLoopRef 的封装，其提供面向对象的 API（非线程安全）。 Run Loop 与线程Run Loop 和线程是一一对应的。每个线程（包括主线程）都有一个对应的 Run Loop 对象。Run Loop 对象的创建发生在第一次获取时（如果不主动获取，它一直都不会被创建）；Run Loop 对象的销毁发生在线程结束时。 用户无法创建 Run Loop 对象，但可以获取系统提供的 Run Loop 对象。注意：只能在一个线程的内部获取其 Run Loop 对象，主线程不受限制。 关于 Run Loop 的启动，主线程的 Run Loop 在应用启动时自动启动，其他线程的 Run Loop 默认不会自动启动，需手动启动。 Run Loop Source从上面 Run Loop 工作模式示意图中可知，Run Loop 有两种接收事件的渠道：Input Source、Timer Source。 Input SourceInput Source 可分为三类： Custom Input Sources（Source0）：用户自定义的事件，不会主动触发事件，也不会主动唤醒 Run Loop 的线程。 Port-Based Sources（Source1）：系统底层的 Port 事件（Mac Port），例如 CFSocketRef。一般用于通过内核和其他线程相互发送消息，应用层很少使用。这种 Source 可以主动唤醒 Run Loop 的线程。 Timer SourceTimer Source 即定时器事件。 Run Loop ObserverRun Loop 通过监控 Source 来决定是否执行处理程序。而 Runloop Observer 则监控 Runloop 本身的状态。 Runloop Observer 可监控的 runloop 事件如下所示： 123456789/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入 Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出 Loop&#125;; Run Loop ModeRun Loop Mode 即 Run Loop 工作模式。苹果文档中定义了 5 种 Mode： NSDefaultRunLoopMode NSConnectionReplyMode NSModalPanelRunLoopMode NSEventTrackingRunLoopMode NSRunLoopCommonModes iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。 一个 Run Loop 可以包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。Run Loop 在某个时刻只能工作在一个 Mode 下，处理该 Mode 中的 Source/Timer/Observer。如果需要切换 Mode，只能退出 Run Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，使其互不影响。 如下所示为 Run Loop Mode 和 Run Loop 的部分源码定义。123456789101112131415161718struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;;typedef struct __CFRunLoop * CFRunLoopRef; struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; Source/Timer/Observer 被统称为 Mode Item，一个 Item 可以被同时加入多个 Mode。但一个 Item 被重复加入同一个 Mode 时是不会有效果的。如果一个 Mode 中一个 Item 都没有，则 Run Loop 会直接退出，不进入“接受消息-&gt;等待-&gt;处理”循环。 Common Mode一个 Mode 可以将自己标记为 Common（通过将其 Mode Name 添加到 Run Loop 的 _commonModes 中）。每当 Run Loop 内容发生变化，Run Loop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 Common 标记的所有 Mode 里。 举例主线程的 Run Loop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为 Common。kCFRunLoopDefaultMode 是 App 平时所处的状态，UITrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当创建一个 Timer 并加到 kCFRunLoopDefaultMode 时，Timer 会得到重复回调，但此时滑动 TableView 时，Run Loop 会将 Mode 切换为 UITrackingRunLoopMode。这是系统为了保持滑动流畅而做出的 Mode 切换。但这会导致 Timer 不被回调。 为了让 Timer 能在这两种 Mode 下都能得到回调，有 3 种解决方案： 将 Timer 分别加入两种 Mode 将 Timer 加入 Run Loop 的 _commonModeItems 中。因为，Run Loop 发生变化时，Run Loop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 Common 标记的所有 Mode 里。 在另一个线程执行和处理 Timer 事件，然后在主线程更新 UI。 Run Loop 工作流程下图所示为 Run Loop 工作流程示意图。 如下所示为 Run Loop 工作流程的核心代码整理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// ? 一个基于 port 的Source 的事件。 /// ? 一个 Timer 到时间了 /// ? RunLoop 自身的超时时间到了 /// ? 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 其内部是一个 do-while 循环。当调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 123456789/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; /// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; 基于 Run Loop 的系统功能如下所示为 App 启动后 Run Loop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as &apos;common mode items&apos; */ &#125;, sources1 = &#123; /* same as &apos;common mode items&apos; */ &#125;, observers = &#123; /* same as &apos;common mode items&apos; */ &#125;, timers = &#123; /* same as &apos;common mode items&apos; */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 根据 modes 成员的状态可知，系统默认注册了 5 个 Mode： kCFRunLoopDefaultMode：App 的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode：接收系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes：占位的 Mode，无实际作用。 AutoReleasePoolApp 启动后，系统在主线程 Run Loop 中注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监听了一个事件： kCFRunLoopEntry（即将进入 Loop）：调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证在其他所有回调之前创建。 第二个 Observer 监听了两个事件： kCFRunLoopBeforeWaiting（即将进入休眠）：调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧池并创建新池。 kCFRunLoopExit（即将退出 Loop）：调用 _objc_autoreleasePoolPop() 来释放自动释放池。其 order 是 2147483647，优先级最低，保证在其他所有回调之后释放。 事件回调、Timer 回调一般在主线程执行。这些回调会被 Run Loop 创建的 AutoreleasePool 所环绕，所以不会出现内存泄漏，开发者也不必显式创建自动释放池。 事件响应苹果注册了一个 Source1（Mach Port）用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键（锁屏/静音等）、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括：识别 UIGesture、处理屏幕旋转、发送给 UIWindow 等。在此回调中完成的事件包括：UIButton 点击、touchesBegin/Move/End/Cancel 事件等。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监听 kCFRunLoopBeforeWaiting（即将进入休眠）事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化（创建/销毁/状态改变）时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 kCFRunLoopBeforeWaiting（即将进入休眠） 和 kCFRunLoopExit（即将退出 Loop），回调执行的函数会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 定时器NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 Run Loop 后，Run Loop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20 这几个时间点。Run Loop为了节省资源，并不会在非常准确的时间点回调 Timer。Timer 有个属性叫做 Tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 参考 Run Loops 深入理解RunLoop RunLoop @autoreleasepool-内存的分配与释放]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Run Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 图像渲染原理]]></title>
    <url>%2F2018%2F09%2F25%2Fios-graphics-render-principle%2F</url>
    <content type="text"><![CDATA[通过 图形渲染原理 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。 图形渲染技术栈下图所示为 iOS App 的图形渲染技术栈，App 使用 Core Graphics、Core Animation、Core Image 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系。这些框架都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。 iOS 渲染框架UIKitUIKit 是 iOS 开发者最常用的框架，可以通过设置 UIKit 组件的布局以及相关属性来绘制界面。 事实上， UIKit 自身并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（UIView 继承自 UIResponder），事件响应的传递大体是经过逐层的 视图树 遍历实现的。 Core AnimationCore Animation 源自于 Layer Kit，动画只是 Core Animation 特性的冰山一角。 Core Animation 是一个复合引擎，其职责是 尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即 CALayer），这些图层会被存储在一个叫做图层树的体系之中。从本质上而言，CALayer 是用户所能在屏幕上看见的一切的基础。 Core GraphicsCore Graphics 基于 Quartz 高级绘图引擎，主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。 当开发者需要在 运行时创建图像 时，可以使用 Core Graphics 去绘制。与之相对的是 运行前创建图像，例如用 Photoshop 提前做好图片素材直接导入应用。相比之下，我们更需要 Core Graphics 去在运行时实时计算、绘制一系列图像帧来实现动画。 Core ImageCore Image 与 Core Graphics 恰恰相反，Core Graphics 用于在 运行时创建图像，而 Core Image 是用来处理 运行前创建的图像 的。Core Image 框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。 大部分情况下，Core Image 会在 GPU 中完成工作，但如果 GPU 忙，会使用 CPU 进行处理。 OpenGL ESOpenGL ES（OpenGL for Embedded Systems，简称 GLES），是 OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL 是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。 MetalMetal 类似于 OpenGL ES，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过 Metal，但其实所有开发者都在间接地使用 Metal。Core Animation、Core Image、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。 当在真机上调试 OpenGL 程序时，控制台会打印出启用 Metal 的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL 命令无缝桥接到 Metal 上，由 Metal 担任真正于硬件交互的工作。 UIView 与 CALayer 的关系在前面的 Core Animation 简介中提到 CALayer 事实上是用户所能在屏幕上看见的一切的基础。为什么 UIKit 中的视图能够呈现可视化内容？就是因为 UIKit 中的每一个 UI 视图控件其实内部都有一个关联的 CALayer，即 backing layer。 由于这种一一对应的关系，视图层级拥有 视图树 的树形结构，对应 CALayer 层级也拥有 图层树 的树形结构。 其中，视图的职责是 创建并管理 图层，以确保当子视图在层级关系中 添加或被移除 时，其关联的图层在图层树中也有相同的操作，即保证视图树和图层树在结构上的一致性。 那么为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？ 其原因在于要做 职责分离，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，对应 Mac OS X 有 AppKit 和 NSView 的原因。它们在功能上很相似，但是在实现上有着显著的区别。 实际上，这里并不是两个层级关系，而是四个。每一个都扮演着不同的角色。除了 视图树 和 图层树，还有 呈现树 和 渲染树。 CALayer那么为什么 CALayer 可以呈现可视化内容呢？因为 CALayer 基本等同于一个 纹理。纹理是 GPU 进行图像渲染的重要依据。 在 图形渲染原理 中提到纹理本质上就是一张图片，因此 CALayer 也包含一个 contents 属性指向一块缓存区，称为 backing store，可以存放位图（Bitmap）。iOS 中将该缓存区保存的图片称为 寄宿图。 图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成纹理），也支持直接使用纹理（图片）进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 手动绘制；另一种是 使用图片。 对此，iOS 中也有两种相应的实现方式： 使用图片：contents image 手动绘制：custom drawing Contents Image Contents Image 是指通过 CALayer 的 contents 属性来配置图片。然而，contents 属性的类型为 id。在这种情况下，可以给 contents 属性赋予任何值，app 仍可以编译通过。但是在实践中，如果 content 的值不是 CGImage ，得到的图层将是空白的。 既然如此，为什么要将 contents 的属性类型定义为 id 而非 CGImage。这是因为在 Mac OS 系统中，该属性对 CGImage 和 NSImage 类型的值都起作用，而在 iOS 系统中，该属性只对 CGImage 起作用。 本质上，contents 属性指向的一块缓存区域，称为 backing store，可以存放 bitmap 数据。 Custom DrawingCustom Drawing 是指使用 Core Graphics 直接绘制寄宿图。实际开发中，一般通过继承 UIView 并实现 -drawRect: 方法来自定义绘制。 虽然 -drawRect: 是一个 UIView 方法，但事实上都是底层的 CALayer 完成了重绘工作并保存了产生的图片。下图所示为 -drawRect: 绘制定义寄宿图的基本原理。 UIView 有一个关联图层，即 CALayer。 CALayer 有一个可选的 delegate 属性，实现了 CALayerDelegate 协议。UIView 作为 CALayer 的代理实现了 CALayerDelegae 协议。 当需要重绘时，即调用 -drawRect:，CALayer 请求其代理给予一个寄宿图来显示。 CALayer 首先会尝试调用 -displayLayer: 方法，此时代理可以直接设置 contents 属性。 1- (void)displayLayer:(CALayer *)layer; 如果代理没有实现 -displayLayer: 方法，CALayer 则会尝试调用 -drawLayer:inContext: 方法。在调用该方法前，CALayer 会创建一个空的寄宿图（尺寸由 bounds 和 contentScale 决定）和一个 Core Graphics 的绘制上下文，为绘制寄宿图做准备，作为 ctx 参数传入。 1- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx; 最后，由 Core Graphics 绘制生成的寄宿图会存入 backing store。 Core Animation 流水线通过前面的介绍，我们知道了 CALayer 的本质，那么它是如何调用 GPU 并显示可视化内容的呢？下面我们就需要介绍一下 Core Animation 流水线的工作原理。 事实上，app 本身并不负责渲染，渲染则是由一个独立的进程负责，即 Render Server 进程。 App 通过 IPC 将渲染任务及相关数据提交给 Render Server。Render Server 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。 Core Animation 流水线的详细过程如下： 首先，由 app 处理事件（Handle Events），如：用户的点击操作，在此过程中 app 可能需要更新 视图树，相应地，图层树 也会被更新。 其次，app 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 Render Server，即完成了一次 Commit Transaction 操作。 Render Server 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU GPU 则在物理层上完成了对图像的渲染。 最终，GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上。 对上述步骤进行串联，它们执行所消耗的时间远远超过 16.67 ms，因此为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式进行并行执行，如下图所示。 Commit Transaction在 Core Animation 流水线中，app 调用 Render Server 前的最后一步 Commit Transaction 其实可以细分为 4 个步骤： Layout Display Prepare Commit LayoutLayout 阶段主要进行视图构建，包括：LayoutSubviews 方法的重载，addSubview: 方法填充子视图等。 DisplayDisplay 阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的 drawRect: 方法可以自定义 UIView 的显示，其原理是在 drawRect: 方法内部绘制寄宿图，该过程使用 CPU 和内存。 PreparePrepare 阶段属于附加步骤，一般处理图像的解码和转换等操作。 CommitCommit 阶段主要将图层进行打包，并将它们发送至 Render Server。该过程会递归执行，因为图层和视图都是以树形结构存在。 动画渲染原理iOS 动画的渲染也是基于上述 Core Animation 流水线完成的。这里我们重点关注 app 与 Render Server 的执行流程。 日常开发中，如果不是特别复杂的动画，一般使用 UIView Animation 实现，iOS 将其处理过程分为如下三部阶段： Step 1：调用 animationWithDuration:animations: 方法 Step 2：在 Animation Block 中进行 Layout，Display，Prepare，Commit 等步骤。 Step 3：Render Server 根据 Animation 逐帧进行渲染。 参考 Getting Pixels onto the Screen，中文版（iOS 开发：绘制像素到屏幕） 深入理解 iOS Rendering Process iOS Core Animation: Advanced Techniques中文译本 关于drawRect iOS 绘图与动画原理剖析 WWDC 2014 Session 419: Advanced Graphics and Animations for iOS Apps 扩展阅读 离屏渲染优化详解：实例示范+性能测试 Mastering Offscreen Render Optimizing 2D Graphics and Animation Performance Polishing Your Interface Rotation Animations Core Animation Essentials Understanding UIKit Rendering iOS: Rendering the UI iOS 事件处理机制与图像渲染过程 iOS 动画篇：核心动画 GPU Framebuffer Memory: Understanding Tiling iOS 保持界面流畅的技巧 OpenGL ES 框架详细解析（八） —— OpenGL ES 设计指南 iOS 开发-视图渲染与性能优化 iOS 视图、动画渲染机制探究 iOS 事件处理机制与图像渲染过程 iOS界面渲染流程 界面渲染的整体流程 iOS图像处理之Core Graphics和OpenGL ES初见 WWDC 2012 Session 506: Optimizing 2D Graphics and Animations Performances WWDC 2011 Session 421: Core Animation Essentials WWDC 2011 Session 129: Practical Drawing for iOS Developers]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Core Animation Pipeline</tag>
        <tag>Render Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(7)——图形图像渲染原理]]></title>
    <url>%2F2018%2F08%2F26%2Fgraphics-rending-principle-gpu%2F</url>
    <content type="text"><![CDATA[最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。 本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识储备。 引言作为程序员，我们或多或少知道可视化应用程序都是由 CPU 和 GPU 协作执行的。那么我们就先来了解一下两者的基本概念： CPU（Central Processing Unit）：现代计算机的三大核心部分之一，作为整个系统的运算和控制单元。CPU 内部的流水线结构使其拥有一定程度的并行计算能力。 GPU（Graphics Processing Unit）：一种可进行绘图运算工作的专用微处理器。GPU 能够生成 2D/3D 的图形图像和视频，从而能够支持基于窗口的操作系统、图形用户界面、视频游戏、可视化图像应用和视频播放。GPU 具有非常强的并行计算能力。 这时候可能会产生一个问题：CPU 难道不能代替 GPU 来进行图形渲染吗？答案当然是肯定的，不过在看了下面这个视频就明白为什么要用 GPU 来进行图形渲染了。 GPU CPU 模拟绘图视频 使用 GPU 渲染图形的根本原因就是：速度。GPU 的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。 那么像素是如何绘制在屏幕上的？计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为 渲染。渲染过程中最常用的技术就是 光栅化。 关于光栅化的概念，以下图为例，假如有一道绿光与存储在内存中的一堆三角形中的某一个在三维空间坐标中存在相交的关系。那么这些处于相交位置的像素都会被绘制到屏幕上。当然这些三角形在三维空间中的前后关系也会以遮挡或部分遮挡的形式在屏幕上呈现出来。一句话总结：光栅化就是将数据转化成可见像素的过程。 GPU 则是执行转换过程的硬件部件。由于这个过程涉及到屏幕上的每一个像素，所以 GPU 被设计成了一个高度并行化的硬件部件。 下面，我们来简单了解一下 GPU 的历史。 GPU 历史GPU 还未出现前，PC 上的图形操作是由 视频图形阵列（VGA，Video Graphics Array） 控制器完成。VGA 控制器由连接到一定容量的DRAM上的存储控制器和显示产生器构成。 1997 年，VGA 控制器开始具备一些 3D 加速功能，包括用于 三角形生成、光栅化、纹理贴图 和 阴影。 2000 年，一个单片处图形处理器继承了传统高端工作站图形流水线的几乎每一个细节。因此诞生了一个新的术语 GPU 用来表示图形设备已经变成了一个处理器。 随着时间的推移，GPU 的可编程能力愈发强大，其作为可编程处理器取代了固定功能的专用逻辑，同时保持了基本的 3D 图形流水线组织。 近年来，GPU 增加了处理器指令和存储器硬件，以支持通用编程语言，并创立了一种编程环境，从而允许使用熟悉的语言（包括 C/C++）对 GPU 进行编程。 如今，GPU 及其相关驱动实现了图形处理中的 OpenGL 和 DirectX 模型，从而允许开发者能够轻易地操作硬件。OpenGL 严格来说并不是常规意义上的 API，而是一个第三方标准（由 khronos 组织制定并维护），其严格定义了每个函数该如何执行，以及它们的输出值。至于每个函数内部具体是如何实现的，则由 OpenGL 库的开发者自行决定。实际 OpenGL 库的开发者通常是显卡的生产商。DirectX 则是由 Microsoft 提供一套第三方标准。 GPU 图形渲染流水线GPU 图形渲染流水线的主要工作可以被划分为两个部分： 把 3D 坐标转换为 2D 坐标 把 2D 坐标转变为实际的有颜色的像素 GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示。 顶点着色器（Vertex Shader） 形状装配（Shape Assembly），又称 图元装配 几何着色器（Geometry Shader） 光栅化（Rasterization） 片段着色器（Fragment Shader） 测试与混合（Tests and Blending） 第一阶段，顶点着色器。该阶段的输入是 顶点数据（Vertex Data） 数据，比如以数组的形式传递 3 个 3D 坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器可以对顶点属性进行一些基本处理。 第二阶段，形状（图元）装配。该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图中则是一个三角形。图元（Primitive） 用于表示如何渲染顶点数据，如：点、线、三角形。 第三阶段，几何着色器。该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。 第四阶段，光栅化。该阶段会把图元映射为最终屏幕上相应的像素，生成片段。片段（Fragment） 是渲染一个像素所需要的所有数据。 第五阶段，片段着色器。该阶段首先会对输入的片段进行 裁切（Clipping）。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。 第六阶段，测试与混合。该阶段会检测片段的对应的深度值（z 坐标），判断这个像素位于其它物体的前面还是后面，决定是否应该丢弃。此外，该阶段还会检查 alpha 值（ alpha 值定义了一个物体的透明度），从而对物体进行混合。因此，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。 关于混合，GPU 采用如下公式进行计算，并得出最后的颜色。 1R = S + D * (1 - Sa) 关于公式的含义，假设有两个像素 S(source) 和 D(destination)，S 在 z 轴方向相对靠前（在上面），D 在 z 轴方向相对靠后（在下面），那么最终的颜色值就是 S（上面像素） 的颜色 + D（下面像素） 的颜色 * （1 - S（上面像素） 颜色的透明度）。 上述流水线以绘制一个三角形为进行介绍，可以为每个顶点添加颜色来增加图形的细节，从而创建图像。但是，如果让图形看上去更加真实，需要足够多的顶点和颜色，相应也会产生更大的开销。为了提高生产效率和执行效率，开发者经常会使用 纹理（Texture） 来表现细节。纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理）。纹理一般可以直接作为图形渲染流水线的第五阶段的输入。 最后，我们还需要知道上述阶段中的着色器事实上是一些程序，它们运行在 GPU 中成千上万的小处理器核中。这些着色器允许开发者进行配置，从而可以高效地控制图形渲染流水线中的特定部分。由于它们运行在 GPU 中，因此可以降低 CPU 的负荷。着色器可以使用多种语言编写，OpenGL 提供了 GLSL（OpenGL Shading Language） 着色器语言。 GPU 存储系统早期的 GPU，不同的着色器对应有着不同的硬件单元。如今，GPU 流水线则使用一个统一的硬件来运行所有的着色器。此外，nVidia 还提出了 CUDA（Compute Unified Device Architecture） 编程模型，可以允许开发者通过编写 C 代码来访问 GPU 中所有的处理器核，从而深度挖掘 GPU 的并行计算能力。 下图所示为 GPU 内部的层级结构。最底层是计算机的系统内存，其次是 GPU 的内部存储，然后依次是两级 cache：L2 和 L1，每个 L1 cache 连接至一个 流处理器（SM，stream processor）。 SM L1 Cache 的存储容量大约为 16 至 64KB。 GPU L2 Cache 的存储容量大约为几百 KB。 GPU 的内存最大为 12GB。 GPU 上的各级存储系统与对应层级的计算机存储系统相比要小不少。 此外，GPU 内存并不具有一致性，也就意味着并不支持并发读取和并发写入。 GPU 流处理器下图所示为 GPU 中每个流处理器的内部结构示意图。每个流处理器集成了一个 L1 Cache。顶部是处理器核共享的寄存器堆。 CPU-GPU 异构系统至此，我们大致了解了 GPU 的工作原理和内部结构，那么实际应用中 CPU 和 GPU 又是如何协同工作的呢？ 下图所示为两种常见的 CPU-GPU 异构架构。 左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e 总线进行连接。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。 右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。 注意，目前很多 SoC 都是集成了CPU 和 GPU，事实上这仅仅是在物理上进行了集成，并不意味着它们使用的就是耦合式结构，大多数采用的还是分离式结构。耦合式结构是在系统上进行了集成。 在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 GPU 共享系统内存，由 MMU 进行存储管理。 图形应用程序调用 OpenGL 或 Direct3D API 功能，将 GPU 作为协处理器使用。API 通过面向特殊 GPU 优化的图形设备驱动向 GPU 发送命令、程序、数据。 GPU 资源管理模型下图所示为分离式异构系统中 GPU 的资源管理模型示意图。 MMIO（Memory-Mapped I/O） CPU 通过 MMIO 访问 GPU 的寄存器状态。 通过 MMIO 传送数据块传输命令，支持 DMA 的硬件可以实现块数据传输。 GPU Context 上下文表示 GPU 的计算状态，在 GPU 中占据部分虚拟地址空间。多个活跃态下的上下文可以在 GPU 中并存。 CPU Channel 来自 CPU 操作 GPU 的命令存储在内存中，并提交至 GPU channel 硬件单元。 每个 GPU 上下文可拥有多个 GPU Channel。每个 GPU 上下文都包含 GPU channel 描述符（GPU 内存中的内存对象）。 每个 GPU Channel 描述符存储了channel 的配置，如：其所在的页表。 每个 GPU Channel 都有一个专用的命令缓冲区，该缓冲区分配在 GPU 内存中，通过 MMIO 对 CPU 可见。 GPU 页表 GPU 上下文使用 GPU 页表进行分配，该表将虚拟地址空间与其他地址空间隔离开来。 GPU 页表与 CPU 页表分离，其驻留在 GPU 内存中，物理地址位于 GPU 通道描述符中。通过 GPU channel 提交的所有命令和程序都在对应的 GPU 虚拟地址空间中执行。 GPU 页表将 GPU 虚拟地址不仅转换为 GPU 设备物理地址，还转换为主机物理地址。这使得 GPU 页面表能够将 GPU 存储器和主存储器统一到统一的 GPU 虚拟地址空间中，从而构成一个完成的虚拟地址空间。 PFIFO Engine PFIFO 是一个提交 GPU 命令的特殊引擎。 PFIFO 维护多个独立的命令队列，即 channel。 命令队列是带有 put 和 get 指针的环形缓冲器。 PFIFO 引擎会拦截多有对通道控制区域的访问以供执行。 GPU 驱动使用一个通道描述符来存储关联通道的设置。 BO 缓冲对象（Buffer Object）。一块内存，可以用来存储纹理，渲染对象，着色器代码等等。 CPU-GPU 工作流下图所示为 CPU-GPU 异构系统的工作流，当 CPU 遇到图像处理的需求时，会调用 GPU 进行处理，主要流程可以分为以下四步： 将主存的处理数据复制到显存中 CPU 指令驱动 GPU GPU 中的每个运算单元并行处理 GPU 将显存结果传回主存 屏幕图像显示原理介绍屏幕图像显示的原理，需要先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。 下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。 最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 双缓冲机制。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。 双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图： 为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。 参考 GPU Architecture and Models 计算机组成与设计：硬件、软件接口 欢迎来到OpenGL的世界 AMD APU Series 一文详解GPU结构及工作原理 Revisting Co-Processing for Hash Joins on the Coupled CPU-GPU Architecture GPU Architecture Overview CUDA iOS 保持界面流程的技巧 iOS 开发：绘制像素到屏幕 扩展阅读 Rendering pipeline: The hardware side Graphics Processing Unit(GPU) Memory Hierarchy Graphics Processing Unit Architecture(GPU Arch) With a focus on NVIDIA GeForce 6800 GPU iOS动画篇：核心动画 The iPhone 5s Review A Look Inside Apple’s Custom GPU for the iPhone One Apple GPU, one giant leap in graphics for iPhone 8]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(6)——线程]]></title>
    <url>%2F2018%2F07%2F10%2Fthread-introduce%2F</url>
    <content type="text"><![CDATA[现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。 线程基础线程概念线程（Thread），也称轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合、堆栈组成。通常，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（如打开文件和信号）。 同一进程中的多个线程可以互不干扰地并发执行，并且共享进程的全局变量和堆的数据。相对于单线程进程，使用多线程的原因有一下几点： 某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待时间进行线程切换。如等待网络响应。 某个操作可能会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会被中断。多线程可以让一个线程负责交互，另一个线程负责计算。 程序本身要求并发操作，如一个多端下载软件（如Bittorrent）。 多CPU或多核处理器，本身具备同时执行多个线程的能力，因此单线程程序无法全面发挥计算机的全部计算能力。 相对于多进程应用，多线程在数据共享方面效率更高。 线程访问权限线程可以访问进程内存中的所有的数据，包括如下几个方面： 全局变量 堆数据 函数里的静态变量 程序代码，任何线程都有权利读取并执行任何代码 打开的文件，A线程打开的文件可以由B线程读取 当然实际上线程也拥有自己的私有存储空间，包括如下几个方面： 栈：尽管并非完全无法被其他线程访问，但是一般情况下还是认为栈是私有数据。 线程局部存储（Thread Local Storage，TLS）：线程局部存储是某些操作系统为线程单独提供的私有空间，容量有限。 寄存器：寄存器是执行流的基本数据，为线程私有。 线程调度与优先级当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上。当线程数据大于处理器数量时，此时至少有一个处理器会运行多个线程。 在单处理器运行多线程情况下，并发是一种模拟出来的状态。操作系统会让这些多线程轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样每个线程“看起来”在同时执行。这样一个不断在处理器上切换不同的线程的行为称为 线程调度。 在线程调度中，线程通常拥有至少三种状态，分别是： 运行（Running）：此时线程正在执行。 就绪（Ready）：此时线程可以立刻运行，但CPI已被占用。 等待（Waiting）：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。 处于运行中的线程拥有一段可以执行的时间，这段时间称为 时间片（Time Slice）。当时间片用尽时，线程进入就绪状态。如果线程在时间片用尽前就开始等待某事件，则它将进入等待状态。当一个线程离开运行状态时，系统会选择一个处于就绪状态的线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。如下图所示为线程的状态转移图。 在线程调度中，主要有两种调度算法： 优先级调度（Priority Schedule）：线程拥有各自的 线程优先级（Thread Priority），高优先级的线程会更早执行，低优先级的线程需要等待系统中没有高优先级的可执行线程存在时才能执行。 轮转调度（Round Robin Schedule）：让各个线程轮流执行一段时间片。 实际应用中，系统还会根据不同线程的表现自动调整优先级，提高线程调度效率。在系统中，一般把频繁等待的线程称为 IO密集型线程（IO Bound Thread）；把很少等待的线程称为 CPU密集型线程（CPU Bound Thread）。通常，IO 密集型线程比 CPU 密集型线程更容易得到优先级的提升。 在优先级调度中，存在一种 饿死（Starvation） 现象，即一个线程的优先级较低，在它执行之前，总是有较高优先级的线程在它之前执行。当一个CPU密集型的线程获得较高优先级时，许多低优先级的进程就可能饿死。当一个IO密集型的线程获得较高优先级时，由于大部分之间处于等待状态，因此相对不容易造成其他线程饿死。为了避免饿死现象，调度系统通常会逐步提升那些等待时间过长且未得到执行的线程的优先级。 可抢占线程和不可抢占线程轮转调度中，线程在用尽时间片后会被强制剥夺继续执行的权利，而进入就绪状态，该过程称为 抢占（Preemption）。在早期的一些操作系统中，线程是不可抢占的。在这种调度模型下，线程必须主动进入就绪状态，而不是靠时间片用尽来被强制进入。如果线程始终拒绝进入就绪状态，并且不进行任何等待操作，其他线程将永远无法执行。 在不可抢占线程中，线程会在两种情况下主动放弃执行： 当线程试图等待某些事件时（如I/O事件）。 线程主动放弃时间片。 线程安全多线程程序处于一个多变的环境中，可以访问的全局变量和堆数据随时都可能被其他的线程改变。因此，多线程程序在并发时数据的一致性非常重要。 竞争与原子操作多线程同时访问一个共享数据，可能会造成严重的后果。以一个著名的例子为例，假设有两个线程分别执行如下所示的 C 代码。123456// 线程 1i = 1;++i;// 线程 2--i; 在很多体系结构中，++i 的实现方式一般如下： 读取 i 到某个寄存器 X X++ 将 X 的内容存储至 i 由于线程 1 和线程 2并发执行，因此两个线程的执行可能如下（注意，寄存器 X 的 内容在不同的线程中是不一样的，这里用 X[1] 和 X[2] 分别表示线程 1 和线程 2 中的 X），如下所示： 执行序号 执行指令 语句执行后的变量值 线程 1 i = 1 i = 1, X[1] = 未知 1 2 X[1] = i i = 1, X[1] = 1 1 3 X[2] = i i = 1, X[2] = 1 2 4 X[1]++ i = 1, X[1] = 2 1 5 X[2]– i = 1, X[2] = 0 2 6 i = X[1] i = 2, X[1] = 2 1 7 i = X[2] i = 0, X[2] = 0 2 从程序逻辑上看，两个线程都执行完毕之后，i 的值应该是 1，但从表中的执行序列可以看到，i 的实际值是 0。实际上，这两个线程如果同时执行，i 的结果有可能是 0 或 1 或 2。 很明显，由于 i++ 操作在多线程环境下会出现错误是因为该操作被编译成汇编代码后不止一条指令，因此在执行时可能会被调度系统打断，去执行别的代码。通常，我们把单指令的操作称为 原子操作，因为单条指令的执行是不会被打断的。很多体系结构都提供了一些常用的原子指令，如 i386 就有一条 inc 指令可以直接增加一个内存单元值，可以避免上例的错误情况。 尽管原子操作指令非常方便，但是它们仅适用于比较简单特定的场合。在复杂的场合下，比如要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。这里需要更加通用的手段：锁。 同步与锁为了避免多个线程同时读写同一个数据而产生不可预料的后果，需要将各个线程对同一个数据的访问进行 同步（Synchronization）。即在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。 同步最常见的方法是使用 锁（Lock）。锁是一种非强制机制，每个线程在访问数据或资源之前首先试图 获取（Acquire） 锁，并在访问结束之后 释放（Release） 锁。在锁已经被占用时试图获取锁时，线程会等待，直到锁重新可用。 二元信号量二元信号量（Binary Semaphore） 是最简单的一种锁，只有两种状态：占用、非占用。二元信号量适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他所有试图获取该二元信号量的线程将会等待，直到该锁被释放。 多元信号量多元信号量是二元信号量的扩展，简称 信号量（Semaphore）。一个初始值为 N 的信号量允许 N 个线程并发访问。 当线程访问资源时，首先获取信号量，进行如下操作： 将信号量减 1。 如果信号量的值小于 0，则进入等待状态，否则继续执行。 当线程结束访问资源后，线程释放信号量，进行如下操作： 将信号量的值加 1。 如果信号量的值小于 1，唤醒一个等待中的线程。 互斥量互斥量（Mutex） 和二元信号量很相似，资源仅同时允许一个线程访问，但和信号量不同的是：信号量在整个系统中可以被任意线程获取并释放，即同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。 临界区临界区（Read-Write Lock） 是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于：互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的；临界区的作用范围仅限于本进程，其他的进程无法获取该锁。 读写锁读写锁（Read-Write Lock） 致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对该数据进行修改，就必须使用同步手段来避免出错。对此，可以使用上述的信号量、互斥量或临界区中的任何一种来进行同步。虽然这样可以保证程序正确执行，但是对于读取频繁的程序，会显得非常低效。读写锁就是用来提高这种情况下的执行效率的。 读写锁有两种获取方式：共享的（Shared）、独占的（Exclusive）。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有线程释放。处于独占状态的锁将阻止任何其他线程获取该锁。 条件变量条件变量（Condition Variable） 作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作：首先，线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时所有等待此条件变量的线程都会被唤醒并继续执行。 线程模型线程的并发执行是由多处理器或操作系统调度来实现的。但实际情况要更为复杂：大多数操作系统，包括 Windows 和 Linux，都在内核里提供线程的支持，内核态线程由多处理器或调度来实现并发。然而用户实际使用的线程并不是内核态线程，而是用户态线程。用户态线程并不一定在操作系统内核里对应同等数量的内核态线程。它们之间的对应关系有三种类型。 一对一模型对于直接支持线程的系统，一对一模型始终是最简单的模型。对于一对一模型，一个用户态线程唯一对应一个内核态线程，但一个内核态线程并不一定存在相应的用户态线程。模型示意图如下所示。 一对一模型中，用户态线程具有和内核态线程一致的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程的执行不会受到影响。此外，一对一模型也可以让多线程程序在多处理器的系统上有更高的效率。 一对一线程模型也有两个缺点： 由于许多操作系统限制了内核态线程的数量，因此一对一线程会让用户态线程的数量受到限制。 许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。 多对一模型多对一模型将多个用户态线程映射到一个内核态线程上，线程之间的切换由用户态的代码完成。因此相对于一对一模型，多对一模型的切换要快速许多。模型示意图如下所示。 多对一模型的问题在于：如果其中一个用户态线程阻塞，将导致所有线程都无法执行。另外，在多处理器系统中，处理器的增多对于多对一模型的线程性能也不会有明显的提升。多对一模型的优点在于高效的上下文切换和几乎无限制的线程数量。 多对多模型多对多模型结合了多对一模型和一对一模型的特点，将多个用户态线程映射到少数但不止一个内核态线程。模型示意图如下所示。 多对多模型中，一个用户态线程阻塞并不会导致所有的用户态线程阻塞，因为此时还有其他的线程可以被调度来执行。此外，多对多模型对用户线程的数量也没什么限制，在多处理器系统中，多对多模型的线程也能得到一定的性能提升，但是提升幅度步入一对一模型。 参考 《程序员的自我修养——链接、装载与库》 《深入理解计算机系统》 （完）]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>信号量</tag>
        <tag>临界区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(5)——可执行文件的装载与运行]]></title>
    <url>%2F2018%2F06%2F17%2Fexecutable-file-load-and-execution%2F</url>
    <content type="text"><![CDATA[当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。1$ ./hello.out 那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤： 创建新进程 检查可执行文件类型 搜索匹配装载处理过程 装载执行可执行文件 创建新进程首先在用户层面，bash 进程会调用 fork() 系统调用创建一个新的进程。其次，新的进程通过调用 execve() 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。 execve() 系统调用被定义在 unistd.h，其原型如下所示。其中的三个参数分别对应被执行程序的 程序文件名、执行参数、环境变量。1int execve(const char *filename, char *const argv[], char *const envp[]); 检查可执行文件类型当进入 execve() 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，execve() 系统调用相应的入口是 sys_execve()。sys_execve() 进行一些参数的检查复制之后，调用 do_execve()。do_execve() 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。 为什么要先读取文件的前 128 个字节？这是因为Linux支持的可执行文件不止 ELF 一种，还包括 a.out、Java 程序、以 #! 开头的脚本程序。do_execve()通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前4个字节，被称为 魔数（Magic Number）。比如：ELF的可执行文件格式的头 4 个字节为 0x7F、e、l、f；Java的可执行文件格式的头 4 个字节为 c、a、f、e；如果是解释型语言的脚本，则第一行通常是 #!/bin/sh 或 #!/user/bin/python，其中 # 和 ! 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。 搜索匹配装载处理过程当 do_execve() 读取了128个字节的文件头部之后，调用 search_binary_handle() 去搜索和匹配合适的可执行文件装载处理过程。Linux 中所有被支持的可执行文件格式都有相应的装载处理过程，search_binary_handler() 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示. ELF 可执行文件：load_elf_binary() a.out 可执行文件：load_aout_binary() 可执行脚本程序：load_script() 装载执行可执行文件以 ELF 的装载处理过程 load_elf_binary() 为例，其所包含的步骤如下图所示： 操作系统读取可执行文件 ELF 的 Header，检查文件的有效性。 操作系统读取可执行文件 ELF的 Program Header Table 中读取每个 Segment 的虚拟地址、文件地址、属性等。 操作系统根据 Program Header Table 将可执行文件 ELF 映射至内存。 如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 .interp 节，找到 动态链接器（Dynamic Linker） 的位置，并启动动态链接器。在 Linux 下，动态链接器 ld.so 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。 动态链接器获得控制权后，开始执行一系列初始化操作。 动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。 控制权被转交到可执行文件的入口地址，程序开始正式执行。 参考 《程序员的自我修养——链接、装载与库》 《深入理解计算机系统》 （完）]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>装载</tag>
        <tag>静态链接</tag>
        <tag>动态链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(4)——链接、静态链接、动态链接]]></title>
    <url>%2F2018%2F06%2F03%2Flinking-static-linking-dynamic-linking%2F</url>
    <content type="text"><![CDATA[通过前面对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？一切都要从链接说起。 链接概述模块化设计是软件开发中最常用的设计思想。链接（Linking） 本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。比如： 我们在模块main.c中使用另一个模块func.c中的foo()函数。我们在main.c模块中每一处调用foo时都必须确切知道foo函数的地址。但由于每个模块都是单独编译的。编译器在编译main.c的时候并不知道foo函数的地址。所以编译器会暂时把这些调用foo的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。这就是静态链接最基本的过程和作用。 如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj）。目标文件和 库（Library） 一起链接形成最终的可执行文件。 其中，最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。 链接过程主要包含了三个步骤： 地址与空间分配（Address and Storage Allocation） 符号解析（Symbol Resolution） 重定位（Relocation） 下面，我们以两个源代码文件a.c和b.c为例展开分析。1234567// a.cextern int shared;int main() &#123; int a = 100; swap(&amp;a, &amp;shared);&#125; 123456// b.cint shared = 1;void swap(int *a, int *b) &#123; *a ^= *b ^= *a ^= *b;&#125; 其中，b.c中定义了两个全局符号：变量shared、函数swap；a.c中定义了一个全局符号：main。a.c引用了b.c中的swap和shared。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件ab。 使用gcc -c命令我们可以分别编译得到a.o和b.o两个目标文件。 地址与空间分配在介绍ELF文件结构关于段与节的区别时，我们就提到过可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。 按序叠加一个最简单的方案就是将输入的文件按序叠加，如下图所示。 虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。 合并相似节一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 .text节合并到输出文件的 text段（注意，此时出现了段和节两个概念），如下图所示。 其中.bss节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义: 在输出的可执行文件中的空间 在装载后的虚拟地址中的空间 对于有实际数据的节，如.text和.data，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于.bss来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 两步链接（Two-pass Linking） 的方法。即整个链接过程分为两步： 第一步 地址与空间分配 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。 第二步 符号解析与重定位 使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。 在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了ELF文件结构一文中没有介绍的 程序头表（Program Header Table） 结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ text段）、数据段（ data段 ）。 我们使用ld或gcc将a.o和b.o链接起来，然后使用objdump工具来查看链接前后的地址分配情况。 1234567891011$ objdump -h a.oSections:Idx Name Size VMA LMA File off Algn 0 .text 0000004f 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 0000000000000000 0000000000000000 0000008f 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 0000008f 2**0 ALLOC ... 1234567891011$ objdump -h b.oSections:Idx Name Size VMA LMA File off Algn 0 .text 0000004b 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000004 0000000000000000 0000000000000000 0000008c 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 00000090 2**0 ALLOC ... 12345678910111213$ objdump -h abSections:Idx Name Size VMA LMA File off Algn ... 13 .text 00000202 0000000000400450 0000000000400450 00000450 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE ... 24 .data 00000014 0000000000601028 0000000000601028 00001028 2**3 CONTENTS, ALLOC, LOAD, DATA 25 .bss 00000004 000000000060103c 000000000060103c 0000103c 2**0 ALLOC ... 可以发现，链接前目标文件中所有节的 VMA（Virtual Memory Address） 都是0，因为虚拟空间还没有分配。链接后，可执行文件ab中各个节被分配到了相应的虚拟地址，如.text节被分配到了地址0x0000000000400450。 那么，为什么链接器要将可执行文件ab的.text节分配到0x0000000000400450？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从0x0000000000400000开始的，另外.text节之前还有ELF Header、Program Header Table、.init等占用了一定的空间，所以就被分配到了0x0000000000400450。 符号解析在两步链接中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。 然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。 另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。 多重定义的全局符号解析链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？ Linux编译系统采用如下的方法解决多重定义的全局符号解析： 在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。 根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名： 规则1：不允许有多个同名的强符号。 规则2：如果有一个强符号和多个弱符号同名，则选择强符号。 规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。 另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种： 情况1：两个或两个以上的强符号类型不一致。 情况2：有一个强符号，其他都是弱符号，出现类型不一致。 情况3：两个或两个以上弱符号类型不一致。 其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 COMMON块（Common Block） 的机制来处理。其过程如下： 首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。 重定位事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。 那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 重定位表（Relocation Table） 专门用来保存这些与重定位相关的信息。 对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。 我们可以使用objdump工具来查看目标文件中的重定位表：1234567891011121314$ objdump -r a.oa.o: file format elf64-x86-64RELOCATION RECORDS FOR [.text]:OFFSET TYPE VALUE0000000000000023 R_X86_64_32 share0000000000000030 R_X86_64_PC32 swap-0x00000000000000040000000000000049 R_X86_64_PC32 __stack_chk_fail-0x0000000000000004RELOCATION RECORDS FOR [.eh_frame]:OFFSET TYPE VALUE0000000000000020 R_X86_64_PC32 .text 我们可以看到每个要被重定位的地方是一个 重定位入口（Relocation Entry）。利用数据结构成员包含的信息，即可完成重定位。 静态链接事实上，静态链接的过程就是上文所描述的过程。在Linux中，静态链接器（static linker）ld以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。 动态链接静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等。在静态链接中，C语言静态库是很典型的浪费空间的例子。关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序。 解决空间浪费和更新困难最简单的方法便是将程序的模块相互分割开来，形成独立文件。简而言之，就是不对那些组成程序的目标文件进行链接，而是等到程序要运行时才进行链接。 动态链接的基本实现动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。 目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以.so为后缀；在Windows中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以.dll为后缀。 在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 /lib目录下，文件名为 libc.so。整个系统只保留一份C语言动态链接文件libc.so，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。 动态链接程序运行时地址空间分布对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是： 静态共享库（Static Shared Library）（地址固定） 动态共享库（Dynamic Shared Libary）（地址不固定） 静态共享库静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态。 但是静态共享库的目标地址会导致地址冲突、升级等问题。 动态共享库采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）。其基本思路是：在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。 地址无关代码 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 地址无关代码（PIC，Position-independent Code） 技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。 共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型： 类型1：模块内部的函数调用。 类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。 类型3：模块外部的函数调用。 类型4：模块外部的数据访问，如其他模块中定义的全局变量。12345678910111213static int a;extern int b;extern void ext();void bar() &#123; a = 1; // 类型2：模块内部数据访问 b = 2; // 类型4：模块外部数据访问&#125;void foo() &#123; bar(); // 类型1：模块内部函数调用 ext(); // 类型4：模块外部函数调用&#125; 类型1 模块内部函数调用由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。 类型2 模块内部数据访问一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。 类型3 模块间数据访问模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示： 当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。 类型4 模块间函数调用对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。 总结通过上文的描述，我们基本理清了链接的过程以及静态链接和动态链接的区别。事实上，链接的具体实现细节是非常复杂，本文只是对其进行了概述，更多细节以及优化实现还是需要我们自己进一步去探索。 参考 Executable and Linkable Format (ELF) 《Linux 二进制分析》 《程序员的自我修养——链接、装载与库》 《深入理解计算机系统》 Executable and Linkable Format （完）]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>静态链接</tag>
        <tag>动态链接</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(3)——ELF文件结构]]></title>
    <url>%2F2018%2F05%2F21%2Felf-introduce%2F</url>
    <content type="text"><![CDATA[前文结尾说到编译器编译源代码后生成的文件叫做目标文件，而目标文件经过编译器链接之后得到的就是可执行文件。那么目标文件到底是什么？它和可执行文件又有什么区别？链接到底又做了什么呢？接下来，我们将探索一下目标文件的本质。 目标文件的格式目前，PC平台流行的 可执行文件格式（Executable） 主要包含如下两种，它们都是 COFF（Common File Format） 格式的变种。 Windows下的 PE（Portable Executable） Linux下的 ELF（Executable Linkable Format） 目标文件就是源代码经过编译后但未进行连接的那些中间文件（Windows的.obj和Linux的.o），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储。在Windows下采用PE-COFF文件格式；Linux下采用ELF文件格式。 事实上，除了可执行文件外，动态链接库（DDL，Dynamic Linking Library）、静态链接库（Static Linking Library） 均采用可执行文件格式存储。它们在Window下均按照PE-COFF格式存储；Linux下均按照ELF格式存储。只是文件名后缀不同而已。 动态链接库：Windows的.dll、Linux的.so 静态链接库：Windows的.lib、Linux的.a 下面，我们将以ELF文件为例进行介绍。 ELF文件结构 注意：段（Segment）与节（Section）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。 如图所示，为ELF文件的基本结构，其主要由四部分组成： ELF Header ELF Program Header Table (或称Program Headers、程序头) ELF Section Header Table (或称Section Headers、节头表) ELF Sections 从图中，我们就能看出它们各自的数据结构以及相互之间的索引关系。下面我们依次进行介绍。 ELF Header我们可以使用readelf工具来查看ELF Header。12345678910111213141516171819202122$ readelf -h hello.oELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&apos;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 672 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 13 Section header string table index: 10 ELF文件结构示意图中定义的Elf_Ehdr的各个成员的含义与readelf具有对应关系。如下表所示： 成员 含义 e_ident Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2’s complement, little end Version: 1(current) OS/ABI: UNIX - System V ABI Version: 0 e_type Type: REL (Relocatable file) ELF文件类型 e_machine Machine: Advanced Micro Devices X86-64 ELF文件的CPI平台属性 e_version Version: 0x1 ELF版本号。一般为常数1 e_entry Entry point address: 0x0 入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位指令一般没有入口地址，则该值为0 e_phoff Start of program headers: 0(bytes into file) e_shoff Start of section headers: 672 (bytes into file) Section Header Table 在文件中的偏移 e_word Flags: 0x0 ELF标志位，用来标识一些ELF文件平台相关的属性。 e_ehsize Size of this header: 64 (bytes) ELF Header本身的大小 e_phentsize Size of program headers: 0 (bytes) e_phnum Number of program headers: 0 e_shentsize Size of section headers: 64 (bytes) 单个Section Header大小 e_shnum Number of section headers: 13 Section Header的数量 e_shstrndx Section header string table index: 10 Section Header字符串表在Section Header Table中的索引 ELF魔数每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，通常被称为魔数（Magic Number）。通过对魔数的判断可以确定文件的格式和类型。如：ELF的可执行文件格式的头4个字节为0x7F、e、l、f；Java的可执行文件格式的头4个字节为c、a、f、e；如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是#!/bin/sh或#!/usr/bin/perl或#!/usr/bin/python，此时前两个字节#和!就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。 ELF文件类型ELF文件主要有三种类型，可以通过ELF Header中的e_type成员进行区分。 可重定位文件（Relocatable File）：ETL_REL。一般为.o文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。 可执行文件（Executable File）：ET_EXEC。可以直接执行的程序。 共享目标文件（Shared Object File）：ET_DYN。一般为.so文件。有两种情况可以使用。 链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件； 动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像。 ELF Section Header TableELF 节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。 我们可以使用readelf工具来查看节头表。12345678910111213141516171819202122232425262728293031323334353637$ readelf -S hello.oThere are 13 section headers, starting at offset 0x2a0:Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000015 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 000001f0 0000000000000030 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 00000055 0000000000000000 0000000000000000 WA 0 0 1 [ 4] .bss NOBITS 0000000000000000 00000055 0000000000000000 0000000000000000 WA 0 0 1 [ 5] .rodata PROGBITS 0000000000000000 00000055 000000000000000d 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 00000062 0000000000000035 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 00000097 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 00000098 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000220 0000000000000018 0000000000000018 I 11 8 8 [10] .shstrtab STRTAB 0000000000000000 00000238 0000000000000061 0000000000000000 0 0 1 [11] .symtab SYMTAB 0000000000000000 000000d0 0000000000000108 0000000000000018 12 9 8 [12] .strtab STRTAB 0000000000000000 000001d8 0000000000000013 0000000000000000 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) ELF文件结构示意图中定义的Elf_Shdr的各个成员的含义与readelf具有对应关系。如下表所示： 成员 含义 sh_name 节名 节名是一个字符串，保存在一个名为.shstrtab的字符串表（可通过Section Header索引到）。sh_name的值实际上是其节名字符串在.shstrtab中的偏移值 sh_type 节类型 sh_flags 节标志位 sh_addr 节地址：节的虚拟地址 如果该节可以被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址；否则sh_addr为0 sh_offset 节偏移 如果该节存在于文件中，则表示该节在文件中的偏移；否则无意义，如sh_offset对于BSS 节来说是没有意义的 sh_size 节大小 sh_link、sh_info 节链接信息 sh_addralign 节地址对齐方式 sh_entsize 节项大小 有些节包含了一些固定大小的项，如符号表，其包含的每个符号所在的大小都一样的，对于这种节，sh_entsize表示每个项的大小。如果为0，则表示该节不包含固定大小的项。 节类型（sh_type）节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（sh_type）和节的标志位（sh_flags）。 节的类型相关常量以SHT_开头，上述readelf -S命令执行的结果省略了该前缀。常见的节类型如下表所示： 常量 值 含义 SHT_NULL 0 无效节 SHT_PROGBITS 1 程序节。代码节、数据节都是这种类型。 SHT_SYMTAB 2 符号表 SHT_STRTAB 3 字符串表 SHT_RELA 4 重定位表。该节包含了重定位信息。 SHT_HASH 5 符号表的哈希表 SHT_DYNAMIC 6 动态链接信息 SHT_NOTE 7 提示性信息 SHT_NOBITS 8 表示该节在文件中没有内容。如.bss节 SHT_REL 9 该节包含了重定位信息 SHT_SHLIB 10 保留 SHT_DNYSYM 11 动态链接的符号表 节标志位（sh_flag）节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以SHF_开头。常见的节标志位如下表所示： 常量 值 含义 SHF_WRITE 1 表示该节在进程空间中可写 SHF_ALLOC 2 表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。 SHF_EXECINSTR 4 表示该节在进程空间中可以被执行 节链接信息（sh_link、sh_info）如果节的类型是与链接相关的（无论是动态链接还是静态链接），如重定位表、符号表、等，则sh_link、sh_info两个成员所包含的意义如下所示。其他类型的节，这两个成员没有意义。 sh_type sh_link sh_info SHT_DYNAMIC 该节所使用的字符串表在节头表中的下标 0 SHT_HASH 该节所使用的符号表在节头表中的下标 0 SHT_REL 该节所使用的相应符号表在节头表中的下标 该重定位表所作用的节在节头表中的下标 SHT_RELA 该节所使用的相应符号表在节头表中的下标 该重定位表所作用的节在节头表中的下标 SHT_SYMTAB 操作系统相关 操作系统相关 SHT_DYNSYM 操作系统相关 操作系统相关 other SHN_UNDEF 0 ELF Sections节的分类上述ELF Section Header Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。 .text节.text节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，则.text节就会存在于text段中。由于.text节保存了程序代码，所以节类型为SHT_PROGBITS。 .rodata节rodata节保存了只读的数据，如一行C语言代码中的字符串。由于.rodata节是只读的，所以只能存在于一个可执行文件的只读段中。因此，只能在text段（不是data段）中找到.rodata节。由于.rodata节是只读的，所以节类型为SHT_PROGBITS。 .plt节（过程链接表）.plt节也称为过程链接表（Procedure Linkage Table），其包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于.plt节保存了代码，所以节类型为SHT_PROGBITS。 .data节.data节存在于data段中，其保存了初始化的全局变量等数据。由于.data节保存了程序的变量数据，所以节类型为SHT_PROGBITS。 .bss节.bss节存在于data段中，占用空间不超过4字节，仅表示这个节本省的空间。.bss节保存了未进行初始化的全局数据。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于.bss节未保存实际的数据，所以节类型为SHT_NOBITS。 .got.plt节（全局偏移表-过程链接表）.got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。由于.got.plt节与程序执行有关，所以节类型为SHT_PROGBITS。 .dynsym节（动态链接符号表）.dynsym节保存在text段中。其保存了从共享库导入的动态符号表。节类型为SHT_DYNSYM。 .dynstr节（动态链接字符串表）.dynstr保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。 .rel.*节（重定位表）重定位表保存了重定位相关的信息，这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改。由于重定位表保存了重定位相关的数据，所以节类型为SHT_REL。 .hash节.hash节也称为.gnu.hash，其保存了一个用于查找符号的散列表。 .symtab节（符号表）.symtab节是一个ElfN_Sym的数组，保存了符号信息。节类型为SHT_SYMTAB。 .strtab节（字符串表）.strtab节保存的是符号字符串表，表中的内容会被.symtab的ElfN_Sym结构中的st_name引用。节类型为SHT_STRTAB。 .ctors节和.dtors节.ctors（构造器）节和.dtors（析构器）节分别保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码。 符号表节的分类中我们介绍了.dynsym节和.symtab节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？ 符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名。例如，printf()函数会在动态链接符号表.dynsym中存有一个指向该函数的符号项（以Elf_Sym数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即.dynsym和.symtab。 .dynsym保存了引用来自外部文件符号的全局符号。如printf库函数。.dynsym保存的符号是.symtab所保存符合的子集，.symtab中还保存了可执行文件的本地符号。如全局变量，代码中定义的本地函数等。 既然.dynsym是.symtab的子集，那为何要同时存在两个符号表呢？ 通过readelf -S命令可以查看可执行文件的输出，一部分节标志位（sh_flags）被标记为了A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）。其中，.dynsym被标记为ALLOC，而.symtab则没有标记。 ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号。.dynsym对于动态链接可执行文件的执行是必需的，而.symtab只是用来进行调试和链接的。 上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个Elf_Sym结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示： 成员 含义 st_name 符号名。该值为该符号名在字符串表中的偏移地址。 st_value 符号对应的值。存放符号的值（可能是地址或位置偏移量）。 st_size 符号的大小。 st_other 0 st_shndx 符号所在的节 st_info 符号类型及绑定属性 使用readelf工具我们也能够看到符号表的相关信息。123456789101112131415$ readelf -s hello.oSymbol table &apos;.symtab&apos; contains 11 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS hello.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 8 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 21 FUNC GLOBAL DEFAULT 1 main 10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND puts 字符串表类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即.dynstr和.strtab，分别对应于.dynsym和symtab。此外，还有一个.shstrtab的节头字符串表，用于保存节头表中用到的字符串，可通过sh_name进行索引。 ELF文件中所有字符表的结构基本一致，如上图所示。 重定位表重定位就是将符号定义和符号引用进行连接的过程。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。 重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：1234567891011121314$ objdump -r hello.ohello.o: file format elf64-x86-64RELOCATION RECORDS FOR [.text]:OFFSET TYPE VALUE0000000000000005 R_X86_64_32 .rodata000000000000000a R_X86_64_PC32 puts-0x0000000000000004RELOCATION RECORDS FOR [.eh_frame]:OFFSET TYPE VALUE0000000000000020 R_X86_64_PC32 .text 重定位表是一个Elf_Rel类型的数组结构，每一项对应一个需要进行重定位的项。其成员含义如下表所示： 成员 含义 r_offset 重定位入口的偏移。 对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移 对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址 r_info 重定位入口的类型和符号 因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。 对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的。 重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。 参考 Executable and Linkable Format (ELF) 《Linux 二进制分析》 《程序员的自我修养——链接、装载与库》 Executable and Linkable Format (完)]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>ELF文件</tag>
        <tag>目标文件</tag>
        <tag>可执行文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(2)——程序构建及编译原理]]></title>
    <url>%2F2018%2F05%2F12%2Fcompiler-principle%2F</url>
    <content type="text"><![CDATA[最近在看《程序员的自我修养——链接、装载与库》一书，这本书以前看过一部分，由于难啃，当时没有坚持下去。现在工作了，每天接触的都是业务开发，对底层的一些东西感觉越来越陌生。于是，又把此书翻了出来拜读。为了加深阅读的印象，打算对书中的一些有价值的内容进行整理，也方便后续回顾。 程序构建流程下面以“Hello World”程序为例，来介绍程序的编译与链接过程。1234567// hello.c#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello World!\n&quot;); return 0;&#125; 在Linux下，可以直接使用GCC来编译Hello World程序：123$ gcc hello.c$ ./a.outHello World! GCC编译命令隐藏了构建过程中的一些复杂的步骤，主要有4个步骤，如下图所示。 预处理（Propressing） 编译（Compilation） 汇编（Assembly） 链接（Linking） 预编译预编译步骤将源代码文件hello.c以及相关头文件，如：stdio.h等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。 预编译步骤相当于执行如下命令（选项-E表示只进行预编译）1$ gcc -E hello.c -o hello.i 或1$ cpp hello.c &gt; hello.i 预编译主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下： 将所有的“#define”删除，并且展开所有的宏定义。 处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。 删除所有的注释“//”和“/ /”。 添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。 保留所有的#pragma编译器指令，因为编译器须要试用他们。 预编译生成的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。 编译编译就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一。 编译步骤相当于执行如下命令：1$ gcc -S hello.i -o hello.s 或1$ gcc -S hello.c -o hello.s 现在版本的GCC把预编译和编译两个步骤合并成了一个步骤，使用一个叫cc1的程序来完成。该程序位于“/usr/lib/gcc/x86_64-linux-gnu/4.8/”，我们可以直接调用cc1来完成它：1$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c 事实上，对于不同的语言，预编译与编译的程序是不同的，如下所示： C：cc1 C++：cc1plus Objective-C：cc1obj Fortran：f771 Java：jc1 GCC是对这些后台程序的封装，它会根据不同的参数来调用预编译程序cc1、汇编器as、链接器ld。 汇编汇编就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。 汇编步骤相当执行如下命令：1$ gcc -c hello.s -o hello.o 或1$ gcc -c hello.c -o hello.o GCC本质上是调用汇编器as来完成汇编步骤的，我们可以直接调用as来完成该步骤：1$ as hello.s -o hello.o 链接链接主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。 编译器工作原理编译过程可以分为6个步骤，如下图所示。 扫描（Scanning）（又称词法分析） 语法分析（Syntax analysis） 语义分析（Semantic Analysis） 源代码优化（Source Code Optimization） 目标代码生成（Target Code Generation） 目标代码优化（Target Code Optimization） 下面我们以一行简单的C语言代码为例，简单描述从源代码（Source Code）到最终目标代码的过程。代码示例如下：12// CompilerExpression.carray[index] = (index + 4) * (2 + 6) 扫描（词法分析）首先源代码被输入到扫描器（Scanner），扫描器的任务很简单，只是简单地进行词法分析，运用一种类似于有限状态机（Finite State Machine）的算法将源代码的字符序列分割成一系列的记号（Token）。 以上述代码为例，总共包含了28个非空字符，经过扫描后，产生了16个记号。 记号 类型 array 标识符 [ 左方括号 index 标识符 [ 右方括号 = 赋值 ( 左圆括号 index 标识符 + 加号 4 数字 ) 右圆括号 * 乘号 ( 左圆括号 2 数字 + 加号 6 数字 ) 右圆括号 词法分析产生的记号一般可以分为一下几类：关键字、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。 在识别记号的同时，扫描器也完成了其他工作。如：将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。 有一个名为lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。正因为有这样一个程序存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。 语法分析语法分析器（Grammar Parser）将对由扫描器产生的记号进行语法分析。从而产生语法树（Syntax Tree）。整个分析过程采用了上下文无关语法（Context-freeGrammar）的分析手段。简单地讲，由语法分析器生成的语法树是以表达式（Expression）为节点的树。 以上述代码为例，其中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句，下图所示为该语句经过语法分析器后生成的语法树。12// CompilerExpression.carray[index] = (index + 4) * (2 + 6) 在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如：乘法表达式的优先级比加法高，圆括号表达式的优先级比乘法高，等等。另外，有些符号具有多重含义，如“*”在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，因此语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。 有一个名为yacc（Yet Another Compiler Compiler）的工具可以实现语法分析。其根据用户给定的语法规则对输入的记号序列进行解析，从而构建出语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器编写一个语法分析器。因此，其也称为“编译器编译器（Compiler Compiler）” 语义分析语法分析仅仅完成了对表达式的语法层面的分析，但它并不了解这个语句的真正含义，如：C语言里两个指针做乘法运算是没有意义的，但这个语句在语法上是合法的。编译器所能分析的语义是静态语义（Static Semantic），所谓静态语义是指在编译期间可以确定的语义，与之对应的动态语义（Dynamic Semantic）就是只有在运行期才能确定的语义。 静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型的转换过程，语义分析过程中需要完成该步骤。比如讲一个浮点赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。 经过语义分析阶段之后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。下图所示为标记语义后的语法树。 源代码优化（中间代码生成）现代编译器有着很多层次的优化，源码优化器（Source Code Optimizer）则是在源代码级别进行优化。上述例子中，（2 + 6）这个表达式可以被优化掉。因为它的值在编译期就可以被确定。下图所示为优化后的语法树。 事实上，直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Intermediate Code），它是语法树的顺序表示，其实它已经非常接近目标代码了。但它一般与目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等。 中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：三地址码（Three-address Code）、P-代码（P-Code）。以三地址码为例，最基本的三地址码如下所示：12x = y op z# 表示将变量y和z进行op操作后，赋值给x。 因此，可以将上述例子的代码翻译成三地址码：1234t1 = 2 + 6t2 = index + 4t3 = t2 * t1array[index] = t3 为了使所有的操作符合三地址码形式，这里使用了几个临时变量：t1、t2和t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1 = 6。因此，进一步优化后可以得到如下的代码：123t2 = index + 4t2 = t2 * 8array[index] = t2 中间代码将编译器分为前端（Front End）和后端（Back End）。编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码。这样，对于一些可跨平台的编译器，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。比如clange就是一个前端工具，而LLVM则负责后端处理。GCC则是一个套装，包揽了前后端的所有任务。 目标代码生成目标代码生成主要由代码生成器（Code Generator）完成。代码生成器将中间代码转换成目标机器代码，该过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。 上述例子的中间代码，经过代码生成器的处理之后可能会生成如下所示的代码序列（以x86汇编为例，假设index的类型为int型，array的类型为int型数组）：12345movl index, %ecx ; value of index to ecxaddl $4, %ecx ; ecx = ecx + 4mull $8, %ecx ; ecx = ecx * 8movl index, %eax ; value of index to eaxmovl %ecx, array(,%eax,4) ; array[index] = ecx 目标代码优化目标代码生成后，由目标代码优化器（Target Code Optimizer）来进行优化。比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。 上述例子中，乘法由一条相对复杂的基址比例变址寻址（Base Index Scale Addressing）的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。如下所示为优化后的目标代码：123movl index, %edxleal 32(,%edx,8), %eaxmovl %eax, array(,%edx,4) 结尾经过扫描、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化等一系列步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题： index和array的地址还没有确定 如果我们把目标代码使用汇编器编译成真正能够在机器上运行的指令，那么index和array的地址来自哪里？如果index和array定义在跟上面的源代码同一个编译单元里，那么编译器可以为index和array分配空间，确定地址；但如果是定义在其他的程序模块呢？ 事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由编译器最终将这些目标文件链接起来形成可执行文件。 后面，我们将继而探讨链接的原理。 参考 《程序员的自我修养——链接、装载与库》 （完）]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种简易的客户端存储架构设计]]></title>
    <url>%2F2018%2F04%2F26%2Fa-design-of-ios-storage-architecture%2F</url>
    <content type="text"><![CDATA[今天看了公司内部某三个APP项目的存储相关代码。总体来说，存储架构基本上是类似的。对此，我绘制了其存储架构的示意图，如下图所示。 数据库项目使用自定义的数据库KVDBStore，该数据库实际上只是对开源数据库FMDatabase进行了封装，其包含如下两个属性。 123456@interface KVDBStore()@property (nonatomic, strong) FMDatabaseQueue *dbQueue;@property (nonatomic, strong, readonly) NSString *dbPath;@end KVDBStore存储于应用沙盒的Data Container中的Documents目录下（进一步了解应用沙盒结构）。该目录可以通过如下方法获取。1NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]; KVDBStore数据库的存储条目具有几个特定的值，使用DBItem对象来表示，其属性包括：1234567@interface DBItem : NSObject@property (strong, nonatomic) NSString * itemId;@property (strong, nonatomic) id itemObject;@property (strong, nonatomic) NSDate * createdTime;@end KVDBStore主要提供了构造方法、析构方法以及一些基本的操作方法，如：增删查改、Transaction操作等，如下所示：12345678910111213141516171819202122232425262728293031- (id)initDBWithName:(NSString *)dbName;- (id)initWithDBWithPath:(NSString *)dbPath;- (BOOL)createTableWithName:(NSString *)tableName;- (BOOL)clearTable:(NSString *)tableName;- (void)close;...///************************ Transaction methods *************************************- (BOOL)beginTransaction;- (BOOL)rollbackTransaction;- (BOOL)commitTransaction;...///************************ Put&amp;Get methods *****************************************- (BOOL)putObject:(id)object withId:(NSString *)objectId intoTable:(NSString *)tableName;- (id)getObjectById:(NSString *)objectId fromTable:(NSString *)tableName;- (BOOL)deleteObjectById:(NSString *)objectId fromTable:(NSString *)tableName;... 表KVDBStore是在数据库层面实现的一个类，一个数据库通常是由多个表组成的，在实际开发中，表间的联结操作相对比较少，主要还是对特定表进行增删查改的操作。对此，项目实现了表级类BaseTable以便于进行操作，其包含以下属性：1234567@interface BaseTable ()@property (nonatomic, strong) NSString *databaseName;@property (nonatomic, strong) NSString *tableName;@property (nonatomic, strong) KVDBStore *databaseStore; @end 存储架构项目只实例化了一个数据库，所有的表均建立在该数据库中，并且所有的表都继承自BaseTable，而这些表则定义了与该表相关的数据库操作。以AccountTable为例，其应该定义类似以下的方法：1234567- (NSString *)getAccount;- (void)setAccount:(NSString *)account;- (UserInfo *)userInfo;- (void)setUserInfo:(UserInfo *)userInfo;... 在实际开发中，我们经常会面临同时从（向）一个表（或多个表）读取（写入）数据。对此，项目中实现了各种代理单例来完成这些操作，如：使用AccountAgent定义登录和退出的方法，其内部需要对AccountTable进行很多复杂的操作，。当然，在涉及到表间联结操作时，也应该通过代理来进行实现。123456// AccountAgent- (void)login;- (void)logout;... 总结后续，希望能够阅读以下FMDatabase的源码，以对iOS底层的存储原理有进一步的理解。 （完）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC、MVP、MVVM的演化]]></title>
    <url>%2F2018%2F04%2F11%2Fmvc-mvp-mvvm%2F</url>
    <content type="text"><![CDATA[在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。 MVC基本MVC模式如下图所示为基本的MVC（Model-View-Controller）模式结构图，可分为三部分：模型（Model）、视图（View）、控制器（Controller）。其在MVC模式中所扮演的角色分别为： Model：模型管理应用程序的数据，响应有关其状态信息（通常来自View）的请求，并响应指令以更改状态（通常来自Controller）。 View：视图管理数据的展示。 Controller：控制器解释用户的输入，并通知模型、视图进行状态更新。 其中，View和Controller依赖于Model，而Model并不依赖于View和Controller。这种设计模式的优点在于允许Model不受View的影响，从而能够进行独立的构建和测试。 此外，根据Model的具体实现还可以进一步分为：主动型Model、被动型Model。 被动型Model MVC模式当只有一个Controller操控着Model时可以采用被动型Model。Controller定义Model，并在Model发生改变时通知View，后者再进行更新。在这种场景下，Model完全独立于View和Controller。实际上，被动型Model MVC模式就是基本的MVC模式。 主动型Model MVC模式当Model的状态未受Controller干扰的情况下发生变化时，使用主动型Model。当其他来源正在更改数据并且必须立刻反应到View中时，可能会发生这种情况。 为了实现主动型Model，通常使用Observer模式来提供了一种机制来提醒其他对象的状态变化，避免引入依赖关系。各个View实现Observer接口并向Model注册。当Model发生变化时，Model会遍历所有注册的观察者并通知他们相关的变化。这种方法通常被称为“发布 - 订阅”。Model从不需要关于任何View的任何信息。事实上，在Controller需要被告知Model变化的情况下（例如，启用或禁用菜单选项），所有Controller必须通过实现Observer接口并订阅Model的变化。 传统版MVC上述主动型Model MVC模式通过加入Observer模式进行了改良。事实上，随着业务需求的变化，MVC模式通过不断加入一些更基本的设计模式采演化成现在经典的MVC模式。这些基本模式协同工作，定义了MVC应用程序特有的功能分离和通信路径。 上图所示为传统MVC设计模式，其通过Composition、Strategy、Observer等基本设计模式协同工作以实现。用户操作在复合结构的某个层次上操作View，生成一个事件。Controller接收事件，并进行解释。这个过程使用Strategy模式实现，可以是通过消息请求一个Model对象来更新其状态或请求一个View对象来更新其行为或外观。Model对象则在其状态改变时通知所有已注册为观察者的对象。如果观察者是对象，则可以相应更新其外观。 苹果版MVC苹果认为传统的MVC模式中，View通过Observer模式直接观察Model对象以获取相关的通知，而这样的设计会导致View和Model对象不能被广泛复用，因为View与其观察的Model之间存在耦合关系。因此，苹果版MVC与传统MVC基本一致，只是隔离了View和Model。 在iOS中，UIViewController和UIView是一一对应的。随着业务的深入，MVC最终一点点变成了Massive-View-Controller。 MVPMVP（Modell-View-Presenter）模式就是为了解决MVC中Controller越来越臃肿的问题，进一步明确代码分工。MVP与苹果版MVC非常相似，但是它们的从属关系有所不同（实线表示持有）。如下图所示，MVP模式中View持有Presenter，Presenter持有Model，View不能直接访问Model；而MVC模式中Controller持有View和Model。 通过修改从属关系，可以真正意义上实现将UI逻辑和数据逻辑隔离，而隔离之后就可以方便地对数据逻辑部分进行单元测试。 在iOS中，MVP的实现一般如下图所示。 MVVMMVVM（Model View View-Model）就是为了解决MVP中Presenter过于臃肿的问题。MVVM的思想是将Controller中UI控制逻辑与业务逻辑进行分离，并抽离出一个View-Model来完成UI控制的逻辑。而Controller只需要负责业务逻辑即可。如下图便是MVVM的结构图。 通常，View-Model可以调用Model定义的方法，从Model中获取数据以用于View，并对数据进行预处理，使View可以直接使用。View又可以向View-Model发出用户的操作命令，从而更改Model。MVVM实现了一种双向绑定机制。 在iOS中，MVVM的实现一般如下图所示。 MVVM的优点在于：降低了View和Model之间的耦合；分离了业务逻辑和视图逻辑。缺点在于：View和Model双向绑定导致bug难以定位，两者中的任何一方出现问题，另一方也会出现问题；增加了胶水代码。 参考 Model-View-Controller Concepts in Objective-C Programming The MVVM Pattern iOS 关于MVC和MVVM设计模式的那些事 MVC, MVP和MVVM 被误解的MVC和被神化的MVVM iOS使用RAC实现MVVM的正经姿势 （完）]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于树的iOS页面路径转换设计]]></title>
    <url>%2F2018%2F04%2F01%2Fios-tree-based-path-conversion-design%2F</url>
    <content type="text"><![CDATA[需求场景采集用户在购买VIP或购买商品时的操作路径，如：”首页” -&gt; “搜题历史页” -&gt; “题目详情页1” -&gt; “名师大招”。 设计原则 易用性 可靠性 方案分析考虑到上述两个设计原则，路径转换在每个页面中的使用都不应该受限于其相对于其他页面的位置或关系。简而言之，即具备独立性和通用性。以view controller为例，路径转换在特定的生命周期阶段使用，就是符合设计原则的。 以下有两种方案：基于栈的设计、基于多叉树的设计。下面依次进行分析。 1. 栈下图所示为两个View Controller切换时，各个VC的生命周期的切换顺序，其中A为父VC，B为子VC。为了遵循上述设计原则，我们希望能够在特定生命周期进行push/pop操作。合法的push/pop组合应该遵循如下的调用顺序：1A push -&gt; B push -&gt; B pop -&gt; A pop 然而，我们在下图中找不到一个合法的push/pop组合，除了【init/viewDidLoad时push，dealloc时pop】这种情况。 那么，在【init/viewDidLoad时push，dealloc时pop】是不是真能应对所有场景呢？ 试想如下图所示这样一种场景，当一个VC包含多个VC对象时，其中一个VC再调用子VC。这时候，我们期望得到的路径应该是：1A -&gt; D -&gt; E 然而在很多情况下，A会在init/viewDidLoad阶段初始化多有VC对象。这时候如果使用的是【init/viewDidLoad时push，dealloc时pop】这种组合，在E中得到的路径会是：1A -&gt; B -&gt; C -&gt; D -&gt; E 综合上述，使用栈结构很难实现一种易用、可靠的设计方案。 2. 树我们使用多叉树实现了一个易用、可靠的路径转换方案。如下左图所示，为一个app经常会面临的vc结构。我们使用多叉树来描述ap的vc结构。在任何时候，页面总是能够返回到根页面（tab页），所以树节点不会形成环，即可以使用树结构来进行描述，如右图所示。 其中，树节点包括四个属性：1234567@interface VGOKeyfromBaseNode : NSObject@property (nonatomic, weak, nullable) __kindof VGOKeyfromBaseNode *parentNode; // 父节点@property (nonatomic, strong) NSString *value; // 节点信息@property (nonatomic, strong) NSMutableArray&lt;__kindof VGOKeyfromBaseNode *&gt; *subNodes; // 子节点@end 为了能够维护多棵树，使用 VGOKeyfromTreeManager 进行管理，其包含两个属性：12@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof VGOKeyfromBaseNode *&gt; *keyfromTrees; // 存储各个树的根节点@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof VGOKeyfromBaseNode *&gt; *currentNodes; // 存储各个树的当前节点 以 keyfromNode 的类型名称作为 key，分别保存了树的根节点以及当前节点。 使用的方法是： 在viewDidLoad阶段，创建节点并加入树中。 在viewWillAppear/viewDidAppear阶段或者在进入新页面之前，将该节点设置为当前节点。 在dealloc阶段，将本节点的父节点设置为当前节点，并将该节点从树中删除。 树管理器的公有接口如下所示：1234567891011121314151617181920212223// 创建根节点- (void)createKeyfromTreeWithRootNode:(__kindof VGOKeyfromBaseNode *)node;// 设置节点为当前节点- (void)updateCurrentNodeWithNode:(__kindof VGOKeyfromBaseNode *)node;// 向树中添加子节点- (void)addNode:(__kindof VGOKeyfromBaseNode *)node;// 从树中删除子节点- (void)removeNode:(__kindof VGOKeyfromBaseNode *)node;// 获取从根节点到指定节点的列表- (NSArray&lt;__kindof VGOKeyfromBaseNode *&gt; *)nodePathToLastNode:(__kindof VGOKeyfromBaseNode *)node;// 获取从根节点到指定节点的列表，并进行过滤- (NSArray&lt;__kindof VGOKeyfromBaseNode *&gt; *)nodePathToLastNode:(__kindof VGOKeyfromBaseNode *)node exceptValue:(nullable NSString *)value;// 获取从根节点到指定节点的路径- (NSString *)keyfromPathToLastNode:(__kindof VGOKeyfromBaseNode *)node;// 获取从根节点到指定节点的路径，并自定义联结符号、过滤内容- (NSString *)keyfromPathToLastNode:(__kindof VGOKeyfromBaseNode *)node exceptValue:(nullable NSString *)value joinWith:(NSString *)join;``` 节点的公有接口如下所示： // 将本节点设置为根节点 (void)setAsRootNode;// 将本节点设置为当前节点 (void)setAsCurrentNode; // 将本节点添加至树中 (void)addToKeyfromTree;// 将本节点从树种删除 (void)removeFromKeyfromTree; // 清空本节点的所有子节点 (void)clearSubNodes; // 获取本节点类型的根节点 (__kindof VGOKeyfromBaseNode *)rootNode;// 获取本节点类型的当前节点 (__kindof VGOKeyfromBaseNode *)currentNode;// 获取本节点类型的 keyfrom 路径 (NSString *)keyfromPath;``` 实践证明，这种设计方案还能够非常简单地应用到一下这些场景之中。 view Controller、View混合路径； 统跳； view Controller多处复用、节点信息不同； 忽略路径中特定节点]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>路径转化</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《徐彬说投资》笔记]]></title>
    <url>%2F2018%2F02%2F23%2Fxubing-investment%2F</url>
    <content type="text"><![CDATA[几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记在这里 如何计算自己有多少钱可以用于理财？对于我们普通人来说，每个月能够剩余下来的钱（自由现金流）均可以用于理财。自由现金流计算公式如下： 自由现金流 = 收入 - 支出收入 = 劳动收入（工资）支出 = 必需支出（房租、房贷、生活费等） + 可选支出（娱乐费用） 因此，要想有多余的钱理财，必须保证自由现金流为正。如何保证自由现金流为正？两个方法： 开源：增加收入 节流：减少支出 很明显，自己容易控制的便是减少支出，其中可选支出可控程度是比较大的。 生活处处有风险，常见有两种风险可能会导致自由现金流为负：重大疾病、失业。为应对这两种风险，一般我们的措施是： 重大疾病：购买重疾险 失业：预存应急资金。假设失业以后6个月后必能找到工作。可以将6个月的总支出定为应急资金。应急资金需要充分利用，应该放在货币基金，风险相对较小。 一般而言，理财收入不能算入收入，各种奖金也不应该算入收入。通过上述公式便可计算出自己有多少钱可用于理财。 理财的基本概念在理财前，投资者需要了解一下这些概念： 任何理财产品都是具有风险的，而风险的本质便是波动。比如：股票价格的涨跌波动。 风险与收益成正比。另外还需要有充分的时间进行保障。 可投资标的：哪些资产可以在自己的投资期限内进行投资。 风险承受能力：评估可投资标的在投资期限内的最大投资亏损。很多投资亏损就是由于投资前没有评估好自己的风险承受能力，心态受到市场情绪影响导致的。 股票与债券我们都知道股票和债券，那么这两者是什么？有什么区别呢？ 一切要从价值分配模型说起，价值分配模型包含两部分，分别是劳动价值、剩余价值。 一般来说，一个公司的资本分为两类：债券、股票。相应的投资人也分为两类：债券投资人、股票投资人（股东）。公司将其运营产生的剩余价值通过债券、股票分配给投资人。 假设公司不用交税，一年挣了3千万（即剩余价值）。假设去年发行了一个亿3年期，每年利息10%的债券。那么公司的3千万，债券投资人拿走1千万（1亿 x 10%）。其他全部分给股票投资人。 如果一年收益1亿，债券投资人只能拿1千万，而股票投资人则可以拿9千万。 相比而言，债券投资人获取收益的优先级更高，收益比股票投资人更明确。即无论有多少剩余价值，都优先分给债券投资人。在上述例子中，债券的收益是每年10%。而股票的风险比较大，对应的收益也可能更高。 通常，大企业的优势是收益稳定，劣势是发展空间有限；中小企业的优势是发展潜力，劣势是收益。因此，大企业的债券比较可靠，股票的增值空间相对较小；中小企业的债券短期内不一定有收益，长期来看其股票增值空间相对较大。 关于股票，公司分配给股票投资者的价值有两种方式： 发放现金分红 股票价格上涨：如果公司在一段时间内的收益越高，希望投资的人越多，股票价格会变得越高。 货币基金如果投资期限为一年，最好的投资标的是货币基金，如余额宝。货币基金是公募基金的一种。货币基金有以下优点： 货币基金的门槛很低，一块钱都可以 货币基金的各种费用很低 风险极低 每天都有收益，包括节假日 货币基金非常灵活，买入后立刻产生收益。 货币基金往往在其他投资标的表现不好时，收益会更好。 货币基金主要有两个指标: 七日年化收益率：过去七天平均每天的收益如果持续一年可以产生的收益 万份收益：货币基金会保持每份一元的净值水平。因此，货币基金的总资产等于货币基金的总份数。每一万份货币基金，在过去一天产生的收益。 那么为什么货币基金风险很低？这是因为货币基金的投资标的是短期国债、中央银行票据、银行背书的商业汇票、银行承兑汇票、银行定存、大额可转让存单等。这些都是金融投资风险最低。另一方面，货币基金的管理要求非常高，如果基金经理的货币基金做亏了，基本职业生涯完了。所以，货币基金的风险非常低。 货币基金适合投资期限小于一年，随取随存的场景，对于应急资金和工资来说非常适合。我们平时所用的余额宝、活期宝便是货币基金。相对其它投资标的，货币基金收益也较低，一年的收益率大概为4%左右。 货币基金的4个投资技巧 季度末，半年末，年末，货币基金的收益率比较高。 关注央行的行为。其会影响金融市场的流动性。央行加息，提高存款准备金率，会造成市场的钱变少，从而提高货币基金的收益率。 当股市、债市表现不好时候，往往货币基金表现较好（目前市场共有616支货币基金）。 平时买规模大（5亿元以上）的基金，收益比较稳定。在季度末、年底买规模较小（2亿~5亿）的基金博取高收益。 银行理财与货币基金根据如下2017年的数据显示，理财产品的期限越长，予以的收益也越多。 银行活期存款利息：一年0.35% 一年期定期存款：一年1.5% 三年期定期存款：每年2.75% 通常，银行理财都是定期，且5万元起购，这与货币基金的差距较大。另一方面，货币基金的监管比银行理财更严格。网上也经常爆出银行理财的一些骗局，我们可以通过网上银行来进行真伪辨认。 国债逆回购国债逆回购，本质就是一种短期贷款。也就是说，个人通过国债回购市场把自己的资金借出去，获得固定的利息收益；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。 投资者通过股票账户即可投资国债逆回购，国债逆回购具有以下几个基本特点： 国债逆回购的门槛：上证交易所，金额必须是10万的整数倍；深证交易所，金额必须是1000的整数倍。 国债逆回购的价格：任何股票软件都可查询。 国债逆回购的收益：价格、实际占款天数（1、2、3、7）。 国债逆回购价格的规律：季度末、年末的利率较高。一般上午高于下午。 债券基金根据2006至2016的数据显示，债券基金平均每年的收益大约为7%。债券的本质是发行债券的机构向投资者借钱，债券基金的收益主要包含两部分： 利息 债券的价格波动 目前市场中的债券基金一共有1000多只。通常而言，债券基金和股票基金呈跷跷板效应，两者的表现是相反的。 通常不建议自选债券基金进行投资，其知识门槛较高。此外，债券基金进行为期1~2年的投资。长期投资债券基金必然是赚钱的。 债券涨跌原理在金融体系中钱多（收紧或加速流动性）的时候，债券就会上涨；反之，则下跌。 金融体系受两方面影响： 中央银行（中国人民银行，简称央行）货币政策：如加息降息 影响金融机构买债的监管政策 央行主要有两个职能：控制物价（通货膨胀CPI）、维持经济增长（GDP增长率）。如果发生矛盾，以第一项为准。当CPI突破3%，表示通货膨胀过快，需要注意；GDP增长率较低时是投资债券的好时机。 债券基金投资方法债券基金有一个指标——到期收益率，表示如果债券没有出现违约，每年的收益率。债券收益率越高，则债券的估值越低。如果在三年期AA+企业债到期收益率超过5%时，投资债券基金，则未来三年，每年收益率大约为8%~10%。 相关数据表明，长期投资债券基金，亏钱的概率极低。对于债券基金的投资有两个建议： 债券基金的到期收益率越高，投资债券基金赚得越多 债券基金应该越跌越买 什么决定了股票的价格前面说到股票投资者的收益主要有两部分：分红、 股票价格的变化。那么股票的价格是由什么决定的呢？股票的价格可以通过如下公式进行计算： 股票的价格 = 盈利（每股的盈利） *市盈率（每股市价与每股盈利的比率） 比如，某公司一年盈利1000万元，该公司有一亿股股票，则平均每股的盈利为0.1元。如果市盈率是10倍，即每1元的盈利能力是10元。通过公式计算得出，股票的价格为1元。 1元（股票价格） = 0.1（每股的盈利）* 10（市盈率） 因此，市盈率是衡量股票价格高低的重要指标。市盈率是由股票市场中所有的股票投资者决定的。在绝大多数情况下，投资者的情绪比较稳定，市盈率也比较稳定。在某些情况下，投资者的情绪会出现集体波动，在投资者投资情绪乐观时，市盈率偏高；投资情绪悲观时，市盈率偏低。 如何投资股票首先需要评估市场的情绪，乐观、平稳还是悲观？因为投资者的情绪决定了市盈率。有两种评估方法： 定量分析：分析历史数据进行总结，对于沪深300指数，市盈率为12-14倍是合理的；对于中证500指数，市盈率为30-35倍是合理的。高于则是乐观，低于则是悲观。 定性分析：观察财经媒体和大众市场的情绪。情绪乐观时会多买入，情绪悲观时会多卖出。比如：当很多不懂市场的投资者也在争相买入，则是非常乐观。 在了解市场情绪之后，只需要做到三点： 在市场情绪平稳时进行投资，但是不要把所有的前都投进去 在市场情绪悲观时，不仅自己不能恐慌，而应该鼓起勇气追加投资 在市场情绪乐观时，不应该追加投资，应该准备卖出 股票选择一般而言，优质、稳定的投资标的应该会产生持续、稳定的内生收益。公司的盈利、收益是内生收益的来源。股票投资最重要的收益来源就是内生收益。持续、稳定的内生收益会让投资标的有不断上涨的动力。但是在单只股票中寻找能够产生持续、稳定内生收益的股票非常难。 投资者可以通过市场表现来挑选股票，比如每半年对A股上市公司进行市值排名，只投资排名前300的公司。A股市场最常用的两个指数是：沪深300指数、中证500指数。前者包含A股中市值最大的前300家公司；后者包含市值排名第301至800的500家公司。一般排名靠前的大公司，内生收益比较低，稳定性较高，长期收益低。 相对而言，中证500指数包含的公司内生收益相对较高，稳定性一般。 50AH优选上证50指数：表示上海证券交易所上市的市值最大的50家公司。50AH优选指数：看上证50指数中哪些公司在大陆和香港同时上市，挑选价格便宜的进行投资。 根据2015至2017年数据显示，50AH优选指数跑赢了上证50指数8个百分数。因此，投资者也可以根据50AH优选指数来进行股票选择 基金的选择目前市场中共有3485只基金，其从投资标的上来分可分为三种： 货币基金 债券基金 股票基金：变数最大，主要是对比业绩基准。 根据管理方式来分类，基金可以分为两类： 被动管理型基金（指数基金）：其跟随沪深300指数。管理费较低，每年0.7%。 主动管理型基金：想尽一切办法打败业绩基准。研究员使用数据模型定量分析，管理费相对较高，每年1.5%。 国外一个惊人的理论：绝大多数主动管理型基金很难跑过大盘指数。然而，在中国则截然相反，这是因为美国绝大部分的投资者是投资机构。中国股市有大量的散户，投资机构很容易跑赢散户。在中国，主动型管理基金更好。港股和美股则相反。在中国，股票基金平均收益率约为20%，沪深300每年约为10%。 如何选择基金股票基金的收益有两个来源： 对标的股票指数的股票收益 股票基金跑赢股票指数的跑赢收益，即跑赢收益。跑赢收益是真正衡量基金经理能力的指标。 选择基金的完整流程： 第一步，选择未来会上涨的股票指数。只要股票指数的市盈率处于合理或偏低的水平，都可以选择。 第二步，在所有以这个股票指数为业绩基准，即对标的股票指数的股票基金里，选择跑赢收益比较高，且稳定性比较好的股票基金。量化基金的跑赢收益更低，稳定性更好。传统基金的跑赢收益更好，稳定性更差。 第三步，研究基金的策略，判断基金收益是否可持续。比如：通过基金经理访谈。 股票基金收益来源的“终极”公式 股票基金的收益 = 对标股票指数的收益 + 跑赢收益 股票指数是由若干股票组成，可以用于分析股票。每只股票都是一个公司的代表，绝大部分长期来说，其价值在不断提升。通常使用内生收益表示股票价值提升带来的收益。但是有内生收益不一定会带来投资收益。 股票价格的终极计算公式为，其中内生收益代表盈利的上升速度，长期来说内生收益都是正的。 股票价格 = 盈利 *市盈率 那么应该如何确定内生收益？沪深300指数的内生收益和名义GDP增速差不多，稍微高一点。名义GDP和统计局公布的GDP不是一回事，后者是实际GDP增速，前者在实际GDP增速的基础上加上物价增速（即CPI）。名义GDP更多的体现实际的经济发展，更适合描述企业收入和盈利的增长速度。中国的GDP大概维持在6-7%，CPI大概在2%，所以名义GDP大概维持在8-9%。因此，沪深300指数的内生收益大约8-9%（非客观）。 另一方面，市盈率会围绕着合理水平波动。投资者给出的价格水平，乐观时比较高，悲观时比较低。当市盈率回归到合理水平的过程中，产生的收益叫储备收益。因此，可以得到股票指数的收益的公式。 股票指数的收益 = 内生收益 + 储备收益 进一步得出股票基金的收益公式： 股票基金的收益 = 内生收益（经济发展） + 储备收益（投资者心理波动） + 跑赢收益（基金经理的能力） 定投定投：表示定期、定额地投资某一个理财产品的投资方式。这是一种兼顾省心、高收益的投资方式。其适用于长期投资。例如：每个月买1000元的公募基金。 定投为何会赚钱？这是定投可以大幅降低投资风险，只要坚持就能赚钱。定投期间如果基金曲线呈现微笑曲线，则必然是赚钱的，即定投第一定理。 定投是一种守株待兔的方式，经济是由周期的，只要耐心定投，就肯定能赚钱。 定投开始时机在低于市盈率合理值时投资。在沪深300市盈率14倍或中证500市盈率35倍以下可以投。 定投结束时机3个原则： 定投还没开始赚钱，永远不要考虑结束 只要股市估值还没有达到正常水平以上，就不要考虑退出。 当股市估值回到正常水平以上，应该跟随市场不断变化、计划卖出的点位，即止盈点。比如，当这轮行情市盈率跌倒最高点10%以下，止盈。 一个真实的定投案例3-5年长期的准备，定投。2011年开始，定投沪深300指数4年，总收益80%，平均每年收益15.2%。 分为七个阶段 2011年4月开始定投到A点，截止2011年12月27日累计亏损19%。从2011年4月开始，中国经济增长率从每年10%下调至8%。同时CPI很高，在2011年年终，达到了6%以上。央行通过加息来降低CPI。沪深300指数从2011年4月的3400点一路跌到年底的2300点，跌幅达到32%。 A点到B点，截止2012年5月累计盈利0.1%。从2011年底到2012年5月，沪深300指数从2300点反弹到2700点，赚0.1%。 B点到C点，截止2012年12月累计亏损17.5%。从2012年5月到2012年12月，沪深300指数开启长达8个月的下跌。从2700点跌至2100点，跌幅达到22%。创出了3年新低。 C点到D点，两年累计盈利8.7%。2012年12月5日的大涨，开启了一波小牛市。沪深300指数用了两个月一口气从2100点涨到了2800点附近，涨幅达到33%。 D点到E点，累计亏8.5%。2013年2月之后，沪深300指数开始调整，2013年6月开始从2600到2300，跌幅达到22%。2014年7月底，市盈率只有8.2倍，储备收益高达70%。 F点到完美结局，累计大赚80%。2014年7月到2015年6月，沪深300指数从2200点一路上涨到5380点，上涨幅度达到145%。 定投总共4年2个月中，有3年3个月是处于亏损状态。是否掌握一定的定投知识将决定成败。经济每五年一个周期，对应到股市就是每5年一个大牛市。定投就是抓住这5年一次的牛市。定投很有可能三年不开张，开张顶三年！ 如何做投资决策做投资决策前需要做到以下几点： 分析一笔钱可能出现的结果有哪几类？ 对每一种结果评估概率 对每一种结果给出一种应对措施 如果赚钱了是否止盈，什么时候止盈 如果亏钱了是否止损，什么时候止损 如果赚钱了是否追加投资，什么时候 如果亏钱了是否追加投资，什么时候 在投资前思考风险可以让我们在投资过程中保持良好的心态。另外，还需要评估好投资周期、盈亏幅度。 关于如何控制风险？这里也有两种参考方式： 选择一条移动平均线，一旦大盘跌破这条线就止损。根据历史数据显示，60天移动平均线是最优化的选择。 设定一个自己愿意接受的亏损比例，如10%。每天记录总资产额。当某天的总资产额比最高总资产额低10%时，可以止损了。 关于投资笔记投资笔记是执行投资、学习投资过程中一个非常重要且有意义的方式。投资笔记有以下优点： 投资笔记可以帮我们指定投资决策，包括分析过程，思考逻辑，决策分析。投资是不能随机应变的。这是因为，一方面，投资相对比较复杂，需要实现做好预案。另一方面，投资是逆直觉，逆决策的。 投资笔记可以更好地帮助我们复盘。比如在投资过程中哪些地方做对了，结果及其原因又是什么。通过投资笔记，可以对每一个节点的行为逻辑和心态，复盘结果，更重要的是原因。 投资笔记可以帮助我们获得更多的知识。 投资时需要掌握的重要数据投资标的一定是不停生长出价值的投资标的。 经济增长率：经济增长率分为两种：季度增长率、年度增长率。GDP同比前一年同期增长多少。绝对值。增长率。实现国家经济调控的部门是央行，其主要有两个职责：控制物价、促进经济增长。当两者冲突时，往往以第一个为主。物价增长率（CPI），中文学名：通货膨胀率。和GDP不同，CPI是每个月都公布的。如何解读CPI数据：在中国如果CPI达到3%以上，说明物价增长过快了。这时候央行会通过加息，提高存款准备金率等方法来收紧货币。如果CPI跌倒了1%以下，说明物价增长过慢，意味着经济比较低迷，这时候央行会通过降息、降低存款金率等手段来刺激经济。如果CPI处于1~3%为健康状态，央行一般不会进行干涉。GDP在6.5%是合适的；CPI在1-3%是合适的。经济增长率的数据由国家统计局公布，www.stats.gov.cn。GDP和CPI能够勾勒出四个不同的经济周期，见下文。 股票、债券方面的数据。 关于股票，A股共有3000多支股票，关注股票指数就够了，包括：上证50（超大规模）、沪深300（大规模）、中证500（中小规模）。平时需要关注着三个指数的盈利增长率和估值水平 估值水平：对于估值水平的描述一般用市盈率这个指标，对于上证50（10-12倍是合理的），对于沪深300（12-15倍是合理的），对于中证500（30-35倍是合理的）。如果低于，越跌越买；如果处理合理区间，继续持有；如果高于，原则上是不能追加，应该持有+设置好止盈条件等策略。 盈利增长率：必须等每个季度上司公司的财报都公布了以后才知道。与GDP类似，盈利增长的趋势比绝对值更加重要。如果盈利增长在减速，股市的增长水平（市盈率水平）就会下降。如果盈利增长在加速，市盈率就会上升。由于关注的是指数的盈利增长，而这些指数包含的公司都是整个经济体系中的中流砥柱，因此可以用GDP的增长趋势来估计指数盈利增长的趋势。 估值水平：每周六公众号公布；盈利增长率：可以用GDP估算。 债券 到期收益率：如果持有债券到期，并且借钱的机构没有耍赖不还钱的情况，投资者平均每年能赚百分之多少。不同期限，不同评级的债券的到期收益率都不一样。一般来说，关注三年期，AA+的企业债券的到期收益率就够了。只要这个数据高于5%，投资债券基金都是比较安全的，未来1-2年的收益也是比较可观的。 美林团队判断经济周期转折点的重点理论美林时钟理论：只用经济增长率（GDP增速）和通货膨胀率（CPI增速）两个宏观经济指标来描述复杂的经济周期。 运用美林时钟理论，在2006年至2016年，通过资产配置获得11.5倍的收益。全国房价平均每年的年化收益率只有8%。北京的房价平均每年的年化收益率15%。之所以房子赚钱，是因为房价稳定，愿意长期持，复利使得房子显得很赚钱。数据显示，资产配置如果做好了，可以比投资房产更赚钱。 美林时钟理论用到两个宏观经济指标：GDP增长率（描述经济增长速度），CPI增长率（描述通货膨胀速度） GDP增长率高、CPI增长率低：复苏期 GDP增长率高、CPI增长率高：过热期 GDP增长率低、CPI增长率高：滞障期 GDP增长率低、CPI增长率低：衰退期 1 -&gt; 2 -&gt; 3 -&gt; 4：美林时钟 复苏期：重仓股票基金（下一周期GDP仍高）。债券的表现不会差（一时半会不会加息，持有债券去赚利息），应该紧盯通胀，高通货膨胀来了应该减仓。 过热期：中国股市会快速、甚至疯狂上涨。股票继续持有。不应该持有债券基金。关注熊市出现。 滞涨期：股票基金表现不会，不应该持有。债券不太好。这个时期的目标是不亏钱。应该投资货币基金。 衰退期：其末期是特别好的抄底机会。重仓持有债券基金。密切关注股票基金。关注股票基金减仓机会。 （完）]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logos基础语法]]></title>
    <url>%2F2018%2F02%2F22%2Flogos-syntax%2F</url>
    <content type="text"><![CDATA[%hook 该指令指定需要hook的class，必须以%end结尾 123456%hook SpringBoard- (void)_menuButtonDown:(id)down &#123; NSLog(@&quot;Home Button Pressed&quot;); %orig; // call the original _menuButtonDown:&#125;%end %log 该指令在%hook内部使用，将函数的类名、参数等信息写入syslog，可以以%log([(&lt;type&gt;)&lt;expr&gt;, ...])的格式追加其他打印信息。 123456%hook SpringBoard- (void)_menuButtonDown:(id)down &#123; %log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;); %orig; // call the original _menuButtonDown:&#125;%end %orig 该指令在%hook内部使用，执行被hook的函数的原始代码。此外，还可以利用%orig更改原始函数的参数。 12345%hook SBLockScreenDateViewController- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2 &#123; %orig(@&quot;iOS 8 App Reverse Engineering&quot;, arg2);&#125;%end %group 该指令用户将%hook分组，便于代码管理及按条件初始化分组，必须以%end结尾。一个%group可以包含多个%hook，所有不属于某个自定义group的%hook都会被隐式归类到%group_ungrouped中。 12345678910111213141516171819202122232425%group iOS7Hook %hook iOS7Class - (id)iOS7Method &#123; id result = %orig; NSLog(@&quot;This class &amp; method only exist in iOS 7.&quot;); return result;&#125;%end%end // iOS7Hook %group iOS8Hook %hook iOS8Class - (id)iOS8Method &#123; id result = %orig; NSLog(@&quot;This class &amp; method only exist in iOS 8.&quot;); return result;&#125;%end%end // iOS8Hook %hook SpringBoard -(void)powerDown &#123; %orig; &#125;%end %init 该指令用于初始化某个%group，必须在%hook或%ctor内调用；如果带参数，则初始化指定的group；如果不带参数，则初始化_ungroupded。只有调用了%init，对应的%group才能起作用。 123456789101112131415#ifndef kCFCoreFoundationVersionNumber_iOS_8_0#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 #endif%hook SpringBoard- (void)applicationDidFinishLaunching:(id)application &#123; %orig; %init; // Equals to %init(_ungrouped) if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS7Hook); if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS8Hook); &#125;%end %ctor tweak的constructor，完成初始化工作；如果不显示定义，Theos会自动生成一个%ctor，并在其中调用%init(_ungrouped)。 123456%hook SpringBoard - (void)reboot &#123; NSLog(@&quot;If rebooting doesn&apos;t work then I&apos;m screwed.&quot;); %orig; &#125;%end 上述实例可以成功生效，是因为Theos隐式定义了如下内容：1234%ctor &#123; %init(_ungrouped);&#125; %ctor一般可以用来初始化%group，以及进行MSHookFunction等操作。%ctor不需要以%end结尾。12345678910111213141516#ifndef kCFCoreFoundationVersionNumber_iOS_8_0#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 #endif%ctor&#123; %init; if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS7Hook); if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) %init(iOS8Hook); MSHookFunction((void *)&amp;AudioServicesPlaySystemSound, (void *)&amp;replaced_AudioServicesPlaySystemSound, (void **)&amp;original_AudioServicesPlaySystemSound); &#125; %new 在%hook内部使用，给一个现有class添加一个新函数，功能与class_addMethod相同。注意，Objective-C的Category语法也可以给现有的class添加新函数。但区别在于category是静态的，class_addMethod是动态的。 123456%hook SpringBoard%new- (void)namespaceNewMethod &#123; NSLog(@&quot;We&apos;ve added a new method to SpringBoard.&quot;); &#125;%end %c该指令的作用等同于objc_getClass或NSClassFromString，即动态获取一个类的定义，在%hook或%ctor内使用。 (完) 参考 《iOS应用逆向工程（第2版）》 Logos]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Logos语法</tag>
        <tag>Theos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS逆向工程——基础篇]]></title>
    <url>%2F2018%2F02%2F06%2Fios-reverse-engineering-basis%2F</url>
    <content type="text"><![CDATA[iOS文件系统iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有一套标准的文件系统——Filesystem Hierarchy Standard（FHS），其常用目录结构如下所示： /：根目录 /bin：binary，存放用户级基础功能的二进制文件，如ls、ps等 /boot：存放能使系统成功启动的所有文件。iOS中此目录为空 /dev：device，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备。块设备以块为单位传输数据，如硬盘；字符设备以字符为单位传输数据，如调制解调器 /sbin：system binaries，存放提供系统级基础功的二进制文件，如netstat、reboot等 /etc：法语Et Cetera（and so on的意思），存放系统脚本及配置文件，如passwd、hosts。iOS中，/etc是一个符号链接，实际指向/private/etc /lib：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空 /mnt：mount，存放临时的文件系统挂载点。iOS中此目录为空 /private：存放两个目录，分别是/private/etc和/private/var /tmp：临时目录。iOS中，/tmp是一个符号链接，实际指向/private/var/tmp /usr：包含大多数用户和程序。 /usr/bin：包含那些/bin和/sbin中未出现的基础功能，如nm、killall等 /usr/include：包含所有的标准C头文件 /usr/lib：存放库文件 /var：variable，存放一些经常更改的文件，如日志、用户数据、临时文件等。 /var/mobile：存放了mobile用户的文件。逆向工程重点关注目录 /var/root：存放了root用户的文件 iOS独有目录下图所示分别是OSX和iOS的根目录结构，与FHS还是有一定的区别。 对于iOS，其独有的目录如下思维导图所示： /Applications：存放所有的系统App和来自于Cydia的App，不包括StoreApp /Developer：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录 /Developer/Applications /Developer/Library /Developer/Tools /Developer/usr /Library：存放一些提供系统支持的数据 /Library/MobileSubstrate/DynamicLibraries：存放Cydia安装程序的.plist和.dylib文件 /System/Library：iOS文件系统中最重要的目录之一，存放大量系统组件 /System/Library/Frameworks：存放iOS中各种日常使用的framework /System/Library/PrivateFrameworks：存放iOS中未公开的私有framework /System/Library/CoreServices/SpringBoard.app：iOS桌面管理器 /User：用户目录（mobile用户的home目录），实际指向/var/mobile，存放大量用户数据 /var/mobile/Media/DCIM：存放照片 /var/mobile/Media/Recording：存放录音文件 /var/mobile/Library/SMS：存放短信数据库 /var/mobile/Library/Mail：存放邮件数据 /var/mobile/Containers：存放StoreApp。 /var/mobile/Containers/Bundle：存放所有StoreApp的可执行文件和相关资源 /var/mobile/Containers/Data：存放所有StoreApp的数据，沙盒目录的真实目录 iOS应用（StoreApp）沙盒出于安全考虑，iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问）。 上图所示为沙盒结构，沙盒在逻辑上包含两个部分：Bundle Container和Data Container，两者在iOS文件系统中的位置是平行的，分别是/var/mobile/Containers/Bundle和/var/mobile/Containers/Data。实际开发中，通过NSHomeDirectory()方法获取到沙盒根目录对应的是Data Container的路径。 Bundle Containerbundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。 在正向开发时，我们上传至App Store的ipa（iPhone Application）包，解压后会有一个Payload目录，其内部又包含一个.app目录，这个目录就是一个App的目录结构，也是一个bundle。 Bundle Container位于/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/主要用于存放静态资源，主要包含以下目录和文件： MyApp.app 存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、.plist文件。这个目录不会被iTunes同步。 iTunesArtWork iTunesMetadata.plist Data ContainerData Container位于/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/，主要用于存放App运行时产生的动态数据，其主要包含以下目录和文件： Documents 存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录 Library Library/Caches 存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。 Library/Preferences 存放偏好设置。使用NSUserDefaults写的设置数据都会保存在该目录下的一个plist文件中。iTunes或iCloud同步设备时备份该目录。 tmp 存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。 在正向开发时，沙盒目录路径均有相应的获取方式，具体如下所示：123456789101112131415161718// 沙盒目录NSLog(@&quot;%@&quot;,NSHomeDirectory()); // MyApp.appNSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]); // DocumentsNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *docPath = [paths objectAtIndex:0];NSLog(@&quot;%@&quot;,docPath); // LibraryNSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);NSString *libPath = [paths objectAtIndex:0];NSLog(@&quot;%@&quot;,libPath); // tmpNSLog(@&quot;%@&quot;,NSTemporaryDirectory()); 在逆向工程中，可以通过以下方式获取相关的目录：123456// 获取App的Bundle路径iphone: root# ps -e | grep appname // 获取App的Data路径iphone: root# cycript -p appnamecy# directory = NSHomeDirectory() iOS二进制文件类型iOS逆向的目标主要包含三类二进制文件：Application、Dynamic Library、Daemon。 ApplicationApplication，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要： Info.plist Info.plist记录了App的基本信息，如：bundle identifier、可执行文件名、图标文件名等。 可执行文件 查看Info.plist，即可定位可执行文件 lproj目录 lproj目录下存放的是各种本地化的字符串。 系统App VS. StoreApp/Applications/目录下存放系统App（包括CydiaApp）；/var/mobile/Containers/目录下存放StoreApp。其区别在于： 目录结构 两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在/var/mobile/Containers/Data/下，以mobile权限运行的系统App的数据目录在/var/mobile/下，以root权限运行的系统App的数据目录在/var/root/下。 安装格式和权限 Cydia App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。 Dynamic LibraryDynamic Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。 在iOS中，lib分为static和dynamic两种，其中static lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。 dylib是逆向工程的重要目标类型，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。 越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。 DaemoniOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查/System/Library/LaunchDaemons和/Library/LaunchDaemons下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的Info.plist文件作用类似，即记录Daemon的基本信息。 (完) 参考 《iOS应用逆向工程（第2版）》 File System Programming Guide iOS底层基础知识-文件目录结构 iOS APP沙盒目录 Mac OS X 术语表 了解iOS上的可执行文件和Mach-O格式 由App的启动说起 Mach-O 可执行文件]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
        <tag>沙盒原理</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代浏览器工作原理（一）]]></title>
    <url>%2F2018%2F01%2F21%2Fbrowser-architecture-overview%2F</url>
    <content type="text"><![CDATA[序这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了…框架？不是针对特定需求的框架，介绍起来感觉也没有太大的意义… 恍惚间，想起之前@展哥在调高考真题Hybrid页面时，似乎在前端代码方面遇到一些麻烦。于是，我就想到了UIWebView。就此进行思维发散，感觉可以介绍一下浏览器的工作原理。毕竟，iOS和前端同属于大客户端。对于iOS的同学，也算是对知识面的扩展吧。 于是，我查阅了一些与浏览器原理相关的资料。在这个过程中，找到很多优秀的资料。但是，大多数资料的组织结构，不是特别清晰。因此，我想借此机会，结合参考资料，来重新梳理一下浏览器的原理。由于浏览器的结构非常复杂，一篇文章想介绍清楚，真的太难。本文将使用总-分-总的形式，使用一系列文章来进行介绍。如有纰漏，欢迎纠正。 浏览器历史1990年，蒂姆·伯纳斯·李开发了第一个网页浏览器WorldWideWeb，后改名为Nexus。WorldWideWeb浏览器支持早期的HTML标记语言，功能比较简单，只能支持文本、简单的样式表、电影、声音、图片等资源的显示。 1993年，马克·安德森领导的团开发了一个真正有影响力的浏览器Mosaic，这就是后来世界上最流行的浏览器Netscape Navigator。 1995年，微软推出了闻名于世的浏览器Internet Explorer。 1998年，Netscape公司开放Netscape Navigator源代码，成立了Mozilla基金会。 2003年，苹果公司发布了Safari浏览器。 2004年，Netscape公司发布了著名的开源浏览器Mozilla Firefox 2005年，苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目WebKit（Safari浏览器的内核）。 2008年， Google公司已WebKit为内核，创建了一个新的浏览器项目Chromium。以Chromium为基础，谷歌发布了Chrome浏览器。至于这两者的关系，可以简单地理解为：Chromium为实验版，具有众多新特性；Chrome为稳定版。 浏览器特性现代浏览器的特性主要包含如下几部分： 网络 浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。 资源管理 浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。 网页浏览 浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。 多页面管理 浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。 插件和扩展 现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。 账户和同步 现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。 安全机制 现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。 开发者工具 开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。 浏览器结构目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构： 浏览器的抽象分层结构图中将浏览器分成了以下8个子系统： 用户界面（User Interface） 用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。 用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。 浏览器引擎（Browser Engine） 浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。 浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。 浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。 浏览器引擎还允许查询/修改渲染引擎设置。 渲染引擎（Rendering Engine） 渲染引擎为指定的URI生成可视化的表示。 渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。 渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。 渲染引擎内部包含HTML解析器。 网络（Networking） 网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。 JavaScript解释器（JavaScript Interpreter） JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。 XML解析器（XML Parser） XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。 显示后端（Display Backend） 显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。 数据持久层（Data Persistence） 数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。 这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。 渲染引擎浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用： 渲染引擎 浏览器 Trident IE、Edge Gecko Firefox WebKit Safari、Chromium/Chrome 渲染引擎工作流程如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。 Parsing HTML to Construct DOM Tree渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。 Render Tree construction渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 Layout of Render Tree渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。 Painting Render Tree渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。 渲染引擎组成模块下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。 从图中可以看出，渲染引擎主要包含（或调用）的模块有： HTML（XML）解析器 解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。 CSS解析器 将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。 JavaScript解释器 使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。 布局 DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。 绘图 使用图形库将布局计算后的渲染树绘制成可视化的图像结果。 总结本文介绍了浏览器的主要特性以及抽象结构，并选择其中最为核心的渲染引擎进行了介绍。渲染引擎是浏览器中最为复杂的部件，后续将对渲染引擎中的各个模块依次进行介绍。 （完） 参考 Web Browser-Wikipedia Adam Barth, Collin Jackson, Charles Reis, Google Chrome Team. The Security Architecture of the Chromium Browser. Andre Campos, Bryan Lane, Neal Clark, Sunpreet Jassal, Stephen Hitchner. Conceptual Architecture of Firefox. Alan Grosskurth and Michael Godfrey. A case study in architectural analysis: The evolution of the modern web browser. 主流浏览器内核介绍（前端开发值得了解的浏览器内核历史） 朱永盛. 《WebKit技术内幕》. 浏览器的工作原理：新式网络浏览器幕后揭秘 Alan Grosskurth, Michael W.Godfrey. A Reference Architecture for Web Browsers.]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>浏览器原理</tag>
        <tag>渲染引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年总结]]></title>
    <url>%2F2018%2F01%2F02%2F2017-summary%2F</url>
    <content type="text"><![CDATA[这几天，脉脉上有一个年度总结的活动。2017年，我对自己的总结便是一个字——变。 关于论文毕设2017的上半年是我硕士生涯，也是我学生生涯的最后一个学期。这半年真的是一直处于焦虑中，毕业总是令人如鲠在喉。有人可能会问硕士毕业有这么难吗？如果我说我们是在毕业答辩前两个月才开的题你信吗？ 关于毕业论文，我是经历过换题的。研二期间，一直在做碳纳米管计算机项目。然而，到了毕业选题的时候，才发现这个项目根本没有可深入研究的、与计算机体系结构相关的东西。不得已，只能换题。此时，恰逢2016年的10月，校招还在如火如荼地进行。而我已经没有心情继续找工作了。 2017年年初，@易老师给了我一个毕业选题的大方向——RISC-V &amp; TLB &amp; 安全。参考往年类似的毕业选题（如：@天一师兄、@翁东旭师兄的毕业论文），我大致规划出了毕业论文的框架。然而，往年论文的相关实验都是基于完整的项目平台，研究及评测环境相对来说都是比较完备的。我的毕业选题采用的实验平台则是基于RISC-V的开源处理器生成器——Rocket Chip Generator，该平台是2014年由UCB推出的，其研究及评测环境都还不完善，不足以提供标准且完整的论述、验证、评估的能力。 为了让论文能有更多的干货，我还去探索了TLB/MMU在安全方面研究的可能性。不过，这个想法在后来的预开题中被否决了。好在，预开题时，@佟老师给了我很多的建设性的意见，比如：研究Generator自动化生成硬件的原理、Chisel原理等。我能够在6月份顺利毕业，真的要感谢我的导师@佟老师、@易老师，在毕设期间予以我的帮助和建议。 关于科研项目2月底春季的开学阶段，我提前了一周回了学校。因为，在做毕业的同时，我还要和物理电子所的同学对接碳纳米管项目。为了能让项目顺利结题，春节前后和@海涛师兄、@司佳师姐、@东维师弟一起忙活了一段时间。项目最后顺利结题，也算是了却了一桩心事。在4月份左右，@彭老师、@程老大又来了一次巨头会议，要在北大120周年献礼。也就是说，碳纳米管项目继续进行。当然，我知道自己不能继续跟进，便把工作交接了@李宁师妹和@东维师弟了。希望明年的五四，能给大家带来一个惊喜。 关于毕业答辩3月底，实验室进行了开题答辩会。这个开题时间放眼整个北大，也算是晚的了。不知道@老大作何感想，可能真的是日理万机吧。不过，从开题答辩会上老大的表述，能看出@老大对于我们这一届还是抱有歉意，希望我们都能顺利毕业。 6月2日，毕业答辩会如期进行。答辩会上有校外专家，当我们有遇到答不上的问题或被专家刁难的时候，@老大能够及时救场，果然护犊子！手动点赞！结果是显而易见的，所有人都顺利毕业。 答辩过后，和@小威威、@大帅、@赵璐、@昊泽去了南门翅客吃了烧烤，果然是前所未有的轻松。 关于毕业旅行6月3日是我们的发出时间，一个月前订机票时也是非常忐忑，毕竟答辩时间是6月2日，就怕答辩时间更改。关于毕业旅行的详细内容，可以看这里。 关于毕业典礼毕业旅行回来，能感受到浓厚的离别气息。拍毕业照、毕业典礼、谢师宴…从今往后，同窗同门都要各奔东西。 关于工作校招时，我投递的岗位是前端开发工程师，后来HR跟我沟通有没有转岗iOS开发工程师的意愿。在考虑了几天后，我选择了转岗。我当时的想法是这样的： 前端的门槛比较低，从业人员比较很多，想真正脱颖而出还是比较困难的，感觉硕士毕业从事前端的优势并不大。 前端的技术更新迭代速度太快，没有一个统一的行业标准，不同的公司可能采用完全不同的技术栈。所以，前端岗需要不断地学习，一旦松懈，可能就会被淘汰，压力比较大。 程序员都知道所谓的“程序员鄙视链”，前端是处于“鄙视链”的下游的。虽然前端已经今非昔比了，但是总的来说，职业天花板比较低。 出于这些考虑，我选择了转岗。 7月初，办完了毕业手续，我和@撸神便搬家到了我们的整租房。在学校呆了20年，离开时真的很不习惯。 7月10日，在紧张和期待中办理了入职手续。期间，遇到了校友@家骏、@仲雪。中午，我的mentor@展哥接待了我，然后便组织大家在云海肴来了一波TB。 @展哥已经有7年的工作经验了，作为小猿搜题iOS端负责人，他的技术能力的确是很强的。作为mentor，他也是尽心尽力，真的非常nice。相比于我在某度的mentor，真是不知道高到哪里去了，无论是技术能力，还是个人修养。然而，没想到@展哥年后要离职，真的有点不舍啊。 我工位的右边是@展哥，左边是@琳洁——一位iOS程序媛。她虽然话不多，但是只要有问题，她都能悉心指导我。而且做事特别细致，从code review就能看出来。 我的leader@邱瑞，也是我的校友师兄。为人非常nice，说话语气很平和，平时分配任务、交谈时完全没有一种上下级的感觉。对于产品需求的评估、事务的处理都是非常到位。 有人说：想要在职场上快速成长，可以尝试学习你领导的做事方式。我个人非常赞同这种观点，希望新的一年，我能够像@展哥、@邱瑞、@琳洁他们一样做人做事。 关于技术上半年写的代码基本都是服务于毕业设计，都是与硬件相关。下半年学的都是工程相关： 在编程语言方面，学习了两门新的语言：Objective-C、Swift。 在版本管理方面，能够熟练使用git的各种常用命令。 在项目管理方面，了解了公司的项目管理流程以及敏捷开发模式，自己还搭建了Gerrit代码审核服务器。 关于阅读2017年1月1日，我计划开始记录自己的阅读轨迹，其实主要原因是希望能够督促自己保持阅读（阅读轨迹在这里）。2017年总共阅读了不到10本书。希望新的一年，在阅读时能够有更多的自我思考，尽可能产出一些读书笔记。虽然，我读书的时候喜欢使用有道云来做笔记，但是缺少整理、总结和发布。 展望对于公司来说，都会有年度目标，这样公司才能够健康成长。对于个人也是一样，给自己定一个目标，希望能够激励自己成长。2018年伊始，我也想给自己定一些小目标。 至少看完两个iOS开源框架源代码（向大神靠拢） 至少看12本书，非工具类的书，需要有读书笔记（向@巧叔学习） 在技术方面，能够hold住产品经理提出来的所有需求（向@琳洁@展哥学习 在业务方面，了解小猿搜题的所有业务代码（向@邱瑞@琳洁@展哥学习）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH 协议实践]]></title>
    <url>%2F2017%2F12%2F27%2Fssh-protocol-practice%2F</url>
    <content type="text"><![CDATA[SSH概述类似于HTTP，SSH（Secure Shell）是一种加密的网络传输协议，常用于加密远程登录。 1995年，芬兰赫尔辛基理工大学的塔图·于勒宁因为发现自己学校存在嗅探密码的网络攻击，设计了一套保护信息传输的程序，即Secure Shell（简称SSH），其目标是取代先前的rlogin、Telnet、FTP、rsh等安全性不足的协议。如今，最为广泛使用的OpenSSH便是SSH协议的一种免费开源实现。 基本原理SSH使用非对称加密算法实现身份验证，即采用公钥-私钥对来进行加密网络连接。私钥由用户（本地主机）自行保管，公钥由远程主机（如：服务器）保管。 应用实践下面使用OpenSSH进行具体实践。 SSH协议语法格式SSH主要用于远程登录，如下所示为SSH协议的语法格式。1ssh [&lt;username&gt;@]&lt;server&gt;[:&lt;port&gt;] 关于SSH公钥认证为实现公钥认证，作为认证的客户端一方需要拥有两个文件，即公钥-私钥对。一般公钥-私钥对文件创建在用户的主目录下的.ssh目录中。如果用户主目录下不存在.ssh目录，说明SSH公钥-私钥对尚未创建。 创建公钥-私钥对1$ ssh-keygen 该命令会在用户主目录下创建.ssh目录，并在其中创建两个文件： id_rsa：私钥文件。是基于RSA算法创建的。 id_rsa.pub：公钥文件。 分发公钥创建了公钥-私钥对后，需要将公钥交给远程主机保管，这样才能在之后的登录实现无口令登录。如下命令，会将.ssh目录下指定的公钥文件拷贝至远程服务器。1$ ssh-copy-id -i .ssh/id_rsa.pub &lt;user&gt;@&lt;server&gt; 该命令会提示输入用户user在server上的SSH登录口令 此命令执行成功后，再以user用户用ssh命令登录server远程主机时，不必输入口令可直接登录 该命令实际上是.ssh/id_rsa.pub公钥文件拷贝到远程主机server的user主目录下的.ssh/authorized_keys文件中，内容类似如下：1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHJu4oVxIbLS2LBH5wI7htvDxuIMZ5IFUaZjbWI8z...M4yGEWcr7OVPdQa4DIEbrrl8MzsAZ baochuquan@baochuquandeMacBoo k-Pro.local 关于SSH主机别名在实际应用中，有时需要使用多套公钥/私钥对。然而，上述创建公钥-私钥对的命令只会生成默认名为id_rsa的密钥对。 创建公钥-私钥对为了创建不同的公钥/私钥对，在使用ssh-keygen命令时就需要通过-f参数指定不同的私钥名称。用法如下：1$ ssh-keygen -f ~/.ssh/&lt;filename&gt; 命令会在.ssh/目录下创建指定的公钥/私钥对：文件&lt;filename&gt;是私钥，文件&lt;filename&gt;.pub是公钥。 分发公钥将新生成的公钥添加到远程主机登录用户主目录下的.ssh/authorized_keys文件中，就可以使用新创建的公钥建立到远程主机的账户的无口令登录：1$ ssh-copy-id -i .ssh/&lt;filename&gt;.pub &lt;user&gt;@&lt;server&gt; 在有多个公钥/私钥对时，默认使用~/.ssh/id_rsa.pub。那么如何使用新建的公钥连接server呢？ 管理本地私钥SSH的客户端配置文件~/.ssh/config可以通过创建主机别名，连接主机时选择用指定的私钥。例如/.ssh/config文件中的下列配置12345678910111213141516171819# 使用默认的id_rsa私钥Host gerrit.zhenguanyu.com Hostname gerrit.zhenguanyu.com Port 29418 User baocq # 使用指定的chuquan01私钥Host chuquan user root hostname 115.28.167.128 port 22 identityfile ~/.ssh/chuquan01 # 使用指定的gerrit01私钥Host gerrit user gerrit hostname 115.28.167.128 port 22 identityfile ~/.ssh/gerrit01 无口令远程登录执行下面的SSH登录命令，即可登录Host为chuquan的主机：1$ ssh chuquan （完） 参考 Secure Shell SSH原理与运用（一）：远程登录 SSH原理与运用（二）：远程操作与端口转发 《Git权威指南》，蒋鑫]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>公钥/私钥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu + Gerrit + Apache 搭建代码审核服务器]]></title>
    <url>%2F2017%2F12%2F12%2Fubuntu-gerrit-apache%2F</url>
    <content type="text"><![CDATA[我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容… 一、Gerrit介绍Gerrit的目的是提供一个轻量级的框架来review每一个commit，review通过之后，commit会被合入代码库。 Gerrit是一个中间区域，可以看到提交至Gerrit上的代码相对于服务器代码仓库中代码的差异，从而便于检查代码的改动。Gerrit也是整个代码review的推动者。 任何拥有多个成员的团队都应该有一个中央代码仓库。 Git在理论上可以在没有这样的中心位置的情况下工作，但实际上通常有一个中央仓库库作为项目实际内容的权威副本。 开发者从该中央仓库fetch和push Gerrit被部署在上图的中央仓库的位置，并增加一个新的概念：a store of pending changes（未决的修改）。每个人仍然可以从中央仓库fetch，但是push操作则有所变化，push操作会直接push到中央仓库，而是push到了pending changes location，以供review。只有在commit通过了review之后，才会被submit到中央仓库。如下图所示。 Gerrit具有强大的访问控制模型。用户可以被授予访问权限，绕过review，直接推送到中央仓库。Gerrit甚至可以在没有代码review的情况下使用，只用于托管仓库和访问控制。 二、应用场景在安装gerrit之前，我使用node在服务器上部署了一个站点，也就是本博客，其占用了80端口。 在安装gerrit之后，我的服务器又将多出一个站点，用户该如何访问？我又该如何部署呢？这时候，我们就需要了解一下反向代理和端口转发了。 1. 正向代理与反向代理如下所示为正向代理和反向代理的示意图。一般来说，我们会把正向代理是与客户端划为一体，把反向代理和服务器划为一体。 此时，重新思考一下我们的应用场景：博客是一个web服务器，gerrit是一个web服务器，apache作为反向代理，这样就可以满足我们的需求了。 那么反向代理到底是如何做到的呢？答案就是端口转发。 我们知道在浏览器输入网址后，它会在解析后的IP地址之后加上一个默认的端口号80。所以，我们访问chuquan.me时就不需要输入完整的地址chuquan.me:80了。正因为如此，绝大多数服务器软件（包括apache）的默认监听端口也是80。 在安装了apache之后，80端口被apache占用了。因此，gerrit和博客都不能使用80端口了。这时候，我们需要给这两个站点配置使用其他的端口号，如：gerrit的HTTP协议使用8081端口，博客使用8082端口。它们与apache之间使用端口转发来实现反向代理。 三、开发环境 Ubuntu 14.04.5 LTS Java 1.8.0_151 Git 1.9.1 Apache/2.4.7 四、安装Gerrit1. 新建专用用户新建一个用户来专门管理Gerrit相关内容。在root用户下新建一个gerrit用户。12$ adduser gerrit$ su gerrit 2. 下载Gerrit安装包Gerrit下载地址：https://www.gerritcodereview.com/releases/2.14.md 我安装的Gerrit版本是2.14.6。在Linux环境下使用wget进行下载，最终得到一个war包，位于/home/gerrit/目录下。1$ wget https://gerrit-releases.storage.googleapis.com/gerrit-2.14.6.war 3. 安装Gerrit在/home/gerrit/目录下，进行安装：1$ java -jar gerrit-2.14.6.war init -d review_site 上述命令会在当前目录下创建一个review_site目录。接下来就开始进行对话式安装，我们可以直接回车，表示采用默认安装选项。之后还可以通过配置文件进行详细配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*** Gerrit Code Review 2.14.6****** Git Repositories *** Location of Git repositories [git]: *** SQL Database *** Database server type [h2]: *** User Authentication *** Authentication method [OPENID/?]: http Get username from custom HTTP header [y/N]? SSO logout URL : *** Email Delivery *** SMTP server hostname [localhost]: SMTP server port [(default)]: SMTP encryption [NONE/?]: SMTP username : *** Container Process *** Run as [gerrit]: Java runtime [/usr/lib/jvm/java-7-openjdk-amd64/jre]: Copy gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war [Y/n]? Copying gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war *** SSH Daemon *** Listen on address [*]: Listen on port [29418]: *** HTTP Daemon *** Behind reverse proxy [y/N]? Proxy uses SSL (https://) [y/N]? Subdirectory on proxy server [/]: Listen on address [*]: Listen on port [8080]:*** Plugins *** Installing plugins. Install plugin download-commands version v2.11 [y/N]? Install plugin reviewnotes version v2.11 [y/N]? Install plugin singleusergroup version v2.11 [y/N]? Install plugin replication version v2.11 [y/N]? Install plugin commit-message-length-validator version v2.11 [y/N]? Initializing plugins. No plugins found with init steps. Initialized /home/gerrit/review_site... 安装完毕，Gerrit会自动启动，不过我们大概率会启动失败，因为默认的配置并不一定与你当前的环境相匹配。不过，没关系，我们可以根据系统环境对gerrit进行配置。 4. Gerrit配置Gerrit安装完成后，会在review_site目录下生成多个目录。123456789101112131415$ ll review_site./../bin/cache/data/db/etc/git/index/lib/logs/plugins/static/tmp/ 其中etc/目录下存放着gerrit的配置文件gerrit.config，其中已有的内容是根据安装时的选择生成的。我们可以编辑gerrit.config来进行配置更改。其中115.28.168.118是服务器的公网IP地址。123456789101112131415161718192021222324[gerrit] basePath = git serverId = 084efaf9-3bf6-401c-a4b1-8778c998bde2 canonicalWebUrl = http://115.28.168.118 # 指定web访问Gerrit的网址或IP地址[database] type = h2 database = /home/gerrit/review_site/db/ReviewDB[index] type = LUCENE[auth] type = HTTP # 默认是OPENID，改成HTTP后，才能通过浏览器进行访问[receive] enableSignedPush = true[sendemail] smtpServer = localhost[container] user = gerrit javaHome = /usr/lib/jvm/java-8-oracle/jre[sshd] listenAddress = *:29418[httpd] listenUrl = proxy-http://115.28.168.118:8081/ # HTTP代理地址及端口，这里我们配置成8081[cache] directory = cache 四、配置Apache不同系统以及不同版本的Apache的配置文件可能会不一样，无外乎两种：httpd.conf、apache2.conf。本环境的配置文件是apache2.conf。12$ cd /etc/apache2/$ vim apache2.conf 在配置文件的末尾添加apache的端口转发配置。如下所示1234567891011121314151617181920212223242526272829...# Blog相关配置&lt;VirtualHost *:80&gt; ServerName www.chuquan.me # 用于Apache过滤检测的域名 ServerAlias chuquan.me ProxyPass / http://115.28.168.118:8082/ # Blog正向代理转发的端口 ProxyPassReverse / http://localhost:8082/ # Blog反向代理转发的端口&lt;/VirtualHost&gt;# Gerrit相关配置&lt;VirtualHost *:80&gt; ServerName gerrit.chuquan.me # 用户Apache过滤检测的域名 ProxyRequests Off ProxyVia Off ProxyPreserveHost On &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; &lt;Location /login/&gt; AuthType Basic AuthName &quot;Gerrit Code Review&quot; Require valid-user AuthBasicProvider file AuthUserFile /home/gerrit/review_site/etc/passwords &lt;/Location&gt; AllowEncodedSlashes On ProxyPass / http://115.28.168.118:8081/ # Gerrit正向代理转发的端口 ProxyPassReverse / http://115.28.168.118:8081/ # Gerrit反向代理转发端口，应该与ProxyPass一致&lt;/VirtualHost&gt; 五、服务重启Apache和Gerrit配置（当然也包括blog的端口）完之后，我们需要重启服务，包括apache、gerrit，其重启命令分别如下：1$ /etc/init.d/apache2 restart 12$ cd /home/gerrit/$ ./bin/gerrit.sh restart 1. Gerrit启动失败在执行重启Gerrit的命令后，shell很可能会出现如下的信息：1Starting Gerrit Code Review: FAILED 我在安装过程中页出现了这个问题，于是，我通过在./bin/gerrit.sh脚本中的首行添加了一个-x选项，以打印脚本执行的相关信息。12#!/bin/sh -x... 然后再执行该脚本，发现打印信息是一组循环信息。其中，当TIMEOUT的值递减至0时，启动失败。 经过调研发现： Gerrit启动慢是因为java程序启动慢，导致Gerrit启动非常慢，大概需要10分钟左右，而默认的超时时间（TIMEOUT）是90秒，导致一直提示“Starting Gerrit Code Review: FAILEDStarting Gerrit Code Review: FAILED”。对此有如下两种解决方案。 第一种解决方案是：修改java的java.security文件。首先，根据gerrit.config中配置javaHome = /user/lib/jvm/java-8-oracle/jre，找到并进入该目录，然后再进入lib/security/目录，修改java.security文件。将securerandom.source=file:/dev/random改为securerandom.source=file:/dev/urandom。由此，解决gerrit启动慢的问题。 第二种解决方案是：在gerrit.conf文件中的[container]字段下增加`startupTimeout = 900。 2. 反向代理异常当我们配置结束并重启之后，在浏览器中访问很有可能会得到如下的页面： 这个页面在安装过程中，出现次数不下于10次。主要是两种情况，一种是Gerrit配置文件和Apache配置文件可能配置有误。另一种情况是配置没有生效，需要多试试重启。 3. 创建第一个Gerrit账户当所有问题解决完之后，通过浏览器访问Gerrit，将不会出现上面的Error界面，而是会弹出输入对话框，需要你填写账户和密码。 这时候，我们需要为Gerrit创建一个账户，默认第一个创建的账户是管理员。12345$ touch /home/gerrit/review_site/etc/passwords$ htpasswd /home/gerrit/review_site/etc/passwords &quot;admin&quot;New password:Re-type new password:Adding password for user root 重启服务后，再用浏览器打开，登录后就出现久违的界面了！ （完）]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git rebase与merge的区别]]></title>
    <url>%2F2017%2F10%2F10%2Fgit-rebase-merge%2F</url>
    <content type="text"><![CDATA[Git场景在基于Git版本控制的团队协作开发中，当同伴先于自己将新的提交push到远程分支上时，如果要想将自己新的提交push的远程分支，则需要先执行git pull来获取同伴的提交，如果有冲突则先处理完冲突，然后才能将自己的提交push到远程分支。这种情形是非常常见的。 然而执行git pull，在默认情况下，如果远程分支与本地分支的提交线图有分叉（即不是fast-forward，如上述这种情形），git会执行一次merge操作（即相当于执行了git pull --merge），而这会产生一次没有意义的提交记录。久而久之，项目的提交线图会非常混乱，其中会有很多由merge生成的无意义提交。 解决方案为了避免这种情况的出现，在将提交push到远程分支之前，我们一般会执行如下命令：1$ git pull --rebase 通过上述命令，Git会采用rebase策略来代替默认的merge策略。从而避免生成无意义的提交。 分析对比这时候，我们可能就会想：既然merge操作会生成无意义的提交，那它是不是没有什么价值了呢？是不是任何场景下都应该使用rebase操作？ 所以，我们对rebase和merge进行分析和对比。了解清楚了两者的区别，我们才能更好地运用这两个策略。 场景设想假设在执行pull之前的提交线图如下所示： Merge操作如果执行git pull（git默认会执行git pull --merge），提交线图会变成如下所示： 分析提交线图中多出了一个没有必要的提交H Rebase操作如果执行git pull --rebase，提交线图会变成如下所示： 分析提交线图中，本地的新提交F，G变成了两个新的提交F&#39;，G&#39;，拼接在了C后面，多余的分叉也删除了。提交线变得非常清晰。 小结从上述对比可以看出，rebase操作会将本分支的新提交删除并生成新的提交。所以rebase操作比较适用于将一些零碎的提交进行合并清理。比如：在push之前进行整理。 那么merge操作意义何在呢？ merge操作与rebase操作相反，它可以保留了提交线图的分叉，并生成一个新的提交。这种场景适合用于大的分支合并。这样，我们可以在提交线图中看到项目开发迭代过程中经历过哪些feature分支等等。 注意如果执行merge操作之前，提交线图是分叉的（即不是fast-forward，如场景设想的情形），执行git merge操作，是会达保留分支的目的。 但是执行merge操作之前，提交线图不是分叉的（即是fast-forward，如下上图所示），此时执行git merge操作的效果如下下图所示，分支是不会保留的。 在fast-forward情况下进行合并，我们需要执行如下命令来保留分支。执行后的提交线图如下所示。1$ git merge --no-ff （完）]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>merge</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在入职两个月之际]]></title>
    <url>%2F2017%2F09%2F17%2Fgraduated-for-two-month%2F</url>
    <content type="text"><![CDATA[学生生涯结束至今已有两月有余，偶尔还是会念想在北大那些瞬间，好在入职的公司在各方面都非常令我满意，不至于用怀念来解忧生活。 关于工作 说说现在的公司吧，一家处于成长期的K12在线教育创业公司——猿辅导，坐落在阜通站旁的利星行中心。公司主要有粉笔网、猿题库、猿辅导、小猿搜题等几款在线教育App。 7月10日刚入职，我被安排到小猿搜题研发部的iOS开发岗。作为一名无任何iOS开发经验的应届毕业生，我的压力还是蛮大的，毕竟这对我来说是一个全新的挑战。好在我的同事们都非常nice，尤其是我的mentor——展哥，还有坐我旁边的元老级程序媛——琳洁。每每我在学习以及开发过程中有任何问题，他们都会不厌其烦地给我讲解，真的非常感谢他们！相比我之前实习的那家公司（某度），就同事间的关系来说，真是不知道高到哪里去了。 我们研发部研发人员大概不到20人，4个iOS，3个安卓，5个后台，3个前端，3个测试，当然其中也有些人前后端都做，小组内同事大都是硕士以上学历。研发部内部分为三个小团体：产品、客户端、服务器端。iOS、安卓、测试共同组成一个客户端，组内气氛每天都很欢乐，不至于每天工作得很压抑。 公司的工作制度也是比较和谐的。朝十晚七，不打卡，无KPI，不提倡加班。每天上午会有一个几分钟的站会，每个人说一下自己前一天的任务完成情况，以及当天的任务安排。我们平时也没有那么多的会，除非PM有新的产品需求，并且不提倡大家携带笔记本开会，从而提高开会效率。在某度，几乎每天都有各种会议，开会的时候大家基本都会携带笔记本，自己干自己的事。过多的会议真的会严重碎片会工作时间，降低工作效率。在某度实习期间，一个月的代码量都不如我现在一个星期的代码量。 周二下午我们小组会对PM提出的产品需求汇集、拆分，并进行难度评分，最后予以分配。站会也是就是对这些任务进展的汇报及安排。如此一套Scrum开发流程，可以极大地提高我们的工作效率。工作效率高了，也就没有必要加班了，生活也不是那么枯燥乏味了。 入职两个月以来，我能感受到自己的成长非常大。真正的项目实践总是能让你对一些东西有更深入的理解，比如git、gerrit等。公司对于项目管理使用了很多开源的工具，并进行了重组。希望在之后的日子里，我能对这些工具平台也有更深一步的了解。 关于生活 女票家给她在塘溪津门买了一套房，首付30%，2.2w/平米。接下来由我们两来还房贷，我每个月还贷1w，房租3k多，虽说生活还没到捉襟见肘的地步，但是能省则省吧。公积金也准备提出来了，只有这样，生活还能够多出一些积蓄来。当自身背负了如此沉重的房贷后，事业的发展总是会受到一定的影响，在面临选择的时候，会变得格外谨慎、犹豫，未来的我也许也会面临这样的情境。 该吐槽的还是要得吐槽。政府现在真的是把人往绝境里逼，虽说出台了一套又一套的房价抑制政策，然而所谓的政策只不过是稳定人心的幌子，韭菜该割还是要割，房价只是减速增长而已。房价的增长比工资的增长还快，买不起房的人永远都买不起房。 今年北京市的高考状元接受采访时的言论真的是一针见血。在教育方面上，他们享受着农村孩子无法想象的资源优势，进入名校对他们来说只是水到渠成的问题。事实上，在北大求学期间，我也意识到这个问题：周围的同学，尤其是本科生，大多数的家庭要么是高识分子，要么是高收入家庭，农村而来学生真的很少。现在社会频频出现学生入学如调查家庭背景的案例，很明显，学校在区分学生家庭所处的社会阶级，这样的情况在未来还会继续蔓延。富人越富，穷人愈穷，下一代亦是如此，阶级的固化正在酝酿。也许我们这一代还有不少能从底层往上爬，但后来的人真的将越来越难… （完）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 分支模型]]></title>
    <url>%2F2017%2F09%2F10%2Fgit-branching-model%2F</url>
    <content type="text"><![CDATA[我们公司的软件产品迭代采用的是scrum敏捷开发流程，代码使用git进行版本管理。在新人最初的几次开发任务中，我对于git的使用也仅限于一些基本的命令，包括：add、commit、rebase、cherry-pick、push、checkout等等。直到有一天，我发现远程分支上存在着一些历史feature分支，这对于我这个初入职场的小白来说还是有些好奇：feature分支在本地建立不就行了吗？为何还需要推送到远程仓库？带着这一些列的疑问，我仔细研究了一些我们基于gerrit的code review流程，终于明白了为何会有feature远程分支。这一切都与git的分支模型有关。期间，我在一个英文博客上看到了一篇关于git分支模型的介绍，看完后觉得不错，对其进行简要地整理，以呈现给大家。 分权集中下图中心的仓库，是我们建立并在使用的仓库，具有分支模型，其通常会被认为是“真正的中心仓库”。然而，事实上，其仅仅是被认为是中心仓库而已，因为git作为一个分布式版本控制系统（DVCS），在技术层面并不存在哪个仓库是中心仓库。而这个被认为是“中心”的仓库，我们更愿意称之为origin，这个名字对于所有git用户都是很熟悉的。 每个开发者都会从origin进行pull或向其进行push操作。但是除了与origin具有push-pull关系之外，开发者们还可能从其他同级的伙伴那里pull最新的改动，从而形成一个sub team。比如，对于两个以上的开发者，在过早地向origin推送开发进展之前，其可以开辟一个新的feature分支来共同工作。如上图所示，存在着这样几个开发小组：Alice &amp; Bob，Alice &amp; David，Clair &amp; David。 从技术角度而言，这仅仅意味着Alice定义了一个远程仓库，名字是Bob，其指向了Bob的仓库，反之亦然，仅此而已。 主分支归根到底，开发模型也受到了上述思想的影响。在中心仓库中，在其无限的生命周期中，始终存在着两条主分支： master develop 大家对origin上的master分支应该并不陌生。而另一个与之平行的分支，我们称之为develop分支。 origin/master：在这个分支上，源代码的HEAD指针的指向始终都是就绪/可发布的产品状态。 origin/develop：在这个分支上，源代码的HEAD指针的指向始终都是下一个版本的产品状态。 当develop分支的源代码到达某一个可发布的稳定点时，所有的改动都应该合并到master分支，然后打上版本的tag标签。 因此，每次将改动合并至master分支时，意味着一个新版本的诞生。我们往往对这个过程控制得非常严格。所以每次master分支上有commit时，我们都应该使用git hook脚本来自动编译、发布软件至产品服务器上。 支持分支与主分支master、develop相邻的则是各种支持分支，用于帮助团队成员之间进行平行开发，跟踪功能，准备产品发布以及帮助修复在线产品的一些Bug。与主分支不同，这些分支总是具有有限的生命周期，因为它们最终都是要被删除的。 我们可能用到的几种不同的支持分支： Feature分支 Release分支 Hotfix分支 上述的每一个分支都具有特定的目的，并且必须遵守严格的规则。比如：哪些分支可以是它们的源头分支，哪些分支必须是它们的合并目标。 当然，从技术角度来说，这些分支并没有什么特殊之处。所谓的分支类型只是我们根据如何使用它们而进行分类的。 Feature分支规则： 可以源自develop分支必须合并到develop分支命名：除master，develop，release-*，hotfix-*之外 Feature分支（也称：topic分支）用来为即将发布的版本或更远的版本开发新的feature。当开发一个新的功能的时候，我们不知道这个功能会被纳入哪个目标版本。Feature分支的本质就是，只要该功能处于开发阶段，feature分支就会存在，并最终会被合并至develop分支（以确保将新功能添加到即将发布的版本中）或者丢弃（在实验失败的情况下）。 Feature分支通常只存在与开发者自己的仓库中，而不是origin。 创建feature分支当开始开发一个新的功能时，需要从develop主分支中开辟一个新分支。1$ git checkout -b myfeature develop //表示切换到一个新的分支“myfeature” 将完成的功能纳入develop完成的功能可以合并至develop分支，以加入即将发布的版本之中。1234$ git checkout develop //切换至develop分支$ git merge --no-ff myfeature //$ git branch -d myfeature //删除myfeature分支$ git push origin develop –no-ff选项会在合并分支时创建一个新的commit对象，即使合并可以是一次fast-forward操作。这可以避免丢失feature分支的历史存在信息，并将该feature分支上的所有commit放在在一起。 如上图所示，相比较而言，后面一种情况是不可能从git历史记录中看到哪些提交对象一起实现了一个功能，你必须手动读取所有日志信息。在后一种情况下，恢复整个功能（即一组提交）是非常困难的，而如果使用了–no-ff选项，则很容易实现。 当然，这会创建一些空的commit对象，但收益远大于成本。 Release分支规则 可以源自develop分支必须合并到develop分支和master分支命名：release-* Release分支用于支持准备新的产品版本，它们允许对版本进行小错误修复和元数据准备（版本号，构建日期等）。通过在Release分支上进行所有这些工作，develop分支会被清理以接收下一个大版本的功能。 当develop分支达到了新版本的期望状态时，即可从develop分支开辟新的release分支。当然，必须要等到所有待发布的功能合并至develop分支之后才可以。 正是在release分支的开始，即将发布的版本会被分配版本号。直到这一刻起，develop分支“下一个版本”的改动。但是“下一个版本”会变为0.3还是1.0，需要等到release分支开始才知道。这是在release分支开始时，由版本规则决定的。 创release分支Release分支从develop分支创建而来。例如，1.1.5版本是当前的产品版本，我们即将有一个大的版本。develop已经为“下一个版本”准备就绪了，并且我们已经决定这将成为1.2版本（而不是1.1.6或2.0）。所以我们开辟一个分支，并予以相应的版本号。123$ git checkout -b release-1.2 develop å$ ./bump-version.sh 1.2 $ git commit -a -m "Bumped version number to 1.2" 结束release分支当release分支的状态已经准备好成为y一个真正的版本，需要完成一些操作。首先，将release分支合并至master分支（master上的每一个commit都是一个新的版本）。然后，master上的commit必须被打上标签，以便参考历史版本。最后，将在release分支上作出的改动合并到develop分支上，以便未来的版本还包含这些错误修复。 12345678910// step 1$ git checkout master å$ git merge --no-ff release-1.2// step 2$ git tag -a 1.2// step 3$ git checkout develop$ git merge --no-ff release-1.2// 完成后，我们可以将release分支删除$ git branch -d release-1.2 Hotfix分支规则 可以源自develop分支必须合并到develop分支和master分支命名：hotfix-* Hotfix分支与release分支非常相似，其也是用于为新的产品版本做准备，尽管是计划之外的。它们是对发布版本的不良状态作出的回应。当产品版本中的一个关键bug必须要被修复时，可以从master分支上相应的tag标签中开辟一个hotfix分支。 Hotfix分支的本质是可以使develop分支上的工作得以继续，而另外有人进行bug修复。 创建hotfix分支Hotfix分支从master分支创建而来。例如，1.2版本是当前产品的版本号，正在在线运行，由于服务器bug出现了一些问题。但是develop分支上的改动还不稳定。我们需要开辟一个hotfix分支来进行bug修复。 12345$ git checkout -b hotfix-1.2.1 master$ ./bump-version.sh$ git commit -a m "Bumped version number to 1.2.1"// 修复bug并commit$ git commit -m "Fixed server production problem" 结束hotfix分支当完成bug修复之后，hotfix分支需要合并到master分支，当然也需要合并至develop分支，这与release分支是非常相似的。 123456789// step 1: 合并至master，打上版本标签$ git checkout master$ git merge --no-ff hotfix-1.2.1$ git tag -a 1.2.1// step 2: 合并至develop$ git checkout develop$ git merge --no-ff hotfix-1.2.1// step 3: 删除hotfix分支$ git branch -d hotfix-1.2.1 这里有一个例外需要注意，当一个release分支当前还存在时，hotfix分支的修改应该合并至release分支，而不是develop分支。因为release分支完成后，需要合并至develop分支。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>分支模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS View Controller概览]]></title>
    <url>%2F2017%2F08%2F27%2Fios-viewcontroller-introduce%2F</url>
    <content type="text"><![CDATA[引用 在斯坦福CS193p课程中，白胡子老教授首先介绍了iOS开发中的MVC软件设计模式，这是因为iOS应用即采用此种设计模式。如下图所示，MVC模式将软件分为三个部分： Model：数据存储层 View：视图展示层 Controller：逻辑控制层 MVC模式隔离了视图层和数据层，两者必须以控制层作为中介实现交互和通信。实际的iOS应用一般都是MVC模式的嵌套组合实现，如下图所示。其中，控制层是由UIViewController类及其子类（如：UITableViewController、UINavigationController、UITabBarController）的实例实现的。UIViewController自带一个根视图层（即view属性），以便添加和操作用户自定义的视图层。当然，我们也可以在UIViewController中定义数据层。这是因为UIViewController需要这样的接口来连通并控制M和V。但是，好的设计会尽量将数据层和视图层从UIViewController中解耦分离出来。 视图控制器 分类前面说到，实际的app采用MVC嵌套组合的设计模式，以此为据，app中至少包含一个视图控制器。这些视图控制器管理着app中所有的事务，包括：视图管理、事件处理、视图控制器之间的调度等等。 既然视图控制器具有可以嵌套和组合，那么肯定有部分视图控制器可以充当视图控制器的容器。事实上，视图控制器的确可以分为以下两种： 内容视图控制器（Content View Controller）：用于管理app内容的视图控制器，也是最常用的视图控制器。 容器视图控制器（Container View Controller）：作为其他视图控制器的容器，并以某种方式呈现这些视图控制器及其内容。 内容视图控制器内容视图控制器是最常用的元素，常见的有三种（后两者是前者的子类）： UIViewController UITableViewController UICollectionViewController 常用的在大多数情况下，app上的一个页面就是由一个视图控制器所展现的。内容视图控制器的主要任务包含： 更新视图内容，通常是响应底层数据的变化 响应用户与视图的交互 缩放视图、管理布局 容器视图控制器容器视图控制器使用属性viewcontrollers来存储对视图控制器的引用，并且不对容器中视图控制器的数量作限制。最常见容器视图控制器的有两种（两者均是UIViewController的子类）： UINavigationController UITabBarController 关于viewcontrollers属性，UINavigationController采用的是stack结构，UITabBarController采用的是array结构。不同的数据结构，对视图控制器的调度形式也不同。 下图所示为UINavigationController的应用示例，UINavigationController采用stack的方式调度页面（即视图控制器）。 三个视图控制器视图的顶部是UINavigationController的导航栏，当切换到某个内容视图控制器时，导航栏的样式可以由该视图控制器进行配置。 下图所示为UITabBarController的应用示例，其对页面的调度和操作array一样灵活，视图的底部有四个标签，对应着4个独立的视图控制器，可任意切换。 视图管理视图管理器，顾名思义，其有一个重要的作用就是：管理视图的层次结构。每个视图控制器都有一个根视图，其中包含了视图控制器的所有内容，可通过view属性获取。通过该属性，我们可以添加更多视图。内容视图管理器自身管理其所有的视图；容器视图管理器则采用分治的方式，通过子视图控制器来进行视图管理。下图所示，代表性地展示了内容视图控制器及其视图之间的关系。 数据管理在MVC设计模式中，视图控制器作为承担着数据和视图通信的中介角色。通过UIViewController的内置及自定义的属性和方法，可以完成控制器需要承担的任务。如下图所示，为视图控制器与数据、视图的关系示意图。 在实际开发中，我们始终应该清晰地分离视图控制器和数据对象。视图控制器应该扮演逻辑控制的角色，而应该减少数据管理的角色。 为了处理数据管理，很多设计使用了MVVM的设计模式，这种设计添加了一个View Model层来对来自Model层的原始数据进行处理，从而提供给Controller，使其可以直接使用。 生命周期如下图所示为视图控制器的生命周期，其中与视图view相关的步骤较多。 init init阶段，通常只初始化比较关键的数据，而不会在该阶段对view进行初始化。 loadView loadView阶段，通常只初始化view viewDidLoad 此时view不在为nil，适合创建一些附加的view及控件。 viewWillAppear 该阶段view即将被添加到app的window对象之上。 viewDidAppear 该阶段view已经被添加到app的window对象之上，用户可以看到软件的视图，此时可以进行动画操作。 为了进一步了解添加到根视图view上的用户附加视图，我分别在loadView和viewDidLoad阶段添加了一个视图，以观察视图控制器的生命周期，如下所示，为部分代码示例。123456789101112131415161718- (void)loadView &#123; [super loadView]; NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd)); UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(100, 400, 100, 50)]; button.backgroundColor = [UIColor blueColor]; [button addTarget:self action:@selector(buttonPressed) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd)); self.testView = [[TestView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)]; self.testView.backgroundColor = [UIColor grayColor]; [self.view addSubview:self.testView];&#125; 下图为UINavigationController中的一个视图控制器生命周期执行情况。生命周期符合前面的描述，此外还可以发现，在视图控制器中添加自定义的视图，则生命周期中还会多出两个步骤： viewWillLayoutSubviews viewDidLayoutSubviews 仔细观察，还可以发现: viewWillLayoutSubviews和viewDidLayoutSubviews均出现在viewWillAppear之后。在添加视图的时候，每添加一个视图就会执行这两个步骤，而移除视图时直接移除根视图直接移除根视图。 (完)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIViewController</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业旅行——泰国]]></title>
    <url>%2F2017%2F06%2F16%2Ftailand%2F</url>
    <content type="text"><![CDATA[Day 06月3日，周六昨天下午顺利通过硕士论文答辩，必须得感谢各位老师和同学们这三年的关照才得以顺利毕业，和大家相处的三年是非常快乐的。 今天是辩结束后的第一天，三年来从未像此刻一样如此轻松。遂准备本次泰国之行最后的相关事项，即如何去机场啊、酒店机票的订单截图啊之类的。 机票的时间是21:55，晚饭过后在未名湖畔小散了一会儿步，便启程出发，差不多8点多达到首都T2航站楼。 我们在淘宝上订了泰国的7天Happy电话卡，发货方式是机场自取。自取的地点是在国际航班出发点的某个柜台，然而我们去泰国的航班并不是直达，而是从昆明转机至清迈，显然首次航班是国内航班。电话给淘宝客服，居然还不能送出来，也罢，取消了订单，到当地再买happy卡吧。 接下来又发生了一件意想不到的事情：取机票时，柜台说妹纸机票的订票姓名拼音与护照不符，WTF？！打开东航APP上的订单，居然还真拼错了！尴尬！遂致电客服，客服说会尽快修改，但不保证在确定时间内完成。没办法，只能等。离办理值机只剩不到二十分钟了，心情自然也是极度忐忑。遂再次致电客服，客服确认了好几便，说姓名的拼音是正确的，看来是改好了。最终也是有惊无险地办理了值机，顺利登上了飞机。有了这次遭遇，下次应该就长心眼儿了吧。 Day 16月4日，周日首趟航班差不多凌晨1点达到昆明，下机后先找值机柜台，这个点柜台都已经下班了，需要等到凌晨五点。我们航班的时间是6:30，按照值机时间是来得及的。于是便寻找游客休息室，然而大厅中已经全是游客，更气的是不少人一个人占了多个座位在睡觉，不少人席地而坐，素质啊素质。 席地打盹，好不容易熬到5点，便去值机柜台办理值机。没想到办理国际航班的值机服务，不仅要查看护照、签证，还要查找在目的国的酒店订单信息，返程机票以及钱包里的现金。所幸除了现金还需再取，其他的我们都符合要求。昆明机场的确也是非常大的，据说是东航的大本营，果不其然，机场上一排排的飞机基本都是东航的。 第二趟航班差不多经历两个多小时，抵达清迈。刚下飞机没多久，手机时间便自动调整为了泰国时间，比北京时间早1个小时整。清迈机场真心非常小，国内随便找个机场都不知道要比它高几个档次。机场大厅里各个角落的指示牌居然同时有三种语言：泰语、英语、汉语，中国游客对于清迈旅游产业的影响可见一斑。 出了机场，便致电给平那科酒店，以寻求接机服务。学了那么多年的英语，从这一刻开始初见成效了。大约十分钟，接机小哥便来到了机场，下车便用很流利的中文跟我确认身份，我们一度以为他是中国人。地图上，平那科酒店与机场的直线距离只有几公里，然而实际却拐了很多弯才到达酒店，这是因为泰国的很多道路是单行道，正是这单行道后面也让我们吃了不少苦。 抵达平那科酒店大概是在泰国时间的上午8点多，由于一晚都没睡，总感觉现在是下午。Check in的时候，前台小哥便用流利的中文和我们交谈，说房间需要等到12点才会有，可以让我们先把行李寄存在前台，出去玩一会儿。遂即我们便出门去找711超市买happy卡。 由于时间还非常早，我们便打算打乱一下计划，逛一逛宁曼路街区。泰国的环境真的非常好，空气里透露着一股泥土的气息，蓝天和云彩的配合简直完美。 差不多到了中午，我们就近找了一家餐馆就餐，点了心心念念的芒果糯米饭和泰式酸辣海鲜河粉。第一次吃到芒果糯米饭的时候，汗毛都竖了起来，这糯米真的是入口即化！事实证明，这家店的芒果糯米饭是我们在泰国吃过的所有芒果糯米饭中最赞的！唯一遗憾，没记住店名… 饭后便回酒店准备办理入住。环顾酒店大厅，其装潢还是相当不错的。 前台告诉我们行李都已经搬进了房间，对此我是震惊的。在这一方面，国内同样价格的酒店可没这个待遇。我们订的房间大约200多一晚，房间的设施非常完备，吹风机、冰箱、热水壶、电视、衣柜什么都有，性价比非常高。房间的空间很大，装修也是简约大方，不多说，推荐推荐！ 这一天真实特别漫长，当然也是非常累，回房便是洗澡睡觉。恰好老天爷眷顾，外面开始下起了阵雨，等到三点左右我们醒来，雨也停了，气温也降了，给力呀！ 遂即按照计划步行去古城，路上遇到些水果摊显然是管不住自己的手的，榴莲、芒果、红毛丹，买买买。 酒店到古城西门大约2公里，期间我们还晃悠进了一个公园，似乎是个马戏团，外面还摆着演出广告。就这样边吃边看边走，最终大概花了1个小时才到达古城。 今天是周日，古城内会有周日夜市，这也是我们今晚来古城的原因。我们到古城内的街道时，小贩们已经开始陆续占领街道，支帐篷，挂吊灯，备战夜市。 显然小吃是我们此行的重要任务。 穿着拖鞋从酒店走到古城，着实累脚。路中央，一位马杀鸡小哥在盛情揽客，于是就此躺了半小时，腿脚也是满血复活。不吹不黑，马杀鸡，好牛逼！ 夜幕降临之前，我们尽可能地多逛逛古城。最后来到一个广场，这似乎是古城的行政中心。 夜市的吊灯陆续被点亮，游客也越积越多。我们沿着夜市，边吃边逛，挑选购买看上眼的异国小商品。差不多到7点半，我们回到了夜市的入口，搭了辆Tuk-Tuk，回到了平那科。 Day 26月5日，周一平那科酒店是提供早餐的，从8点提供至10点。酒店的一楼大厅便是自助餐厅，餐厅的布局很漂亮，有室内餐桌和室外餐桌。食物也非常丰盛，主要以西餐和泰式菜为主。 安静地享受完早餐，便托前台小哥帮忙租辆摩托车。五分钟后，租车小哥便风尘仆仆地赶来了。用蹩脚的英语与小哥聊了聊，签了合同，抵押了护照，然后预支了一天的租金300B。小哥还提醒我，归还摩托车时需要加满油，need be full，need be full。第一次开摩托，既兴奋又紧张，戴好头盔，便以每小时30公里的速度飞奔古城，游览泰国的知名寺庙。 我们在古城内依次逛了帕辛寺、清迈寺、契迪龙寺等寺庙。说实话，这些寺庙的风格基本上是一致的，只是规模和颜色稍有差别。 很快就到了中午，借着谷歌地图我们来到了大众点评上口碑不错的Mogo Tango餐厅。该餐厅以甜食和冰淇淋为主，平嘴而论，口味对得起评分，可以可以。 因为我们预定了下午一点半去素贴山玩，所以没在餐厅久留，吃完便回酒店睡午觉。 大概一点半左右，导游和司机便来接我们。导游的中文很不错，长得很像张家辉，很可惜没和他合影。 此趟行程的第一站是位于素贴山最高峰的蒲屏皇宫。蒲屏皇宫有点类似于国内的承德避暑山庄，都是皇室避暑的行宫。蒲屏皇宫里面种满了各种花草，环境也是相当的静谧，显然是个避暑好去处。 素贴山的下一站便是双龙寺，这里导游给我们讲了讲双龙寺的来历，并参观了里面的一个舍利塔。在这里可以鸟瞰整个清迈，是一个非常值得推荐的旅游景点。 半日游结束后，导游便送我们回来。我们在宁曼路的玛雅购物中心下了车。玛雅购物中心应该是清迈最大的购物商场，有6层，内部设施非常现代化。我们在这里找了一家游客较多的餐厅就餐。在这里，第一次品尝了正宗的泰国菜。泰国菜，特别是汤类菜肴，基本都会放香茅。这玩意儿味道很重，吃起来就像在吃化妆品，真心不符合中国人的口味。 Day 36月6日，周二7点起床，早早地便在餐厅吃完了早餐，然后就是等待导游来接我们去拜县一日游。拜县位于清迈西北方向100多公里，地处山区，一趟行程就要经历700多个弯道。对此，我们不仅准备了晕车药，还有晕车贴。一路上，不仅上下颠，还左右晃，难受得无法形容。没多久，minivan里就有游客交代了早餐。在车上煎熬了40分钟平地和2小时山路，终于抵达拜县。 此次拜县之旅一共有8个景点，我们去了其中的7个。首先是小树屋。 其次是二战桥。 二战桥之后便是草莓园。 随后抵达小黄屋，据说是《爱在拜城》的取景地，我表示没看过… 午饭前终于达到了期待已久的大树秋千。 等大家都排完队与大树秋千合影之后，便来到了“中华饭店”就餐，肘子、青菜豆腐汤、醋溜土豆丝…几道菜而已。据说此地是云南村，此地大量土著都是华裔，解放时期国共内战，很多人逃离至此。导游本人也是在泰国的华裔二代，所以中文说得溜也是有原因的。 午饭过后在饭店附近玩了玩土著的射箭。稍事休息，便再次踏上旅程。之后依次游览了粉色房子、倒立屋、农场。 差不多下午两点，景点游玩到此结束。然后便是回清迈，又是经历700多个弯。在我看来，拜县就是那种去一次再也不想去的地方，来回1400多个弯！。在快离开山区时，我们在路边买了芒果。半斤重的一个大芒果，折合成人民币仅需1元！买不了吃亏，买不了上当！ 差不多四点多，我们到达玛雅购物中心。从玛雅购物中心步行至平那科酒店大概需要20分钟，在回酒店的路上，看到街边有家店叫“我爱冬阴功”，看着似乎还不错，便进去点了餐。 Day 46月7日，周二在清迈这几天每天都是起早，今天准备放松一下，自由发挥。吃完早餐便租了摩托车，准备从古城西边出发，经过北部，再至东部，最后从古城东门穿越古城返回。清迈的道路真的令人很痛苦，大量的单行单，我们从古城东北角南下时基本都是在单行道上逆行。 好不容易在中午抵达古城，在一个寺庙对面找了家餐馆就餐，一份芒果糯米饭，一份冬阴功汤。期间，又下起了太阳雨。好在我们吃完，雨也停了。 清迈的下午艳阳高照，我们还是决定回酒店等到傍晚再出来。待到6点多，我们赶到古城北部的凤飞飞猪脚饭餐馆，毕竟这家店也算是名声在外。 Day 56月8日，周三凌晨4点起床，因为要赶6点50的航班，飞往甲米。在前台刚刚退完房，门口的送机小哥就迎了上来，非常准时，靠谱！为了感激小哥半夜起床给我们送机，我们也给了他20B，以示感激。 出了甲米机场之后，便步行了大概300米，来到minivan的候车点。大约1点半，minivan准时出现在候车的凉亭前面。Minivan中已经是满满一车人了，我们坐在最后面，虽然长途奔波很是难受，但是相比于拜县的旅程真的无比轻松了。行车1个半小时后便来到了兰塔岛的海峡入口处，经历半小时的车船联运后，抵达兰塔岛。司机依次运送乘客，我们车船联运后20分钟抵达CoCo Lanta Resort。 到达酒店，前台便是热情招待，递上两杯橙汁。CoCo Lanta的房间都是一个个的独栋小别墅。我们入住时发现只有很少的游客入住了，也许是淡季的原因吧。说实话，我们当时是有些后悔来到兰塔岛的。因为与清迈相比，这里显得十分凄凉，酒店附属的酒吧处于休业中，泳池边的遮阳伞都是收着的，躺椅、泳池也没有人。 经过一天的奔波，再加上心理预期上的落差，当时的心情是非常低落的，晚饭也没不想去那个酒店的餐厅去吃，转而去了附近的一家711超市买了泡面，零食等。傍晚，在海边稍许逛了一会，心情也有所复苏。 Day 66月9日，周四早晨9点匆忙来到前台大厅，等待今天出海一日游的minivan。上了车之后没多久便来到了汽艇停靠的港口。港口中泊着一艘红色汽艇，汽艇上的工作人员都很酷，黑皮肤（当然是亚洲人）、黑墨镜、反鸭舌。 汽艇在驶出海湾过程中经过静谧美丽的兰塔红树林，导游说红树林里有猴子，但是我们运气不够好，没遇到。 大约10点，到达Talabeng岛。汽艇靠近海蚀洞穴，以便大家游至洞穴中去。 探索完海蚀洞穴后，汽艇来到了BUBU岛。在BUBU岛沙滩自由浮潜20分钟。 之后便前往奈岛，奈岛是这几个岛中最美的岛屿。 靠近奈岛近海处，导游便带领我们下海浮潜。浮潜了大约半小时，便上岸就餐。 午餐过后便是1个半小时的海滩休闲时光。 1点多，我们离开美丽的奈岛，前往MA岛和CHUEK岛，在汽艇上欣赏海岛屿风光。 汽艇在海上漂游时，偶然发现一片海域的水特别清澈，于是导游带领我们下海浮潜。这里的珊瑚礁特别美丽，由各种色彩斑斓的海鱼，还有海胆。可惜没有租用GoPro进行水下摄影。 一段美妙的浮潜之旅结束了本次出海。早晨汽艇从兰塔岛的东岸南下，返程从兰塔岛的西岸飞驰回港。 Day 76月10日，周五今天的计划是环岛游。早晨睡个懒觉起床，然后到海滩吹了一下海风。 到了10点半左右，从酒店租了辆摩托车，价格要比清迈便宜，只要200B一天。我们的目的是前往老镇吃海鲜。 CoCo Lanta Resort在兰塔岛的西岸中部，老镇则在兰塔岛的东岸南部。摩托一路狂奔，花了一个小时抵达老镇。我们寻找昨天同行游客推荐的Fresh Restaurant。餐厅很不错，架在海上。我们选了一个临海的餐桌就座。服务员递上菜单，菜单上菜品的价格相对北京的海鲜价位而言是比较便宜的。显然，来到海岛当然是点海鲜咯。 饭后，我们来到了餐厅旁边的小港口转了转。之后便前往兰塔岛最南部的灯塔，一路上的山路蜿蜒陡峭，并且道路边树林密布。随着行程的深入，道路原来越窄，车辆也没了。后来开到大路的尽头，还没到达灯塔，我们便掉头回去。昨天那位游客也说路上很阴森很可怕，的确属实。 傍晚照例先去了711超市，然后回来煮泡面。不同的是，今晚是在海边吃的泡面。看着日落，迎着海风，惬意的傍晚。 夜色渐浓，想到远离灯火的海边是绝佳的观星地点。于是，下载了一个“星空”APP，对照着星空寻找星座，狮子座、半人马座、室女座、天平座、大熊座（含北斗七星）、天蝎座… Day 86月11日，周六这是在岛上最后完整的一天，准备在海边度过。 早上来到海边，躺椅上有个五六十岁大爷主动与我们搭话：是中国人吗？之后便与他侃了起来，大爷还给我散烟，我委婉地拒绝了，后来便跟他推荐一些岛上的景点。直到11点，大爷包的车来了，海边这块地便被我占领了。 午饭过后，一直在海滩边躺着，期间还打了个盹儿。 直到下午4点多，海水逐渐退去，近海的礁石都显露了出来。此时是在浅海中玩耍的好时机。 临近黄昏，我们在酒店的餐厅点了一份冬阴功面、炒饭、炸软壳蟹，靠着栏杆，欣赏落日的余晖。 落日之后，便躺在海滩边的吊床中享受在兰塔最后的休暇时光。 Day 96月12日，周日今天将离开兰塔岛，早上去海滩看了最后一眼清晨的大海，将要离开时总会不舍，希望我们还能再见。 再见，CoCo。再见，Lanta。再见，Tailand。 (完)]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>自由行</tag>
        <tag>兰塔岛</tag>
        <tag>清迈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20个强大的Sublime Text插件]]></title>
    <url>%2F2017%2F05%2F12%2Fpowerful-sublimetext-pulgin%2F</url>
    <content type="text"><![CDATA[原文链接SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。这些非常棒的特性包括： 任意跳转（Goto Anything） 多重选择（multiple selections） 指令面板（command palette） 免打扰模式（distraction free mode） 分区编辑（split editing） 快速项目切换（instant project switch） …此外，你还可以随意地自定义更多功能。更重要的是，Sublime支持Mac、Windows和Linux等多种系统平台。 SublimeText本身已经非常强大，但是更棒的是还有大量的插件支持它，给它带来更强大的功能，这就是本文要讨论的内容。不多废话，让我们看看20个强大的SublimeText插件。 20 FTPsync 默认情况下SublimeText不具备FTP功能，如果你正在寻找能在你的SublimeText应用程序中使用的免费易用的FTP工具，你可以考虑FTPSync。这是一个非常简单的FTP同步工具，它可以控制上传目标的多重命名。 19 SASS Build SASS Build 是一个编写CSS的预处理器。这个插件可以帮助你妥善构建包括压缩选项在内的SASS文件。一旦你安装了这个插件，你可以很容易地通过按Ctrl+ B（MAC系统是 Command +B）来启动它。 18 Package Control 简而言之，这个是你在完成安装SublimeText后必须安装的东西。因为有了这个特殊的“插件”，你可以很容易地安装、升级、删除，甚至非常方便地查看你已经安装在SublimeText中的包或插件的列表。它通过菜单和对应的行为使这些过程变得非常容易和有组织。 17 Emmet Emmet（前身是大名鼎鼎的Zen Coding）是一个可以让你更快更高效地编写HTML和CSS，节省你大量时间的插件。你只需按约定的缩写形式书写而不用写整个代码，然后按“扩展”键，这些缩写就会自动扩展为对应的代码内容。 比如，你只需要输入 ((h4&gt;a[rel=external])+p&gt;img[width=500 height=320])*12 ，然后它会被扩展转换成12个列表项和紧随其后的图像。然后你就可以在此基础上再填写内容，就这么简单。 16 SublimeLinter 这个插件最近才为SublimeText3重建和发布。新版本带来了很多新的功能，而不是简单地把所有的Linter放在一个包中，开发者允许用户在升级时选择并安装自己经常使用的Linter。很明显，这可以节省磁盘空间。“更多的定制”，这对用户是很友好的。 15 SublimeEnhancements 这个插件可以给SublimeText的边栏菜单带来扩充的功能，包括：在当前工程文件夹中新建文件，移动文件或文件夹，产生文件或文件夹的副本，在新窗口或浏览器中打开，刷新等。这只是概括地说，安装后探索它更多的功能吧。 14 PackageResourceViewer 通过这个特殊的插件，会给你查看和编辑SublimeText附带的不同的包带来很多方便。你也可以提取任何给定的包。这一行动将其复制到用户文件夹，以便你可以安全地对其进行编辑。 13 Git 虽然名字看上去并不友好，但作为开发者的你肯定一眼就能明白它是干什么的。这个插件会将Git整合进你的SublimeText，使的你可以在SublimeText中运行Git命令，包括添加，提交文件，查看日志，文件注解以及其它Git功能。 12 Terminal 这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。 11 CSSComb 这是用来给CSS属性进行排序的格式化插件。如果你想保持的代码干净整洁，并且希望按一定的顺序排列，那么这个插件是一种有效解决的方案。特别是当你和其他有自己代码编写风格的开发者一同协作的时候。 10 CanIUse 如果你想检查浏览器是否支持你包括在你的代码中的CSS和HTML元素，那么这是你需要的插件。所有你需要做的就是选择有疑问的元素，插件将为你做其余的事情。 9 Alignment 这个插件让你能对齐你的代码，包括 PHP、CSS 和 Javascript。代码看起来更简洁和可读，便于编辑。您可以查看下面的图片来明白我说的意思。 8 Trimmer 你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格。 7 ColorPicker 如果你经常要查看或设置颜色值，这个插件可以很方便地调用你本机的调色板应用。这是一个双向的功能，你既可以在调色板中选择一个颜色，然后按“确定”按钮把该值填写到 SublimeText 中活动文档的当前位置，也可以在活动文档中选择一个颜色的值，按此插件的快捷键就会在显示的调色板中定位到该值所对应的颜色。 6 MarkdownEditing SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。 5 FileDiffs 这个插件允许你看到SublimeText中两个不同文件的差异。你可以比较的对象可以是从剪贴板中复制的数据，或工程中的文件，当前打开的文件等。 4 DocBlock DocBlockr 可以使你很方便地对代码建立文档。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。 3 定制主题 拥有不同的主题可以触发创意和想法，你可能想使用这些插件来实现不同的主题，带来更好的和令人兴奋的前景。 SpaceGray Centurion 2 Snippets Snippets，你一定已经听说了，可以帮你快速书写代码。但它不是像上面提到的插件那样使用缩写，它是重用代码块以节省您的时间。你甚至可以创建自己的代码段，这完全取决于你自己。 1 语法支持 如果有一个SublimeText本身所带语言包不包含的语言，它就无法显示适当的语法高亮。这些语言包括LESS，Sass，SCSS，Styls和Jade（或其它）。如果您正在使用这些语言，你可能要安装它们的语法插件。 LESS Sass SCSS Stylus Jade]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(5)——前端综合]]></title>
    <url>%2F2017%2F05%2F01%2Fit-interviews005%2F</url>
    <content type="text"><![CDATA[XSS攻击 原理: 攻击者往web页面里插入恶意html标签或者javascript代码 示例: 攻击者在论坛中放一个看似安全的连接，骗取用户点击后，窃取cookie中用户私密信息； 防范: (1) 对用户输入的地方和变量要检查长度、对”&lt;”, “&gt;”, “;”, “‘“等字符过滤 (2) 任何内容写入页面之前必须加以encode，避免不小心把html tag弄出来 (3) 避免直接在cookie中泄漏用户隐私，如email、密码等 (4) 通过cookie和系统ip绑定来降低cookir泄漏后的风险 (5) 尽量采用POST而非GET提交表单 CSRF攻击 原理: XSS是CSRF的一种实现方式。但XSS是获取信息，不用提前知道用户的页面代码和数据包；CSRF是代替用户完成指定的动作，需要知道用户页面的代码和数据包 示例: 1. 登陆受信任网站A，并在本地生成cookie；2. 在不登出A的情况下访问危险网站B 防范: (1) 在客户端增加伪随机数 (2) 使用验证码 SQL注入 AJAX (1) 创建XMLHttpRequest对象，即异步调用对象(2) 创建一个新的HTTP请求，并指定该HTTP请求的方法、URL以及验证信息(3) 设置响应HTTP请求状态变化的函数(4) 发送HTTP请求(5) 获取异步调用返回的数据(6) 使用Javascript和DOM实现局部刷新 JSONP 原理 利用script标签没有跨域限制的”漏洞”来达到与第三方通信的目的。当本站需要通信时，本站脚本创建一个script元素，地址指向第三方的API，形如: 1&lt;script src="http://www.example.net/api?param1=1&amp;param2=2"&gt;&lt;/script&gt; 并提供了一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装(json with padding)，形如： 1callback(&#123;"name": "baochuquan", "gender": "male"&#125;); 这样浏览器就会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 CORS CORS与同源AJAX通信没有差别。关键是需要服务器支持CORS接口。 简单请求 条件 (1) 请求方法- HEAD - GET - POST (2) HTTP头信息超出以下几种字段- Accept - Accept-Language - Content-Language - Last-Event-ID - Content-Type: (只限于application/x-www-form-urlencodeed、multipart/formdata、text/plain) 请求 浏览器发现此次跨域AJAX请求是简单请求，自动在头信息中添加Origin字段。 响应 (1) Access-Control-Allow-Origin: 必须(*或请求时Origin字段的值) (2) Access-Control-Allow-Credentials: 可选(是否允许发送cookie) (3) Access-Control-Expose-Headers: 可选(cache, ) 跨域的方法【参考】 二级域名不同 (1) Cookie 两个网页一级域名相同，二级域名不同，浏览器允许通过设置document.domain共享cookie。服务器可设置cookie所属域名 document.domain = &apos;example.com&apos; document.cookie = &apos;key=value&apos; (2) iframe 类似cookie, 一级域名相同，二级域名不同，可以通过浏览器设置document.domain共享相互获取DOM 父窗口获取子窗口: document.getElementById(&quot;iframe&quot;) 子窗口获取父窗口: window.parent.document.body 完全非同源 (1) 片段标识符(URL#之后的部分) 父窗口写子窗口: document.getElementById(&apos;iframe&apos;).src = originURL +&apos;#&apos; + data; 子窗口写父窗口: parent.location.href = target + &apos;#&apos; + data; (2) window.name 同一个标签页 window.name = data location = &apos;http://newurl.com&apos; windodw.name / var data = document.getElementById(&apos;iframe&apos;).contentWindow.name (3) window.postMessage var popup = window.open(url); popup.postMessge(data, url); (4) localStorage 通过window.postMessage来操作localStorage (5) JSONP(只能是GET请求) 网页通过添加一个&lt;script&gt;元素向服务器请求JSON数据；服务器收到请求后将数据放在一个指定名的回调函数中传回来 (6) WebSocket WebSocket是一种通信协议，使用ws://(非加密)和wss://(加密)作为协议前缀，不实行同源策略，只要服务器支持即可进行跨域通信。服务器根据请求中的Origin字段判断请求源。 (7) CORS(可以是任何请求类型) 和同源的AJAX一样。关键是需要服务器实现CORS接口。 (8) 设置服务器代理页面 cookie、session cookie数据存放在浏览器上；session数据存放在服务器上； cookie安全性低；session相对安全； 单个cookie保存的数据不能超过4KB，很多浏览器会限制一个站点只能保存20个cookie session会在一定时间内保存在服务器上。当访问增多，会占用服务器的性能 cookie、sessionStorage、localStorage 特性 cookie localStorage sesstionStorage 数据生命周期 可设置失效时间，默认关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话（当前标签页）下有效，关闭页面或浏览器后被清除 数据容量大小 4KB左右 一般为5MB 一般为5MB 与服务器端通信 每次都会携带在HTTP头中 仅在客户端中保存 仅在客户端中保存 如何实现浏览器内多个标签页之间的通信 cookie、locaStorage sessionStorage只能在一个标签页内传值 Get、Post的区别 GET: 向服务器请求数据，请求可在url中；长度有限(2KB)POST: 向服务器提交数据，每次刷新或后退会重新提交，Post请求数据封装在http请求的首部里 viewport JS延迟加载的方式 defer、async、动态创建DOM方式（JSONP）、AJAX JS阻塞特性 所有浏览器在下载JS时，会阻止一切活动，如其他资源的下载、内容的呈现等。直到JS下载、解析、执行完毕才开始继续并行下载其他资源并呈现内容。 JS无阻塞加载具体方式 (1) 将脚本放在底部 link放在head中；script标签放在/body前(2) 成组脚本 限制页面的script总数。是用于内嵌脚本和外部脚本(3) 非阻塞脚本 等页面加载完后，再加载JS代码 XML、JSON的区别 特性 XML JSON 数据体积 大 小 数据交互 较复杂 易解析 数据描述 好 差 传输速度 慢 快 减少页面加载时间的方法 (1) 优化图片(2) 图像格式的选择（GIF: 提供的颜色少，可用在一些对颜色要求不高的地方）(3) 优化CSS（压缩合并CSS）(4) 网址后加斜杠（www.example.com/目录，会判断）(5) 表明高度和宽度(6) 减少HTTP请求（合并文件、合并图片） WebSocket 一种新的协议(ws)，允许服务器和浏览器端进行全双工通信 SSE 一种轻量级的协议，基于HTTP，浏览器向服务器发送一个HTTP请求，然后 服务器不断单向地向浏览器推送信息 Comet【参考】 定义: 基于HTTP长连接的“服务器推”技术 实现模型 (1) 基于AJAX的长轮询方式1. 服务器会阻塞请求直到有数据传递或超时才返回 2. 客户端JS响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接 3. 当客户端处理接收的数据、重新建立连接时，服务器端可能有新数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端一次取回当前服务器端所有的信息 (2) 基于iframe以及htmlfile的流方式1. 在HTML中嵌入一个隐藏的iframe，将其src属性设为对一个长连接的请求，服务器就能源源不断地往客户端输入数据 2. 服务器端返回对客户端JS函数的调用，类似于JSONP 缺点：某些浏览器下端的进度栏显示加载未完成，且标签页图标旋转——采用htmlfile解决 服务器推送的方式 (1) Comet：基于HTTP长连接的服务器推送技术(2) 基于WebSocket的推送方案(3) SSE：服务器推送数据新方式 预加载、懒加载（延迟加载）【参考】 懒加载（延迟加载） 原理: 延迟加载图片或符合某些条件时才加载某些图片 意义: 作为服务器前端的优化，减少请求数或延迟请求数 实现方式 (1) 纯粹的延迟加载，使用setTimeout或setInterval进行加载延迟 (2) 条件加载，符合某些条件，或触发了某些事件才开始异步下载 (3) 可视区加载，即仅加载用户可以看见的区域，一般会在距用户看到某些图片前一定距离就开始加载 预加载 原理: 提前加载图片，当用户需要查看时可以直接从本地缓存中渲染 意义: 牺牲服务器前端性能，换取更好的用户体验 实现方式 (1) CSS(background) (2) JS(image) (3) HTML() 渐进增强、优雅降级 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级: 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 浏览器缓存【参考01】【参考02】 定义: 浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器可以直接从本地磁盘加载文档。 优点 (1) 减少了冗余的数据传输 (2) 减少了服务器的负担 (3) 加快了客户端加载网页的速度 分类 缓存协商(协商缓存) 彻底缓存(强缓存) 缓存启动过程(当浏览器在第一次请求发生之后，再次请求时) (1) 浏览器先获取该资源缓存的header信息，根据其中的expires和cache-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信； (2) 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息(Last-Modified/IF-Modified-Since、Etag/IF-None-Match)，由服务器根据请求中的相关header字段信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中对应的header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容 强缓存 原理: 利用http返回头中的Expires或者Cache-Control两个字段来控制，用来表示资源的缓存时间 Expires: 值为一个绝对时间的GMT格式的时间字符串。缺点在于浏览器端和服务器端的时间可能不一致 Cache-Control: 利用该字段的max-age值进行判断，即相对时间 max-age=3600 no-cache: 不使用本地缓存。需要使用协商缓存 no-store: 直接禁止浏览器缓存数据，每次用户请求资源都是新下载 public: 可以被所有用户缓存，包括终端用户和CDN等中间代理服务器 private: 只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器缓存 协商缓存 原理: 由服务器来确定缓存资源是否可用，所以需要标识来进行通信。第一次请求的响应头带上某个字段(Last-Modified货Etag)，后续请求会带上对应的请求字段(If-Modified-Since货If-None-Match) Last-Modified: 一个时间标识该资源的最后修改时间 If-Modified-Since: 值为Lst-Modified ETag: 检验码，保证每个资源都是唯一的 移动端性能陷阱和硬件加速【参考】 (1) 减少或避免回流、重绘(2) 尽量缓存所有可以缓存的数据(3) 使用CSS3 transform代替DOM操作(4) 不要给非static元素增加CSS3动画，浏览器的性能开销会成倍增加(5) 适当使用硬件加速，如: canvas, transform 前端优化规则【参考】 尽可能的减少 HTTP 的请求数 使用CDN（内容分发网络） 添加Expire/Cache-Control 头 启用Gzip压缩 将css放在页面最上面 将script放在页面最下面 避免在CSS中使用Expressions 把javascript和css都放到外部文件中 减少DNS查询 压缩 JavaScript 和 CSS 避免重定向 移除重复的脚本 配置实体标签 使 AJAX 缓存 性能优化方式 (1) 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。(2) 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数(3) 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。(4) 当需要设置的样式很多时设置className而不是直接操作style。(5) 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。(6) 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。(7) 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 移动端性能优化 (1) 尽量使用CSS3动画，开启硬件加速；(2) 适当使用touch事件代替click事件(3) 避免使用CSS3渐变阴影效果(4) 尽可能少的使用box-shadow和gradient————性能杀手 前端兼容性问题【参考1】【参考2】 (1) XMLHttpRequest、ActiveXObject(2) W3C盒子模型、IE盒子模型(3) 不同浏览器的标签默认margin和padding不同 - 解决方案: * { margin: 0; padding: 0; } (4) 块属性标签float后，又有横向的margin情况下，IE6显示margin比设置的大 - 解决方案: 在float的标签样式控制中加入display: inline，将其转换为行内属性 (5) 设置较小高度标签(一般小于10px)，在IE6中，IE7，遨游中高度超出自己设置的高度 - 解决方案: 给超出高度的标签设置overflow: hidden; 或者设置行高line-height小于你设置的高度 (6) 行内属性标签，设置display: block后采用float布局，又有横向margin的情况，IE6间距BUG - 解决方案: 在display: block;后面加入display:inline;display:table (7) 图片默认有间距 - 解决方案: 使用float属性为img布局 (8) 标签最低高度设置min-height - 解决方案: 如果要设置一个标签的最小高度为200px，需要进行的设置为: {min-height:200px; height:auto !important; height: 200px; overflow: visible; } (9) 透明度的兼容CSS设置 - 解决方案: CSS hack - 如: height: 300px; *height: 200px; _height: 100px; - IE6认识的hacker: _, *；IE7、遨游认识的hacker: * (10) var e = e || window.event;(11) document.documentElement.clientWidth || document.body.clientWidth(12) var target = e.target || e.srcElement(13) cursor: hand, cursor.pointer//firefox不支持hand viewport【参考】 定义: 设备的屏幕上能用来显示网页的那一块区域。viewport不局限于浏览器可视区域的大小，可以比浏览器的可视区域大，也可以比浏览器的可视区域小。默认情况下，移动设备上的viewport大于浏览器可视区域。 CSS中的像素是一个抽象的单位，在不同的设备或不同的环境中，css中的1px代表的物理像素是不同的。 window.devicePixelRatio属性: 设备物理像素和设备独立像素的比例，即devicePixelRatio = 物理像素/独立像素。 三个viewport理论 (1) layout viewport: 浏览器默认的viewport，可通过document.documentElement.clientWidth获取，默认大于浏览器可视区域的宽度 (2) visual viewport: 代表浏览器的可视区域，可通过window.innerWidth获取，但在Android 2, Opera mini, UC无法获取 (3) ideal viewport: 没有固定的尺寸，不同的设备具有不同的ideal viewport。所有的iphone的ideal viewport都是320px，无论屏幕宽度是320还是640，css中320px就代表iphone屏幕的宽度 利用meta标签对viewport进行控制 meta viewport的6个属性 (1) width: 设置layout viewport的宽度，为一个正整数，或字符串”width-device” (2) initial-scale: 设置页面初始缩放值，为一个数字，可以带小数，相对于ideal viewport进行缩放 (3) minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数 (4) maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数 (5) height: 设置layout viewport的高度，很少使用 (6) user-scalable: 是否允许用户进行缩放，值为“no”或“yes”，no代表不允许，yes代表允许 把当前的viewport宽度设置为ideal viewport的宽度 visual viewport宽度 = ideal viewport宽度 / 当前缩放值 浏览器输入URL后发生了什么 (1) 输入URL(2) 浏览器查找域名的IP地址（DNS具体查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存）(3) 浏览器web服务器发送一个HTTP请求(4) 服务器的永久重定向响应（从http://example.com到http://www.example.com）(5) 浏览器跟踪重定向地址(6) 服务器处理请求(7) 服务器返回一个HTTP响应(8) 浏览器显示HTML(9) 浏览器发送请求获取嵌入在HTML中的资源（如图片、视频、音频、CSS、JS等）(10) 浏览器发送异步请求 浏览器结构 (1) User Interface 用户界面 如：顶部(前进、后退、刷新、停止、地址栏、书签栏、状态栏、工具栏等) 侧栏(滚动条)、底栏（滚动条）、开发工具、下拉菜单、下载管理等(2) Browser Engine 浏览器引擎 作用: 向上连接用户界面，向下连接渲染引擎，向右连接数据持久层(3) Rendering Engine 渲染引擎（浏览器内核） - 作用: 能显示HTML、XML和图片，并且通过一个插件可以显示其他类型资源，如PDF view显示PDF格式 - 常见的渲染引擎 - webkit: Safari、Chrome - gecko: Firefox - 流程: - 从网络层获取请求文档的内容，解析HTML/SVG/XHTML，形成DOM树 ； - 解析CSS形成CSS规则树； - 两者结合构成渲染树； - 通过JS解释器解析脚本 - 最后通过UI后盾提供的接口绘出效果 (4) Networking - 作用: 用于网络调用，如HTTP、HTTPS (5) Javascript Interpreter JS解释器 - 作用: 解析和运行JS (6) UI Backend UI后端 - 作用: 用于绘制基本的部件 (7) DATA Persistence 数据持久层 - 作用: 浏览器需要保存各种分类的数据在硬盘，例如cookies和HTML5的本地数据库等，都是通过这层来实现的 浏览器的内核有哪些 Trident IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape8、 Gecko Firefox、Netscape6-9 Webkit Safari、chrome Presto Opera JS引擎]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(4)——Javascript]]></title>
    <url>%2F2017%2F04%2F27%2Fit-interviews004%2F</url>
    <content type="text"><![CDATA[网页、屏幕宽度、高度的获取 屏幕分辨率的宽度: window.screen.width 屏幕分辨率的高度: window.screen.height 屏幕可用工作区宽度: window.screen.availWidth 屏幕可用工作区高度: window.screen.availHeight 网页被卷起的高度: document.body.scrollTop 网页被卷起的左边: document.body.scrollLeft 网页正文的全文宽: document.body.scrollWidth 网页正文的全文高: document.body.scrollHeight 网页可见区域宽度: document.body.offsetWidth, document.body.clientWidth; 网页可见区域高度: document.body.offsetHeight, document.body.clientHeight; 元素宽度、高度的获取【参考】 clientWidth: 标准盒模型的宽度(包含border) offsetWidth: 对象的宽度(width+padding+border) style.width: 行内式才能获取，包含px, % offsetLeft: 距离上层左边的距离 style.left: 可设置 property、attribute的区别 相同之处 标准的DOM properties与attributes是同步。 公认的（非自定义）特性被以属性的形式添加到DOM对象中，如: id, align, style 不同之处 对于有些标准的特性的操作，getAttribute()与点号(.)获取的值存在差异，如href、src、value、style、onclick等 property(属性): property的值不会出现在html中，只保存在js中 attribute(特性): 只能是字符串，大小写不敏感，出现在innerHTML中 typeof string number boolean undefined function object Javascript、Nodejs的区别 Javascript ECMAScript: 语言基础，如：语法、数据类型结构、内置对象 DOM: 操作页面元素的方法 BOM: 操作浏览器的方法 Nodejs ECMAScript: 语言基础，如：语法、数据类型结构、内置对象 os: 操作系统 file: 文件系统 net: 网络系统 database: 数据库 escape、encodeURI、encodeURIComponent escape: 将字符的unicode编码转换成为16进制序列，不编码字符有69个 如: *，+，-，.，/，@，_，0-9，a-z，A-Z encodeURI: 将字符的unicode编码转换成为UTF-8，不编码的字符有82个 如: !，#，$，&amp;，’，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z encodeURIComponent: 将字符的unicode编码转换成为UTF-8，不编码的字符有71个 如: !， ‘，(，)，*，-，.，_，~，0-9，a-z，A-Z stopropagtion(), stopImmediatePropagation() stopPropagation(): 阻止事件在DOM中继续传播 stopImmediatePropagation(): 阻止同一个事件的其他监听函数被调用 DOMContentLoaded事件, readstatechange事件** DOMContentLoaded事件: 比load事件早，文档下载并解析完成(DOM生成)，所有外部资源可能还没下载结束 readystatechange事件: 发生在Document对象和XMLHttpRequest对象，当其readyState属性发生变化时触发 Javascript前缀命名规范 s: 表示字符串。如：sName，sHtml； n: 表示数字。例如：nPage，nTotal； b: 表示逻辑。例如：bChecked，bHasLogin； a: 表示数组。例如：aList，aGroup； r: 表示正则表达式。例如：rDomain，rEmail； f: 表示函数。例如：fGetHtml，fInit； o: 表示以上未涉及到的其他对象，例如：oButton，oDate； g: 表示全局变量，例如：gUserName，gLoginTime； 闭包 原理: 当某个函数调用时会创建一个执行环境以及作用域链，然后根据arguments和其他命名参数初始化形成活动对象。当外部函数调用结束后，其执行环境与作用域链被销毁，但是其活动对象保存在了闭包之中，最后在闭包函数调用结束后才销毁。 实现: 在函数中定义函数，并且内部函数引用了外部函数的变量，最后内部函数被返回 特性 (1) 函数嵌套函数 (2) 函数内部可以引用外部的参数和变量 (3) 参数和变量不会被垃圾回收机制回收 Javascript垃圾回收原理 (1) 如果一个对象不再被引用，那么对象会被GC回收(2) 如果两个对象相互引用，且不被第三者引用，那么这两个对象会被回收 call、apply 其作用是可以改变其this的指向，其调用方式有所不同。 call传递参数；apply传递数组 Javascript数据类型 基本数据类型 string number boolean 引用数据类型 object array 特殊数据类型 null undefined 原型、原型链 原型: 一个普通的对象，自带隐式的proto属性，原型也有自己的原型原型链: 有一些用来继承和共享属性的对象组成的（有限的）对象链 null、undefined null: 一个表示“无”的对象，转为数值时为0；undefined: 一个表示“无”的原始值，转为数值时为NaN this指针 arguments ES6新特性【参考】 箭头操作符：=&gt; 类的支持：class 增强的对象字面量： 可以再对象字面量里定义原型 可以直接调用父类方法 定义方法可以不用function关键字 字符串模板：·your name is ${num}· 解构：自动解析数组或对象中的值 默认参数、不定参数、拓展参数 let、const关键字 for of：值遍历 模块：module Map、Set、WeakMap、WeakSet Proxies Symbols Math、Number、String、Object的新API Promises Promise Promise的四种状态 (1) pending: 初始状态，非fulfilled或rejected (2) fulfilled: 成功的操作 (3) rejected: 失败的操作 (4) settled: Promise已经被fulfilled或rejected，且不是pending 严格模式 目的 (1) 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 (2) 消除代码运行的一些不安全之处，保证代码运行的安全； (3) 提高编译器效率，增加运行速度； (4) 为未来新版本的Javascript做好铺垫。 缺点 (1) 与未采用严格模式的文件一起压缩，反而会浪费字节 DOM操作 创建 createDocumentFragment() createElement() createTextNode() 添加、移除、替换、插入 appendChild() removeChild() replaeChild() insertBefor() 查找 getElementsByTagName() getElementsByName() getElementById() document.write、innerHTML的区别 document.write: 只能重绘整个页面innerHTML: 可以重绘部分页面 Javascript对象创建的几种方式 (1) 工厂模式(2) 构造函数模式(3) 原型模式(4) 混合构造模式和原型模式(5) 动态原型模式(6) 寄生构造函数模式(7) 稳妥构造函数模式 Javascript继承的6中方法 (1) 原型链继承(2) 借用构造函数继承(3) 组合继承（原型+借用构造）(4) 原型式继承(5) 寄生式继承(6) 寄生组合式继承 如何获取UA 12345678&lt;script&gt; function whatBrowser()&#123; document.Browser.Name.value = navigator.appName; document.Browser.Version.value = navigator.appVersion; document.Browser.Code.value = navigator.appCodeName; document.Browser.Agent.value = navigator.userAgent; &#125;&lt;/script&gt; slice()、substr()、substring()的区别 slice(start, [end])：参数可为负 substr(start, length) substring(start, [end]): 参数不可为负 Array方法 转换方法 valueOf() toString() toLocaleString() join() 堆栈方法 push() pop() 队列方法 push() shift() unshift(item1, item2, …) 排序方法 reverse() sort() 操作方法 concat(arr1, arr2, …) slice() splice() 位置方法 indexOf() lastIndexOf() 迭代方法 every() filter() forEach() map() some() 合并方法 reduce() reduceRight() String方法 字符方法 charAt(index): 返回指定位置的字符 charCodeAt(): 返回指定位置的字符的unicode编码 操作方法 concat() slice() substring() substr() 位置方法 indexOf() lastIndexOf() trim方法 trim() trimLeft() trimRight() 大小写转换方法 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 模式匹配方法 match(string/reg)： string: 返回匹配结果的数组 reg(g): 返回所有的匹配子串 reg: 返回一个数组：元素0存放的是匹配文本；其余元素存放与正则表达式的子表达式匹配的文本；input属性表示匹配文本的起始字符的位置；input属性表示输入字符串 search() replace() split() 其他方法 localeCompare() fromCharCode() 正则表达式 定义方法 直接定义: var r = /pattern/flags; 构造函数: var r = new RegExp(‘pattern’, ‘flags’); 元字符: ( ) [ ] { } \ ^ $ | ? * + . 特殊元字符 .: 查找单个字符 \w: 查找字母数字下划线 \W: 查找非字母数字下划线 \d: 查找数字 \D: 查找非数字字符 \s: 查找空白字符 \S: 查找非空白字符 \b: 匹配单词边界 \B: 匹配非单词边界 \0: 查找NULL字符 \n: 查找换行符 \f: 查找换页符 \t: 查找回车符 \v: 查找垂直制表符 \xxx: 查找以8进制xxx规定的字符 \xdd: 查找以16进制dd规定的字符 \uxxxx: 查找以16进制xxxx规定的unicode字符 […]: 匹配括号中的任何一个字符 [^…]: 匹配不在括号中的任何一个字符 {m,n}: 最少匹配前面表达式m次，最多n次 {m,}: 最少匹配前面表达式m次 {m}: 正好匹配前面表达式m次 ?: 匹配前面表达式0或1次 +: 最少匹配前面表达式1次 *: 最少匹配前面表达式0次 |: 匹配前面表达式或后面表达式 (…): 组合项目 ^: 匹配字符串的开头 $: 匹配字符串的结尾 正则表达式方法 test(): 返回一个布尔值，表示传入的 字符串是否匹配（从lastIndex属性指示的地方开始） exec(): 返回一个包含了匹配结果的数组（额外具有两个属性: input表示本次搜索的目标字符串；index表示匹配结果在目标字符串内的位置） 常见的正则表达式 匹配中文: [u4e00-u9fa5] 匹配URL /http(s)?:\/\/([\w-]+.)+[\w-]+(\/[\w-.\/\?%&amp;=]*)?/ 匹配Email: /^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$/ JS函数调用的方法【参考】 (1) 方法调用模式(2) 函数调用模式(3) 构造器调用模式(4) apply调用模式 setTimeout 随机打乱数组顺序123function randomArr(arr)&#123; arr.sort(function()&#123; return Math.random() - 0.5; &#125;)&#125; 实现duplicate12345678910111213141516171819function duplicate(obj)&#123; var buf; if(obj instanceof Array)&#123; buf = []; var i = obj.length(); while(i--)&#123; buf[i] = duplicate(obj[i]); &#125; return buf; &#125; else if(obj instanceof Object)&#123; buf = &#123;&#125;; for(var k in obj)&#123; buf[k] = duplicate(obj[k]); &#125; return buf; &#125; else &#123; return obj; &#125;&#125; 实现数组去重12345function distinct(arr)&#123; return arr.filter(function (elem, index)&#123; return arr.indexOf(elem, index+1) === -1; &#125;);&#125; 获取元素到页面顶部和左边的距离123456789101112function getDistance(el)&#123; var x = el.offsetLeft; var y = el.ofsetTop; while(el = el.offsetParent)&#123; x += el.offsetLeft; y += el.offsetTop; &#125; return &#123; 'x': x, 'y': y &#125;;&#125; 实现bind方法123456Function.prototype.bind = function(context)&#123; self = this; return function()&#123; self.apply(context, arguments); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(3)——CSS]]></title>
    <url>%2F2017%2F03%2F17%2Fit-interviews003%2F</url>
    <content type="text"><![CDATA[盒子模型【参考】 组成: content、padding、border、margin 标准盒模型 width/height = content IE盒模型 width/height = content + padding + border 行级元素、块级元素的区别 块级元素: margin、padding可设置 行级元素: margin、padding水平方向可设置；竖直方向不可设置 浮动及其原理 脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留 缺点 (1) 父元素的高度无法被撑开，影响与父元素同级的元素 (2) 与浮动元素同级的非浮动元素（内联元素）会跟随其后 (3) 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 清除方法 (1) clear:both清除浮动 (2) 父级div定义overflow:autooverflow有三个值: hidden, auto, visible; hidden, auto可用来清除浮动, auto对SEO更友好 (3) :after方法 line-height CSS hack 定义: 针对不同浏览器/版本而写CSS的过程叫做CSS hack 三种方法 (1) IE条件注释法: 即在正常代码之外添加判断IE浏览器或对应版本的条件注释，符合条件的浏览器或版本号才会执行里面的代码。- &lt;!-- [if IE]&gt;要执行的代码&lt;![endif]--&gt; - &lt;!-- [if lt LE 8]&gt;要执行的代码&lt;![endif]--&gt; - &lt;!-- [if ! IE 8]&gt;要执行的代码&lt;![endif]--&gt; (2) CSS属性前缀法: 即给CSS的属性添加前缀。比如: 可以被IE6/IE7识别，_只能被IE6识别，”\9”可以被IE6-IE10识别，IE6不能识别!important，Firefox不能识别,_,\9- #example{ color: #111; color: #222\9; *color: #333; _color: #444; } (3) 选择器前缀法: 即给选择器加上前缀- *div{ color: red; } - *+div{ color: red; } background-属性 background-color: 规定要使用的背景颜色 color-name hex-number rgb-number transparent inherit background-position: 规定背景图像的位置 top/left/bottom/right/center x% y% xpos ypos background-size: 规定背景图片尺寸 length percentage cover contain background-repeat: 规定如何重复背景图像 repeat repeat-x repeat-y no-repeat inherit background-origin: 规定背景的定位区域 padding-box border-box content-box background-clip: 规定背景的绘制区域 border-box padding-box content-box background-attachment: 规定背景图像是否固定或者随着页面的其余部分滚动 scroll fixed inherit background-image: 规定要使用的背景图像 url(‘URL’) none inherit display:none和visibility: hidden的区别 display: none 隐藏对应的元素，在文档布局中不分配空间； visibility: hidden 隐藏对应的元素，但是在文档布局中仍然保留员阿里的空间 link、@import link属于HTML标签；而@import是CSS提供的 页面被加载时，link会被同时加载，而@import引用的CSS会等到页面被加载完再加载 link方式的样式的权重高于@import的权重 position: absolute和float的区别 共同点: 对内联元素float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高 不同点: float仍会占据位置，position会覆盖文档流中的其他元素 relative、absolute、fixed、static absolute: 生成绝对定位的元素，相对于最近一级的定位不是static的父元素来进行定位fixed: 生成绝对定位的元素，相对于浏览器窗口进行定位relative: 生成相对定位的元素，相对于其在普通流中的位置进行定位static: 默认值。没有定位，元素出现在正常的流中 box-sizing content-box: 让元素维持W3C的标准盒模型border-box: 让元素位置IE传统盒模型 CSS选择器 (1) id选择器(#myId)(2) 类选择器(.myclassname)(3) 标签选择器(div, h1, p)(4) 相邻选择器(h1 + p)(5) 子选择器(ul &gt; li)(6) 后代选择器(li a)(7) 通配符选择器(*)(8) 属性选择器(a[rel=”external”])(9) 伪类选择器(a: hover, li:nth-child) CSS选择器【参考】CSS伪类、伪元素 伪类 定义: 基于当前元素所处的状态，或者说元素所具有的特性，而不是元素的id、class、属性等静态的标志。 :link :visited :hover :active :focus :first-child :lang 伪元素 定义: 目的是获取诸如元素内容第一个字、第一行，获取某些内容前面或后面这种普通的选择器无法完成的工作。 :first-letter :first-line :before :after CSS可被继承、不可被继承的样式 可继承: font-size, font-family, color, text-indent不可继承: border, padding, margin, width, height CSS优先级 !important &gt; 内联 &gt; id &gt; class &gt; tag &gt; 默认样式 class属性覆盖 当存在多个类名时，类名的位置不会对属性的渲染产生影响。只有在style中定义的位置才会有影响，同一条属性，后面的定义会覆盖前面的定义 CSS选择器权重 通用选择器: 0-0-0 标签选择器，伪元素: 0-0-1 类选择器，属性选择器，伪类: 0-1-0 ID选择器: 1-0-0 em, rem, px【参考】 px: 像素。相对长度单位。像素px是相对显示器屏幕分辨率而言的 em: 相对长度单位。相对于当前对象内文本的字体尺寸。如果当前对内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 rem: 相对长度单位。相对于HTML根元素。既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应 CSS3新特性 边框：border-radius、box-shadow、border-image 背景：background-size、background-origin 文本：text-shadow、word-wrap 字体：@font-face 2D转换：transform、translate()、rotate()、scale()、skew()、matrix() 3D转换：rotateX()、rotateY() 过度：transition 动画：@keyframes、animation水平垂直居中【参考】 (1) 绝对定位 + 负margin - 优点: 兼容性好 - 缺点: 需要知道宽高，不够灵活 (2) 绝对定位 + Transform - 优点: 不需要知道宽高，灵活 - 缺点: 兼容性不好，在移动设备上建议使用 (3) 绝对定位 + 自动margin - 优点: 灵活性兼容性好 - 缺点: 适用于本身有尺寸的元素，如图片，对于段落等必须显示设置其宽高 (4) CSS3 flexbox - 优点: 不需要知道宽高 - 缺点: 兼容性不好，在移动设备上建议使用 (5) table display - 优点: 兼容性好 - 缺点: 增加了无用的html结构 两列布局 (1) 左浮动 + 右margin(2) 左绝对定位 + 右margin(3) flex实现两列布局: 设置为flex布局后，子元素的float、clear、 vertical-align属性将失效(4) calc实现两列布局: 使用百分比、em、px、rem单位值计算出其宽度或者高度。通过对右div设置width: calc(100%-100px)来实现自适应布局(5) float + margin负值 - 给右边的div外面套上一个父div，然后让父div的宽度设为100%。对父div的宽度设为100% 水平居中【参考】 行内元素 对父元素设置文本居中，如: text-align: center 适用于inline, inline-block, inline-table, inline-flex 块级元素 margin: 0 auto 浮动元素 Box、Formatting Context【参考】 Box: CSS布局的基本单位，一个页面由多个Box组成。元素的类型和display属性，决定了Box的类型。不同类型的Box，会参与不同的Formatting Context（一个决定如何渲染文档的容器），即Box内的元素会以不同的方式渲染。 (1) block-level box: display属性为block、list-item、table的元素 (2) inline-level box: display属性为inline、inline-block、inline-table的元素 (3) run-in box: CSS3存在 Formatting context: 页面中的一块渲染区域，并且有一套渲染规则，其决定了其子元素将如何定位，以及和其他元素的 关系和相互作用 (1) BFC: Block Formatting Context (2) IFC: Inline Formatting Context (3) GFC: CSS3 (4) FFC: CSS3 BFC【参考】 定义: 块级格式化上下文。一个独立的渲染区域，只有block-level box参与，规定了内部的 block-level box如何布局。 BFC布局规则 (1) 内部的box会在垂直方向一个个进行放置 (2) box垂直方向的距离由margin决定。属于同一个BFC的两个相邻box的margin会发生重叠 (3) 每个元素的margin box的左边，与包含块border box的左边相接触。即使存在浮动也是如此。 (4) BFC的区域不会与float box重叠 (5) BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 (6) 计算BFC的高度时，浮动元素也参与计算 生成BFC的元素 根元素 float属性不为none position为absolute或fixed display为 inline-block，table-cell，table-caption，flex，inline-flex overflow不为visible 边界塌陷 &amp; 边界重叠 定义: CSS中存在一个margin collapse， 即边界塌陷或边界重叠。对于上下两个并列的div，上面的div的margin-bottom和下面的div的margin-top会塌陷，取两者margin的最大值 CSS sprite 把网页中的一些背景图片整合到一张图片中，再利用CSS的background-repeat,background-image,background-position的组合进行定位 CSS 媒体查询【参考】 作用: @media可以针对不同的屏幕尺寸设置不同的样式，特别是设置响应式的页面 语法 @media mediatype and|not|only (mediafeature){ CSS-Code; } 如: @media screen and (max-width: 300px) { … }, @media mediatype all: 用于所有设备 print: 用于打印机和打印预览 screen: 用于电脑屏幕，平板电脑，智能手机等 speech: 应用于屏幕阅读器等发声设备 mediafeature aspect-ratio: 定义输出设备中的页面可见区域宽度和高度的比率 color: 定义输出设备每一组彩色原件的个数 color-index device-aspect-ratio device-height device-width grid height max-aspect-ratio max-color max-device-s … @font-face【参考】 语法: @font-face { font-properties } font-properties font-family: 定义字体的名称(必须) src: 定义字体的下载地址(必须) font-stretch: 定义字体该如何被拉长 font-style: 定义字体该是怎样的样式 font-weight: 定义字体的粗细 unicode-range: 定义字体支持Unicode字符的范围 CSS3画一个旋转的3/4的圆环123456789101112.circle &#123; height: 100px; width: 100px; border-radius: 50%; border: 20px solid black; border-left-color: transparent; -webkit-animation: mycircle 1s infinite linear;&#125;@keyframes mycircle &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(-360deg); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(2)——HTML]]></title>
    <url>%2F2017%2F03%2F07%2Fit-interviews002%2F</url>
    <content type="text"><![CDATA[Doctype 作用 (1) 对文档进行有效性验证： 告诉用户代理和校验器该文档的DTD (2) 决定浏览器的呈现模式：通知浏览器读取文档时采用何种解析算法。浏览器有三种方式解析HTML文档(标准模式、怪异模式、部分怪异模式) 种类 (1) HTML 4.01: Strict, Transitional, Framset (2) XHTML 1.0: Strict, Transitional, Framset 标准模式、怪异模式 标准模式：页面按照HTML与CSS的定义渲染 怪异模式：浏览器为了了兼容很早之前针对旧版本浏览器设计、并未严格遵循W3C标准的网页而产生的一种页面渲染模式 语义化 (1) 去掉或丢失样式时能够让页面呈现出清晰的结构(2) 有利于SEO：爬虫依赖于标签来确定上下文和各个关键字的权重(3) 方便其他设备解析以意义的方式来渲染网页(4) 可读性更好，方便团队开发 XHTML (1) 所有的标记都必须要有一个相应的结束标记(2) 所有标签的元素和属性的名字都必须使用小写(3) 所有的XML标记都必须合理嵌套(4) 所有的属性必须用引号””括起来(5) 把所有&lt;和&amp;特殊符号用编码表示(6) 给所有属性赋一个值(7) 不要在注释内容中使“–”(8) 图片必须有说明文字 data-属性 自定义属性，可通过对象的dataset属性获取，或通过getAttribute方法获取：1&lt;div data-author="baochuquan" data-time="2016-06-20" data-comment="10"&gt;&lt;/div&gt; 1div.dataset.commentNum;//10 input的type属性【参考】 button checkbox color date datetime datetime-local month week time email file hidden image number password radio range reset search submit tel text url iframe的优缺点 优点(1) 解决加载缓慢的第三方内容(如图标和广告等)的加载问题(2) Security sandbox(3) 并行加载脚本 缺点(1) iframe会阻塞主页面的onload事件(2) 即使内容为空，加载也需要时间(3) 没有语义 HTML表单元素【参考】 input select option textarea button HTMl5表单元素【参考】 datalist: datalist元素规定输入域的选项列表，列表是通过datalist内的option元素创建的 keygen: keygen元素的作用是提供一种验证用户的可靠方法 output: output元素用于不同类型的输出，如计算或脚本输出 head标签及其内容【参考】 作用: 描述了文档的各种属性和信息，包括文档的标题、在web中的位置以及和其它文档的关系等 内容 title: 定义文档的标题，是head部分中唯一必需的元素 base: 为页面上的所有链接规定默认地址或默认目标 必选: href 可选: target meta: 可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词 必选: content 可选 http-equiv(Content-Type, expires, Refresh, set-cookie) name: author, description, keywords, generator, revised, others link: 链接一个外部样式表 rel, href, type, charset script: 直接包含脚本，或者通过src属性指向外部脚本文件 style: 为HTML文档定义样式信息 块级元素、行内元素、空元素 块级元素 div、dl、dt、dd、ul、li、ol、p、h1-6、table、fieldset、form 行内元素 a、em、strong、i、img、b、label、select、textarea、sub、sup、q 空元素 br、hr 自闭合元素 自闭合标签不加斜杠，如: br, link HTML5新特性 新的文档类型：&lt;!DOCTYPR html&gt; 脚本和链接不需要type： 语义标签：header、footer hgroup 标记元素：mark 图形元素：figure 必要属性：require 音频视频：video, audio 正则表达式：pattern属性 canvas API：栅格图形API SVG：矢量图形API Geolocation API Communication API WebSockets API Form API Web Works API Web Storage API 置换元素、不可置换元素 置换元素 定义：浏览器根据元素的标签和属性，来决定元素的具体显示内容 如：imt, input, textarea, select, object 不可替换元素 定义：其内容直接呈现给用户 meta标签【参考】 作用 通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie； 可以用于鉴别作者，设定页面格式，标注内容提要和关键字； 可以设置页面使其可以根据自己定义的时间间隔刷新自己 设置RASC内容等级 分类 (1) http-equiv: HTTP标题信息- Content-Type、Content-Language - 说明: 设定页面使用的字符集，用以说明主页只做所使用的文字及语言 - 用法 - &lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; Charset=gb2312&quot;&gt; - &lt;meta http-equiv=&quot;Content-Language&quot; Content=&quot;zh-CN&quot;&gt; - Refresh - 说明: 让网页多长时间刷新自己，或在多长时间后让网页自动链接到其他网页 - 用法 - &lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;30&quot;&gt; - &lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;5;Url=&quot;http://www.baidu.com&quot;&gt; - Expires - 说明: 指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调整 - &lt;meta http-equiv=&quot;Expires&quot; Content=&quot;0&quot;&gt; - &lt;meta http-equiv=&quot;Expires&quot; Content=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;&gt; - Pragma(cache模式) - 说明: 禁止浏览器从本地机的缓存中调阅页面内容 - Set-Cookie(cookie设定) (2) name: 页面描述信息]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT面试整理(1)——网络]]></title>
    <url>%2F2017%2F03%2F02%2Fit-interviews001%2F</url>
    <content type="text"><![CDATA[网络体系结构 OSI五层模型 应用层 传输层 网络层 数据链路层 物理层 OSI七层模型 应用层: 文件传输，电子邮件，文件服务，虚拟终端 （协议族: FTP,HTTP,SMTP,DNS,Telnet,SNMP） 表示层: 数据格式化，代码转换，数据加密。对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 会话层: 解除或建立与别的节点的联系。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 传输层: 提供端到端的接口。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层处理端到端的差错控制和流量控制问题。 （协议族: TCP, UDP） 网络层: 为数据包选择路由。还可以实现拥塞控制、网际互连等功能 （协议族: IP, ICMP, RIP, OSPF, BGP, IGMP） 数据链路层: 传输有地址的帧以及错误检测功能。在不可靠的物理介质上提供可靠的传输，该层的作用包括：物理地址寻址、数据的成帧、流量控制、 数据的检错、重发等 （协议族: SLIP, CSLIP, PPP, ARP, RARP, MTU） 物理层: 以二进制数据形式在物理媒介上传输数据。激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性 （协议族: ISO2110, IEEE802, IEEE802.2） 地址解析协议 原理: 适用于局域网，主机在发送帧前将目标IP地址转换成目标MAC地址的过程 工作过程 (1) 当主机A向本局域网上主机B发送IP数据报时，先在自己的ARP缓冲表中查看有无主机B的IP地址； (2) 如果有，查出对应的硬件地址，并将此硬件地址写入MAC帧，然后通过以太网将数据包发送到目的主机中 (3) 如果查不到主机B的IP地址的表项，高速缓存表可能是空的。主机A就自动运行ARP协议 ARP进程在本局域网上广播一个ARP请求分组。ARP请求分组的主要内容表明：我的IP地址是192.168.0.2，我的硬件地址是00-C0-15-AD-18，我想知道IP地址为192.168.0.4的主机的硬件地址 本局域网上的所有主机上运行的AR进程都接收此ARP请求分组 主机B在ARP请求分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址 主机A收到主机B的ARP响应分组后，在其ARP高速缓存中写入主机B的IP地址硬件地址的映射 路由选择协议 RIP协议 底层是Bellmanford算法，其选择路由的度量标准是跳数，最大跳数是15跳，如果大于15跳，则丢弃数据包 OSPF协议 底层是Dijskra算法，是链状状态路由选择协议，其选择路由的度量标准是带宽、延迟 NAT协议、DHCP议、DNS协议 NAT协议 网络地址转换协议: 一种将私有地址转换成合法IP地址的转换技术，完美解决了IP地址不足的问题，还能有效避免来自网络外部的攻击 DHCP协议 动态主机配置协议: 一种局域网的网络协议，使用UDP协议工作，主要用途: (1) 给内部网络或者网络供应商自动分配IP地址 (2) 给用户或者内部网络管理员作为对所有计算机作中央管理的手段 DNS协议 将域名和IP地址相互映射的一个分布式数据库 实现可靠传输的协议 (1) 停止等待协议 每发完一帧就停止发送，直到收到接收确认信号再发送下一帧，如果没有收到接收确认信号，则通过设定的定时器 超时后重传上一帧，通过序号判断之前的帧是否被接收 (2) 连续ARQ协议 发送窗口大于1，接收窗口等于1。如果发送窗口已经发送到了序号为5的帧，但是接收端收到序号为3的帧出错，那么3以后的帧都需重传。为了避免后面的帧重传，可以使用缓存 (3) 选择重传协议 TCP拥塞控制 【参考】 定义: 防止过多的数据注入网络中，可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是指点对点通信量的控制 方法: (1) 慢开始与拥塞避免 慢开始： 先探测网络的拥塞程度，从小到大逐渐增加拥塞窗口的大小 拥塞避免: 让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1 (2) 快重传与快恢复 (3) 随机早起检测RED 网络设备及其相关层 网关: 网络层以上的设备 网络层: 路由器 数据链路层: 网桥、交换机 物理层: 中继器、集线器 HTTPS 【参考】 在HTTP和TCP协议之间建立一层TLS/SSL协议 HTTP头 【参考】 报文格式 报文首部 空行 报文主体 请求报文首部 请求行（GET /index.html/ HTTP/1.1） 请求首部字段 请求信息性首部字段 From: 请求来自何方，格式是客户端用户的有效电子邮件地址 Host: 服务器的主机名和端口号 Referer: 这次请求的URL是从哪里获得的 User-Agent: 客户端的浏览器或代理信息 Accept首部字段 Accept: 客户端通过该首部字段告诉服务器自己可以接收哪些媒体类型，如text/html。此外，还有可以权重系数（q值）来表示媒体类型的优先级。 Accept-Charset: 客户端可以接收哪些字符集，也可以有q值 Accept-Encoding: 客户端支持的内容编码及内容编码的优先级顺序。 Accept-Language: 客户端能够处理的自然语言集（中文、英文等） TE: 客户端能够处理的传输编码，还可以指定伴随trailer字段的分块传输编码方式 条件请求首部字段 Expect: 客户端通过该首部字段告知服务器它们需求某种行为，现在该首部与响应码100 Continue紧密相关。如果服务器无法理解该首部的值，就应该返回417 Expectation Failed If-Match: 服务器会比对该字段的值和资源的ETag值，仅当两者一致时，才会执行请求，否则，返回412 Precondition Failed。该字段值为*时，会忽略ETag值 If-Modified-Since: 该字段值应该是一个日期，如果服务器上资源的更新时间较该字段值新则处理该请求，否则，返回304 Not Modified If-None-Match: 与If-Match相反，该字段的值与请求资源的ETag不一致时，处理该请求 If-Range: 该字段的值（ETag或时间）与资源的ETag或时间一致时，作为范围请求处理（参加首部字段Range）。否则，返回全体资源 If-Unmodified-Since: 与If-Modified-Since相反，服务器上资源的更新时间早于该字段值时处理请求，否则，返回412 Precondition Failed Range: 范围请求，只获取部分资源。如Range: bytes=5001-10000，表示获取从第5001字节至10000字节的资源。成功处理范围请求时返回206 Partial Content响应，无法处理范围请求时返回200 OK响应及全部资源 安全请求首部字段 Authorization: 向服务器回应自己的身份验证信息。客户端收到来自服务器的401 Authentication Required响应后，要在其请求中包含这个首部 Cookie: HTTP/1.1中没有定义，用于客户端识别和跟踪的扩展首部 代理请求首部字段 Max-Forwards: 只能和TRACE方法一起使用，指定经过代理或其他中间节点的最大数目。每个收到带此首部的TRACE请求的应用程序，在请求转发之前都要将这个值减1；如果应用程序收到请求时，该首部值为0，则立即回应一条200 OK响应 Proxy-Authorization: 与Authorization类似，用于客户端与代理服务器之间的身份验证 通用首部字段 实体首部字段 其他 响应报文首部 状态行（HTTP/1.1 200 OK） 响应首部字段 响应信息性首部字段 - Age: 响应已经产生了多长时间。HTTP/1.1规定缓存服务器在创建响应时必须包含Age首部 Location: 客户端应重定向到指定URI，基本配合响应出现 Retry-After: 告诉客户端多久之后再次发送请求。主要配合503 Service Unavailable使用，或与3**响应一起使用 Server: HTTP服务器的应用程序信息 Warning: 协商首部字段 Accept-Ranges: 服务器是否能处理范围请求，bytes表示能，none表示不能 Vary: 安全响应首部字段 Proxy-Authorizate: 与WWW-Authenticate类似，用于代理与客户端之间的认证，407 Proxy Authentication Required响应必须包含该首部 Set-Cookie: 非HTTP/1.1标准首部 WWW-Authenticate: 告诉客户端访问所请求资源的认证方案，401 Unauthorized响应中肯定有该首 通用首部字段 通用信息性首部字段 Connection: 两个作用 控制不再转发给代理的首部字段 管理持久连接 Date: 创建HTTP报文的时间和日期 Trailer: 说明在报文主体后记录了哪些首部字段 Transfer-Encoding: 传输报文主体时采用的编码方式 Upgrade: 用于检测HTTP协议及其他协议是否可使用更高的版本进行通信 Via: 追踪客户端与服务器之前的请求和响应报文的传输路径 通用缓存首部字段 Cache-Control: 管理缓存信息，是HTTP/1.1引入的一个复杂首部 Pragma: HTTP/1.1以前的遗留字段Pargma: no-cache与Cache-Control: no-cache功能一致，只用在客户端发送请求时 实体首部字段 实体信息性首部字段 Allow: 通知客户端可以对特定资源使用那些HTTP方法。405 Method Not Allowed响应中必须包含该首部 内容首部字段 Content-Encoding: 告诉客户端实体的主体部分选用的内容编码方式。具体方式参见Accept-Encoding Content-Language: 告诉客户端实体主体使用的自然语言（中文、英文等） Content-Length: 表明实体主体部分的大小（单位：字节）。对实体主体进行内容编码传输时，不能再使用该首部字段 Content-Location: 报文主体部分相对应的URI Content-MD5: 一串由MD5算法生成的值。对于检查在传输过程中数据是否被无意的修改非常有用，但不能用于安全目的，因为报文如果被有意的修改，该字段的值也可以计算后作相应修改 Content-Range: 针对范围请求，提供了请求实体在原始实体内的位置（范围），还给出了整个实体的长度 Content-Type: 响应报文中对象的媒体类型 实体缓存首部字段 ETag: 实体标记，就是一种标识资源的方式 Expires: 资源失效日期，当Cache-Control有指定max-age指令时，会优先处理max-age Last-Modified: 资源最终修改时间 其他 HTTP请求方法 GET: 最常见，向服务器请求某个资源 POST: 起初用于向服务器输入数据。实际上，通常用于HTML表单数据的提交 HEAD: 与GET的行为类似，但服务器返回的响应中只包含首部，不会返回主体部分 PUT: 向服务器写入文档 DELETE: 删除指定资源 TRACE: 服务器回送收到的请求信息给客户端，主要用于诊断 ONNECT OPTIONS: 查询服务器支持的方法（通用或针对指定资源） HTTP状态码 100 Continue: 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK: 正常返回信息 201 Created: 请求成功并且服务器创建了新的资源 202 Accepted: 服务器已接受请求，但尚未处理 301 Moved Permanently: 请求的网页已永久移动到新位置。 302 Found: 临时性重定向。 303 See Other: 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified: 自从上次请求后，请求的网页未修改过。 400 Bad Request: 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized: 请求未授权。 403 Forbidden: 禁止访问。 404 Not Found: 找不到如何与 URI 相匹配的资源。 500 Internal Server Error: 最常见的服务器端错误。 503 Service Unavailable: 服务器端暂时无法处理请求（可能是过载或维护）。 域名劫持 原理: 通过攻击域名解析服务器或者伪造域名解析服务器的方法，把目标网站域名解析到错误的地址。 Content-Type 含义: 用于指定请求和响应的HTTP内容类型。如果未指定，默认为text/html 格式: [type]/[subtype];parameter type text: 用于标准化地表示文本信息，文本消息可以是多种字符集或多种格式的 multipart: 用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据 application: 用于传输应用程序数据或二进制数据 message: 用于包装一个email消息 image: 用于传输静态图片数据 audio: 用于传输音频数据 video: 用于传输动态影像数据，可以是与音频编辑在一起的视频格式的数据 q subtype patameter 常见值 text/html text/plain text/css text/javascript application/x-www-form-urlencoded: 常用的表单发包方式，POST发包方式 multipart/form-data: 发送文件的POST包 application/json application/xml Etag cache-control private: 默认值。内容只缓存到私有缓存中（仅客户端可以换成，代理服务器不可缓存） public: 所用内容都可以被缓存（客户端和代理服务器都可缓存）cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载 no-store: 所有内容都不会被缓存到缓存或Internet临时文件中 max-age: 缓存的内容将在xxx秒后失效 must-revalidate/proxy-revalidation: 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 三次握手、四次挥手 三次握手 Client端发送连接请求报文 Server端接收连接请求，并回复ACK报文，并为此次连接分配资源 Client端接收ACK报文，向Server端发送ACK报文，并分配资源 四次挥手 Client端发送中断请求，即FIN报文 Server端收到FIN报文，发送ACK报文，并继续发送数据 Client端收到ACK报文，进入FIN_WAIT状态 Server端数据发送完毕，发送FIN报文 Client端收到FIN报文，发送ACK报文，等待2MSL IP地址 特殊的IP地址 网络地址 IP地址由网络号和主机号组成，网络地址的主机号为全0，网络地址代表整个网络 广播地址（直接广播地址） IP地址主机号全为1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息 既可本地广播，也可跨网段广播 组播地址 D类即主播地址 255.255.255.255（受限广播地址） 受限广播地址，只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组 0.0.0.0 表示整个网络。它的作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去。 回环地址 表示本机地址 A、B、C类私有地址 A类私有地址: 10.0.0.0/8, 范围: 10.0.0.0~10.255.255.255 B类私有地址: 172.16.0.0/12, 范围: 172.16.0.0~172.31.255.255 C类私有地址: 182.168.0.0/16, 范围: 192.168.0.0~192.168.255.255 IP地址分类 A类地址: 0开头，8位网络号 B类地址: 10开头，16位网络号 C类地址: 110开头，24位网络号 D类地址: 1110开头，用于多播 E类地址: 1111开头 子网 原理: 从二级IP地址到三级IP地址 二级IP地址: &lt;网络号&gt;&lt;主机号&gt;，默认子网掩码为网络号的长度 三级IP地址: &lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;，默认子网掩码为网络号+子网号的长度 超网 原理: 变长子网掩码，无分类编址CIDR IP地址: &lt;网络前缀&gt;&lt;主机号&gt; 特点: TCP、UDP 【参考】 报文格式 共有字段: 源端口和目的端口号 数据长度 校验和 数据域 TCP特有字段 序列号和确认号 接收窗口 TCP首部 标识字段 区别 TCP 面向连接的协议，提供可靠的数据传输 当数据接收方收到数据发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在收到确认消息之后才会继续发送其他信息； 报文最大长度允许超过512字节 UDP 用户数据报协议，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 报文最大长度为512字节 TCP对应的协议和UDP对应的协议 TCP FTP: 定义了文件传输协议，使用21端口 Telnet: 一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DO S模式下的通信服务，使用23端口 SMTP: 定义了简单邮件传送协议，使用25端口 POP3: 和SMTP对应，POP3用于接收邮件，使用110端口 HTTP: 从web服务器传输超文本到本地浏览器的传送协议 UDP DNS: 用于域名解析服务，将域名地址转换为IP地址，使用53端口 SNMP: 简单网络管理协议，用来管理网络设备，使用161端口 TFTP: 简单文件传输协议，使用69端口 Socket 套接字 是支持TCP/IP协议的网络通信的基本操作单元，是网络通信过程中端点的抽象表示，包含进行 套接字 = 连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口 HTTP2.0 特性 入服务器端推: 允许服务器端在客户端需要数据之前就主动地将数据发送到客户端缓存 提供更多加密技术 使用多路技术，允许多个消息在一个连接上同时交叉 增加了头压缩，即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2017%2F02%2F08%2Fcharacter-code%2F</url>
    <content type="text"><![CDATA[概念 字符是一个信息单位，在计算机中，一个中文汉字是一个字符，一个英文字母是一个字符，一个阿拉伯数字是一个字符，一个标点符号也是一个字符。 字符集是字符组成的集合，通常以二维表的形式存在于每一台计算机本地，二维表的内容和大小是由使用者的语言而定的，可以是英语、汉语、希腊语等等。 字符编码是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。编码方式一般是对二维表的横纵坐标进行变换的算法。一般都比较简单，直接把横纵坐标拼一起。后来随着字符集的不断扩大，为了节省存储空间，才出现了各种编码算法。 字符集和字符编码一般是成对出现的，如ASCII、IOS-8859-1、GB2312、GBK等，都是既表示了字符集又表示了对应的字符编码，下文统称编码。Unicode比较特殊，后面细说。 发展 ASCII计算机是美国人发明的，由于他们的语言的是美式英语，字符比较少，所以一开始就设计了一个不大的二维表，128个字符，取名ASCII（American Standard Code for Information Interchange）。128个码位（包括32个不能打印出来的控制符号）只占用了一个字节的后面7位，最前面的1位统一规定为0，其表示范围为00000000-01111111或0x00-0x7F。 后来美国人发现128个字符不够用，于是在原来的二维表的基础上进行了扩展，利用ASCII编码字节中闲置的最高位，从而编入新的符号。这种扩展后的编码被称为EASCII（Extended ASCII）。256个码位正好可以使用一个字节表示，其表示范围为00000000-11111111或0x00-0xFF。 当计算机技术传递到欧洲后，美国的编码标准就不适用了，但是改改还能凑合。于是国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，跟EASCII类似，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，如ISO-8859-1、ISO-8859-2、ISO-8859-3，……，ISO-8859-16等等。 非ASCII单个字节表示256个字符的ASCII系编码，对于欧洲各国的语言尚可表示，然而，对于亚洲地区的语言来说则远远不够，中国的汉字就多达10万左右。因此，就必须使用多个字节表示一个字符。为此在，亚洲地区又出现了很多编码，大陆的GB2312和GBK（GB2312的扩展，Kuozhan）、港台的BIG5、日本的Shift JIS等等。例如，GB2312编码使用两个字节表示一个汉字，所以理论上最多可以表示65536个汉字。 Unicode当互联网席卷了全球，地域限制被打破了，不同国家和地区的计算机在交换数据的过程中，一旦使用不同的字符编码就会出现乱码的问题。要彻底解决这个问题，就必须使用一个通用的字符集UCS（Universal Character Set）和一个通用的字符编码Unicode。 Unicode 可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么就可以彻底解决乱码问题。这就是Unicode，就像它的名字一样，这是一种所有符号的编码。 Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 Unicode只是一个符号集，只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 问题事实上，Unicode在实现上存在两个需要解决的问题： (1) 如果采用多字节定长存储，则面临着极大的存储空间浪费以及字符集扩展问题。如：单字节的ASCII编码将浪费大量存储空间。(2) 如果采用多字节非定长存储，则面临着不定长编码的识别问题。即，如何知道一个编码使用了多少字节。 目前，有三种被广泛认知的Unicode实现方式：UTF-8，UTF-16（字符用两个字节或四个字节表示），UTF-32（字符用四个字节表示）。然而只有UTF-8有效地解决了上述两个问题，使得其成为目前最广泛的Unicode实现方式。 UTF-8UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有二条： (1) 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。(2) 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 下表总结了UTF-8编码规则，字母x表示可用编码的位。 Unicode符号范围(十六进制) UTF-8编码方式(二进制) 0000-0000-0000-007F 0xxxxxxx 0000-0080-0000-07FF 110xxxxx 10xxxxxx 0000-0800-0000-FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001-0000-0010-FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx UTF-8的编码规则：如果第一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字符。 下面，还是以汉字”严”为例，演示如何实现UTF-8编码。已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 历史 ASCII 1960 开发 1963 发布 1986 最后一次更新 ISO-8859-1 1998 发布 GB2312 1980 发布 GBK 1993 发布 UCS-2 In the late 1980s Unicode 1987 开发 1991 发布 1996 实现代理机制（UTF-16） 2015 最新版8.0 UTF-8 1993 发布 2008 流行 UTF-16 1996 开发 2000 发布 根据以上各个编码发展的一些时间节点，再配合下图UTF-8制霸互联网过程，会有一个比较清晰的了解。 (完) 参考 字符，字符集，字符编码 字符编码笔记：ASCII，Unicode和UTF-8 The Unicode Consortium 字体编辑用中日韩Unicode编码表]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《兄弟连》观影有感]]></title>
    <url>%2F2017%2F01%2F15%2Fband-of-brothers%2F</url>
    <content type="text"><![CDATA[电影《血战钢锯岭》的上映获得了极大的反响，战争题材的电影时隔多年又重新焕发光彩。我本人也对这类电影颇感兴趣，可能是我内心的确很想了解数十年前人类历史上最惨烈的两场大规模战争的真实面目。 然而，国产抗战剧没有多少部让我能够真正予以赞许。国产抗战剧永远都是对战争胜利一方歌功颂德，将己方士兵都描绘成类似于董成瑞、邱少云一样的置之生死于度外的英雄式人物，将对方士兵极致丑化。当然，我深信那段时期我们有着大量敢于英勇就义的战士，也不否认敌方士兵的穷凶极恶。但我想说的是，我们的抗战剧总是缺少类似纪录片一样的客观、公正的态度，无法真实地呈现出战争的惨烈，参战士兵、人民的真实感受。战争片的意义是在于让观影者能够身临其境地感受这一切，进而能够珍惜、维护这来之不易的和平。 很庆幸，《太平洋战争》、《兄弟连》等作品都是以最底层、最前线的士兵的经历和回忆来还原这一切，所以在《兄弟连》中甚至从未出现过高级军官的指点江山的场景。 《兄弟连》是根据美国101陆军空降师部队E连的真实事迹改编，描述的是第二次世界大战的尾声，也是战况最为惨烈的时节。1944年6月6日，美国101空降师506团E连奉命空降登陆诺曼底，此后一年多经历了高密集度的战斗，从法国的卡朗唐镇到荷兰的埃因霍温，再到比利时的巴斯托尼，德国的海格纳镇，到最后的纳粹德军最高首领的大本营贝希特斯加登，所到之处皆留下了E连兄弟们的身影和鲜血。 这里我不想具体述说影片的内容，只想回顾那几幕令我为之动容的场景。 第一幕温特斯中尉率领士兵在荷兰的堤防上展开了一次危险任务，结果获得了空前的胜利，他也因此被晋升为步兵营的执行官。然而，在这次任务中，温特斯在带头侧翼攻击时，他一个人冲到了堤坝上，结果一个俯身在草丛中的德军士兵发现了他，而那个德军士兵只是个少年，温特斯举枪对准他的那一刻，他的表情经历了惊讶到恐惧的。然而，为了完成战斗任务，温特斯还是果断开了枪。而此后，这一场景成为了温特斯脑海中挥之不去的一幕。也是他至此之后再也没开过枪的原因。 第二幕而在新一轮轰炸中，乔治·鲁兹未来得及回到散兵坑，他在炮火中疯狂地向散兵坑爬去，散兵坑里穆克和潘卡拉也是大喊着快点，然而即将爬进坑时，一枚炮弹掉入了他眼前的这个散兵坑。那一瞬间，鲁兹整个人都懵了。 第三幕鲁兹清醒后又立刻爬到了卡伍德·李普顿所在的散兵坑。然而，又一枚炮弹调到他们散兵坑的边缘处，庆幸的是，炮弹一直冒着烟，但没有爆炸。死里逃生的两人盯着炮弹很久，然后鲁兹点起了一根烟，而李普顿作为一个从来不抽烟的人却主动抢了过来抽了起来。难以想象，两人的内心是怎样一种感受。 第四幕在严寒的冬季中，饥寒交迫的E连于比利时巴斯托尼市外的森林中孤军奋战，死守同盟军的防线，仅有少量的补给品与弹药抵达，但是御寒的冬衣却一件也没有。在德军一轮轮的炮轰之中，多名弟兄阵亡。其中有一幕就是，乔·托伊被炮弹炸断了腿，哭着喊着要站起来，那时他的内心已经到了崩溃的边缘。 第五幕炮轰过后，听到乔·托伊的呼救，好友比尔·葛奈瑞立马去营救他，一路上，乔·托伊还喊着要自己的钢盔。然而，在快到散兵坑的时候，又一轮炮轰开始，一枚炮弹不幸落在他们身边。然而，这一幕发生在刚从散兵坑跳出来准备帮忙的巴克·康普顿眼前。自此之后，他的心理发生了巨大变化。 第六幕E连进入德国后，一个小分队在邻近的森林中，发现了一个被遗弃的纳粹集中营，里面还充满了饱受折磨的俘虏。令人惊奇的是，当地居民竟否认这个集中营的存在。而就在此时，欧洲各地都纷纷传来发现死亡集中营的消息。看到那一幕，我的心情很沉重，我并不明白希特勒为什么要搞种族屠杀。而这仅仅只是其中一个纳粹集中营，难以想象奥斯维辛集中营是如何人间地狱一般地存在。战争总是会让无辜的人民成为战争的牺牲品。 第七幕影片的最后，温特斯少校老年的的回忆，有一天他的孙子问了他一个问题,“爷爷，你是战争中的英雄吗？”，他说：“不是，可是我和英雄们一起战斗。”。说完，温特斯老爷爷哽咽了，我能感受到他内心那种复杂的心情。 无论是哪一方的士兵，都只是在执行上级的命令，战场上你死我活，然而在战争之前，他们也许和你我一样拥有着相似的爱好，从事着相似的工作，甚至能够彼此建立起友谊。我想，从他们返回战场那一刻，没有人不希望和平的到来。 现在，中日一旦出现紧张关系，总有人叫嚣着要开战，也许他们看惯例国产抗战剧、看惯了祖国的各种军演，总以为我们无需伤亡即可碾压对手。对这种一时图快，看不清战争危害的言行，我只想说：Naive！ 最后，我想以德军投降前，一位纳粹将军对自己的士兵们说的简短的几句话结尾： 这是一场漫长的战争，也是一场艰苦的战争，你们英勇并骄傲地为祖国作战，你们是一群特别的人，你中有我，我中有你，只有在战斗中会有这样的友谊，在兄弟之间共同使用散兵坑，在最需要的时刻相互扶持，你们见证过死亡，一起接受磨难，我很自豪能与你们每个人共同服役，你们有权利享受永远的快乐和平的生活… (完)]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS原理]]></title>
    <url>%2F2017%2F01%2F08%2Fhttps-principle%2F</url>
    <content type="text"><![CDATA[HTTPS概述 在互联网领域，安全永远是一个重点关注的方向。现阶段HTTPS的安全指数显然要比HTTP高很多，前者也是互联网发展的必然趋势。为了鼓励全球网站的HTTPS实现，Google甚至调整了其搜索引擎算法，提升HTTPS网站的搜索排名。那HTTPS和HTTP到底有什么区别呢？简单而言，HTTPS可以认为是HTTP+TLS/SSL。 SSL/TLS 作用我们都知道不使用SSL/TLS的HTTP通信，即不加密的通信。其具有以下几个潜在的风险： (1) 窃听风险（eavesdropping）：第三方可获知通信内容。(2) 篡改风险（tampering）：第三方可以修改通信内容。(3) 冒充风险（pretending）：第三方可以冒充他人进行通信。 而SSL/TLS的作用就是解决上述几个潜在的风险： (1) 所有信息都是加密传播，第三方无法窃听。(2) 具备校验机制，一旦被篡改，通信双方会立刻发现。(3) 配备身份整数，防止身份被冒充。 历史互联网加密通信协议的历史，几乎与互联网的历史一样长。 1994年，NetScape公司设计了SSL协议（Secure Socket Layer）的1.0版本，但是未发布。1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。1996年，SSL 3.0版本问世，得到大规模应用。1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版本。2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版本和TLS 1.2版本。最新的变动是2011年TLS 1.2的修订版 目前，应用最广泛的是TLS 1.0，然后是SSL 3.0。不过，主流浏览器都已经实现了对TLS 1.2的支持。通常，TLS 1.0会被标示为SSL 3.1，TLS 1.1会被标示为TLS 1.2会被标示为SSL 3.3。 原理SSL/TLS协议的基本思路是采用公钥加密法，即：客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，使用私钥解密。而这个过程中需要解决两个问题：(1) 如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 (2) 公钥加密法作为一种非对称加密算法，计算量比对称加密算法大很多，如何减少耗费时间？ 解决方法：每次会话（session），客户端和服务器端都生成一个”会话密钥“（session key），用它来加密信息。这里，客户端仅用公钥加密”会话密钥”，而通信过程中的大量信息则用”会话密钥”来加密，由于大量使用对称加密算法，所以可以大幅减少加密运算的时间。 因此，SSL/TLS协议的基本过程如下： (1) 客户端向服务器索取并验证公钥。(2) 双方协商生成”会话密钥”。(3) 双方采用”会话密钥”进行加密通信。 其中，(1)(2)又称为”握手阶段“（handshake）。 握手阶段 如上图所示，”握手阶段”包含4次通信。而”握手阶段”的所用通信都是明文的。下面分别介绍”握手阶段”的4次通信过程。 客户端发出请求(ClientHello)ClientHello请求: 客户端（通常是浏览器）先向服务器发出加密通信的请求。在这一步，客户端主要向服务器提供以下信息： (1) 支持的协议版本，如TLS 1.0版本。(2) 一个客户端生成的随机数，稍后用于生成”会话密钥”。(3) 支持的加密方法，如RSA公钥加密。(4) 支持的压缩方法。 需要注意的是，客户端发送的信息之中不包括服务器的域名。即理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。 但是，这对于虚拟主机用户来说，极为不便。为此，2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。 服务器回应(ServerHello)ServerHello: 服务器收到客户端请求后，向客户端发出回应。在这一步，服务器端的回应包含以下内容： (1) 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。(2) 一个服务器生成的随机数，稍后用于生成”会话密钥”。(3) 确认使用的加密方法，如RSA公钥加密。(4) 服务器证书。 除了以上信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 (1) 一个随机数。该随机数用服务器公钥加密，防止被窃听。(2) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。(3) 客户端握手结束通知，表示客户端的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。 此过程中出现的随机数是整个握手阶段出现的第三个随机数，又称”premaster secret“。经过这个过程之后，服务器端和客户端就同时拥有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥“。 但是为什么一定要用三个随机数来生成”会话密钥”呢？CSDN的dog250给出如下解释： “不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，premaster secret本身就是一个随机数，再加上hello消息中的随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。Premaster secret的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么premaster secret就有可能被才出来，那么仅适用premaster secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上premaster secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机数可能完全不随机，可是三个伪随机数就十分接近随机了。” 此外，如果前一步，服务器要求客户端提供证书，客户端会在这一步发送证书及其相关信息。 服务器回应服务器收到客户端的第三个随机数premaster secret之后，计算本次会话所需的”会话密钥”。然后，向客户端发送以下信息： (1) 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。(2) 服务器握手结束通知，表示服务器的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。 数字签名和数字证书我们回顾一下SSL/TLS握手阶段的整个过程的一些关键点，来看看其中是否还有潜在的风险。 (1) 客户端产生一个随机数A，以明文方式发给服务器。(2) 服务器产生一个随机数B，以明文方式发给客户端。此外，服务器还将公钥放入证书中发送给客户端。(3) 此时客户端拥有随机数A，B以及证书（公钥）。服务器拥有随机数A，B以及其私钥。(4) 客户端产生一个随机数C，使用公钥加密，发送给服务器，服务器以私钥解密，得到随机数C。此过程使用公钥加密法（非对称加密）。(5) 此时客户端和服务器使用三个随机数A，B，C，生成相同的成对的”会话密钥”。(6) 此后，客户端和服务器端进行通信采用”会话密钥”进行加密通信（对称加密），可以减少加解密时间，提高通信速度。 那么问题来了，步骤(2)中的证书是如何防止被窃听和篡改的呢？这个过程中似乎没有采用任何算法对其进行加密保护。我们知道随机数A，B作为明文可以被窃听，而如果证书也被篡改，恶意的第三方甚至就可以向用户提供自己的证书（公钥），将自己伪装成客户端想要通信的对象。最终可以获取用户的信息，达到其进一步的目的。 因此，客户端需要一种机制来确认其请求的服务器是否伪造的。而数字证书就像身份证一样可以证明服务器的真伪。 数字证书数字证书由专门的机构”证书中心“（Certificate authority，简称CA）颁发。证书中心用自己的私钥，将服务器的公钥及其相关信息进行加密，生成”数字证书“（Digital Certificate）。 客户端（浏览器）的”证书管理器“，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发，浏览器会发出另一种警告。 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，从而进行后续的通信加密相关操作。 数字签名除了数字证书以外，我们经常还能看到的”数字签名“（Digital signature）又是什么呢？ 数字签名是将公钥密码反过来使用。签名者将信息用私钥加密（这是一种反用，因为通常私钥是用于解密）；验证者使用公钥解密信息。也就是说，客户端向服务器端发送消息是一种正向的公钥加密法（公钥加密，私钥解密）；而服务器端向客户端发送消息则是一种公钥加密法的反向实现（私钥加密，公钥解密）。 数字签名的目的是为了防止通信内容被修改。通信过程中，信息发送方对通信内容进行hash，并将产生hash值作为通信内容的摘要（digest）。 然后，使用私钥将摘要进行加密，得到数字签名。而接收端使用公钥即可解密得到摘要。 最终，客户端将通信内容进行hash，并与解密后得到的摘要进行比对，如果一致则表示内容未被篡改。 （完） 参考[1] SSL/TLS协议运行机制的概述[2] SSL协议中的DH算法的pre-master-secret[3] 数字签名是什么？[4] 数字签名[5] 图解SSL/TLS]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【我的阅读轨迹】]]></title>
    <url>%2F2017%2F01%2F05%2Fread-books%2F</url>
    <content type="text"><![CDATA[回看过去三个月，从10月中旬开始毕设换题，到现在2017年初，自己一直忙于毕设相关事宜，几乎没有挤出一些时间来提升自己。为了能够改变现在的生活状态，写下这篇博文以长期记录自己的阅读轨迹，希望能够以此鞭策自己不断地阅读、学习、思考、成长。 2017《黑客与画家》 时间: 1月3日至1月16日，一遍完 简评: 硅谷创业之父Paul Graham的散文集，描述了作者对社会现象、人生、技术、创业等方面的一些自己独特的见解。虽然本书并没有围绕具体某个主题展开，但是作者不时地传达出“Think Different”的思想，非常好的一本书。 《Webkit技术内幕》 时间: 1月17日至今，未读完 《启示录 打造用户喜爱的产品》 时间: 2月9日至2月19日，一遍完 简评: 本书分为三大部分：人员，流程，产品。人员部分主要介绍了围绕一款产生的设计、开发、发布、管理需要进行的人员配置，这方面非常适合类似相管理等职位的人来阅读；流程部分则介绍了产品诞生的过程中，以产品经理为中心，如何处理和协调整个过程；产品部分则是关于作者根据自己30年从业经验给产品经理的一些意见和建议。总体来说，本书对于产品经理是一本非常有价值的指导手册。希望有时间能够再次拜读此书，汲取其精华，写一点自己的得心体会。 《从0到1 开启商业与未来的秘密》 时间: 2月19日至5月1日 简评: 作者是Paypal的创始人之一，本文与《黑客与画家》类似，每一章都一个主题，但整本书始终围绕着如何创业、如何打造一个成功的企业来阐述作者的观点。 《Objective-C编程》 时间: 7月11日至7月13日 简评: 入职后转岗iOS开发，Mentor指引了一条学习路线，首先看《Object-C编程》这本书。此书非常适于iOS开发入门，主要介绍Object-C的语法及相关概念。题外话：不得不说人的潜能真的是难以置信，三天看完了一本380页的技术书，还撸了一遍示例代码。 《iOS编程》 时间: 7月22日至7月30 简评: 一本非常好的开发指南，初学如果不看斯坦福的视频，对于里面的介绍各种东西可能会比较陌生。本书覆盖的知识面比较广，但并不深入，总体来说是一本非常好的iOS入门书籍。 《iOS开发进阶》 时间: 9月10日~9月12日 简评: 花了三天空余时间过了一遍这本书，主要介绍了作者根据自身多年iOS开发经验总结出的一些开发经验，包括对使用工具提高开发、应用发布的注意事项等等。 《iOS Core Animation：Advanced Techniques》 时间: 9月12日~10月24日 简评: 主要介绍Core Animation框架的关键原理以及相关应用，值得二刷。 《Swift 3.0 官方教程中文版》 时间: 10月24日~10月30日 简评: 官方教程，详细全面地介绍了swift 3.0的特性。语言类的官方教程阅读起来还是比较枯燥的，希望以后能够多多锻炼。 《Swift编程入门》 时间：10月31日~11月12日 简评：此书是对Swift官方教程进行了简化，整理得出的一般语言教程，很不错，值得向初学者推荐。 2018《iOS应用逆向工程》 时间：1月14日~2月22日 简评：作者根据自己多年的逆向经验总结的一套方法，包括：理论、工具、实例等。总体说来，iOS逆向的原理并不复杂，工程性比较强，如果要做iOS逆向工程，可以深入了解一下。 笔记：iOS逆向工程——基础篇、Logos基础语法 《MBA教不了的创富课》 时间：2月23日~2月25日 简评：本书分为九个部分：念力、统御力、成长力、财务力、前瞻力、决断力、竞争力、洞察力、批判力。老雕从这个九个方面开始，以身边或编撰的创业故事为例，以创业者、企业管理者的角度来分析如何应对各种公司、企业运行过程中可能会遇到的一些问题。并以此进行总结。虽然，书中对于理论总结的部分很少，但是通过这些例子实实在在地传达了这些理念。值得推荐！ 《机器学习实战》 时间：4月12日~至今 简评： （未完待续）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel手册]]></title>
    <url>%2F2016%2F12%2F18%2Fchisel-manual%2F</url>
    <content type="text"><![CDATA[原文链接 Introduce本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本手册中，我们假设您已经了解了Scala的基础知识。如果你不熟悉Scala，我们建议你参考一本优秀的Scala书。 NodesChisel中任何硬件设计最终都由节点对象的图表表示。Chisel中的用户代码生成此节点图，然后将其传递到Chisel后端以转换为Verilog或C ++代码。节点定义如下：1234567891011121314151617181920class Node &#123; // name assigned by user or from introspection var name: String = "" // incoming graph edges def inputs: ArrayBuffer[Node] // outgoing graph edges def consumers: ArrayBuffer[Node] // node specific width inference def inferWidth: Int // get width immediately inferrable def getWidth: Int // get first raw node def getRawNode: Node // convert to raw bits def toBits: Bits // convert to raw bits def fromBits(x: Bits): this.type // return lit value if inferrable else null def litOf: Lit // return value of lit if litOf is non null def litValue(default: BigInt = BigInt(-1)): BigInt &#125; 节点类层次结构的最高级别如图所示。基本类别是： Lit: 常量或文本 Op: 逻辑或算术操作 Updateable: 条件更新节点 Data: 具有类型的wire或port Reg: 上升沿触发的寄存器 Mem: 存储 Lits原始文本表示为Lit节点，定义如下：1234class Lit extends Node &#123; // original value val inputVal: BigInt&#125; 原始文本包含位的集合。用户不直接创建原始文本，而是使用第Type节中定义的类型构造函数。 Ops原始操作表示为如下定义的Op节点：1234class Op extends Node &#123; // op name used during emission val op: String&#125; Ops计算其输入的组合函数。 Types表示硬件设计的Chisel图包含原始节点和类型节点。Chisel类型系统与底层Scala类型系统分开维护，因此类型节点散布在原始节点之间，以允许Chisel检查并响应Chisel类型。Chisel类型节点在硬件设计转换为C ++或Verilog之前被擦除。getRawNode运算符定义在基本Node类中，跳过类型节点并返回找到的第一个原始节点。下图显示了内置的Chisel类型层次结构，其中Data为最顶层节点。 内置标量类型包括Bool，SInt和UInt和内置聚合类型Bundle和Vec允许用户使用其他类型的集合扩展Chisel数据类型集。Data自身就是一个节点：1234567891011121314151617181920212223abstract class Data extends Node &#123; override def cloneType(): this.type = this.getClass.newInstance.asInstanceOf[this.type] // simple conversions def toSInt: SInt def toUInt: UInt def toBool: Bool def toBits: Bits // flatten out to leaves of tree def flatten: Array[(String, Data)] // port direction if leaf def dir: PortDir // change dir to OUTPUT def asOutput: this.type // change dir to INPUT def asInput: this.type // change polarity of dir def flip: this.type // assign to input def :=[T &lt;: Data](t: T) // bulk assign to input def &lt;&gt;(t: Data)&#125; Data类具有用于在类型之间转换和将端口方法委托给其单个输入的方法。我们将在Port一节讨论端口。最后，用户可以在其自己的类型节点（例如bundle）中覆盖cloneType方法，以便反映克隆所需的构造参数。Data节点可以用于四种目的： types: UInt(width = 8), 在指定最小位宽的图中记录中间类型（在本节中描述） wires: UInt(width = 8), 作为数据的前向声明，允许将来的条件更新（在Updateable一节中描述） ports: UInt(dir = OUTPUT, width = 8), 定义模块接口的专用线，还能指定方向（在Ports一节中描述） literals: UInt(1) 或 UInt(1, 8), 可以使类型对象构造函数来构造其值和可选宽度。 Bits在Chisel中，位的原始集合如下Bits类型定义所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344object Bits &#123; def apply(dir: PortDir = null, width: Int = -1): Bits // create literal from BigInt or Int def apply(value: BigInt, width: Int = -1): Bits // create literal from String using // base_char digit+ string format def apply(value: String, width: Int = -1): Bits &#125;class Bits extends Data with Updateable &#123; // bitwise-not def unary_~(): Bits // bitwise-and def &amp; (b: Bits): Bits // bitwise-or def | (b: Bits): Bits // bitwise-xor def ^ (b: Bits): Bits // and-reduction def andR(): Bool // or-reduction def orR(): Bool // xor-reduction def xorR(): Bool // logical NOT def unary_!(): Bool // logical AND def &amp;&amp; (b: Bool): Bool // logical OR def || (b: Bool): Bool // equality def ===(b: Bits): Bool // inequality def != (b: Bits): Bool // logical left shift def &lt;&lt; (b: UInt): Bits // logical right shift def &gt;&gt; (b: UInt): Bits // concatenate def ## (b: Bits): Bits // extract single bit, LSB is 0 def apply(x: Int): Bits // extract bit field from end to start bit pos def apply(hi: Int, lo: Int): Bits&#125;def Cat[T &lt;: Data](elt: T, elts: T*): Bits Bits具有用于简单位操作的方法。注意，##是二进制连接，而Cat是一个正则拼接。为了避免与Scala的内置==冲突，Chisel的按位比较命名为===。使用Fill可以创建n位宽的域：1def Fill(n: Int, field: Bits): Bits 一个两输入的选择器可以使用Mux：1def Mux[T &lt;: Data](sel: Bits, cons: T, alt: T): T 常量或字面值使用Scala整数或传递给构造函数的字符串表示：1234UInt(1)UInt("ha")UInt("o12")UInt("b1010") // binary 4-bit lit from string. 如下图所示的最左边子图，可以产生Lit。 操作返回一个实际的操作符节点和类型节点组合成输入类型节点。参见上图，了解更复杂的例子。 Bools布尔值用Bools表示：123456object Bool &#123; def apply(dir: PortDir = null): Bool // create literal def apply(value: Boolean): Bool&#125;class Bool extends UInt Bool与UInt(width = 1)相等。 NumsNum是一个类型节点，定义了算术运算：123456789101112131415161718class Num extends Bits &#123; // Negation def unary_-(): Bits // Addition def +(b: Num): Num // Subtraction def -(b: Num): Num // Multiplication def *(b: Num): Num // Greater than def &gt;(b: Num): Bool // Less than def &lt;(b: Num): Bool // Less than or equal def &lt;=(b: Num): Bool // Greater than or equal def &gt;=(b: Num): Bool&#125; 有符号和无符号整数被认为是定点数的子集，并且分别由类型SInt和UInt表示：12345678910111213141516object SInt &#123; def apply (dir: PortDir = null, width: Int = -1): SInt // create literal def apply (value: BigInt, width: Int = -1): SInt def apply (value: String, width: Int = -1): SInt &#125;class SInt extends Num object UInt &#123; def apply(dir: PortDir = null, width: Int = -1): UInt // create literal def apply(value: BigInt, width: Int = -1): UInt def apply(value: String, width: Int = -1): UInt&#125;class UInt extends Num &#123; // arithmetic right shift override def &gt;&gt; (b: UInt): SInt&#125; 带符号的定点数（包括整数）使用二进制补码格式表示。 BundlesBundle将几种不同类型的命名字段组合成一个连续单元，非常像C中的struct：1234class Bundle extends Data &#123; // shallow named bundle elements def elements: ArrayBuffer[(String, Data)]&#125; 使用elements方法可以获取Bundle中每个元素的名称和类型，flatten方法返回嵌套聚合的叶子处的元素。 用户可以通过对bundle进行子类化来定义新的bundle，如下所示：12345class MyFloat extends Bundle &#123; val sign = Bool() val exponent = UInt(width = 8) val significand = UInt(width = 23)&#125; 元素通过Scala字段访问：12val x = new MyFloat() val xs = x.sign 当使用C++或Verilog后端发送时，bundle的元素的名称是从它们的bundle字段名获取的，使用Scala内省。 VecsVecs可以创建可索引元素向量：1234567891011121314151617object Vec &#123; def apply[T &lt;: Data](elts: Seq[T]): Vec[T] def apply[T &lt;: Data](elt0: T, elts: T*): Vec[T] def fill[T &lt;: Data](n: Int) (gen: =&gt; T): Vec[T] def tabulate[T &lt;: Data](n: Int)(gen: (Int) =&gt; T): Vec[T] def tabulate[T &lt;: Data](n1: Int, n2: Int) (gen: (Int, Int) =&gt; T): Vec[Vec[T]]&#125;class Vec[T &lt;: Data](n: Int, val gen: () =&gt; T) extends Data &#123; def apply(idx: UInt): T def apply(idx: Int): T def forall(p: T =&gt; Bool): Bool def exists(p: T =&gt; Bool): Bool def contains[T &lt;: Bits](x: T): Bool def count(p: T =&gt; Bool): UInt def indexWhere(p: T =&gt; Bool): UInt def lastIndexWhere(p: T =&gt; Bool): UInt&#125; 其中n个元素类型由gen定义。用户可以使用Int索引静态访问元素或使用UInt索引动态访问元素，其中动态访问创建一个虚拟类型节点（表示读取“端口”），该节点使用给定地址记录读取。在任一情况下，用户可以连线到读取的结果如下：1v(a) := d 只读存储器可以使用Vecs来表示：12val rom = Vec(UInt(3), UInt(7), UInt(4), UInt(0)) &#123; UInt(width=3) &#125;val dout = rom(addr) Bit Width Inference用户需要设置端口和寄存器的位宽度，否则节点上的位宽度会自动推断，除非用户手动设置（使用Extract或Cat）。位宽推理引擎从图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度： 其中例如wz是线z的位宽度，并且＆规则应用于所有按位逻辑运算。 位宽推理过程继续，直到没有位宽改变。除了固定位数的右移之外，位宽度推断规则规定输出位宽不能小于输入位宽度，因此，输出位宽度增长或保持相同。此外，寄存器的宽度必须由用户明确地或从复位值的位宽指定。从这两个要求，我们可以知道位宽推理过程将收敛到一个固定点。 Updateables当描述线和状态节点的操作时，将规范作为输出值的一系列条件更新并且跨多个单独的语句分布这些更新通常是有用的。例如，可以立即引用数据节点的输出，但可以稍后设置其输入。可更新表示一个条件可更新节点，其累积对节点的访问，并且其稍后可以生成多路复用器以在电路中组合这些访问。123456789abstract class Updateable extends Node &#123; // conditional reads def reads: Queue[(Bool, UInt)] // conditional writes def writes: Queue[(Bool, UInt, Node)] // gen mux integrating all conditional writes def genMuxes(default: Node) override def := (x: Node): this.type&#125; Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格：1234567object when &#123; def apply(cond: Bool)(block: =&gt; Unit): when&#125;class when (prevCond: Bool) &#123; def elsewhen (cond: Bool)(block: =&gt; Unit): when def otherwise (block: =&gt; Unit): Unit&#125; when操作具有动态作用域的全局条件堆栈。因此，when创建一个在条件函数调用中有效的新条件。例如：123456789def updateWhen (c: Bool, d: Data) = when (c) &#123; r := d &#125;when (a) &#123; updateWhen(b, x)&#125;// the same aswhen (a) &#123; when (b) &#123; r := x &#125;&#125; Chisel为其他常见形式的条件更新提供了一些语法糖：1234def unless(c: Bool)(block: =&gt; Unit) = when (!c) &#123; block )def otherwise(block: =&gt; Unit) = when (Bool(true)) &#123; block &#125; 我们再介绍用于条件更新的switch语句，其涉及对一个公共密钥的一系列比较：12def switch(c: UInt)(block: =&gt; Unit): Unit def is(v: Bool)(block: =&gt; Unit) Forward Declaration纯组合电路不允许在节点之间有循环，如果检测到这样的循环，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建法向组合电路，通过添加其输入从已经定义的节点导出的新节点。 时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前参考输出线。因为Scala按顺序执行程序语句，所以我们允许数据节点用作提供节点声明的线，可：1234567val pcPlus4 = UInt() val brTarget = UInt()val pcNext = Mux(pcSel, brTarget, pcPlus4)val pcReg = RegUpdate(pcNext)pcPlus4 := pcReg + UInt(4)... brTarget := addOut 接线操作符：=用于在pcReg和addOut定义之后进行连接。在所有赋值完成后，如果前向声明未分配，则是一个错误。… RegsChisel支持的状态元素的最简单形式是一个正边沿触发寄存器，定义如下：12345678910object Reg &#123; def apply[T &lt;: Data] (data: T, next: T = null, init: T = null): T &#125;object RegNext &#123; def apply[T &lt;: Data] (next: T, init: T = null): T&#125;object RegInit &#123; def apply[T &lt;: Data] (init: T): T&#125;class Reg extends Updateable 可以如下进行构造：1234val r1 = RegUpdate(io.in)val r2 = RegReset(UInt(1, 8))val r3 = RegUpdate(io.in, UInt(1)) val r4 = Reg(UInt(width = 8)) 其中resetVal是reset为ture时用于寄存器的值。 MemsChisel通过Mem结构支持随机存取存储器。写入Mem是正边沿触发，读取是组合或正边沿触发。1234567object Mem &#123; def apply[T &lt;: Data](depth: Int, gen: =&gt; T, seqRead: Boolean = false): Mem&#125;class Mem[T &lt;: Data](gen: () =&gt; T, depth: Int, seqRead: Boolean = false) extends Updateable &#123; def apply(idx: UInt): T&#125; 通过应用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32个条目的寄存器文件可以表示如下：1234val rf = Mem(32, UInt(width = 64)) when (wen) &#123; rf(waddr) := wdata &#125; val dout1 = rf(waddr1)val dout2 = rf(waddr2) 如果设置了可选参数seqRead，当Reg分配了Mem的输出时，Chisel将尝试推断顺序读端口。单读，单写SRAM可以描述如下：1234val ram1r1w = Mem(1024, UInt(width = 32), seqRead = true)val dout = Reg(UInt())when (wen) &#123; ram1r1w(waddr) := wdata &#125; when (ren) &#123; dout := ram1r1w(raddr) &#125; 单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：12345val ram1p =Mem(1024, UInt(width = 32), seqRead = true)val dout = Reg(UInt())when (wen) &#123; ram1p(waddr) := wdata &#125; .elsewhen (ren) &#123; dout := ram1p(raddr) &#125; 如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据是实现定义的。Mem还支持子字写入的写掩码。如果相应的屏蔽位置1，则写入给定位。12val ram = Mem(256, UInt(width = 32))when (wen) &#123; ram.write(waddr, wdata, wmask) &#125; Ports端口是用作硬件模块接口的Data派生节点。端口是原始Data对象的定向版本。端口方向定义如下：123trait PortDirobject INPUT extends PortDir object OUTPUT extends PortDir 聚合端口可以使用vec或bundle的实例作为叶子递归构造。 Modules在Chisel中，module与Verilog中的module非常相似，在生成电路中定义了层次结构。分层模块命名空间可在下游工具中访问，以帮助调试和物理布局。用户定义的模块被定义为一个类： 继承自Module 包含一个接口Bundle，其存储在一个名为io的域中 在其构造器中将子电路连接起来 用户通过子类化Module来编写自己的模块，其定义如下：123456abstract class Module &#123; val io: Bundle var name: String = "" def compileV: Unit def compileC: Unit&#125; 并定义自己的io字段。例如，要定义一个两输入多路复用器，我们将定义一个模块如下：123456789class Mux2 extends Module &#123; val io = new Bundle&#123; val sel = Bool(INPUT) val in0 = Bool(INPUT) val in1 = Bool(INPUT) val out = Bool(OUTPUT) &#125; io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)&#125; :=赋值运算符，在模块定义的主体中使用，是Chisel中的一个特殊运算符，它将左侧的输入连接到右侧的输出。它通常用于将输出端口连接到其定义。 &lt;&gt;操作符批量连接父对象模型之间的对等相反接口或父/子模块之间相同的接口。批量连接使用路径名匹配连接叶子端口。仅当其中一个端口非空时允许连接，从而允许用户重复地批量连接部分填充的接口。在所有连接完成并且电路正在精心设计后，Chisel警告用户端口是否只有一个到它们的连接。 当使用C++或Verilog后端发送时，存储在模块中的节点和子模块的名称可以使用Scala内省从它们的模块字段名称中获取。使用函数setName()设置节点或子模块的名称。 Black Box黑盒允许用户定义接口到Chisel之外定义的电路。用户定义： 一个BlackBox子类的模块 一个带有接口的io 可选的VerilogParameters子类 例如，可以将简单的ROM黑盒定义为：12345678910111213141516171819class RomIo extends Bundle &#123; val isVal = Bool(INPUT) val raddr = UInt(INPUT, 32) val rdata = UInt(OUTPUT, 32) raddr.setName("RADDR")&#125;class RomParams extends VerilogParameters &#123; val MY_STR = "Test" val MY_INT = 5&#125;class Rom extends BlackBox &#123; val io = new RomIo() val romParams = new RomParams() setVerilogParameters(romParams) renameClock(Driver.implicitClock, "clock_A") renameClock("my_other_clock", "test_clock") renameReset("rst") // Define how to use in simulation here&#125; 参数将转换为verilog参数，其中包含类定义中使用的名称和值。setVerilogParameters也可以直接接受一个字符串。函数renameClock可以获取Clock对象或时钟的字符串名称来重命名BlackBox输出时钟。函数renameReset将重命名隐式重置。如果需要命名其他重置，请调用setName()。在io类中显示了使用setName()的示例。而不是被称为io_raddr为黑箱的io，它将是RADDR。黑盒在c模拟中作为一个模块。这意味着您可以使用io实现BlackBox的功能，以便您可以验证您的设计。 Printf &amp; SprintfChisel提供了为调试目的格式化和打印字符串的能力。printf和sprintf结构与它们的C名称类似：它们取一个格式字符串和可变数量的参数，然后分别打印或返回一个字符串。在模拟期间，printf在上升时钟沿将控制字符串打印到控制台。另一方面，sprintf返回格式化的字符串作为位向量。 支持的格式说明符是％b（二进制数），％d（十进制数），％x（十六进制数）和％s（由8位扩展ASCII字符序列组成的字符串）。%%指定文字％。）与C不同，没有宽度修饰符：相应参数的位宽决定了字符串表示中的宽度。 以下示例在c为true时打印“0x4142 16706 AB”行：123val x = Bits(0x4142)val s1 = sprintf("%x %s", x, x);when (c) &#123; printf("%d %s\n", x, s1); &#125; Assert运行时断言由assert结构提供。在仿真期间，如果断言的论点在上升时钟边沿为false，则会打印错误并终止仿真。例如，以下将在十个时钟周期后终止仿真：123val x = Reg(init = UInt(0, 4)) x := x + UInt(1)assert(x &lt; UInt(10)) Main &amp; Testing为了构造一个电路，用户从它们的顶层main函数调用chiselMain：1234object chiselMain &#123; def apply[T &lt;: Module] (args: Array[String], comp: () =&gt; T): T &#125; 运行以上对象会在–targetDir dir_name参数指定的目录下生成module_name.cpp和module_name.h C++文件。 测试是电路设计的一个关键部分，因此在Chisel中，我们提供了一种测试电路的机制，通过使用Tester类的子类在Scala中提供测试向量：123456789101112131415161718class Tester[T &lt;: Module] (val c: T, val isTrace: Boolean = true) &#123; var t: Int var ok: Boolean val rnd: Random def int(x: Boolean): BigInt def int(x: Int): BigInt def int(x: Bits): BigInt def reset(n: Int = 1) def step(n: Int): Int def pokeAt(data: Mem[T], index: Int, x: BigInt) def poke(data: Bits, x: BigInt) def poke(data: Aggregate, x: Array[BigInt]) def peekAt(data: Mem[T], index: Int) def peek(data: Bits): BigInt def peek(data: Aggregate): Array[BigInt] def expect (good: Boolean, msg: String): Boolean def expect (data: Bits, target: BigInt): Boolean&#125; 它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户利用： poke: 设置端口和状态值 step: 以一个时间单位执行电路 peek: 读端口和状态值 expect: 比较测试电路的值和预期的值 用户通过如下方式连接tester实例和模块：12345object chiselMainTest &#123; def apply[T &lt;: Module] (args: Array[String], comp: () =&gt; T)( tester: T =&gt; Tester[T]): T&#125; 当–test作为chiselMain的参数时，tester实例在单独的进程中运行被测设计（DUT），stdin和stdout连接，以便调试命令可以发送到DUT，并且响应可以从DUT如图所示。 如下所示：1234567891011121314class Mux2Tests(c: Mux2) extends Tester(c) &#123; val n = pow(2, 3).toInt for (s &lt;- 0 until 2) &#123; for (i0 &lt;- 0 until 2) &#123; for (i1 &lt;- 0 until 2) &#123; poke(c.io.sel, s) poke(c.io.in1, i1) poke(c.io.in0, i0) step(1) expect(c.io.out, (if (s == 1) i1 else i0)) &#125; &#125; &#125; &#125; 使用poke将Mux2的每个输入的分配设置为适当的值。对于这个特定的例子，我们通过将输入硬编码到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块的适当输入，并告诉模拟将这些值分配给我们正在测试的器件的输入c，步骤电路和测试期望值。最后，下面显示了如何调用测试器：123chiselMainTest(args + "--test", () =&gt; new Mux2())&#123; c =&gt; new Mux2Tests(c)&#125; 最后，chiselMain*有以下命令参数： –targetDir 目标路径前缀–genHarness 生成C++文件–debug 把所有wire放入C++类文件中–compile 编译生成的C++–test 使用C++应用运行测试–backend v 产生verilog–backend c 产生C++（默认）–vcd 使能vcd打印 C++ EmulatorC ++仿真器基于使用C ++模板的快速多字库。 单个字由val_t定义如下：123typedef uint64_t val_t; typedef int64_t sval_t; typedef uint32_t half_val_t; 多字由dat_t定义，如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081template &lt;int w&gt; class dat_t &#123; public: const static int n_words; inline int width ( void ); inline int n_words_of ( void ); inline bool to_bool ( void ); inline val_t lo_word ( void ); inline unsigned long to_ulong ( void ); std::string to_str (); dat_t&lt;w&gt; ();template &lt;int sw&gt; dat_t&lt;w&gt; (const dat_t&lt;sw&gt;&amp; src); dat_t&lt;w&gt; (const dat_t&lt;w&gt;&amp; src); dat_t&lt;w&gt; (val_t val);template &lt;int sw&gt; dat_t&lt;w&gt; mask(dat_t&lt;sw&gt; fill, int n);template &lt;int dw&gt; dat_t&lt;dw&gt; mask(int n);template &lt;int n&gt; dat_t&lt;n&gt; mask(void); dat_t&lt;w&gt; operator + ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator - ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator - ( ); dat_t&lt;w+w&gt; operator * ( dat_t&lt;w&gt; o ); dat_t&lt;w+w&gt; fix_times_fix( dat_t&lt;w&gt; o ); dat_t&lt;w+w&gt; ufix_times_fix( dat_t&lt;w&gt; o ); dat_t&lt;w+w&gt; fix_times_ufix( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &lt; ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &gt; ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &gt;= ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator &lt;= ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; gt ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; gte ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; lt ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; lte ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator ^ ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator &amp; ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator | ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator ~ ( void); dat_t&lt;1&gt; operator ! ( void ); dat_t&lt;1&gt; operator &amp;&amp; ( dat_t&lt;1&gt; o ); dat_t&lt;1&gt; operator || ( dat_t&lt;1&gt; o ); dat_t&lt;1&gt; operator == ( dat_t&lt;w&gt; o ); dat_t&lt;1&gt; operator == ( datz_t&lt;w&gt; o ); dat_t&lt;1&gt; operator != ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator &lt;&lt; ( int amount ); dat_t&lt;w&gt; operator &lt;&lt; ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; operator &gt;&gt; ( int amount ); dat_t&lt;w&gt; operator &gt;&gt; ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; rsha ( dat_t&lt;w&gt; o); dat_t&lt;w&gt;&amp; operator = ( dat_t&lt;w&gt; o ); dat_t&lt;w&gt; fill_bit(val_t bit); dat_t&lt;w&gt; fill_byte(val_t byte, int nb, int n);template &lt;int dw, int n&gt; dat_t&lt;dw&gt; fill( void );template &lt;int dw, int nw&gt; dat_t&lt;dw&gt; fill( dat_t&lt;nw&gt; n );template &lt;int dw&gt; dat_t&lt;dw&gt; extract(); template &lt;int dw&gt; dat_t&lt;dw&gt; extract(val_t e, val_t s); template &lt;int dw, int iwe, int iws&gt; dat_t&lt;dw&gt; extract(dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s);template &lt;int sw&gt; dat_t&lt;w&gt; inject(dat_t&lt;sw&gt; src, val_t e, val_t s); template &lt;int sw, int iwe, int iws&gt; dat_t&lt;w&gt; inject (dat_t&lt;sw&gt; src, dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s); template &lt;int dw&gt; dat_t&lt;dw&gt; log2(); dat_t&lt;1&gt; bit(val_t b); val_t msb();template &lt;int iw&gt; dat_t&lt;1&gt; bit(dat_t&lt;iw&gt; b)&#125;template &lt;int w, int sw&gt; dat_t&lt;w&gt; DAT(dat_t&lt;sw&gt; dat);template &lt;int w&gt; dat_t&lt;w&gt; LIT(val_t value);template &lt;int w&gt; dat_t&lt;w&gt; mux ( dat_t&lt;1&gt; t, dat_t&lt;w&gt; c, dat_t&lt;w&gt; a ) 其中w是位宽参数。 Chisel编译器将顶层模块编译为可以创建和执行的单个扁平的mod_t类：123456789101112131415class mod_t &#123; public: // initialize module virtual void init (void) &#123; &#125;; // compute all combinational logic virtual void clock_lo (dat_t&lt;1&gt; reset) &#123; &#125;; // commit state updates virtual void clock_hi (dat_t&lt;1&gt; reset) &#123; &#125;; // print printer specd node values to stdout virtual void print (FILE* f) &#123; &#125;; // scan scanner specd node values from stdin virtual bool scan (FILE* f) &#123; return true; &#125;; // dump vcd file virtual void dump (FILE* f, int t) &#123; &#125;;&#125;; Chisel编译器可以创建一个线束，或者用户可以自己写一个线束。以下是CPU模块的线束示例：12345678910111213#include "cpu.h"int main (int argc, char* argv[]) &#123; cpu_t* c = new cpu_t(); int lim = (argc &gt; 1) ? atoi(argv[1]) : -1; c-&gt;init(); for (int t = 0; lim &lt; 0 || t &lt; lim; t++) &#123; dat_t&lt;1&gt; reset = LIT&lt;1&gt;(t == 0); if (!c-&gt;scan(stdin)) break; c-&gt;clock_lo(reset); c-&gt;clock_hi(reset); c-&gt;print(stdout); &#125; &#125; Verilog当-v参数传递到chiselMain时，Chisel生成Verilog。 例如，从SBT，以下：1run --v 将在目标目录中生成名为module-name.v的单个Verilog文件。该文件将包含一个模块，每个模块定义为在chiselMain中创建的顶层模块的子模块。具有相同接口和主体的模块将被缓存和重用。 Multiple Clock DomainsCreating Clock domains为了使用多个时钟域，用户必须创建多个时钟。在Chisel中，时钟是用复位信号参数创建的一级节点，并定义如下：123class Clock (reset: Bool) extends Node &#123; def reset: Bool // returns reset pin&#125; 在Chisel中有一个内置的隐式时钟，状态元素默认使用：1var implicitClock = new Clock( implicitReset ) 状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：123Reg(... clock: Clock = implicitClock) Mem(... clock: Clock = implicitClock) Module(... clock: Clock = implicitClock) Crossing Clock Domains有两种方式可以定义电路在时钟域之间发送数据。第一种和最原始的方式是使用由两个寄存器组成的同步电路，如下所示：1234567// signalA is in clock domain clockA,// want a version in clockB as signalBval s1 = Reg(init = UInt(0), clock = clockB) val s2 = Reg(init = UInt(0), clock = clockB)s1 := signalAs2 := s1;signalB := s2 由于亚稳性问题，该技术限于在域之间传递一位数据。 在域之间发送数据的第二种更一般的方式是通过使用异步fifo：12class AsyncFifo[T&lt;:Data](gen: T, entries: Int, enq_clk: Clock, deq_clock: Clock) extends Module 然后，我们可以通过指定标准fifo参数和两个时钟，然后使用标准去耦就绪/有效信号，从时钟频率A到时钟B获得一个版本的signalA：123456val fifo = new AsyncFifo(Uint(width = 32), 2, clockA, clockB)fifo.io.enq.bits := signalAsignalB := fifo.io.deq.bits fifo.io.enq.valid := condA fifo.io.deq.ready := condB... Backend Specific Multiple Clock Domains时钟域可以以域特定的方式映射到C++和Verilog后端。为了展示如何驱动多时钟设计，考虑硬件示例，其中两个模块使用AsyncFifo进行通信，每个模块在不同的时钟：fastClock和slowClock。 C++在C ++后端，对于每个时钟i，有一个： uint64_t clk_i域表示时钟i的周期 uint63_t clk_i_cnt域表示时钟i当前计数 clock_lo_i和clock_hi_i int reset()函数，其保证了所有的clock_lo和clock_hi函数被立即调用 int clock(reset)函数，其计算最小增量，调用适当的clock_lo和clock_hi，并返回使用的最小增量。 为了建立C++模拟，用户需要： 将所有周期字段初始化为所需周期 将所有计数字段初始化为期望的相位 调用reset 重复调用时钟逐步模拟 以下是slowClock / fastClock的main函数C++示例：12345678910111213int main(int argc, char** argv) &#123; ClkDomainTest_t dut; dut.init(1); dut.clk = 2; dut.clk_cnt = 1; dut.fastClock = 4; dut.fastClock_cnt = 0; dut.slowClock = 6; dut.slowClock_cnt = 0; for (int i = 0; i &lt; 12; i ++) dut.reset(); for (int i = 0; i &lt; 96; i ++) dut.clock(LIT&lt;1&gt;(0)); &#125; Verilog在verilog中， Chisel为每个时钟/复位创建一个新端口 Chisel将所有时钟连接到顶部模块 用户必须为每个时钟i创建一个always块时钟驱动器 以下是驱动slowClock / fastClock示例电路的顶层线束的Verilog示例：123456789101112131415161718192021module emulator; reg fastClock = 0, slowClock = 0, resetFast = 1, resetSlow = 1; wire [31:0] add, mul, test; always #2 fastClock = ~fastClock; always #4 slowClock = ~slowClock; initial begin #8 resetFast = 0; resetSlow = 0; #400 $finish; endClkDomainTest dut ( .fastClock(fastClock), .slowClock(slowClock), .io_resetFast(resetFast), .io_resetSlow(resetSlow), .io_add(add), .io_mul(mul), .io_test(test));endmodule Extra Stuff1234567891011121314151617181920def ListLookup[T &lt;: Bits](addr: UInt, default: List[T], mapping: Array[(UInt, List[T])]): List[T]// def Lookup[T &lt;: Data] (addr: UInt, default: T, mapping: Seq[(UInt, T)]): T// // n-way multiplexordef MuxCase[T &lt;: Data](default: T, mapping: Seq[(Bool, T)]): T//// n-way indexed multiplexer:def MuxLookup[S &lt;: UInt, T &lt;: Data](key: S, default: T, mapping: Seq[(S, T)]): T//// create n enum values of given typedef Enum[T &lt;: UInt](n: Int)(gen: =&gt; T): List[T]//// create enum values of given type and namesdef Enum[T &lt;: UInt](l: Symbol *)(gen: =&gt; T): Map[Symbol, T]//// create enum values of given type and namesdef Enum[T &lt;: UInt](l: List[Symbol])(gen: =&gt; T): Map[Symbol, T] Standard LibraryMath123456789101112131415// Returns the log base 2 of the input // Scala Integer rounded updef log2Up(in: Int): Int// Returns the log base 2 of the input // Scala Integer rounded downdef log2Down(in: Int): Int////// Returns true if the input Scala Integer //isapowerof2def isPow2(in: Int): Boolean////// linear feedback shift registerdef LFSR16(increment: Bool = Bool(true)): UInt Sequential123456789101112// Returns the n-cycle delayed version// of the input signal// Has an optional enable signal defaulting to true def ShiftRegister[T &lt;: Data (in: T, n: Int, en = Bool(true)): T def Counter(cond: Bool, n: Int) = &#123; val c = RegReset(UInt(0, log2Up(n))) val wrap = c === UInt(n-1) when (cond) &#123; c := Mux(Bool(!isPow2(n)) &amp;&amp; wrap, UInt(0), c + UInt(1)) &#125; (c, wrap &amp;&amp; cond) &#125; UInt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Returns the number of bits set in the // input signal. Causes an exception if // the input is wider than 32 bits.def PopCount(in: UInt): UInt////// Returns the reverse the input signaldef Reverse(in: UInt): UInt////// returns the one hot encoding of// the input UIntdef UIntToOH(in: UInt, width: Int): UInt////// does the inverse of UIntToOHdef OHToUInt(in: UInt): UIntdef OHToUInt(in: Seq[Bool]): UInt////// Builds a Mux tree out of the input// signal vector using a one hot encoded // select signal. Returns the output of // the Mux treedef Mux1H[T &lt;: Data] (sel: UInt, in: Vec[T]): T def Mux1H[T &lt;: Data] (sel: Vec[Bool], in: Vec[T]): T//// Builds a Mux tree under the// assumption that multiple// select signals can be enabled.// Priority is given to the first// select signal. Returns the output // of the Mux tree.def PriorityMux[T &lt;: Data](sel: UInt, in: Seq[T]): T def PriorityMux[T &lt;: Data](sel: Seq[UInt], in: Seq[T]): T//// Returns the bit position of the// trailing 1 in the input vector with // the assumption that multiple bits of // the input bit vector can be setdef PriorityEncoder(in: UInt): UIntdef PriorityEncoder(in: Seq[Bool]): UInt////// Returns the bit position of the// trailing 1 in the input vector with// the assumption that only one bit in// the input vector can be setdef PriorityEncoderOH(in: UInt): UIntdef PriorityEncoderOH(in: Seq[Boo]): UInt Decoupled123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Adds a ready-valid handshaking // protocol to any interface. The// standard used is that the// consumer uses the fliped interface//class DecoupledIO[+T &lt;: Data](gen: T) extends Bundle &#123; val ready = Bool(INPUT) val valid = Bool(OUTPUT) val bits = gen.cloneType.asOutput&#125;////// Adds a valid protocol to any// interface. The standard used is // that the consumer uses the// fliped interface.class ValidIO[+T &lt;: Data](gen: T) extends Bundle &#123; val valid = Bool(OUTPUT) val bits = gen.cloneType.asOutput&#125;////// Hardware module that is used to // sequence n producers into 1 consumer// Priority is given to lower// producer// Example usage: // val arb = new Arbiter(UInt(), 2)// arb.io.in(0) &lt;&gt; producer0.io.out// arb.io.in(1) &lt;&gt; producer1.io.out// consumer.io.in &lt;&gt; arb.io.outclass Arbiter[T &lt;: Data](gen: T, n: Int) extends Module// Hardware module that is used to// sequence n producers into 1 consumer.// Producers are chosen in round robin// order// Example usage:// val arb = new RRArbiter(UInt(), 2) // arb.io.in(0) &lt;&gt; producer0.io.out // arb.io.in(1) &lt;&gt; producer1.io.out // consumer.io.in &lt;&gt; arb.io.out class RRArbiter[T &lt;: Data](gen: T, n: Int) extends Module// Generic hardware queue. Required // parameter entries controls the// depth of the queues. The width of// the queue is determined from the // inputs.// Example usage:// val q = new Queue(UInt(), 16)// q.io.enq &lt;&gt; producer.io.out// consumer.io.in &lt;&gt; q.io.deqclass Queue[T &lt;: Data] (gen: T, entries: Int, pipe: Boolean = false, flow: Boolean =false) extends Module//// A hardware module that delays data // coming down the pipeline by the // number of cycles set by the // latency parameter. Functionality // is similar to ShiftRegister but // this exposes a Pipe interface. // Example usage:// val pipe = new Pipe(UInt()) // pipe.io.enq &lt;&gt; produce.io.out // consumer.io.in &lt;&gt; pipe.io.deqclass Pipe[T &lt;: Data](gen: T, latency: Int = 1) extends Module （完）]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel入门教程]]></title>
    <url>%2F2016%2F12%2F17%2Fchisel-tutorial%2F</url>
    <content type="text"><![CDATA[原文链接 介绍Chisel（Constructing Hardware In a Scala Embedded Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例子来说明某些重要的Scala特征，可以让你只使用本文介绍的东西也能完成一些伟大的硬件设计。 当你越来越有经验，希望自己的代码能够更加简化或提高复用性，你会发现有必要了解Scala语言的潜力。 所以，进一步学习Scala会让你变得更加专业。 Chisel仍处于起步阶段，你可能会遇到一些实现方面的bug，甚至可能会遇到一些概念设计问题。不过，我们正在积极地修改和改进语言，并且对错误报告和建议开放。即使在早期阶段，我们希望Chisel将帮助设计师在构建易于重复使用和维护的设计时更有效率。 Chisel硬件表达此版本的Chisel只支持二进制逻辑，不支持三态信号。 我们专注于二进制逻辑设计，因为它们构成了实践中的绝大多数设计。我们忽略对当前Chisel语言中的三态逻辑的支持，因为这在工业环境中也很少支持，并且难以在受控硬宏之外可靠地使用。 Chisel数据类型Chisel数据类型用于指定状态元素中保存的值或wire上传输的值。虽然硬件设计最终操作的是二进制数值向量，但对于值的其他抽象表示具有更清晰的规范，并且能够帮助工具生成更优化的电路。在Chisel中，原始比特集合可以用Bits类型来表示。带符号和无符号整数被认为是定点数的子集，可以用SInt和UInt来表示。带符号定点整数（包括整数）使用二进制补码格式来表示。布尔值可以用Bool类型表示。注意，这些类型与Scala的内建类型不同，例如Int或Boolean。另外，Chisel定义了Bundle用来将值进行集合（类似于其他语言中的struct），还定义了Vec用来对值的集合进行索引。 常量或字面值使用Scala整数或传递给构造函数的字符串表示：123456789UInt(1) // decimal 1-bit lit from Scala Int.UInt("ha") // hexadecimal 4-bit lit from string.UInt("o12") // octal 4-bit lit from string.UInt("b1010") // binary 4-bit lit from string.SInt(5) // signed decimal 4-bit lit from Scala Int. SInt(-8) // negative decimal 4-bit lit from Scala Int. UInt(5) // unsigned decimal 3-bit lit from Scala Int.Bool(true) // Bool lits from Scala lits. Bool(false) 下划线可以用作长字符串文字中的分隔符，以帮助可读性，但在创建值时会被忽略，例如：1UInt("h_dead_beef") // 32-bit lit of type UInt 默认情况下，Chisel编译器将每个常量的大小设置为保存常量所需的最小位数，包括带符号类型的符号位。位宽也可以在字面上明确指定，如下所示：12345UInt("ha", 8) // hexadecimal 8-bit lit of type UInt UInt("o12", 6) // octal 6-bit lit of type UInt UInt("b1010", 12) // binary 12-bit lit of type UIntSInt(5, 7) // signed decimal 7-bit lit of type SInt UInt(5, 8) // unsigned decimal 8-bit lit of type UInt 对于UInt类型值，值被零扩展到所需的位宽。对于类型为SInt的文字，该值被符号扩展以填充所需的位宽度。如果给定的位宽太小而不能容纳参数值，则会生成Chisel错误。 组合电路在Chisel中，电路会被表示为一张节点图。每个节点是具有零个或多个输入并驱动一个输出的硬件运算符。上面介绍的Uint是一种退化类型的节点，它没有输入，并且在其输出上驱动一个恒定的值。创建和连接节点的一种方法是使用字面表达式。例如，我们可以使用以下表达式来表示简单的组合逻辑电路：1(a &amp; b) | (~c &amp; d) 语法应该看起来很熟悉，用＆和|分别表示按位与和按位或，~表示按位非。a到d表示某些（未指定）宽度的命名导线。任何简单的表达式都可以直接转换成电路树，在叶子处使用命名的导线和操作符形成内部节点。表达式的电路输出取自树根处的运算符，在本示例中是按位或运算。简单表达式可以以树的形式构建电路，但是如果想以任意有向非循环图（DAG）的形式构建电路，我们需要描述扇出。在Chisel中，我们通过命名一根wire来表示一个子表达式，这样我们就可以在后续表达式中多次引用。我们通过声明变量来命名Chisel中的wire。例如，考虑如下示例的select表达式，它在后续的多选器描述中可以多次使用：12val sel = a | bval out = (sel &amp; in1) | (~sel &amp; in0) 关键字val是Scala的一部分，用于命名具有不会再更改的值的变量。 在上面的例子中它命名了wire类型的sel，保存了第一个按位或运算符的输出，以便输出可在第二个表达式中多次使用。 内建操作符Chisel定义了一组硬件操作符，如下表所示： 位宽接口用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度： 其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算。 位宽推测过程会持续到没有位宽改变。 除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。 此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。 我们选择的运算符名称受到Scala语言的限制。所以我们必须使用===表示等于判断逻辑和=/=表示不等判断逻辑，这样可以保持原生Scala相关运算符可用。 功能抽象我们可以定义函数来分解一个重复的逻辑，这样可以在后续设计中重复使用。例如，我们可以包装一个简单的组合逻辑块：12def clb(a: UInt, b: UInt, c: UInt, d: UInt): UInt = (a &amp; b) | (~c &amp; d) 其中clb是表示以a，b，c，d为参数的函数，并返回一个布尔电路的输出。 def关键字是Scala的一部分，表示引入了一个函数定义，每个语句后面跟一个冒号，然后是它的类型，函数返回类型在参数列表之后的冒号之后。（=）符号将函数参数列表与函数定义分隔开。然后我们就可以在其他的电路中使用了：1val out = clb(a,b,c,d) 我们将在后面介绍许多吊炸天的函数使用方法来构造硬件。 Bundles &amp; VecsBundle和Vec是可以允许用户使用其他数据类型来扩展Chisel数据类型集合的类。Bundle可以将一些不同类型的命名字段组合成一个单元，类似于C语言中的struct。用户可以通过将一个类定义为Bundle的子类来定义自己的bundle：1234567class MyFloat extends Bundle &#123; val sign = Bool() val exponent = UInt(width = 8) val significand = UInt(width = 23)&#125;val x = new MyFloat()val xs = x.sign scala约定将新类的名称的首字母大写，所以我们建议在Chisel中也遵循这个约定。 UInt构造函数的width命名参数指定类型中的位数。 Vecs用来创建一个可索引的元素向量，其构造如下所示：1234// Vector of 5 23-bit signed integers.val myVec = Vec.fill(5)&#123; SInt(width = 23) &#125; // Connect to one element of vector.val reg3 = myVec(3) （注意，我们必须在花括号内指定Vec元素的类型，因为我们必须将位宽参数传递给SInt构造器。）原始类（SInt，UInt和Bool）加上聚合类（Bundles和Vecs）都继承自一个公共的超类Data。在电路中，每个最终继承自Data的对象都可以表示为一个位向量。Bundle和Vec可以任意嵌套，从而构建复杂的数据结构：1234567class BigBundle extends Bundle &#123; // Vector of 5 23-bit signed integers. val myVec = Vec.fill(5) &#123; SInt(width = 23) &#125; val flag = Bool() // Previously defined bundle. val f = new MyFloat()&#125; 端口端口用作硬件组件的接口。一个端口可以是任意的Data对象，但它是具有方向的。Chisel提供端口构造函数，以允许在构建时给对象添加（输入或输出）。原始的端口构造函数需要将方向作为第一个参数（方向为INPUT或OUTPUT），将位数作为第二个参数（除了始终为1位的布尔值）。端口的声明如下所示：12345class Decoupled extends Bundle &#123; val ready = Bool(OUTPUT) val data = UInt(INPUT, 32) val valid = Bool(INPUT)&#125; Decoupled被定义后，它就会变成一个新的类型，可以根据需要用于模块接口或命名的wire集合。对象的方向也可以实例化时确定：12345class ScaleIO extends Bundle &#123; val in = new MyFloat().asInput val scale = new MyFloat().asInput val out = new MyFloat().asOutput&#125; asInput和asOutput方法可以强制数据对象的所有模块设置成对应的方向。通过将方向折叠到对象声明中，Chisel能够提供强大的布线能力，稍后会详细介绍。 Modules我们现在可以构建电路层次，我们可以从较小的子模块开开始构建更大的模块。例如，我们可以通过将三个2输入多路选择器连接在一起，构建一个4输入多路选择器模块：1234567891011121314151617181920212223class Mux4 extends Module &#123; val io = new Bundle &#123; val in0 = UInt(INPUT, 1) val in1 = UInt(INPUT, 1) val in2 = UInt(INPUT, 1) val in3 = UInt(INPUT, 1) val sel = UInt(INPUT, 2) val out = UInt(OUTPUT, 1) &#125; val m0 = Module(new Mux2()) m0.io.sel := io.sel(0) m0.io.in0 := io.in0; m0.io.in1 := io.in1 val m1 = Module(new Mux2()) m1.io.sel := io.sel(0) m1.io.in0 := io.in2; m1.io.in1 := io.in3 val m3 = Module(new Mux2()) m3.io.sel := io.sel(1) m3.io.in0 := m0.io.out; m3.io.in1 := m1.io.out io.out := m3.io.out &#125; 运行和测试现在我们已经定义了模块，我们将讨论如何实际运行并测试电路。Chisel代码可以转换为C++或Verilog。 为了编译电路，我们需要调用chiselMain：12345object tutorial &#123; def main(args: Array[String]) = &#123; chiselMain(args, () =&gt; Module(new Mux2())) &#125; &#125; 测试是电路设计的关键部分，因此在Chisel中，我们通过这样一种测试机制：使用Tester类的子类在Scala中提供测试向量：1234567891011121314151617class Tester[T &lt;: Module] (val c: T, val isTrace: Boolean = true) &#123; var t: Int val rnd: Random def int(x: Boolean): BigInt def int(x: Int): BigInt def int(x: Bits): BigInt def reset(n: Int = 1) def step(n: Int): Int def pokeAt(data: Mem[T], index: Int, x: BigInt) def poke(data: Bits, x: BigInt) def poke(data: Aggregate, x: Array[BigInt]) def peekAt(data: Mem[T], index: Int) def peek(data: Bits): BigInt def peek(data: Aggregate): Array[BigInt] def expect (good: Boolean, msg: String): Boolean def expect (data: Bits, target: BigInt): Boolean&#125; 它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户会用到一下这些： poke: 设置输入端口以及状态值 step: 以一个时间单元执行电路 peek: 读取端口和状态值 expect: 比较peek获得的值和期望的值 用户使用如下的方式连接tester和模块：12345object chiselMainTest &#123; def apply[T &lt;: Module] (args: Array[String], comp: () =&gt; T)( tester: T =&gt; Tester[T]): T&#125; 当- -test作为参数传递给chiselMainTest时，tester实例在独立的进程中运行被测器件（DUT），并连接stdin和stdout，这样调试命令可以发送到DUT，响应也可以从DUT接收，如图所示。 举例说明：1234567891011121314class Mux2Tests(c: Mux2) extends Tester(c) &#123; val n = pow(2, 3).toInt for (s &lt;- 0 until 2) &#123; for (i0 &lt;- 0 until 2) &#123; for (i1 &lt;- 0 until 2) &#123; poke(c.io.sel, s) poke(c.io.in1, i1) poke(c.io.in0, i0) step(1) expect(c.io.out, (if (s == 1) i1 else i0)) &#125; &#125; &#125;&#125; 使用poke将Mux2的每个输入的分别设置为合适的值。对于这个例子，我们通过硬编码输入到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块输入，让模拟将这些值分配给我们正在测试的器件c的输入，单步运行电路并对比期望值。最后，简单说明一下如何调用测试器：123chiselMainTest(args + "--test", () =&gt; Module(new Mux2()))&#123; c =&gt; new Mux2Tests(c)&#125; 还有其他的一些命令参数： –targetDir 目标路径名前缀–genHarness 生成C++文件–backend v 生成verilog–backend c 生成C++（默认）–vcd 开启vcd打印–debug 把所有的wire放入class文件 状态元素Chisel支持的状态元素的最简单形式是上升沿触发寄存器，可以实例化为：1val reg = Reg(next = in) 该电路具有输出，该输出是前一个时钟周期的输入信号产生的值。注意，我们不必指定Reg的类型，因为它会在实例化时从输入开始自动推断。在当前版本的Chisel中，时钟和复位是全局信号，在需要时可以隐式包含。使用寄存器，我们可以快速定义一些有用的电路结构。 例如，当当前值为true且之前的值为false时，上升沿检测器能够获取到布尔信号并输出true，如下所示：1def risingedge(x: Bool) = x &amp;&amp; !Reg(next = x) 计数器是一个重要的时序电路。 如果想构建一个向上计数器，计数到最大值max后回到零：12345def counter(max: UInt) = &#123; val x = Reg(init = UInt(0, max.getWidth)) x := Mux(x === max, UInt(0), x + UInt(1)) x&#125; 计数器复位值为0（宽度大到足以容纳max），当电路的全局复位置位时，寄存器将初始化为该值。计数器可用于构建很多有用的时序电路。例如，我们可以通过在计数器达到零时输出true来构建脉冲发生器：12// Produce pulse every n cycles.def pulse(n: UInt) = counter(n - UInt(1)) === UInt(0) 然后可以通过切换方波发生器脉冲序列，在每个脉冲上的true和false之间切换：12345678// Flip internal state when input true.def toggle(p: Bool) = &#123; val x = Reg(init = Bool(false)) x := Mux(p, !x, x) x&#125;// Square wave of a given period.def squareWave(period: UInt) = toggle(pulse(period/2)) 转发声明纯组合电路在节点之间不存在周期，如果检测到这样的周期，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建组合电路，通过添加一些输入从已经定义的节点导出的新节点。时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前输出。因为Scala顺序执行程序语句，所以我们允许数据节点作为wire来提供节点声明，这样可以立即被使用，但其输入将稍后设置。如下例所示，在简单的CPU中，我们需要定义pcPlus4和brTarget的线，以便在定义之前引用它们：1234567val pcPlus4 = UInt()val brTarget = UInt()val pcNext = Mux(io.ctrl.pcSel, brTarget, pcPlus4)val pcReg = Reg(next = pcNext, init = UInt(0, 32)) pcPlus4 := pcReg + UInt(4)...brTarget := addOut 接线操作符:=用于在pcReg和addOut定义后连接。 条件更新在前面使用到寄存器的示例中，我们简单地将组合逻辑块连接到寄存器的输入。当描述状态元素的操作时，指定何时将发生寄存器更新并且用几个单独的语句指明这些更新。Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格。例如，1234val r = Reg(init = UInt(0, 16)) when (cond) &#123; r := r + UInt(1) &#125; 其中只有在cond为真时，才在当前时钟周期的结尾更新寄存器r。when的参数是返回Bool值。后面的更新块只能包含使用赋值运算符:=，简单表达式和用val定义的命名引线的更新语句。在条件更新序列中，条件为真的最近条件更新优先。 例如：12when (c1) &#123; r := UInt(1) &#125; when (c2) &#123; r := UInt(2) &#125; 上述表达式会根据以下真值表更新r： c1 c2 r 0 0 r r 不变 0 1 2 1 0 1 1 1 2 c2优先于c1 下图显示了如何将每个条件更新视为在寄存器的输入之前插入mux，根据when选择更新表达式或之前的输入。编译器会把初始化值置于链的开头，以便如果在一个时钟周期内没有条件更新激活，则寄存器的加载使能将被置为无效，寄存器值就不会改变。 Chisel为条件更新的其他常见形式提供了一些语法糖。除非结构与when相同，但否定其条件。也就是说，123unless (c) &#123; body &#125;// the same aswhen (!c) &#123; body &#125; 更新块可以操作多个目标寄存器，在不同更新块中的也允许存在寄存器的不同重叠子集。每个寄存器只受其出现的条件的影响。组合电路（更新Wire）也是可能的。注意，所有组合电路需要默认值。例如：123r := SInt(3); s := SInt(3)when (c1) &#123; r := SInt(1); s := SInt(1) &#125; when (c2) &#123; r := SInt(2) &#125; 上述语句会根据如下真值表更新r和s： c1 c2 r s 0 0 3 3 0 1 2 3 1 0 1 1 1 1 2 1 条件更新结构可以嵌套，任何给定块在所有外嵌套条件的联合下才能执行。例如，123when (a) &#123; when (b) &#123; body &#125; &#125;// the same aswhen (a &amp;&amp; b) &#123; body &#125; 条件可以使用when，.elsewhen，.otherwise来链式表达，对应于Scala中的if, else if, else。例如：1234567when (c1) &#123; u1 &#125; .elsewhen (c2) &#123; u2 &#125; .otherwise &#123; ud &#125;// the same aswhen (c1) &#123; u1 &#125;when (!c1 &amp;&amp; c2) &#123; u2 &#125; when (!(c1 || c2)) &#123; ud &#125; 我们再介绍关于用于条件更新的switch语句，其涉及针对公共密钥的一系列比较。例如，1234567switch(idx) &#123; is(v1) &#123; u1 &#125; is(v2) &#123; u2 &#125;&#125;// the same sawhen (idx === v1) &#123; u1 &#125; .elsewhen (idx === v2) &#123; u2 &#125; Chisel还允许Wire，即一些组合逻辑的输出，成为条件性更新语句的目标，以允许逐步构建复杂的组合逻辑表达式。Chisel不允许不指定组合输出，并且如果组合输出未遇到无条件更新，则报告错误。 有限状态机在数字设计中有限状态机（FSM）是时序电路常用的类型。简单FSM的例子就是奇偶校验生成器：12345678910111213class Parity extends Module &#123; val io = new Bundle &#123; val in = Bool(dir = INPUT) val out = Bool(dir = OUTPUT) &#125; val s_even :: s_odd :: Nil = Enum(UInt(), 2) val state = Reg(init = s_even) when (io.in) &#123; when (state === s_even) &#123; state := s_odd &#125; when (state === s_odd) &#123; state := s_even &#125; &#125; io.out := (state === s_odd)&#125; 其中Enum(Uint(), 2)生成两个UInt数。当io.in为true时更新状态。需要注意的是，FSM的所有机制都建立在寄存器，线和条件更新的基础上。下面是一个复杂的FSM例子，这是一个自动售货机接收货币的电路：1234567891011121314151617181920212223242526272829class VendingMachine extends Module &#123; val io = new Bundle &#123; val nickel = Bool(dir = INPUT) val dime = Bool(dir = INPUT) val valid = Bool(dir = OUTPUT) &#125; val s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: Nil = Enum(UInt(), 5) val state = Reg(init = s_idle) when (state === s_idle) &#123; when (io.nickel) &#123; state := s_5 &#125; when (io.dime) &#123; state := s_10 &#125; &#125; when (state === s_5) &#123; when (io.nickel) &#123; state := s_10 &#125; when (io.dime) &#123; state := s_15 &#125; &#125; when (state === s_10) &#123; when (io.nickel) &#123; state := s_15 &#125; when (io.dime) &#123; state := s_ok &#125; &#125; when (state === s_15) &#123; when (io.nickel) &#123; state := s_ok &#125; when (io.dime) &#123; state := s_ok &#125; &#125; when (state === s_ok) &#123; state := s_idle &#125; io.valid := (state === s_ok) &#125; 下面是一个使用switch语句定义的售货机FSM：123456789101112131415161718192021222324252627class VendingMachine extends Module &#123; val io = new Bundle &#123; val nickle = Bool(dir = INPUT) val dime = Bool(dir = INPUT) val valid = Bool(dir = OUTPUT) &#125; val s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: Nil = Enum(UInt(), 5) val state = Reg(init = s_idle) switch (state) &#123; is (s_idle) &#123; when (io.nickel) &#123; state := s_5 &#125; when (io.dime) &#123; state := s_10 &#125; &#125; is (s_5) &#123; when (io.nickel) &#123; state := s_10 &#125; when (io.dime) &#123; state := s_15 &#125; &#125; is (s_10) &#123; when (io.nickel) &#123; state := s_15 &#125; when (io.dime) &#123; state := s_ok &#125; &#125; is (s_ok) &#123; state := s_idle &#125; &#125; io.valid := (state === s_ok)&#125; 内存Chisel提供了创建只读和读/写存储器的功能。 ROM用户可以使用Vec定义ROM：12Vec(inits: Seq[T])Vec(elt0: T, elts: T*) 其中inits是初始化ROM的初始Data序列。例如，用户可以创建一个初始化为1,2,4,8的小型ROM，并使用计数器作为地址生成器循环访问所有值，如下所示：12val m = Vec(Array(UInt(1), UInt(2), UInt(4), UInt(8))) val r = m(counter(UInt(m.length))) 我们可以使用如下初始化的ROM创建n值正弦查找表：1234567def sinTable (amp: Double, n: Int) = &#123; val times = Range(0, n, 1).map(i =&gt; (i*2*Pi)/(n.toDouble-1) - Pi) val inits = times.map(t =&gt; SInt(round(amp * sin(t)), width = 32)) Vec(inits)&#125;def sinWave (amp: Double, n: Int) = sinTable(amp, n)(counter(UInt(n)) 其中amp用于缩放存储在ROM中的固定点值。 Mem存储器在Chisel中被给予特殊处理，因为存储器的硬件实现具有许多变化，例如，FPGA存储器与ASIC存储实例化的结果完全不同。Chisel定义了一个内存抽象，可以映射到简单的Verilog行为描述，也可以映射到从代工厂或IP厂商提供的外部内存生成器获得的内存模块实例。Chisel通过Mem结构可以支持随机存取存储器。写入Mems是正边沿触发，读取是组合或正边沿触发。12345678object Mem &#123; def apply[T &lt;: Data](type: T, depth: Int, seqRead: Boolean = false): Mem&#125;class Mem[T &lt;: Data](type: T, depth: Int, seqRead: Boolean = false) extends Updateable &#123; def apply(idx: UInt): T &#125; 通过使用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32-entry的寄存器堆可以如下表示：1234val rf = Mem(UInt(width = 64), 32) when (wen) &#123; rf(waddr) := wdata &#125; val dout1 = rf(waddr1)val dout2 = rf(waddr2) 如果设置了可选参数seqRead，当读地址为Reg时，Chisel将尝试推断顺序读端口。单读端口，单写端口SRAM可以描述如下：12345val ram1r1w = Mem(UInt(width = 32), 1024, seqRead = true)val reg_raddr = Reg(UInt())when (wen) &#123; ram1r1w(waddr) := wdata &#125; when (ren) &#123; reg_raddr := raddr &#125;val rdata = ram1r1w(reg_raddr) 单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：12345val ram1p = Mem(UInt(width = 32), 1024, seqRead = true) val reg_raddr = Reg(UInt())when (wen) &#123; ram1p(waddr) := wdata &#125; .elsewhen (ren) &#123; reg_raddr := raddr &#125;val rdata = ram1p(reg_raddr) 如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据为未定义。Mem还支持subword写入的写掩码。如果相应的屏蔽位置1，则写入给定位。123456val ram = Mem(UInt(width = 32), 256)when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;class FilterIO extends Bundle &#123; val x = new PLink().flip val y = new PLink()&#125; 其中flip递归地改变Bundle的“性别”，将输入改变为输出和输出。我们现在可以通过定义一个过滤器类扩展模块来定义一个过滤器：123class Filter extends Module &#123; val io = new FilterIO() ...&#125; 其中io包含了FilterIO。 Bundle 向量除了单个元素，元素向量可以形成更丰富的分层接口。例如，创建具有输入向量的交叉开关，产生输出向量，并通过UInt输入选择，我们可以使用Vec构造函数：12345class CrossbarIo(n: Int) extends Bundle &#123; val in = Vec.fill(n)&#123; new PLink().flip() &#125; val sel = UInt(INPUT, sizeof(n)) val out = Vec.fill(n)&#123; new PLink() &#125;&#125; 其中Vec用第一个参获取大小，区块返回一个端口作为第二个参数。 批量连接我们现在可以将两个过滤器组成一个过滤器块，如下所示：12345678class Block extends Module &#123; val io = new FilterIO() val f1 = Module(new Filter()) val f2 = Module(new Filter()) f1.io.x &lt;&gt; io.x f1.io.y &lt;&gt; f2.io.x f2.io.y &lt;&gt; io.y&#125; 其中&lt;&gt;批量连接同级模块之间的相反接口或父/子模块之间的相同接口。批量连接将相同名称的叶子端口彼此连接。在所有连接完成后，Chisel警告用户端口是否只有一个到它们的连接。 接口视图考虑一个由控制逻辑和数据通路子模块以及主机和存储器接口组成的简单CPU，如图所示。在这个CPU中，我们可以看到控制逻辑和数据通路每个只连接到指令和数据存储器接口的一部分。Chisel允许用户通过部分实现接口来实现这一点。用户首先定义到ROM和Mem的完整接口，如下： 123456789class RomIo extends Bundle &#123; val isVal = Bool(INPUT) val raddr = UInt(INPUT, 32) val rdata = UInt(OUTPUT, 32)&#125;class RamIo extends RomIo &#123; val isWr = Bool(INPUT) val wdata = UInt(INPUT, 32)&#125; 现在控制逻辑可以根据这些接口构建接口：12345class CpathIo extends Bundle &#123; val imem = RomIo().flip() val dmem = RamIo().flip() ...&#125; 而且控制和数据通路模块可以通过部分地分配来给这个接口来构建，如下所示：12345678910111213141516class Cpath extends Module &#123; val io = new CpathIo(); ... io.imem.isVal := ...; io.dmem.isVal := ...; io.dmem.isWr := ...; ...&#125;class Dpath extends Module &#123; val io = new DpathIo(); ... io.imem.raddr := ...; io.dmem.raddr := ...; io.dmem.wdata := ...; ...&#125; 我们现在可以使用批量连接来连接CPU，就像使用其他bundle一样：123456789101112class Cpu extends Module &#123; val io = new CpuIo() val c = Module(new CtlPath()) val d = Module(new DatPath()) c.io.ctl &lt;&gt; d.io.ctl c.io.dat &lt;&gt; d.io.dat c.io.imem &lt;&gt; io.imem d.io.imem &lt;&gt; io.imem c.io.dmem &lt;&gt; io.dmem d.io.dmem &lt;&gt; io.dmem d.io.host &lt;&gt; io.host&#125; 模块的功能创建制造用于模块构造的功能接口也是有用的。例如，我们可以构建一个构造函数，它将多路复用器输入作为参数，并返回多路复用器输出：123456789object Mux2 &#123; def apply (sel: UInt, in0: UInt, in1: UInt) = &#123; val m = new Mux2() m.io.in0 := in0 m.io.in1 := in1 m.io.sel := sel m.io.out &#125;&#125; 其中对象Mux2在Mux2模块类中创建一个Scala单例对象，并且apply定义了创建Mux2实例的方法。有了这个Mux2创建功能，Mux4的规格现在明显更简单。1234567891011class Mux4 extends Module &#123; val io = new Bundle &#123; val in0 = UInt(INPUT, 1) val in1 = UInt(INPUT, 1) val in2 = UInt(INPUT, 1) val in3 = UInt(INPUT, 1) val sel = UInt(INPUT, 2) val out = UInt(OUTPUT, 1) &#125; io.out := Mux2(io.sel(1), Mux2(io.sel(0), io.in0, io.in1), Mux2(io.sel(0), io.in2, io.in3))&#125; Chisel提供MuxCase，其本质上是一个n-way Mux。1MuxCase(default, Array(c1 -&gt; a, c2 -&gt; b, ...)) 其中每个条件/值在Scala数组中表示为元组，并且其中MuxCase可以转换为以下Mux表达式：1Mux(c1, a, Mux(c2, b, Mux(..., default))) Chisel还提供MuxLookup，其本质是一个n-way的可索引多路选择器：12MuxLookup(idx, default, Array(UInt(0) -&gt; a, UInt(1) -&gt; b, ...)) 这可以用MuxCase来重写：1MuxCase(default,Array((idx === UInt(0)) -&gt; a,(idx === UInt(1)) -&gt; b, ...)) 多态性和参数化Scala是一种强类型语言，使用参数化类型来指定通用函数和类。 在本节中，我们展示了Chisel用户如何使用参数化类来定义自己的可重用函数和类。 参数化函数前面我们在Bool上定义了Mux2，但现在我们展示如何定义一个通用的多路复用器功能。我们使用一个布尔条件和con和alt参数（对应于then和else表达式）来定义一个T类型的函数：1def Mux[T &lt;: Bits](c: Bool, con: T, alt: T): T &#123; ... &#125; 其中T需要是Bits的子类。Scala确保在Mux的每个使用中，它可以找到实际的con和alt参数类型的公共超类，否则会导致Scala编译类型错误。例如，1Mux(c, UInt(10), UInt(11)) 这会产生一个UInt线，因为con和alt参数都是UInt类型。我们现在提出一个更高级的参数化函数的例子，用于定义一个内积FIR数字滤波器，通常用于Chisel Num。 内积FIR滤波器可以在数学上定义为： 其中x是输入，w是权重向量。在Chisel中，这可以定义为：12345def delays[T &lt;: Data](x: T, n: Int): List[T] = if (n &lt;= 1) List(x) else x :: Delays(RegNext(x), n-1)def FIR[T &lt;: Data with Num[T]](ws: Seq[T], x: T): T = (ws, Delays(x, ws.length)).zipped.map( _ * _ ).reduce( _ + _ ) 其中延迟产生其输入的增量递增延迟的列表，并且reduce构造给出二进制组合器函数f的简化电路。在这种情况下，reduce创建一个求和电路。最后，FIR函数被限制为处理类型Num的输入，其中定义了Chisel乘法和加法。 参数化类与参数化函数一样，我们也可以参数化类，使它们可重用程度更高。例如，我们可以将Filter类概括为可以使用任何类型的链接。我们可以通过参数化FilterIO类和定义构造函数采取零参数类型构造函数来做到这点，如下所示：1234class FilterIO[T &lt;: Data](type: T) extends Bundle &#123; val x = type.asInput.flip val y = type.asOutput&#125; 我们现在可以通过定义一个模块类来定义Filter，该模块类也接收一个链接类型构造函数参数，并将其传递给FilterIO接口构造器：1234class Filter[T &lt;: Data](type: T) extends Module &#123; val io = new FilterIO(type) ...&#125; 我们现在可以定义一个基于PLant的过滤器，如下所示：1val f = Module(new Filter(new PLink())) 其中大括号{}表示零参数函数（也称为thunk），在这种情况下创建链接类型。通用FIFO可以这样定义，并使用如下：12345678910111213141516171819202122232425262728293031323334353637class DataBundle extends Bundle &#123; val A = UInt(width = 32) val B = UInt(width = 32)&#125;object FifoDemo &#123; def apply () = new Fifo(new DataBundle, 32)&#125;class Fifo[T &lt;: Data] (type: T, n: Int) extends Module &#123; val io = new Bundle &#123; val enq_val = Bool(INPUT) val enq_rdy = Bool(OUTPUT) val deq_val = Bool(OUTPUT) val deq_rdy = Bool(INPUT) val enq_dat = type.asInput val deq_dat = type.asOutput &#125; val enq_ptr = Reg(init = UInt(0, sizeof(n))) val deq_ptr = Reg(init = UInt(0, sizeof(n))) val is_full = Reg(init = Bool(false)) val do_enq = io.enq_rdy &amp;&amp; io.enq_val val do_deq = io.enq_rdy &amp;&amp; io.deq_val val is_empty = !is_full &amp;&amp; (enq_ptr === deq_ptr) val deq_ptr_inc = deq_ptr + UInt(1) val enq_ptr_inc = enq_ptr + UInt(1) val is_full_next = Mux(do_enq &amp;&amp; ~do_deq &amp;&amp; (enq_ptr_inc === deq_ptr), Bool(true), Mux(do_deq &amp;&amp; is_full, Bool(false), is_full)) enq_ptr := Mux(do_enq, enq_ptr_inc, enq_ptr) deq_ptr := Mux(do_deq, deq_ptr_inc, deq_ptr) is_full := is_full_next val ram = Mem(n) when (do_enq) &#123; ram(enq_ptr) := io.enq_dat &#125; io.enq_rdy := !is_full io.deq_val := !is_empty ram(deq_ptr) &lt;&gt; io.deq_dat&#125; 也可以定义成通用解耦接口：12345class DecoupledIO[T &lt;: Data](data: T) extends Bundle &#123; val ready = Bool(INPUT) val valid = Bool(OUTPUT) val bits = data.clone.asOutput &#125; 然后可以使用该模板向任何信号集添加握手：12class DecoupledDemoextends DecoupledIO()( new DataBundle ) FIFO的接口也可以如下进行简化：1234567class Fifo[T &lt;: Data] (data: T, n: Int) extends Module &#123; val io = new Bundle &#123; val enq = new DecoupledIO( data ).flip() val deq = new DecoupledIO( data ) &#125; ... &#125; 多时钟域Chisel 2.0介绍了对多时钟域的支持。 创建时钟域为了使用多个时钟域，用户必须创建多个时钟。 在Chisel中，时钟是使用复位信号参数创建的第一级节点，定义如下：123class Clock (reset: Bool) extends Node &#123; def reset: Bool // returns reset pin&#125; 在Chisel中有一个内置的隐式时钟，状态元素默认使用：1var implicitClock = new Clock( implicitReset ) 状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：123Reg(... clock: Clock = implicitClock) Mem(... clock: Clock = implicitClock) Module(... clock: Clock = implicitClock) 交叉时钟域有两种方式可以定义电路在时钟域之间发送数据。第一种也是最原始的方式就是使用由两个寄存器组成的同步器电路，如下所示：1234567// signalA is in clock domain clockA,// want a version in clockB as signalBval s1 = Reg(init = UInt(0), clock = clockB) val s2 = Reg(init = UInt(0), clock = clockB)s1 := signalAs2 := s1;signalB := s2 由于亚稳性问题，该技术只限于在域之间传递一位数据。在域之间发送数据的第二种和更一般的方式是通过使用异步fifo：1class AsyncFifo[T&lt;:Data](gen: T, entries: Int, enq_clk: Clock, deq_clock:Clock) extends Module 当通过指定标准fifo参数和两个时钟，然后使用标准解耦就绪/有效信号从时钟域clockA到clockB获取一个版本的signalA时：12345val fifo = new AsyncFifo(Uint(width = 32), 2, clockA, clockB)fifo.io..enq.bits := signalAsignalB := fifo.io.deq.bitsfifo.io.enq.valid := condAfifo.io.deq.ready := condB 后端特定的多个时钟域每个Chisel后端需要用户以后端特定的方式设置和控制多个时钟。为了展示如何驱动一个多时钟设计，考虑这样一个硬件示例，其中两个模块使用Async-Fifo进行通信，每个模块在不同的时钟：fastClock和slowClock。 C++在C++后端，对于每个时钟i有： size_t clk.len域表示时钟i的周期 clock_lo_i，clock_hi_i int reset() 函数，可以保证clock_lo和clock_hi的所有函数被立刻调用 int clock(reset)函数，计算最小增量，调用合适的clock_lo和clock_hi，并返回使用的最小增量。 为了设置一个C++模拟器，用户需要： 将所有周期字段初始化为期望的周期 将所有计数字段初始化为期望的相位 调用reset 重复调用时钟来单步模拟 以下是slowClock / fastClock的main函数C++示例：123456789101112int main(int argc, char** argv) &#123; ClkDomainTest_t dut; dut.init(1); dut.clk = 2; dut.clk_cnt = 1; dut.fastClock = 4; dut.fastClock_cnt = 0; dut.slowClock = 6; dut.slowClock_cnt = 0; for (int i = 0; i &lt; 12; i ++) dut.reset(); for (int i = 0; i &lt; 96; i ++) dut.clock(LIT&lt;1&gt;(0)); &#125; Verilog在Verilog中： Chisel为每个时钟/复位创建一个新端口， Chisel将所有的时钟连到顶层模块 用户必须要为每个时钟i创建一个always块时钟驱动 以下是驱动slowClock / fastClock电路的顶层Verilog示例：123456789101112131415161718192021module emulator; reg fastClock = 0, slowClock = 0, resetFast = 1, resetSlow = 1; wire [31:0] add, mul, test; always #2 fastClock = ~fastClock; always #4 slowClock = ~slowClock; initial begin # 8 resetFast = 0; resetSlow = 0; #400 $finish;endClkDomainTest dut ( .fastClock(fastClock), .slowClock(slowClock), .io_resetFast(resetFast), .io_resetSlow(resetSlow), .io_add(add), .io_mul(mul), .io_test(test));endmodule （完）]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机那些事(1)——开机启动过程]]></title>
    <url>%2F2016%2F12%2F14%2Fcomputer-boot-process%2F</url>
    <content type="text"><![CDATA[首先用一张图来大致了解一下计算机启动的整个过程。 上电按下主机的电源键后，计算机开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动CPU。如果启动失败（例如CPU坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。 如果前一个阶段未出错，就开始加电工作，在多CPU或多核CPU情况下，某一个CPU会被随机选取作为启动CPU（bootstrap processor，BSP）运行BIOS内部的程序。其余的CPU（application processor，AP）保持停机直到操作系统内核显式地使用它们。 2000年以前的计算机主板上均使用BIOS，如今绝大多数计算机采用的是EFI（Mac用的就是EFI）或UEFI，BIOS正在逐步被淘汰。基于EFI、UEFI的开机过程与传统的BIOS不尽相同，本文将以传统的BIOS，Intel CPU为例介绍开机过程。 此时CPU工作模式为实模式，该模式下地址总线是20位，寻址范围是0x00000~0xFFFFF的1M范围。这也就解释了为什么BIOS的容量只有1MB。 Intel CPU用三种运行模式: 实模式、32位保护模式、64位保护模式。实模式: Intel 8086的寻址方案，为了商业连续性，兼容了这古老的方案；保护模式: 采用了虚实地址转换方案。 BIOS启动之初，内存是空的。此时CPU处于实模式，内存的地址映射均为硬连接的设备。内存映射图如下图所示: 重置向量CPU启动后其大多数寄存器会被初始化为预定的值，包括指令寄存器（instruction pointer, EIP），它保存着CPU将要执行指令的内存地址。此时CPU会有一个特殊行为，其会对EIP的初始值加上一个基址寄存器的值，生成一个32位的地址0xFFFFFFF0。之所以称为特殊行为，是因为实模式下CPU只能寻址1MB地址空间，而这个32位地址已经大于1MB的内存限制。因此，0xFFFFFFF0也被称为重置向量（reset vector），参考上图0xFFFFFFF0处的标识。 于是，CPU开始执行0xFFFFFFF0地址处的指令，该地址处是一条JUMP指令，这条指令清空了基址寄存器的值，并让指令跳回到BIOS开始处（物理地址为0xF0000，参考上图0xF0000处的标识）以执行BIOS。 BIOS内部可以分成两个区块: code block（普通程序）、boot block（引导程序）。上电后，boot block会先被执行，它会检查code block的代码是否正确，如果正确，就会转到code block继续执行下去。 BIOS初始化0xF0000地址实际上是BIOS中的boot block的开始处。在这个阶段，会初始化部分硬件。系统的CPU、USB只有部分被初始化。 BIOS POST（加电自检）初始化完成后，CPU跳转到0xA0000地址处（参考上图640KB处）进行BIOS加电自检（power on self test, POST）。这个过程会检查计算机的各项组件，如CPU、显卡、内存、鼠标、键盘等。如果找不到内存或者键盘都有可能让BIOS停止工作并且打印一些相关的错误信息，如果找不到显卡BIOS会发出蜂鸣警告（因为无法显示画面）当CPU执行到0xC0000地址处（参考上图768KB处），开始寻找其他设备的ROM，如果找到任何其他设备的BIOS，它们也会被执行。下一步，显卡就会显示BIOS界面，并进行更深入的检查。 BIOS记录系统设定值检查完成后，BIOS会根据自己的“系统资源表”，对系统进行进一步确认，从而确定计算机配有哪些资源或设备。例如BIOS支持随插即用，它会检测并配置随插即用设备。然后BIOS会遵循高级配置电源接口（Advanced Configuration Power Interface，ACPI）在内存中设置好一系列的数据来描述硬件信息，以便被操作系统内核利用。 搜索MBR到这一步，BIOS开始尝试加载操作系统。它会从硬盘，光驱，软驱，网络等几个地方依次寻找操作系统（用户可以在BIOS设定中修改查找的优先级）。如果找不到操作系统，BIOS会停机并给出错误信息。 假设在硬盘上找到了操作系统，它会首先读取硬盘上的大小为512B的0号扇区，这个扇区被称为主引导记录（master boot record，MBR），其包含三部分：(1) 启动代码(2) 硬盘分区表(3) 结束标志字 BIOS读完磁盘上的MBR之后会把它拷贝到内存0x7C00地址处，然后CPU跳转到该内存地址执行MBR里的指令。下图可以帮助大家理解MBR的结构。 启动代码中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（Windows里面是Windows MBR Loader，Linux的话可能是LILO或者GRUB）。磁盘分区表是固定的，一个64字节的区域，每16字节为一个条目，描述硬盘的分区信息（这样就可以在同一磁盘的不同分区上安装不同的操作系统）。所以采用了MBR格式分区表的文件系统最多能安装四个操作系统。 引导操作系统执行MBR内部启动代码中的引导程序可以引导操作系统。Linux的引导程序LILO和GRUB可以处理各种不同的操作系统，文件系统和引导配置。 根据MBR启动代码中的引导程序加载包含了额外引导代码的其他扇区。这些扇区可能是一个分区的引导扇区，也可能是MBR安装时硬编码到MBR代码中的某个扇区。 执行步骤1载入的引导代码读取配置文件（例如，GRUB中是grub.conf，windows中是boot.ini）。然后它会显示启动选项，或直接启动操作系统 此时引导程序开始引导操作系统内核。它必须能够识别内核所在引导分区的文件系统。在Linux中，这一步是读取一个类似“vmlinuz”的文件，加载至内存中并跳转到内核启动代码。 此时我们回头再看第一张图，从引导程序到早期的内核初始化过程，此时内核解压开始了。 参考[1] How Computers Boot Up[2] 即将换掉传统BIOS的UEFI （完）]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>开机原理</tag>
        <tag>BIOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RISC-V——针对SoC的一套开放标准]]></title>
    <url>%2F2016%2F12%2F01%2Friscv-brief-introduction%2F</url>
    <content type="text"><![CDATA[对于大多数计算设备来说Linux已经成为了标准的操作系统，伯克利的研究者希望RISC-V也能够像Linux一样成为所有计算设备的标准ISA 片上系统（systems-on-a-chip, SoCs)，集成了处理器和cache，如今已经被越来越广泛的运用到各个领域之中。因此有越来越多的公司加入到了芯片制造这个领域之中。鉴于业界已经通过开放标准和开源软件进行了革命——如TCP/IP和Linux。那么作为最重要的接口之一的指令系统（instruction set architecture，ISA）为什么不对所有人开放呢？ 尽管指令系统由于历史或商业原因变得专利化了，但是从技术角度来看，必须要有免费的、开放的ISA。 这并不是一个遗漏的错误。一些拥有很成功ISA的公司，如ARM，IBM，Intel，MIPS都拥有针对他们自己的ISA的专利，而这使得我们这些没有license的学术机构和小公司根本无法使用这些ISA，除非付出巨额的费用。 而ARM的license甚至还不允许你设计自己的ARM核；而是只能使用其设计。目前世界上大约只有10家大公司才拥有修改其设计自己的ARM核的license。这就是商业，通过阻止别人进行设计改造从而扼杀了竞争和创新。 也不是因为公司做大部分的软件开发。虽然围绕这些流行ISA的软件生态系统有着非常高价值，但这几乎都是外人构建了所有的软件。 并不只有公司具备设计合格的ISA的能力。虽然设计ISA涉及到大量工作，但是今天有很多机构或公司有能力设计ISA。 最流行的ISA并不见得是完美的ISA。ARM和80x86不被视为完美的ISA。 也不是只有设计ISA的公司才能验证它们。很久以前，开放组织开发了可以确保与诸如浮点单元（IEEE 754），网络芯片和交换机（以太网）和I/O总线（PCIe）的硬件标准兼容的机制。如果没有这样的组织，开放的IT标准也不会那么受欢迎。 最后，专有ISA不能保证永远存活下去。如果一个公司倒闭了，它的ISA也会随之消亡。Digital Equipment公司的消亡导致Alpha和VAX ISA也一起终结了。注意，ISA实际上是一个接口规范，而不是实现。 其实有应该三种类型的ISA实现：(1) 私有的闭源，如AppleiOS(2) 许可的开源，如Wind River VxWorks(3) 免费的开源，用户可以修改、共享，如Linux 拥有专利的ISA实际上允许前两种类型，但是我们还需要一种免费开放的ISA。 我们的结论是，业界将受益于可行的，免费开放的ISA，就像它从免费开放的软件栈中获益。例如，它将实现一个真正的，自由，开放的处理器设计市场，拥有专利的ISA阻止了这样一个市场的诞生。这样的市场会具有： 更强大的创新能力: 通过源自更多设计师的自由市场竞争，包括开放ISA与专有的ISA的竞争。 共享的、开放的核心设计: 这意味着更短的上市时间，更低的成本（由于重复使用），更少的错误（因为有更多人的关注），比如这将使政府机构加入涉密后门更困难。 负担得起的处理器: 更多的设备能够负担得起处理器的费用，这将有助于扩大物联网，其目标成本可能只有1美元。 要想让开源社区拥抱如此的开源ISA，我们认为它需要一个可靠的商业记录。第一个问题是，哪种风格的ISA有成功的历史？ 在30年来没有这样的成功的ISA。除了DSP市场的一部分，VLIW已经失败了：Multiflow也不行，Itanium破产了，尽管惠普和英特尔投资了数十亿美元。没有新的CISC ISA可以成功数十年。幸存的CISC从复杂的ISA转换为更容易执行的ISA，这对于制定有价值的遗留代码基础是非常有意义的。 一套新的ISA不会有任何遗留代码，所以额外的硬件成本和翻译的开销成本很难证明：为什么不是只使用易于执行的ISA在第一位？ RISC风格load-store ISA可以追溯到至少50年到Seymour Cray的CDC 6600.虽然80x86赢得了PC战争，RISC主导后PC时代的平板电脑和智能手机; 在2013年超过100亿基于ARM的SoC出货，相比之下，80x86芯片只有3亿。 鉴于ISA可以存活数十年，我们预测未来的技术景观，看看哪些功能对于基于RISC的免费开放ISA可能是重要的。 三个平台可能占据主导地位：物联网，个人移动设备和仓库规模计算机（WSC）。 这个蓝图式的建议有四个关键要求：(1) 基本、扩展ISA: 为了匹配SoC的需求，同时保持稳定的软件基础，自由的，开放的ISA应该具有： 编译器和操作系统可以依赖的一小组核心指令 标准且可扩展的ISA，可以为应用程序定制SoC 可调用特定应用程序加速器的全新操作码的空间这符合当今SoC经常使用自定义应用程序特定加速器的做法。 (2) 紧凑指令集编码: 考虑到IoT的成本敏感性和对小容量存储器的期望，较小代码是可取的。(3) 四精度（QP）以及单精度和双精度浮点: 在WSC中运行的一些应用程序处理这样的大数据集，这依靠软件库进行QP运算。(4) 128位寻址以及32位和64位: 物联网上的节点的有限内存大小意味着32位寻址在未来几十年将是非常重要的，而64位寻址是更高要求的标准。尽管WSC行业不需要128位的运算，但是在十年内，WSC可能需要超过64位（16艾字节）来寻址所有的固态，非易失性存储器。 这些都是需要很多年才能确认是否正确的细节，所以似乎使用现有的ISA起步是更聪明的做法，而不是成立委员会，从头开始。 RISC ISAs都很相似，所以其中很多都可能是很好的选择。好消息是，已经有三个开源RISC ISA：SPARC，OpenRISC和RISC-V。 只有RISC-V满足上述所有四个要求（见下表）。 RISC-V也是10到20岁的年轻人，所以我们可以从以前的RISC ISA的错误中学习和修复——例如，SPARC和OpenRISC延迟分支——这就是为什么RISC-V是如此简单和干净。 此外，SPARC（V9）的64位地址版本是专有的，而OpenRISC可能失去了动力。 RISC-V有很大的发展势头，到目前为止，它有来自Berkeley的8个芯片实现，以及在印度，英国和美国的外部项目。 由于开源Chisel硬件设计系统，一个64位RISC-V核要比类似过程制造的32位ARM内核快，且功耗和速度均为后者的一半。 虽然很难摒弃我们的偏见，但我们认为RISC-V是自由，开放RISC ISA的最好的、最安全的选择。为了扩大这个免费的，开放的ISA的社区，我们将提供研讨会和创建一个非营利基础，以验证实施和维护和发展RISC-V。 虽然RISC-V的第一个首要目标是物联网，但我们有着更为远大的目标：正如Linux已成为大多数计算设备的标准操作系统一样，我们设想RISC-V成为所有计算设备的标准ISA。 目前已经有大量公司和机构加入并关注着RISC-V的发展。 （完） 参考[1] RISC-V: An Open Standard for SoCs]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chisel高级参数化详解]]></title>
    <url>%2F2016%2F11%2F10%2Fadvanced-chisel%2F</url>
    <content type="text"><![CDATA[介绍本文为Chisel高级参数库手册。关于Chisel更多通用信息请参考Getting Started文档。随着硬件设计的复杂度的不断提高，模块化对于验证和复用都是非常重要的。Chisel的主要应用案例就是描述各种高度可配置的硬件生成器，我们很快意识到传统的参数化方式迫使设计的源代码非常脆弱，并且限制了组件的重用。 高级参数化每个Chisel Module有一个Parameters类的成员参数，其提供在模块之间传递参数的机制。本节描述以下这些特征:(1) Parameters类及其相关的方法/成员；(2) 基本使用模型；(3) 语法糖；(4) 向外部用户/程序暴露参数的模板代码；(5) Views(site, here, up)的高级功能； 类和方法Parameters有以下这些基本方法:12345678class Parameters &#123; // 返回类型T的一个值 def apply[T](key:Any):T // 返回一个新的Parameters类 def alter(mask:(Any,View,View,View)=&gt;Any):Paramters // 返回一个模块的Parameters实例 def params:Parameters&#125; View是一个只包含一个基本方法的类:1234class View &#123; // 返回类型T的一个值 def apply[T](key:Any):T&#125; Parameters有一个工厂对象，其包含一个基本的方法:1234object Parameters &#123; // 返回一个空的Parameters实例 def empty:Parameters&#125; Module工厂对象有一个附加的apply方法:1234object Module &#123; // 返回一个新的类型T的Module，如果_p!=None，则由一个Parameters实例初始化 def apply[T&lt;:Module](C: =&gt; T)(implicit _p: Option[Parameters] = None):T&#125; 基本使用模型这个例子示范了最简单的用法: (1)查询参数; (2) 改变Parameters对象; (3) 传递一个Parameters对象到一个Module。12345678910class Tile extends Module &#123; val width = params[Int]('width')&#125;object Top &#123; val parameters = Parameters.empty val tile_parameters = parameters.alter((key, site, here, up) =&gt; &#123;case 'width' =&gt; 64&#125;) def main(args: Array[String]) = &#123; chiselMain(args,()=&gt;Module(new Tile)(Some(tile_paramters))) &#125;&#125; 在Module Tile中，params成员被查询，通过调用Parameters.apply传递key并返回value类型。在Top中，通过调用Parameters.empty创建了一个空的parameters；然后通过(Any, View, View, View) =&gt; Any函数修改参数值并返回一个新的Parameters实例，并赋值给tile_parameters。将tile_parameters包装在Some:Option[Parameters]之后，当其被传递给chiselMain时，它会被作为第二个参数传递给Module对象。 语法糖: Field[T]一个简单的例子: 要求返回类型Int必须作为参数传给apply方法；否则Scala编译器会抛出错误:123class Tile extends Module &#123; val width = params[Int]('width')&#125; 如上所示的代码示例为一种参数查询的方式，还有一种方式如下所示，可以为每个key创建一个case object，该对象继承自Field[T]，并直接传递给params的apply方法。由于Field包含了返回类型信息，所以类型并不需要被传递:1234case object Width extends Field[Int]class Tile extends Module &#123; val width = params(Width)&#125; 文档的剩下内容，假设每个查询的key都是一个继承自Field[T]的case类。 语法糖: Passing &amp; Altering当具有模块层级结构时，这些Parameters对象会在父模块和子模块之间传递。如果程序员指定，这些对象可以在实例化子对象之前被拷贝，修改。当发生修改时，Chisel会在内部拷贝存在的key/value映射链，并将提供的key/value映射添加到链的底部（译者注: 类似于JS中的原型链）。 当进行一次查询时，会首先查询链的底部key/value映射。如果没有匹配，则会查询链上的下一级key/value映射，以此类推。如果查询达到链的顶部还没有匹配，则Chisel会触发一个ParameterUndefinedExpection。当实例化一个子模块时，父模块可以以两种方式传递它的Parameters对象: 给Module工厂方法传递第二个参数，即包装在Option[Parameters]，显式地传递其Parameters对象至子模块: 12345class Tile extends Module &#123; val width = params(Width) val core = Module(new Core)(Some(params)) // 显示地传递Tile的参数给Core&#125; 隐式地将其Parameters对象传递给子模块: 12345class Tile extends Module &#123; val width = params(Width) val core = Module(new Core) // 隐式地传递Tile的参数给Core&#125; 如果父模块想要拷贝或修改子模块的字典，父模块有两种方法来完成: 向Module工厂方法提供一个偏函数映射作为一个参数。内部地，Chisel会拷贝父模块的Parameters对象并进行修改: 12345class Tile extends Module &#123; val width = params(Width) val core = Module(new Core, &#123;case Width =&gt; 32&#125;) // 向Module工厂方法提供偏函数来改变Core的code&#123;Parameters&#125;对象&#125; 调用Parameters.alter方法，该方法会返回一个新的Parameters对象。这种方法让程序员可以访问新的Parameters对象，还能够使用site，here，up，请看2.6，2.7，2.8: 123456class Tile extends Module &#123; val width = params(Width) val core_params = params.alter((pname, site, here, up) =&gt; pname match &#123;case Width =&gt; 32&#125;) val core = Module(new Core)(Some(core_params)) // 使用Parameters.alter方法来返回一个修改过的Parameters对象。只有当需要site，here或up等机制时才使用。&#125; 下图所示是一个更加复杂的修改链的示例: 12345678910111213141516171819class Tile extends Module &#123; ... val core = Module(new Core, &#123; case FPU =&gt; true; case QDepth =&gt; 20; case Width =&gt; 64 &#125;)&#125;class Core extends Module&#123; val fpu = params(FPU) val width = params(Width) val depth = params(Depth) val quete = Module(new Queue, &#123;case Depth =&gt; depth*2; case Width =&gt; 32&#125;)&#125;class Queue extends Module &#123; val depth = params(Depth) val width = params(Width) val mem = Module(new Memory, &#123;case Size =&gt; depth * width&#125;)&#125;class Memory extends Module &#123; val size = params(Size) val width = params(Width)&#125; ChiseConfig &amp; BoilerplateChisel配置顶层参数的机制是通过一个ChiselConfig对象实现的。ChiselConfig.topDefinitions包含最高层的参数定义，如下所示:1234case object Width extends Field[Int]class DefaultConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123;(pname,site,here) =&gt; pname match &#123;case Width =&gt; 32&#125;&#125;&#125; 通常，设计会调用chiselMain.apply来实例化一个设计。为了使用Chisel的参数化机制并正确地配置ChiselConfig，应该调用chiselMain.run，且设计不能用Module工厂方法包裹起来。这样的原因是为了针对已经存在的设计而保留的向后兼容性，未来我们会修复这个问题的。如下就是一个调用chiselMain.run的例子:12345object Run &#123; def main(args: Array[String]): Unit = &#123; chiselMain.run(args, () =&gt; new Tile()) &#125;&#125; 为了用特定的ChiselConfig来实例化设计，可以简单地在调用Chisel编译器时使用–configInstance project_name.configClass_name参数。 使用site为了帮助设计者表达参数之间传递的关系，我们添加了site机制。为了理解它的功能，从概念上记住，一个被查询的Module的参数成员首先会查看其所在的key/value映射链的最底部的key/value映射。如果不匹配，查询会向上寻找。假设我们有一些如下形式的模块:12345678class Core extends Module &#123; val data_width = params(Width) ...&#125;class Cache extends Module &#123; val line_width = params(Width) ...&#125; 这里有两个相同的查询参数Width，但是对于这个例子，它们有不同的语义。在Core中，Width表示字长，而在Cache中，Width表示cache line的宽度。我们希望能够简单地做一个参数查询响应机制。site机制允许链中间位置的key/value映射可以从链的底部开始进行查询。看下面的例子:1234567891011121314class DefaultConfig extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,size,here) =&gt; pname match &#123; case With =&gt; site(Location) match&#123; case 'core' =&gt; 64 // data width case 'cache' =&gt; 128 // cache line width &#125; &#125; &#125;&#125;class Tile extends Module &#123; val core = Module(new Core, &#123;case Location =&gt; 'core'&#125;) val cache = Module(new Cache, &#123;case Location =&gt; 'cache'&#125;)&#125; 如下图所示，顶层key/value映射使用site为Location查询链的底部。顶层的key/value映射产生不同的值，这依赖于Location返回的值(“core”或”cache”)。 使用here如下图所示，如果参数是同一级key/value映射链中其他参数的函数表达式，该参数并不想复制一个值，因为赋予一个新值需要多处变化。那么，它可以通过使用here机制来查询同一层级的key/value映射: 12345678910class Tile extends Module &#123; val cache_params = param.alter( (pname, site, here, up) =&gt; pname match &#123; case Sets =&gt; 128 case Ways =&gt; 4 case Size =&gt; here(Sets)*here(Ways) &#125; ) val cache = Module(new Cache)(cache_params)&#125; 使用upup机制允许用户查询父级key/value映射。这等同于直接调用Parameters.apply，但可以在Parameters.alter中完成。具体请看3.6节。 示例所有参数化方案都需要遵循以下三个准则:(1) 所有可查找到的参数暴露在顶层；(2) 评估不同节点时源代码绝对不能改变；(3) 添加新的参数时尽量不用改变源代码。本章在介绍完每个例子之后，我们会提出最简单的参数化方案以支持期望的设计空间，且不违反三个准则中的任意一个。随着例子的复杂性提高，最简单的设计方案也会随着改变，直到我们使用这里介绍的高级参数化方案。 简单参数 在这个设计中，我们只改变core和cache的参数。最直接的参数化方案就是通过Tile构造函数参数来传递所有的参数。这些值然后会被传递给Core和Cache，通过它们各自的构造函数完成传递:12345678class Tile(val fpu:Boolean, val ic_set:Int, val ic_way:Int, val dc_sets:Int, val dc_ways:Int) extends Module &#123; val core = Module(new Core(fpu)) val icache = Module(new Cache(ic_sets, ic_ways)) val dcache = Module(new Cache(dc_sets, dc_ways)) ...&#125;class Core (val fpu:Boolean) &#123;...&#125;class Cache(val sets:Int, val ways:Int) extends Module &#123;...&#125; 当探索我们的参数空间时，没有源代码被修改，并且所有的可查找参数暴露在顶层。此外，添加一个新的参数，由于这个例子简单，我们的代码只需要很少的改动。 不相交参数集合 在下一个设计中，我们设计一个芯片，其可以实例化不同的core，每个core有自己的一组参数。如果我们使用简单的解决方案，Tile的构造函数的参数会非常多，因为它必须为所有可能的core包含所有的参数。有一个更好的办法就是把参数集合成一个配置对象。比如，我们可以把所有的BigCore参数集合到一个BigCoreConfig的case class中，把所有的SmallCore的参数集合到一个SmallCoreConfig的case类中，它们都继承自CoreConfig。此外，我们让Cache和Tile在它们的构造函数中分别接受CacheConfig和TileConfig。1234567891011121314abstract class CoreConfig &#123;&#125;case class BigCoreConfig(iq_depth:Int, lsq_depth:Int) extends CoreConfigcase class SmallCoreConfig(fpu:Boolean) extends CoreConfigcase class CacheConfig(sets:Int, ways:Int)case class TileConfig(cc:CoreConfig, icc:CacheConfig, dcc:CacheConfig)class TIle (val tc:TileConfig) extends Module &#123; val core = tc.cc match &#123; case bcc:BigCoreConfig =&gt; Module(new BigCore(tc.bcc)) case scc:SmallCoreConfig =&gt; Module(new SmallCore(tc.scc)) &#125; val icache = Module(new Cache(tc.icc)) val dcache = Module(new Cache(tc.dcc)) ...&#125; 位置无关参数 嵌套配置对象是非常脆弱的，这是因为嵌入配置对象的结构与模块的层次结构强相关。给定一个如上图所示的设计，我们假设其中包含BigCore的IQ和LSQ，以及icache和dcache，实例化一个Memory模块。Memory模块包含一个width参数，为了能让设计符合正确的预期功能，所有的Memory宽度必须设为同样的值。为了确保这个要求，代码可能会这样写:123456789101112131415161718case class MemConfig(size:Int, banks:Int, width:Int)case class CacheConfig(sets:Int, ways:Int, mc:MemConfig)case class QueueConfig(depth:Int, mc:MemConfig)case class BigCoreConfig(iqc:QueeuConfig, lsqc:QueueConfig, mc:MemConfig)case class TileConfig(cc:CoreConfig, icc:CacheConfig, dcc:CacheConfig)class Tile(val tc:TileConfig) extends Module &#123; val core = tc.cc match &#123; case bcc:BigCoreConfig =&gt; Module(new BigCore(tc.bcc)) case scc:SmallCoreConfig =&gt; Module(new SmallCore(tc.scc)) &#125; val icache = Module(new Cache(tc.icc)) val dcache = Module(new Cache(tc.dcc)) require(tc.dcc.mc.width == td.icc.mc.width) require(tc.bcc.iqc.mc.width == tc.bcc.lsqc.mc.width) require(tc.dcc.mc.width == tc.bcc.lsqc.mc.width) ...&#125;... 这一系列的require声明是非常脆弱的，因为我们设计的层次结构发生任何变化都需要大量重写这些声明。忽略这些require声明并不是可行的方法；这些声明对于强制基础设计要求是非常重要的。配置对象的这个缺点引领我们向用户参数化方案靠近，即Parameters类型字典的拷贝/修改。我们使用这种key-value结构来存储模块的参数。为了参数化上图的设计，我们隐式地传递Parameters对象，如果需要修改，则向Module工厂方法提供偏函数。回顾前面的ChiselConfig那一节，MyConfig类(继承自ChiselConfig)必须被传递给Chisel编译器，通过–configInstance选项来配置顶层参数:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname, site, here) =&gt; pname match &#123; case IQ_depth =&gt; 10 case LSQ_depth =&gt; 10 case Ic_sets =&gt; 128 case Ic_ways =&gt; 2 case Dc_sets =&gt; 512 case Dc_ways =&gt; 4 case Width =&gt; 64 // 因为任何模块查询Width都会返回64，所以它的名字不应该对模块是唯一的 &#125; &#125;&#125;class Tile extends Module &#123; val core = Module(new Core)(params) val ic_sets = params(Ic_sets) val ic_ways = params(Ic_ways) val icache = Module(new Cache, &#123;case Sets =&gt; ic_sets; case Ways =&gt; ic_ways&#125;) // we can rename Ic_sets to Sets, effectively isolating Cache’s query keys from any design hierarchy dependence val dc_sets = params(Dc_sets) val dc_ways = params(Dc_ways) val dcache = Module(new Cache, &#123;case Sets =&gt; dc_sets; case Ways =&gt; dc_ways&#125;) // similarly we rename Dc_sets to Sets and Dc_ways to Ways&#125; class Core extends Module &#123; val iqdepth = params(IQ_depth) val iq = Module(new Queue, &#123;case Depth =&gt; iqdepth&#125;) val lsqdepth = params(LSQ_depth) val lsq = Module(new Queue, &#123;case Depth =&gt; lsqdepth&#125;) ... &#125; class Queue extends Module &#123; val depth = params(Depth) val mem = Module(new Memory,&#123;case Size =&gt; depth&#125;) ... &#125; class Cache extends Module &#123; val sets = params(Sets) val ways = params(Ways) val mem = Module(new Memory,&#123;case Size =&gt; sets*ways&#125;) &#125; class Memory extends Module &#123; val size = params(Size) val width = params(Width) &#125;&#125; 尽管这种参数化方法相当冗长，但是它在添加参数时能表现出较好的扩展性，也不需要改变源代码，并允许单个参数，如Width改变所有的叶子模块。 特定位置参数我们在前一节看到拷贝并修改一个Parameters对象会非常冗长。如果我们想要添加一个ECC参数到我们的Memory模块，而这个参数取决于Memory实例化的位置，这时候我们需要修改多个父模块的中的代码来重命名每个参数(如: ECC_icache =&gt; ECC) 如上图所示，我们采用Parameters对象的site功能来获取特定位置信息，从而定制我们想要返回给特定位置值的值。在添加了特定位置信息之后，我们彻底减少了必须要改动的代码的数量:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case Depth =&gt; site(Queue_type) match &#123; case 'iq' =&gt; 20 case 'lsq' =&gt; 10 &#125; case Sets =&gt; site(Cache_type) match &#123; case 'i' =&gt; 128 case 'd' =&gt; 512 &#125; case Ways =&gt; site(Cache_type) match &#123; case 'i' =&gt; 2 case 'd' =&gt; 4 &#125; case Width =&gt; 64 // since any module querying Width should return 64, the name should NOT be unique to modules case ECC =&gt; site(Location) match &#123; 'incore' =&gt; false 'incache' =&gt; true &#125; &#125; &#125;&#125; class Tile (val params:Parameters) extends Module &#123; val core = Module(new Core,&#123;Location =&gt; ’incore’&#125;) // we can give core and its child modules a location identifier val cacheparams = params.alter(&#123;Location =&gt; ’incache’&#125;) // we can give both caches and all their child modules a location identifier val icache = Module(new ICache)(cacheparams) val dcache = Module(new DCache)(cacheparams)&#125;class Core extends Module &#123; val iq = Module(new IQ) val lsq = Module(new LSQ) ... &#125; class IQ extends Module &#123; val depth = params(Depth) val mem = Module(new Memory, &#123;Size = depth&#125;) // in some cases, using copy/alter is preferred instead of \code&#123;site&#125; (see Design Heuristics for more details) ... &#125; class LSQ extends Module &#123; val depth = params(Depth) val mem = Module(new Memory, &#123;Size = depth&#125;) ... &#125; class ICache extends Module &#123; val sets = params(Sets) val ways = params(Ways) val mem = Module(new Memory,&#123;Size =&gt; sets*ways&#125;) &#125; class DCache extends Module &#123; val sets = params(Sets) val ways = params(Ways) val mem = Module(new Memory, &#123;Size =&gt; sets*ways&#125;) &#125; class Memory extends Module &#123; val size = params(Size) val ecc = params(ECC) &#125; 派生参数 如上图所示，我们总是希望我们的ROB可以是物理寄存器数量和体系结构寄存器数量差异的大小的4/3。如果我们在MyConfig.top中写明，可能就是这样的:123456789101112case object NUM_arch_reg extends Field[Int] case object NUM_phy_reg extends Field[Int] case object ROB_size extends Field[Int] class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NUM_arch_reg =&gt; 32 case NUM_phy_reg =&gt; 64 case ROB_size =&gt; 4*(64-32)/3 &#125; &#125;&#125; 然而，如果我们之后增加了物理寄存器的数量，我们需要记得更新在ROB尺寸中的派生值。为了避免这种潜在的出错，可以使用here功能来查询同级的参数:12345678910class DefaultConfig() extends ChiselConfig &#123; val top:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NUM_arch_reg =&gt; 32 case NUM_phy_reg =&gt; 64 case ROB_size =&gt; 4*(here(NUM_phy_reg) here(NUM_arch_reg))/3 &#125; &#125;&#125; 重命名参数 上图所示，两个cache模块查询一个sets参数。然而，Tile有ic_sets和dc_sets参数。为了重命名这些参数，我们可以读取父模块的值并修改子模块中的Parameters对象:1234567class Tile extends Module &#123; val ic_sets = params(Ic_sets) val ic = Module(new Cache,&#123;case Sets =&gt; ic_sets&#125;) val dc_sets = params(Ic_sets) val dc = Module(new Cache,&#123;case Sets =&gt; dc_sets&#125;) ...&#125; 还有一种方法就是，我们可以在Parameters.alter方法中使用up机制来查询父模块的Parameters对象:123456789class Tile extends Module &#123; val ic_params = params.alter( (pname,site,here,up) =&gt; pname match &#123; case Sets =&gt; up(Ic_sets) &#125; ) val ic = Module(new Cache)(ic_params) ... &#125; 通常一般不使用up机制，因为它会变得更加冗余。但是，如果父模块对子模块的Parameters对象做了非常大的改动时，up机制会非常有用，因为所有的改变会包含在Parameters.alter方法中，这个方法可以访问所有三种机制(up, site, here). 外部接口到目前为止，本文只描述了一些在顶层类(ChiselConfig)操作参数的机制。但是，为了能够实际生成多个C++或Verilog设计，我们需要手动改变这些参数。我们还要明确设计的约束(参数范围，依赖，约束)以及把一个特定设计的实际实例从有效设计空间表达中分离出来。带着这些动机，Chisel具一个额外的特征，其基于一个叫做Knobs的概念或者用于探索设计空间的特定参数。这一节将会介绍Knobs以及其使用方法，Dump对象，参数和Knob的约束添加，以及运行Chisel编译器的两种模式: -configCollect和-configInstance. Knobs生成器会有一些参数是固定的，其他的则指示了生成的特定设计节点。这些生成器级的参数，称之为Knobs，其具有一个额外的key-value映射以允许外部程序和用户来轻易地重写它们的值。Knobs只能在ChiselConfig的子类TopDefinitions中被实例化:12345678910111213package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NTiles =&gt; Knob('NTILES') case .... =&gt; .... // other non-generator parameters go here &#125; &#125; override val knobValues:Any=&gt;Any = &#123; case NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; 当查询NTiles在topDefinitions中匹配时，Knob(‘NTLES’)会被返回。内部地，Chisel会在MyConfig.knobValues中查找并返回1。2.5节所示，执行生成器时需要指定特定的config:1sbt run ... --configInstance example.MyConfig 假设我们想要实例化一个新的设计，该设计有两个tile: 可以简单地使用Scala的类继承并重写knobValues的值:1234567package example class MyConfig2 extends MyConfig &#123; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 2 // will generate new design with 2 tiles &#125; &#125; 注意，两个类都可以存在于源代码中，因此两个设计都可以通过命令行被实例化。对于有两个tile的新设计:1sbt run --configInstance exmaple.MyConfig2 Dump顺着Chisel而下，其他的工具可能需要知道特定的参数/Knob赋值。如果需要，只要将Knob/value传给Dump对象，该对象会把name和value写入一个文件，然后返回Knob/value:123456789101112131415package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case Width =&gt; Dump('Width',64) // will return 64. Requires naming the parameter as the 1st argument case NTiles =&gt; Dump(Knob('NTILES')) // will return Knob('NTILES'), no name needed &#125; &#125; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; 每个废弃的参数的name和value会被重写到一个.knb文件，文件在*–targetDir path指定的目录中。 约束现在外部程序/用户可以很容易地重写一个配置的knobValue方法，我们提供了一种机制可以定义合法的Knobs范围。在ChiselConfig中，可以重写另一个称为topConstraint的方法:1234567891011121314package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NTiles =&gt; Knob(’NTILES’) &#125; &#125; override val topConstraints:List[ViewSym=&gt;Ex[Boolean]] = List( &#123; ex =&gt; ex(NTiles) &gt; 0 &#125;, &#123; ex =&gt; ex(NTiles) &lt;= 4 &#125;) override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; 现在，如果有人想要用以下的配置和命令实例化我们的设计，会无法通过:1234567package example class BadConfig extends ChiselConfig &#123; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 5 // would violate our constraint, throws an error &#125; &#125; 12// throws 'Constriant failed' error sbt run ... --configInstance example.BadConfig 约束可以在设计中的任何位置声明，并不只是在顶层，通过调用Parameters的constant方法:123456789101112131415161718192021package example class MyConfig extends ChiselConfig &#123; val topDefinitions:World.TopDefs = &#123; (pname,site,here) =&gt; pname match &#123; case NTiles =&gt; Knob('NTILES') &#125; &#125; override val knobValues:Any=&gt;Any = &#123; case 'NTILES' =&gt; 1 // generator parameter assignment &#125; &#125; class Tile extends Module &#123; params.constrain( ex =&gt; ex(NTiles) &gt; 0 ) params.constrain( ex =&gt; ex(NTiles) &lt;= 4 ) &#125; object Run &#123; def main(args: Array[String]): Unit = &#123; chiselMain.run(args, () =&gt; new Tile()) &#125;&#125; 1sbt runMain example.Run ... --configInstance example.MyConfig 最后，如果设计者想要知道设计约束，他们可以执行Chisel，用–configCollect project_name.config_name选项，这会把一系列约束打印到一个.cst文件中，该文件的位置由*–targetDir path指定: 1sbt runMain example.Run ... --configCollect example.MyConfig --targetDir &lt;path&gt; （完） 参考[1] Bachrach,J.,Vo,H.,Richards,B.,Lee,Y.,Waterman, A., Avižienis, Wawrzynek, J., Asanovic´ Chisel: Constructing Hardware in a Scala Embedded Language in DAC ’12.[2] Odersky, M., Spoon, L., Venners, B. Programming in Scala by Artima.[3] Payne, A., Wampler, D. Programming Scala by O’Reilly books.]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【美食北京】]]></title>
    <url>%2F2016%2F10%2F15%2Ffood-in-beijing%2F</url>
    <content type="text"><![CDATA[博客的目的就是为了记录自己的生活和成长。本篇博文将会持续更新以记录我在北京所探索并尝试的美食，当然曾经也发现过不少美食，虽然饱了口福，却没有充实记忆。 江边城外烤 连锁(五道口店)2016-10-15之前就来过两次，这次来体验一下五道口店。不愧是名声在外，每一次光顾江边城外，门口都是排满了顾客。排号的时候，也可先点菜，毕竟从活鱼到处理完毕再到烹饪完成还是需要比较久的时间的。和妹子两个人，点了份香辣烤鱼(一个香辣盘底和一条2.8斤的清江鱼)，外加几个辅助菜: 乌笋，腐竹。鱼很新鲜，汤汁浓郁鲜美，鱼肉蘸着吃，入口就是一种正宗的重庆味道。评分: 4.5 小吊梨汤 连锁(畅春园店)2016-10-16京城官府菜的代表，每次来都需要排号，受欢迎程度可见一斑。店内装饰别具一格，无论是桌椅还是墙纸灯饰都非常具有古韵，置身店内就有一种神游古都的感觉。深秋，夜幕降至，和女神一起来体验一回京城官府菜。招牌传统小吊梨汤是每次必点饮品，小煎仔鸡、原汤西红柿焖牛腩、椒麻排骨作为热菜，以甜食果粒蜂窝煤为主食，足矣。事实证明，这几个菜对两个人来说稍略显多。小吊梨汤：非常适合寒冷的季节饮用，就像寒冬饮热酒一般。梨汤虽然不是很甜，但是正是这样，喝一壶也不腻。小煎仔鸡：青椒片煎鸡柳，酱汁不错，味道鲜美。 原汤西红柿焖牛腩：土豆和萝卜炖得非常入味，牛肉的味道自然不必多说。 椒麻排骨：排骨中渗透着花椒的味道，感觉还不够入味。 果粒蜂窝煤：甜食，用杂粮做成煤球的形状，内掺火龙果，什锦等果粒。评分: 4.5 金谷园 连锁(北邮南门)2016-10-22周五傍晚永远都是一周中最轻松愉悦、充满期待的一段时光，显然，用美食来消遣这段时光是最佳选择之一。小雨夜，女神带我穿街走巷来到北邮门的一个小胡同。虽说是个连锁店，但却像个小作坊，门面很小。不过里面的空间还是挺大的，特别是屋内的装饰，令人耳目一新，像个咖啡厅，甚至还有长条沙发作座椅。皮蛋瘦肉粥：我人生中喝过的最好的皮蛋瘦肉粥。日式土豆泥沙拉：土豆泥很细，掺和着沙拉，对于深秋季节还是有点凉。葱麻鸡：葱油鸡上浇了层麻酱，鸡肉的味道不够足，总体还是满意的。孜然羊肉饺子：肉馅的分量很足，羊肉磨的很细，饺子皮内还有羊肉汤汁，味道鲜美。鲅鱼饺子：毕竟招牌饺子，饺子皮很劲道，饺子馅鲜美多汁，美味无需多言。评分: 4.5 东来顺 连锁(中关村)2016-11-26在中国的冬季，想必绝大多数人都会把火锅列为好友聚会兄弟小酌的首选之一。而在北方，涮肉的地位等同于南方人心中的火锅。今天就来体验一下，北京大名鼎鼎的东来顺。铜锅的造型就是影视作品里的经典形象，里面有一堆碳木用以保持外面的水沸腾。我们两个人，点了羊肚、蔬菜拼盘、肥牛、肥羊、菌菇拼盘还有两个小烧饼。说实话，实际品尝后心里落差还是蛮大的。关于羊肚，羊肚的劲道和牛肚完全不是一个档次，食材选择的失误直接导致我放弃好评。蔬菜拼盘、菌菇用清水烫，味道中规中矩。肥牛和肥羊只需要稍微涮一下就可出锅，实际上效果和火锅是一样的。唯一值得称赞的也许就是涮肉必备的麻酱了。以前吃过各式各样的麻酱，不过东来顺的麻酱可能是最香的。麻酱浓厚可以掩盖锅底味道的不足。建议吃火锅的时候还是应该选择人多的时候比较合适，能够品尝到各类食材，这样才能达到最高的性价比。评分: 3.8 牛十一海鲜馆 连锁(交大店)2016-11-26“吃”一直都是一个难以抉择的问题。和女神在交大附近游玩，好不容易在大众点评上看到一个距离又近，评分也不错的馆子，随即决定以身试分。辣炒花蛤: 花蛤肉很饱满，味道微辣，属于来店推荐一档。碳烤羊肉串: 属于羊肉串中的上等，价格良心，值得一试。烤大鱿鱼: 切开大鱿鱼绝对是提高用户体验的一道手续。牛十三特色生串: 这个绝对是本店特色，生肉的品相和嚼劲，难以描述的特别味道。克服心理障碍后此处应点赞。烤茄子: 茄子上的微辣细腻的蒜泥绝对能改变有些人对大蒜的偏见。铺在茄子的上层，蒜泥和茄子充分融合，这是爱茄人士的福利。事实上这家店还有一道特色菜——海鲜大拼盘，但由于这次下馆子只有两个人，点海鲜大拼盘绝对是不理智的选择，希望有机会和更多朋友来试试这道菜。评分: 4.3 南京大排档 连锁(中关村)2016-12-4以前在合肥经常吃重庆大排档，来北京两年多了没吃过一次大排档。今天来美嘉看新海诚新作《你的名字》，突然发现这里有家南京大排档，果断来店品尝。店里的装饰和工作人员的服饰都是精心设计的，以营造一种年代感。街坊炒螺蛳: 久违的家乡味道，如何能让一个水乡游子不予以赞许？家乡臭豆腐: 并不是长沙臭豆腐的烹饪方法制作而成，而是用烂咸菜汁做的。小时候家里也做过这种咸菜，那时的我却是非常讨厌吃这种咸菜，而如今却只是慢慢的回忆。江南水乡一同鲜: 里面的食材有大闸蟹，鱼丸子，明虾，花蛤，豆皮。所谓的“鲜”味还有所欠缺。鸭血粉丝砂锅: 切碎的小块鸭血和少许鸭肝、鸭胗，加上香菜和粉丝煲成的砂锅。味道不错，可惜这个砂锅在我心中还是没有超越回味的鸭血粉丝汤。评分: 4.3 重八牛府 连锁(之初入江湖店)2017-1-7女神快要放假回家了，为了庆祝寒假的到来，我们一个星期前就预想着来重八牛府吃一次火锅。周六下午三点开始预约，三点刚过几分钟，已有六桌已预约，火爆程度可见一斑。来到双榆树店，数十米外就能闻到浓郁开胃的火锅飘香。门面是一套木质古风的装饰，迈进门槛，入眼就是十张八仙桌，所幸我们预约得早，很快就排上了座。与我之前吃过的火锅都不一样，这里有专门的服务员为我们配置火锅酱，而且不同的食材会有不同的蘸酱，比如：火锅面就有专门的一碗类似炸酱面的拌酱，对于肥牛肥羊之类的褶皱较多的食材则有对应的酱汁。一个大铜锅盛满清汤锅底，相较于其他火锅也算是独具一格。至于火锅的味道，两点令我印象深刻：酱料、飘香。尽管我没去过火锅之都重庆，但是好歹我也吃过不少火锅：海底捞、澳门豆捞、傣妹…对于重八牛府，我能出给的评价是：这是我迄今为止吃过最好吃的火锅。听朋友说重庆还有更好吃的火锅，因此我们已经盘算着上半年去重庆旅游，毕竟美食对于吃货来说是旅游的最大动力。这次的照片数量有点少，因为这次光顾着吃而没有拍下多少照片，囧…评分: 4.8 （未完待续）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【我的绘画作品】]]></title>
    <url>%2F2016%2F08%2F29%2Fmy-paintings%2F</url>
    <content type="text"><![CDATA[小时候，我的梦想是成为一个画家。在幼儿园之前，曾经有机会接触绘画教育，很遗憾却因为一些小意外而错失了。不过，这并不能阻止我热爱绘画。我的画作其实并不多，现在一年能画一幅已然是奢侈。用一篇持续更新的博文来展示我的画作其实也足够了。 20162月和bluestory风格类似，不过符合我的口味。 20152月非常喜欢DJ Okawarri的flowerdance专辑以及专辑封面。 20142月百无聊赖。 1月想画画，但不知道画什么，突然想到好友喜欢海贼王，那就来个路飞吧。 2013一天时间重新回味了一遍《变形金刚》三部曲，心血来潮的作品。 （未完待续）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>绘画</tag>
        <tag>手绘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码解读——Matrix-Code-Rain]]></title>
    <url>%2F2016%2F08%2F26%2Fmatrix-code-rain%2F</url>
    <content type="text"><![CDATA[最近自己的博客刚刚建起来，想好好经营一下。内容比较少，另外希望能产出一些高质量的文章，所以不想将CSDN博客上的文章迁移过来。那么就得自己发点干货了。废话不多说，转入正题。 数个月前在github上阅读过一个小项目的源码——Matrix-code-rain。其效果是黑客帝国中代码在屏幕上从上至下滑落。DEMO见此链接。如下截图所示即代码雨效果图: 首先观察效果图，大致分为三个部分: 左上角的帧频监测模块、左下角的快照工具栏、代码雨主体。 项目的index.html文件中的body部分包含了两个主要的元素: id=”info”的div元素 id=”canvas”的画布前者提供了快照功能，以旋转方式显示/隐藏的特效（该效果是以CSS3实现的）；后者实现了帧频检测功能以及主效果代码雨。 下面先把JS主干代码贴出，并做简要解读。 主干代码这里仅标出代码主干，具体细节请查看源码。代码的主干很简单，如下所示: 123456789101112131415var stats = new Stats();stats.domElement.style.position = 'absolute';stats.domElement.style.left = '0px';stats.domElement.style.top = '0px';document.body.appendChild( stats.domElement );var M = &#123;...&#125;;function eventListenerz()&#123;...&#125;window.onload = function()&#123; M.init(); eventListenerz();&#125;; 先简单分析一下主干代码，然后再分析具体细节:开头五行代码，引用了一个外部JS文件(stats.min.js)定义的一个构造函数Stats()，然后初始化一个对象，这个对象的功能就是帧频检测，最后把它放到左上角。接着初始化一个对象M，这个对象内部定义了很多属性和方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var M = &#123; // 属性 // 关于每一栏canvas的属性设置 setting: &#123; COL_WIDTH: 15, // 每一栏的宽度 COL_HEIGHT: 25, // 每一栏的高度 VELOCITY_PARAMS: &#123; min: 4, // 代码雨的最小速度 max: 8 // 代码雨的最大速度 &#125;, CODE_LENGTH_PARAMS: &#123; min: 20,// 代码雨的最小长度 max: 40 // 代码雨的最大长度 &#125; &#125;, animation: null, c: null, ctx: null, lineC: null, ctx2: null, video: null, WIDTH: window.innerWidth, HEIGHT: window.innerHeight, COLUMNS: null, // canvas列数 canvii: [], font: '30px matrix-code', letters: ['a', 'b', 'c', ...], codes: [], createCodeLoop: null, codesCounter: 0, // 方法 init(), loop(), draw(), createCode(), createCanvii(), createLines(), assignColumn(), randomFromInterval(), snapshot() &#125;; 然后定义一个添加事件监听的函数eventListenerz。 当页面加载后执行如下代码:1234window.onload = &#123; M.init(); // 初始化M eventListenerz(); //添加事件监听&#125;; M.init()做了以下这些事: 将canvas元素赋值给M.c； 获取画布上的绘图环境，并赋值给M.ctx（后面称之为画布）； 获取页面的高度、宽度并设置画布的高度和宽度，让画布充满整个页面； 设置画布背景色为黑色； 设置画布的字体为30px matrix-code； 创造屏幕质感，画一条条的横线。这里动态创建了一个canvas元素，并设置画布的宽高与页面一致，通过调用M.createLines()方法来绘制满屏的横线，其实为了效果更好每条横线下面紧挨一条颜色更淡的横线，达到色差缓冲的效果； 根据网页的宽度、预设的canvas宽度，计算网页横向能放多少个canvas； 针对每一栏canvas初始化一个codes数组，数组的0索引的值是一个对象: 12345&#123; 'open': true, 'position': &#123;'x', 0, 'y': 0&#125;, 'strength': 0&#125; 调用M.loop()方法，该方法内部调用了requestAnimationFrame，并把其任务ID赋值给M.animation。然后是loop方法的主体，调用M.draw()——想必就是绘制代码雨的效果。此外，同时更新帧频检测器的数据状态，达到循环动画的效果。 调用M.createCode()方法，该方法什么作用？请继续往下阅读。 这时候，代码的大体流程已经知道了，我们只要了解M.draw()是如何绘制代码雨，以及M.createCode()是如何初始化的即可。 代码雨先来看我绘制的一张图，改图简要的介绍了代码雨的组成，在看具体分析之前大家可以先自己想想其实现方式。 要了解代码雨原理，首先了解M.draw()是如何工作的。 M.draw()M.draw()做了以下工作: 清理画布，避免之前绘制的图像遗留在画布上产生重影； 设置如何将新图像绘制到已有图像之上，默认为source-over； 对每一canvas进行处理。 1). 当其codes[0]包含canvas属性时，获取其速度值、canvas的高度，x、y坐标，canvas元素，canvas画布。然后根据其位置将这个canvas添加到主canvas上。 a. 当y坐标小于网页高度时（即canvas的y坐标还在网页范围内），更新y坐标(y减去速度值)； b. 否则，将y坐标设为0，这就达到了同一列不停的循环的效果。 看到第3步，对比代码主干一节中第8步，我们发现：M.draw()阶段时每一栏的canvas的codes数组根本没有canvas属性。这种情况下，第3步中的处理条件根本无法达到。所以肯定缺少初始化的一步，这肯定包含在M.createCode()中，其实看方法名也能看出来。 M.createCode()M.createCode()做了以下工作: 判断M.codesCounter是否大于canvas列数。如果是，清除M.createCodeLoop的定时任务，并返回。否则，继续往下执行。推断一下：毕竟网页横向被分解成了很多个canvas，有多少个canvas，M.createCode()就会被调用多少次吧。 给局部变量randomInterval赋值为M.randomFromInterval(0,100)的执行结果。直接跳到这段代码看看，哦，生成一个0到100之间的随机数。 给局部变量colum赋值为M.assignColumn()的执行结果。直接跳到这段代码看看：随机获取一个canvas的索引，如果该canvas的codes[0]的open属性为true，则置为false，并返回canvas的索引；否则直接返回false。仔细想想，这段代码把open置为false后，并没有还原成true。 根据column索引值，对对应一列的canvas进行处理。 1). 随机获取一个代码雨长度值，并赋值给codeLength； 2). 随机获取一个代码雨速度值，并赋值给codeVelocity； 3). 获取代码雨字符表的长度，并赋值给lettersLength； 4). 设置该canvas的codes[0].position属性，起始的x坐标与列索引有关，y坐标都为0； 5). 设置该canvas的codes[0].velocity属性，为随机获取的速度值； 6). 设置该canvas的codes[0].strength属性，为其速度/速度上限值，这个到底什么作用呢？先放着继续往下看； 7). 根据代码雨长度值，获取相应数量的字符，这是通过在字符表中随机获取的，并将字符依次赋值给该canvas的codes[1], codes[2]… 8). 调用M.createCanvii(column)。这里把canvas的列索引值传递进去了，想必就是进行绘制操作了。 9). M.codesCount++，这一步验证了第1步的猜想。 根据局部变量randomInterval来设置另一列canvas的初始化。 M.createCanvii()上面一节第8步对M.createCanvii(col)的作用进行了猜想，下面我们来看看是不是符合我们的猜想。M.createCanvii(col)做了以下工作: 获取该列canvas要显示的字符数，赋值给codeLen； 获取该列canvas的高度，通过字符数*每个字符的高度即可得到； 获取该列canvas的速度，通过codes[0].velocity即可得到； 获取该列canvas的strength，此时我们还是不知道这是个什么参数； 创建一个canvas元素，并获取其画布环境，并设置其宽度和高度； 根据codeLen，绘制所有字符，这里并不是单纯的绘制。前5个和最后4个不太一样，哪里不一样呢？之前不明白其含义的strength出现了，原来是为了让两端的颜色变淡一些。 绘制完毕后，将该列canvas的codes[0].canvas的值赋为这里绘创建的canvas元素。哦，这时候，M.draw()一节的第3步的条件就成立了，就可以把这个创建的canvas添加到网页的主canvas了。 现在一切就明了了，接下来有兴趣的话可以看看快照工具栏的效果实现。 快照工具栏先来看看CSS3提供的几个动画方法和特性: transform: none | transform-functions123456matrix(): /*定义转换*/ translate(): /*原点坐标偏移*/scale(): /*缩放*/ rotate(): /*沿轴旋转*/ skew(): /*沿轴倾斜*/ perspective(): /*定义透视*/ transition: property duration timing-function delay123transition-property: none|all|property; transition-duration: time(s/ms); transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n) transform属性的是transform-function，上述只列出了6类方法，每一类方法对应还有针对2D, 3D的方法。 很明显，快照工具栏的旋转显示/隐藏方式是以tramsform分别对显示时定义一个状态，隐藏时定义一个状态，然后通过CSS3的transition属性来进行状态切换设置。 果然代码中也是以这种方式实现的:显示状态123transform-origin: bottom center;transform: rotate(0deg);transition: transform 1s ease-in-out; 隐藏状态1transform: rotate(180deg); 状态转移方式1transition: transform 1s ease-in-out; 两个状态、转移方式都定义好了，那么就可以通过事件了切换这两者的状态了。用toggle的方法来添加/删除类来达到状态切换的效果。果然，JS代码中有一个函数eventListenerz()就包含了状态切换的处理。此外，快照工具栏还有一个主要功能: 快照。还是在上面那个函数里面，包含了这两行代码:12var snapshotBtn = document.getElementById('snapshot');snapshotBtn.addEventListener('click', M.snapshot, false); 第一行代码获取了快照按钮的buttn元素；第二行代码则是对该按钮添加了一个click事件监听以及相应的回调函数。M.snapshot是其内部定义的一个方法。其源码如下:1234snapshot: function()&#123; M.createLines(M.ctx); window.open(M.c.toDataURL());&#125; M.c为页面的主canvas，对其调用toDataURL()方法，该方法将canvas进行转化成一个特定格式的图片（默认PNG），并返回一个data URI。最后新开一个窗口显示该图片。 （完）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Matrix-Code-Rain</tag>
        <tag>源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于此博客]]></title>
    <url>%2F2016%2F08%2F14%2Fblog-introduce%2F</url>
    <content type="text"><![CDATA[为何建这个博客互联网在国内兴起的时候我还很小，那时候依稀记得QQ，博客，上网这些字眼儿。等到稍微大一点的时候才知道原来博客其实也是一类网站，那时就希望未来能有一个自己的网站。 如今，作为一个计算机系的学生，身边不乏有很多大神都拥有着自己的网站（博客），分享着自己的生活，技术以及其他各方面的收获。我也希望自己能够向这些大神们迈进，同时也能记录身边的点点滴滴。或许，待到某一天，你回首往事，那一刻的真实感受会从字里行间再次涌现。 之前，看到一篇文章，文章里说：真正优秀的程序员，往往都有着非常好的逻辑思维能力和语言表达能力，而经常撰写对外公开博文会让你不断提炼自己的语言文字，锻炼你的总结能力和表述能力，这显然有利于这些能力的培养。 平常的看书的时候我会记一些笔记，而那些笔记总是那么索然无味，或者缺少自己总结和见解。希望此博客的诞生能够为我的学习提供更大的帮助。 关于博客的域名查询注册域名的时候，很高兴发现我的全名的.com域名（www.baochuquan.com）居然没有被注册。不过，身为一名前端，用户体验之上的理念始终贯穿我心，太长的域名显然不利于用户体验。就这样，亲切易记的chuquan.me成为了我的首选。 （完）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业旅行——厦门]]></title>
    <url>%2F2014%2F05%2F27%2Fxiamen%2F</url>
    <content type="text"><![CDATA[清理照片时，看到了我们毕业旅行去厦门的照片，满满的都是回忆。想着好久都没写过博文了，就写一篇旅游回忆吧~ Day 15月18日启程，普快卧铺。从合肥站上车，目的地是厦门站。妹纸人生第一次坐火车，我却是第一次吃康师傅的新款泡面——爱鲜大餐。 这是我们的床铺~ Day 2在火车进入福建境内后，开始在山区中曲折前行，路边的植物也开始热带化了，滴水观音什么的随处可见。抵达目的地已经是下午5点左右了，我们到来之前的厦门刚刚经历一场阵雨，空气中弥漫着浓厚的湿气。下车后，我们在车站关于坐公交还是打的去旅馆纠结了一会儿，最终还是上了黑的。我们住的第一家旅馆是在曾厝垵，不过当时根本没发现这里居然离芙蓉隧道非常近。品尝了当地的大青芒和路边摊~ Day 3计划去鼓浪屿，清晨的时候下着大雨，我们等到雨停了出发。到达码头后坐船进发鼓浪屿，抵达鼓浪屿的三丘田码头。三丘田码头~ 导游图~鼓浪屿一眼望去都是些西洋楼，完整地保留着大使馆的样式。我们选了一条路线，这条路线的开始便是一道小巷子，有一侧是石墙，墙内红杏出墙，哈哈。转过小巷子便是一片文艺清新的民宅。每家宅子里都装饰的非常漂亮，花草满院。再往深处走便是各种古树与建筑交叠。我们的目的是先把行李放到岛上旅馆————程程家旮旯。旅馆是在岛上，网上评分还挺高的，院子内的装饰布置都是很清新的。行李放下后，可以肆意地潇洒了。尝了尝当地的果子，好像叫奇异果，忘记叫什么名字了，有点酸~随后我们到了鼓浪屿著名的商业区，各种文艺小店铺依次呈现。闽台地区的肠粉~豆来豆去的土豆卷儿然后就是各种奇葩小店铺。、我们在来玩之前看了不少攻略推荐，美式什么的啥都少不了，挨个儿品尝。林氏鱼丸马拉桑——有些桑果的味道沙茶面海蛎煎后来到了一个环形的建筑内，顶部是敞空的，还有人在拍婚纱。接着就转悠到了海边。虾扯蛋——有点像章鱼小丸子旅游怎么能没有自拍呢麻糍——感觉像是糯米团子一逛就是一下午，来海边看一下日落。我也来个自拍吧天很快进入夜色，我们海边找了家馆子，吃了些海瓜子什么的。打开QQ，封面是520，因为这天正好是520，我们算好这天登陆鼓浪屿。 Day 4今天要离岛，我们出门便退了房，背上了行李，告别前，妹纸在墙上贴了留言。 我们继续游览鼓浪屿，首先就是路经安献堂。安献堂门口是一条通幽曲径。然后，我们径直向日光岩出发，日光岩是鼓浪屿的制高点，在顶峰可以一览鼓浪屿全貌。下一个目的地是郑成功纪念馆。我把你拍的那么美，你把我拍成一团黑~然后就是漫无目的的逛岛。大约中午，我们乘船离开了鼓浪屿。回到第一天住的地方后，我们就去曾厝垵找传说中的亚尖大排档，不过并没有传说中那么好吃。饭后，曾厝垵必须逛一逛。 Day 5清晨，下着小雨，我们启程去南普陀和厦大。 南普陀的旁边就是厦大，和清北很像，厦大也是有很多人排队参观。芙蓉湖里好多鲶鱼前方便是芙蓉隧道，隧道有一公里长，在里面时间太久会有缺氧感，我们没有久留。 Day 6这天，天有小雨，我们逛了中山街，类似于各个城市的步行街，然后晚上去了湖里区，因为那里离机场比较近。 Day 7在烟雨蒙蒙的清晨告别厦门。果然计划赶不上变化，我们有好多地方没有去玩，当然天气也是有原因的。如果是晴天，便可以允许骑行环岛路，游白城沙滩。童话村也没来得及去等等。以后有机会，我们还会再来的。 （完）]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>厦门</tag>
        <tag>鼓浪屿</tag>
        <tag>曾厝垵</tag>
      </tags>
  </entry>
</search>
