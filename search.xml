<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2017 年度总结</title>
    <url>/2018/01/02/2017-summary/</url>
    <content><![CDATA[<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/maimai-2017-summary.png?x-oss-process=image/resize,w_400" /></p>
<span id="more"></span>
<p>这几天，脉脉上有一个年度总结的活动。2017年，我对自己的总结便是一个字——<strong>变</strong>。</p>
<h3 id="关于论文毕设">关于论文毕设</h3>
<p>2017的上半年是我硕士生涯，也是我学生生涯的最后一个学期。这半年真的是一直处于焦虑中，毕业总是令人如鲠在喉。有人可能会问硕士毕业有这么难吗？如果我说我们是在毕业答辩前两个月才开的题你信吗？</p>
<p>关于毕业论文，我是经历过换题的。研二期间，一直在做碳纳米管计算机项目。然而，到了毕业选题的时候，才发现这个项目根本没有可深入研究的、与计算机体系结构相关的东西。不得已，只能换题。此时，恰逢2016年的10月，校招还在如火如荼地进行。而我已经没有心情继续找工作了。</p>
<p>2017年年初，<span class="citation"
data-cites="易老师给了我一个毕业选题的大方向">@易老师给了我一个毕业选题的大方向</span>——RISC-V
&amp; TLB &amp; 安全。参考往年类似的毕业选题（如：<span class="citation"
data-cites="天一师兄">@天一师兄</span>、<span class="citation"
data-cites="翁东旭师兄的毕业论文">@翁东旭师兄的毕业论文</span>），我大致规划出了毕业论文的框架。然而，往年论文的相关实验都是基于完整的项目平台，研究及评测环境相对来说都是比较完备的。我的毕业选题采用的实验平台则是基于RISC-V的开源处理器生成器——Rocket
Chip
Generator，该平台是2014年由UCB推出的，其研究及评测环境都还不完善，不足以提供标准且完整的论述、验证、评估的能力。</p>
<p>为了让论文能有更多的干货，我还去探索了TLB/MMU在安全方面研究的可能性。不过，这个想法在后来的预开题中被否决了。好在，预开题时，<span
class="citation"
data-cites="佟老师给了我很多的建设性的意见">@佟老师给了我很多的建设性的意见</span>，比如：研究Generator自动化生成硬件的原理、Chisel原理等。我能够在6月份顺利毕业，真的要感谢我的导师@佟老师、<span
class="citation"
data-cites="易老师">@易老师</span>，在毕设期间予以我的帮助和建议。</p>
<h3 id="关于科研项目">关于科研项目</h3>
<p>2月底春季的开学阶段，我提前了一周回了学校。因为，在做毕业的同时，我还要和物理电子所的同学对接碳纳米管项目。为了能让项目顺利结题，春节前后和@海涛师兄、<span
class="citation" data-cites="司佳师姐">@司佳师姐</span>、<span
class="citation"
data-cites="东维师弟一起忙活了一段时间">@东维师弟一起忙活了一段时间</span>。项目最后顺利结题，也算是了却了一桩心事。在4月份左右，<span
class="citation" data-cites="彭老师">@彭老师</span>、<span
class="citation"
data-cites="程老大又来了一次巨头会议">@程老大又来了一次巨头会议</span>，要在北大120周年献礼。也就是说，碳纳米管项目继续进行。当然，我知道自己不能继续跟进，便把工作交接了@李宁师妹和<span
class="citation"
data-cites="东维师弟了">@东维师弟了</span>。希望明年的五四，能给大家带来一个惊喜。</p>
<h3 id="关于毕业答辩">关于毕业答辩</h3>
<p>3月底，实验室进行了开题答辩会。这个开题时间放眼整个北大，也算是晚的了。不知道@老大作何感想，可能真的是日理万机吧。不过，从开题答辩会上老大的表述，能看出@老大对于我们这一届还是抱有歉意，希望我们都能顺利毕业。</p>
<p>6月2日，毕业答辩会如期进行。答辩会上有校外专家，当我们有遇到答不上的问题或被专家刁难的时候，<span
class="citation"
data-cites="老大能够及时救场">@老大能够及时救场</span>，果然护犊子！手动点赞！结果是显而易见的，所有人都顺利毕业。</p>
<p>答辩过后，和@小威威、<span class="citation"
data-cites="大帅">@大帅</span>、<span class="citation"
data-cites="赵璐">@赵璐</span>、<span class="citation"
data-cites="昊泽去了南门翅客吃了烧烤">@昊泽去了南门翅客吃了烧烤</span>，果然是前所未有的轻松。</p>
<h3 id="关于毕业旅行">关于毕业旅行</h3>
<p>6月3日是我们的发出时间，一个月前订机票时也是非常忐忑，毕竟答辩时间是6月2日，就怕答辩时间更改。关于毕业旅行的详细内容，可以看这里。</p>
<h3 id="关于毕业典礼">关于毕业典礼</h3>
<p>毕业旅行回来，能感受到浓厚的离别气息。拍毕业照、毕业典礼、谢师宴...从今往后，同窗同门都要各奔东西。</p>
<h3 id="关于工作">关于工作</h3>
<p>校招时，我投递的岗位是前端开发工程师，后来HR跟我沟通有没有转岗iOS开发工程师的意愿。在考虑了几天后，我选择了转岗。我当时的想法是这样的：</p>
<ul>
<li>前端的门槛比较低，从业人员比较很多，想真正脱颖而出还是比较困难的，感觉硕士毕业从事前端的优势并不大。</li>
<li>前端的技术更新迭代速度太快，没有一个统一的行业标准，不同的公司可能采用完全不同的技术栈。所以，前端岗需要不断地学习，一旦松懈，可能就会被淘汰，压力比较大。</li>
<li>程序员都知道所谓的“程序员鄙视链”，前端是处于“鄙视链”的下游的。虽然前端已经今非昔比了，但是总的来说，职业天花板比较低。</li>
</ul>
<p>出于这些考虑，我选择了转岗。</p>
<p>7月初，办完了毕业手续，我和@撸神便搬家到了我们的整租房。在学校呆了20年，离开时真的很不习惯。</p>
<p>7月10日，在紧张和期待中办理了入职手续。期间，遇到了校友@家骏、<span
class="citation"
data-cites="仲雪">@仲雪</span>。中午，我的mentor@展哥接待了我，然后便组织大家在云海肴来了一波TB。</p>
<p><span class="citation"
data-cites="展哥已经有7年的工作经验了">@展哥已经有7年的工作经验了</span>，作为小猿搜题iOS端负责人，他的技术能力的确是很强的。作为mentor，他也是尽心尽力，真的非常nice。相比于我在某度的mentor，真是不知道高到哪里去了，无论是技术能力，还是个人修养。然而，没想到@展哥年后要离职，真的有点不舍啊。</p>
<p>我工位的右边是@展哥，左边是@琳洁——一位iOS程序媛。她虽然话不多，但是只要有问题，她都能悉心指导我。而且做事特别细致，从code
review就能看出来。</p>
<p>我的leader@邱瑞，也是我的校友师兄。为人非常nice，说话语气很平和，平时分配任务、交谈时完全没有一种上下级的感觉。对于产品需求的评估、事务的处理都是非常到位。</p>
<p>有人说：想要在职场上快速成长，可以尝试学习你领导的做事方式。我个人非常赞同这种观点，希望新的一年，我能够像@展哥、<span
class="citation" data-cites="邱瑞">@邱瑞</span>、<span class="citation"
data-cites="琳洁他们一样做人做事">@琳洁他们一样做人做事</span>。</p>
<h3 id="关于技术">关于技术</h3>
<p>上半年写的代码基本都是服务于毕业设计，都是与硬件相关。下半年学的都是工程相关：</p>
<ul>
<li>在编程语言方面，学习了两门新的语言：Objective-C、Swift。</li>
<li>在版本管理方面，能够熟练使用git的各种常用命令。</li>
<li>在项目管理方面，了解了公司的项目管理流程以及敏捷开发模式，自己还搭建了Gerrit代码审核服务器。</li>
</ul>
<h3 id="关于阅读">关于阅读</h3>
<p>2017年1月1日，我计划开始记录自己的阅读轨迹，其实主要原因是希望能够督促自己保持阅读（阅读轨迹<a
href="http://chuquan.me/2017/01/05/read-books/">在这里</a>）。2017年总共阅读了不到12本书。希望新的一年，在阅读时能够有更多的自我思考，尽可能产出一些读书笔记。虽然，我读书的时候喜欢使用有道云来做笔记，但是缺少整理、总结和发布。</p>
<h3 id="展望">展望</h3>
<p>对于公司来说，都会有年度目标，这样公司才能够健康成长。对于个人也是一样，给自己定一个目标，希望能够激励自己成长。2018年伊始，我也想给自己定一些小目标。</p>
<ul>
<li>至少看完两个iOS开源框架源代码（向大神靠拢）</li>
<li>至少看12本书，非工具类的书，需要有读书笔记（向@巧叔学习）</li>
<li>在技术方面，能够hold住产品经理提出来的所有需求（向@琳洁<span
class="citation" data-cites="展哥学习">@展哥学习</span></li>
<li>在业务方面，了解小猿搜题的所有业务代码（向@邱瑞<span
class="citation" data-cites="琳洁">@琳洁</span><span class="citation"
data-cites="展哥学习">@展哥学习</span>）</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 年度总结</title>
    <url>/2018/12/31/2018-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>又到了年末总结的时候了...回望年初立下的
Flag，不知道倒下了多少，扶都扶不起来。</p>
<p>简单总结一下这一年吧..</p>
<h2 id="关于运动">关于运动</h2>
<p>从 7 月份至 10 月份，在这 4
个月期间，每周末去自学游泳。从旱鸭子状态开始，依次掌握了蛙泳，狗刨，自由泳，仰泳，蝶泳。目前，蝶泳还不是非常协调，有待进一步强化练习。毕竟，蝶泳是所用泳姿中门槛最高的一种，无论是在力量方面还是协调性方面。</p>
<p>当然，完全靠自己摸索来学习游泳是一个很漫长的过程。为了加快我的学习进入，在学游泳期间，我坚持观看
YouTube 上易梦觉教练的一些游泳教学视频，学习一些游泳的技巧。</p>
<p>年底的时候，开始教妹子学游泳，目前蛙泳差不多已经会了。</p>
<p>除了游泳，今年在周末的时间还有一部分给了篮球。自从 3
月份那会儿在高家园附近的社科院里发现了一个室外篮球场后，在 7
月份之前几乎每周末都会去打一次球。</p>
<p>总体来说，今年的运动量增加了不少，同时掌握了游泳这个新技能。</p>
<h2 id="关于旅行">关于旅行</h2>
<p>今年 10 月底，随公司一起去俄罗斯玩了一周。<a
href="http://chuquan.me/2018/11/03/st-petersburg/">游记传送门</a></p>
<h2 id="关于工作">关于工作</h2>
<p>年初的时候，刚刚开始接手模块级的 iOS
开发任务，那时候还不是非常娴熟。经过这一年的锻炼，已经能够 carry
任何需求了。</p>
<p>这一年里，公司的工作节奏依然比较快的，毕竟走的是 Scrum
的项目管理模式，需求迭代很快，并且研发人员相对产品经理较少。为了解决研发人员不足的问题，从年初就开始不停地招人。到年底，我们整个研发组从原来的
15 人左右增至 30 多人。公司整体的人员也增涨了不少，去年入职时只有 500
人左右，此刻已经有了 2800
多人了。在全球经济如此不景气，各个公司都不断裁员的背景下，我司还在不断地扩招，不禁感慨教育行业的优越性[手动捂脸]。</p>
<p>6
月份，公司给我们调了一次薪水，发了期权，虽然不是很多，但符合预期。</p>
<h2 id="关于技术">关于技术</h2>
<p>今年来了几位有着丰富工作经验的同事，在他们的积极推动下，我们的搜题和口算的项目也开始引入了一些新的技术框架。口算目前基本已经在使用
Swift 进行开发了，并已经在使用函数响应式编程框架
RxSwift。搜题方面由于历史原因，虽然引入了
RxSwift，但还没有开始全面使用。</p>
<p>去年立下的关于阅读开源框架的
Flag，今年只是阅读了一些公司内部的框架，如：YTKFrog、YTKRouterManager、YTKResourceSync
等，关于阅读开源框架这个 Flag，希望明年能够重视。</p>
<h2 id="关于阅读">关于阅读</h2>
<p>今年上半年，我又重新看了一遍《程序员的自我修养——装载、链接与库》，然后写了几篇博客。从中我发现了一种相比以前更加高效的吸收知识、提高阅读效率的方法——写博客。为什么呢？因为我们看完一本书时，其实有效的知识吸收程度并不高，写博客能够让我们加强对关心的主题的理解。写博客的过程中，需要我们不断地重新翻看书中的一些要点，甚至查阅其他书籍、博客，从而加强我们对它的理解。后来我写的几篇博客：<a
href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">《计算机那些事(7)——图形图像渲染原理》</a>、<a
href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/">iOS
图像渲染原理</a> 都是按照同样的方式做的，受益匪浅。后一篇文章甚至被
CocoaChina 社区转载了，虽然没有稿费，但还是非常开心。</p>
<p>年末的时候，我开始对编程语言、编程范式起了兴趣。依次看了几本书：《七周七语言》、《函数式编程思维》、《函数式
Swift》。希望新的一年能够继续深入研究编程语言，能够产出几篇博文。</p>
<h2 id="flag">Flag</h2>
<p>Flag
还是要立起来的，毕竟明年年底要是要给自己打打脸，清醒地认清自我。</p>
<ol type="1">
<li>深入研究编程语言，包括编程范式、实现模式、DSL 等。先列一些书单：
<ul>
<li>《类型和程序设计语言》</li>
<li>《自制编程语言》</li>
<li>《领域特定语言》</li>
<li>《编程语言实现模式》</li>
<li>...</li>
</ul></li>
<li>掌握一些其他的编程语言。</li>
<li>副业搞起来，通过专利代理人资格考试</li>
<li>横向发展，学习 Android 开发。</li>
<li>提升 Linux 基本技能</li>
<li>做一个全栈项目</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2019！佳油鸭!</title>
    <url>/2020/01/19/2019-summary-of-panhaiyan/</url>
    <content><![CDATA[<p>2019年对我来说注定是人生中最重要的一年之一，这不仅是人生阶段的迈进，更是灵魂的升华的重要节点。站在2020年年初，回首2019年，这一年对我个人而言是要铭记的、感慨的和回味的。</p>
<span id="more"></span>
<h1 id="关于学业">关于学业</h1>
<p>我法学硕士毕业了！首先最得感谢的就是我自己了，论文从选题到构思再到修改，真是煞费苦心。熬夜赶进度，最后成稿时赫然发现自己和国宝成了姐妹，毕竟这祖传的黑眼圈容不得质疑。其次，我要感谢男朋友，写论文期间各种阴晴不定，总是找他哼哼，或者焦虑、哭泣，他没有任何不耐烦，将他毕业时写论文的心得向我娓娓道来，让我别着急，慢慢来。不得不说，他的表现让我非常满意（不过有时候脸上表情有点严肃）。最后，感谢程玉师兄，帮我彻头彻尾改了一遍，从框架到文中的参考资料都细心备注与修改，这里也要小小声说下感谢我导师曹明德老师，毕竟我改了一遍后给他老人家看，他觉得我写的很好，可以定稿了（此处应该有个哭笑不得的表情）。嗯！这让我有很大的信心去答辩，毫不畏惧2019年国家（参考翟天临的知网事件）对硕士和博士论文把控的难度，我校的查重率是百分之零点五。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2019-summary-of-yanzi01.jpeg?x-oss-process=image/resize,w_800" /></p>
<p>不管怎么说，最后有惊无险的毕业了！毕业论文答辩虽然没获得优秀，但是顺利毕业就很开心啦！当然，在硕士研究生毕业之际我获得了2019年中国政法大学优秀毕业生和2019年北京市优秀毕业生的荣誉，算是个小惊喜，爸妈非常开心！</p>
<h1 id="关于工作">关于工作</h1>
<p>这是人生中的第一份工作，高校的法律管理岗，这份工作对我来说，谈不上喜欢也谈不上讨厌，大概就是时间点到了正好有这样一个机会就抓住了。为什么没找一份自己喜欢的工作？我仔细回想了下当时的心路历程，大概有以下几个原因吧：第一，研究生二年级在投行实习时被加班支配的恐惧，工作内容总是在晚上压过来，导致那段时间睡眠都不太好；第二，总归是不喜欢北京这座城市，想回家乡，虽然家乡没有首都发达，但是那是我长大的地方，那里有我的家人，我的朋友以及我的家乡味，虽然它只是个中部省会城市，但是我爱它，我想回去，和男朋友一起回去，这样他的压力不会特别大，毕竟人生短暂，和他一起回家乡风花雪月就是我想要的生活；第三，当时选择这份工作是藏有私心的，因为寒暑假可以让我有更长时间准备我回家乡的考试。</p>
<p>从事这份工作已经工作有半年了，总体来说工作内容不复杂，涉及专业方面的工作就是起草文件、合同以及修改；经过半年的锻炼，对我来说文件和合同这块目前没有什么挑战，在以后的工作中，我和我们主任提出希望多多参与诉讼案件以及庭审的锻炼，希望在接下来的工作中得到快速成长！自己也准备在掌握好本领后去互联网公司闯一闯或者去当个律师？虽然没想好，但是多试试的想法一刻都没有停歇呢，毕竟人的一生如果一直做一份工作该有多无趣啊！</p>
<p>我相信只要我好好规划，在顺利考取家乡功名前的这段时间，我会在首都这篇土地上好好工作，努力提升自身能力，享受工作带来的成就感！</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2019-summary-of-yanzi02.jpeg?x-oss-process=image/resize,w_800" /></p>
<h1 id="关于生活">关于生活</h1>
<p>我现在真正体会到和优秀的人在一起是多么重要，因为优秀的人就像太阳，我们会向向日葵一样朝着太阳的方向努力生长。很庆幸我没有太迟认识到这点，在接下来的人生当中我会越来越努力，和优秀的男朋友一起创造美好未来。</p>
<p>这一年心路历程也发生了很大的变化，总体而言就是变得更成熟了，从学生转变成上班族，从穿衣打扮到为人处世都在一点一滴的发生着变化，我期待着这些变化，拥抱这些变化。</p>
<p>2019年立的flag一个一个都倒下了！比如减肥······败的一塌糊涂，连年终奖都输给了男朋友，但是，2019年还是学会了游泳的！这其中功劳最大的就属拿走我年终奖的那个人了，哎，就当交学费了！</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2019-summary-of-yanzi03.jpeg?x-oss-process=image/resize,w_300" /></p>
<p>2020，欢迎你的到来，新的一年让我们更好的相处，这一年我即将迎来人生中的好几个第一次，好期待啊！当然，2020年2月15日到2020年4月28日，我要瘦20斤！！（不立flag不像我的风格，这次这面旗一定不会倒，毕竟关系到婚纱照）</p>
]]></content>
      <categories>
        <category>佳油鸭</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年度总结</title>
    <url>/2020/01/04/2019-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight230.jpg?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>到了这个时间节点，又该回顾年初立下的
Flag。比对一下这一整年做过的事情，基本上是完全不同。年初给自己定下的目标是希望自己能够深挖编程语言的知识。然而事实上，自己并没有真正去努力学习这方面的知识，倒是最后一个季度，却静下心来学习了比特币及区块链的相关知识。</p>
<p>2019
年一整年都比较平淡，没有什么大事件发生。但是，既然是年度总结嘛，还是要例行简单总结一下这一年。</p>
<h1 id="关于运动">关于运动</h1>
<p>在运动方面，今年总体来说还是比较规律的。基本上一周两次游泳，一次篮球。</p>
<p>游泳技术有了新的提升，蝶泳基本上已经完全解锁了，剩下的就是体能的训练了。自由泳能够不停地泳，前段时间试过
40 分钟泳 2
千米，没什么困难，剩下的就是再雕琢自己的技术细节，让自己游得更快。</p>
<p>篮球方面，有得有失。现在带球，突破越来越少，投篮倒是越来越准。尤其是下半年，在看了一个库里投篮教学视频后，重新改变自己的投篮姿势。自此之后，投篮愈发稳定，动作愈发协调。</p>
<h1 id="关于旅行">关于旅行</h1>
<p>今年 6 月底，部门组织年度旅游，我们研发内部分成了 3
个团：日本团、台湾团、澳洲团。我们澳洲团 8 人，开启了一次为期 10
天的澳洲自驾游。<a
href="http://chuquan.me/2019/07/11/australia-from-sydeny-to-brisbane/">游记传送门</a></p>
<p>总体而言，这次自驾游没有达到预期的效果，白天时间基本都是在酒店和车上度过，没有太多时间体验异国风情，而且长时间的自驾，也是比较累的。</p>
<h1 id="关于工作">关于工作</h1>
<p>今年的工作相比去年更有挑战性，对自己的成长也更大。</p>
<p>年初做了一个性能监视器，在调研的过程中，学习了性能检测的一些原理和知识，顺便产出了两篇文章：<a
href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">《iOS
性能监控(1)——CPU、Memory、FPS》</a>、<a
href="http://chuquan.me/2019/06/17/ios-performance-monitor-caton/">《iOS
性能监控(2)——卡顿》</a>。</p>
<p>4
月份的时候对相机进行了重构，这是我第一次对主流程中的代码进行重构，也是第一次进行大型功能的重构。可惜的是，最后重构上线后在相册相关的逻辑中出现了一个
bug。这个 bug
是用户反馈后，经过主管反馈到我这里的，虽然影响人数只有几千人，但是是主管给报的故障，影响还是挺不好的，当季的绩效也受到了影响。</p>
<p>5、6
月份做了大的需求——整页拍，期间琳洁、周剑都或多或少请了些假，我主要负责这个项目的开发，这个过程也有比较好的锻炼。</p>
<p>7月份的时候，公司入职了一批应届生，我作为 iOS
开发的一名讲师，给他们分享了
网络和多线程相关的内容。在准备过程中，我也学习了
NSURLSession、AFNetworking、YTKNetwork
这些框架。为此，也产出了几篇文章：<a
href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/">《iOS网络(1)——NSURLSession》</a>、<a
href="http://chuquan.me/2019/08/06/ios-network-afnetworking/">《iOS网络(2)——AFNetworking》</a>、<a
href="http://chuquan.me/2019/08/20/ios-network-ytknetwork/">iOS网络(3)——YTKNetwork</a>。</p>
<p>9
月份又做了一个大需求，接入打印机功能。期间也对部分祖传代码进行了梳理和重构。</p>
<p>10
月份开始，对项目中最复杂的视频播放相关的代码进行重构。前期，周剑已经做了一版重构，将一个四层继承结构打平为一个两层的继承结构。这是第二版重构，前期我和周剑一起做了一些工作，后期由我来主导整个重构工作，并加入了对
MP4
播发器的支持（此前的播放器是我们内部定制的一个特殊的播放器）。重构完成后，产出了一篇内部的
wiki，并和组内 iOS 成员进行 code &amp; design
review。美中不足的是，项目上线后出现了一个小的
bug，紧急修复后立刻发版，影响用户大约几百人。</p>
<p>11
月份，开始做播放缓存及预加载功能。前期梳理了已有的小视频播放器逻辑，并调研了两款开源的播放缓存方案，阅读源码并绘制其设计框架。从第三方库的设计中汲取优秀的设计，并设计了我们自己的视频缓存方案。在项目实现阶段，对工作进行分工，和仪伦一起完成了整个设计方案。虽然让一个完全不了解项目的同学一起开发，沟通成本和时间成本要比我一个人开发更多，但是从中学习了如何对项目进行评估、分工等技能。</p>
<p>12
月份，处理了我们的打包机存在的一些问题，从中也学到了不少东西。包括以前一直理不清的开发证书相关的内容，打包脚本等。</p>
<h1 id="关于阅读">关于阅读</h1>
<p>今年空余时间也完整地读了一些书：</p>
<ul>
<li>《三国演义》</li>
<li>《中国共产党简明历史》</li>
<li>《富爸爸穷爸爸》</li>
<li>《一本书读懂财报》</li>
<li>《小狗钱钱》</li>
<li>《精通比特币》</li>
<li>《以太坊技术详解与实战》</li>
<li>《函数式编程思维》</li>
</ul>
<p>技术书读的不够多，尤其是职业相关的书籍，希望 2020
年能够有所改善。</p>
<h1 id="新年愿景">新年愿景</h1>
<p>2020
年希望自己能够有更大的提升，多读一些技术方面的书籍，人文、经济方面的书也是需要读的。职业相关的技能要加强提升，多读读源码，多看看书籍。在工作方面，希望能够在业务和技术方面投入更多的思考，以一个技术管理者的角色去工作。</p>
<p>Flag 今年就不立了，希望能够诸事顺遂！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年度总结</title>
    <url>/2021/01/02/2020-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/friends-from-young.jpg?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>2020
年注定是写入史册的一年，这一年发生了太多事情，于人类，于国家，于个人都是令人难以忘怀的一年。</p>
<p>对于我而言，这一年成长飞速，收获颇多。下面来对这一年做一个简单的总结。</p>
<h1 id="关于工作">关于工作</h1>
<p>今年的工作内容主要包括几个方面：横竖屏适配、Flutter
落地、辅导导流需求、Swift
迁移、业务迭代。随着业务的迭代，项目的复杂度也在增加，导致实现需求的难度也在增加。在做业务需求的过程中，没有太多成就感，遇到的琐碎的问题比较多，有时间好好思考一下这些问题的来源和解决方式。</p>
<h1 id="关于技术">关于技术</h1>
<p>关于技术，可以算得上是工作 3
年以来收获最多的一年。上半年，我们开始探索跨平台技术，学习
Flutter。Android 和 iOS 两端各自投入了 3 个人（到后期两端各 1
个人），花了差不多三个月的时间，从零开始学习 Dart 编程语言，Flutter
开发框架，搭建混编环境，解决工程问题、编译问题，建设基础库、插件，实现业务模块，到最终落地发版。期间还做了一次主题为《Flutter
状态管理实践》实践的分享。这样一次快速学习新技术并将其应用实践的经历，对于个人的提升是非常显著的。更重要的是，通过这次
flutter 经历，极大地提升了解决问题的能力。在 flutter
开发中遇到一些网上也没有人遇到过的问题，如：编译问题、环境问题等，面对这些未知问题时，调整心态，从容面对，从本质去挖掘、梳理，总是能解决的。</p>
<p>另外，今年自己的 shell
脚本编写能力也得到了极大的提升，也算是完成了自己多年的夙愿。在做 flutter
项目期间，阅读了很多 flutter 自带的一些脚本，让自己对 shell
脚本不再那么生疏了。下半年，自己业余时间写了一个 shell 工具——NOX。NOX
是一个基于 zsh 的脚本管理工具，以 nox
为主命令，将脚本名称、脚本存储路径转换为子命令，并支持 tab
自动补全子命令、脚本选项。项目的命名、功能的构想、结构的设计、代码的实现、Logo
的设计、wiki
的构建，让我综合能力得到了很大的提升。当然，自信心的提升也是非常显著的，一举抹除了读研时被大神们碾压的后遗症。</p>
<p>今年，系统地阅读了两个开源项目的源码，RxSwift 和 oh-my-zsh。RxSwift
源码多而复杂，上半年阅读它花了我不少时间，不过结果是令人满意的，我基本搞清楚了
RxSwift 的设计，及其背后的思想，并且还产出了一篇文章——《RxSwift
核心实现原理》。在阅读了 RxSwift
源码之后，面对复杂的开源项目源代码时，也从容了许多，oh-my-zsh
就是一个佐证。在做 NOX 项目时，为了找寻一些设计灵感而去阅读了 oh-my-zsh
的源代码，代码阅读非常顺利，也产出了一篇文章——《源码解读——ohmyzsh》。总体而言，阅读开源代码的收获还是挺多的，关于如何阅读开源代码，自己也积累了一些经验，能够为后续进一步学习提供帮助。</p>
<h1 id="关于学习">关于学习</h1>
<p>学习方面，看了些博客和文章，有些是源于工作，为了解决当时的一些疑惑，有些是源于眼缘，类似于公众号文章，社区文章，满足了一时的求知欲，还有些是源于乐趣，比如xxx科技周刊、xxx读书笔记。这些大多数文章和博客大多数没有进行深度学习。</p>
<p>今年业余时间研究了一些主题，如：iOS 证书幕后原理、Swift
性能优化、Swift 泛型与协议底层实现、RxSwift 核心实现原理、Flutter
状态管理、zsh
自动补全、函数式编程、Mach-O，同时顺带也产出了一些文章。不过，总体来说少了一些，这里的主要原因是持续两个多月的校招面试和持续三个多月的
flutter 项目，导致业余学习时间的连续性不够。</p>
<h1 id="关于读书">关于读书</h1>
<p>今年读的书并不多，寥寥数本而已。文学类的书读完了《红楼梦》和《水浒传》，读得比较细，也算是完成了读完四大名著的夙愿。历史类读了《极简二战史》，今年对于历史文化产生了比较大的兴趣，不过看的书少了点。技术类读了《计算机程序的构造与解释》、《Flutter
实战》、《Ruby 基础教程》，零零碎碎阅读了《深入解析 Mac OS X 和 iOS
操作系统》。对于技术书，以前是为了读而读，现在读书是为了作为参考资料而去读，今年有很多书是为了查阅某些内容而去节选地进行阅读，没有在此罗列。</p>
<h1 id="关于运动">关于运动</h1>
<p>疫情关系，今年上半年基本没有运动。后面因为项目和校招面试，没有怎么运动。大概到10月份才开始打球、游泳。运动的频率相比去年也小了不少。游泳技术没怎么提到，蝶泳还是做不到轻松蝶，自由泳倒是可以一直游，但是比较慢。上半年，一直在家办公，基本上一整天都是盯着电脑，导致视力散光度增加了不少，来年要时刻注意保护眼睛。</p>
<h1 id="新年愿景">新年愿景</h1>
<p>希望新的一年在硬实力方面，提升架构设计、重构方面的能力；在软实力方面，提升技术影响力、团队影响力、业务掌控力。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年度总结</title>
    <url>/2022/01/02/2021-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/hangzhou/WechatIMG1304.jpeg?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>2021
年是剧变的一年，教培行业受到了前所未有的打压。身为半个教培行业从业者，切身感受到了政策所带来的冲击。另外，在人口负增长的开端，国内互联网
toC
业务的增量时代也基本到头了，互联网行业也是裁员不断。焦虑无所不在...</p>
<p>其他的也不多说了，就说说自己这一年的收获吧。</p>
<h1 id="关于工作">关于工作</h1>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/life/dolphin-apps.png?x-oss-process=image/resize,w_800" /></p>
<p>今年 1 月份，我做了一个决定：离开小猿搜题业务团队，内部转岗去小猿 AI
课业务团队。这么做的原因是：</p>
<ul>
<li>一方面，自己已经在搜题按部就班地做了三年的一线研发，虽然在搜题还有很多有趣的事可以干，但是我更希望能够突破一下自己的能力，挑战一下自己；</li>
<li>另一方面，小猿 AI
课是从小猿搜题孵化出来的，我一直在对接相关的需求，也了解到它的数据很不错，很有前景，说不定它能像斑马一样，会迎来爆发式增长呢？</li>
</ul>
<p>初来乍到，整个研发团队还处于组建初期，除了 TL 外，前 3
位研发分别是我、<span class="citation"
data-cites="李哲">@李哲</span>、<span class="citation"
data-cites="周剑">@周剑</span>。经过一年时间，现在整个研发团队已经达到几十人的规模。</p>
<p>在双减政策下来之前的上半年，我们一直处于“打鸡血”状态，特别是 iOS
团队始终比 Android 团队少一人，对比之下，压力更大。一天修 50 个
bug、两周内完成 app
提测到上线、无产品稿开发、连续周末加班、1.5倍速开发、两天支持
IAP...这些都是经历过的事。在整个猿辅导内部，我们可能是最“卷”的业务团队了。</p>
<p>7月底，双减政策下来，我们的线上售卖全部下架，同时业务要进行调整。产品花了很长时间去进行调研，空档期间我们重新开始做
flutter 混合开发，以提升开发人效，毕竟后面的招聘工作会越来越难。</p>
<p>说到招聘，今年的上半年的面试强度很大，从 3 月到 8
月初，我差不多了面了 60 个 iOS 候选人，最频繁的时候，一天 2 场面试，一周
5 场面试。由于，iOS 比 Android 人少，Android 面试放缓，iOS
面试优先，开发时间又被面试时间挤压，属实艰难。所幸，iOS 中流砥柱 <span
class="citation" data-cites="王昱">@王昱</span>
为我分担了不少压力，无论是面试还是开发。为昱总打 call~</p>
<p>下半年，我主要负责做 flutter 基建，包括：flutter
桥能力、网络库适配、混合开发/独立开发、混合栈等。虽然写了挺多 Dart
代码，但是没怎么写业务开发，也算是个遗憾吧。一直想深入研究一下
flutter，奈何时间不允许，希望后面有时间能做点研究吧。</p>
<p>由于战略调整、业务转型等因素，我们下半年轻松了很多，并且我们团队了来了不少搜题的同学，为我们分担了研发压力。下半年，我简单地入门学习了
Android 开发、阅读了几个开源框架的源码、研究了一下 Swift
泛型协议和类型擦除、学习了 Ruby 开发等，还是有不少收获的。</p>
<p>整体而言，2021
年收获还是不少的。以前只需要关注自己手头上的活即可，现在需要把控负责项目的方方面面，需要付出更多的精力，这过程中心态、抗压、架构、管理、规划、沟通等各个方面都有所提升。</p>
<h1 id="关于学习">关于学习</h1>
<p>由于上半年工作压力很大，没有什么精力去学习，断断续续地写了几篇博客。好在下半年时间非常充裕，在这期间学习了收获了不少，同时产出了不少文章。今年有不少文章是
10 月之后产出的，为了填补上半年的空缺，故意把发表时间平均到每个月。</p>
<p>9 月份阅读了 Codable 源码，研究了一下 Swift
泛型协议和类型擦除，顺便产出了 3 篇文章：<a
href="http://chuquan.me/2021/10/18/codable/">《源码解读——Codable》</a>、<a
href="http://chuquan.me/2021/10/10/swift-type-erase/">《Swift
类型擦除》</a>、<a
href="http://chuquan.me/2021/09/25/swift-generic-protocol/">《Swift
泛型协议》</a>。</p>
<p>10 月份学习了 Android 开发，原本想着能够做一些 Android
需求，可惜条件不允许，希望以后有机会，无论是工作项目还是开源项目。此外，还阅读了
Resolver 源码，顺便产出了 2 篇文章：<a
href="http://chuquan.me/2021/06/07/ioc-di-sl/">《控制反转、依赖注入、服务定位》</a>、<a
href="http://chuquan.me/2021/07/01/resolver/">《源码解读——Resolver》</a>。</p>
<p>11 月重新温习了一下 Ruby，看了下《Ruby 元编程》。然后开始阅读
CocoaPods
源码，断断续续到现在差不多有两个月了。虽然还没看完，但是对它的设计有了一个整体认识。现在正在对细节部分进行研读。这期间也产出了一些文章：</p>
<ul>
<li><a
href="http://chuquan.me/2021/11/04/claide/">《源码解读——CLAide》</a></li>
<li><a
href="http://chuquan.me/2021/11/21/how-to-develop-command-line-tool-with-claide/">《如何使用
CLAide 开发命令行工具》</a></li>
<li><a
href="http://chuquan.me/2021/12/03/understand-concepts-in-xcode/">《理解
Xcode 中的各种概念》</a></li>
<li><a
href="http://chuquan.me/2021/12/14/understand-files-in-xcode/">《理解
Xcode 中的各种文件》</a></li>
<li><a
href="http://chuquan.me/2021/12/24/podfile-analyze-principle/">《Podfile解析原理》</a></li>
</ul>
<p>关于 CocoaPods，后面的研究还会继续进行，博客查出也会及时跟进。</p>
<p>整体来说，今年的阅读源码的能力有了很大的提升。另外，因为做了不少基建相关的工作，工程能力相比去年又提升了不少。</p>
<h1 id="关于读书">关于读书</h1>
<p>关于读书，今年着实有些拉跨，技术方面看了 5 本书：</p>
<ul>
<li>《Ruby 基础教程》</li>
<li>《Ruby 元编程》</li>
<li>《第一行 Android 代码》</li>
<li>《SwiftUI 与 Combine 编程》</li>
<li>《松本行弘：编程语言的设计与实现》</li>
</ul>
<p>其他的书就看了一本《中国通史》，主要原因是不再进行微信读书打卡了，没有
<span class="citation" data-cites="琳洁">@琳洁</span>
监督，懈怠了不少。</p>
<p>希望明年能多读点书吧~</p>
<h1 id="关于生活">关于生活</h1>
<p>今年完成了自己的终身大事，始从校园，十年时间，终于修成正果。4 月 16
日领证，7 月 25
日婚礼。婚礼的筹备非常烦神，感谢老婆不厌其烦地进行各方沟通和操劳，当然还得感谢父母们对婚礼的筹备~</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/life/WechatIMG1305.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>因为疫情和工作，今年没有去度蜜月。不过，倒是在北京环球影城内测阶段去玩一天，的确很不错，值得一玩。PS：如果去的话，建议买优速通，游玩体验应该能提升不少。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/life/WechatIMG1306.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>另外，国庆期间去杭州和合肥玩了 10
天，行程匆忙，没有尽兴。希望以后能多出去玩玩，不要老是宅在家里~</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/life/WechatIMG1308.jpeg?x-oss-process=image/resize,w_800" /></p>
<h1 id="关于运动">关于运动</h1>
<p>今年一整年都没有游几次泳，首先上半年没时间，下半年公司的健身房福利取消，自己又没有去办卡，于是就荒废了。倒是今年开始室外跑步了，一开始跑
5 公里，两次后就跑 10 公里，配速差不多稳定在 5 分 40
几秒。但是天气很快转冷，室外跑步的次数越来越少。</p>
<p>为了每周都能锻炼，到了下半年，我基本上每周都去打一次篮球，整体状态还可以。</p>
<p>希望新年游泳、跑步、篮球都能长期坚持下来~</p>
<h1 id="新年愿景">新年愿景</h1>
<p>希望能够保持好心态，拥抱变化。保持运动，保持健康。多喝水，降低尿酸。</p>
<p>另外，要多读书，学习新知识，不仅限于技术方面。</p>
<p>最后，祝新年快乐~</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 年度总结</title>
    <url>/2022/12/31/2022-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-08.png?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>又到了一年一次例行总结的时候，写篇文章来回顾一下这一年的经历、收获和成长吧。</p>
<h1 id="自由市场">自由市场</h1>
<p>今年年初，部门内出现了不少人员变动，印象中有 <span class="citation"
data-cites="周剑">@周剑</span>、<span class="citation"
data-cites="向南">@向南</span>、<span class="citation"
data-cites="孝发">@孝发</span>、<span class="citation"
data-cites="全义">@全义</span>
等都提了离职。一方面，考虑到公司因政策影响无法上市，未来非常不明朗；另一方面，我工作
4
年至今未曾接触自由市场。因此，想了解一下自己在市场中属于什么水平，看看有没有好的机会。</p>
<p>我从 1 月 20 日第一次面试，到 3 月 17
日最后一次面试，中间经历了过年，有两个多星期没有安排面试，总共历时 2
个月。简历差不多投递了十几家公司，基本都是知名的互联网大厂和中厂，最终差不多面试了
30
场，也是心力交瘁，自我介绍和项目介绍都背麻了...不过，好在结果还是挺好的，除了有一家技术面面挂了，其他的基本上要么是流程到了
HR 面，要么是我主动结束面试流程，还有几家是给了书面 Offer 或口头
Offer。</p>
<p>这三个月业余时间一直在复习基础、刷算法题、复盘面试，期间和 <span
class="citation" data-cites="瑀晗">@瑀晗</span>、<span class="citation"
data-cites="金俊">@金俊</span>
也经常交流面试情况和工作选择。万万没想到的是 <span class="citation"
data-cites="瑀晗">@瑀晗</span> 和 <span class="citation"
data-cites="金俊">@金俊</span>
最终去了同一家公司的同一个小组，换了个公司做同事。当然，这期间基本上没有放在太多心思在工作和学习上，但总的来说，收获还是挺大的，大概有几点：</p>
<ul>
<li>了解了自己在大厂职级体系中所对应的水平，因此个人自信心增长了不少。</li>
<li>了解了岗位所需要的知识体系，看到了自己的短板，摸清了各个公司面试重点和套路。</li>
<li>了解了更加高阶的岗位要求是什么，找到了自己努力和进阶的方向。</li>
</ul>
<p>当然，最终我没有选择跳槽，主要原因还是 <span class="citation"
data-cites="碧峰">@碧峰</span> 说的
“有更大的发挥空间和成长空间”。另外，还有几个次要原因：</p>
<ul>
<li>觉得通过面试已经找到了努力的方向，如果换个地方，可能适应环境都要花费很久，而且很多东西都要从头开始。</li>
<li>觉得外面的公司绝大多数都太卷，薪资性价比不是特别高。</li>
<li>觉得整体大环境不好，裁员比比皆是，有点不稳定，担心“毕业”。</li>
</ul>
<p>在作出决定之前，<span class="citation" data-cites="李哲">@李哲</span>
转岗去了搜题，大哥找我聊了一次；在作出决定之后，我找大哥又聊了一次。在得到了大哥的一些承诺之后，开始逐步接管客户端团队，负责
Android/iOS/Cocos/Flutter 的日常事务和工作安排，这时候差不多 4
月份了。</p>
<h1 id="关于工作">关于工作</h1>
<p>今年的工作角色发生了转变，从 iOS Owner
转变成客户端负责人。这一年来，自己也推动了一些事情的落地。</p>
<p>第一件事是优化 Zeta Math 上课路径效果。经过综合考虑后，设计了一套基于
Cocos View
复用，支持代码热更新、内容增量更新的技术方案。相比于第一版基于 Native
实现的方案，新版本的视觉效果和用户体验好了很多。项目整体开发经历了一个月，最终顺利上线。</p>
<p>第二件事是 GitLab CICD 建设，搭建了一套基于 Danger 的
Lua/Swift/Kotlin 的静态代码检查能力。由于 Lua
较为小众，没有现成的插件可供使用，对此，开发了一个 ruby gem——<a
href="https://rubygems.org/gems/danger-luacheck">danger-luacheck</a>。Dart
的静态代码检查能力暂时还没支持，后续有时间再整吧。</p>
<p>当然，CICD
能做的事远远不止这些，包括：单元测试、依赖分析、编译检查、代码扫描等等。等到后续人手充足，时间充裕，再捡起来。</p>
<p>第三件事是去 Flutter 化。海豚自习 App 的首页四个
Tab，包括一部分二级页都是用 Flutter 写的。在需求迭代过程中，Flutter
开发的很多痛点逐步暴露出来了，主要包括以下这些：</p>
<ul>
<li>调试不方便。特别是涉及到 Native 和 Flutter
混合调试时，大部分情况只能使用日志进行调试。</li>
<li>线上问题多。由于我们的 Tab 也是 Flutter 实现的，因此 Flutter
页面曝光率是
100%。对此，线上经常出现白屏、内存泄露、页面卡顿、图片锯齿等问题。由于我们对于
Flutter 的投入太少，很多东西都无法解决。</li>
<li>新人不友好。新入职的同学基本都没有 Flutter
开发经验，从头开始学得占用一段时间。最头疼的是，我们的需求变动最频繁的几个
Flutter 页面都非常复杂，新人上手的成本非常高。</li>
<li>提效不明显。在开发效率方面，Flutter 的目标是 Native 的 2
倍，然而在实践中，我觉得顶多也就 1.5 倍左右。有时候也会遇到 Native
很容易实现，而 Flutter
却很难实现的情况。另外很多情况下，还需要双端同时开发插件。</li>
</ul>
<p>一方面，考虑到后续几个 Tab
首页的需求迭代会越来越多；另一方面，希望能够让更多的同学参与到这些需求的开发中。于是，开始规划
Tab 重写。很幸运地，在国庆前找到了一个空档期，所有同学都参与了 Tab
重写，同样也花了一个月的时间，顺利上线。上线后的优化效果的确很明显，白屏没有人报了，崩溃率也下降了不少，页面流畅度也提升了不少。</p>
<p>第四件事是基于 page scheme 的动态弹窗管理能力建设。构想并建设 page
scheme 主要基于几个事实：</p>
<ul>
<li>一个定制弹窗需求。对此，我调研了淘宝的 PopLayer 方案，设计了一套基于
WebView 的弹窗方案，称之为 WebLayer。</li>
<li>一个卡牌激励需求。对此，我们上线了基于 MQTT
的长连接能力，并设计了一套基于页面白名单和黑名单的消息处理能力。</li>
<li>统一页面曝光需求。这是一个技术需求，希望能够在当前页面上报埋点时，携带上级页面的信息，此外，还能够处理页面停留时长、网络请求时长等信息。</li>
<li>统跳链接信息维护。一直以来，包括小猿搜题、海豚自习馆等诸多
App，我们都是通过手动维护一个 wiki
来记录统跳信息。这里，我希望能够通过代码生成统跳信息，甚至还包括其他的页面信息、参数信息等等。</li>
</ul>
<p>最终，我构想了一套 page scheme 能力，通过项目代码生成不同版本的 page
scheme 文件，后台可以根据 page scheme
配置指定的页面显示弹窗或一些其他能力。服务器将后台配置结合消息数据，通过
MQTT 或 HTTP 的方式下发至 App，App 再进行处理。</p>
<p>期望的项目终极形态是，支持在运营在后台配置任意弹窗，包括：WebLayer、Native
弹窗等，支持指定页面显示（或不显示）。其中，WebLayer
支持类似弹窗、新手引导、红包雨、气泡等各种运营效果。</p>
<p>目前，page scheme
能力的搭建还在进行中，客户端的相关能力基本已经完成，包括：弹窗管理器、page
scheme 定义、配置文件生成、MQTT 分派、WebLayer
管理器等。后续，还要继续推动后台相关的基础设施的搭建。整体来讲，我个人觉得这个项目还是比较有意义的，并且具有一定的创新性，期待上线后的效果。</p>
<h1 id="关于学习">关于学习</h1>
<h2 id="开源代码">开源代码</h2>
<p>今年阅读了四个开源项目的代码，分别是：getopt、git、Aspects、PromiseKit。</p>
<p>关于 getopt 源码，主要是出于两个契机。一个是自己看完了《C
语言教程》；一个是出于优化 nox 的目的。最终，产出了一篇源码解读文章 <a
href="http://chuquan.me/2022/04/04/getopt/">《源码解读——getopt》</a>。</p>
<p>关于 git 源码，我首先精读了创世版的代码，也就是 Linus Torvalds
写的那个版本。然后看了下 2.0.0
版本的代码，核心的数据结构和设计原理没有太大的变化。同时又看了《Pro
Git》的部分章节，最终对 Git
的底层设计原理有了一个比较清晰的认识。对此，写了篇文章 <a
href="http://chuquan.me/2022/05/21/understand-principle-of-git/">《深入理解
Git 底层实现原理》</a>，并在团队内部做了次技术分享。</p>
<p>关于 Aspects
源码，框架的实现非常精简，只有一份代码文件。当然，也是非常仔细的阅读了一遍，整理了一下思路，并写了篇文章
<a
href="http://chuquan.me/2022/11/13/understand-principle-of-aspects/">《深入理解
Aspects 设计原理》</a>。</p>
<p>关于 PromiseKit
源码，是因为年底的时候对于异步编程比较感兴趣，想到辅导的代码里也用到了，于是想来学习了一下。最后也产出了两篇相关的文章：</p>
<ul>
<li><a
href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise
核心实现原理》</a></li>
<li><a
href="http://chuquan.me/2022/10/29/promisekit/">《源码解读——PromiseKit》</a></li>
</ul>
<h2 id="技术书籍">技术书籍</h2>
<p>今年自己读书相关的计划完成的还可以，主要看了以下这么些：</p>
<ul>
<li>《C语言教程》</li>
<li>《C++ Primer Plus》</li>
<li>《Software Engineering at Google》</li>
<li>《编译原理》：泛读了一下，另外看了两遍哈工大的编译原理公开课。</li>
<li>《How to write your own
compiler》：这本书花了一个月的业余时间，精读、翻译、实验，但是发现其所使用的
LLVM
版本过低，导致我花了很多时间用于解决各种报错。最后几章节的一些报错实在解决不了了，遂放弃。</li>
<li>《Kaleidoscope: Implementing a Language with
LLVM》：这本书差不多用了两个月的业余时间，精读、翻译、实验。</li>
<li>《大型网站技术架构》</li>
<li>《Swift 异步与并发》</li>
<li>《计算之魂》</li>
</ul>
<p>除了技术书籍之外，其他的就看了毛选的卷一，看了一半，确实能感受到教员的伟大。后面，有时间有心境的时候，还是要好好读读毛选。</p>
<h2 id="博客文章">博客文章</h2>
<p>今年总共写了 20 来篇博客，有一半是对于《Kaleidoscope: Implementing a
Language with
LLVM》的章节翻译，当然也包含了一部分自己精读后的理解。除此之外，一部分是跟编译原理工具有关，一部分是跟异步编程有关，其他的还有一些琐碎的主题。整体来说，涉及的技术广度还不是很大。</p>
<h2 id="学习英语">学习英语</h2>
<p>因为今年年初的面试经历，了解到外企的一些高级岗位还是有英语要求的，特别是口语。考虑到未来失业了能多一个选择🐶，于是想着从现在开始好好练练口语。苦于没有语言环境，最后抱着试试看的心态，买了个流利说的课。想着坚持一年，看看效果。从4月份到现在，总体感觉是有点帮助的，至少语感，语言组织要比以前好很多。后续再看看，要不要考虑一下真人一对一。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-02.jpeg?x-oss-process=image/resize,w_200" /></p>
<h1 id="关于生活">关于生活</h1>
<p>今年生活中最大的里程碑就是还完了房贷，好歹少还了大几十万的利息。</p>
<p>其次，便是休了一个长假，国庆节 + 8 天年假 + 1 个周末，总共休假 17
天。假期计划分三段行程：湖州长兴、南京、合肥。</p>
<p>在长兴的几天，见了假期最后一天的老弟，走了几家亲戚，和发小看了场"乡BA"、吃了顿夜宵。在家的几天，和老姐、外甥去了次太湖龙之梦。龙之梦确实非常大，比环球影城大不少，但是有些主题公园还没有完全造好。我们只体验了动物世界主题公园，整体感觉还是挺不错的，比北京动物园强多了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-05.jpeg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-04.jpeg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-06.jpeg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-03.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>因为疫情原因，本来去南京玩的计划取消了，直接去了合肥。在合肥待的时间比较久，于是定了计划，把《Software
Engineering at
Google》看完了。由于国庆期间天气太极端，不是极端热就是寒潮降温，周边玩也没玩好。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-07.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>国庆前两天，偶然看了下北京健康宝，发现弹窗3。因为可能会耽误回京，导致后面几天每天都在尝试消弹窗，也没什么心情出去玩。</p>
<p>一整年来，因为疫情反复，也没有出去好好玩玩。2023
年放开了之后，希望一切都能恢复正常吧。</p>
<h1 id="关于运动">关于运动</h1>
<p>今年一直在保持运动，跟 <span class="citation"
data-cites="龙哥">@龙哥</span>
一伙人组了局，同时部门内部又组了个局，基本上每周都能打次球，甚至打两次。</p>
<p>另外，今年算是把跑步坚持了下来。从 7
月份开始，每周跑一次十公里。配速从 6:00 提高到了最快
5:16。可惜，到了十一月份，因为疫情，再加上室外过于寒冷，风又太大，就暂停了。希望明年能够从开春就坚持跑步，保持每周十公里，争取能参加一次马拉松。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-01.jpeg?x-oss-process=image/resize,w_280" /></p>
<h1 id="新年愿景">新年愿景</h1>
<p>2022
年一直处于较为紧张和规律的状态，收获也挺多，看了些书，读了些源码，写了些博客，希望
2023 年能够继续保持吧。</p>
<p>另外，身体才是革命的本钱。少熬夜，多喝水。保护视力，坚持运动。</p>
<p>最后，祝新年快乐~</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2023，31岁客三消从业者的年度回顾</title>
    <url>/2024/01/05/2023-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-01.jpg?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>每年总是要例行回顾一下过去一年，看看自己做了什么，收获了什么。</p>
<h1 id="角色适应">角色适应</h1>
<p>今年是作为移动客户端负责人的第 2
年，自己基本已经适应了这个角色。一开始，我和团队中很多成员都是一线的研发，后面被提拔到这个位置。那时候，在技术决策、任务分配、会议沟通时，经常会想自己的决策和做法是否被认可？是否被信服？团队成员是否认可自己？总之，心理负担一直都是有的。</p>
<p>在业务的迭代和发展过程中，我会回顾自己做的决策。从结果看来，整体都是符合预期的，比如：</p>
<ul>
<li><strong>关于兄弟团队借人的决策</strong>。部门内有两条业务线，另一条业务线今年年初在快速发展，缺
iOS 开发，于是经过部门老大的同意向我们借人，希望能够支援 3
个月。，最终我决定让组内的几个同学轮流支援，每人支援一个月。一方面，可以避免外派同学产生边缘心理；另一方面，也可以避免借人还人的情况。</li>
<li><strong>关于提测质量竞赛的决策</strong>。年初在与测试同学的沟通中了解到：在服务端、前端、客户端的测试过程中，测试体验最差的往往都是客户端。当然，这里面是存在客观原因的。关于服务端，其主要是开发业务逻辑，不包含
UI 逻辑，一旦联调完毕，在测试阶段 BUG
其实是很少的；关于前端，其与客户端非常相似，区别在于前端在测试阶段可以热修复
BUG，前一分钟还存在的
BUG，后一分钟可能就解决了。关于客户端，相比服务端多了 UI
BUG，相比前端修复周期比较长（修复、编译、验证、打包、提测）。最终产生客户端测试体验差的感觉。为了提高提测质量，提出了提测质量竞赛的机制，对于同一个需求，Android/iOS
BUG 数量出现大于等于 5 的情况时，BUG
数量少的一方和对应的测试同学将获得一杯喜茶，并记录在 Score Board
中。一年下来，组内成员的自测意识确实提高了不少，产生的 BUG
基本上都是测试用例之外的 BUG。</li>
</ul>
<p>正确的决策会带来正向的激励，从而产生正反馈效应。于是，之前心理负担开始慢慢的消失，自己对于这个角色也开始逐步适应，慢慢开始变得得心应手起来。</p>
<h1 id="工作产出">工作产出</h1>
<p>在工作产出方面，今年主要做了一些工程能力和技术调研等工作，比如：</p>
<ul>
<li>构建客户端 NodeJS 服务，支持 Sentry 崩溃告警、GitLab Code
Review、包体积分析等能力。</li>
<li>Cocos
引擎定制的工程化，解决底层引擎替换问题，增加引擎日志，独立引擎打包等。</li>
<li>推进并落地 Cocos 资源代码隔离能力，从而让 App 内的 Cocos
互动题具备全局的热修复能力。</li>
<li>直播自建、局部录屏、恢复购买、家庭共享、Deferred Deep Link
等技术方案调研。</li>
</ul>
<p>今年，在 iOS
同学外派支援期间，我做了一些业务需求，其他时间基本都没有参与复杂业务和模块的具体开发。因为团队内
Android 和 iOS
的研发人员数量对等，所以不需要我来承担额外的开发任务。只有当出现临时需求或者排期时没有分配的需求时，为了不打乱既定的排期，一般会由我来兜底做这些需求，一个人同时写
Android 和 iOS。</p>
<p>整体而言，今年开始逐步退居二线，做一些技术决策和工程能力等相关工作。不过，在日常中我仍然坚持写代码，因为我始终觉得一旦自己脱离一线太久，很容易会作出一些不符合现实的决策和排期。</p>
<h1 id="身体是革命的本钱">身体是革命的本钱</h1>
<h2 id="眼睛疲劳">眼睛疲劳</h2>
<p>从 2021 年下半年到 2022
年上半年，我一直有着眼睛疲劳的症状，具体表现就是
<strong>眼睛无法准确对焦</strong>。当我在观察 3
米以外的物体时，大脑中呈现的视觉效果是有两个物体（两个眼镜各自成像的物体），两个物体无法合成到一个画面中，需要非常努力的弄眉挤眼才能对焦上，但是过不了多久又会失焦。</p>
<p>这个问题我一直都没有发现，因为在工作生活中，眼睛对焦基本都在 3
米以内。最后是在电影院观影时才发现的，画面有重影，观影感极差。从那时起，我才开始重视视力问题。</p>
<p>在 4
月份，我预约了同仁医院的眼科挂号。在医院里，我看到了各种饱受眼科疾病困扰的患者，青光眼、视网膜脱落、近视手术后遗症等等，这让我视力恢复之前都非常焦虑。在经历一系列眼科诊断之后，医生得出的结论是眼睛疲劳
+
近视度数上涨。于是，在同仁医院配了一副眼镜，自己额外配了一副隔蓝光的镜片，配合着服用叶黄素，进行修养。总体来说，是有效果的，但是效果还是有点慢。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-02.jpg?x-oss-process=image/resize,w_600" /></p>
<p>在 5
月份，五一长假休假在家，我尝试尽量不使用电脑和手机。即使使用电脑，也是投屏到电视上，然后坐在沙发上观看电视屏幕，尽量保持远距离观看。经过一个多星期的调养。眼睛疲劳改善非常明显。假期结束后，我期望着眼睛能完全恢复，可惜大概一个月作用的时间，眼睛又开始疲劳。特别是中午遇到强光时，症状会更加严重。</p>
<p>在 8
月份，我开始意识到眼睛疲劳可能是因为睡前和醒后躺在床上刷手机导致的。每次睡觉前我都会不由自主地刷一个多小时的手机，早上醒来也是躺在床上刷一个多小时手机，加上姿势不正确，导致视力疲劳。于是，我开始强制自己在床上玩手机不超过
20 分钟。坚持了半年了，现在视力明显恢复了。</p>
<p>在视力恢复之前，我一度非常焦虑，经常思考程序员的职业给我带来了什么？如果视力无法治疗该怎么办？...好在现在恢复了，这次经历让我明白了身体健康的重要性。一定要注意身体，不要让打工挣的钱成为身体的医疗费！从而言之，身体是革命的本钱。</p>
<h2 id="运动健身">运动健身</h2>
<h3 id="健身">健身</h3>
<p>8 月份，在 <span class="citation" data-cites="昱总">@昱总</span>
的安利下，我办了天奥的健身卡，怕自己坚持不下来，先办了一年的年卡。由于 8
月份期间参加各种篮球赛，所以真正开始规律健身应该是从 9
月份开始，周一练背，周四练肩，周五练手臂，偶尔练练卧推。目前卧推能 60KG
做组，左右手力量也均衡了很多。除此之外，双十一配了肌酸和蛋白粉，喝的不算多，佛系健身。于我而言，健身的目的是为了自己变得壮一点，而不是看起来像细狗，仅此而已，什么健体、健美并不是我的目标。</p>
<h3 id="篮球">篮球</h3>
<p>今年算是工作以来打篮球最多的一年了，首先是固定每周二中午打 2
小时篮球。另外就是篮球赛，8 月参加了 CBD 篮球联赛，9 月参加了 CYBA
篮球联赛，这两个月周末总有一天是在打篮球。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-03.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-04.jpg?x-oss-process=image/resize,w_600" /></p>
<h3 id="跑步">跑步</h3>
<p>2022
年终总结时给自己定了一个目标——<strong>参加一次半程马拉松</strong>。因此，我计划参加
4
月份的北京半程马拉松。结果，等到报名时发现要求必须三年内参加过其他马拉松，并提供相关证明。没办法，没有资格参加，只能选择参加奥森马拉松。</p>
<p>我从 2.25 开始备战，从 5 公里开始，每周跑一次，每次比上一次增加 2.5
公里左右，最终达到 21 公里。练了一次 21
公里后，参加比赛。最终成绩还不错，用时 <code>2:01:52</code>。定一个 2024
年的小目标——<strong>半马破 2 小时</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-05.jpg?x-oss-process=image/resize,w_320" /></p>
<p>参加半马之后，我开始坚持每周末都跑一次 10
公里，偶尔还会参加一下线上马拉松，收集了不少奖牌。最终坚持到了 10
月底，11 月份室外跑步属实太冷了，打算 2 月份重新开始。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-06.jpg?x-oss-process=image/resize,w_800" /></p>
<h3 id="作息">作息</h3>
<p>正是办了健身卡之后，我和媳妇开始调整生活作息，拒绝熬夜，晚上 11:20
之前睡觉。早上差不多能 6、7
点起床，起来后去四得公园，媳妇跑步，我则散步。在公园大概 40
分钟，期间能呼吸一下新鲜空气，放空一下大脑。当然在一个人散步的时候会思考很多，比如：职业规划、业余项目、技术问题等。散步结束回来大概
8 点左右，还能有两个小时看会儿书或写会儿代码。</p>
<p>调整作息之后，感觉自己的精神状态好了很多，下班时间的使用效率也变得更高了。当然，周末也不再是没有上午的周末，时间也变得更加充足。作息调整是今年个人转变的最大成就，为了健康和效率，未来一直要继续保持下去。</p>
<h1 id="学习收获">学习收获</h1>
<p>上半年因为眼睛问题，有意减少电脑使用时间，下半年业余时间主要在项目，因此整体而言，2023
年在学习上投入的时间并不是很多。关于学习方面的成就主要有以下几部分。</p>
<h2 id="书籍">书籍</h2>
<p>因为尽量不过度用眼，今年看的书并不多，只有以下几本：</p>
<ul>
<li>《第一行代码——Android（第3版）》</li>
<li>《架构师的自我修炼》</li>
<li>《程序员修炼之道》</li>
<li>《On Java 基础版》</li>
<li>《重构》</li>
<li>《程序员的自我修养》三刷</li>
<li>《计算机图形学入门：3D渲染指南》</li>
</ul>
<h2 id="博客">博客</h2>
<p>今年写的博客也不多，年初的时候产出了几篇编程语言相关的博客：<a
href="http://chuquan.me/2023/01/15/actor/">《浅谈 Actor 模型》</a>、<a
href="http://chuquan.me/2023/03/11/structured-concurrency/">《结构化并发》</a>、<a
href="http://chuquan.me/2023/04/22/prototype-based-inheritance/">《基于原型的继承模式》</a>。</p>
<p>年中的时候研究 Homebrew 和 fishhook 产出了两篇原理分析博客：<a
href="http://chuquan.me/2023/06/24/understand-fishhook-design/">《如何从链接原理的角度理解
fishhook 的设计思想？》</a>、<a
href="http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/">《Homebrew
的设计哲学》</a>。</p>
<p>最后就是十一那会儿写了两篇关于差分算法的博客：<a
href="http://chuquan.me/2023/09/13/myers-difference-algorithm/">《Myers
差分算法 》</a>、<a
href="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/">《Paul
Heckel 差分算法》</a>。</p>
<h2 id="项目">项目</h2>
<p>今年业余时间总共做了三个半项目，相比之前几年，产出高出了不少，希望明年继续保持。</p>
<p>第一个项目是 <a
href="https://github.com/baochuquan/taskloop">Taskloop</a>。这是一款基于
crontab
的定时任务管理器，支持语义化的配置规则，并且支持环境变量导入、日持查询等功能。具体介绍详见
<a
href="http://chuquan.me/2023/07/30/introduction-to-taskloop/">《如何优雅地管理你的定时任务？》</a>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800" /></p>
<p>第二个项目是 Morph Clock（中文名：莫负时钟）屏幕保护程序。这是一款
MacOS 屏幕保护程序，采用一种数字变形的艺术效果实现。</p>
<p>第三个项目是 <a
href="https://apps.apple.com/us/app/morph-rest-break-reminder/id6474056217">Morph
Rest</a>（中文名：莫负休息）。这是一款 MacOS
休息提醒应用程序，预防眼睛疲劳、腰间盘突出、劲椎疼痛等职业病，也可辅助提醒喝水，避免尿酸过高，引发痛风等疾病。为什么做这个项目？主要有两方面原因：一方面，我经历了眼睛疲劳，迫切需要一款软件能够经常提醒我站起来活动活动，让视线远离屏幕，顺带提醒自己多喝水。另一方面，我希望打造一款独立产品，尝试利用业务时间成为一位
Indie
Hacker。于是，差不多花了一个半月的业余时间，完成了项目，并最终上架。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-07.png?x-oss-process=image/resize,w_800" /></p>
<p>Morph Clock 和 Morph Rest 则是面向普通 Mac
用户的独立产品。项目代码并没有开源，因为我希望能够通过它们创造收入，这里定一个小目标：<strong>在未来
2024 年内通过独立产品创造 99
美元的收入，回收的开通苹果开发者账号的成本</strong>。如果有用户支持，欢迎下载使用。</p>
<h2 id="其他">其他</h2>
<p>其他方面的学习收获也是有的，首先是 Android
开发，春节假期期间，在家学习了一下 Android 开发，重写了海豚 AI
学中的一个 Flutter 页面，算是入门了 Android。鉴于此，下半年能够做一些
Android 小需求。但是没有深入研究 Android
开发，也没有做过一些复杂业务开发，这一方面希望 2024 年能够有所改善。</p>
<p>其次，在下半年做独立产品期间，系统性地学习了 Sketch
相关技巧和理论。Morph Rest 和 Morph Clock 相关的 UI
设计和切图也都是自己完成的，算是额外掌握了一个 Indie Hacker
必备的技能吧。</p>
<p>最后，系统性地学习了一下 MacOS 开发，它与 iOS
开发在整体上一致的，在一些实现细节上有所不同。如果按照自己所认知的 iOS
原理来开发 MacOS 应用会遇到很多奇怪的 BUG。在系统性学习之后，再来开发
MacOS 应用会简单很多，这一点我深有体会。</p>
<h1 id="生活不只有工作">生活不只有工作</h1>
<p>今年是工作以来第一个没有债务的年份，因此不再考虑紧巴巴地生活了，该吃吃，该喝喝，该玩玩。不过因为疫情三年养成了一种「宅」感，所以还需要继续调整和适应。</p>
<h2 id="假期">假期</h2>
<h3 id="合肥">合肥</h3>
<p>五一假期回合肥休假，为了调养眼睛疲劳，没怎么学习，主打的就是休假。期间主要在滨湖转悠，骑上共享电驴，环游了一些景点和公园，渡江战役纪念馆、岸上草原、安徽名人馆、塘西河公园、金斗公园等。比较可惜的是，没约上安徽美术馆，不过以后有的是机会。</p>
<p>在家期间，用闲置的 Mac Mini
配上电视，效果很不错，也很护眼。用这一套装置在家看完了《漫长的季节》！《漫长的季节》成为了我心中国产剧的
No.1，墙裂推荐！</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-09.jpg?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-10.jpg?x-oss-process=image/resize,w_800" /></p>
<h3 id="廊坊">廊坊</h3>
<p>7
月份，我在朋友圈看到有同事去了廊坊的只有红楼梦·梦幻戏剧城，感觉很不错，加上自己很喜欢《红楼梦》，所以抽了一个周末去了一趟廊坊。园区非常大，网上的评价大多是一天的游玩时间不够，于是我们就订了
2 日通票。不得不说，里面的建筑和剧场都非常惊艳！绝对值得去玩一次！</p>
<p>不过很可惜，我们去的那个周末天气不太好。周六阴天，周日暴雨。因为暴雨园区闭园，给我们退了一半的票，算下来也就是玩了一天时间，差不多玩了大半个园区吧，只不过话剧和情景剧没看够。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-08.jpg?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-11.jpg?x-oss-process=image/resize,w_800" /></p>
<h3 id="哈尔滨">哈尔滨</h3>
<p>今年 10
月份原本打算去哈尔滨，结果跟我弟了解了一下情况后，决定等到冰雪大世界开放之后再去。最终在元旦前请了几天假提前出发，主要是为了避开假期旅游高峰。好巧不巧，哈尔滨旅游今年出圈了，游客非常多，几个热门项目排队时间都超长，几乎每个都要排队
3
个小时起步，比如：大滑梯、摩天轮、哈冰秀。我们在冰雪大世界整一天就是佛系游玩，毕竟在零下十度的室外排队几个小时的体验可不是那么好。不过有一说一，冰雪大世界里的冰雕、雪雕确实都非常精美、壮观，绝对值得去参观一次！</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-12.jpg?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-13.jpg?x-oss-process=image/resize,w_600" /></p>
<h2 id="搬家">搬家</h2>
<p>今年 10 月份搬了一次家，离开了住了 6
年的高家园。高家园附近环境其实很不错，小区门口很多街边商店，很繁华；马路对面就是丽都，是一个相对比较高端的街区；500
米远处是四得公园，疫情期间翻修了一次，环境非常不错。因为生活很方便，所以在这里住了
6
年。搬家期间，特别是对面的室友搬走的时候，内心非常感慨：岁月匆匆，人生匆匆，北漂生活何时终了？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-14.jpg?x-oss-process=image/resize,w_600" /></p>
<h1 id="思维转变">思维转变</h1>
<p>2023 年，我感觉自己最大的变化是思维的转换，主要是两点：</p>
<ul>
<li>身体是最重要的，其他的一切都是身外之物。</li>
<li>打工是没有出路的，提前计划自己的未来。</li>
</ul>
<p>第一点不用多说，是眼睛疲劳期间非常焦虑，那会儿才真正体会和理解这一点。第二点是因为今年
8
月开始早起散步，散步期间开始思考未来的打算。这两年各种裁员消息层出不穷，即使你学历再好，技术再厉害，当公司不需要你时，无外乎其他任何因素，随时都可能裁你。一旦失业，你再就业的难度会与你的年龄正比，这是非常现实的问题。</p>
<p>于是，我开始逛一下独立开发者相关的网站，比如：Indie Hacker，Product
Hunt，w2solo。在这些论坛中，我看到了很多独立开发者的成功案例，这也激励了我尝试使用业余时间来走这条道路。11
月份，我开始着手做一款 iOS
App，期间自己做产品调研，画设计稿，代码实现。期间感觉自己对于产品的最终效果还是有点不确定，而且担心战线太长，所以果断暂停了项目，转而开发形态更加确定的一款
MacOS App——<a
href="https://apps.apple.com/cn/app/morph-rest-break-reminder/id6474056217?mt=12">MorphRest</a>。期间，还写了一个
MacOS 屏幕保护程序——Morph
Clock。这些产品未来不一定能成功，但是我不迈出这一步，那么永远都不会成功。</p>
<h1 id="新年愿景">新年愿景</h1>
<p>未来一年，我应该还会继续尝试做一些独立产品，努力成为 Indie
Hacker。当然，技术博客也会被不定期更新，毕竟这是热爱，而不是生活。</p>
<p>最后，祝新年快乐~</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>一种简易的客户端存储架构设计</title>
    <url>/2018/04/26/a-design-of-ios-storage-architecture/</url>
    <content><![CDATA[<p>今天看了公司内部某三个APP项目的存储相关代码。总体来说，存储架构基本上是类似的。对此，我绘制了其存储架构的示意图，如下图所示。</p>
<span id="more"></span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/leo-local-storage.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="数据库">数据库</h1>
<p>项目使用自定义的数据库<code>KVDBStore</code>，该数据库实际上只是对开源数据库<code>FMDatabase</code>进行了封装，其包含如下两个属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface KVDBStore()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) FMDatabaseQueue *dbQueue;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *dbPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>KVDBStore</code>存储于应用沙盒的<code>Data Container</code>中的<code>Documents</code>目录下（<a
href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis">进一步了解应用沙盒结构</a>）。该目录可以通过如下方法获取。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];</span><br></pre></td></tr></table></figure></p>
<p><code>KVDBStore</code>数据库的存储条目具有几个特定的值，使用<code>DBItem</code>对象来表示，其属性包括：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface DBItem : NSObject</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString * itemId;</span><br><span class="line">@property (strong, nonatomic) id itemObject;</span><br><span class="line">@property (strong, nonatomic) NSDate * createdTime;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><code>KVDBStore</code>主要提供了构造方法、析构方法以及一些基本的操作方法，如：增删查改、Transaction操作等，如下所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)initDBWithName:(NSString *)dbName;</span><br><span class="line"></span><br><span class="line">- (id)initWithDBWithPath:(NSString *)dbPath;</span><br><span class="line"></span><br><span class="line">- (BOOL)createTableWithName:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (BOOL)clearTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (void)close;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">///************************ Transaction methods *************************************</span><br><span class="line"></span><br><span class="line">- (BOOL)beginTransaction;</span><br><span class="line"></span><br><span class="line">- (BOOL)rollbackTransaction;</span><br><span class="line"></span><br><span class="line">- (BOOL)commitTransaction;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">///************************ Put&amp;Get methods *****************************************</span><br><span class="line"></span><br><span class="line">- (BOOL)putObject:(id)object withId:(NSString *)objectId intoTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (id)getObjectById:(NSString *)objectId fromTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (BOOL)deleteObjectById:(NSString *)objectId fromTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="表">表</h1>
<p><code>KVDBStore</code>是在数据库层面实现的一个类，一个数据库通常是由多个表组成的，在实际开发中，表间的联结操作相对比较少，主要还是对特定表进行增删查改的操作。对此，项目实现了表级类<code>BaseTable</code>以便于进行操作，其包含以下属性：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface BaseTable ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *databaseName;</span><br><span class="line">@property (nonatomic, strong) NSString *tableName;</span><br><span class="line">@property (nonatomic, strong) KVDBStore *databaseStore; </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h1 id="存储架构">存储架构</h1>
<p>项目只实例化了一个数据库，所有的表均建立在该数据库中，并且所有的表都继承自<code>BaseTable</code>，而这些表则定义了与该表相关的数据库操作。以<code>AccountTable</code>为例，其应该定义类似以下的方法：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSString *)getAccount;</span><br><span class="line">- (void)setAccount:(NSString *)account;</span><br><span class="line"></span><br><span class="line">- (UserInfo *)userInfo;</span><br><span class="line">- (void)setUserInfo:(UserInfo *)userInfo;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在实际开发中，我们经常会面临同时从（向）一个表（或多个表）读取（写入）数据。对此，项目中实现了各种代理单例来完成这些操作，如：使用<code>AccountAgent</code>定义登录和退出的方法，其内部需要对<code>AccountTable</code>进行很多复杂的操作，。当然，在涉及到表间联结操作时，也应该通过代理来进行实现。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// AccountAgent</span><br><span class="line"></span><br><span class="line">- (void)login;</span><br><span class="line">- (void)logout;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>后续，希望能够阅读以下<code>FMDatabase</code>的源码，以对iOS底层的存储原理有进一步的理解。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本次博客升级</title>
    <url>/2023/09/16/about-blog-upgrade/</url>
    <content><![CDATA[<p>最近在写一篇文章 <a
href="http://chuquan.me/2023/09/13/myers-difference-algorithm/">《Myers
差分算法》</a>，发布之后发现 NexT
默认使用的公式渲染器的效果不太好，于是...搞了几晚，整体升级了 Hexo
系统和 NexT 主题。</p>
<span id="more"></span>
<p>升级后的博客支持了以下这些特性：</p>
<ul>
<li>黑暗模式：自动识别系统当前的模式，自动切换，并提供按钮支持手动切换。</li>
<li>公式渲染：使用 pandoc 渲染公式，支持独立和内嵌两种渲染方式。</li>
<li>评论系统：摒弃了原先的 LiveRe
评论系统（不稳定，经常加载不出来），使用了 Waline
评论系统，支持评论通知。</li>
<li>独立留言区：<a
href="https://vercel.chuquan.me">vercel.chuquan.me</a></li>
</ul>
<p>在升级过程中，我在 LiveRe
后台看到了博客里的很多评论，还是蛮开心的，承蒙大家的喜欢和支持
[手动抱拳]。之前评论系统非常不稳定，导致我一直都不太关注评论，因为我也经常加载不出来（除非挂代理）[手动狗头]。而且我也没有看过评论后台，加上评论系统也不支持评论通知，所以很多留言和问题都没有及时回复，感到十分抱歉。</p>
<p>为了能有更好的交流体验，这次我换了个评论系统，并将历史评论导入了进来，可惜的是历史评论时间无法修改。同时，我也支持了评论通知功能。如果有评论，我会立即收到微信通知；如果我回复了，你也会收到邮件。所以留言时，请正确填写你的邮箱。</p>
<p>后续，我会持续关注博客中的留言，并及时予以回复（毕竟支持了评论通知能力）。Waline
评论系统支持匿名评论和登录评论，如果后续会有回复，我强烈建议你点击登录按钮注册一个账号。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/comment-example.jpg?x-oss-process=image/resize,w_800" /></p>
<p>当然，除了在指定文章下面留言，这里还提供了一个独立的留言区 <a
href="https://vercel.chuquan.me/">vercel.chuquan.me</a>。如果你有一些与具体文章无关的想法，欢迎在这里留言，比如：关于文章主题的建议（因为有时候我也不知道要写什么主题的文章）、关于开源项目或自主创业的想法、关于人生的思考、关于职场的吐槽...</p>
<p>最后，再解答一个重复度比较高的问题：</p>
<p>Q：文章中的图是用什么画的？<br />
A：绝大部分的彩色配图都是使用 Sketch 画的，少部分类图使用 draw.io
画的。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Waline</tag>
        <tag>Vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 Actor 模型</title>
    <url>/2023/01/15/actor/</url>
    <content><![CDATA[<p>自分布式计算出现以来，业界已经开始广泛研究基于消息传递编程模型的解决方案。关于消息传递，Wikipedia
描述其广泛定义主要包括：<strong>远程过程调用（Remote Procedure Calls,
RPC）</strong> 和 <strong>消息传递接口（Message Passing Interface,
MPI）</strong>。但是，如今我们所谈到的消息传递，通常是指 <strong>actor
模型（Actor Model）</strong>。作为一种通用的消息传递编程模型，其起源于
20 世纪 70 年代，如今被广泛用于构建大规模可伸缩分布式系统。</p>
<span id="more"></span>
<p>作为入门，本文我们来简单聊一聊 actor 模型。</p>
<h1 id="actor-模型">Actor 模型</h1>
<p>一个 actor 定义为一个计算单元。所谓麻雀虽小，五脏俱全，每个 Actor
包含了存储、通信、计算等能力。在分布式系统中，通常包含了非常多的服务器集群，每一台服务器又包含了大量
actor 实例，它们共同构成了强大的并行计算能力。</p>
<p>Actor 的核心思想是
<strong>独立维护隔离状态，并基于消息传递实现异步通信</strong>。围绕其进行实现，actor
通常包含以下特征：</p>
<ul>
<li>每个 actor
持有一个邮箱（mailbox），本质上是一个队列，用于存储消息。</li>
<li>每个 actor 可以发送消息至任何 actor。</li>
<li>每个 actor 可以通过处理消息来更新内部状态，对于外部而言，actor
的状态是隔离的状态（isolated state）。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/actor-01.png?x-oss-process=image/resize,w_800" /></p>
<p>为了便于通信，actor 模型使用 <strong>异步</strong>
消息传递。消息传递不使用任何中间实体，如：通道（channel）。由于 actor
模型的消息是异步传递的，中间可能会经过很长时间，甚至丢失，因此无法保证消息到达目标
actor 时的顺序。每个 actor 都完全独立于任何其他实例，actor
之间的交互完全基于异步消息，因此能够在很大程度上避免共享内存的存在问题。</p>
<h1 id="任务调度">任务调度</h1>
<p>Actor 模型根据任务调度的方式可以分为两种，分别是：</p>
<ul>
<li><strong>基于线程（thread-based）的 actor 模型</strong></li>
<li><strong>事件驱动（event-driven）的 actor 模型</strong></li>
</ul>
<h2 id="基于线程的-actor-模型">基于线程的 actor 模型</h2>
<p>基于线程的 actor 模型，其本质是为每一个 actor
分配一个独立的“线程”。这里的“线程”并不是严格意义的操作系统线程，而是广泛意义的执行过程，它可以是线程、协程或虚拟机线程。</p>
<p>在基于线程的 actor 模型中，每个 actor 独占一个线程，如果当前 actor
的邮箱为空，actor 会阻塞当前线程，等待接收新的消息。在实现中，一般使用
<code>receive</code> 原语。</p>
<p>这种 actor
模型实现起来比较简单，但是缺点也非常明显，由于线程数量受到系统的限制，因此
actor 的数量也会受到限制。现阶段，只有少部分 actor
模型采用基于线程的实现方式，如：Erlang、Scala Actor、Cloud Haskell。</p>
<h3 id="erlang-actor">Erlang Actor</h3>
<p>Erlang 是第一种实现基于线程的 actor 模型的编程语言。Erlang
提供三种基本操作以实现 actor 模型，分别是：</p>
<ul>
<li><code>spawn</code>：创建一个进程（process）。在 Erlang
中，进程属于虚拟机，而非操作系统。</li>
<li><code>send</code>：发送消息至一个线程。</li>
<li><code>receive</code>：接收消息。</li>
</ul>
<p>如下所示，为一个基于 Erlang actor 的使用示例。 <figure class="highlight erl"><table><tr><td class="code"><pre><span class="line"><span class="comment">% area_server.erl</span></span><br><span class="line"><span class="keyword">-module</span><span class="params">(area_server)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">0</span>, area/<span class="number">2</span>, loop/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span> spawn(area_server, loop, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">area</span><span class="params">(Pid, What)</span> -&gt;</span></span><br><span class="line">    rpc(Pid, What).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span> </span><br><span class="line">    Pid ! &#123;self(), Request&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;Pid, Response&#125; -&gt;</span><br><span class="line">            Response</span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span> </span><br><span class="line">        &#123;From, &#123;rectangle, Width, Ht&#125;&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), Width * Ht&#125;,</span><br><span class="line">            loop();</span><br><span class="line">        &#123;From, &#123;circle, R&#125;&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), <span class="number">3.14159</span> * R * R&#125;,</span><br><span class="line">            loop();</span><br><span class="line">        &#123;From, Other&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), &#123;error, Other&#125;&#125;,</span><br><span class="line">            loop()</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure> 我们可以
Shell 环境下通过 <code>erl</code> 解释执行。当进入 Erlang REPL
环境后，我们可以执行如下代码进行测试。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1&gt; c(area_server).</span><br><span class="line">&#123;ok,area_server&#125;</span><br><span class="line"></span><br><span class="line">2&gt; Pid = area_server:start().</span><br><span class="line">&lt;0.94.0&gt;</span><br><span class="line"></span><br><span class="line">3&gt; area_server:area(Pid, &#123;rectangle, 10 * 8&#125;).</span><br><span class="line">&#123;error,&#123;rectangle,80&#125;&#125;</span><br><span class="line"></span><br><span class="line">4&gt; area_server:area(Pid, &#123;circle, 5&#125;).</span><br><span class="line">78.53975</span><br></pre></td></tr></table></figure></p>
<h3 id="scala-actor">Scala Actor</h3>
<p>Scala Actor 同样也实现了基于线程的 actor 模型，它将 Erlang
风格的轻量级消息传递并发性待到了
JVM，并将其集成到了重量级的线程/进程并发模型中。如下所示，为 Scala Actor
的使用示例，其实现语法也与 Erlang 非常相似。不过，从 Scala 2.11
开始，scala actors
不再作为标准库，示例中的代码我们需要进行一番改造才能运行。但是，从实现上来看，Scala
Actor 和 Erlang Actor 非常相似，均采用 <code>receive</code>
原语接收消息，阻塞线程。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pingpong.scala</span></span><br><span class="line"><span class="keyword">import</span> scala.actors.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> scala.actors.<span class="type">Actor</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Ping</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Pong</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Stop</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ping</span>(<span class="params">count: int, pong: <span class="type">Actor</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> pingsLeft = count - <span class="number">1</span></span><br><span class="line">    pong ! <span class="type">Ping</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      receive &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Pong</span> =&gt;</span><br><span class="line">          <span class="keyword">if</span> (pingsLeft % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="type">Console</span>.println(<span class="string">&quot;Ping: pong&quot;</span>)</span><br><span class="line">          <span class="keyword">if</span> (pingsLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pong ! <span class="type">Ping</span></span><br><span class="line">            pingsLeft -= <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Console</span>.println(<span class="string">&quot;Ping: stop&quot;</span>)</span><br><span class="line">            pong ! <span class="type">Stop</span></span><br><span class="line">            exit()</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pong</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> pongCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      receive &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Ping</span> =&gt;</span><br><span class="line">          <span class="keyword">if</span> (pongCount % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="type">Console</span>.println(<span class="string">&quot;Pong: ping &quot;</span>+pongCount)</span><br><span class="line">          sender ! <span class="type">Pong</span></span><br><span class="line">          pongCount = pongCount + <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Stop</span> =&gt;</span><br><span class="line">          <span class="type">Console</span>.println(<span class="string">&quot;Pong: stop&quot;</span>)</span><br><span class="line">          exit()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">pingpong</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> pong = <span class="keyword">new</span> <span class="type">Pong</span></span><br><span class="line">  <span class="keyword">val</span> ping = <span class="keyword">new</span> <span class="type">Ping</span>(<span class="number">100000</span>, pong)</span><br><span class="line">  ping.start</span><br><span class="line">  pong.start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件驱动的-actor-模型">事件驱动的 actor 模型</h2>
<p>在事件驱动的 actor 模型，actor
并不直接与线程耦合，只有在事件触发（即接收消息）时，才为 actor
的任务分配线程并执行。这种方式使用续体闭包（Continuation Closure）来封装
actor
及其状态。当事件处理完毕，即退出线程。通过这种方式，我们可以使用很少的线程来执行大量
actor 产生的任务。在实现中，一般使用 <code>react</code> 原语。</p>
<p>事件驱动的 actor
模型在消息触发时，会自动创建并分配线程。在这种过程中，一般的优化是将
actor
执行建立在底层的线程池之上，这些线程可以是线程、协程或虚拟机线程。从概念上讲，这种实现与
run loop、event loop 机制非常相似。</p>
<p>现阶段，大部分 actor 模型采用事件驱动的调度方式。</p>
<h3 id="dart-isolate">Dart Isolate</h3>
<p>Dart Isolate 本质上是一种事件驱动的 actor 模型，一个 Isolate 对应一个
Actor。一个 IsolateGroup 管理多个
Isolate，基于此可以实现结构化并发。Dart VM
底层实现了一个线程池，管理操作系统线程。当接收到一个消息时，会自动创建一个线程来执行对应的处理方法。</p>
<p>如下所示，是一个 Dart Isolate 的使用示例。<code>ReceivePort</code> 和
<code>SendPort</code> 本质上就是 Isolate
的地址，只不过从语义上进行区分，定义了接收者和发送者。<code>spawn</code>
方法创建一个新的 Isolate，续体闭包 <code>_readAndParseJson</code>
即新创建的 actor。执行完毕之后，通过 <code>SendPort</code>
将结果返回给主 Isolate。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> jsonData = <span class="keyword">await</span> _parseInBackground();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Number of JSON keys: <span class="subst">$&#123;jsonData.length&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&gt; _parseInBackground() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> p = ReceivePort();</span><br><span class="line">  <span class="keyword">await</span> Isolate.spawn(_readAndParseJson, p.sendPort);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> p.first <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; _readAndParseJson(SendPort p) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> fileData = <span class="keyword">await</span> File(filename).readAsString();</span><br><span class="line">  <span class="keyword">final</span> jsonData = jsonDecode(fileData);</span><br><span class="line">  Isolate.exit(p, jsonData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="groovy-actor">Groovy Actor</h3>
<p>Groovy 的 Gpars Actor 也是一种事件驱动的 actor 模型，并发的 actor
共享一个线程池，底层使用 fork/join 进行线程调度，其使用了
<code>react</code> 原语。</p>
<p>如下所示，为一个 Gpars Actor 的使用示例。 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> groovyx.gpars.actor.Actor</span><br><span class="line"><span class="keyword">import</span> groovyx.gpars.actor.Actors</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> doubler = Actors.reactor &#123;</span><br><span class="line">    <span class="number">2</span> * it</span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line">Actor actor = Actors.actor &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.10</span>).each &#123;doubler &lt;&lt; it&#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span></span><br><span class="line">    loop &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) stop()</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            react &#123;message -&gt;</span><br><span class="line">                println <span class="string">&quot;Double of $i = $message&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line">actor.join()</span><br><span class="line">doubler.stop()</span><br><span class="line">doubler.join()</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>Actor
模型是分布式/并发编程中常用的一种解决方案，其基本的设计结构非常简单，其核心思想是
“独立维护隔离状态，并基于消息传递实现异步通信”。</p>
<p>根据 actor 的底层调度方式，其又可以分为：基于线程的 actor
和事件驱动的
actor。两者在底层的线程使用方式上有所区别。目前，绝大多数编程语言采用的事件驱动的
actor
模型，其在资源分配方面更加合理，执行效率也更高；缺点在于底层实现复杂度高。</p>
<p>后续有机会我们来探索一下 actor 的实现源码，加强一下对于 actor
实现的整体认知。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Message_passing">Message
passing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Actor_model">Actor
model</a></li>
<li><a
href="http://dist-prog-book.com/chapter/3/message-passing.html#why-the-actor-model">Message
Passing and the Actor Model</a></li>
<li><a href="https://dart.cn/guides/language/concurrency">Dart
中的并发</a></li>
<li>《七周七并发模型》</li>
<li><a
href="https://berb.github.io/diploma-thesis/original/054_actors.html">Actor-based
Concurrency</a></li>
<li><a href="https://www.state-machine.com/doc/Bereznitsky2009.pdf">The
Actor Model Towards Better Concurrency</a></li>
<li><a
href="https://www.adit.io/posts/2013-05-15-Locks,-Actors,-And-STM-In-Pictures.html">Locks,
Actors, And Stm In Pictures</a></li>
<li><a
href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">并发模型与事件循环</a></li>
<li><a href="https://dzone.com/articles/erlangs-actor-model">Erlang's
actor model</a></li>
<li><a
href="https://www.cnblogs.com/jeffreyzhao/archive/2009/05/11/a-simple-actor-model-implementation.html">ActorLite:
一个轻量级Actor模型实现</a></li>
<li>《Erlang 程序设计》</li>
<li><a href="https://docs.scala-lang.org/overviews/core/actors.html">The
Scala Actors API</a></li>
<li><a href="https://www.scala-lang.org/old/node/242">Scala Actors: A
Short Tutorial</a></li>
<li><a href="https://doc.akka.io/docs/akka/current/actors.html">Classic
Actors</a></li>
<li><a
href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">Dart
asynchronous programming: Isolates and event loops</a></li>
<li><a href="https://mrale.ph/dartvm/">Introduction to Dart VM</a></li>
</ol>
]]></content>
      <categories>
        <category>异步与并发</category>
      </categories>
      <tags>
        <tag>actor</tag>
        <tag>事件驱动</tag>
        <tag>Isolate</tag>
      </tags>
  </entry>
  <entry>
    <title>Chisel高级参数化详解</title>
    <url>/2016/11/10/advanced-chisel/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>本文为Chisel高级参数库手册。关于Chisel更多通用信息请参考Getting
Started文档。<br />
随着硬件设计的复杂度的不断提高，模块化对于验证和复用都是非常重要的。Chisel的主要应用案例就是描述各种高度可配置的硬件生成器，我们很快意识到传统的参数化方式迫使设计的源代码非常脆弱，并且限制了组件的重用。</p>
<span id="more"></span>
<h1 id="高级参数化">高级参数化</h1>
<p>每个Chisel
Module有一个Parameters类的成员参数，其提供在模块之间传递参数的机制。<br />
本节描述以下这些特征:<br />
(1) <strong>Parameters</strong>类及其相关的方法/成员；<br />
(2) 基本使用模型；<br />
(3) 语法糖；<br />
(4) 向外部用户/程序暴露参数的模板代码； (5) <strong>Views(site, here,
up)</strong>的高级功能； ## 类和方法
<strong>Parameters</strong>有以下这些基本方法:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回类型T的一个值</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](key:<span class="type">Any</span>):<span class="type">T</span></span><br><span class="line">	<span class="comment">// 返回一个新的Parameters类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">alter</span></span>(mask:(<span class="type">Any</span>,<span class="type">View</span>,<span class="type">View</span>,<span class="type">View</span>)=&gt;<span class="type">Any</span>):<span class="type">Paramters</span></span><br><span class="line">	<span class="comment">// 返回一个模块的Parameters实例</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">params</span></span>:<span class="type">Parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>View</strong>是一个只包含一个基本方法的类:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回类型T的一个值</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](key:<span class="type">Any</span>):<span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Parameters</strong>有一个工厂对象，其包含一个基本的方法:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Parameters</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个空的Parameters实例</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>:<span class="type">Parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Module</strong>工厂对象有一个附加的<strong>apply</strong>方法:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回一个新的类型T的Module，如果_p!=None，则由一个Parameters实例初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>&lt;:<span class="type">Module</span>](<span class="type">C</span>: =&gt; <span class="type">T</span>)(<span class="keyword">implicit</span> _p: <span class="type">Option</span>[<span class="type">Parameters</span>] = <span class="type">None</span>):<span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本使用模型">基本使用模型</h2>
<p>这个例子示范了最简单的用法: (1)查询参数; (2) 改变Parameters对象; (3)
传递一个Parameters对象到一个Module。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params[<span class="type">Int</span>](&#x27;width&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Top</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> parameters = <span class="type">Parameters</span>.empty</span><br><span class="line">	<span class="keyword">val</span> tile_parameters = parameters.alter((key, site, here, up) =&gt; &#123;<span class="keyword">case</span> &#x27;width&#x27; =&gt; <span class="number">64</span>&#125;)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">		chiselMain(args,()=&gt;<span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Tile</span>)(<span class="type">Some</span>(tile_paramters)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<strong>Module
Tile</strong>中，<strong>params</strong>成员被查询，通过调用<strong>Parameters.apply</strong>传递key并返回value类型。<br />
在<strong>Top</strong>中，通过调用<strong>Parameters.empty</strong>创建了一个空的<strong>parameters</strong>；然后通过<strong>(Any,
View, View, View) =&gt;
Any</strong>函数修改参数值并返回一个新的<strong>Parameters</strong>实例，并赋值给<strong>tile_parameters</strong>。<br />
将<strong>tile_parameters</strong>包装在<strong>Some:Option[Parameters]</strong>之后，当其被传递给<strong>chiselMain</strong>时，它会被作为第二个参数传递给<strong>Module</strong>对象。</p>
<h2 id="语法糖-fieldt">语法糖: Field[T]</h2>
<p>一个简单的例子:
要求返回类型<strong>Int</strong>必须作为参数传给<strong>apply</strong>方法；否则Scala编译器会抛出错误:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params[<span class="type">Int</span>](&#x27;width&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示的代码示例为一种参数查询的方式，还有一种方式如下所示，可以为每个<strong>key</strong>创建一个<strong>case
object</strong>，该对象继承自<strong>Field[T]</strong>，并直接传递给<strong>params</strong>的<strong>apply</strong>方法。由于<strong>Field</strong>包含了返回类型信息，所以类型并不需要被传递:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Width</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>文档的剩下内容，假设每个查询的<strong>key</strong>都是一个继承自<strong>Field[T]</strong>的<strong>case</strong>类。</p>
<h2 id="语法糖-passing-altering">语法糖: Passing &amp; Altering</h2>
<p>当具有模块层级结构时，这些<strong>Parameters</strong>对象会在父模块和子模块之间传递。如果程序员指定，这些对象可以在实例化子对象之前被拷贝，修改。<br />
当发生修改时，Chisel会在内部拷贝存在的key/value映射链，并将提供的key/value映射添加到链的底部（译者注:
类似于JS中的原型链）。</p>
<p>当进行一次查询时，会首先查询链的底部key/value映射。如果没有匹配，则会查询链上的下一级key/value映射，以此类推。如果查询达到链的顶部还没有匹配，则Chisel会触发一个<strong>ParameterUndefinedExpection</strong>。<br />
当实例化一个子模块时，父模块可以以两种方式传递它的<strong>Parameters</strong>对象:<br />
1.
给<strong>Module</strong>工厂方法传递第二个参数，即包装在<strong>Option[Parameters]</strong>，显式地传递其<strong>Parameters</strong>对象至子模块:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)(<span class="type">Some</span>(params))</span><br><span class="line">	<span class="comment">// 显示地传递Tile的参数给Core</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>隐式地将其<strong>Parameters</strong>对象传递给子模块:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)</span><br><span class="line">	<span class="comment">// 隐式地传递Tile的参数给Core</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果父模块想要拷贝或修改子模块的字典，父模块有两种方法来完成:<br />
1.
向<strong>Module</strong>工厂方法提供一个偏函数映射作为一个参数。内部地，Chisel会拷贝父模块的<strong>Parameters</strong>对象并进行修改:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>, &#123;<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;)</span><br><span class="line">	<span class="comment">// 向Module工厂方法提供偏函数来改变Core的code&#123;Parameters&#125;对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>调用<strong>Parameters.alter</strong>方法，该方法会返回一个新的<strong>Parameters</strong>对象。这种方法让程序员可以访问新的<strong>Parameters</strong>对象，还能够使用<strong>site</strong>，<strong>here</strong>，<strong>up</strong>，请看<a
href="http://chuquan.me/2016/11/10/advanced-chisel/#2-6-使用site">2.6</a>，<a
href="http://chuquan.me/2016/11/10/advanced-chisel/#2-7-使用here">2.7</a>，<a
href="http://chuquan.me/2016/11/10/advanced-chisel/#2-8-使用up">2.8</a>:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> core_params = params.alter((pname, site, here, up) =&gt; pname <span class="keyword">match</span> &#123;<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;)</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)(<span class="type">Some</span>(core_params))</span><br><span class="line">	<span class="comment">// 使用Parameters.alter方法来返回一个修改过的Parameters对象。只有当需要site，here或up等机制时才使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
下图所示是一个更加复杂的修改链的示例:<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/key-value-chain.png" />
</div>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>, &#123; <span class="keyword">case</span> <span class="type">FPU</span> =&gt; <span class="literal">true</span>; <span class="keyword">case</span> <span class="type">QDepth</span> =&gt; <span class="number">20</span>; <span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">64</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span></span>&#123;</span><br><span class="line">	<span class="keyword">val</span> fpu = params(<span class="type">FPU</span>)</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>)</span><br><span class="line">	<span class="keyword">val</span> quete = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>, &#123;<span class="keyword">case</span> <span class="type">Depth</span> =&gt; depth*<span class="number">2</span>; <span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>)</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="keyword">case</span> <span class="type">Size</span> =&gt; depth * width&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> size = params(<span class="type">Size</span>)</span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="chiseconfig-boilerplate">ChiseConfig &amp; Boilerplate</h2>
<p>Chisel配置顶层参数的机制是通过一个<strong>ChiselConfig</strong>对象实现的。<strong>ChiselConfig.topDefinitions</strong>包含最高层的参数定义，如下所示:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Width</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123;(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123;<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">32</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，设计会调用<strong>chiselMain.apply</strong>来实例化一个设计。为了使用Chisel的参数化机制并正确地配置<strong>ChiselConfig</strong>，应该调用<strong>chiselMain.run</strong>，且设计不能用<strong>Module</strong>工厂方法包裹起来。这样的原因是为了针对已经存在的设计而保留的向后兼容性，未来我们会修复这个问题的。<br />
如下就是一个调用<strong>chiselMain.run</strong>的例子:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">		chiselMain.run(args, () =&gt; <span class="keyword">new</span> <span class="type">Tile</span>())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了用特定的<strong>ChiselConfig</strong>来实例化设计，可以简单地在调用Chisel编译器时使用<strong>--configInstance
project_name.configClass_name</strong>参数。</p>
<h2 id="使用site">使用site</h2>
<p>为了帮助设计者表达参数之间传递的关系，我们添加了<strong>site</strong>机制。为了理解它的功能，从概念上记住，一个被查询的Module的参数成员首先会查看其所在的key/value映射链的最底部的key/value映射。如果不匹配，查询会向上寻找。<br />
假设我们有一些如下形式的模块:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> data_width = params(<span class="type">Width</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> line_width = params(<span class="type">Width</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有两个相同的查询参数<strong>Width</strong>，但是对于这个例子，它们有不同的语义。在<strong>Core</strong>中，<strong>Width</strong>表示字长，而在<strong>Cache</strong>中，<strong>Width</strong>表示cache
line的宽度。我们希望能够简单地做一个参数查询响应机制。<br />
<strong>site</strong>机制允许链中间位置的key/value映射可以从链的底部开始进行查询。<br />
看下面的例子:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123;</span><br><span class="line">		(pname,size,here) =&gt; pname <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">With</span> =&gt; site(<span class="type">Location</span>) <span class="keyword">match</span>&#123;</span><br><span class="line">				<span class="keyword">case</span> &#x27;core&#x27; =&gt; <span class="number">64</span> <span class="comment">// data width</span></span><br><span class="line">				<span class="keyword">case</span> &#x27;cache&#x27; =&gt; <span class="number">128</span> <span class="comment">// cache line width</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>, &#123;<span class="keyword">case</span> <span class="type">Location</span> =&gt; &#x27;core&#x27;&#125;)</span><br><span class="line">	<span class="keyword">val</span> cache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>, &#123;<span class="keyword">case</span> <span class="type">Location</span> =&gt; &#x27;cache&#x27;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
如下图所示，顶层key/value映射使用<strong>site</strong>为<strong>Location</strong>查询链的底部。顶层的key/value映射产生不同的值，这依赖于<strong>Location</strong>返回的值("core"或"cache")。<br />

<div data-center="align">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/site.png" />
</div>
<h2 id="使用here">使用here</h2>
如下图所示，如果参数是同一级key/value映射链中其他参数的函数表达式，该参数并不想复制一个值，因为赋予一个新值需要多处变化。那么，它可以通过使用<strong>here</strong>机制来查询同一层级的key/value映射:<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/here.png" />
</div>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> cache_params = param.alter(</span><br><span class="line">		(pname, site, here, up) =&gt; pname <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">Sets</span> =&gt; <span class="number">128</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ways</span> =&gt; <span class="number">4</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Size</span> =&gt; here(<span class="type">Sets</span>)*here(<span class="type">Ways</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">val</span> cache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>)(cache_params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用up">使用up</h2>
<p><strong>up</strong>机制允许用户查询父级key/value映射。这等同于直接调用<strong>Parameters.apply</strong>，但可以在<strong>Parameters.alter</strong>中完成。具体请看<a
href="http://chuquan.me/2016/11/10/advanced-chisel/#3-6-重命名参数">3.6</a>节。</p>
<h1 id="示例">示例</h1>
<p>所有参数化方案都需要遵循以下三个准则: (1)
所有可查找到的参数暴露在顶层；<br />
(2) 评估不同节点时源代码绝对不能改变；<br />
(3) 添加新的参数时尽量不用改变源代码。<br />
本章在介绍完每个例子之后，我们会提出最简单的参数化方案以支持期望的设计空间，且不违反三个准则中的任意一个。随着例子的复杂性提高，最简单的设计方案也会随着改变，直到我们使用这里介绍的高级参数化方案。</p>
<h2 id="简单参数">简单参数</h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/simple-parameters.png" />
</div>
<p>在这个设计中，我们只改变core和cache的参数。最直接的参数化方案就是通过<strong>Tile</strong>构造函数参数来传递所有的参数。这些值然后会被传递给<strong>Core</strong>和<strong>Cache</strong>，通过它们各自的构造函数完成传递:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span>(<span class="params">val fpu:<span class="type">Boolean</span>, val ic_set:<span class="type">Int</span>, val ic_way:<span class="type">Int</span>, val dc_sets:<span class="type">Int</span>, val dc_ways:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>(fpu))</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(ic_sets, ic_ways))</span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(dc_sets, dc_ways))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> (<span class="params">val fpu:<span class="type">Boolean</span></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>(<span class="params">val sets:<span class="type">Int</span>, val ways:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>当探索我们的参数空间时，没有源代码被修改，并且所有的可查找参数暴露在顶层。此外，添加一个新的参数，由于这个例子简单，我们的代码只需要很少的改动。</p>
<h2 id="不相交参数集合">不相交参数集合</h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/disjoint-parameter-sets.png" />
</div>
<p>在下一个设计中，我们设计一个芯片，其可以实例化不同的core，每个core有自己的一组参数。如果我们使用简单的解决方案，<strong>Tile</strong>的构造函数的参数会非常多，因为它必须为所有可能的core包含所有的参数。<br />
有一个更好的办法就是把参数集合成一个配置对象。比如，我们可以把所有的<strong>BigCore</strong>参数集合到一个<strong>BigCoreConfig</strong>的<strong>case
class</strong>中，把所有的<strong>SmallCore</strong>的参数集合到一个<strong>SmallCoreConfig</strong>的<strong>case</strong>类中，它们都继承自<strong>CoreConfig</strong>。此外，我们让<strong>Cache</strong>和<strong>Tile</strong>在它们的构造函数中分别接受<strong>CacheConfig</strong>和<strong>TileConfig</strong>。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreConfig</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCoreConfig</span>(<span class="params">iq_depth:<span class="type">Int</span>, lsq_depth:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">CoreConfig</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallCoreConfig</span>(<span class="params">fpu:<span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">CoreConfig</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span>(<span class="params">sets:<span class="type">Int</span>, ways:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TileConfig</span>(<span class="params">cc:<span class="type">CoreConfig</span>, icc:<span class="type">CacheConfig</span>, dcc:<span class="type">CacheConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TIle</span> (<span class="params">val tc:<span class="type">TileConfig</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = tc.cc <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> bcc:<span class="type">BigCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BigCore</span>(tc.bcc))</span><br><span class="line">		<span class="keyword">case</span> scc:<span class="type">SmallCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">SmallCore</span>(tc.scc))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.icc))</span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.dcc))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="位置无关参数">位置无关参数</h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/location-independent-parameters.png" />
</div>
<p>嵌套配置对象是非常脆弱的，这是因为嵌入配置对象的结构与模块的层次结构强相关。给定一个如上图所示的设计，我们假设其中包含<strong>BigCore</strong>的IQ和LSQ，以及<strong>icache</strong>和<strong>dcache</strong>，实例化一个<strong>Memory</strong>模块。<strong>Memory</strong>模块包含一个<strong>width</strong>参数，为了能让设计符合正确的预期功能，所有的<strong>Memory</strong>宽度必须设为同样的值。为了确保这个要求，代码可能会这样写:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MemConfig</span>(<span class="params">size:<span class="type">Int</span>, banks:<span class="type">Int</span>, width:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span>(<span class="params">sets:<span class="type">Int</span>, ways:<span class="type">Int</span>, mc:<span class="type">MemConfig</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConfig</span>(<span class="params">depth:<span class="type">Int</span>, mc:<span class="type">MemConfig</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCoreConfig</span>(<span class="params">iqc:<span class="type">QueeuConfig</span>, lsqc:<span class="type">QueueConfig</span>, mc:<span class="type">MemConfig</span></span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TileConfig</span>(<span class="params">cc:<span class="type">CoreConfig</span>, icc:<span class="type">CacheConfig</span>, dcc:<span class="type">CacheConfig</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span>(<span class="params">val tc:<span class="type">TileConfig</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = tc.cc <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> bcc:<span class="type">BigCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">BigCore</span>(tc.bcc))</span><br><span class="line">		<span class="keyword">case</span> scc:<span class="type">SmallCoreConfig</span> =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">SmallCore</span>(tc.scc))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.icc))</span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>(tc.dcc))</span><br><span class="line">	require(tc.dcc.mc.width == td.icc.mc.width)</span><br><span class="line">	require(tc.bcc.iqc.mc.width == tc.bcc.lsqc.mc.width)</span><br><span class="line">	require(tc.dcc.mc.width == tc.bcc.lsqc.mc.width)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这一系列的<strong>require</strong>声明是非常脆弱的，因为我们设计的层次结构发生任何变化都需要大量重写这些声明。忽略这些<strong>require</strong>声明并不是可行的方法；这些声明对于强制基础设计要求是非常重要的。<br />
配置对象的这个缺点引领我们向用户参数化方案靠近，即<strong>Parameters</strong>类型字典的拷贝/修改。我们使用这种key-value结构来存储模块的参数。<br />
为了参数化上图的设计，我们隐式地传递<strong>Parameters</strong>对象，如果需要修改，则向<strong>Module</strong>工厂方法提供偏函数。回顾前面的<strong>ChiselConfig</strong>那一节，<strong>MyConfig</strong>类(继承自<strong>ChiselConfig</strong>)必须被传递给Chisel编译器，通过<strong>--configInstance</strong>选项来配置顶层参数:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123;</span><br><span class="line">		(pname, site, here) =&gt; pname <span class="keyword">match</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="type">IQ_depth</span> =&gt; <span class="number">10</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">LSQ_depth</span> =&gt; <span class="number">10</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ic_sets</span> =&gt; <span class="number">128</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ic_ways</span> =&gt; <span class="number">2</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Dc_sets</span> =&gt; <span class="number">512</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Dc_ways</span> =&gt; <span class="number">4</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">64</span></span><br><span class="line">			<span class="comment">// 因为任何模块查询Width都会返回64，所以它的名字不应该对模块是唯一的</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>)(params)</span><br><span class="line">	<span class="keyword">val</span> ic_sets = params(<span class="type">Ic_sets</span>)</span><br><span class="line">	<span class="keyword">val</span> ic_ways = params(<span class="type">Ic_ways</span>)</span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>, &#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; ic_sets; <span class="keyword">case</span> <span class="type">Ways</span> =&gt; ic_ways&#125;)</span><br><span class="line">	<span class="comment">// we can rename Ic_sets to Sets, effectively isolating Cache’s query keys from any design hierarchy dependence </span></span><br><span class="line">	<span class="keyword">val</span> dc_sets = params(<span class="type">Dc_sets</span>) </span><br><span class="line">	<span class="keyword">val</span> dc_ways = params(<span class="type">Dc_ways</span>) </span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>, &#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; dc_sets; <span class="keyword">case</span> <span class="type">Ways</span> =&gt; dc_ways&#125;) </span><br><span class="line">	<span class="comment">// similarly we rename Dc_sets to Sets and Dc_ways to Ways</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> iqdepth = params(<span class="type">IQ_depth</span>) </span><br><span class="line">	<span class="keyword">val</span> iq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>, &#123;<span class="keyword">case</span> <span class="type">Depth</span> =&gt; iqdepth&#125;) </span><br><span class="line">	<span class="keyword">val</span> lsqdepth = params(<span class="type">LSQ_depth</span>) </span><br><span class="line">	<span class="keyword">val</span> lsq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Queue</span>, &#123;<span class="keyword">case</span> <span class="type">Depth</span> =&gt; lsqdepth&#125;) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>,&#123;<span class="keyword">case</span> <span class="type">Size</span> =&gt; depth&#125;) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> sets = params(<span class="type">Sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ways = params(<span class="type">Ways</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>,&#123;<span class="keyword">case</span> <span class="type">Size</span> =&gt; sets*ways&#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> size = params(<span class="type">Size</span>) </span><br><span class="line">	<span class="keyword">val</span> width = params(<span class="type">Width</span>) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管这种参数化方法相当冗长，但是它在添加参数时能表现出较好的扩展性，也不需要改变源代码，并允许单个参数，如<strong>Width</strong>改变所有的叶子模块。</p>
<h2 id="特定位置参数">特定位置参数</h2>
我们在前一节看到拷贝并修改一个<strong>Parameters</strong>对象会非常冗长。如果我们想要添加一个<strong>ECC</strong>参数到我们的<strong>Memory</strong>模块，而这个参数取决于<strong>Memory</strong>实例化的位置，这时候我们需要修改多个父模块的中的代码来重命名每个参数(如:
ECC_icache =&gt; ECC)<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/location-specific-parameters.png" />
</div>
<p>如上图所示，我们采用<strong>Parameters</strong>对象的<strong>site</strong>功能来获取特定位置信息，从而定制我们想要返回给特定位置值的值。在添加了特定位置信息之后，我们彻底减少了必须要改动的代码的数量:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Depth</span> =&gt; site(<span class="type">Queue_type</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="keyword">case</span> &#x27;iq&#x27; =&gt; <span class="number">20</span> </span><br><span class="line">				<span class="keyword">case</span> &#x27;lsq&#x27; =&gt; <span class="number">10</span> </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Sets</span> =&gt; site(<span class="type">Cache_type</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="keyword">case</span> &#x27;i&#x27; =&gt; <span class="number">128</span></span><br><span class="line">				<span class="keyword">case</span> &#x27;d&#x27; =&gt; <span class="number">512</span></span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Ways</span> =&gt; site(<span class="type">Cache_type</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				<span class="keyword">case</span> &#x27;i&#x27; =&gt; <span class="number">2</span> </span><br><span class="line">				<span class="keyword">case</span> &#x27;d&#x27; =&gt; <span class="number">4</span> </span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="number">64</span> </span><br><span class="line">			<span class="comment">// since any module querying Width should return 64, the name should NOT be unique to modules </span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">ECC</span> =&gt; site(<span class="type">Location</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">				&#x27;incore&#x27; =&gt; <span class="literal">false</span> </span><br><span class="line">				&#x27;incache&#x27; =&gt; <span class="literal">true</span> </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> (<span class="params">val params:<span class="type">Parameters</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> core = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Core</span>,&#123;<span class="type">Location</span> =&gt; ’incore’&#125;) </span><br><span class="line">	<span class="comment">// we can give core and its child modules a location identifier</span></span><br><span class="line">	<span class="keyword">val</span> cacheparams = params.alter(&#123;<span class="type">Location</span> =&gt; ’incache’&#125;) </span><br><span class="line">	<span class="comment">// we can give both caches and all their child modules a location identifier </span></span><br><span class="line">	<span class="keyword">val</span> icache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">ICache</span>)(cacheparams) </span><br><span class="line">	<span class="keyword">val</span> dcache = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">DCache</span>)(cacheparams)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> iq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">IQ</span>) </span><br><span class="line">	<span class="keyword">val</span> lsq = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">LSQ</span>) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IQ</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="type">Size</span> = depth&#125;) </span><br><span class="line">	<span class="comment">// in some cases, using copy/alter is preferred instead of \code&#123;site&#125; (see Design Heuristics for more details) </span></span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LSQ</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> depth = params(<span class="type">Depth</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="type">Size</span> = depth&#125;) </span><br><span class="line">	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ICache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> sets = params(<span class="type">Sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ways = params(<span class="type">Ways</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>,&#123;<span class="type">Size</span> =&gt; sets*ways&#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DCache</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> sets = params(<span class="type">Sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ways = params(<span class="type">Ways</span>) </span><br><span class="line">	<span class="keyword">val</span> mem = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Memory</span>, &#123;<span class="type">Size</span> =&gt; sets*ways&#125;) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> size = params(<span class="type">Size</span>) </span><br><span class="line">	<span class="keyword">val</span> ecc = params(<span class="type">ECC</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="派生参数">派生参数</h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/derivative-parameter.png" />
</div>
<p>如上图所示，我们总是希望我们的ROB可以是物理寄存器数量和体系结构寄存器数量差异的大小的4/3。如果我们在<strong>MyConfig.top</strong>中写明，可能就是这样的:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NUM_arch_reg</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>] </span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NUM_phy_reg</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>] </span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ROB_size</span> <span class="keyword">extends</span> <span class="title">Field</span>[<span class="type">Int</span>] </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_arch_reg</span> =&gt; <span class="number">32</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_phy_reg</span> =&gt; <span class="number">64</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">ROB_size</span> =&gt; <span class="number">4</span>*(<span class="number">64</span><span class="number">-32</span>)/<span class="number">3</span> </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，如果我们之后增加了物理寄存器的数量，我们需要记得更新在ROB尺寸中的派生值。为了避免这种潜在的出错，可以使用<strong>here</strong>功能来查询同级的参数:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultConfig</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> top:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_arch_reg</span> =&gt; <span class="number">32</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NUM_phy_reg</span> =&gt; <span class="number">64</span> </span><br><span class="line">			<span class="keyword">case</span> <span class="type">ROB_size</span> =&gt; <span class="number">4</span>*(here(<span class="type">NUM_phy_reg</span>) </span><br><span class="line">			here(<span class="type">NUM_arch_reg</span>))/<span class="number">3</span> </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重命名参数">重命名参数</h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/renaming-parameter.png" />
</div>
<p>上图所示，两个cache模块查询一个<strong>sets</strong>参数。然而，<strong>Tile</strong>有<strong>ic_sets</strong>和<strong>dc_sets</strong>参数。为了重命名这些参数，我们可以读取父模块的值并修改子模块中的<strong>Parameters</strong>对象:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ic_sets = params(<span class="type">Ic_sets</span>) </span><br><span class="line">	<span class="keyword">val</span> ic = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>,&#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; ic_sets&#125;)</span><br><span class="line">	<span class="keyword">val</span> dc_sets = params(<span class="type">Ic_sets</span>) </span><br><span class="line">	<span class="keyword">val</span> dc = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>,&#123;<span class="keyword">case</span> <span class="type">Sets</span> =&gt; dc_sets&#125;) </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一种方法就是，我们可以在<strong>Parameters.alter</strong>方法中使用<strong>up</strong>机制来查询父模块的<strong>Parameters</strong>对象:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ic_params = params.alter( </span><br><span class="line">		(pname,site,here,up) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Sets</span> =&gt; up(<span class="type">Ic_sets</span>) </span><br><span class="line">		&#125; </span><br><span class="line">	) </span><br><span class="line">	<span class="keyword">val</span> ic = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Cache</span>)(ic_params)</span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常一般不使用<strong>up</strong>机制，因为它会变得更加冗余。但是，如果父模块对子模块的<strong>Parameters</strong>对象做了非常大的改动时，<strong>up</strong>机制会非常有用，因为所有的改变会包含在<strong>Parameters.alter</strong>方法中，这个方法可以访问所有三种机制(<strong>up</strong>,
<strong>site</strong>, <strong>here</strong>).</p>
<h1 id="外部接口">外部接口</h1>
<p>到目前为止，本文只描述了一些在顶层类(<strong>ChiselConfig</strong>)操作参数的机制。但是，为了能够实际生成多个C++或Verilog设计，我们需要手动改变这些参数。<br />
我们还要明确设计的约束(参数范围，依赖，约束)以及把一个特定设计的实际实例从有效设计空间表达中分离出来。<br />
带着这些动机，Chisel具一个额外的特征，其基于一个叫做<strong>Knobs</strong>的概念或者用于探索设计空间的特定参数。这一节将会介绍<strong>Knobs</strong>以及其使用方法，<strong>Dump</strong>对象，参数和<strong>Knob</strong>的约束添加，以及运行Chisel编译器的两种模式:
<strong>-configCollect</strong>和<strong>-configInstance</strong>.</p>
<h2 id="knobs">Knobs</h2>
<p>生成器会有一些参数是固定的，其他的则指示了生成的特定设计节点。这些生成器级的参数，称之为<strong>Knobs</strong>，其具有一个额外的key-value映射以允许外部程序和用户来轻易地重写它们的值。<br />
<strong>Knobs</strong>只能在<strong>ChiselConfig</strong>的子类<strong>TopDefinitions</strong>中被实例化:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Knob</span>(&#x27;<span class="type">NTILES</span>&#x27;) </span><br><span class="line">			<span class="keyword">case</span> .... =&gt; .... </span><br><span class="line">			<span class="comment">// other non-generator parameters go here </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="type">NTILES</span>&#x27; =&gt; <span class="number">1</span> <span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当查询<strong>NTiles</strong>在<strong>topDefinitions</strong>中匹配时，<strong>Knob('NTLES')</strong>会被返回。内部地，Chisel会在<strong>MyConfig.knobValues</strong>中查找并返回1。2.5节所示，执行生成器时需要指定特定的config:<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sbt run ... --configInstance example.MyConfig</span><br></pre></td></tr></table></figure></p>
<p>假设我们想要实例化一个新的设计，该设计有两个tile:
可以简单地使用Scala的类继承并重写<strong>knobValues</strong>的值:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig2</span> <span class="keyword">extends</span> <span class="title">MyConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> &#x27;<span class="type">NTILES</span>&#x27; =&gt; <span class="number">2</span> </span><br><span class="line">		<span class="comment">// will generate new design with 2 tiles </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，两个类都可以存在于源代码中，因此两个设计都可以通过命令行被实例化。对于有两个tile的新设计:<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sbt run --configInstance exmaple.MyConfig2</span><br></pre></td></tr></table></figure></p>
<h2 id="dump">Dump</h2>
<p>顺着Chisel而下，其他的工具可能需要知道特定的参数/Knob赋值。如果需要，只要将Knob/value传给<strong>Dump</strong>对象，该对象会把name和value写入一个文件，然后返回Knob/value:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">Width</span> =&gt; <span class="type">Dump</span>(&#x27;<span class="type">Width</span>&#x27;,<span class="number">64</span>) </span><br><span class="line">			<span class="comment">// will return 64. Requires naming the parameter as the 1st argument </span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Dump</span>(<span class="type">Knob</span>(&#x27;<span class="type">NTILES</span>&#x27;)) </span><br><span class="line">			<span class="comment">// will return Knob(&#x27;NTILES&#x27;), no name needed </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> &#x27;<span class="type">NTILES</span>&#x27; =&gt; <span class="number">1</span> </span><br><span class="line">		<span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个废弃的参数的name和value会被重写到一个*.knb文件，文件在<strong>--targetDir
path</strong>指定的目录中。</p>
<h2 id="约束">约束</h2>
<p>现在外部程序/用户可以很容易地重写一个配置的<strong>knobValue</strong>方法，我们提供了一种机制可以定义合法的<strong>Knobs</strong>范围。在<strong>ChiselConfig</strong>中，可以重写另一个称为<strong>topConstraint</strong>的方法:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Knob</span>(’<span class="type">NTILES</span>’) </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> topConstraints:<span class="type">List</span>[<span class="type">ViewSym</span>=&gt;<span class="type">Ex</span>[<span class="type">Boolean</span>]] </span><br><span class="line">		= <span class="type">List</span>( &#123; ex =&gt; ex(<span class="type">NTiles</span>) &gt; <span class="number">0</span> &#125;, </span><br><span class="line">				&#123; ex =&gt; ex(<span class="type">NTiles</span>) &lt;= <span class="number">4</span> &#125;) </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> &#x27;<span class="type">NTILES</span>&#x27; =&gt; <span class="number">1</span> <span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，如果有人想要用以下的配置和命令实例化我们的设计，会无法通过:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BadConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> &#x27;<span class="type">NTILES</span>&#x27; =&gt; <span class="number">5</span> </span><br><span class="line">		<span class="comment">// would violate our constraint, throws an error </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// throws <span class="string">&#x27;Constriant failed&#x27;</span> error </span><br><span class="line">sbt run ... --configInstance example.BadConfig</span><br></pre></td></tr></table></figure></p>
<p>约束可以在设计中的任何位置声明，并不只是在顶层，通过调用<strong>Parameters</strong>的<strong>constant</strong>方法:<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">extends</span> <span class="title">ChiselConfig</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> topDefinitions:<span class="type">World</span>.<span class="type">TopDefs</span> = &#123; </span><br><span class="line">		(pname,site,here) =&gt; pname <span class="keyword">match</span> &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="type">NTiles</span> =&gt; <span class="type">Knob</span>(&#x27;<span class="type">NTILES</span>&#x27;) </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">override</span> <span class="keyword">val</span> knobValues:<span class="type">Any</span>=&gt;<span class="type">Any</span> = &#123; </span><br><span class="line">		<span class="keyword">case</span> &#x27;<span class="type">NTILES</span>&#x27; =&gt; <span class="number">1</span> </span><br><span class="line">		<span class="comment">// generator parameter assignment </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tile</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	params.constrain( ex =&gt; ex(<span class="type">NTiles</span>) &gt; <span class="number">0</span> ) </span><br><span class="line">	params.constrain( ex =&gt; ex(<span class="type">NTiles</span>) &lt;= <span class="number">4</span> ) </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Run</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">		chiselMain.run(args, () =&gt; <span class="keyword">new</span> <span class="type">Tile</span>())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sbt runMain example.Run ... --configInstance example.MyConfig</span><br></pre></td></tr></table></figure>
<p>最后，如果设计者想要知道设计约束，他们可以执行Chisel，用<strong>--configCollect
project_name.config_name</strong>选项，这会把一系列约束打印到一个*.cst文件中，该文件的位置由<strong>--targetDir
path</strong>指定:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sbt runMain example.Run ... --configCollect example.MyConfig --targetDir &lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>（完）</p>
<h1 id="参考">参考</h1>
<p>[1] Bachrach,J.,Vo,H.,Richards,B.,Lee,Y.,Waterman, A., Avižienis,
Wawrzynek, J., Asanovic´ Chisel: Constructing Hardware in a Scala
Embedded Language in DAC ’12.<br />
[2] Odersky, M., Spoon, L., Venners, B. Programming in Scala by
Artima.<br />
[3] Payne, A., Wampler, D. Programming Scala by O’Reilly books.</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title>澳洲自驾游</title>
    <url>/2019/07/11/australia-from-sydeny-to-brisbane/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight216.jpg?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>今年的年度旅游，我们部门分成了多个团体自行安排旅游。我们 8
个人（<span class="citation" data-cites="邱老师">@邱老师</span>、<span
class="citation" data-cites="海侠">@海侠</span>、<span class="citation"
data-cites="捧鹏">@捧鹏</span>、<span class="citation"
data-cites="拢龙">@拢龙</span>、<span class="citation"
data-cites="佳欣">@佳欣</span>、<span class="citation"
data-cites="底迪">@底迪</span>、<span class="citation"
data-cites="雪洁">@雪洁</span>、<span class="citation"
data-cites="我">@我</span>）组成了一个澳洲团（自诩：卢瑟天团），来了一次自驾游：从悉尼到布里斯班。</p>
<p>这次行程基本都是 <span class="citation"
data-cites="佳欣">@佳欣</span>
安排，我差不多全程属于放空状态，有时甚至连自己在哪里都不知道。8
人自驾游租了两辆 SUV，司机分别是 <span class="citation"
data-cites="邱老师">@邱老师</span>、<span class="citation"
data-cites="捧鹏">@捧鹏</span>。</p>
<p>出游前，我就计划这次旅行尝试一下做旅拍。为此，我刷了一些 YouTube
上的大神们的作品，如：KOLD。大神们的作品对我这种菜鸟新手来说难度太高，实际操作起来非常困难。于是我又刷了一些入门级拍摄技巧的视频教程，如：HeyDrones。为此，我还租了GoPro
7 Hero Black 运动相机和 Mavic Air 无人机。</p>
<p>关于 GoPro 和无人机的使用体验。我全程基本都是在用 GoPro
进行视频拍摄，性价比特别高。无人机使用相对就少了很多，首先续航时间短，只有20分钟，实际电池电量剩
20%
时就提示自动返航了。另外，再加上天气、限飞、周围环境等因素，体验并不是很好。不过，无人机拍出来的效果的确逼格提升了不少。所以，还是逃不出“真香”定理，不出意外，以后旅游我还会带上无人机。</p>
<h1 id="day-1">Day 1</h1>
<p>From 北京 to 深圳，From 深圳 to 悉尼。</p>
<p>在北京飞深圳的航班上，看到一团云挺好看，顺手拍了张照片。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight191.jpg?x-oss-process=image/resize,w_600" /></p>
<p>深圳机场的晚霞还是挺好看的。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight194.jpg?x-oss-process=image/resize,w_600" /></p>
<p>从深圳起飞，拍了张深圳上空照片（很难得的角度）。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight193.jpg?x-oss-process=image/resize,w_400" /></p>
<h1 id="day-2">Day 2</h1>
<p>飞机上一觉醒来便是凌晨，转头便看到了日月同辉前的一幕美景。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight197.jpg?x-oss-process=image/resize,w_600" /></p>
<p>抵达悉尼机场，第一个任务便是租车。然后便是前往悉尼歌剧院。可能是大家很疲惫吧，只是在歌剧院脚下拍了些照片，没有人提出去对岸拍它的全景。
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight199.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight200.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_3898.JPG?x-oss-process=image/resize,w_600" /></p>
<p>然后就是逛了下歌剧院旁边的皇家植物园。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight202.jpg?x-oss-process=image/resize,w_600" /></p>
<p>汉堡王之后，就驱车两小时去山里找我们的爱彼迎民宿。刚进入别墅时，我们所有人都是刘姥姥进大观园的状态。别墅建在山坡上，一种后战争（Post
War）风格的建筑，自带车库，露天大阳台（配有烧烤架），二层有小花园，三层有大花园。<span
class="citation" data-cites="地址">@地址</span>：22 Bildera Place, Grays
Point, 新南威尔士州 2232。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight207.jpg?x-oss-process=image/resize,w_600" />
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight206.jpg?x-oss-process=image/resize,w_600" />
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight209.jpg?x-oss-process=image/resize,w_600" /></p>
<p>旅行的开始总是兴奋的。是晚，便来了一次自制火锅。晚餐过后便是拍照时间，山寨了一次“我爱我家”的经典场景。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_4305.JPG?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-3">Day 3</h1>
<p>前一晚，玩桌游差不多到凌晨
2：00。这一天是预料中的晚起，下午出门去悉尼大学。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight219.jpg?x-oss-process=image/resize,w_600" />
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight217.jpg?x-oss-process=image/resize,w_600" />
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight214.jpg?x-oss-process=image/resize,w_600" /></p>
<p>差不多逛到一般吧，<span class="citation"
data-cites="拢龙">@拢龙</span>
便叫我去打球。商场的车库后面，有一个街头篮球场。和当地人来了次比赛，5 VS
6，对方 3 男 3
女。比赛以一个女生膝盖受伤而告终。不过不得不感慨，澳洲人的身体素质是真好，这个场地就有两人能扣篮...</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_3951.JPG?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-4">Day 4</h1>
<p>这天开始挪地方，先是驱车去了猎人谷参观了当地历史最悠久的酒庄 Audery
Wikinson。可惜季节不是很好，并没有看到满山的葡萄，不过惊喜的是，遇到了野生的袋鼠。</p>
<p>参观结束便是驱车前往预订的一个位于富人社区的爱彼迎民宿，自带泳池的那种。<span
class="citation" data-cites="地址">@地址</span>：68 O'Shea
Circuit，赛斯诺克，新南威尔士州 2325。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/FullSizeRender.jpg?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-5">Day 5</h1>
<p>按计划前往斯蒂芬斯港转了一圈。当晚入住一个平民民宿。<span
class="citation" data-cites="地址">@地址</span>：1315 Lemon Tree Passage
Road，Lemon。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight243.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight220.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight226.jpg?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-6">Day 6</h1>
<p>自驾 5
小时，抵达汽车旅馆。旅馆也有泳池，可惜天气太冷，有没尝试。<span
class="citation" data-cites="地址">@地址</span>：阿曲亚吉汽车旅馆 49
Park Beach Road，科夫斯港，2450。</p>
<p>Check In 之后，我和 <span class="citation"
data-cites="拢龙">@拢龙</span>
便按计划去找篮球场打球。可惜当地的篮球馆很早就关门了。我们好不容易找到一个室外场，装了下逼，拍了些照。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight224.jpg?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-7">Day 7</h1>
<p>驱车三小时去拜伦湾，原本打算跳伞，然而下雨了...于是乎前往下一个目的地——拜伦角灯塔。这天是阴雨天，灯塔附近的风浪非常大，我们摆拍了一些照片后就离开了。</p>
<p>在拜伦湾小镇吃了个午饭后，我们就去酒店办理入住。<span
class="citation" data-cites="地址">@地址</span>：发现假日酒店 399
Ewingsdale Road，拜伦湾，2481。</p>
<p>这个公园酒店很大，就如其名字一样，是一个大公园，内部有很多房车式的独栋小房子，就是游客的住所。</p>
<p>行李整顿完毕之后，闲逛了下公园，遇到一群小孩，拍了短视频。</p>
<div align=center>
<video src='https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Videoleap-216A7632-23B2-4CF2-A02C-8B5E675A75B1.MOV' type='video/mov' controls='controls'  width='60%' height='60%'>
</div>
<p>之后，我们又是去找篮球馆。我们找到一个高级篮球馆。这个篮球馆每周工作日晚上都会举行比赛，周六下午才对外开放。据我们了解，拜伦湾当地有十二支业余球队，每支球队都由少年、青年、老年不同年龄段的人组成。篮球水平在业余中属于比较高的水平，有不少能扣篮的人。至此，我们算是了解到了澳洲民间篮球的真实水平了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight233.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight234.jpg?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-8">Day 8</h1>
<p>前往布里斯班，中途经过黄金海岸。季节不适，风浪很大，稍作逗留便离开了。</p>
<p>然后前往市中心，入住了当地一家酒店。<span class="citation"
data-cites="地址">@地址</span>：Hotel Grand Chancellor</p>
<p>当天晚上就是代购，各种买买买。</p>
<h1 id="day-9">Day 9</h1>
<p>驱车去龙伯考拉动物园，看了些动物表演，包括：飞禽、牧羊犬。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight231.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight232.jpg?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight230.jpg?x-oss-process=image/resize,w_800" /></p>
<h1 id="day-10">Day 10</h1>
<p>From 布里斯班 to 广州，From 广州 to 北京。</p>
<div align=center>
<video src='https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Videoleap-3169FC88-2225-42CC-B360-4EC21496D948.MOV' type='video/mov' controls='controls'  width='60%' height='60%'>
</div>
<p>(完)</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>澳大利亚</tag>
        <tag>悉尼</tag>
        <tag>布里斯班</tag>
        <tag>自驾游</tag>
      </tags>
  </entry>
  <entry>
    <title>《兄弟连》观影有感</title>
    <url>/2017/01/15/band-of-brothers/</url>
    <content><![CDATA[<p>电影《血战钢锯岭》的上映获得了极大的反响，战争题材的电影时隔多年又重新焕发光彩。我本人也对这类电影颇感兴趣，可能是我内心的确很想了解数十年前人类历史上最惨烈的两场大规模战争的真实面目。</p>
<span id="more"></span>
<p>然而，国产抗战剧没有多少部让我能够真正予以赞许。国产抗战剧永远都是对战争胜利一方歌功颂德，将己方士兵都描绘成类似于董成瑞、邱少云一样的置之生死于度外的英雄式人物，将对方士兵极致丑化。当然，我深信那段时期我们有着大量敢于英勇就义的战士，也不否认敌方士兵的穷凶极恶。但我想说的是，我们的抗战剧总是缺少类似纪录片一样的客观、公正的态度，无法真实地呈现出战争的惨烈，参战士兵、人民的真实感受。战争片的意义是在于让观影者能够身临其境地感受这一切，进而能够珍惜、维护这来之不易的和平。</p>
<p>很庆幸，《太平洋战争》、《兄弟连》等作品都是以最底层、最前线的士兵的经历和回忆来还原这一切，所以在《兄弟连》中甚至从未出现过高级军官的指点江山的场景。</p>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers01.png" />
</div>
<p>《兄弟连》是根据美国101陆军空降师部队E连的真实事迹改编，描述的是第二次世界大战的尾声，也是战况最为惨烈的时节。1944年6月6日，美国101空降师506团E连奉命空降登陆诺曼底，此后一年多经历了高密集度的战斗，从法国的卡朗唐镇到荷兰的埃因霍温，再到比利时的巴斯托尼，德国的海格纳镇，到最后的纳粹德军最高首领的大本营贝希特斯加登，所到之处皆留下了E连兄弟们的身影和鲜血。</p>
<p>这里我不想具体述说影片的内容，只想回顾那几幕令我为之动容的场景。</p>
<h1 id="第一幕">第一幕</h1>
温特斯中尉率领士兵在荷兰的堤防上展开了一次危险任务，结果获得了空前的胜利，他也因此被晋升为步兵营的执行官。然而，在这次任务中，温特斯在带头侧翼攻击时，他一个人冲到了堤坝上，结果一个俯身在草丛中的德军士兵发现了他，而那个德军士兵只是个少年，温特斯举枪对准他的那一刻，他的表情经历了惊讶到恐惧的。然而，为了完成战斗任务，温特斯还是果断开了枪。而此后，这一场景成为了温特斯脑海中挥之不去的一幕。也是他至此之后再也没开过枪的原因。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers03.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers07.png" />
</div>
<h1 id="第二幕">第二幕</h1>
而在新一轮轰炸中，乔治·鲁兹未来得及回到散兵坑，他在炮火中疯狂地向散兵坑爬去，散兵坑里穆克和潘卡拉也是大喊着快点，然而即将爬进坑时，一枚炮弹掉入了他眼前的这个散兵坑。那一瞬间，鲁兹整个人都懵了。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers11.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers12.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers13.png" />
</div>
<h1 id="第三幕">第三幕</h1>
鲁兹清醒后又立刻爬到了卡伍德·李普顿所在的散兵坑。然而，又一枚炮弹调到他们散兵坑的边缘处，庆幸的是，炮弹一直冒着烟，但没有爆炸。死里逃生的两人盯着炮弹很久，然后鲁兹点起了一根烟，而李普顿作为一个从来不抽烟的人却主动抢了过来抽了起来。难以想象，两人的内心是怎样一种感受。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers14.png" />
</div>
<h1 id="第四幕">第四幕</h1>
在严寒的冬季中，饥寒交迫的E连于比利时巴斯托尼市外的森林中孤军奋战，死守同盟军的防线，仅有少量的补给品与弹药抵达，但是御寒的冬衣却一件也没有。在德军一轮轮的炮轰之中，多名弟兄阵亡。<br />
其中有一幕就是，乔·托伊被炮弹炸断了腿，哭着喊着要站起来，那时他的内心已经到了崩溃的边缘。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers08.png" />
</div>
<h1 id="第五幕">第五幕</h1>
炮轰过后，听到乔·托伊的呼救，好友比尔·葛奈瑞立马去营救他，一路上，乔·托伊还喊着要自己的钢盔。然而，在快到散兵坑的时候，又一轮炮轰开始，一枚炮弹不幸落在他们身边。然而，这一幕发生在刚从散兵坑跳出来准备帮忙的巴克·康普顿眼前。自此之后，他的心理发生了巨大变化。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers09.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers10.png" />
</div>
<h2 id="第六幕">第六幕</h2>
E连进入德国后，一个小分队在邻近的森林中，发现了一个被遗弃的纳粹集中营，里面还充满了饱受折磨的俘虏。令人惊奇的是，当地居民竟否认这个集中营的存在。而就在此时，欧洲各地都纷纷传来发现死亡集中营的消息。看到那一幕，我的心情很沉重，我并不明白希特勒为什么要搞种族屠杀。而这仅仅只是其中一个纳粹集中营，难以想象奥斯维辛集中营是如何人间地狱一般地存在。战争总是会让无辜的人民成为战争的牺牲品。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers15.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers16.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers17.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers18.png" />
</div>
<h2 id="第七幕">第七幕</h2>
影片的最后，温特斯少校老年的的回忆，有一天他的孙子问了他一个问题,“爷爷，你是战争中的英雄吗？”，他说：“不是，可是我和英雄们一起战斗。”。说完，温特斯老爷爷哽咽了，我能感受到他内心那种复杂的心情。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers02.jpg" />
</div>
<p>无论是哪一方的士兵，都只是在执行上级的命令，战场上你死我活，然而在战争之前，他们也许和你我一样拥有着相似的爱好，从事着相似的工作，甚至能够彼此建立起友谊。我想，从他们返回战场那一刻，没有人不希望和平的到来。</p>
<p>现在，中日一旦出现紧张关系，总有人叫嚣着要开战，也许他们看惯例国产抗战剧、看惯了祖国的各种军演，总以为我们无需伤亡即可碾压对手。对这种一时图快，看不清战争危害的言行，我只想说：Naive！</p>
<p>最后，我想以德军投降前，一位纳粹将军对自己的士兵们说的简短的几句话结尾：
&gt;
这是一场漫长的战争，也是一场艰苦的战争，你们英勇并骄傲地为祖国作战，你们是一群特别的人，你中有我，我中有你，只有在战斗中会有这样的友谊，在兄弟之间共同使用散兵坑，在最需要的时刻相互扶持，你们见证过死亡，一起接受磨难，我很自豪能与你们每个人共同服役，你们有权利享受永远的快乐和平的生活...</p>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers04.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers05.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/band-of-brothers06.png" />
</div>
<p>(完)</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币那些事(3)——区块链</title>
    <url>/2019/11/05/bitcoin-blockchain/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin-logo02.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>通过 <a
href="http://chuquan.me/2019/10/07/understand-bitcoin/">《比特币那些事(1)——入门》</a>
和 <a
href="http://chuquan.me/2019/11/25/bitcoin-transaction/">《比特币那些事(2)——交易》</a>
两文，我们基本认识了比特币。本文我们来探索一下比特币工作的核心——区块链。
# 区块链
区块链，顾名思义，就是由一个个被称为区块的数据结构组成的一个链表。每个区块中都记录了大量的交易信息。比特币系统中的所有节点都维护着一个全局区块链，其中
<strong>全节点</strong>（完整节点）则拥有一份完整的拷贝。</p>
<p>既然区块链是由区块串联而成，那么区块之间是否有什么关系呢？事实上，每个区块都包含了前一个区块的信息。新的区块在创建时会对前一个区块的区块头进行
SHA256 加密，进而生成一个哈希值。然后在新区块的区块头中的
<strong>父区块哈希值</strong>
字段中引用该哈希值，从而实现每个区块头都包含它的父区块哈希值。最终形成一条可追溯到第一个区块（创世区块）的区块链。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin016.png?x-oss-process=image/resize,w_300" /></p>
<p>区块链可以被存储为 <strong>平面文件</strong>（Flat
File），或者被存储在数据库中。比特币核心客户端就是使用 Google 的 LevelDB
数据库存储区块链的元数据。</p>
<h1 id="区块">区块</h1>
<p>区块本质上是一个服务于交易信息的容器数据结构。我们通过一个 Swift
开源库 BitcoinKit 来看看它是如何描述比特币的区块结构。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">BlockMessage</span> &#123;</span><br><span class="line">    <span class="comment">/* 区块头 */</span></span><br><span class="line">    <span class="comment">/// Block version information (note, this is signed)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> version: <span class="type">Int32</span></span><br><span class="line">    <span class="comment">/// The hash value of the previous block this particular block references</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> prevBlock: <span class="type">Data</span></span><br><span class="line">    <span class="comment">/// The reference to a Merkle tree collection which is a hash of all transactions related to this block</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> merkleRoot: <span class="type">Data</span></span><br><span class="line">    <span class="comment">/// A Unix timestamp recording when this block was created (Currently limited to dates before the year 2106!)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> timestamp: <span class="type">UInt32</span></span><br><span class="line">    <span class="comment">/// The calculated difficulty target being used for this block</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> bits: <span class="type">UInt32</span></span><br><span class="line">    <span class="comment">/// The nonce used to generate this block… to allow variations of the header and compute different hashes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> nonce: <span class="type">UInt32</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 交易数 */</span></span><br><span class="line">    <span class="comment">/// Number of transaction entries</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> transactionCount: <span class="type">VarInt</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 交易列表 */</span></span><br><span class="line">    <span class="comment">/// Block transactions, in format of &quot;tx&quot; command</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> transactions: [<span class="type">Transaction</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上述代码，其实我们可以把区块结构分为三部分：</p>
<ul>
<li><strong>Block Header</strong>：由多个字段构成的区块头</li>
<li><strong>Transaction Count</strong>：记录本区块所记录的交易数量</li>
<li><strong>Transactions</strong>：本区块所记录的区块列表</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/block-structure01.png?x-oss-process=image/resize,w_800" /></p>
<p>下面我们依次来看一下各个部分。</p>
<h2 id="区块头">区块头</h2>
<p>从上述示例代码可看出，区块头包含 6 个字段：</p>
<ul>
<li><strong>Version</strong>：本区块的版本号</li>
<li><strong>Previous Block Hash</strong>：父区块的区块头哈希值</li>
<li><strong>Merkle Root</strong>：由本区块交易构成的默克尔树（Merkle
Tree）的树根值</li>
<li><strong>Timestamp</strong>：本区块的创建时间戳</li>
<li><strong>Difficulty
Target</strong>：工作量证明的目标值，也称难度目标</li>
<li><strong>Nonce</strong>：本区块计算出的工作量证明值</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/block-structure02.png?x-oss-process=image/resize,w_800" /></p>
<p>其中，Nonce、Difficulty Target、Timestamp 会用于挖矿过程。</p>
<h3 id="merkle-tree">Merkle Tree</h3>
<p>上文我们提到每个区块中都包含一个 <code>Merkle Root</code>
的字段，用于记录默克尔树的树根。那么默克尔树是什么呢？为什么要建立这棵树？</p>
<p>默克尔树是一种
<strong>哈希二叉树</strong>，主要用于快速归纳和校验大规模数据完整性的数据结构。</p>
<p>在比特币系统中，默克尔树则被用来归纳一个区块中的所有交易，同时生成区块交易集合的数字指纹，并且提供了一种
<strong>校验区块中是否存在某交易</strong> 的高效途径。</p>
<p>默克尔树是自底向上构建的。构建默克尔树时会递归地对一对节点进行哈希，并将新生成的哈希节点插入到默克尔树中，直到只剩下一个哈希节点，即默克尔树的根。</p>
<p>下图所示，为我们对 A、B、C、D 4 个交易构建默克尔树的示例。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/blockchain-merkle-tree01.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="构建过程">构建过程</h4>
<p>首先，对每个交易进行加密哈希运算（Double-SHA256）得到叶子节点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin017.png?x-oss-process=image/resize,w_800" /></p>
<p>接着，将叶子节点两两串联后进行加密哈希运算得到父节点。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin018.png?x-oss-process=image/resize,w_800" /></p>
<p>继续类似的操作，直到只剩下一个顶部的节点，即默克尔根（Merkle Root）。
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin019.png?x-oss-process=image/resize,w_800" /></p>
<p>由于默克尔树时二叉树，因此它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，最后一个交易会被复制以构成偶数个叶子节点。如下图所示，C
节点会被复制。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/blockchain-merkle-tree02.png?x-oss-process=image/resize,w_800" /></p>
<p>由于加密哈希运算的结果长度始终都是都 32
位，所以无论使用多少交易来构建默克尔树，默克尔树的根的大小始终都是 32
位。</p>
<h4 id="交易验证">交易验证</h4>
<p>为了证明区块中存在某交易，一个节点只需要计算 <code>log2(N)</code>
个哈希值，形成一条从该交易到树根的认证路径（也称默克尔路径）即可。这种验证方式可以将验证的时间复杂度从
<code>O(N)</code> 降到
<code>log2(N)</code>。随着交易数量的增加，这种验证方式的效率优势越明显。</p>
<p>以如下图所示的默克尔树为例，验证区块中是否存在交易 K。为了验证交易 K
是否存在，我们需要提供认证路径上的节点的子节点，即蓝色标注的节点，包括：
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin020.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，使用交易 K
结合这些节点，以构建默克尔树的方式，依次进行加密哈希运算，得到： <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin021.png?x-oss-process=image/resize,w_800" /></p>
<p>计算得到的最后一个节点即 Merkle Root，如果它与区块中记录的 Merkle
Root 的值一致，则表示本区块中存在交易 K。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/blockchain-merkle-tree03.png?x-oss-process=image/resize,w_800" /></p>
<p>这时候可能会产生一些问题：</p>
<ul>
<li>比特币系统中的节点不是都有一份全局区块链的副本吗？直接遍历区块链不就可以验证交易是否存在了吗？</li>
<li>通过默克尔树验证交易时，辅助验证的那些节点从哪里来的？</li>
</ul>
<p>事实上，比特币系统中并不是所有节点都保存了一份完整的全局区块链的副本。因为现阶段的比特币全局区块链数据量已经非常大了，对于普通的客户端，尤其是移动客户端，保存一份完整的区块链副本是不现实的。</p>
<p>因此，根据是否保存了一份完整的全局区块链副本，可以将比特币系统中的节点分成两种类型：</p>
<ul>
<li><strong>全节点</strong>（Full
Node）：保存了一份完整的区块链副本，可以独立自主验证所有交易。</li>
<li><strong>轻节点</strong>（也称 SPV
节点）：只保留了一部分区块链，依赖全节点提供验证数据，通过
<strong>简易支付验证</strong> 的方式验证交易。</li>
</ul>
<p>事实上，基于默克尔树验证交易的方式就是所谓的
<strong>简易支付验证</strong>，主要用于轻节点。</p>
<h4 id="简易支付验证">简易支付验证</h4>
<p>轻节点不会保存完整的区块链副本，仅仅保存区块头。它们使用认证路径来验证交易是否存在于区块中，而不必下载区块中的所有交易。</p>
<p>试想这样一个场景：一个 SPV
节点想知道它的钱包中的与某个地址相关的某个交易是否完成。</p>
<p>为了完成这个验证过程，SPV 节点首先会在节点间的通信链接上建立
<strong>布隆过滤器</strong>（Bloom
Filter），限制只接受含有目标地址的交易。当对接的全节点探测到某个交易符合布隆过滤器，它将以
<strong>默克尔消息</strong>（Merkle Message）的形式发送该区块。</p>
<blockquote>
<p>默克尔消息包含区块头和一条连接目标交易与默克尔根的认证路径。</p>
</blockquote>
<p>SPV
节点使用默克尔消息中的认证路径以及目标交易得到默克尔根的值。然后与默克尔消息中的区块头的默克尔根值进行验证，从而判断对应区块中是否存在该交易。这种就可以证明交易是否存在于区块链中，即交易是否完成。</p>
<h2 id="交易数">交易数</h2>
<p>交易数记录了本区块包含多少条交易数据。</p>
<h2 id="交易列表">交易列表</h2>
<p>交易列表中记录了一系列的交易。我们来看看开源库中是如何描述交易的。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line">    <span class="comment">/// Transaction data format version (note, this is signed)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> version: <span class="type">UInt32</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// A list of 1 or more transaction inputs or sources for coins</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> inputs: [<span class="type">TransactionInput</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// A list of 1 or more transaction outputs or destinations for coins</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> outputs: [<span class="type">TransactionOutput</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// A list of witnesses, one for each input; omitted if flag is omitted above</span></span><br><span class="line">    <span class="comment">// public let witnesses: [TransactionWitness] // A list of witnesses, one for each input; omitted if flag is omitted above</span></span><br><span class="line">    <span class="comment">/// The block number or timestamp at which this transaction is unlocked:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> lockTime: <span class="type">UInt32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对比 <code>Transaction</code> 类型的成员与<a
href="http://chuquan.me/2019/11/25/bitcoin-transaction/">《比特币(2)——交易》</a>
所描述的交易的结构，两者基本一致。因此，本文也不再做赘述。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《精通比特币》</li>
<li>《区块链开发指南》</li>
<li><a href="https://jysperm.me/2016/05/blockchain-slides/">BlockChain
与 Ethereum 介绍</a></li>
<li><a href="https://github.com/yenom/BitcoinKit">BitcoinKit</a></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>Merkle Tree</tag>
        <tag>SPV</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币那些事(2)——交易</title>
    <url>/2019/10/20/bitcoin-transaction/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin-network01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>在 <a
href="http://chuquan.me/2019/10/07/understand-bitcoin/">比特币(1)——入门</a>
一文中，我们简要介绍了比特币系统是如何通过
<strong>未花费的交易输出</strong>（Unspent Transaction Outputs,
UTXO）来限制交易的支付者就是交易的发起方。</p>
<p>本文我们来详细探讨一下比特币的交易组成及其验证过程。</p>
<h1 id="概述">概述</h1>
<p>交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中的所有模块都是服务于交易的，这些模块可以创建、传播、验证交易，并最终将交易写入比特币区块链。</p>
<h1 id="举例">举例</h1>
<p>下面，我们以一个具体的例子来介绍交易。</p>
<p>Alice 在 Bob 的咖啡店购买了一杯咖啡，为此，Alice 支付了 0.015
比特币。这笔交易在区块浏览器中显示的内容如下所示（<a
href="https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2">点击查看Alice的交易</a>）：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin-transaction-example.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，实际的交易数据与区块浏览器所显示的内容完全不同。我们通过对
Alice 的交易进行解码，可以得到如下所示的实际交易数据： <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;locktime&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vin&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;txid&quot;</span><span class="punctuation">:</span><span class="string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;vout&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;scriptSig&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sequence&quot;</span><span class="punctuation">:</span> <span class="number">4294967295</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vout&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.01500000</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;scriptPubKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.08450000</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;scriptPubKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="交易输入输出">交易输入输出</h1>
<p>比特币的交易与复式记账类似，下图所示为复式记账。每一笔交易包含一个或多个“输入”，输入是针对支付方的比特币账号。与此同时，每一笔交易还包含一个或多个输出，输出是针对接收方的比特币账号。</p>
<p>输入和输出的总额不必相等。相反，当输出总和小于输入总和时，两者的差值则代表了一笔交易手续费。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin012.png?x-oss-process=image/resize,w_400" /></p>
<p>在比特币系统中，<strong>交易输出</strong>
是创建交易的核心元素。<strong>交易输入</strong>
本质上也是基于交易输出。比特币区块链中记录了所有的交易，每一个交易包含了多个交易输入和交易输出，这些数据都被记录在比特币区块链中，完整的比特币节点可以查询并验证所有的历史交易记录。</p>
<h2 id="交易输出">交易输出</h2>
<p>交易输出根据是否被引用过可以分为两种类型：</p>
<ul>
<li><strong>未花费交易输出</strong>（Unspent Transaction
Output，UTXO）</li>
<li><strong>已花费交易输出</strong>（Spent Transaction
Output，STXO）</li>
</ul>
<p>一个 UTXO 只能被一个交易引用，当该交易写入区块链后，该 UTXO
就转换成了 STXO，无法再被其他交易引用。</p>
<p>下面，我们来看一下交易输出到底是什么？以上述例子为例，交易输出位于
<code>vout</code> 数组中。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vout&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.01500000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;scriptPubKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">0.08450000</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;scriptPubKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p><code>vout</code>
数组中的每一项都是一个交易输出。由此可见，每个交易输出包含两个值：</p>
<ul>
<li><code>value</code>：指交易输出指定可用的比特币数量（最小单位是“聪”，satoshi）。</li>
<li><code>scriptPubKey</code>：指交易输出作为 UTXO
被引用时，交易的创建者需要满足的条件，或者说是需要解决的
<strong>加密难题</strong>（cryptographic puzzle）。</li>
</ul>
<p>加密难题也称为 <strong>锁定脚本（Locking
Script）</strong>、<strong>见证脚本（Witness Script）</strong> 或
<strong>脚本公钥（ScriptPubKey）</strong>。事实上，交易输出在创建时就已经通过
<code>scripPubKey</code> 指明了可以使用它的账户。</p>
<p>所以说，当用户的钱包“收到”比特币时，指的就是钱包已经检测到了该账户可用的
UTXO。而用户的比特币“余额”指的就是该账户可用的 UTXO 总和。这些 UTXO
可能分散在数百个交易中。</p>
<!--如果一个 UTXO 比一笔交易所需的数额要大，它仍然会作为一个整体被花费掉，但同时会在交易中生成零头。例如：使用一个价值 20 比特币的 UTXO 支付 1 比特币，那么交易必须消耗掉整个 20 比特币的 UTXO，并产生两个输出：一个支付了 1 比特币给接收人，另一个支付了 19 比特币的找零到支付人的钱包。-->
<p>那么， <code>scriptPubKey</code>
到底包含了什么信息呢？我们后面会继续介绍。</p>
<h2 id="交易输入">交易输入</h2>
<p>交易输入本质上还是基于交易输出，它通过引用 UTXO 将其标记为
<strong>已花费</strong>，并通过 <strong>解锁脚本</strong> 提供对 UTXO
的所有权。</p>
<p>我们仍然以上述列子为例，该交易的交易输入位于 <code>vin</code>
数组中。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vin&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;txid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vout&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;scriptSig&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sequence&quot;</span><span class="punctuation">:</span> <span class="number">4294967295</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p><code>vin</code>
数组的每一项都是一个交易输入。每个交易输入包含几个部分：</p>
<ul>
<li><code>txid</code>：所引用的 UTXO 所在的交易ID（哈希值）。</li>
<li><code>vout</code>：所引用的 UTXO 在其交易输出中的序号。</li>
<li><code>scriptSig</code>：解锁脚本，与锁定脚本进行配对。</li>
<li><code>sequence</code>：序列号。</li>
</ul>
<p>仅看交易输入，我们无法直接获取交易输入所引用的 UTXO
的内容。因此，比特币节点会检索整个区块链来查找被引用的
UTXO，从而对本交易进行验证。一旦发现区块链中存在某个交易的交易输入已经引用了该
UTXO，那么说明本交易的交易数据已经不是 UTXO 了，而是
STXO，因此本交易无法通过验证。</p>
<p>那么，<code>scriptSign</code>
到底包含了什么信息呢？解锁脚本和锁定脚本是如何进行验证的呢？</p>
<p>下面，我们来介绍锁定脚本和解锁脚本。</p>
<h1 id="交易脚本">交易脚本</h1>
<p>比特币包含两种交易脚本：</p>
<ul>
<li><strong>锁定脚本</strong></li>
<li><strong>解锁脚本</strong></li>
</ul>
<p><strong>锁定脚本指出了交易输出作为 UTXO
被引用时，交易的创建者需要满足的条件</strong>。由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），所以也被称为
<strong>脚本公钥</strong>（ScriptPubKey）。</p>
<p>解锁脚本则是与锁定脚本相匹配的脚本，可以满足锁定脚本所设置的花费条件。由于解锁脚本包含一个数字签名，因此也被称为
<em>脚本签名</em>（ScriptSig）。</p>
<p>当比特币节点对一笔交易进行验证时，交易验证引擎会进行以下几个步骤：</p>
<ol type="1">
<li>通过交易输入的 <code>scriptSig</code> 获取到解锁脚本</li>
<li>通过交易输入的 <code>txid</code> 和 <code>vout</code> 获取到对应的
UTXO</li>
<li>通过 UTXO 的 <code>scripPubKey</code> 获取到锁定脚本</li>
<li>将解锁脚本和锁定脚本组合成组合验证脚本</li>
<li>执行组合验证脚本</li>
<li>根据执行结果判断交易验证是否通过，即判断解锁脚本是否满足锁定脚本设置的条件</li>
</ol>
<p>下图所示为最常见的比特币交易的解锁脚本和锁定脚本的示例，它们在交易验证时会组合成组合验证脚本。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin013.png?x-oss-process=image/resize,w_600" /></p>
<h2 id="脚本语言">脚本语言</h2>
<p>交易脚本使用一种类似 Forth 的逆波兰表达式的基于堆栈的脚本语言。</p>
<p>脚本语言包含许多操作码，这些操作码并不包含
<strong>循环或复杂流控制</strong>
的能力，从而保证了脚本语言的图灵非完备性。
脚本语言的图灵非完备性，意味着脚本只有有限的复杂性和可预见的执行次数，这样可以确保该语言不被用于创造无限循环或其他类型的逻辑黑洞。</p>
<h2 id="执行堆栈">执行堆栈</h2>
<p>脚本语言是基于堆栈的语言，因为它使用一种被称为堆栈的数据结构。</p>
<p>脚本语言通过从左到右处理每个项目来执行脚本。数据项被 Push
到堆栈上。操作码会先从堆栈中 Pop
多个参数，对参数进行操作后，可能会将结果 Push 到堆栈中。如：操作码
<code>OP_ADD</code> 会从堆栈中 Pop 两个数据项，对其求和后将结果 Push
到堆栈中。</p>
<p>如下所示，是一个简单的脚本执行堆栈示意图。脚本
<code>2 3 OP_ADD 5 OP_EQUAL</code> 演示了算术加法操作码
<code>OP_ADD</code>，该操作码将两个数据项相加，然后把结果 Push
到堆栈，操作码 <code>OP_EQUAL</code> 则验算之前的两数据项之和是否等于
5。脚本执行完后，堆栈顶部的结果为
<code>true</code>，则表示交易验证通过。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin014.png?x-oss-process=image/resize,w_600" /></p>
<p>事实上，上述执行是一个组合验证脚本，即解锁脚本和锁定脚本的组合。对应，解锁脚本和锁定脚本可能分别是：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 解锁脚本</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">// 锁定脚本</span><br><span class="line">3 OP_ADD 5 OP_EQUAL</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：最初版本的比特币客户端中，解锁脚本和锁定脚本就是按照上述方式组合后再执行。不过，这种方式存在一定的安全隐患：异常的解锁脚本推送数据入栈可能会污染锁定脚本。为了提高安全性，2010
年比特币客户端的脚本执行方案发生了变化：解锁脚本和锁定脚本各自独立执行。首先执行解锁脚本，如果解锁脚本在执行过程中未报错（如：没有悬挂操作码），则复制主堆栈，并执行锁定脚本。</p>
<h2 id="p2pkh-脚本">P2PKH 脚本</h2>
<p>P2PKH（Pay-To-Public Key
Hash）是一种特定的交易脚本类型（解锁脚本和锁定脚本均使用这种类型）。比特币中的大多数交易都采用了
P2PKH 脚本。P2PKH 锁定脚本将输入锁定为一个公钥哈希值，即比特币地址。由
P2PKH
锁定脚本可以通过提供一个公钥和和由相应私钥创建的数字签名来解锁。其原理的本质如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-verify03.png?x-oss-process=image/resize,w_600" /></p>
<p>以 Alice 向 Bob 咖啡馆支付 0.015
比特币为例，该交易的交易输出的锁定脚本如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure>
其中，<code>&lt;Cafe Public Key Hash&gt;</code> 为 Bob
咖啡馆的比特币地址，暗示了本交易的此 UTXO 只允许 Bob
咖啡馆才能使用。</p>
<p>上述锁定脚本对应的解锁脚本如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</span><br></pre></td></tr></table></figure> 当后续 Bob
咖啡馆向引用此 UTXO 时进行其他交易时，可以使用该解锁脚本。</p>
<p>将两个脚本结合起来可以形成如下的组合验证脚本： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</span><br></pre></td></tr></table></figure></p>
<p>其执行堆栈如下所示，只有当解锁脚本得到了咖啡馆的有效签名，交易执行结果才会被通过（结果为真），该有效签名是从与公钥哈希相匹配的咖啡馆的私钥中所获取的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin015.png?x-oss-process=image/resize,w_600" /></p>
<h2 id="多重签名脚本">多重签名脚本</h2>
<p>由上述 P2PKH
脚本的机制可知，当用户丢失了私钥，就无法再花费对应地址的比特币。为了避免一个私钥的丢失导致资产冻结。比特币引入了多重签名机制，以分散风险。多重签名脚本就是具体的实现方案（也称
M-N 方案），即锁定脚本记录了 N 个公钥，解锁脚本必须提供了至少 M
个签名才能花费创建交易。</p>
<p>M-N 多重签名脚本的锁定脚本的一般形式如下所示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N CHECKMULTISIG</span><br></pre></td></tr></table></figure></p>
<p>假设有一个 2-3 多重签名脚本，那么它的锁定脚本、解锁脚本将如下所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 锁定脚本</span><br><span class="line">2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 CHECKMULTISIG</span><br><span class="line"></span><br><span class="line">// 解锁脚本：可以是任意两个签名</span><br><span class="line">&lt;Signature B&gt; &lt;Signature C&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里我们考虑一个问题：如果 N
特别大，即允许的签名数量非常多，会产生什么问题？很显然，锁定脚本会特别长，占有的容量也会特别大。一般而言，锁定脚本是由支付方生成的；解锁脚本是由接收方生成的。为了将减小支付方的压力，P2SH
脚本出现了。（其实这里我也不是很明白，为什么要转移压力）</p>
<h2 id="p2sh-脚本">P2SH 脚本</h2>
<p>P2SH（Pay-to-Script-Hash）是一种新型的、可简化复杂交易脚本的脚本类型。P2SH
主要用于解决多重签名脚本的锁定脚本冗长的问题。</p>
<p>P2SH 脚本提出了 <strong>赎回脚本</strong>（Redeem
Script）的概念，其内容本质上与多重签名脚本的锁定脚本一致。相应地，P2SH
脚本的锁定脚本和解锁脚本也发生了一定的变化。下面我们以一个简单的例子来对比
P2SH 和多重签名脚本。</p>
<p><strong>多重签名脚本</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 锁定脚本</span><br><span class="line">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</span><br><span class="line"></span><br><span class="line">// 解锁脚本</span><br><span class="line">Sig1 Sig2</span><br></pre></td></tr></table></figure></p>
<p><strong>P2SH 脚本</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 赎回脚本 redeem script</span><br><span class="line">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG</span><br><span class="line"></span><br><span class="line">// 锁定脚本</span><br><span class="line">HASH160 &lt;20-byte hash of redeem script&gt; EQUAL</span><br><span class="line"></span><br><span class="line">// 解锁脚本</span><br><span class="line">Sig1 Sig2 &lt;redeem script&gt;</span><br></pre></td></tr></table></figure></p>
<p>关于 P2SH
脚本的验证。比特币系统节点首先会将赎回脚本和锁定脚本进行对比，确认赎回脚本的哈希值是否与锁定脚本中的哈希值一致。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG&gt; HASH160 &lt;redeem scriptHash&gt; EQUAL</span><br></pre></td></tr></table></figure></p>
<p>如果哈希值一致，解锁脚本会被执行以释放赎回脚本。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 CHECKMULTISIG</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>至此，我们知道了比特币系统是如何验证交易的。本质上，交易验证充分的应用了密码学的相关原理。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《精通比特币》</li>
<li>《区块链开发指南》</li>
<li><a
href="https://github.com/EdgeIntelligenceChain/EdgenceChain/issues/102">脚本验证支持MS（Multiple
Signatures）多重签名</a></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>交易</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币那些事(4)——钱包</title>
    <url>/2019/11/20/bitcoin-wallet/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin022.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>比特币中钱包并不是传统意义的钱包，它不包含比特币，仅仅包含密钥。每个用户都有一个包含多个密钥的钱包，钱包只包含私钥/公钥对的密钥链。用户用密钥签名交易，从而证明他们拥有交易输出，最终花费比特币。关于交易输出的概念，可以查看
<a
href="http://chuquan.me/2019/11/25/bitcoin-transaction/">《比特币那些事(2)——交易》</a>。</p>
<h1 id="钱包">钱包</h1>
<p>比特币钱包根据其包含的多个密钥是否相互关联，可以分为两种类型：</p>
<ul>
<li><strong>非确定性钱包</strong>（Nondeterministic Wallet）</li>
<li><strong>确定性钱包</strong>（Deterministic Wallet）</li>
</ul>
<p>非确定性钱包中的所有密钥都是由 <strong>随机数</strong>
独立生成的。密钥之间彼此无关，因此也称为 “Just a Bunch of Keys”，简称
<strong>JBOK 钱包</strong>。</p>
<p>确定性钱包中的所有密钥都是从一个 <strong>主密钥</strong>
派生出来的。主密钥也称为
<strong>种子</strong>（Seed）。确定性钱包中所有密钥相互关联，如果有原始种子，则可以再次生成全部密钥。</p>
<h2 id="非确定性钱包">非确定性钱包</h2>
<p>在早期的比特币客户端（Bitcoin
Core，也称比特币核心客户端）中，钱包只是随机生成的私钥集合。随机密钥的缺点就是如果你生成很多私钥，就必须保存它们所有的副本。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-unconfirmed-wallet.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="确定性钱包">确定性钱包</h2>
<p>确定性钱包通过使用单项离散函数从公共的种子生成的私钥。种子是随机生成的数字。在确定性钱包中，种子可以恢复所有的已经生成的私钥，因此，只要在初始创建时对种子进行备份就可以了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-confirmed-wallet.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="分层确定性钱包">分层确定性钱包</h1>
<p>确定性钱包使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为
<strong>分层确定性钱包</strong>（Hierarchical Deterministic Wallet，简称
<strong>HD 钱包</strong>）。在 HD
钱包中，父密钥可以衍生出一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-hd-wallet.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="举例">举例</h2>
<p>下面，我们通过一个例子来介绍 HD 钱包的实现原理。</p>
<p>Alice 经营了一家网络商店销售T恤。她使用 Trezor 比特币硬件钱包（硬件
HD 钱包）来管理她的比特币。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-trezor-wallet.png?x-oss-process=image/resize,w_800" /></p>
<p>Alice 首次使用 Trezor 时，设备从内置的硬件随机数生成器生成
<strong>助记词</strong>。钱包会在屏幕上按顺序逐个显示助记词。通过记下这些助记符，Alice
创建了一个备份，如下所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">1</th>
<th style="text-align: left;">army</th>
<th style="text-align: left;">2</th>
<th style="text-align: left;">van</th>
<th style="text-align: left;">3</th>
<th style="text-align: left;">defense</th>
<th style="text-align: left;">4</th>
<th style="text-align: left;">carry</th>
<th style="text-align: left;">5</th>
<th style="text-align: left;">jealous</th>
<th style="text-align: left;">6</th>
<th style="text-align: left;">true</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">7</td>
<td style="text-align: left;">garbage</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">claim</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">echo</td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">media</td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">make</td>
<td style="text-align: left;">12</td>
<td style="text-align: left;">crunch</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：这里举例显示了 12 个助记词。事实上，大多数硬件钱包会生成更安全的
24 个助记词。</p>
</blockquote>
<h2 id="工作原理">工作原理</h2>
<p>HD 钱包的密钥推导主要包括以下几个步骤：</p>
<ul>
<li>创建助记词</li>
<li>创建种子</li>
<li>创建钱包</li>
</ul>
<p>下面我们依次来介绍这个三个主要步骤。</p>
<h3 id="创建助记词">创建助记词</h3>
<p>BIP-39 是助记词行业标准，定义了助记词和种子的创建。助记词是由钱包使用
BIP-39
中定义的标准化过程自动生成的。助记词的生成主要包含以下这些步骤：</p>
<ol type="1">
<li>创建一个 128 至 256 位的随机序列（熵）</li>
<li>提取随机序列哈希值的前几位（随机序列长度/32），作为随机序列的校验和</li>
<li>将校验和拼接至随机序列的末尾</li>
<li>将序列进行分割成多个单元，每个单元占 11 位</li>
<li>将每个单元的值映射到一个包含 2048（2^11）个单词的字典</li>
<li>映射得到有顺序的单词组，即助记词</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-bitcoin-mnemonic.png?x-oss-process=image/resize,w_800" /></p>
<p>根据上述助记词的生成步骤，可以推测出随机序列（熵）与助记词长度的关系，如下表所示：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Entropy(bits)</th>
<th style="text-align: left;">Checksum(bits)</th>
<th style="text-align: left;">Entropy + Checksum(bits)</th>
<th style="text-align: left;">Mnemonic Length(words)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">128</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">132</td>
<td style="text-align: left;">12</td>
</tr>
<tr class="even">
<td style="text-align: left;">160</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">165</td>
<td style="text-align: left;">15</td>
</tr>
<tr class="odd">
<td style="text-align: left;">192</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">198</td>
<td style="text-align: left;">18</td>
</tr>
<tr class="even">
<td style="text-align: left;">224</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">231</td>
<td style="text-align: left;">21</td>
</tr>
<tr class="odd">
<td style="text-align: left;">256</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">264</td>
<td style="text-align: left;">24</td>
</tr>
</tbody>
</table>
<h3 id="创建种子">创建种子</h3>
<p>助记词创建之后，可以通过密钥延伸函数 PBKDF2 进一步生成种子。</p>
<p>密钥延伸函数 PBKDF2
有两个参数：<strong>助记词</strong>、<strong>盐</strong>
(Salt)。盐的目的是为了增加暴力攻击的难度。</p>
<p>种子的生成主要包含以下步骤：</p>
<ol start="7" type="1">
<li>PBKDF2 密钥延伸函数的第一个参数是助记词。</li>
<li>PBKDF2
密钥延伸函数的第二个参数是盐。<strong>盐由助记词和可选的用户提供的密码组成</strong>。</li>
<li>PBKDF2 密钥延伸函数内部使用 HMAC-SHA512 算法，进行 2048
次哈希运算，生成一个 512 位的种子。</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-bitcoin-seed.png?x-oss-process=image/resize,w_800" /></p>
<p>下表所示为示例的 128 位熵转换成 512 位种子的结果。 |Entropy(128
bits)|0c1e24e5917779d297e14d45f14e1a1a| |:---|:---| |<strong>Mnemonic(12
words)</strong>|<strong>army van defense carry jealous true garbage
claim echo media make crunch</strong>|
|<strong>Passphrase</strong>|(none)| |<strong>Seed(512
bits)</strong>|<strong>5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39a88b76373733891bfaba16ed27a813ceed498804c0570</strong>|</p>
<h3 id="创建钱包">创建钱包</h3>
<p>钱包的创建主要包含以下几项工作：</p>
<ul>
<li>创建主私钥，即密钥树的根</li>
<li>创建子私钥</li>
<li>创建子公钥</li>
</ul>
<p>下面我们依次介绍这几个步骤，在介绍完之后，我们再来看看其中存在的安全风险，进而介绍硬件子私钥的创建。</p>
<h4 id="创建主私钥">创建主私钥</h4>
<p>HD 钱包的确定性源自于 <strong>根种子</strong>（Root
Seed），即上述过程所生成的种子。</p>
<p>根种子通过 HMAC-SHA512 算法可生成 512
位哈希值。该将哈希值分成左右两部分，分别得到：</p>
<ul>
<li><strong>主私钥(m)</strong>（Master Private
Key(m)）：主私钥(m)通过椭圆曲线算法可以生成
<strong>主公钥(M)</strong>（Master Public Key(M)）。</li>
<li><strong>主链码</strong>（Master Chain Code）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-bitcoin-main-private-key.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="创建子私钥">创建子私钥</h4>
<p>我们知道 HD
钱包采用树状结构进行密钥推导。在树状的密钥结构中，除了主密钥是通过根种子推导的，其他层级的密钥都是通过其母密钥推导的，采用
<strong>子密钥衍生函数</strong> CKD (Child Key Derivation)。</p>
<p>子密钥衍生函数的调用需要三个参数：</p>
<ul>
<li><strong>母私钥</strong></li>
<li><strong>母链码</strong></li>
<li><strong>索引号</strong>：32 位的值，因此每个母私钥可以推导出 2^32
个子私钥。</li>
</ul>
<p>子私钥的具体衍生过程：根据母私钥推导出母公钥，将
<strong>母公钥-母链码-索引号</strong> 合并后使用 HMAC-SHA512 算法并结合
<strong>母私钥</strong> 生成 512
位哈希值。将该哈希值继续拆分成左右两部分，分别得到：</p>
<ul>
<li><strong>子私钥</strong></li>
<li><strong>子链码</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-bitcoin-child-private-key-01.png?x-oss-process=image/resize,w_800" /></p>
<p>上述子密钥衍生函数所使用的三个参数，其中母私钥和母链码的结合被称为
<strong>扩展私钥</strong>（Extended Private
Key）。通过上述子私钥推导的原理，可以知道：一个扩展密钥作为 HD
钱包中密钥树的一个分支，可以衍生出该分支下的所有密钥。</p>
<p>与 <strong>扩展私钥</strong> 相对应是
<strong>扩展公钥</strong>（Extended Public Key），它由
<strong>母公钥</strong> 和 <strong>母链码</strong>
组成，可用于通过母公钥直接创建子公钥。</p>
<h4 id="创建子公钥">创建子公钥</h4>
<p>分层确定性钱包还有一个特点是：可以不通过私钥而直接从母公钥衍生出子公钥。这就给我们提供了两种衍生子公钥的方法：</p>
<ul>
<li>通过子私钥衍生子公钥</li>
<li>通过母公钥衍生子公钥</li>
</ul>
<p>子公钥的具体衍生过程（利用扩展公钥）：将
<strong>母公钥-母链码-索引号</strong> 合并后使用 HMAC-SHA512 算法并结合
<strong>母公钥</strong> 生成 512
位哈希值。将该哈希值继续拆分成左右两部分，分别得到：</p>
<ul>
<li><strong>子私钥</strong></li>
<li><strong>子链码</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-bitcoin-child-public-key.png?x-oss-process=image/resize,w_800" /></p>
<p>这种子公钥的衍生过程不涉及任何私钥，运用到实际场景，可以实现私钥和公钥的分开管理。比如：在电商场景中，网络服务器仅维护公钥树结构，给每一笔交易创建一个比特币地址（只能接收比特币，而不能花费比特币）。为了安全起见，网络服务器不会有任何私钥。电商服务器则维护了私钥树结构，保证比特币的花费权在自己手上。</p>
<h4 id="创建硬化子私钥">创建硬化子私钥</h4>
<p>现在，我们深究一下上述子私钥和子公钥的创建方式，它们分别使用了
<strong>扩展私钥</strong> 和
<strong>扩展公钥</strong>。这两种扩展密钥都包含了相同的母链码。这时候就可能存在安全风险：由于扩展公钥包含母链码，如果子私钥泄露了，攻击者就可以通过扩展公钥的母链码和子私钥组成一个扩展私钥。那么，该分支下的所有私钥都会泄露。更糟糕的是，子私钥与母链码可以用来推断母私钥。</p>
<p>为了应对这种风险，HD 钱包使用一种叫做
<strong>硬化衍生</strong>（Hardened
Derivation）衍生函数。其本质就是让子私钥衍生和子公钥衍生使用不同的链码。</p>
<p>具体实现是
<strong>使用母私钥去推导子链码</strong>。非硬化子私钥衍生则是使用
<strong>母公钥去推导子链码</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-bitcoin-hardend-child-private-key.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="核心源码">核心源码</h4>
<p>如下所示为比特币开源库 BitcoinKit
中关于密钥推导的核心方法。从中，我们能一窥其技术原理。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BitcoinKitPrivateSwift.swift</span></span><br><span class="line"><span class="comment">// 子私钥和子公钥的衍生方法源代码</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">derived</span>(<span class="params">at</span> <span class="params">childIndex</span>: <span class="type">UInt32</span>, <span class="params">hardened</span>: <span class="type">Bool</span>) -&gt; _HDKey<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="operator">=</span> <span class="type">Data</span>()</span><br><span class="line">    <span class="comment">// 是否使用硬化衍生</span></span><br><span class="line">    <span class="keyword">if</span> hardened &#123;</span><br><span class="line">        data.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> privateKey <span class="operator">=</span> <span class="keyword">self</span>.privateKey <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 强化衍生时，加入母私钥</span></span><br><span class="line">        data.append(privateKey)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非强化衍生，加入母公钥</span></span><br><span class="line">        data.append(publicKey)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> childIndex <span class="operator">=</span> <span class="type">CFSwapInt32HostToBig</span>(hardened <span class="operator">?</span> (<span class="number">0x80000000</span> <span class="keyword">as</span> <span class="type">UInt32</span>) <span class="operator">|</span> childIndex : childIndex)</span><br><span class="line">    <span class="comment">// 加入索引号</span></span><br><span class="line">    data.append(<span class="type">Data</span>(bytes: <span class="operator">&amp;</span>childIndex, count: <span class="type">MemoryLayout</span>&lt;<span class="type">UInt32</span>&gt;.size))</span><br><span class="line">    <span class="comment">// 结合母链码，生成哈希值。注意，是否为强化衍生将影响生成的链码</span></span><br><span class="line">    <span class="keyword">var</span> digest <span class="operator">=</span> _Hash.hmacsha512(data, key: <span class="keyword">self</span>.chainCode)</span><br><span class="line">    <span class="keyword">let</span> derivedPrivateKey: [<span class="type">UInt8</span>] <span class="operator">=</span> digest[<span class="number">0</span><span class="operator">..&lt;</span><span class="number">32</span>].map &#123; <span class="variable">$0</span> &#125;      <span class="comment">// 左半部分为私钥</span></span><br><span class="line">    <span class="keyword">let</span> derivedChainCode: [<span class="type">UInt8</span>] <span class="operator">=</span> digest[<span class="number">32</span><span class="operator">..&lt;</span><span class="number">64</span>].map &#123; <span class="variable">$0</span> &#125;      <span class="comment">// 右半部分为链码</span></span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> privateKey <span class="operator">=</span> <span class="keyword">self</span>.privateKey &#123;</span><br><span class="line">        <span class="comment">// 子私钥的衍生。调用本方法时会传入 privateKey</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> ctx <span class="operator">=</span> secp256k1_context_create(<span class="type">UInt32</span>(<span class="type">SECP256K1_CONTEXT_SIGN</span>)) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> &#123; secp256k1_context_destroy(ctx) &#125;</span><br><span class="line">        <span class="comment">// 本质上，使用了母私钥衍生子私钥</span></span><br><span class="line">        <span class="keyword">var</span> privateKeyBytes <span class="operator">=</span> privateKey.map &#123; <span class="variable">$0</span> &#125;     </span><br><span class="line">        <span class="keyword">var</span> derivedPrivateKeyBytes <span class="operator">=</span> derivedPrivateKey.map &#123; <span class="variable">$0</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> secp256k1_ec_privkey_tweak_add(ctx, <span class="operator">&amp;</span>privateKeyBytes, <span class="operator">&amp;</span>derivedPrivateKeyBytes) <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子私钥</span></span><br><span class="line">        result <span class="operator">=</span> <span class="type">Data</span>(privateKeyBytes)      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子公钥的衍生。调用本方法时不会传入 privateKey</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> ctx <span class="operator">=</span> secp256k1_context_create(<span class="type">UInt32</span>(<span class="type">SECP256K1_CONTEXT_VERIFY</span>)) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> &#123; secp256k1_context_destroy(ctx) &#125;</span><br><span class="line">        <span class="comment">// 本质上，使用了母公钥衍生子公钥</span></span><br><span class="line">        <span class="keyword">let</span> publicKeyBytes: [<span class="type">UInt8</span>] <span class="operator">=</span> publicKey.map &#123; <span class="variable">$0</span> &#125;  </span><br><span class="line">        <span class="comment">// 子公钥推导的特殊处理，结合了母公钥</span></span><br><span class="line">        <span class="keyword">var</span> secpPubkey <span class="operator">=</span> secp256k1_pubkey()</span><br><span class="line">        <span class="keyword">if</span> secp256k1_ec_pubkey_parse(ctx, <span class="operator">&amp;</span>secpPubkey, publicKeyBytes, publicKeyBytes.count) <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> secp256k1_ec_pubkey_tweak_add(ctx, <span class="operator">&amp;</span>secpPubkey, derivedPrivateKey) <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> compressedPublicKeyBytes <span class="operator">=</span> [<span class="type">UInt8</span>](repeating: <span class="number">0</span>, count: <span class="number">33</span>)</span><br><span class="line">        <span class="keyword">var</span> compressedPublicKeyBytesLen <span class="operator">=</span> <span class="number">33</span></span><br><span class="line">        <span class="keyword">if</span> secp256k1_ec_pubkey_serialize(ctx, <span class="operator">&amp;</span>compressedPublicKeyBytes, <span class="operator">&amp;</span>compressedPublicKeyBytesLen, <span class="operator">&amp;</span>secpPubkey, <span class="type">UInt32</span>(<span class="type">SECP256K1_EC_COMPRESSED</span>)) <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子公钥</span></span><br><span class="line">        result <span class="operator">=</span> <span class="type">Data</span>(compressedPublicKeyBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fingerPrint: <span class="type">UInt32</span> <span class="operator">=</span> _Hash.sha256ripemd160(publicKey).to(type: <span class="type">UInt32</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">return</span> _HDKey(privateKey: result, publicKey: result, chainCode: <span class="type">Data</span>(derivedChainCode), depth: <span class="keyword">self</span>.depth <span class="operator">+</span> <span class="number">1</span>, fingerprint: fingerPrint, childIndex: childIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《精通比特币》</li>
<li>《区块链技术指南》</li>
<li><a href="https://iancoleman.io/bip39/#english">Mnemonic Code
Converter</a></li>
<li><a href="https://github.com/yenom/BitcoinKit">BitcoinKit</a></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>比特币钱包</tag>
        <tag>HD 钱包</tag>
        <tag>扩展密钥</tag>
      </tags>
  </entry>
  <entry>
    <title>关于此博客</title>
    <url>/2016/08/14/blog-introduce/</url>
    <content><![CDATA[<h1 id="为何建这个博客">为何建这个博客</h1>
<p>互联网在国内兴起的时候我还很小，那时候依稀记得<code>QQ</code>，<code>博客</code>，<code>上网</code>这些字眼儿。等到稍微大一点的时候才知道原来<code>博客</code>其实也是一类网站，那时就希望未来能有一个自己的网站。</p>
<span id="more"></span>
<p>如今，作为一个计算机系的学生，身边不乏有很多大神都拥有着自己的网站（博客），分享着自己的生活，技术以及其他各方面的收获。我也希望自己能够向这些大神们迈进，同时也能记录身边的点点滴滴。或许，待到某一天，你回首往事，那一刻的真实感受会从字里行间再次涌现。</p>
<p>之前，看到一篇文章，文章里说：真正优秀的程序员，往往都有着非常好的逻辑思维能力和语言表达能力，而经常撰写对外公开博文会让你不断提炼自己的语言文字，锻炼你的总结能力和表述能力，这显然有利于这些能力的培养。</p>
<p>平常的看书的时候我会记一些笔记，而那些笔记总是那么索然无味，或者缺少自己总结和见解。希望此博客的诞生能够为我的学习提供更大的帮助。</p>
<h1 id="关于博客的域名">关于博客的域名</h1>
<p>查询注册域名的时候，很高兴发现我的全名的.com域名（www.baochuquan.com）居然没有被注册。不过，身为一名前端，用户体验之上的理念始终贯穿我心，太长的域名显然不利于用户体验。就这样，亲切易记的chuquan.me成为了我的首选。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>现代浏览器工作原理（一）</title>
    <url>/2018/01/21/browser-architecture-overview/</url>
    <content><![CDATA[<h1 id="序">序</h1>
<p>这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了...框架？不是针对特定需求的框架，介绍起来感觉也没有太大的意义...</p>
<span id="more"></span>
<p>恍惚间，想起之前@展哥在调高考真题Hybrid页面时，似乎在前端代码方面遇到一些麻烦。于是，我就想到了UIWebView。就此进行思维发散，感觉可以介绍一下浏览器的工作原理。毕竟，iOS和前端同属于大客户端。对于iOS的同学，也算是对知识面的扩展吧。</p>
<p>于是，我查阅了一些与浏览器原理相关的资料。在这个过程中，找到很多优秀的资料。但是，大多数资料的组织结构，不是特别清晰。因此，我想借此机会，结合参考资料，来重新梳理一下浏览器的原理。由于浏览器的结构非常复杂，一篇文章想介绍清楚，真的太难。本文将使用总-分-总的形式，使用一系列文章来进行介绍。如有纰漏，欢迎纠正。</p>
<h1 id="浏览器历史">浏览器历史</h1>
<p>1990年，<a
href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E">蒂姆·伯纳斯·李</a>开发了第一个网页浏览器<a
href="https://zh.wikipedia.org/wiki/WorldWideWeb">WorldWideWeb</a>，后改名为<strong>Nexus</strong>。WorldWideWeb浏览器支持早期的HTML标记语言，功能比较简单，只能支持文本、简单的样式表、电影、声音、图片等资源的显示。</p>
<p>1993年，<a
href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%85%8B%C2%B7%E5%AE%89%E5%BE%B7%E6%A3%AE">马克·安德森</a>领导的团开发了一个真正有影响力的浏览器<a
href="https://zh.wikipedia.org/wiki/Mosaic">Mosaic</a>，这就是后来世界上最流行的浏览器<a
href="https://zh.wikipedia.org/wiki/Netscape_Navigator">Netscape
Navigator</a>。</p>
<p>1995年，微软推出了闻名于世的浏览器<a
href="https://zh.wikipedia.org/wiki/Internet_Explorer">Internet
Explorer</a>。</p>
<p>1998年，Netscape公司开放Netscape
Navigator源代码，成立了Mozilla基金会。</p>
<p>2003年，苹果公司发布了Safari浏览器。</p>
<p>2004年，Netscape公司发布了著名的开源浏览器<a
href="https://zh.wikipedia.org/wiki/Firefox">Mozilla Firefox</a></p>
<p>2005年，苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目WebKit（Safari浏览器的内核）。</p>
<p>2008年， Google公司已WebKit为内核，创建了一个新的浏览器项目<a
href="https://zh.wikipedia.org/zh-hant/Chromium">Chromium</a>。以Chromium为基础，谷歌发布了<a
href="https://zh.wikipedia.org/wiki/Google_Chrome">Chrome</a>浏览器。至于这两者的关系，可以简单地理解为：Chromium为实验版，具有众多新特性；Chrome为稳定版。</p>
<h1 id="浏览器特性">浏览器特性</h1>
<p>现代浏览器的特性主要包含如下几部分：</p>
<ul>
<li><strong>网络</strong><br />
浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。
网络模块是浏览器最重要的模块之一。</li>
<li><strong>资源管理</strong><br />
浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。</li>
<li><strong>网页浏览</strong><br />
浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。</li>
<li><strong>多页面管理</strong><br />
浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。</li>
<li><strong>插件和扩展</strong><br />
现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。</li>
<li><strong>账户和同步</strong><br />
现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。</li>
<li><strong>安全机制</strong><br />
现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。</li>
<li><strong>开发者工具</strong><br />
开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。</li>
</ul>
<h1 id="浏览器结构">浏览器结构</h1>
<p>目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构：</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/browser-architecture001.png" /></p>
<p>浏览器的抽象分层结构图中将浏览器分成了以下8个子系统：</p>
<ul>
<li><strong>用户界面（User Interface）</strong><br />
用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。<br />
用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。</li>
<li><strong>浏览器引擎（Browser Engine）</strong><br />
浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。<br />
浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。<br />
浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript
alert。<br />
浏览器引擎还允许查询/修改渲染引擎设置。</li>
<li><strong>渲染引擎（Rendering Engine）</strong><br />
渲染引擎为指定的URI生成可视化的表示。<br />
渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。<br />
渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。<br />
渲染引擎内部包含HTML解析器。</li>
<li><strong>网络（Networking）</strong><br />
网络系统实现HTTP和FTP等文件传输协议。
网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。
网络系统可以实现最近检索资源的缓存功能。</li>
<li><strong>JavaScript解释器（JavaScript Interpreter）</strong><br />
JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。
为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。</li>
<li><strong>XML解析器（XML Parser）</strong><br />
XML解析器可以将XML文档解析成文档对象模型（Document Object
Model，DOM）树。
XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。</li>
<li><strong>显示后端（Display Backend）</strong><br />
显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。</li>
<li><strong>数据持久层（Data Persistence）</strong><br />
数据持久层将与浏览会话相关联的各种数据存储在硬盘上。
这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</li>
</ul>
<p>这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？<br />
原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。</p>
<h1 id="渲染引擎">渲染引擎</h1>
<p>浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">渲染引擎</th>
<th style="text-align: left;">浏览器</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Trident</td>
<td style="text-align: left;">IE、Edge</td>
</tr>
<tr class="even">
<td style="text-align: left;">Gecko</td>
<td style="text-align: left;">Firefox</td>
</tr>
<tr class="odd">
<td style="text-align: left;">WebKit</td>
<td style="text-align: left;">Safari、Chromium/Chrome</td>
</tr>
</tbody>
</table>
<h2 id="渲染引擎工作流程">渲染引擎工作流程</h2>
<p>如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/browser-architecture002.png" /></p>
<ol type="1">
<li><p><strong>Parsing HTML to Construct DOM Tree</strong><br />
渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。<br />
同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。</p></li>
<li><p><strong>Render Tree construction</strong><br />
渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。<br />
渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p></li>
<li><p><strong>Layout of Render Tree</strong><br />
渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</p></li>
<li><p><strong>Painting Render Tree</strong><br />
渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。</p></li>
</ol>
<h2 id="渲染引擎组成模块">渲染引擎组成模块</h2>
<p>下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/browser-architecture003.png" /></p>
<p>从图中可以看出，渲染引擎主要包含（或调用）的模块有：</p>
<ul>
<li><strong>HTML（XML）解析器</strong><br />
解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。</li>
<li><strong>CSS解析器</strong><br />
将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。</li>
<li><strong>JavaScript解释器</strong><br />
使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。</li>
<li><strong>布局</strong><br />
DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。</li>
<li><strong>绘图</strong><br />
使用图形库将布局计算后的渲染树绘制成可视化的图像结果。</li>
</ul>
<h1 id="总结">总结</h1>
<p>本文介绍了浏览器的主要特性以及抽象结构，并选择其中最为核心的渲染引擎进行了介绍。渲染引擎是浏览器中最为复杂的部件，后续将对渲染引擎中的各个模块依次进行介绍。</p>
<p>（完）</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">Web
Browser-Wikipedia</a></li>
<li>Adam Barth, Collin Jackson, Charles Reis, Google Chrome Team. The
Security Architecture of the Chromium Browser.</li>
<li>Andre Campos, Bryan Lane, Neal Clark, Sunpreet Jassal, Stephen
Hitchner. Conceptual Architecture of Firefox.</li>
<li>Alan Grosskurth and Michael Godfrey. A case study in architectural
analysis: The evolution of the modern web browser.</li>
<li><a
href="http://web.jobbole.com/84826/">主流浏览器内核介绍（前端开发值得了解的浏览器内核历史）</a></li>
<li>朱永盛. 《WebKit技术内幕》.</li>
<li><a
href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
<li>Alan Grosskurth, Michael W.Godfrey. A Reference Architecture for Web
Browsers.</li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>浏览器原理</tag>
        <tag>渲染引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码</title>
    <url>/2017/02/08/character-code/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<blockquote>
<p><strong>字符</strong>是一个信息单位，在计算机中，一个中文汉字是一个字符，一个英文字母是一个字符，一个阿拉伯数字是一个字符，一个标点符号也是一个字符。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>字符集</strong>是字符组成的集合，通常以二维表的形式存在于每一台计算机本地，二维表的内容和大小是由使用者的语言而定的，可以是英语、汉语、希腊语等等。</p>
</blockquote>
<blockquote>
<p><strong>字符编码</strong>是把字符集中的字符编码为特定的二进制数，以便在计算机中存储。编码方式一般是对二维表的横纵坐标进行变换的算法。一般都比较简单，直接把横纵坐标拼一起。后来随着字符集的不断扩大，为了节省存储空间，才出现了各种编码算法。</p>
</blockquote>
<p>字符集和字符编码一般是成对出现的，如ASCII、IOS-8859-1、GB2312、GBK等，都是既表示了字符集又表示了对应的字符编码，下文统称编码。Unicode比较特殊，后面细说。</p>
<h1 id="发展">发展</h1>
<h2 id="ascii">ASCII</h2>
计算机是美国人发明的，由于他们的语言的是美式英语，字符比较少，所以一开始就设计了一个不大的二维表，128个字符，取名<strong>ASCII</strong>（American
Standard Code for Information
Interchange）。128个码位（包括32个不能打印出来的控制符号）只占用了一个字节的后面7位，最前面的1位统一规定为0，其表示范围为<code>00000000-01111111</code>或<code>0x00-0x7F</code>。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ascii.gif" />
</div>
后来美国人发现128个字符不够用，于是在原来的二维表的基础上进行了扩展，利用ASCII编码字节中闲置的最高位，从而编入新的符号。这种扩展后的编码被称为<strong>EASCII</strong>（Extended
ASCII）。256个码位正好可以使用一个字节表示，其表示范围为<code>00000000-11111111</code>或<code>0x00-0xFF</code>。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/eascii.gif" />
</div>
<p>当计算机技术传递到欧洲后，美国的编码标准就不适用了，但是改改还能凑合。于是国际标准化组织在ASCII的基础上进行了扩展，形成了ISO-8859标准，跟EASCII类似，兼容ASCII，在高128个码位上有所区别。但是由于欧洲的语言环境十分复杂，所以根据各地区的语言又形成了很多子标准，如ISO-8859-1、ISO-8859-2、ISO-8859-3，......，ISO-8859-16等等。</p>
<h2 id="非ascii">非ASCII</h2>
<p>单个字节表示256个字符的ASCII系编码，对于欧洲各国的语言尚可表示，然而，对于亚洲地区的语言来说则远远不够，中国的汉字就多达10万左右。因此，就必须使用多个字节表示一个字符。为此在，亚洲地区又出现了很多编码，大陆的GB2312和GBK（GB2312的扩展，Kuozhan）、港台的BIG5、日本的Shift
JIS等等。例如，GB2312编码使用两个字节表示一个汉字，所以理论上最多可以表示65536个汉字。</p>
<h2 id="unicode">Unicode</h2>
<p>当互联网席卷了全球，地域限制被打破了，不同国家和地区的计算机在交换数据的过程中，一旦使用不同的字符编码就会出现乱码的问题。要彻底解决这个问题，就必须使用一个通用的字符集<strong>UCS</strong>（Universal
Character Set）和一个通用的字符编码<strong>Unicode</strong>。</p>
<h1 id="unicode-1">Unicode</h1>
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么就可以彻底解决乱码问题。这就是Unicode，就像它的名字一样，这是一种所有符号的编码。</p>
<p>Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字"严"。具体的符号对应表，可以查询<a
href="http://www.unicode.org/">unicode.org</a>，或者专门的<a
href="http://www.chi2ko.com/tool/CJK.htm">汉字对应表</a>。</p>
<blockquote>
<p>Unicode只是一个符号集，只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p>
</blockquote>
<h2 id="问题">问题</h2>
<p>事实上，Unicode在实现上存在两个需要解决的问题： &gt; (1)
如果采用多字节定长存储，则面临着极大的存储空间浪费以及字符集扩展问题。如：单字节的ASCII编码将浪费大量存储空间。<br />
&gt; (2)
如果采用多字节非定长存储，则面临着不定长编码的识别问题。即，如何知道一个编码使用了多少字节。</p>
<p>目前，有三种被广泛认知的Unicode实现方式：<strong>UTF-8</strong>，<strong>UTF-16</strong>（字符用两个字节或四个字节表示），<strong>UTF-32</strong>（字符用四个字节表示）。然而只有UTF-8有效地解决了上述两个问题，使得其成为目前最广泛的Unicode实现方式。</p>
<h2 id="utf-8">UTF-8</h2>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8的编码规则很简单，只有二条： &gt; (1)
对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br />
&gt; (2)
对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>下表总结了UTF-8编码规则，字母x表示可用编码的位。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Unicode符号范围(十六进制)</th>
<th style="text-align: left;">UTF-8编码方式(二进制)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0000-0000-0000-007F</td>
<td style="text-align: left;">0xxxxxxx</td>
</tr>
<tr class="even">
<td style="text-align: left;">0000-0080-0000-07FF</td>
<td style="text-align: left;">110xxxxx 10xxxxxx</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0000-0800-0000-FFFF</td>
<td style="text-align: left;">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr class="even">
<td style="text-align: left;">0001-0000-0010-FFFF</td>
<td style="text-align: left;">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>UTF-8的编码规则：如果第一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字符。</p>
<p>下面，还是以汉字"严"为例，演示如何实现UTF-8编码。<br />
已知"严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000
0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx
10xxxxxx
10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码是"11100100
10111000 10100101"，转换成十六进制就是E4B8A5。</p>
<h1 id="历史">历史</h1>
<ul>
<li>ASCII
<ul>
<li>1960 开发</li>
<li>1963 发布</li>
<li>1986 最后一次更新</li>
</ul></li>
<li>ISO-8859-1
<ul>
<li>1998 发布</li>
</ul></li>
<li>GB2312
<ul>
<li>1980 发布</li>
</ul></li>
<li>GBK
<ul>
<li>1993 发布</li>
</ul></li>
<li>UCS-2
<ul>
<li>In the late 1980s</li>
</ul></li>
<li>Unicode
<ul>
<li>1987 开发</li>
<li>1991 发布</li>
<li>1996 实现代理机制（UTF-16）</li>
<li>2015 最新版8.0</li>
</ul></li>
<li>UTF-8
<ul>
<li>1993 发布</li>
<li>2008 流行</li>
</ul></li>
<li>UTF-16
<ul>
<li>1996 开发</li>
<li>2000 发布</li>
</ul></li>
</ul>
根据以上各个编码发展的一些时间节点，再配合下图UTF-8制霸互联网过程，会有一个比较清晰的了解。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/utf-8.png" />
</div>
<p>(完)</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="http://www.jianshu.com/p/bd7a6c508c33">字符，字符集，字符编码</a><br />
</li>
<li><a
href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode和UTF-8</a></li>
<li><a href="http://www.unicode.org/">The Unicode Consortium</a><br />
</li>
<li><a
href="http://www.chi2ko.com/tool/CJK.htm">字体编辑用中日韩Unicode编码表</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>Chisel手册</title>
    <url>/2016/12/18/chisel-manual/</url>
    <content><![CDATA[<p><a
href="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/chisel-manual.pdf">原文链接</a></p>
<h1 id="introduce">Introduce</h1>
<p>本文档是Chisel的手册（在Scala嵌入语言中构建硬件）。Chisel是嵌入在高级编程语言Scala中的硬件构造语言。单独的Chisel教程文档提供了使用Chisel的简单介绍，建议首先阅读。本手册提供了Chisel语言的全面概述和规范，它只是一组特殊的类定义，预定义对象和Scala中的使用约定。当你写一个Chisel程序时，你实际上是在写一个Scala程序。在本手册中，我们假设您已经了解了Scala的基础知识。如果你不熟悉Scala，我们建议你参考一本优秀的Scala书。</p>
<span id="more"></span>
<h1 id="nodes">Nodes</h1>
<p>Chisel中任何硬件设计最终都由节点对象的图表表示。Chisel中的用户代码生成此节点图，然后将其传递到Chisel后端以转换为Verilog或C
++代码。节点定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">// name assigned by user or from introspection var name: String = &quot;&quot;</span></span><br><span class="line">	<span class="comment">// incoming graph edges</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inputs</span></span>: <span class="type">ArrayBuffer</span>[<span class="type">Node</span>]</span><br><span class="line">	<span class="comment">// outgoing graph edges</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">consumers</span></span>: <span class="type">ArrayBuffer</span>[<span class="type">Node</span>]</span><br><span class="line">	<span class="comment">// node specific width inference</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inferWidth</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="comment">// get width immediately inferrable</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getWidth</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="comment">// get first raw node</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getRawNode</span></span>: <span class="type">Node</span></span><br><span class="line">	<span class="comment">// convert to raw bits</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBits</span></span>: <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// convert to raw bits</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fromBits</span></span>(x: <span class="type">Bits</span>): <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// return lit value if inferrable else null def litOf: Lit</span></span><br><span class="line">	<span class="comment">// return value of lit if litOf is non null</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">litValue</span></span>(<span class="keyword">default</span>: <span class="type">BigInt</span> = <span class="type">BigInt</span>(<span class="number">-1</span>)): <span class="type">BigInt</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点类层次结构的最高级别如图所示。基本类别是：</p>
<ul>
<li><strong>Lit</strong>: 常量或文本<br />
</li>
<li><strong>Op</strong>: 逻辑或算术操作<br />
</li>
<li><strong>Updateable</strong>: 条件更新节点<br />
</li>
<li><strong>Data</strong>: 具有类型的wire或port<br />
</li>
<li><strong>Reg</strong>: 上升沿触发的寄存器<br />
</li>
<li><strong>Mem</strong>: 存储<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-node.png" />
</div></li>
</ul>
<h1 id="lits">Lits</h1>
<p>原始文本表示为Lit节点，定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lit</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="comment">// original value</span></span><br><span class="line">	<span class="keyword">val</span> inputVal: <span class="type">BigInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原始文本包含位的集合。用户不直接创建原始文本，而是使用第Type节中定义的类型构造函数。</p>
<h1 id="ops">Ops</h1>
<p>原始操作表示为如下定义的Op节点：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Op</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="comment">// op name used during emission </span></span><br><span class="line">	<span class="keyword">val</span> op: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Ops计算其输入的组合函数。</p>
<h1 id="types">Types</h1>
表示硬件设计的Chisel图包含原始节点和类型节点。Chisel类型系统与底层Scala类型系统分开维护，因此类型节点散布在原始节点之间，以允许Chisel检查并响应Chisel类型。Chisel类型节点在硬件设计转换为C
++或Verilog之前被擦除。getRawNode运算符定义在基本Node类中，跳过类型节点并返回找到的第一个原始节点。下图显示了内置的Chisel类型层次结构，其中Data为最顶层节点。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-type.png" />
</div>
<p>内置标量类型包括Bool，SInt和UInt和内置聚合类型Bundle和Vec允许用户使用其他类型的集合扩展Chisel数据类型集。<br />
Data自身就是一个节点：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cloneType</span></span>(): <span class="keyword">this</span>.<span class="keyword">type</span> =</span><br><span class="line">		<span class="keyword">this</span>.getClass.newInstance.asInstanceOf[<span class="keyword">this</span>.<span class="keyword">type</span>]</span><br><span class="line">	<span class="comment">// simple conversions</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toSInt</span></span>: <span class="type">SInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toUInt</span></span>: <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBool</span></span>: <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">toBits</span></span>: <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// flatten out to leaves of tree </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Data</span>)] </span><br><span class="line">	<span class="comment">// port direction if leaf</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">dir</span></span>: <span class="type">PortDir</span></span><br><span class="line">	<span class="comment">// change dir to OUTPUT </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asOutput</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span> </span><br><span class="line">	<span class="comment">// change dir to INPUT </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asInput</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// change polarity of dir </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">flip</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">	<span class="comment">// assign to input</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> </span>:=[<span class="type">T</span> &lt;: <span class="type">Data</span>](t: <span class="type">T</span>) </span><br><span class="line">	<span class="comment">// bulk assign to input </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;&gt;</span></span>(t: <span class="type">Data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Data类具有用于在类型之间转换和将端口方法委托给其单个输入的方法。我们将在Port一节讨论端口。最后，用户可以在其自己的类型节点（例如bundle）中覆盖cloneType方法，以便反映克隆所需的构造参数。<br />
Data节点可以用于四种目的：</p>
<ul>
<li><strong>types</strong>: UInt(width = 8),
在指定最小位宽的图中记录中间类型（在本节中描述）<br />
</li>
<li><strong>wires</strong>: UInt(width = 8),
作为数据的前向声明，允许将来的条件更新（在Updateable一节中描述）<br />
</li>
<li><strong>ports</strong>: UInt(dir = OUTPUT, width = 8),
定义模块接口的专用线，还能指定方向（在Ports一节中描述）<br />
</li>
<li><strong>literals</strong>: UInt(1) 或 UInt(1, 8),
可以使类型对象构造函数来构造其值和可选宽度。</li>
</ul>
<h2 id="bits">Bits</h2>
<p>在Chisel中，位的原始集合如下Bits类型定义所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bits</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// create literal from BigInt or Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// create literal from String using</span></span><br><span class="line">	<span class="comment">// base_char digit+ string format</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">Bits</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bits</span> <span class="keyword">extends</span> <span class="title">Data</span> <span class="keyword">with</span> <span class="title">Updateable</span> </span>&#123; </span><br><span class="line">	<span class="comment">// bitwise-not</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_~</span></span>(): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// bitwise-and</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// bitwise-or</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">|</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// bitwise-xor</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">^</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// and-reduction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">andR</span></span>(): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// or-reduction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">orR</span></span>(): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// xor-reduction def xorR(): Bool </span></span><br><span class="line">	<span class="comment">// logical NOT</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span></span>(): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical AND</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;&amp;</span> </span>(b: <span class="type">Bool</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical OR</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">||</span> </span>(b: <span class="type">Bool</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// equality</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">===</span></span>(b: <span class="type">Bits</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// inequality</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">!=</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// logical left shift </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;&lt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// logical right shift </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">Bits</span> </span><br><span class="line">	<span class="comment">// concatenate</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">##</span> </span>(b: <span class="type">Bits</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// extract single bit, LSB is 0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// extract bit field from end to start bit pos </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(hi: <span class="type">Int</span>, lo: <span class="type">Int</span>): <span class="type">Bits</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Cat</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elt: <span class="type">T</span>, elts: <span class="type">T</span>*): <span class="type">Bits</span></span><br></pre></td></tr></table></figure></p>
<p>Bits具有用于简单位操作的方法。注意，##是二进制连接，而Cat是一个正则拼接。为了避免与Scala的内置==冲突，Chisel的按位比较命名为===。<br />
使用Fill可以创建n位宽的域：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fill</span></span>(n: <span class="type">Int</span>, field: <span class="type">Bits</span>): <span class="type">Bits</span></span><br></pre></td></tr></table></figure></p>
<p>一个两输入的选择器可以使用Mux：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Bits</span>, cons: <span class="type">T</span>, alt: <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure></p>
<p>常量或字面值使用Scala整数或传递给构造函数的字符串表示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;ha&quot;</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;o12&quot;</span>)</span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;b1010&quot;</span>) <span class="comment">// binary 4-bit lit from string.</span></span><br></pre></td></tr></table></figure></p>
如下图所示的最左边子图，可以产生Lit。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-op-lit-graph.png" />
</div>
<p>操作返回一个实际的操作符节点和类型节点组合成输入类型节点。参见上图，了解更复杂的例子。</p>
<h2 id="bools">Bools</h2>
<p>布尔值用Bools表示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">Boolean</span>): <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bool</span> <span class="keyword">extends</span> <span class="title">UInt</span></span></span><br></pre></td></tr></table></figure></p>
<p>Bool与UInt(width = 1)相等。</p>
<h2 id="nums">Nums</h2>
<p>Num是一个类型节点，定义了算术运算：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span> <span class="keyword">extends</span> <span class="title">Bits</span> </span>&#123; </span><br><span class="line">	<span class="comment">// Negation</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">unary_-</span></span>(): <span class="type">Bits</span></span><br><span class="line">	<span class="comment">// Addition</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Subtraction</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">-</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Multiplication </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(b: <span class="type">Num</span>): <span class="type">Num</span> </span><br><span class="line">	<span class="comment">// Greater than</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="comment">// Less than</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// Less than or equal </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="comment">// Greater than or equal </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(b: <span class="type">Num</span>): <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有符号和无符号整数被认为是定点数的子集，并且分别由类型SInt和UInt表示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span></span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">SInt</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SInt</span> <span class="keyword">extends</span> <span class="title">Num</span> <span class="title">object</span> <span class="title">UInt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(dir: <span class="type">PortDir</span> = <span class="literal">null</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="comment">// create literal</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">BigInt</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(value: <span class="type">String</span>, width: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">UInt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UInt</span> <span class="keyword">extends</span> <span class="title">Num</span> </span>&#123;</span><br><span class="line">	<span class="comment">// arithmetic right shift override </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&gt;&gt;</span> </span>(b: <span class="type">UInt</span>): <span class="type">SInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 带符号的定点数（包括整数）使用二进制补码格式表示。</p>
<h2 id="bundles">Bundles</h2>
<p>Bundle将几种不同类型的命名字段组合成一个连续单元，非常像C中的struct：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="comment">// shallow named bundle elements</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">elements</span></span>: <span class="type">ArrayBuffer</span>[(<span class="type">String</span>, <span class="type">Data</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用elements方法可以获取Bundle中每个元素的名称和类型，flatten方法返回嵌套聚合的叶子处的元素。
用户可以通过对bundle进行子类化来定义新的bundle，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFloat</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> sign = <span class="type">Bool</span>()</span><br><span class="line">	<span class="keyword">val</span> exponent = <span class="type">UInt</span>(width = <span class="number">8</span>) </span><br><span class="line">	<span class="keyword">val</span> significand = <span class="type">UInt</span>(width = <span class="number">23</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>元素通过Scala字段访问：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">MyFloat</span>() </span><br><span class="line"><span class="keyword">val</span> xs = x.sign</span><br></pre></td></tr></table></figure></p>
<p>当使用C++或Verilog后端发送时，bundle的元素的名称是从它们的bundle字段名获取的，使用Scala内省。</p>
<h2 id="vecs">Vecs</h2>
<p>Vecs可以创建可索引元素向量：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Vec</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elts: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">Vec</span>[<span class="type">T</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](elt0: <span class="type">T</span>, elts: <span class="type">T</span>*): <span class="type">Vec</span>[<span class="type">T</span>] </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fill</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n: <span class="type">Int</span>)	(gen: =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">T</span>] </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tabulate</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n: <span class="type">Int</span>)(gen: (<span class="type">Int</span>) =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">T</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tabulate</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](n1: <span class="type">Int</span>, n2: <span class="type">Int</span>) (gen: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">T</span>): <span class="type">Vec</span>[<span class="type">Vec</span>[<span class="type">T</span>]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">n: <span class="type">Int</span>, val gen: (</span>) <span class="title">=&gt;</span> <span class="title">T</span>) <span class="keyword">extends</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">Int</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">forall</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">Bool</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](x: <span class="type">T</span>): <span class="type">Bool</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">indexWhere</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">lastIndexWhere</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Bool</span>): <span class="type">UInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中n个元素类型由gen定义。用户可以使用Int索引静态访问元素或使用UInt索引动态访问元素，其中动态访问创建一个虚拟类型节点（表示读取“端口”），该节点使用给定地址记录读取。在任一情况下，用户可以连线到读取的结果如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">v(a) := d</span><br></pre></td></tr></table></figure></p>
<p>只读存储器可以使用Vecs来表示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rom = <span class="type">Vec</span>(<span class="type">UInt</span>(<span class="number">3</span>), <span class="type">UInt</span>(<span class="number">7</span>), <span class="type">UInt</span>(<span class="number">4</span>), <span class="type">UInt</span>(<span class="number">0</span>)) &#123; <span class="type">UInt</span>(width=<span class="number">3</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> dout = rom(addr)</span><br></pre></td></tr></table></figure></p>
<h2 id="bit-width-inference">Bit Width Inference</h2>
用户需要设置端口和寄存器的位宽度，否则节点上的位宽度会自动推断，除非用户手动设置（使用Extract或Cat）。位宽推理引擎从图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png" />
</div>
<p>其中例如wz是线z的位宽度，并且＆规则应用于所有按位逻辑运算。</p>
<p>位宽推理过程继续，直到没有位宽改变。除了固定位数的右移之外，位宽度推断规则规定输出位宽不能小于输入位宽度，因此，输出位宽度增长或保持相同。此外，寄存器的宽度必须由用户明确地或从复位值的位宽指定。从这两个要求，我们可以知道位宽推理过程将收敛到一个固定点。</p>
<h1 id="updateables">Updateables</h1>
<p>当描述线和状态节点的操作时，将规范作为输出值的一系列条件更新并且跨多个单独的语句分布这些更新通常是有用的。例如，可以立即引用数据节点的输出，但可以稍后设置其输入。可更新表示一个条件可更新节点，其累积对节点的访问，并且其稍后可以生成多路复用器以在电路中组合这些访问。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Updateable</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="comment">// conditional reads</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reads</span></span>: <span class="type">Queue</span>[(<span class="type">Bool</span>, <span class="type">UInt</span>)]</span><br><span class="line">	<span class="comment">// conditional writes</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">writes</span></span>: <span class="type">Queue</span>[(<span class="type">Bool</span>, <span class="type">UInt</span>, <span class="type">Node</span>)]</span><br><span class="line">	<span class="comment">// gen mux integrating all conditional writes </span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">genMuxes</span></span>(<span class="keyword">default</span>: <span class="type">Node</span>)</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> </span>:= (x: <span class="type">Node</span>): <span class="keyword">this</span>.<span class="keyword">type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">when</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(cond: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>): when</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">when</span> (<span class="params">prevCond: <span class="type">Bool</span></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">elsewhen</span> </span>(cond: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>): when </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">otherwise</span> </span>(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>when操作具有动态作用域的全局条件堆栈。因此，when创建一个在条件函数调用中有效的新条件。例如：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateWhen</span> </span>(c: <span class="type">Bool</span>, d: <span class="type">Data</span>) = </span><br><span class="line">	when (c) &#123; r := d &#125;</span><br><span class="line">when (a) &#123; </span><br><span class="line">	updateWhen(b, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (a) &#123;</span><br><span class="line">	when (b) &#123; r := x &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel为其他常见形式的条件更新提供了一些语法糖：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unless</span></span>(c: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>) = </span><br><span class="line">	when (!c) &#123; block )</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">otherwise</span></span>(block: =&gt; <span class="type">Unit</span>) = </span><br><span class="line">	when (<span class="type">Bool</span>(<span class="literal">true</span>)) &#123; block &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再介绍用于条件更新的switch语句，其涉及对一个公共密钥的一系列比较：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch</span></span>(c: <span class="type">UInt</span>)(block: =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is</span></span>(v: <span class="type">Bool</span>)(block: =&gt; <span class="type">Unit</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="forward-declaration">Forward Declaration</h1>
<p>纯组合电路不允许在节点之间有循环，如果检测到这样的循环，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建法向组合电路，通过添加其输入从已经定义的节点导出的新节点。
时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前参考输出线。因为Scala按顺序执行程序语句，所以我们允许数据节点用作提供节点声明的线，可：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> pcPlus4 = <span class="type">UInt</span>() </span><br><span class="line"><span class="keyword">val</span> brTarget = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> pcNext	= <span class="type">Mux</span>(pcSel, brTarget, pcPlus4)</span><br><span class="line"><span class="keyword">val</span> pcReg	= <span class="type">RegUpdate</span>(pcNext)</span><br><span class="line">pcPlus4  := pcReg + <span class="type">UInt</span>(<span class="number">4</span>)</span><br><span class="line">... </span><br><span class="line">brTarget := addOut</span><br></pre></td></tr></table></figure></p>
<p>接线操作符：=用于在pcReg和addOut定义之后进行连接。在所有赋值完成后，如果前向声明未分配，则是一个错误。...</p>
<h1 id="regs">Regs</h1>
<p>Chisel支持的状态元素的最简单形式是一个正边沿触发寄存器，定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Reg</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (data: <span class="type">T</span>, next: <span class="type">T</span> = <span class="literal">null</span>, init: <span class="type">T</span> = <span class="literal">null</span>): <span class="type">T</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RegNext</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (next: <span class="type">T</span>, init: <span class="type">T</span> = <span class="literal">null</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RegInit</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (init: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reg</span> <span class="keyword">extends</span> <span class="title">Updateable</span></span></span><br></pre></td></tr></table></figure> 可以如下进行构造：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> r1 = <span class="type">RegUpdate</span>(io.in)</span><br><span class="line"><span class="keyword">val</span> r2 = <span class="type">RegReset</span>(<span class="type">UInt</span>(<span class="number">1</span>, <span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> r3 = <span class="type">RegUpdate</span>(io.in, <span class="type">UInt</span>(<span class="number">1</span>)) </span><br><span class="line"><span class="keyword">val</span> r4 = <span class="type">Reg</span>(<span class="type">UInt</span>(width = <span class="number">8</span>))</span><br></pre></td></tr></table></figure></p>
<p>其中resetVal是reset为ture时用于寄存器的值。</p>
<h1 id="mems">Mems</h1>
<p>Chisel通过Mem结构支持随机存取存储器。写入Mem是正边沿触发，读取是组合或正边沿触发。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](depth: <span class="type">Int</span>, gen: =&gt; <span class="type">T</span>, seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: (</span>) <span class="title">=&gt;</span> <span class="title">T</span>, <span class="title">depth</span></span>: <span class="type">Int</span>, seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">extends</span> <span class="type">Updateable</span> &#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过应用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32个条目的寄存器文件可以表示如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rf = <span class="type">Mem</span>(<span class="number">32</span>, <span class="type">UInt</span>(width = <span class="number">64</span>)) </span><br><span class="line">when (wen) &#123; rf(waddr) := wdata &#125; </span><br><span class="line"><span class="keyword">val</span> dout1 = rf(waddr1)</span><br><span class="line"><span class="keyword">val</span> dout2 = rf(waddr2)</span><br></pre></td></tr></table></figure></p>
<p>如果设置了可选参数seqRead，当Reg分配了Mem的输出时，Chisel将尝试推断顺序读端口。单读，单写SRAM可以描述如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1r1w = <span class="type">Mem</span>(<span class="number">1024</span>, <span class="type">UInt</span>(width = <span class="number">32</span>), seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> dout = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1r1w(waddr) := wdata &#125; </span><br><span class="line">when (ren) &#123; dout := ram1r1w(raddr) &#125;</span><br></pre></td></tr></table></figure></p>
<p>单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1p =</span><br><span class="line"><span class="type">Mem</span>(<span class="number">1024</span>, <span class="type">UInt</span>(width = <span class="number">32</span>), seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> dout = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1p(waddr) := wdata &#125; </span><br><span class="line">.elsewhen (ren) &#123; dout := ram1p(raddr) &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据是实现定义的。<br />
Mem还支持子字写入的写掩码。如果相应的屏蔽位置1，则写入给定位。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ram = <span class="type">Mem</span>(<span class="number">256</span>, <span class="type">UInt</span>(width = <span class="number">32</span>))</span><br><span class="line">when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ports">Ports</h1>
<p>端口是用作硬件模块接口的Data派生节点。端口是原始Data对象的定向版本。端口方向定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PortDir</span></span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">INPUT</span> <span class="keyword">extends</span> <span class="title">PortDir</span> </span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OUTPUT</span> <span class="keyword">extends</span> <span class="title">PortDir</span></span></span><br></pre></td></tr></table></figure></p>
<p>聚合端口可以使用vec或bundle的实例作为叶子递归构造。</p>
<h1 id="modules">Modules</h1>
<p>在Chisel中，module与Verilog中的module非常相似，在生成电路中定义了层次结构。分层模块命名空间可在下游工具中访问，以帮助调试和物理布局。用户定义的模块被定义为一个类：<br />
- 继承自Module<br />
- 包含一个接口Bundle，其存储在一个名为io的域中<br />
- 在其构造器中将子电路连接起来</p>
<p>用户通过子类化Module来编写自己的模块，其定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io: <span class="type">Bundle</span></span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compileV</span></span>: <span class="type">Unit</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compileC</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并定义自己的io字段。例如，要定义一个两输入多路复用器，我们将定义一个模块如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	io.out := (io.sel &amp; io.in1) | (~io.sel &amp; io.in0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>:=赋值运算符，在模块定义的主体中使用，是Chisel中的一个特殊运算符，它将左侧的输入连接到右侧的输出。它通常用于将输出端口连接到其定义。</p>
<p>&lt;&gt;操作符批量连接父对象模型之间的对等相反接口或父/子模块之间相同的接口。批量连接使用路径名匹配连接叶子端口。仅当其中一个端口非空时允许连接，从而允许用户重复地批量连接部分填充的接口。在所有连接完成并且电路正在精心设计后，Chisel警告用户端口是否只有一个到它们的连接。</p>
<p>当使用C++或Verilog后端发送时，存储在模块中的节点和子模块的名称可以使用Scala内省从它们的模块字段名称中获取。使用函数setName()设置节点或子模块的名称。</p>
<h1 id="black-box">Black Box</h1>
<p>黑盒允许用户定义接口到Chisel之外定义的电路。用户定义：</p>
<ul>
<li>一个BlackBox子类的模块<br />
</li>
<li>一个带有接口的io<br />
</li>
<li>可选的VerilogParameters子类</li>
</ul>
<p>例如，可以将简单的ROM黑盒定义为：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isVal = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> raddr = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> rdata = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">32</span>) </span><br><span class="line">	raddr.setName(<span class="string">&quot;RADDR&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomParams</span> <span class="keyword">extends</span> <span class="title">VerilogParameters</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> <span class="type">MY_STR</span> = <span class="string">&quot;Test&quot;</span></span><br><span class="line">	<span class="keyword">val</span> <span class="type">MY_INT</span> = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rom</span> <span class="keyword">extends</span> <span class="title">BlackBox</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">RomIo</span>()</span><br><span class="line">	<span class="keyword">val</span> romParams = <span class="keyword">new</span> <span class="type">RomParams</span>() </span><br><span class="line">	setVerilogParameters(romParams) 	</span><br><span class="line">	renameClock(<span class="type">Driver</span>.implicitClock, <span class="string">&quot;clock_A&quot;</span>)</span><br><span class="line">	renameClock(<span class="string">&quot;my_other_clock&quot;</span>, <span class="string">&quot;test_clock&quot;</span>) </span><br><span class="line">	renameReset(<span class="string">&quot;rst&quot;</span>)</span><br><span class="line">	<span class="comment">// Define how to use in simulation here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数将转换为verilog参数，其中包含类定义中使用的名称和值。setVerilogParameters也可以直接接受一个字符串。函数renameClock可以获取Clock对象或时钟的字符串名称来重命名BlackBox输出时钟。函数renameReset将重命名隐式重置。如果需要命名其他重置，请调用setName()。在io类中显示了使用setName()的示例。而不是被称为io_raddr为黑箱的io，它将是RADDR。黑盒在c模拟中作为一个模块。这意味着您可以使用io实现BlackBox的功能，以便您可以验证您的设计。</p>
<h1 id="printf-sprintf">Printf &amp; Sprintf</h1>
<p>Chisel提供了为调试目的格式化和打印字符串的能力。printf和sprintf结构与它们的C名称类似：它们取一个格式字符串和可变数量的参数，然后分别打印或返回一个字符串。在模拟期间，printf在上升时钟沿将控制字符串打印到控制台。另一方面，sprintf返回格式化的字符串作为位向量。</p>
<p>支持的格式说明符是％b（二进制数），％d（十进制数），％x（十六进制数）和％s（由8位扩展ASCII字符序列组成的字符串）。%%指定文字％。）与C不同，没有宽度修饰符：相应参数的位宽决定了字符串表示中的宽度。</p>
<p>以下示例在c为true时打印“0x4142 16706 AB”行：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Bits</span>(<span class="number">0x4142</span>)</span><br><span class="line"><span class="keyword">val</span> s1 = sprintf(<span class="string">&quot;%x %s&quot;</span>, x, x);</span><br><span class="line">when (c) &#123; printf(<span class="string">&quot;%d %s\n&quot;</span>, x, s1); &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="assert">Assert</h1>
<p>运行时断言由assert结构提供。在仿真期间，如果断言的论点在上升时钟边沿为false，则会打印错误并终止仿真。例如，以下将在十个时钟周期后终止仿真：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">4</span>)) </span><br><span class="line">x := x + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">assert(x &lt; <span class="type">UInt</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="main-testing">Main &amp; Testing</h1>
<p>为了构造一个电路，用户从它们的顶层main函数调用chiselMain：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>): <span class="type">T</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行以上对象会在--targetDir
dir_name参数指定的目录下生成module_name.cpp和module_name.h C++文件。</p>
<p>测试是电路设计的一个关键部分，因此在Chisel中，我们提供了一种测试电路的机制，通过使用Tester类的子类在Scala中提供测试向量：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>[<span class="type">T</span> &lt;: <span class="type">Module</span>] (<span class="params">val c: <span class="type">T</span>, val isTrace: <span class="type">Boolean</span> = true</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> ok: <span class="type">Boolean</span></span><br><span class="line">	<span class="keyword">val</span> rnd: <span class="type">Random</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Boolean</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Int</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(n: <span class="type">Int</span> = <span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pokeAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>, x: <span class="type">BigInt</span>) </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Bits</span>, x: <span class="type">BigInt</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Aggregate</span>, x: <span class="type">Array</span>[<span class="type">BigInt</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peekAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Aggregate</span>): <span class="type">Array</span>[<span class="type">BigInt</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(good: <span class="type">Boolean</span>, msg: <span class="type">String</span>): <span class="type">Boolean</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(data: <span class="type">Bits</span>, target: <span class="type">BigInt</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户利用：<br />
- <strong>poke</strong>: 设置端口和状态值<br />
- <strong>step</strong>: 以一个时间单位执行电路<br />
- <strong>peek</strong>: 读端口和状态值<br />
- <strong>expect</strong>: 比较测试电路的值和预期的值</p>
<p>用户通过如下方式连接tester实例和模块：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMainTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>)( </span><br><span class="line">		tester: <span class="type">T</span> =&gt; <span class="type">Tester</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
当--test作为chiselMain的参数时，tester实例在单独的进程中运行被测设计（DUT），stdin和stdout连接，以便调试命令可以发送到DUT，并且响应可以从DUT如图所示。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png" />
</div>
<p>如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2Tests</span>(<span class="params">c: <span class="type">Mux2</span></span>) <span class="keyword">extends</span> <span class="title">Tester</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> n = pow(<span class="number">2</span>, <span class="number">3</span>).toInt</span><br><span class="line">	<span class="keyword">for</span> (s &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i0 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123; </span><br><span class="line">			<span class="keyword">for</span> (i1 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">				poke(c.io.sel, s)</span><br><span class="line">				poke(c.io.in1, i1)</span><br><span class="line">				poke(c.io.in0, i0)</span><br><span class="line">				step(<span class="number">1</span>)</span><br><span class="line">				expect(c.io.out, (<span class="keyword">if</span> (s == <span class="number">1</span>) i1 <span class="keyword">else</span> i0))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用poke将Mux2的每个输入的分配设置为适当的值。对于这个特定的例子，我们通过将输入硬编码到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块的适当输入，并告诉模拟将这些值分配给我们正在测试的器件的输入c，步骤电路和测试期望值。最后，下面显示了如何调用测试器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">chiselMainTest(args + <span class="string">&quot;--test&quot;</span>, () =&gt; <span class="keyword">new</span> <span class="type">Mux2</span>())&#123; </span><br><span class="line">	c =&gt; <span class="keyword">new</span> <span class="type">Mux2Tests</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，chiselMain*有以下命令参数：<br />
&gt; --targetDir 目标路径前缀<br />
&gt; --genHarness 生成C++文件 &gt; --debug 把所有wire放入C++类文件中
&gt; --compile 编译生成的C++ &gt; --test 使用C++应用运行测试 &gt;
--backend v 产生verilog &gt; --backend c 产生C++（默认） &gt; --vcd
使能vcd打印</p>
<h1 id="c-emulator">C++ Emulator</h1>
<p>C ++仿真器基于使用C ++模板的快速多字库。
单个字由val_t定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">typedef uint64_t val_t; </span><br><span class="line">typedef int64_t sval_t; </span><br><span class="line">typedef uint32_t half_val_t;</span><br></pre></td></tr></table></figure></p>
<p>多字由dat_t定义，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">template &lt;int w&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dat_t</span> </span>&#123;</span><br><span class="line">	public:</span><br><span class="line">		const static int n_words;</span><br><span class="line">		<span class="keyword">inline</span> int width ( void );</span><br><span class="line">		<span class="keyword">inline</span> int n_words_of ( void );</span><br><span class="line">		<span class="keyword">inline</span> bool to_bool ( void );</span><br><span class="line">		<span class="keyword">inline</span> val_t lo_word ( void );</span><br><span class="line">		<span class="keyword">inline</span> unsigned long to_ulong ( void ); </span><br><span class="line">		std::string to_str ();</span><br><span class="line">		dat_t&lt;w&gt; ();</span><br><span class="line">template &lt;int sw&gt;</span><br><span class="line">	dat_t&lt;w&gt; (const dat_t&lt;sw&gt;&amp; src); </span><br><span class="line">	dat_t&lt;w&gt; (const dat_t&lt;w&gt;&amp; src); </span><br><span class="line">	dat_t&lt;w&gt; (val_t <span class="keyword">val</span>);</span><br><span class="line">template &lt;int sw&gt;</span><br><span class="line">	dat_t&lt;w&gt; mask(dat_t&lt;sw&gt; fill, int n);</span><br><span class="line">template &lt;int dw&gt; </span><br><span class="line">	dat_t&lt;dw&gt; mask(int n);</span><br><span class="line">template &lt;int n&gt;</span><br><span class="line">	dat_t&lt;n&gt; mask(void);</span><br><span class="line">	dat_t&lt;w&gt; operator + ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator - ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator - ( );</span><br><span class="line">	dat_t&lt;w+w&gt; operator * ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; fix_times_fix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; ufix_times_fix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w+w&gt; fix_times_ufix( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &lt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &gt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &gt;= ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &lt;= ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; gt ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; gte ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; lt ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; lte ( dat_t&lt;w&gt; o );</span><br><span class="line">	dat_t&lt;w&gt; operator ^ ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &amp; ( dat_t&lt;w&gt; o );	</span><br><span class="line">	dat_t&lt;w&gt; operator | ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator ~ ( void);</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator ! ( void );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator &amp;&amp; ( dat_t&lt;<span class="number">1</span>&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator || ( dat_t&lt;<span class="number">1</span>&gt; o );</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator == ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator == ( datz_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; operator != ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &lt;&lt; ( int amount ); </span><br><span class="line">	dat_t&lt;w&gt; operator &lt;&lt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; operator &gt;&gt; ( int amount ); </span><br><span class="line">	dat_t&lt;w&gt; operator &gt;&gt; ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; rsha ( dat_t&lt;w&gt; o); </span><br><span class="line">	dat_t&lt;w&gt;&amp; operator = ( dat_t&lt;w&gt; o ); </span><br><span class="line">	dat_t&lt;w&gt; fill_bit(val_t bit); </span><br><span class="line">	dat_t&lt;w&gt; fill_byte(val_t byte, int nb, int n);</span><br><span class="line">template &lt;int dw, int n&gt;</span><br><span class="line">	dat_t&lt;dw&gt; fill( void );</span><br><span class="line">template &lt;int dw, int nw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; fill( dat_t&lt;nw&gt; n );</span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(); </span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(val_t e, val_t s); </span><br><span class="line">template &lt;int dw, int iwe, int iws&gt;</span><br><span class="line">	dat_t&lt;dw&gt; extract(dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s);</span><br><span class="line">template &lt;int sw&gt; </span><br><span class="line">	dat_t&lt;w&gt; inject(dat_t&lt;sw&gt; src, val_t e, val_t s); </span><br><span class="line">template &lt;int sw, int iwe, int iws&gt;</span><br><span class="line">	dat_t&lt;w&gt; inject (dat_t&lt;sw&gt; src, dat_t&lt;iwe&gt; e, dat_t&lt;iws&gt; s); </span><br><span class="line">template &lt;int dw&gt;</span><br><span class="line">	dat_t&lt;dw&gt; log2(); </span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; bit(val_t b); </span><br><span class="line">	val_t msb();</span><br><span class="line">template &lt;int iw&gt;</span><br><span class="line">	dat_t&lt;<span class="number">1</span>&gt; bit(dat_t&lt;iw&gt; b)</span><br><span class="line">&#125;</span><br><span class="line">template &lt;int w, int sw&gt; </span><br><span class="line">	dat_t&lt;w&gt; <span class="type">DAT</span>(dat_t&lt;sw&gt; dat);</span><br><span class="line">template &lt;int w&gt;</span><br><span class="line">	dat_t&lt;w&gt; <span class="type">LIT</span>(val_t value);</span><br><span class="line">template &lt;int w&gt; dat_t&lt;w&gt;</span><br><span class="line">	mux ( dat_t&lt;<span class="number">1</span>&gt; t, dat_t&lt;w&gt; c, dat_t&lt;w&gt; a )</span><br></pre></td></tr></table></figure></p>
<p>其中w是位宽参数。</p>
<p>Chisel编译器将顶层模块编译为可以创建和执行的单个扁平的mod_t类：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mod_t</span> </span>&#123; </span><br><span class="line">	public:</span><br><span class="line">		<span class="comment">// initialize module</span></span><br><span class="line">		virtual void init (void) &#123; &#125;;</span><br><span class="line">		<span class="comment">// compute all combinational logic</span></span><br><span class="line">		virtual void clock_lo (dat_t&lt;<span class="number">1</span>&gt; reset) &#123; &#125;; </span><br><span class="line">		<span class="comment">// commit state updates</span></span><br><span class="line">		virtual void clock_hi (dat_t&lt;<span class="number">1</span>&gt; reset) &#123; &#125;; </span><br><span class="line">		<span class="comment">// print printer specd node values to stdout </span></span><br><span class="line">		virtual void print (<span class="type">FILE</span>* f) &#123; &#125;;</span><br><span class="line">		<span class="comment">// scan scanner specd node values from stdin </span></span><br><span class="line">		virtual bool scan (<span class="type">FILE</span>* f) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;; </span><br><span class="line">		<span class="comment">// dump vcd file</span></span><br><span class="line">		virtual void dump (<span class="type">FILE</span>* f, int t) &#123; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Chisel编译器可以创建一个线束，或者用户可以自己写一个线束。以下是CPU模块的线束示例：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">#include <span class="string">&quot;cpu.h&quot;</span></span><br><span class="line">int main (int argc, char* argv[]) &#123;</span><br><span class="line">	cpu_t* c = <span class="keyword">new</span> cpu_t();</span><br><span class="line">	int lim = (argc &gt; <span class="number">1</span>) ? atoi(argv[<span class="number">1</span>]) : <span class="number">-1</span>; </span><br><span class="line">	c-&gt;init();</span><br><span class="line">	<span class="keyword">for</span> (int t = <span class="number">0</span>; lim &lt; <span class="number">0</span> || t &lt; lim; t++) &#123;</span><br><span class="line">		dat_t&lt;<span class="number">1</span>&gt; reset = <span class="type">LIT</span>&lt;<span class="number">1</span>&gt;(t == <span class="number">0</span>); </span><br><span class="line">		<span class="keyword">if</span> (!c-&gt;scan(stdin)) <span class="keyword">break</span>; </span><br><span class="line">		c-&gt;clock_lo(reset); </span><br><span class="line">		c-&gt;clock_hi(reset); </span><br><span class="line">		c-&gt;print(stdout);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="verilog">Verilog</h1>
<p>当-v参数传递到chiselMain时，Chisel生成Verilog。
例如，从SBT，以下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">run --v</span><br></pre></td></tr></table></figure></p>
<p>将在目标目录中生成名为module-name.v的单个Verilog文件。该文件将包含一个模块，每个模块定义为在chiselMain中创建的顶层模块的子模块。具有相同接口和主体的模块将被缓存和重用。</p>
<h1 id="multiple-clock-domains">Multiple Clock Domains</h1>
<h2 id="creating-clock-domains">Creating Clock domains</h2>
<p>为了使用多个时钟域，用户必须创建多个时钟。在Chisel中，时钟是用复位信号参数创建的一级节点，并定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> (<span class="params">reset: <span class="type">Bool</span></span>) <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>: <span class="type">Bool</span> <span class="comment">// returns reset pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Chisel中有一个内置的隐式时钟，状态元素默认使用：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitClock = <span class="keyword">new</span> <span class="type">Clock</span>( implicitReset )</span><br></pre></td></tr></table></figure></p>
<p>状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Reg</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Mem</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Module</span>(... clock: <span class="type">Clock</span> = implicitClock)</span><br></pre></td></tr></table></figure></p>
<h2 id="crossing-clock-domains">Crossing Clock Domains</h2>
<p>有两种方式可以定义电路在时钟域之间发送数据。第一种和最原始的方式是使用由两个寄存器组成的同步电路，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signalA is in clock domain clockA,</span></span><br><span class="line"><span class="comment">// want a version in clockB as signalB</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB) </span><br><span class="line"><span class="keyword">val</span> s2 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB)</span><br><span class="line">s1 := signalA</span><br><span class="line">s2 := s1;</span><br><span class="line">signalB := s2</span><br></pre></td></tr></table></figure></p>
<p>由于亚稳性问题，该技术限于在域之间传递一位数据。</p>
<p>在域之间发送数据的第二种更一般的方式是通过使用异步fifo：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncFifo</span>[<span class="type">T</span>&lt;:<span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, enq_clk: <span class="type">Clock</span>, deq_clock: <span class="type">Clock</span></span>)</span></span><br><span class="line">	<span class="keyword">extends</span> <span class="type">Module</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以通过指定标准fifo参数和两个时钟，然后使用标准去耦就绪/有效信号，从时钟频率A到时钟B获得一个版本的signalA：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> fifo = <span class="keyword">new</span> <span class="type">AsyncFifo</span>(<span class="type">Uint</span>(width = <span class="number">32</span>), <span class="number">2</span>, clockA, clockB)</span><br><span class="line">fifo.io.enq.bits := signalA</span><br><span class="line">signalB := fifo.io.deq.bits </span><br><span class="line">fifo.io.enq.valid := condA </span><br><span class="line">fifo.io.deq.ready := condB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="backend-specific-multiple-clock-domains">Backend Specific
Multiple Clock Domains</h2>
<p>时钟域可以以域特定的方式映射到C++和Verilog后端。为了展示如何驱动多时钟设计，考虑硬件示例，其中两个模块使用AsyncFifo进行通信，每个模块在不同的时钟：fastClock和slowClock。</p>
<h3 id="c">C++</h3>
<p>在C ++后端，对于每个时钟i，有一个：<br />
- uint64_t clk_i域表示时钟i的周期<br />
- uint63_t clk_i_cnt域表示时钟i当前计数<br />
- clock_lo_i和clock_hi_i<br />
- int reset()函数，其保证了所有的clock_lo和clock_hi函数被立即调用<br />
- int
clock(reset)函数，其计算最小增量，调用适当的clock_lo和clock_hi，并返回使用的最小增量。</p>
<p>为了建立C++模拟，用户需要：<br />
- 将所有周期字段初始化为所需周期<br />
- 将所有计数字段初始化为期望的相位<br />
- 调用reset<br />
- 重复调用时钟逐步模拟</p>
<p>以下是slowClock / fastClock的main函数C++示例：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123; </span><br><span class="line">	<span class="type">ClkDomainTest_t</span> dut; dut.init(<span class="number">1</span>);</span><br><span class="line">	dut.clk = <span class="number">2</span>;</span><br><span class="line">	dut.clk_cnt = <span class="number">1</span>; </span><br><span class="line">	dut.fastClock = <span class="number">4</span>; </span><br><span class="line">	dut.fastClock_cnt = <span class="number">0</span>; </span><br><span class="line">	dut.slowClock = <span class="number">6</span>; </span><br><span class="line">	dut.slowClock_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++)</span><br><span class="line">		dut.reset();</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i ++)</span><br><span class="line">		dut.clock(<span class="type">LIT</span>&lt;<span class="number">1</span>&gt;(<span class="number">0</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="verilog-1">Verilog</h3>
<p>在verilog中，<br />
- Chisel为每个时钟/复位创建一个新端口<br />
- Chisel将所有时钟连接到顶部模块<br />
- 用户必须为每个时钟i创建一个always块时钟驱动器</p>
<p>以下是驱动slowClock /
fastClock示例电路的顶层线束的Verilog示例：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">module emulator;</span><br><span class="line">	reg fastClock = <span class="number">0</span>, slowClock = <span class="number">0</span>, resetFast = <span class="number">1</span>, resetSlow = <span class="number">1</span>; </span><br><span class="line">	wire [<span class="number">31</span>:<span class="number">0</span>] add, mul, test; </span><br><span class="line">	always #<span class="number">2</span> fastClock = ~fastClock; </span><br><span class="line">	always #<span class="number">4</span> slowClock = ~slowClock; </span><br><span class="line">	initial begin</span><br><span class="line">		#<span class="number">8</span></span><br><span class="line">		resetFast = <span class="number">0</span>; </span><br><span class="line">		resetSlow = <span class="number">0</span>; </span><br><span class="line">		#<span class="number">400</span></span><br><span class="line">		$finish;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="type">ClkDomainTest</span> dut (</span><br><span class="line">	.fastClock(fastClock), </span><br><span class="line">	.slowClock(slowClock), </span><br><span class="line">	.io_resetFast(resetFast), </span><br><span class="line">	.io_resetSlow(resetSlow),</span><br><span class="line">	.io_add(add), </span><br><span class="line">	.io_mul(mul), </span><br><span class="line">	.io_test(test));</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h1 id="extra-stuff">Extra Stuff</h1>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListLookup</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](addr: <span class="type">UInt</span>, <span class="keyword">default</span>: <span class="type">List</span>[<span class="type">T</span>],</span><br><span class="line">	mapping: <span class="type">Array</span>[(<span class="type">UInt</span>, <span class="type">List</span>[<span class="type">T</span>])]): <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Lookup</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (addr: <span class="type">UInt</span>, <span class="keyword">default</span>: <span class="type">T</span>,</span><br><span class="line">	mapping: <span class="type">Seq</span>[(<span class="type">UInt</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">// n-way multiplexor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MuxCase</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="keyword">default</span>: <span class="type">T</span>, mapping: <span class="type">Seq</span>[(<span class="type">Bool</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// n-way indexed multiplexer:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MuxLookup</span></span>[<span class="type">S</span> &lt;: <span class="type">UInt</span>, <span class="type">T</span> &lt;: <span class="type">Data</span>](key: <span class="type">S</span>, <span class="keyword">default</span>: <span class="type">T</span>, mapping: <span class="type">Seq</span>[(<span class="type">S</span>, <span class="type">T</span>)]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create n enum values of given type</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](n: <span class="type">Int</span>)(gen: =&gt; <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create enum values of given type and names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](l: <span class="type">Symbol</span> *)(gen: =&gt; <span class="type">T</span>): <span class="type">Map</span>[<span class="type">Symbol</span>, <span class="type">T</span>]</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// create enum values of given type and names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enum</span></span>[<span class="type">T</span> &lt;: <span class="type">UInt</span>](l: <span class="type">List</span>[<span class="type">Symbol</span>])(gen: =&gt; <span class="type">T</span>): <span class="type">Map</span>[<span class="type">Symbol</span>, <span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<h1 id="standard-library">Standard Library</h1>
<h2 id="math">Math</h2>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the log base 2 of the input </span></span><br><span class="line"><span class="comment">// Scala Integer rounded up</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2Up</span></span>(in: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="comment">// Returns the log base 2 of the input </span></span><br><span class="line"><span class="comment">// Scala Integer rounded down</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log2Down</span></span>(in: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns true if the input Scala Integer </span></span><br><span class="line"><span class="comment">//isapowerof2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPow2</span></span>(in: <span class="type">Int</span>): <span class="type">Boolean</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// linear feedback shift register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LFSR16</span></span>(increment: <span class="type">Bool</span> = <span class="type">Bool</span>(<span class="literal">true</span>)): <span class="type">UInt</span></span><br></pre></td></tr></table></figure>
<h2 id="sequential">Sequential</h2>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the n-cycle delayed version</span></span><br><span class="line"><span class="comment">// of the input signal</span></span><br><span class="line"><span class="comment">// Has an optional enable signal defaulting to true def ShiftRegister[T &lt;: Data (in: T, n: Int, en = </span></span><br><span class="line">	<span class="type">Bool</span>(<span class="literal">true</span>)): <span class="type">T</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Counter</span></span>(cond: <span class="type">Bool</span>, n: <span class="type">Int</span>) = &#123; </span><br><span class="line">	<span class="keyword">val</span> c = <span class="type">RegReset</span>(<span class="type">UInt</span>(<span class="number">0</span>, log2Up(n))) </span><br><span class="line">	<span class="keyword">val</span> wrap = c === <span class="type">UInt</span>(n<span class="number">-1</span>)</span><br><span class="line">	when (cond) &#123;</span><br><span class="line">		c := <span class="type">Mux</span>(<span class="type">Bool</span>(!isPow2(n)) &amp;&amp; wrap, <span class="type">UInt</span>(<span class="number">0</span>), c + <span class="type">UInt</span>(<span class="number">1</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	(c, wrap &amp;&amp; cond) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="uint">UInt</h2>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the number of bits set in the // input signal. Causes an exception if // the input is wider than 32 bits.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PopCount</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the reverse the input signal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// returns the one hot encoding of</span></span><br><span class="line"><span class="comment">// the input UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">UIntToOH</span></span>(in: <span class="type">UInt</span>, width: <span class="type">Int</span>): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// does the inverse of UIntToOH</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OHToUInt</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OHToUInt</span></span>(in: <span class="type">Seq</span>[<span class="type">Bool</span>]): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Builds a Mux tree out of the input</span></span><br><span class="line"><span class="comment">// signal vector using a one hot encoded </span></span><br><span class="line"><span class="comment">// select signal. Returns the output of </span></span><br><span class="line"><span class="comment">// the Mux tree</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux1H</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (sel: <span class="type">UInt</span>, in: <span class="type">Vec</span>[<span class="type">T</span>]): <span class="type">T</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux1H</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (sel: <span class="type">Vec</span>[<span class="type">Bool</span>], in: <span class="type">Vec</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Builds a Mux tree under the</span></span><br><span class="line"><span class="comment">// assumption that multiple</span></span><br><span class="line"><span class="comment">// select signals can be enabled.</span></span><br><span class="line"><span class="comment">// Priority is given to the first</span></span><br><span class="line"><span class="comment">// select signal. Returns the output </span></span><br><span class="line"><span class="comment">// of the Mux tree.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityMux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">UInt</span>, in: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">T</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityMux</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Seq</span>[<span class="type">UInt</span>], in: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the bit position of the</span></span><br><span class="line"><span class="comment">// trailing 1 in the input vector with </span></span><br><span class="line"><span class="comment">// the assumption that multiple bits of </span></span><br><span class="line"><span class="comment">// the input bit vector can be set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoder</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoder</span></span>(in: <span class="type">Seq</span>[<span class="type">Bool</span>]): <span class="type">UInt</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns the bit position of the</span></span><br><span class="line"><span class="comment">// trailing 1 in the input vector with</span></span><br><span class="line"><span class="comment">// the assumption that only one bit in</span></span><br><span class="line"><span class="comment">// the input vector can be set</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoderOH</span></span>(in: <span class="type">UInt</span>): <span class="type">UInt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PriorityEncoderOH</span></span>(in: <span class="type">Seq</span>[<span class="type">Boo</span>]): <span class="type">UInt</span></span><br></pre></td></tr></table></figure>
<h2 id="decoupled">Decoupled</h2>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adds a ready-valid handshaking </span></span><br><span class="line"><span class="comment">// protocol to any interface. The</span></span><br><span class="line"><span class="comment">// standard used is that the</span></span><br><span class="line"><span class="comment">// consumer uses the fliped interface</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledIO</span>[+<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits  = gen.cloneType.asOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Adds a valid protocol to any</span></span><br><span class="line"><span class="comment">// interface. The standard used is </span></span><br><span class="line"><span class="comment">// that the consumer uses the</span></span><br><span class="line"><span class="comment">// fliped interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidIO</span>[+<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits  = gen.cloneType.asOutput</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hardware module that is used to </span></span><br><span class="line"><span class="comment">// sequence n producers into 1 consumer</span></span><br><span class="line"><span class="comment">// Priority is given to lower</span></span><br><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="comment">// Example usage: </span></span><br><span class="line"><span class="comment">// 		val arb = new Arbiter(UInt(), 2)</span></span><br><span class="line"><span class="comment">//		arb.io.in(0) &lt;&gt; producer0.io.out</span></span><br><span class="line"><span class="comment">// 		arb.io.in(1) &lt;&gt; producer1.io.out</span></span><br><span class="line"><span class="comment">//		consumer.io.in &lt;&gt; arb.io.out</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arbiter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hardware module that is used to</span></span><br><span class="line"><span class="comment">// sequence n producers into 1 consumer.</span></span><br><span class="line"><span class="comment">// Producers are chosen in round robin</span></span><br><span class="line"><span class="comment">// order</span></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">//		val arb = new RRArbiter(UInt(), 2) </span></span><br><span class="line"><span class="comment">//		arb.io.in(0) &lt;&gt; producer0.io.out </span></span><br><span class="line"><span class="comment">//		arb.io.in(1) &lt;&gt; producer1.io.out </span></span><br><span class="line"><span class="comment">//		consumer.io.in &lt;&gt; arb.io.out </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RRArbiter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic hardware queue. Required </span></span><br><span class="line"><span class="comment">// parameter entries controls the</span></span><br><span class="line"><span class="comment">// depth of the queues. The width of</span></span><br><span class="line"><span class="comment">// the queue is determined from the </span></span><br><span class="line"><span class="comment">// inputs.</span></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">// 		val q = new Queue(UInt(), 16)</span></span><br><span class="line"><span class="comment">//		q.io.enq &lt;&gt; producer.io.out</span></span><br><span class="line"><span class="comment">// 		consumer.io.in &lt;&gt; q.io.deq</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, pipe: <span class="type">Boolean</span> = false, flow: <span class="type">Boolean</span> =false</span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A hardware module that delays data </span></span><br><span class="line"><span class="comment">// coming down the pipeline by the </span></span><br><span class="line"><span class="comment">// number of cycles set by the </span></span><br><span class="line"><span class="comment">// latency parameter. Functionality </span></span><br><span class="line"><span class="comment">// is similar to ShiftRegister but </span></span><br><span class="line"><span class="comment">// this exposes a Pipe interface. </span></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">// 		val pipe = new Pipe(UInt()) </span></span><br><span class="line"><span class="comment">//		pipe.io.enq &lt;&gt; produce.io.out </span></span><br><span class="line"><span class="comment">// 		consumer.io.in &lt;&gt; pipe.io.deq</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipe</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, latency: <span class="type">Int</span> = 1</span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure>
<p>（完）</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title>Chisel入门教程</title>
    <url>/2016/12/17/chisel-tutorial/</url>
    <content><![CDATA[<p><a
href="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/riscv/chisel-tutorial.pdf">原文链接</a>
# 介绍 Chisel（Constructing Hardware In a Scala Embedded
Language）是一种嵌入在高级编程语言Scala的硬件构建语言。Chisel实际上只是一些特殊的类定义，预定义对象的集合，使用Scala的用法，所以在写Chisel程序时实际上是在写Scala程序。不过，本文我们并不假设你知道如何去写一个Scala程序。本文会通过一些Chisel的例子来说明某些重要的Scala特征，可以让你只使用本文介绍的东西也能完成一些伟大的硬件设计。
当你越来越有经验，希望自己的代码能够更加简化或提高复用性，你会发现有必要了解Scala语言的潜力。
所以，进一步学习Scala会让你变得更加专业。</p>
<span id="more"></span>
<p>Chisel仍处于起步阶段，你可能会遇到一些实现方面的bug，甚至可能会遇到一些概念设计问题。不过，我们正在积极地修改和改进语言，并且对错误报告和建议开放。即使在早期阶段，我们希望Chisel将帮助设计师在构建易于重复使用和维护的设计时更有效率。</p>
<h1 id="chisel硬件表达">Chisel硬件表达</h1>
<p>此版本的Chisel只支持二进制逻辑，不支持三态信号。</p>
<blockquote>
<p>我们专注于二进制逻辑设计，因为它们构成了实践中的绝大多数设计。我们忽略对当前Chisel语言中的三态逻辑的支持，因为这在工业环境中也很少支持，并且难以在受控硬宏之外可靠地使用。</p>
</blockquote>
<h1 id="chisel数据类型">Chisel数据类型</h1>
<p>Chisel数据类型用于指定状态元素中保存的值或wire上传输的值。虽然硬件设计最终操作的是二进制数值向量，但对于值的其他抽象表示具有更清晰的规范，并且能够帮助工具生成更优化的电路。在Chisel中，原始比特集合可以用Bits类型来表示。带符号和无符号整数被认为是定点数的子集，可以用SInt和UInt来表示。带符号定点整数（包括整数）使用二进制补码格式来表示。布尔值可以用Bool类型表示。注意，这些类型与Scala的内建类型不同，例如Int或Boolean。另外，Chisel定义了Bundle用来将值进行集合（类似于其他语言中的struct），还定义了Vec用来对值的集合进行索引。</p>
<p>常量或字面值使用Scala整数或传递给构造函数的字符串表示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="number">1</span>)			<span class="comment">// decimal 1-bit lit from Scala Int.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;ha&quot;</span>)		<span class="comment">// hexadecimal 4-bit lit from string.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;o12&quot;</span>)		<span class="comment">// octal 4-bit lit from string.</span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;b1010&quot;</span>) 	<span class="comment">// binary 4-bit lit from string.</span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">5</span>) 		<span class="comment">// signed decimal 4-bit lit from Scala Int. </span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">-8</span>) 		<span class="comment">// negative decimal 4-bit lit from Scala Int. </span></span><br><span class="line"><span class="type">UInt</span>(<span class="number">5</span>) 		<span class="comment">// unsigned decimal 3-bit lit from Scala Int.</span></span><br><span class="line"><span class="type">Bool</span>(<span class="literal">true</span>) 		<span class="comment">// Bool lits from Scala lits. </span></span><br><span class="line"><span class="type">Bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>下划线可以用作长字符串文字中的分隔符，以帮助可读性，但在创建值时会被忽略，例如：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="string">&quot;h_dead_beef&quot;</span>) <span class="comment">// 32-bit lit of type UInt</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Chisel编译器将每个常量的大小设置为保存常量所需的最小位数，包括带符号类型的符号位。位宽也可以在字面上明确指定，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">UInt</span>(<span class="string">&quot;ha&quot;</span>, <span class="number">8</span>) 		<span class="comment">// hexadecimal 8-bit lit of type UInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;o12&quot;</span>, <span class="number">6</span>) 		<span class="comment">// octal 6-bit lit of type UInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="string">&quot;b1010&quot;</span>, <span class="number">12</span>) 	<span class="comment">// binary 12-bit lit of type UInt</span></span><br><span class="line"><span class="type">SInt</span>(<span class="number">5</span>, <span class="number">7</span>) 			<span class="comment">// signed decimal 7-bit lit of type SInt </span></span><br><span class="line"><span class="type">UInt</span>(<span class="number">5</span>, <span class="number">8</span>) 			<span class="comment">// unsigned decimal 8-bit lit of type UInt</span></span><br></pre></td></tr></table></figure></p>
<p>对于UInt类型值，值被零扩展到所需的位宽。对于类型为SInt的文字，该值被符号扩展以填充所需的位宽度。如果给定的位宽太小而不能容纳参数值，则会生成Chisel错误。</p>
<h1 id="组合电路">组合电路</h1>
<p>在Chisel中，电路会被表示为一张节点图。每个节点是具有零个或多个输入并驱动一个输出的硬件运算符。上面介绍的Uint是一种退化类型的节点，它没有输入，并且在其输出上驱动一个恒定的值。创建和连接节点的一种方法是使用字面表达式。例如，我们可以使用以下表达式来表示简单的组合逻辑电路：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(a &amp; b) | (~c &amp; d)</span><br></pre></td></tr></table></figure></p>
<p>语法应该看起来很熟悉，用＆和|分别表示按位与和按位或，~表示按位非。a到d表示某些（未指定）宽度的命名导线。<br />
任何简单的表达式都可以直接转换成电路树，在叶子处使用命名的导线和操作符形成内部节点。表达式的电路输出取自树根处的运算符，在本示例中是按位或运算。<br />
简单表达式可以以树的形式构建电路，但是如果想以任意有向非循环图（DAG）的形式构建电路，我们需要描述扇出。在Chisel中，我们通过命名一根wire来表示一个子表达式，这样我们就可以在后续表达式中多次引用。我们通过声明变量来命名Chisel中的wire。例如，考虑如下示例的select表达式，它在后续的多选器描述中可以多次使用：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sel = a | b</span><br><span class="line"><span class="keyword">val</span> out = (sel &amp; in1) | (~sel &amp; in0)</span><br></pre></td></tr></table></figure></p>
<p>关键字<strong>val</strong>是Scala的一部分，用于命名具有不会再更改的值的变量。
在上面的例子中它命名了wire类型的sel，保存了第一个按位或运算符的输出，以便输出可在第二个表达式中多次使用。</p>
<h1 id="内建操作符">内建操作符</h1>
Chisel定义了一组硬件操作符，如下表所示：<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-operators.png" />
</div>
<h2 id="位宽接口">位宽接口</h2>
用户需要设置端口和寄存器的位宽，除非用户手动设置，否则编译器会自动推测wire上的位宽。位宽推测引擎会从节点图的输入端口开始，并根据以下规则集从它们各自的输入位宽度计算节点输出位宽度：<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-interfence-rule.png" />
</div>
<p>其中例如wz是wire z的位宽，＆规则可应用于所有按位逻辑运算。</p>
<p>位宽推测过程会持续到没有位宽改变。
除了通过已知固定数量的右移之外，位宽推测规定了输出位宽度不能小于输入位宽度，因此输出位宽度增长或保持相同。
此外，寄存器的宽度必须由用户明确地或根据复位值或下一个参数的位宽指定。根据这两个要求，我们可以将位宽推测过程将收敛到一个固定点。<br />
&gt;
我们选择的运算符名称受到Scala语言的限制。所以我们必须使用===表示等于判断逻辑和=/=表示不等判断逻辑，这样可以保持原生Scala相关运算符可用。</p>
<h1 id="功能抽象">功能抽象</h1>
<p>我们可以定义函数来分解一个重复的逻辑，这样可以在后续设计中重复使用。例如，我们可以包装一个简单的组合逻辑块：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clb</span></span>(a: <span class="type">UInt</span>, b: <span class="type">UInt</span>, c: <span class="type">UInt</span>, d: <span class="type">UInt</span>): <span class="type">UInt</span> = </span><br><span class="line">	(a &amp; b) | (~c &amp; d)</span><br></pre></td></tr></table></figure></p>
<p>其中clb是表示以a，b，c，d为参数的函数，并返回一个布尔电路的输出。
<strong>def</strong>关键字是Scala的一部分，表示引入了一个函数定义，每个语句后面跟一个冒号，然后是它的类型，函数返回类型在参数列表之后的冒号之后。（=）符号将函数参数列表与函数定义分隔开。<br />
然后我们就可以在其他的电路中使用了：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> out = clb(a,b,c,d)</span><br></pre></td></tr></table></figure></p>
<p>我们将在后面介绍许多吊炸天的函数使用方法来构造硬件。</p>
<h1 id="bundles-vecs">Bundles &amp; Vecs</h1>
<p>Bundle和Vec是可以允许用户使用其他数据类型来扩展Chisel数据类型集合的类。<br />
Bundle可以将一些不同类型的命名字段组合成一个单元，类似于C语言中的struct。用户可以通过将一个类定义为Bundle的子类来定义自己的bundle：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFloat</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> sign = <span class="type">Bool</span>()</span><br><span class="line">	<span class="keyword">val</span> exponent = <span class="type">UInt</span>(width = <span class="number">8</span>) </span><br><span class="line">	<span class="keyword">val</span> significand = <span class="type">UInt</span>(width = <span class="number">23</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">MyFloat</span>()</span><br><span class="line"><span class="keyword">val</span> xs = x.sign</span><br></pre></td></tr></table></figure></p>
<p>scala约定将新类的名称的首字母大写，所以我们建议在Chisel中也遵循这个约定。
UInt构造函数的width命名参数指定类型中的位数。</p>
<p>Vecs用来创建一个可索引的元素向量，其构造如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector of 5 23-bit signed integers.</span></span><br><span class="line"><span class="keyword">val</span> myVec = <span class="type">Vec</span>.fill(<span class="number">5</span>)&#123; <span class="type">SInt</span>(width = <span class="number">23</span>) &#125; </span><br><span class="line"><span class="comment">// Connect to one element of vector.</span></span><br><span class="line"><span class="keyword">val</span> reg3 = myVec(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>（注意，我们必须在花括号内指定Vec元素的类型，因为我们必须将位宽参数传递给SInt构造器。）<br />
原始类（SInt，UInt和Bool）加上聚合类（Bundles和Vecs）都继承自一个公共的超类Data。在电路中，每个最终继承自Data的对象都可以表示为一个位向量。<br />
Bundle和Vec可以任意嵌套，从而构建复杂的数据结构：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigBundle</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Vector of 5 23-bit signed integers.</span></span><br><span class="line">	<span class="keyword">val</span> myVec = <span class="type">Vec</span>.fill(<span class="number">5</span>) &#123; <span class="type">SInt</span>(width = <span class="number">23</span>) &#125; </span><br><span class="line">	<span class="keyword">val</span> flag = <span class="type">Bool</span>()</span><br><span class="line">	<span class="comment">// Previously defined bundle.</span></span><br><span class="line">	<span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">MyFloat</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="端口">端口</h1>
<p>端口用作硬件组件的接口。一个端口可以是任意的Data对象，但它是具有方向的。<br />
Chisel提供端口构造函数，以允许在构建时给对象添加（输入或输出）。原始的端口构造函数需要将方向作为第一个参数（方向为INPUT或OUTPUT），将位数作为第二个参数（除了始终为1位的布尔值）。<br />
端口的声明如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoupled</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> data = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Decoupled被定义后，它就会变成一个新的类型，可以根据需要用于模块接口或命名的wire集合。<br />
对象的方向也可以实例化时确定：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaleIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> in = <span class="keyword">new</span> <span class="type">MyFloat</span>().asInput </span><br><span class="line">	<span class="keyword">val</span> scale = <span class="keyword">new</span> <span class="type">MyFloat</span>().asInput </span><br><span class="line">	<span class="keyword">val</span> out = <span class="keyword">new</span> <span class="type">MyFloat</span>().asOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>asInput和asOutput方法可以强制数据对象的所有模块设置成对应的方向。<br />
通过将方向折叠到对象声明中，Chisel能够提供强大的布线能力，稍后会详细介绍。</p>
<h1 id="modules">Modules</h1>
<p>我们现在可以构建电路层次，我们可以从较小的子模块开开始构建更大的模块。例如，我们可以通过将三个2输入多路选择器连接在一起，构建一个4输入多路选择器模块：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux4</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in2 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) 	</span><br><span class="line">		<span class="keyword">val</span> in3 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">2</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> m0 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m0.io.sel := io.sel(<span class="number">0</span>)</span><br><span class="line">	m0.io.in0 := io.in0; </span><br><span class="line">	m0.io.in1 := io.in1</span><br><span class="line">	<span class="keyword">val</span> m1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m1.io.sel := io.sel(<span class="number">0</span>)</span><br><span class="line">	m1.io.in0 := io.in2; </span><br><span class="line">	m1.io.in1 := io.in3</span><br><span class="line">	<span class="keyword">val</span> m3 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())</span><br><span class="line">	m3.io.sel := io.sel(<span class="number">1</span>)</span><br><span class="line">	m3.io.in0 := m0.io.out; </span><br><span class="line">	m3.io.in1 := m1.io.out</span><br><span class="line">	io.out := m3.io.out </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="运行和测试">运行和测试</h1>
<p>现在我们已经定义了模块，我们将讨论如何实际运行并测试电路。Chisel代码可以转换为C++或Verilog。
为了编译电路，我们需要调用chiselMain：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">tutorial</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">		chiselMain(args, () =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>())) </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试是电路设计的关键部分，因此在Chisel中，我们通过这样一种测试机制：使用Tester类的子类在Scala中提供测试向量：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>[<span class="type">T</span> &lt;: <span class="type">Module</span>] (<span class="params">val c: <span class="type">T</span>, val isTrace: <span class="type">Boolean</span> = true</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">val</span> rnd: <span class="type">Random</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Boolean</span>): <span class="type">BigInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Int</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">int</span></span>(x: <span class="type">Bits</span>): <span class="type">BigInt</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(n: <span class="type">Int</span> = <span class="number">1</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">step</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">pokeAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>, x: <span class="type">BigInt</span>) </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Bits</span>, x: <span class="type">BigInt</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(data: <span class="type">Aggregate</span>, x: <span class="type">Array</span>[<span class="type">BigInt</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peekAt</span></span>(data: <span class="type">Mem</span>[<span class="type">T</span>], index: <span class="type">Int</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Bits</span>): <span class="type">BigInt</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">peek</span></span>(data: <span class="type">Aggregate</span>): <span class="type">Array</span>[<span class="type">BigInt</span>]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(good: <span class="type">Boolean</span>, msg: <span class="type">String</span>): <span class="type">Boolean</span> </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">expect</span> </span>(data: <span class="type">Bits</span>, target: <span class="type">BigInt</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它将tester绑定到模块，并允许用户使用给定的调试协议编写测试。用户会用到一下这些：<br />
- <strong>poke</strong>: 设置输入端口以及状态值<br />
- <strong>step</strong>: 以一个时间单元执行电路<br />
- <strong>peek</strong>: 读取端口和状态值<br />
- <strong>expect</strong>: 比较peek获得的值和期望的值</p>
<p>用户使用如下的方式连接tester和模块：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">chiselMainTest</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Module</span>]</span><br><span class="line">		(args: <span class="type">Array</span>[<span class="type">String</span>], comp: () =&gt; <span class="type">T</span>)( </span><br><span class="line">			tester: <span class="type">T</span> =&gt; <span class="type">Tester</span>[<span class="type">T</span>]): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
当-
-test作为参数传递给chiselMainTest时，tester实例在独立的进程中运行被测器件（DUT），并连接stdin和stdout，这样调试命令可以发送到DUT，响应也可以从DUT接收，如图所示。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-DUT.png" />
</div>
<p>举例说明：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux2Tests</span>(<span class="params">c: <span class="type">Mux2</span></span>) <span class="keyword">extends</span> <span class="title">Tester</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> n = pow(<span class="number">2</span>, <span class="number">3</span>).toInt</span><br><span class="line">	<span class="keyword">for</span> (s &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i0 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123; </span><br><span class="line">			<span class="keyword">for</span> (i1 &lt;- <span class="number">0</span> until <span class="number">2</span>) &#123;</span><br><span class="line">				poke(c.io.sel, s)</span><br><span class="line">				poke(c.io.in1, i1)</span><br><span class="line">				poke(c.io.in0, i0)</span><br><span class="line">				step(<span class="number">1</span>)</span><br><span class="line">				expect(c.io.out, (<span class="keyword">if</span> (s == <span class="number">1</span>) i1 <span class="keyword">else</span> i0))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></p>
<p>使用poke将Mux2的每个输入的分别设置为合适的值。对于这个例子，我们通过硬编码输入到一些已知的值并检查输出是否对应于已知的值来测试Mux2。为此，在每次迭代中，我们生成模块输入，让模拟将这些值分配给我们正在测试的器件c的输入，单步运行电路并对比期望值。最后，简单说明一下如何调用测试器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">chiselMainTest(args + <span class="string">&quot;--test&quot;</span>, () =&gt; <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Mux2</span>()))&#123; </span><br><span class="line">	c =&gt; <span class="keyword">new</span> <span class="type">Mux2Tests</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 还有其他的一些命令参数：<br />
&gt; --targetDir 目标路径名前缀<br />
&gt; --genHarness 生成C++文件<br />
&gt; --backend v 生成verilog<br />
&gt; --backend c 生成C++（默认）<br />
&gt; --vcd 开启vcd打印<br />
&gt; --debug 把所有的wire放入class文件</p>
<h1 id="状态元素">状态元素</h1>
<p>Chisel支持的状态元素的最简单形式是上升沿触发寄存器，可以实例化为：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> reg = <span class="type">Reg</span>(next = in)</span><br></pre></td></tr></table></figure></p>
<p>该电路具有输出，该输出是前一个时钟周期的输入信号产生的值。注意，我们不必指定Reg的类型，因为它会在实例化时从输入开始自动推断。在当前版本的Chisel中，时钟和复位是全局信号，在需要时可以隐式包含。<br />
使用寄存器，我们可以快速定义一些有用的电路结构。
例如，当当前值为true且之前的值为false时，上升沿检测器能够获取到布尔信号并输出true，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">risingedge</span></span>(x: <span class="type">Bool</span>) = x &amp;&amp; !<span class="type">Reg</span>(next = x)</span><br></pre></td></tr></table></figure></p>
<p>计数器是一个重要的时序电路。
如果想构建一个向上计数器，计数到最大值max后回到零：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span></span>(max: <span class="type">UInt</span>) = &#123;</span><br><span class="line">	<span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, max.getWidth))</span><br><span class="line">	x := <span class="type">Mux</span>(x === max, <span class="type">UInt</span>(<span class="number">0</span>), x + <span class="type">UInt</span>(<span class="number">1</span>))</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计数器复位值为0（宽度大到足以容纳max），当电路的全局复位置位时，寄存器将初始化为该值。<br />
计数器可用于构建很多有用的时序电路。例如，我们可以通过在计数器达到零时输出true来构建脉冲发生器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Produce pulse every n cycles.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pulse</span></span>(n: <span class="type">UInt</span>) = counter(n - <span class="type">UInt</span>(<span class="number">1</span>)) === <span class="type">UInt</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过切换方波发生器脉冲序列，在每个脉冲上的true和false之间切换：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Flip internal state when input true.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toggle</span></span>(p: <span class="type">Bool</span>) = &#123;</span><br><span class="line">	<span class="keyword">val</span> x = <span class="type">Reg</span>(init = <span class="type">Bool</span>(<span class="literal">false</span>)) </span><br><span class="line">	x := <span class="type">Mux</span>(p, !x, x)</span><br><span class="line">	x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Square wave of a given period.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squareWave</span></span>(period: <span class="type">UInt</span>) = toggle(pulse(period/<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="转发声明">转发声明</h2>
<p>纯组合电路在节点之间不存在周期，如果检测到这样的周期，则Chisel将报告错误。因为它们不具有周期，所以可以总是以前馈方式构建组合电路，通过添加一些输入从已经定义的节点导出的新节点。时序电路在节点之间具有反馈，因此有时需要在生成节点被定义之前输出。因为Scala顺序执行程序语句，所以我们允许数据节点作为wire来提供节点声明，这样可以立即被使用，但其输入将稍后设置。如下例所示，在简单的CPU中，我们需要定义pcPlus4和brTarget的线，以便在定义之前引用它们：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> pcPlus4 = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> brTarget = <span class="type">UInt</span>()</span><br><span class="line"><span class="keyword">val</span> pcNext = <span class="type">Mux</span>(io.ctrl.pcSel, brTarget, pcPlus4)</span><br><span class="line"><span class="keyword">val</span> pcReg = <span class="type">Reg</span>(next = pcNext, init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">32</span>)) </span><br><span class="line">pcPlus4 := pcReg + <span class="type">UInt</span>(<span class="number">4</span>)</span><br><span class="line">...</span><br><span class="line">brTarget := addOut</span><br></pre></td></tr></table></figure></p>
<p>接线操作符:=用于在pcReg和addOut定义后连接。</p>
<h2 id="条件更新">条件更新</h2>
<p>在前面使用到寄存器的示例中，我们简单地将组合逻辑块连接到寄存器的输入。当描述状态元素的操作时，指定何时将发生寄存器更新并且用几个单独的语句指明这些更新。Chisel以when的形式提供条件更新规则，以支持这种顺序逻辑描述的风格。例如，<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> r = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, <span class="number">16</span>)) </span><br><span class="line">when (cond) &#123;</span><br><span class="line">	r := r + <span class="type">UInt</span>(<span class="number">1</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中只有在cond为真时，才在当前时钟周期的结尾更新寄存器r。when的参数是返回Bool值。后面的更新块只能包含使用赋值运算符:=，简单表达式和用val定义的命名引线的更新语句。<br />
在条件更新序列中，条件为真的最近条件更新优先。 例如：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">when (c1) &#123; r := <span class="type">UInt</span>(<span class="number">1</span>) &#125; </span><br><span class="line">when (c2) &#123; r := <span class="type">UInt</span>(<span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述表达式会根据以下真值表更新r：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">c1</th>
<th style="text-align: center;">c2</th>
<th style="text-align: center;">r</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">r</td>
<td style="text-align: left;">r 不变</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">c2优先于c1</td>
</tr>
</tbody>
</table>
下图显示了如何将每个条件更新视为在寄存器的输入之前插入mux，根据when选择更新表达式或之前的输入。编译器会把初始化值置于链的开头，以便如果在一个时钟周期内没有条件更新激活，则寄存器的加载使能将被置为无效，寄存器值就不会改变。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-for-when.png" />
</div>
<p>Chisel为条件更新的其他常见形式提供了一些语法糖。除非结构与when相同，但否定其条件。也就是说，<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">unless (c) &#123; body &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (!c) &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>更新块可以操作多个目标寄存器，在不同更新块中的也允许存在寄存器的不同重叠子集。每个寄存器只受其出现的条件的影响。组合电路（更新Wire）也是可能的。注意，所有组合电路需要默认值。例如：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">r := <span class="type">SInt</span>(<span class="number">3</span>); s := <span class="type">SInt</span>(<span class="number">3</span>)</span><br><span class="line">when (c1) &#123; r := <span class="type">SInt</span>(<span class="number">1</span>); s := <span class="type">SInt</span>(<span class="number">1</span>) &#125; </span><br><span class="line">when (c2) &#123; r := <span class="type">SInt</span>(<span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述语句会根据如下真值表更新r和s：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">c1</th>
<th style="text-align: center;">c2</th>
<th style="text-align: center;">r</th>
<th style="text-align: center;">s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>条件更新结构可以嵌套，任何给定块在所有外嵌套条件的联合下才能执行。例如，<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">when (a) &#123; when (b) &#123; body &#125; &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (a &amp;&amp; b) &#123; body &#125;</span><br></pre></td></tr></table></figure></p>
<p>条件可以使用when，.elsewhen，.otherwise来链式表达，对应于Scala中的if,
else if, else。例如：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">when (c1) &#123; u1 &#125; </span><br><span class="line">.elsewhen (c2) &#123; u2 &#125; </span><br><span class="line">.otherwise &#123; ud &#125;</span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line">when (c1) &#123; u1 &#125;</span><br><span class="line">when (!c1 &amp;&amp; c2) &#123; u2 &#125; </span><br><span class="line">when (!(c1 || c2)) &#123; ud &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再介绍关于用于条件更新的switch语句，其涉及针对公共密钥的一系列比较。例如，<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">switch(idx) &#123; </span><br><span class="line">	is(v1) &#123; u1 &#125; </span><br><span class="line">	is(v2) &#123; u2 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the same sa</span></span><br><span class="line">when (idx === v1) &#123; u1 &#125; </span><br><span class="line">.elsewhen (idx === v2) &#123; u2 &#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel还允许Wire，即一些组合逻辑的输出，成为条件性更新语句的目标，以允许逐步构建复杂的组合逻辑表达式。Chisel不允许不指定组合输出，并且如果组合输出未遇到无条件更新，则报告错误。</p>
<h2 id="有限状态机">有限状态机</h2>
<p>在数字设计中有限状态机（FSM）是时序电路常用的类型。简单FSM的例子就是奇偶校验生成器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parity</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>) </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_even :: s_odd :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">2</span>) </span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_even)</span><br><span class="line">	when (io.in) &#123;</span><br><span class="line">		when (state === s_even) &#123; state := s_odd &#125;</span><br><span class="line">		when (state === s_odd) &#123; state := s_even &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	io.out := (state === s_odd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Enum(Uint(),
2)生成两个UInt数。当io.in为true时更新状态。需要注意的是，FSM的所有机制都建立在寄存器，线和条件更新的基础上。<br />
下面是一个复杂的FSM例子，这是一个自动售货机接收货币的电路：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> nickel = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> dime   = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> valid  = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_idle) </span><br><span class="line">	when (state === s_idle) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_5 &#125;</span><br><span class="line">		when (io.dime) &#123; state := s_10 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_5) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_10 &#125; </span><br><span class="line">		when (io.dime) &#123; state := s_15 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_10) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_15 &#125;</span><br><span class="line">		when (io.dime) &#123; state := s_ok &#125; </span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_15) &#123;</span><br><span class="line">		when (io.nickel) &#123; state := s_ok &#125; </span><br><span class="line">		when (io.dime) &#123; state := s_ok &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	when (state === s_ok) &#123;</span><br><span class="line">		state := s_idle</span><br><span class="line">	&#125;</span><br><span class="line">	io.valid := (state === s_ok) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个使用switch语句定义的售货机FSM：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> nickle = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> dime   = <span class="type">Bool</span>(dir = <span class="type">INPUT</span>)</span><br><span class="line">		<span class="keyword">val</span> valid  = <span class="type">Bool</span>(dir = <span class="type">OUTPUT</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> s_idle :: s_5 :: s_10 :: s_15 :: s_ok :: <span class="type">Nil</span> = <span class="type">Enum</span>(<span class="type">UInt</span>(), <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">val</span> state = <span class="type">Reg</span>(init = s_idle) </span><br><span class="line">	switch (state) &#123; </span><br><span class="line">		is (s_idle) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_5 &#125;</span><br><span class="line">			when (io.dime) &#123; state := s_10 &#125; </span><br><span class="line">		&#125; </span><br><span class="line">		is (s_5) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_10 &#125; </span><br><span class="line">			when (io.dime) &#123; state := s_15 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		is (s_10) &#123;</span><br><span class="line">			when (io.nickel) &#123; state := s_15 &#125;</span><br><span class="line">			when (io.dime) &#123; state := s_ok &#125; </span><br><span class="line">		&#125;</span><br><span class="line">		is (s_ok) &#123;</span><br><span class="line">			state := s_idle</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	io.valid := (state === s_ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 内存 Chisel提供了创建只读和读/写存储器的功能。</p>
<h2 id="rom">ROM</h2>
<p>用户可以使用Vec定义ROM：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Vec</span>(inits: <span class="type">Seq</span>[<span class="type">T</span>])</span><br><span class="line"><span class="type">Vec</span>(elt0: <span class="type">T</span>, elts: <span class="type">T</span>*)</span><br></pre></td></tr></table></figure></p>
<p>其中inits是初始化ROM的初始Data序列。例如，用户可以创建一个初始化为1,2,4,8的小型ROM，并使用计数器作为地址生成器循环访问所有值，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="type">Vec</span>(<span class="type">Array</span>(<span class="type">UInt</span>(<span class="number">1</span>), <span class="type">UInt</span>(<span class="number">2</span>), <span class="type">UInt</span>(<span class="number">4</span>), <span class="type">UInt</span>(<span class="number">8</span>))) </span><br><span class="line"><span class="keyword">val</span> r = m(counter(<span class="type">UInt</span>(m.length)))</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用如下初始化的ROM创建n值正弦查找表：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinTable</span> </span>(amp: <span class="type">Double</span>, n: <span class="type">Int</span>) = &#123; </span><br><span class="line">	<span class="keyword">val</span> times = <span class="type">Range</span>(<span class="number">0</span>, n, <span class="number">1</span>).map(i =&gt; (i*<span class="number">2</span>*<span class="type">Pi</span>)/(n.toDouble<span class="number">-1</span>) - <span class="type">Pi</span>) </span><br><span class="line">	<span class="keyword">val</span> inits = times.map(t =&gt; <span class="type">SInt</span>(round(amp * sin(t)), width = <span class="number">32</span>)) </span><br><span class="line">	<span class="type">Vec</span>(inits)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinWave</span> </span>(amp: <span class="type">Double</span>, n: <span class="type">Int</span>) =</span><br><span class="line">	sinTable(amp, n)(counter(<span class="type">UInt</span>(n))</span><br></pre></td></tr></table></figure></p>
<p>其中amp用于缩放存储在ROM中的固定点值。</p>
<h2 id="mem">Mem</h2>
<p>存储器在Chisel中被给予特殊处理，因为存储器的硬件实现具有许多变化，例如，FPGA存储器与ASIC存储实例化的结果完全不同。Chisel定义了一个内存抽象，可以映射到简单的Verilog行为描述，也可以映射到从代工厂或IP厂商提供的外部内存生成器获得的内存模块实例。<br />
Chisel通过Mem结构可以支持随机存取存储器。写入Mems是正边沿触发，读取是组合或正边沿触发。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mem</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="class"><span class="keyword">type</span></span>: <span class="type">T</span>, depth: <span class="type">Int</span>,</span><br><span class="line">		seqRead: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mem</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span>, depth: <span class="type">Int</span>, seqRead: <span class="type">Boolean</span> = false</span>)</span></span><br><span class="line">	<span class="keyword">extends</span> <span class="type">Updateable</span> &#123; </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(idx: <span class="type">UInt</span>): <span class="type">T</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用UInt索引创建到Mems的端口。具有一个写入端口和两个组合读取端口的32-entry的寄存器堆可以如下表示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rf = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">64</span>), <span class="number">32</span>) </span><br><span class="line">when (wen) &#123; rf(waddr) := wdata &#125; </span><br><span class="line"><span class="keyword">val</span> dout1 = rf(waddr1)</span><br><span class="line"><span class="keyword">val</span> dout2 = rf(waddr2)</span><br></pre></td></tr></table></figure></p>
<p>如果设置了可选参数seqRead，当读地址为Reg时，Chisel将尝试推断顺序读端口。单读端口，单写端口SRAM可以描述如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1r1w = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">1024</span>, seqRead = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> reg_raddr = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1r1w(waddr) := wdata &#125; </span><br><span class="line">when (ren) &#123; reg_raddr := raddr &#125;</span><br><span class="line"><span class="keyword">val</span> rdata = ram1r1w(reg_raddr)</span><br></pre></td></tr></table></figure></p>
<p>单端口SRAM可以在读和写条件在链中相同时相互排斥时推断：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ram1p = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">1024</span>, seqRead = <span class="literal">true</span>) </span><br><span class="line"><span class="keyword">val</span> reg_raddr = <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">when (wen) &#123; ram1p(waddr) := wdata &#125; </span><br><span class="line">.elsewhen (ren) &#123; reg_raddr := raddr &#125;</span><br><span class="line"><span class="keyword">val</span> rdata = ram1p(reg_raddr)</span><br></pre></td></tr></table></figure></p>
<p>如果相同的Mem地址在相同的时钟沿上被写入和顺序读取，或者如果顺序读取使能被清除，则读取数据为未定义。<br />
Mem还支持subword写入的写掩码。如果相应的屏蔽位置1，则写入给定位。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ram = <span class="type">Mem</span>(<span class="type">UInt</span>(width = <span class="number">32</span>), <span class="number">256</span>)</span><br><span class="line">when (wen) &#123; ram.write(waddr, wdata, wmask) &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> x = <span class="keyword">new</span> <span class="type">PLink</span>().flip</span><br><span class="line">	<span class="keyword">val</span> y = <span class="keyword">new</span> <span class="type">PLink</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中flip递归地改变Bundle的“性别”，将输入改变为输出和输出。<br />
我们现在可以通过定义一个过滤器类扩展模块来定义一个过滤器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; <span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中io包含了FilterIO。</p>
<h2 id="bundle-向量">Bundle 向量</h2>
<p>除了单个元素，元素向量可以形成更丰富的分层接口。例如，创建具有输入向量的交叉开关，产生输出向量，并通过UInt输入选择，我们可以使用Vec构造函数：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossbarIo</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> in = <span class="type">Vec</span>.fill(n)&#123; <span class="keyword">new</span> <span class="type">PLink</span>().flip() &#125; </span><br><span class="line">	<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, sizeof(n))</span><br><span class="line">	<span class="keyword">val</span> out = <span class="type">Vec</span>.fill(n)&#123; <span class="keyword">new</span> <span class="type">PLink</span>() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中Vec用第一个参获取大小，区块返回一个端口作为第二个参数。</p>
<h2 id="批量连接">批量连接</h2>
<p>我们现在可以将两个过滤器组成一个过滤器块，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>()</span><br><span class="line">	<span class="keyword">val</span> f1 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>()) </span><br><span class="line">	<span class="keyword">val</span> f2 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>())</span><br><span class="line">	f1.io.x &lt;&gt; io.x </span><br><span class="line">	f1.io.y &lt;&gt; f2.io.x </span><br><span class="line">	f2.io.y &lt;&gt; io.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中&lt;&gt;批量连接同级模块之间的相反接口或父/子模块之间的相同接口。批量连接将相同名称的叶子端口彼此连接。在所有连接完成后，Chisel警告用户端口是否只有一个到它们的连接。</p>
<h2 id="接口视图">接口视图</h2>
考虑一个由控制逻辑和数据通路子模块以及主机和存储器接口组成的简单CPU，如图所示。在这个CPU中，我们可以看到控制逻辑和数据通路每个只连接到指令和数据存储器接口的一部分。Chisel允许用户通过部分实现接口来实现这一点。用户首先定义到ROM和Mem的完整接口，如下：<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-cpu.png" />
</div>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RomIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isVal = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> raddr = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>) </span><br><span class="line">	<span class="keyword">val</span> rdata = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RamIo</span> <span class="keyword">extends</span> <span class="title">RomIo</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> isWr = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> wdata = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在控制逻辑可以根据这些接口构建接口：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CpathIo</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> imem = <span class="type">RomIo</span>().flip() </span><br><span class="line">	<span class="keyword">val</span> dmem = 	<span class="type">RamIo</span>().flip() </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且控制和数据通路模块可以通过部分地分配来给这个接口来构建，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpath</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">CpathIo</span>();</span><br><span class="line">	...</span><br><span class="line">	io.imem.isVal := ...;</span><br><span class="line">	 io.dmem.isVal := ...; </span><br><span class="line">	 io.dmem.isWr := ...; </span><br><span class="line">	 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dpath</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">DpathIo</span>(); </span><br><span class="line">	...</span><br><span class="line">	io.imem.raddr := ...; </span><br><span class="line">	io.dmem.raddr := ...; </span><br><span class="line">	io.dmem.wdata := ...;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在可以使用批量连接来连接CPU，就像使用其他bundle一样：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpu</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">CpuIo</span>()</span><br><span class="line">	<span class="keyword">val</span> c = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">CtlPath</span>()) </span><br><span class="line">	<span class="keyword">val</span> d = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">DatPath</span>()) </span><br><span class="line">	c.io.ctl &lt;&gt; d.io.ctl</span><br><span class="line">	c.io.dat &lt;&gt; d.io.dat </span><br><span class="line">	c.io.imem &lt;&gt; io.imem</span><br><span class="line">	d.io.imem &lt;&gt; io.imem</span><br><span class="line">	c.io.dmem &lt;&gt; io.dmem</span><br><span class="line">	d.io.dmem &lt;&gt; io.dmem</span><br><span class="line">	d.io.host &lt;&gt; io.host</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模块的功能创建">模块的功能创建</h1>
<p>制造用于模块构造的功能接口也是有用的。例如，我们可以构建一个构造函数，它将多路复用器输入作为参数，并返回多路复用器输出：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Mux2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(sel: <span class="type">UInt</span>, in0: <span class="type">UInt</span>, in1: <span class="type">UInt</span>) = &#123;</span><br><span class="line">		<span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">Mux2</span>() </span><br><span class="line">		m.io.in0 := in0 </span><br><span class="line">		m.io.in1 := in1 </span><br><span class="line">		m.io.sel := sel </span><br><span class="line">		m.io.out</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中对象Mux2在Mux2模块类中创建一个Scala单例对象，并且apply定义了创建Mux2实例的方法。有了这个Mux2创建功能，Mux4的规格现在明显更简单。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mux4</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> in0 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">val</span> in1 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in2 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> in3 = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">1</span>) </span><br><span class="line">		<span class="keyword">val</span> sel = <span class="type">UInt</span>(<span class="type">INPUT</span>, <span class="number">2</span>) </span><br><span class="line">		<span class="keyword">val</span> out = <span class="type">UInt</span>(<span class="type">OUTPUT</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	io.out := <span class="type">Mux2</span>(io.sel(<span class="number">1</span>), <span class="type">Mux2</span>(io.sel(<span class="number">0</span>), io.in0, io.in1), <span class="type">Mux2</span>(io.sel(<span class="number">0</span>), io.in2, io.in3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chisel提供MuxCase，其本质上是一个n-way Mux。<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">MuxCase</span>(<span class="keyword">default</span>, <span class="type">Array</span>(c1 -&gt; a, c2 -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<p>其中每个条件/值在Scala数组中表示为元组，并且其中MuxCase可以转换为以下Mux表达式：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Mux</span>(c1, a, <span class="type">Mux</span>(c2, b, <span class="type">Mux</span>(..., <span class="keyword">default</span>)))</span><br></pre></td></tr></table></figure></p>
<p>Chisel还提供MuxLookup，其本质是一个n-way的可索引多路选择器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">MuxLookup</span>(idx, <span class="keyword">default</span>,</span><br><span class="line">	<span class="type">Array</span>(<span class="type">UInt</span>(<span class="number">0</span>) -&gt; a, <span class="type">UInt</span>(<span class="number">1</span>) -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<p>这可以用MuxCase来重写：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">MuxCase</span>(<span class="keyword">default</span>,<span class="type">Array</span>((idx === <span class="type">UInt</span>(<span class="number">0</span>)) -&gt; a,(idx === <span class="type">UInt</span>(<span class="number">1</span>)) -&gt; b, ...))</span><br></pre></td></tr></table></figure></p>
<h1 id="多态性和参数化">多态性和参数化</h1>
<p>Scala是一种强类型语言，使用参数化类型来指定通用函数和类。
在本节中，我们展示了Chisel用户如何使用参数化类来定义自己的可重用函数和类。</p>
<h2 id="参数化函数">参数化函数</h2>
<p>前面我们在Bool上定义了Mux2，但现在我们展示如何定义一个通用的多路复用器功能。我们使用一个布尔条件和con和alt参数（对应于then和else表达式）来定义一个T类型的函数：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Mux</span></span>[<span class="type">T</span> &lt;: <span class="type">Bits</span>](c: <span class="type">Bool</span>, con: <span class="type">T</span>, alt: <span class="type">T</span>): <span class="type">T</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中T需要是Bits的子类。Scala确保在Mux的每个使用中，它可以找到实际的con和alt参数类型的公共超类，否则会导致Scala编译类型错误。例如，<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Mux</span>(c, <span class="type">UInt</span>(<span class="number">10</span>), <span class="type">UInt</span>(<span class="number">11</span>))</span><br></pre></td></tr></table></figure></p>
这会产生一个UInt线，因为con和alt参数都是UInt类型。<br />
我们现在提出一个更高级的参数化函数的例子，用于定义一个内积FIR数字滤波器，通常用于Chisel
Num。 内积FIR滤波器可以在数学上定义为：<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/chisel-gongshi.png" />
</div>
<p>其中x是输入，w是权重向量。在Chisel中，这可以定义为：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delays</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](x: <span class="type">T</span>, n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">T</span>] =</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="type">List</span>(x) <span class="keyword">else</span> x :: <span class="type">Delays</span>(<span class="type">RegNext</span>(x), n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FIR</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span> <span class="keyword">with</span> <span class="type">Num</span>[<span class="type">T</span>]](ws: <span class="type">Seq</span>[<span class="type">T</span>], x: <span class="type">T</span>): <span class="type">T</span> = </span><br><span class="line">	(ws, <span class="type">Delays</span>(x, ws.length)).zipped.map( _ * _ ).reduce( _ + _ )</span><br></pre></td></tr></table></figure></p>
<p>其中延迟产生其输入的增量递增延迟的列表，并且reduce构造给出二进制组合器函数f的简化电路。在这种情况下，reduce创建一个求和电路。最后，FIR函数被限制为处理类型Num的输入，其中定义了Chisel乘法和加法。</p>
<h2 id="参数化类">参数化类</h2>
<p>与参数化函数一样，我们也可以参数化类，使它们可重用程度更高。例如，我们可以将Filter类概括为可以使用任何类型的链接。我们可以通过参数化FilterIO类和定义构造函数采取零参数类型构造函数来做到这点，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> x = <span class="keyword">type</span>.asInput.flip</span><br><span class="line">	<span class="keyword">val</span> y = <span class="keyword">type</span>.asOutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在可以通过定义一个模块类来定义Filter，该模块类也接收一个链接类型构造函数参数，并将其传递给FilterIO接口构造器：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">type: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">FilterIO</span>(<span class="class"><span class="keyword">type</span>)</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在可以定义一个基于PLant的过滤器，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Filter</span>(<span class="keyword">new</span> <span class="type">PLink</span>()))</span><br></pre></td></tr></table></figure></p>
<p>其中大括号{}表示零参数函数（也称为thunk），在这种情况下创建链接类型。<br />
通用FIFO可以这样定义，并使用如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBundle</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123; </span><br><span class="line">	<span class="keyword">val</span> <span class="type">A</span> = <span class="type">UInt</span>(width = <span class="number">32</span>)</span><br><span class="line">	<span class="keyword">val</span> <span class="type">B</span> = <span class="type">UInt</span>(width = <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FifoDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>() = <span class="keyword">new</span> <span class="type">Fifo</span>(<span class="keyword">new</span> <span class="type">DataBundle</span>, <span class="number">32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifo</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">type: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> enq_val = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> enq_rdy = <span class="type">Bool</span>(<span class="type">OUTPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> deq_val = <span class="type">Bool</span>(<span class="type">OUTPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> deq_rdy = <span class="type">Bool</span>(<span class="type">INPUT</span>) </span><br><span class="line">		<span class="keyword">val</span> enq_dat = <span class="keyword">type</span>.asInput </span><br><span class="line">		<span class="keyword">val</span> deq_dat = <span class="keyword">type</span>.asOutput</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">val</span> enq_ptr = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, sizeof(n)))</span><br><span class="line">	<span class="keyword">val</span> deq_ptr = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>, sizeof(n)))</span><br><span class="line">	<span class="keyword">val</span> is_full = <span class="type">Reg</span>(init = <span class="type">Bool</span>(<span class="literal">false</span>))</span><br><span class="line">	<span class="keyword">val</span> do_enq  = io.enq_rdy &amp;&amp; io.enq_val</span><br><span class="line">	<span class="keyword">val</span> do_deq  = io.enq_rdy &amp;&amp; io.deq_val </span><br><span class="line">	<span class="keyword">val</span> is_empty = !is_full &amp;&amp; (enq_ptr === deq_ptr)</span><br><span class="line">	<span class="keyword">val</span> deq_ptr_inc = deq_ptr + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">val</span> enq_ptr_inc = enq_ptr + <span class="type">UInt</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">val</span> is_full_next = <span class="type">Mux</span>(do_enq &amp;&amp; ~do_deq &amp;&amp; (enq_ptr_inc === deq_ptr), <span class="type">Bool</span>(<span class="literal">true</span>), <span class="type">Mux</span>(do_deq &amp;&amp; is_full, <span class="type">Bool</span>(<span class="literal">false</span>), is_full)) </span><br><span class="line">	enq_ptr := <span class="type">Mux</span>(do_enq, enq_ptr_inc, enq_ptr) </span><br><span class="line">	deq_ptr := <span class="type">Mux</span>(do_deq, deq_ptr_inc, deq_ptr) </span><br><span class="line">	is_full := is_full_next</span><br><span class="line">	<span class="keyword">val</span> ram = <span class="type">Mem</span>(n) </span><br><span class="line">	when (do_enq) &#123;</span><br><span class="line">		ram(enq_ptr) := io.enq_dat </span><br><span class="line">	&#125;</span><br><span class="line">	io.enq_rdy := !is_full </span><br><span class="line">	io.deq_val := !is_empty </span><br><span class="line">	ram(deq_ptr) &lt;&gt; io.deq_dat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以定义成通用解耦接口：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">data: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> ready = <span class="type">Bool</span>(<span class="type">INPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> valid = <span class="type">Bool</span>(<span class="type">OUTPUT</span>)</span><br><span class="line">	<span class="keyword">val</span> bits = data.clone.asOutput </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以使用该模板向任何信号集添加握手：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoupledDemo</span></span></span><br><span class="line"><span class="keyword">extends</span> <span class="type">DecoupledIO</span>()( <span class="keyword">new</span> <span class="type">DataBundle</span> )</span><br></pre></td></tr></table></figure></p>
<p>FIFO的接口也可以如下进行简化：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fifo</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>] (<span class="params">data: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">	<span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">		<span class="keyword">val</span> enq = <span class="keyword">new</span> <span class="type">DecoupledIO</span>( data ).flip() </span><br><span class="line">		<span class="keyword">val</span> deq = <span class="keyword">new</span> <span class="type">DecoupledIO</span>( data )</span><br><span class="line">	&#125;</span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多时钟域">多时钟域</h1>
<p>Chisel 2.0介绍了对多时钟域的支持。</p>
<h2 id="创建时钟域">创建时钟域</h2>
<p>为了使用多个时钟域，用户必须创建多个时钟。
在Chisel中，时钟是使用复位信号参数创建的第一级节点，定义如下：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> (<span class="params">reset: <span class="type">Bool</span></span>) <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>: <span class="type">Bool</span> <span class="comment">// returns reset pin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Chisel中有一个内置的隐式时钟，状态元素默认使用：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitClock = <span class="keyword">new</span> <span class="type">Clock</span>( implicitReset )</span><br></pre></td></tr></table></figure></p>
<p>状态元素和模块的时钟可以使用名为clock的附加命名参数来定义：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Reg</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Mem</span>(... clock: <span class="type">Clock</span> = implicitClock) </span><br><span class="line"><span class="type">Module</span>(... clock: <span class="type">Clock</span> = implicitClock)</span><br></pre></td></tr></table></figure></p>
<h2 id="交叉时钟域">交叉时钟域</h2>
<p>有两种方式可以定义电路在时钟域之间发送数据。第一种也是最原始的方式就是使用由两个寄存器组成的同步器电路，如下所示：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signalA is in clock domain clockA,</span></span><br><span class="line"><span class="comment">// want a version in clockB as signalB</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB) </span><br><span class="line"><span class="keyword">val</span> s2 = <span class="type">Reg</span>(init = <span class="type">UInt</span>(<span class="number">0</span>), clock = clockB)</span><br><span class="line">s1 := signalA</span><br><span class="line">s2 := s1;</span><br><span class="line">signalB := s2</span><br></pre></td></tr></table></figure></p>
<p>由于亚稳性问题，该技术只限于在域之间传递一位数据。<br />
在域之间发送数据的第二种和更一般的方式是通过使用异步fifo：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncFifo</span>[<span class="type">T</span>&lt;:<span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, entries: <span class="type">Int</span>, enq_clk: <span class="type">Clock</span>, deq_clock:<span class="type">Clock</span></span>) <span class="keyword">extends</span> <span class="title">Module</span></span></span><br></pre></td></tr></table></figure></p>
<p>当通过指定标准fifo参数和两个时钟，然后使用标准解耦就绪/有效信号从时钟域clockA到clockB获取一个版本的signalA时：<br />
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> fifo = <span class="keyword">new</span> <span class="type">AsyncFifo</span>(<span class="type">Uint</span>(width = <span class="number">32</span>), <span class="number">2</span>, clockA, clockB)</span><br><span class="line">fifo.io..enq.bits	:= signalA</span><br><span class="line">signalB				:= fifo.io.deq.bits</span><br><span class="line">fifo.io.enq.valid	:= condA</span><br><span class="line">fifo.io.deq.ready	:= condB</span><br></pre></td></tr></table></figure></p>
<h2 id="后端特定的多个时钟域">后端特定的多个时钟域</h2>
<p>每个Chisel后端需要用户以后端特定的方式设置和控制多个时钟。为了展示如何驱动一个多时钟设计，考虑这样一个硬件示例，其中两个模块使用Async-Fifo进行通信，每个模块在不同的时钟：fastClock和slowClock。</p>
<h3 id="c">C++</h3>
<p>在C++后端，对于每个时钟i有：<br />
- size_t clk.len域表示时钟i的周期<br />
- clock_lo_i，clock_hi_i - int reset()
函数，可以保证clock_lo和clock_hi的所有函数被立刻调用<br />
- int
clock(reset)函数，计算最小增量，调用合适的clock_lo和clock_hi，并返回使用的最小增量。</p>
<p>为了设置一个C++模拟器，用户需要：<br />
- 将所有周期字段初始化为期望的周期<br />
- 将所有计数字段初始化为期望的相位<br />
- 调用reset - 重复调用时钟来单步模拟</p>
<p>以下是slowClock / fastClock的main函数C++示例：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123; </span><br><span class="line">	ClkDomainTest_t dut; dut.<span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line">	dut.clk = <span class="number">2</span>;</span><br><span class="line">	dut.clk_cnt = <span class="number">1</span>; </span><br><span class="line">	dut.fastClock = <span class="number">4</span>; </span><br><span class="line">	dut.fastClock_cnt = <span class="number">0</span>; </span><br><span class="line">	dut.slowClock = <span class="number">6</span>; 	</span><br><span class="line">	dut.slowClock_cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i ++)</span><br><span class="line">	dut.<span class="built_in">reset</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">96</span>; i ++)</span><br><span class="line">		dut.<span class="built_in">clock</span>(<span class="built_in">LIT</span>&lt;<span class="number">1</span>&gt;(<span class="number">0</span>)); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="verilog">Verilog</h3>
<p>在Verilog中：<br />
- Chisel为每个时钟/复位创建一个新端口，<br />
- Chisel将所有的时钟连到顶层模块<br />
- 用户必须要为每个时钟i创建一个always块时钟驱动</p>
<p>以下是驱动slowClock / fastClock电路的顶层Verilog示例：<br />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> emulator;</span><br><span class="line">	<span class="keyword">reg</span> fastClock = <span class="number">0</span>, slowClock = <span class="number">0</span>, resetFast = <span class="number">1</span>, resetSlow = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] add, mul, test;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">2</span> fastClock = ~fastClock;</span><br><span class="line">	<span class="keyword">always</span> #<span class="number">4</span> slowClock = ~slowClock; </span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		# <span class="number">8</span></span><br><span class="line">		resetFast = <span class="number">0</span>; </span><br><span class="line">		resetSlow = <span class="number">0</span>; </span><br><span class="line">		#<span class="number">400</span></span><br><span class="line">	<span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ClkDomainTest dut (</span><br><span class="line">	<span class="variable">.fastClock</span>(fastClock), </span><br><span class="line">	<span class="variable">.slowClock</span>(slowClock), </span><br><span class="line">	<span class="variable">.io_resetFast</span>(resetFast),</span><br><span class="line">	<span class="variable">.io_resetSlow</span>(resetSlow),</span><br><span class="line">	<span class="variable">.io_add</span>(add), </span><br><span class="line">	<span class="variable">.io_mul</span>(mul), </span><br><span class="line">	<span class="variable">.io_test</span>(test));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>（完）</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>硬件描述语言</tag>
        <tag>Chisel</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——CLAide</title>
    <url>/2021/11/04/claide/</url>
    <content><![CDATA[<p><a href="https://github.com/CocoaPods/CLAide">CLAide</a> 是 CocoaPods
社区开发的一款命令行解析工具，其提供了一系列 API
允许我们快速创建自定义的命令行工具。iOS 开发者常用的依赖管理工具
CocoaPods 就是基于 CLAide 开发实现的。CocoaPods
通过各种子命令、参数、选项提供了诸多依赖管理相关功能。那么，CocoaPods
的各种命令、参数、选项如何映射到对应的功能实现呢？答案就是
CLAide。CLAide 的核心功能就是
<strong>解析不同的命令、参数、选项，并调用对应的功能实现</strong>。</p>
<span id="more"></span>
<p>下面，我们来看看 CLAide 究竟是如何实现的。</p>
<blockquote>
<p>注：本文分析的 CLAide 源码版本是 1.0.3。</p>
</blockquote>
<h1 id="整体结构">整体结构</h1>
<p>如下所示为 CLAide 核心部分的类图。</p>
<p>CLAide 是使用 Ruby 编写的，Ruby 采用的是不允许具有多个父类的
<strong>单一继承</strong> 模型，但是通过利用
mixin，可以既保持单一继承的关系，又可以同时让多个类共享功能。CLAide
也大量使用了 mixin，比如：<code>Help</code> 类通过 mixin
<code>InformativeError</code>，共享了其功能。Mixin 有点类似于 OC、swift
中的 protocol，因此在本文的类图中，我们将它等同为协议（接口）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/claide-01.png?x-oss-process=image/resize,w_800" /></p>
<p>CLAide 以 <code>Command</code> 抽象类为核心，它使用 <code>ARGV</code>
类对命令进行解析，解析成多个分解项，包括：<strong>子命令</strong>、<strong>选项</strong>、<strong>参数</strong>
等。根据 Ruby 的语言特性，通过 <strong>子命令</strong> 查找到同名的
<code>Command</code> 具体类，同时，将
<strong>选项</strong>、<strong>参数</strong> 传递给对应的
<code>Command</code> 具体类。<code>Command</code> 具体类则覆写
<code>run</code> 方法实现具体的功能。</p>
<p><code>Command</code> 抽象类在调用 <code>run</code> 之前，会先调用
<code>validate</code>
方法进行校验。校验的过程中会根据命令分解项，是否存在对应的
<code>Command</code>
具体类、参数是否符合预期等等。如果校验失败，则给出相似命令提示、命令使用的提示等等。</p>
<p>下面，我们将按照上述类图，结合 CocoaPods 的一些命令，对 CLAide
中的各个类进行介绍。</p>
<h1 id="命令解析">命令解析</h1>
<p>CLAide 的核心功能之一是 <strong>命令解析</strong>，我们以
<code>pod update</code> 命令为例，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/claide-02.png?x-oss-process=image/resize,w_800" /></p>
<p>在 CLAide 的定义中，一个完备的命令由以下 4 个部分组成：</p>
<ul>
<li>一个或多个 <strong>命令（command）</strong>：最左侧的命令称为
<strong>根命令（root command）</strong>，其余的命令称为
<strong>子命令（subcommand）</strong>。在命令行中，一个命令必须紧跟另一个命令。</li>
<li>零个或多个
<strong>参数（argument）</strong>：参数在命令中的位置是固定的，一般紧跟在最后一个子命令（或称叶子命令）。</li>
<li>零个或多个 <strong>标志（flag）</strong>：以 <code>--</code>
为前缀的特定描述，用于控制功能的开关。标志在命令中的位置不固定。</li>
<li>零个或多个
<strong>选项（option）</strong>：与标志的定义相同，区别在于选项会通过
<code>=</code> 拼接一个值。选项在命令中的位置不固定。</li>
</ul>
<h2 id="command">Command</h2>
<p>CLAide 定义了一个 <code>Command</code>
抽象类，其中命令组成部分的相关定义如下。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">CLAide</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">    <span class="keyword">class</span> &lt;&lt; <span class="variable language_">self</span></span><br><span class="line">      <span class="comment"># 命令是否为抽象命令（非叶子命令）</span></span><br><span class="line">      <span class="built_in">attr_accessor</span> <span class="symbol">:abstract_command</span></span><br><span class="line">      <span class="comment"># 为抽象命令进行代理的命令</span></span><br><span class="line">      <span class="built_in">attr_accessor</span> <span class="symbol">:default_subcommand</span></span><br><span class="line">      <span class="comment"># 命令功能摘要</span></span><br><span class="line">      <span class="built_in">attr_accessor</span> <span class="symbol">:summary</span></span><br><span class="line">      <span class="comment"># 命令功能描述</span></span><br><span class="line">      <span class="built_in">attr_accessor</span> <span class="symbol">:description</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 命令的参数</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">arguments</span></span><br><span class="line">        <span class="variable">@arguments</span> |<span class="params"></span>|= []</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 命令的名字</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">command</span></span><br><span class="line">        <span class="variable">@command</span> |<span class="params"></span>|= name.split(<span class="string">&#x27;::&#x27;</span>).last.gsub(<span class="regexp">/[A-Z]+[a-z]*/</span>) <span class="keyword">do</span> |<span class="params">part</span>|</span><br><span class="line">          part.downcase &lt;&lt; <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        <span class="keyword">end</span>[<span class="number">0</span>..-<span class="number">2</span>]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 命令的选项（包括标志、选项）</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.options</span><br><span class="line">        <span class="keyword">if</span> root_command?</span><br><span class="line">          <span class="variable constant_">DEFAULT_ROOT_OPTIONS</span> + <span class="variable constant_">DEFAULT_OPTIONS</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="variable constant_">DEFAULT_OPTIONS</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="variable constant_">DEFAULT_ROOT_OPTIONS</span> = [</span><br><span class="line">        [<span class="string">&#x27;--version&#x27;</span>, <span class="string">&#x27;Show the version of the tool&#x27;</span>],</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">      <span class="variable constant_">DEFAULT_OPTIONS</span> = [</span><br><span class="line">        [<span class="string">&#x27;--verbose&#x27;</span>, <span class="string">&#x27;Show more debugging information&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;--no-ansi&#x27;</span>, <span class="string">&#x27;Show output without ANSI codes&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;--help&#x27;</span>,    <span class="string">&#x27;Show help banner of specified command&#x27;</span>],</span><br><span class="line">      ]</span><br><span class="line">    </span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Command</code>
抽象类描述了如何定义一个命令的组成。<code>arguments</code>
方法定义了命令包含哪些参数；<code>self.options</code>
方法定义了命令包含哪些选项， 由于标志是一种特殊的选项，这里将使用
<code>self.options</code>
统一描述标志和选项。除此之外，还描述了命令是否为抽象命令（即是否为非叶子命令）、命令的名称等。</p>
<p>下面，我们来看一下 <code>pod update</code> 命令所对应的
<code>Command</code> 具体类，如下所示。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Update</span> &lt; <span class="title class_ inherited__">Command</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">self</span>.summary = <span class="string">&#x27;Update outdated project dependencies and create new &#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;Podfile.lock&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">self</span>.description = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">        Updates the Pods identified by the specified `POD_NAMES`, which is a</span></span><br><span class="line"><span class="string">        space-delimited list of pod names. If no `POD_NAMES` are specified, it</span></span><br><span class="line"><span class="string">        updates all the Pods, ignoring the contents of the Podfile.lock. This</span></span><br><span class="line"><span class="string">        command is reserved for the update of dependencies; pod install should</span></span><br><span class="line"><span class="string">        be used to install changes to the Podfile.</span></span><br><span class="line"><span class="string">      DESC</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">self</span>.arguments = [</span><br><span class="line">        <span class="title class_">CLAide::Argument</span>.new(<span class="string">&#x27;POD_NAMES&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>),</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.options</span><br><span class="line">        [</span><br><span class="line">          [<span class="string">&quot;--sources=<span class="subst">#&#123;<span class="title class_">Pod</span><span class="symbol">:</span><span class="symbol">:TrunkSource</span><span class="symbol">:</span><span class="symbol">:TRUNK_REPO_URL</span>&#125;</span>&quot;</span>, <span class="string">&#x27;The sources from which to update dependent pods. &#x27;</span> \</span><br><span class="line">           <span class="string">&#x27;Multiple sources must be comma-delimited&#x27;</span>],</span><br><span class="line">          [<span class="string">&#x27;--exclude-pods=podName&#x27;</span>, <span class="string">&#x27;Pods to exclude during update. Multiple pods must be comma-delimited&#x27;</span>],</span><br><span class="line">          [<span class="string">&#x27;--clean-install&#x27;</span>, <span class="string">&#x27;Ignore the contents of the project cache and force a full pod installation. This only &#x27;</span> \</span><br><span class="line">           <span class="string">&#x27;applies to projects that have enabled incremental installation&#x27;</span>],</span><br><span class="line">        ].concat(<span class="variable language_">super</span>)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述例子中，<code>Command</code> 具体类
<code>Pod::Command::Update</code>
覆写了部分方法和属性，这些方法和属性也为后续的命令解析提供了数据源。当然，命令的帮助描述也是基于这些方法和属性实现的，如下所示为
<code>pod update</code> 命令的描述信息与定义的映射关系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/claide-03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="argument">Argument</h2>
<p>在上述例子中，<code>Pod::Command::Update</code> 使用通过覆写
<code>arguments</code> 属性来配置该命令支持的参数列表，类型为
<code>Array&lt;Argument&gt;</code>，它最终会格式化成对应的信息，展示在
<code>Usage</code> banner 中。</p>
<p><code>Argument</code> 的构造方法如下： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># argument.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">CLAide</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Argument</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">names, required, repeatable = <span class="literal">false</span></span>)</span><br><span class="line">      <span class="variable">@names</span> = <span class="title class_">Array</span>(names)</span><br><span class="line">      <span class="variable">@required</span> = required</span><br><span class="line">      <span class="variable">@repeatable</span> = repeatable</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>names</code> 表示 <code>Usage</code> banner
中参数的名称，在上述例子中是 <code>POD_NAMES</code>。</p>
<p><code>require</code> 表示 <code>Argument</code>
是否为必选参数，可选参数会使用 <code>[]</code>
包装起来。在上述例子中，<code>pod update</code> 命令默认不需要传
<code>POD_NAMES</code> 参数。</p>
<p><code>repeatable</code> 表示 <code>Argument</code>
是否可以重复多次出现。如果是可重复，则会在 <code>names</code>
输出的信息后面添加 <code>...</code> 表示该参数为可重复参数，比如：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pod update Alamofire, RxSwift</span></span><br></pre></td></tr></table></figure></p>
<h2 id="argv">ARGV</h2>
<p>在上述例子中，<code>Pod::Command::Update</code> 通过覆写
<code>options</code>、<code>arguments</code> 等方法和属性，声明了一个
<code>pod update</code>
命令的组成标准。在实际使用时，我们会输入命令、参数、选项。其中，这些输入内容由
<code>ARGV</code> 负责解析。</p>
<p><code>ARGV</code> 使用
<code>:arg</code>、<code>:flag</code>、<code>:option</code>
分别表示参数（和命令）、标志、选项，并在内部调用一个私有模块
<code>Parser</code> 进行解析，解析方法如下所示： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># argv.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.parse(argv)</span><br><span class="line">  entries = []</span><br><span class="line">  copy = argv.map(&amp;<span class="symbol">:to_s</span>)</span><br><span class="line">  double_dash = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> argument = copy.shift</span><br><span class="line">    <span class="keyword">next</span> <span class="keyword">if</span> !double_dash &amp;&amp; double_dash = (argument == <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">    type = double_dash ? <span class="symbol">:arg</span> : argument_type(argument)</span><br><span class="line">    parsed_argument = parse_argument(type, argument)</span><br><span class="line">    entries &lt;&lt; [type, parsed_argument]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  entries</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>ARGV</code> 将解析结果存储在一个内部数组 <code>@entries</code>
中，以
<code>pod update Alamofire --no-repo-update --exclude-pods=RxSwift</code>
为例，其存储的内容如下： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">@entries</span> = [</span><br><span class="line">  [<span class="symbol">:arg</span>, <span class="string">&quot;update&quot;</span>],</span><br><span class="line">  [<span class="symbol">:arg</span>, <span class="string">&quot;Alamofire&quot;</span>],</span><br><span class="line">  [<span class="symbol">:flag</span>, [<span class="string">&quot;repo-update&quot;</span>, <span class="literal">false</span>]],</span><br><span class="line">  [<span class="symbol">:option</span>, [<span class="string">&quot;exclude-pods&quot;</span>, <span class="string">&quot;RxSwift&quot;</span>]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>此外，<code>ARGV</code>
还提供了一系列遍历方法，用于读取/操作参数、标志、选项等。</p>
<h1 id="命令查找">命令查找</h1>
<p>我们注意到 <code>ARGV</code> 使用 <code>:argv</code>
同时表示参数和命令，这里为什么这么做？</p>
<p>我们知道选项和标志都是使用 <code>--</code> 作为前缀，选项使用
<code>=</code> 对 key 和 value
进行拆分，两者都是有明显的特征的，而命令和参数在表示上并没有明显区别。因此，<code>ARGV</code>
暂时将命令和参数都标记为 <code>:arg</code>，具体的解析和区分交给
<code>Command</code> 中的 <code>parse</code>
方法来处理，该方法如下所示。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.parse(argv)</span><br><span class="line">  <span class="comment"># 通过解析 argv 获取到与 cmd 名称</span></span><br><span class="line">  argv = <span class="variable constant_">ARGV</span>.coerce(argv)</span><br><span class="line">  cmd = argv.arguments.first</span><br><span class="line">  <span class="keyword">if</span> cmd &amp;&amp; subcommand = find_subcommand(cmd)</span><br><span class="line">    <span class="comment"># 如果 cmd 存在对应的 Command 类，则更新 argv，继续解析命令</span></span><br><span class="line">    argv.shift_argument</span><br><span class="line">    subcommand.parse(argv)</span><br><span class="line">  <span class="keyword">elsif</span> abstract_command? &amp;&amp; default_subcommand</span><br><span class="line">    <span class="comment"># 如果 cmd 为抽象命令且指定了默认命令，则返回默认命令继续解析参数</span></span><br><span class="line">    load_default_subcommand(argv)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 初始化真正的 cmd 实例</span></span><br><span class="line"></span><br><span class="line">    new(argv)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>命令查找的过程是一个 <strong>多叉树遍历</strong>
的过程，整个过程如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/claide-04.png?x-oss-process=image/resize,w_800" /></p>
<p>在命令查找过程中，首先查找命令的子命令，那么这里的子命令是从哪里来的呢？命令和子命令是如何关联的呢？<strong>这里其实巧妙利用了
Ruby 的语言特性，通过 Hook Method <code>self.inherited</code>
获取继承它的子类，并将其保存在 <code>subcommands</code>
数组中</strong>，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.inherited(subcommand)</span><br><span class="line">  subcommands &lt;&lt; subcommand</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>最终，命令查找会根据 <code>ARGV</code> 所解析的 <code>:arg</code>
找到对应的 <strong>叶子命令</strong> 或
<strong>抽象命令的代理命令</strong>。找到对应的命令后，使用
<code>ARGV</code> 中剩余的参数实例化命令。注意，在整个过程中，会逐步消耗
<code>ARGV</code> 中的解析结果。</p>
<h1 id="命令校验">命令校验</h1>
<p>命令查找结果是创建一个 <code>Command</code> 对象，该命令对象会使用
<code>ARGV</code> 中的解析结果设置其所需要的参数、选项、标志。</p>
<p>之后，会进一步进行命令校验，校验的目的是判断命令行中是否有多余或错误的参数，具体如下：
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validate!</span></span><br><span class="line">  <span class="comment"># 如果有 --help 标志，则打印使用帮助</span></span><br><span class="line">  banner! <span class="keyword">if</span> help?</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unless</span> <span class="variable">@argv</span>.empty?</span><br><span class="line">    <span class="comment"># 如果 argv 存在多余的解析结果，则根据第一个多余的解析结果，决定打印哪项使用帮助</span></span><br><span class="line">    argument = <span class="variable">@argv</span>.remainder.first</span><br><span class="line">    help! <span class="title class_">ArgumentSuggester</span>.new(argument, <span class="variable language_">self</span>.<span class="keyword">class</span>).suggestion</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 如果命令是抽象命令，则打印使用帮助</span></span><br><span class="line">  help! <span class="keyword">if</span> <span class="variable language_">self</span>.<span class="keyword">class</span>.abstract_command?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>首先，判断命令行中是够存在 <code>--help</code>
标志，如果存在，则打印使用帮助。</p>
<p>其次，判断是够存在剩余未解析的参数或选项，如果有，则取出第一个多余的参数或选项作为参数，初始化一个
<code>ArgumentSuggester</code> 对象，<code>ArgumentSuggester</code>
或给出一个建议性的提示信息，并将该信息作为参数传递给 <code>help!</code>
方法。</p>
<p>最后，判断命令是否是抽象命令，如果是，则直接调用 <code>help!</code>
方法。</p>
<h2 id="help">Help</h2>
<p><code>help!</code> 方法的定义如下，其内部会调用一个
<code>help!</code> 类方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">help!</span>(<span class="params">error_message = <span class="literal">nil</span></span>)</span><br><span class="line">  invoked_command_class.help!(error_message)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>help!</code> 类方法定义如下，它会抛出一个标准错误对象
<code>Help</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.help!(error_message = <span class="literal">nil</span>, help_class = <span class="title class_">Help</span>)</span><br><span class="line">  <span class="keyword">raise</span> help_class.new(banner, error_message)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>标准错误会被 <code>Command</code>
捕获，并调用如下所示的异常处理方法，它最终会在控制台打印错误信息，也可以选择打印出错堆栈。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.handle_exception(command, exception)</span><br><span class="line">  <span class="keyword">if</span> exception.is_a?(<span class="title class_">InformativeError</span>)</span><br><span class="line">    puts exception.message</span><br><span class="line">    <span class="keyword">if</span> command.<span class="literal">nil</span>? |<span class="params"></span>| command.verbose?</span><br><span class="line">      puts</span><br><span class="line">      puts(*exception.backtrace)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    exit exception.exit_status</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    report_error(exception)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="banner">Banner</h2>
<p>在调用 <code>self.help!</code> 方法时，我们会传入一个
<code>banner</code> 参数，事实上，这是一个 <code>Banner</code>
对象，<code>banner</code> 的定义如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.banner(banner_class = <span class="title class_">Banner</span>)</span><br><span class="line">  banner_class.new(<span class="variable language_">self</span>).formatted_banner</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Banner</code> 类基于 <code>Command</code>
类的相关信息，将命令的摘要、描述、参数、选项、标志进行了格式化封装。<code>Banner</code>
内部基于 ANSI
转义码对字符串进行封装，从而能够支持不同的颜色、字体等，如下所示是
<code>pod update --help</code> 的格式化内容输出。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/claide-05.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="命令运行">命令运行</h1>
<p>当命令校验通过后，会调用命令对象的 <code>run</code>
方法，<code>Command</code> 具体类通过覆写 <code>run</code>
方法实现具体逻辑。</p>
<h1 id="整体流程">整体流程</h1>
<p>我们以
<code>pod update Alamofire --no-repo-update --exclude-pods=RxSwift</code>
为例， 当我们在命令行中输入命令后，会转换成如下所示的方法调用。
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bin/pod</span></span><br><span class="line"><span class="variable">$ </span><span class="title class_">Pod</span><span class="symbol">:</span><span class="symbol">:Command</span>.run([<span class="string">&quot;update&quot;</span>, <span class="string">&quot;Alamofire&quot;</span>, <span class="string">&quot;--no-repo-update&quot;</span>, <span class="string">&quot;--exclude-pods=RxSwift&quot;</span>])</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>run</code> 方法是一个类方法，其定义如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.run(argv = [])</span><br><span class="line">  <span class="comment"># 加载插件</span></span><br><span class="line">  plugin_prefixes.each <span class="keyword">do</span> |<span class="params">plugin_prefix</span>|</span><br><span class="line">    <span class="title class_">PluginManager</span>.load_plugins(plugin_prefix)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 命令解析</span></span><br><span class="line">  argv = <span class="variable constant_">ARGV</span>.coerce(argv)</span><br><span class="line">  <span class="comment"># 命令查找</span></span><br><span class="line">  command = parse(argv)</span><br><span class="line">  <span class="variable constant_">ANSI</span>.disabled = !command.ansi_output?</span><br><span class="line">  <span class="keyword">unless</span> command.handle_root_options(argv)</span><br><span class="line">    <span class="comment"># 命令校验</span></span><br><span class="line">    command.validate!</span><br><span class="line">    <span class="comment"># 命令运行</span></span><br><span class="line">    command.run</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">rescue</span> <span class="title class_">Object</span> =&gt; exception</span><br><span class="line">    handle_exception(command, exception)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="pluginmanager">PluginManager</h2>
<p>整体流程中的第一个步骤就是加载插件，该任务由
<code>PluginManager</code>
负责完成，其仅加载命令类中指定前缀标识的文件下的命令。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plugin_manager.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.load_plugins(plugin_prefix)</span><br><span class="line">  loaded_plugins[plugin_prefix] |<span class="params"></span>|=</span><br><span class="line">  plugin_gems_for_prefix(plugin_prefix).map <span class="keyword">do</span> |<span class="params">spec, paths</span>|</span><br><span class="line">    spec <span class="keyword">if</span> safe_activate_and_require(spec, paths)</span><br><span class="line">  <span class="keyword">end</span>.compact</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.plugin_gems_for_prefix(prefix)</span><br><span class="line">  glob = <span class="string">&quot;<span class="subst">#&#123;prefix&#125;</span>_plugin<span class="subst">#&#123;<span class="title class_">Gem</span>.suffix_pattern&#125;</span>&quot;</span></span><br><span class="line">  <span class="comment"># 查找所有 gem 的 specification 进行查找匹配</span></span><br><span class="line">  <span class="title class_">Gem</span><span class="symbol">:</span><span class="symbol">:Specification</span>.latest_specs(<span class="literal">true</span>).map <span class="keyword">do</span> |<span class="params">spec</span>|</span><br><span class="line">    matches = spec.matches_for_glob(glob)</span><br><span class="line">    [spec, matches] <span class="keyword">unless</span> matches.empty?</span><br><span class="line">  <span class="keyword">end</span>.compact</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.safe_activate_and_require(spec, paths)</span><br><span class="line">  <span class="comment"># 动态导入文件</span></span><br><span class="line">  spec.activate</span><br><span class="line">  paths.each &#123; |<span class="params">path</span>| <span class="keyword">require</span>(path) &#125;</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">Exception</span> =&gt; exception <span class="comment"># rubocop:disable RescueException</span></span><br><span class="line">  message = <span class="string">&quot;\n---------------------------------------------&quot;</span></span><br><span class="line">  message &lt;&lt; <span class="string">&quot;\nError loading the plugin `<span class="subst">#&#123;spec.full_name&#125;</span>`.\n&quot;</span></span><br><span class="line">  message &lt;&lt; <span class="string">&quot;\n<span class="subst">#&#123;exception.<span class="keyword">class</span>&#125;</span> - <span class="subst">#&#123;exception.message&#125;</span>&quot;</span></span><br><span class="line">  message &lt;&lt; <span class="string">&quot;\n<span class="subst">#&#123;exception.backtrace.join(<span class="string">&quot;\n&quot;</span>)&#125;</span>&quot;</span></span><br><span class="line">  message &lt;&lt; <span class="string">&quot;\n---------------------------------------------\n&quot;</span></span><br><span class="line">  warn message.ansi.yellow</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>插件加载流程大体如下：</p>
<ul>
<li>调用 <code>load_plugins</code> 并传入
<code>plugin_prefix</code>。</li>
<li><code>plugin_gems_for_prefix</code>
对插件名进行处理，查找对应的文件。</li>
<li>调用 <code>safe_activate_and_require</code> 对相应的 gem spec
进行校验，并对加载每个文件。</li>
</ul>
<p>CocoaPods 的插件加载正是依托于 CLAide 的
<code>load_plugins</code>，它会遍历所有的 RubyGem，并搜索这些 Gem
中是否包含名为 <code>#&#123;plugin_prefix&#125;_plugin.rb</code> 的文件。</p>
<p>在 CocoaPods 中，其配置如下。<strong>它会加载所有包含
<code>claide_plugin.rb</code> 或 <code>cocoapods_plugins.rb</code>
文件的 gem</strong>。通过在运行时的文件检查加载符合要求的相关命令。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">self</span>.plugin_prefixes = <span class="string">%w(claide cocoapods)</span></span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本文，梳理了 CLAide 的工作流程，主要包含四个步骤：</p>
<ul>
<li>命令解析</li>
<li>命令查找</li>
<li>命令校验</li>
<li>命令执行</li>
</ul>
<p>这四个步骤各自由一些类负责实现。此外，在整体流程中，CLAide
会加载它所依赖的插件，由 <code>PluginManager</code>
实现，这也是插件功能的核心部分。</p>
<p>CLAide
采用的设计模式是模板方法模式，开发者实现具体的命令类，只需要覆写相关方法即可，CocoaPods
就是基于 CLAide 设计实现的，具有非常好的扩展性，并且支持插件机制。</p>
<p>在了解了 CLAide 的原理后，我们再去解读 CocoaPods
的源码，思路就会清晰很多。后续有时间，我们再来深入分析一下 CocoaPods
中的设计细节。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/CocoaPods/CLAide">CLAide</a></li>
<li><a
href="https://www.desgard.com/2020/09/02/cocoapods-story-3.html">CocoaPods
命令解析 - CLAide</a></li>
</ol>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>CLAide</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>Clang Module</title>
    <url>/2021/02/11/clang-module/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>在日常开发中，绝大多数软件都是基于一系列的库（Library）构建而成的，这些库包括平台所提供的库、软件自身的内建库以及第三方库。库的实现主要包括两部分：<strong>接口</strong>（interface，或称
API）和 <strong>实现</strong>（Implementation）。在 C
家族的语言中，一般都通过包含（include）头文件（header
files）的方式来访问库的接口，如下所示。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SomeLib.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>头文件包含后，再通过链接器链接至对应的库，从而完成接口与实现的绑定，比如：通过传递
<code>-lSomeLib</code> 参数给链接器完成接口与实现的绑定。</p>
<p>模块（Module）提供了另一种更为简单的使用库的方式。模块能够提供更好的编译时可伸缩性，并且能够消除使用
C 预处理器访问库的 API 时所遇到的各种问题。</p>
<h1 id="基于预处理的文本包含模型">基于预处理的文本包含模型</h1>
<p>通过 C 预处理器提供的 <code>#include</code> 方式来访问库的 API
并不是一种优雅的方式，因为它存在着很多问题，主要有以下这些：</p>
<ul>
<li><strong>编译时可扩展性</strong>。每当包含一个头文件时，编译器会预处理、解析头文件中的文本，并递归地处理该头文件所包含的头文件。应用程序编译过程中的每一个
<strong>编译单元</strong>（Translation
Unit）都是如此，因此存在着大量的重复工作。假如，一个项目包含 N
个编译单元，每个编译单元包含 M
个头文件，尽管编译单元相互之间共享着一部分头文件，编译器的编译时间复杂度还是会达到
M x N。对于
C++，情况更加糟糕，因为模板的编译模型会将大量代码强制写入头文件，导致编译单元工作量增大。</li>
<li><strong>易错性</strong>。预处理器将 <code>#include</code>
视为文本包含，因此在包含时接受任何宏定义。如果宏定义与库中的名称产生冲突，那么可能会破坏库
API 或导致库的头文件编译失败。比如，定义
<code>#define std "The C++ Standard"</code>
并包含一个标准库的头文件，这会产生一系列编译报错。当两个不同库的头文件之间存在宏定义冲突时，会产生很多细节的问题，这时就需要通过重新排序
<code>#include</code> 或者引入 <code>#undef</code>
来解决某些依赖关系。</li>
<li><strong>常规解决方法</strong>：C 语言开发者采用了很多约定来解决 C
预处理器模型的易错性。比如，通过 <strong>包含保护</strong>（Include
Guard）保证多次包含不会产生编译出错；宏的名称采用
<code>LONG_PREFIXED_UPPERCASE_IDENTIFIERS</code>
的规则进行定义，从而避免冲突；甚至，某些库或框架的开发者通过在头文件中使用带下划线的非常规的宏名称，避免与常规的宏名称产生冲突。总体而言，这些解决方式都不够优雅。</li>
</ul>
<blockquote>
<p><strong>编译单元</strong>：当一个 c 或 cpp
文件在编译时，预处理器首先递归地包含头文件，形成一个包含所有必要信息的单个源文件，该源文件就是一个编译单元。</p>
</blockquote>
<h1 id="基于模块的语义导入模型">基于模块的语义导入模型</h1>
<p>通过将 <strong>基于预处理的文本包含模型</strong> 替换成
<strong>基于模块的语义导入模型</strong>（或称
<strong>模块导入模型</strong>），能够有效改善对库 API
的访问。从开发者的角度看，代码略有不同，仅仅是使用 <code>import</code>
声明和使用 <code>#include</code> 声明的区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">std</span>.io</span><br></pre></td></tr></table></figure>
<p>事实上，使用 <code>import std.io</code> 的模块导入方式和使用
<code>#include &lt;stdio.h&gt;</code>
的文本包含方式完全不同：当编译器发现上面的模块导入时，它会加载
<code>std.io</code> 模块的二进制表示，并将其 API
直接提供给应用程序。在模块导入声明之前的文本包含声明不会对
<code>std.io</code> 提供的 API
产生影响，因为模块本身是作为独立的此外，模块进行编译的。此外，导入
<code>std.io</code>
模块时，会自动提供链接器所需的链接选项。最重要的是，这种语义导入模型能够解决能够预处理包含模型的难以解决的问题：</p>
<ul>
<li><strong>编译时可扩展性</strong>：<code>std.io</code>
模块只会编译一次，并且将模块导入编译单元是一个常量操作（与模块系统无关）。因此，每个库的
API 只会解析一次，从而将 M x N 的时间复杂度降低到 M + N。</li>
<li><strong>易错性</strong>：每个模块被解析为一个独立实体，因此它们具有一致的预处理器环境，也就不需要通过下划线的方式来避免冲突了。除此之外，如果当前的预处理定义之前存在同一个库的导入声明，那么这里的预处理声明就会被忽略，因此一个库不会影响另一个库的编译，从而消除了包含顺序的依赖关系。</li>
</ul>
<h1 id="模块的局限性">模块的局限性</h1>
<p>很多编程语言都有模块系统或包系统，由于这些语言的功能多种多样，因此必须定义模块能力范围。下面列出的所有内容都不在模块的能力范围之中：</p>
<ul>
<li><strong>重写代码</strong>：要求应用程序或库进行大幅度的修改或非向后兼容的修改是不现实的，完全消除头文件也是不可行的。模块必须要和现有的库共存，并允许逐步替过渡。</li>
<li><strong>版本控制</strong>：模块并没有版本信息的概念。开发者必须依赖语言的版本控制机制（如果存在）来对库（模块）进行版本控制。</li>
<li><strong>命名空间</strong>：与某些语言不通，模块并不意味着命名空间。因此，在一个模块中声明的结构体仍然可能会与不同模块中声明的同名结构体产生冲突，就像在两个不同的头文件中声明它们一样。这方面对于向后兼容非常重要，比如，在引入模块时，库中的实体的
<strong>修饰别名</strong>（Mangled Name）不能被修改。</li>
<li><strong>模块的二进制分发</strong>：头文件（特别是 C++
头文件）暴露了语言的全部复杂性。从技术方面而言，在体系结构、编译器版本、编译器供应商之间维持稳定的二进制模块格式是不可行的。</li>
</ul>
<h1 id="如何使用模块">如何使用模块</h1>
<p>要启用模块，需要传递命令行参数
<code>-fmodules</code>。这将使所有支持模块的库都可作为模块被使用，同时也会引入模块特定语法。</p>
<h2 id="objective-c-导入声明">Objective-C 导入声明</h2>
<p>Objective-C 支持以 <code>@import declaration</code>
的方式导入模块，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> std;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>@import</code> 声明会导入 <code>std</code>
模块的所有内容（可能包含完整的 C 或 C++ 标准库），从而使其 API
在当前的编译单元中可见。如果希望导入模块的一部分，可以使用点语法来导入指定的子模块，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> std.io;</span><br></pre></td></tr></table></figure>
<p>重复的导入声明会被忽略。此外，如果导入声明位于全局范围内，那么可以在编译单元的任何位置导入模块。</p>
<p>目前为止，还没有用于导入声明的 C 或 C++ 语法。Clang 会持续关注 C++
委员会中关于模块的提议。</p>
<h2 id="include-自动转换为-import"><code>include</code> 自动转换为
<code>import</code></h2>
<p>模块的最主要的用户级功能是 <strong>导入</strong>
操作，模块导入之后即可访问库的 API。但是，现在的应用程序广泛使用
<code>#include</code>，将这些代码全部改成 <code>import</code>
的方式是不现实的。为此，<strong>模块会自动将 <code>#include</code>
指令转换为相应的模块导入</strong>。下面例子中的 <code>#include</code>
指令会被自动转换为对模块 <code>std.io</code> 的导入。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>所有启用了模块的库都能够将 <code>#include</code> 自动转换为
<code>import</code>，这对向后兼容性非常重要，可以无需修改应用程序的代码，也能够享受到模块的优势。</p>
<blockquote>
<p>注：<code>#include</code> 到 <code>import</code>
的自动转换也解决了另一个问题：当导入一个具有某个实体定义（如：<code>struct Point</code>）的模块后，解析到一个头文件，其包含了另一个
<code>struct Point</code> 的定义，即使 <code>struct Point</code>
是同一个，那么也会出现重复定义的报错。通过将 <code>#include</code>
映射到
<code>import</code>，编译器可以保证它始终只看到模块中已经解析的定义。</p>
</blockquote>
<p>除此之外，模块也会对 <code>#include_next</code>
进行转换。<code>#include_next</code> 的一般用法是：在
<code>include</code>
路径列表中查找特定的文件名，从找到的当前文件的下一个路径往后找。在模块中，由于
<code>module maps</code> 中列出的文件并不会通过 <code>include</code>
路径来查找，对于这些文件，<code>#include_next</code>
采取了一种不同的策略：在 <code>include</code>
路径列表中来搜索指定的头文件名，从而找到第一个引用当前文件的
<code>include</code> 路径。如果找到了 <code>module maps</code>
命名的文件，那么 <code>#include_next</code> 会被转换成
<code>import</code> 命令。</p>
<h1 id="module-maps">Module Maps</h1>
<p>本质上，模块和头文件之间的关系是通过
<strong>模块映射</strong>（module map）来定义的，<code>module map</code>
描述了现有的头文件是如何组成一个模块结构的。比如，一个包含了 C 标砖库的
<code>std</code> 模块。每个 C
标准库头文件（如：<code>&lt;stdio.h&gt;</code>、<code>&lt;stdlib.h&gt;</code>、<code>&lt;math.h&gt;</code>）都可以将它们各自的
API
放入对应的子模块中（如：<code>std.io</code>、<code>std.lib</code>、<code>std.math</code>）。</p>
<p>一般而言，<code>module map</code>
是一个特定的独立文件（比如：<code>module.modulemap</code>），文件中定义了对应模块所包含头文件。如下所示是
iOS 中 <code>SnapKit</code> 框架的 <code>modulemap</code> 文件
<code>SnapKit.modulemap</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">module SnapKit &#123;</span><br><span class="line">  umbrella header <span class="string">&quot;SnapKit-umbrella.h&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> *</span><br><span class="line">  module * &#123; <span class="keyword">export</span> * &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模块编译模型">模块编译模型</h1>
<p>编译器会根据需要自动生成模块的二进制表示。当一个模块被导入时（比如：通过
<code>#include</code>
导入模块的一个头文件），编译器会生成一个编译单元来解析模块中的头文件，然后将生成的抽象语法树（Abstract
Syntax
Tree，AST）持久保存在模块的二进制表示中，当遇到模块导入时，在将其加载到编译单元之中。</p>
<p>模块的二进制表示存储在 <strong>模块缓存</strong>（module
cache）中。当导入一个模块时，会首先查找模块缓存，如果所需模块的二进制表示存在，则直接进行加载。因此，每个语言配置只会对模块的头文件进行一次解析，而不会在每个使用该模块的编译单元中都进行解析。</p>
<p>模块包含着模块构建所依赖的头文件。如果对这些头文件中的任何头文件进行修改，或者对模块所依赖的某个模块进行修改，那么编译器会自动重新编译该模块。这个过程不需要开发者进行干预。</p>
<h1 id="模块映射语言">模块映射语言</h1>
<p><strong>模块映射语言</strong>（module map
language）描述了如何将头文件进行映射并组合成模块。为了能够将一个库作为模块来使用，必须要为库定义一个
<code>module.modulemap</code> 文件。如下所示，是为 C 标准库定义
<code>module map</code> 文件的例子。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module <span class="built_in">std</span> [system] [extern_c] &#123;</span><br><span class="line">  module assert &#123;</span><br><span class="line">    textual header <span class="string">&quot;assert.h&quot;</span></span><br><span class="line">    header <span class="string">&quot;bits/assert-decls.h&quot;</span></span><br><span class="line">    export *</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  module <span class="type">complex</span> &#123;</span><br><span class="line">    header <span class="string">&quot;complex.h&quot;</span></span><br><span class="line">    export *</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  module ctype &#123;</span><br><span class="line">    header <span class="string">&quot;ctype.h&quot;</span></span><br><span class="line">    export *</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  module errno &#123;</span><br><span class="line">    header <span class="string">&quot;errno.h&quot;</span></span><br><span class="line">    header <span class="string">&quot;sys/errno.h&quot;</span></span><br><span class="line">    export *</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  module fenv &#123;</span><br><span class="line">    header <span class="string">&quot;fenv.h&quot;</span></span><br><span class="line">    export *</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...more headers follow...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，顶层模块
<code>std</code> 包含了整个 C
标准库。它具有很多子模块，这些子模块包含了标准库的不同部分：<code>complex</code>
模块用于复数，<code>ctype</code>
模块用于字符类型等。每个子模块列出了一个或多个头文件，这些头文件为对应子模块提供了具体的内容。最后，<code>export *</code>
命令指定对应子模块包含的所有内容将自动重新导出。</p>
<p>与编程语言一样，模块映射语言也有很多预定义的修饰符，如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config_macros   export_as    private</span><br><span class="line">conflict        framework    requires</span><br><span class="line">exclude         header       textual</span><br><span class="line">explicit        link         umbrella</span><br><span class="line"><span class="keyword">extern</span>          module       use</span><br><span class="line">export</span><br></pre></td></tr></table></figure></p>
<p>这里主要介绍一下 <code>framework</code> 和 <code>umbrella</code>
关键字。</p>
<p><code>framework</code> 修饰符指定了模块对应了 Darwin
风格的框架。Darwin 风格的框架（主要用于 macOS 和 iOS）通常是包含在一个
<code>Name.framework</code> 的目录中，其中 <code>Name</code>
是框架的名称（也就是模块的名称）。该目录的结构如下所示：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name.framework/</span><br><span class="line">  Modules/module.modulemap  Module map <span class="keyword">for</span> the framework</span><br><span class="line">  Headers/                  Subdirectory containing framework headers</span><br><span class="line">  PrivateHeaders/           Subdirectory containing framework private headers</span><br><span class="line">  Frameworks/               Subdirectory containing embedded frameworks</span><br><span class="line">  Resources/                Subdirectory containing additional resources</span><br><span class="line">  Name                      Symbolic <span class="built_in">link</span> to the shared library <span class="keyword">for</span> the framework</span><br></pre></td></tr></table></figure></p>
<p><code>umbrella</code> 修饰符指定的头文件被称为 <strong>umbrella
header</strong>。<code>umbrella header</code>
包含了其目录（以及任何子目录）下的全部头文件，通常用于（在
<code>#include</code> 世界中）轻松访问某个库的所有
API。对于模块而言，<code>umbrella header</code> 是一种快捷方式，通过
<code>umbrella header</code>，就不需要为每个库的头文件定义头文件声明。一个目录只能包含一个
<code>umbrella header</code>。举个例子，我们可以通过导入
<code>UIKit</code> 的 <code>umbrella header</code>代替多个导入命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>代替 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIViewController.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UILabel.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIButton.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIDatePicker.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>本文对比了两种访问接口的方式：文本包含方式
<code>#include</code>、模块导入方式 <code>import</code>，介绍了 Clang
如何将 <code>import</code> 的优势向后兼容至
<code>#include</code>。最后，简单介绍了模块在 iOS 开发中的应用。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://clang.llvm.org/docs/Modules.html#includes-as-imports">Clang
12 documentation——Modules</a></li>
<li><a
href="https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0">名字修饰</a></li>
<li><a
href="https://blog.csdn.net/rrrfff/article/details/7228704">编程方式解析C++符号修饰别名(mangled
name)</a></li>
<li><a
href="https://blog.csdn.net/fjb2080/article/details/5247494">gcc：预处理语句－－#include和#include_next</a></li>
</ol>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Clang</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——Codable</title>
    <url>/2021/10/18/codable/</url>
    <content><![CDATA[<p>Swift 4.0
支持了一个新的语言特性——Codable，其提供了一种非常简单的方式支持模型和数据之间的转换。</p>
<span id="more"></span>
<p>关于 Codable，今年年初的时候，我在调研如何让 Codable
在数据转模型时支持默认值，为了能够对 Codable
有个整体印象，我简单阅读了一下源码。当时感觉 Codable
的源码涉及到的类非常多，而且不同的类似乎实现了同样的协议，方法传来传去地执行，整体给人的感觉有点懵。</p>
<p>直到最近，在研究了 Swift 泛型协议和类型擦除后，我对 Codable
逐渐有了一个清晰的认知。本文，则记录了我在阅读 Codable
源码后对于它的一些理解。</p>
<p>本文阅读的 Codable 源码文件主要包含两个文件： - <a
href="https://github.com/apple/swift/blob/56a1663c9859f1283904cb0be4774a4e79d60a22/stdlib/public/core/Codable.swift">Codable.swift</a>
- <a
href="https://github.com/apple/swift/blob/56a1663c9859f1283904cb0be4774a4e79d60a22/stdlib/public/SDK/Foundation/JSONEncoder.swift">JSONEncoder.swift</a></p>
<p>这两个文件中定义了非常多的类，为了能够对各个类有个清晰的认知，我为各个类（包括私有类）抽取了独立的文件，以便于阅读，<a
href="https://github.com/baochuquan/analyze-codable">代码传送门</a>。</p>
<p>下文我们将从使用 Codable 进行 JSON 数据和模型转换的示例说起。</p>
<h1 id="使用示例">使用示例</h1>
<p>通过 Codable，我们很容易就能实现 JSON
数据和自定义模型之间的相互转换，如下所示。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Address</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> province: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> city: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> age</span><br><span class="line">        <span class="keyword">case</span> address <span class="operator">=</span> <span class="string">&quot;addr&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;============= Encode =============&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> address <span class="operator">=</span> <span class="type">Address</span>(province: <span class="string">&quot;Zhejiang&quot;</span>, city: <span class="string">&quot;Huzhou&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;baochuquan&quot;</span>, age: <span class="number">18</span>, address: address)</span><br><span class="line"><span class="keyword">let</span> encoder <span class="operator">=</span> <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">guard</span></span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> encoder.encode(student),</span><br><span class="line">    <span class="keyword">let</span> encodedString <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(encodedString)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &#123;&quot;name&quot;:&quot;baochuquan&quot;,&quot;age&quot;:18,&quot;addr&quot;:&#123;&quot;province&quot;:&quot;Zhejiang&quot;,&quot;city&quot;:&quot;Huzhou&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decode</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;============= Decode =============&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> jsonString <span class="operator">=</span> <span class="string">&quot;&#123;<span class="subst">\&quot;</span>name<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>baochuquan<span class="subst">\&quot;</span>,<span class="subst">\&quot;</span>age<span class="subst">\&quot;</span>:18,<span class="subst">\&quot;</span>addr<span class="subst">\&quot;</span>:&#123;<span class="subst">\&quot;</span>province<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>Zhejiang<span class="subst">\&quot;</span>,<span class="subst">\&quot;</span>city<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>Huzhou<span class="subst">\&quot;</span>&#125;&#125;&quot;</span></span><br><span class="line"><span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">guard</span></span><br><span class="line">    <span class="keyword">let</span> jsonData <span class="operator">=</span> jsonString.data(using: .utf8),</span><br><span class="line">    <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> decoder.decode(<span class="type">Student</span>.<span class="keyword">self</span>, from: jsonData)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Student(name: &quot;baochuquan&quot;, age: 18, address: __lldb_expr_15.Address(province: &quot;Zhejiang&quot;, city: &quot;Huzhou&quot;))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
上述代码描述了一种关于 Codable 的常见用法，我们声明了一个
<code>Studuent</code> 模型，其嵌套了一个 <code>Address</code>
模型。首先通过 encode 的方式将模型转换成 JSON，然后通过 decode 的方式将
JSON 转换成模型。</p>
<h1 id="整体结构">整体结构</h1>
<p><code>Codable</code> 的核心构成可以分为三个部分：</p>
<ul>
<li><strong>Encodable &amp; Decodable 协议</strong></li>
<li><strong>Encoder &amp; Decoder 协议</strong></li>
<li><strong>Container 相关协议</strong></li>
</ul>
<h2 id="encodable-decodable">Encodable &amp; Decodable</h2>
<p><code>Encodable</code> 协议要求目标模型必须提供编码方法
<code>func encode(from encoder: Encoder)</code>，从而按照指定的逻辑进行编码。</p>
<p><code>Decodable</code> 协议要求目标模型必须提供解码方法
<code>func init(from decoder: Decoder)</code>，从而按照指定的逻辑进行解码。</p>
<p><code>Codable</code> 则正是两个协议的并集，如下所示为
<code>Codable</code> 协议的定义。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Encodable</span> &#123;</span><br><span class="line">    <span class="comment">// 把值编码到 encoder 中</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Decodable</span> &#123;</span><br><span class="line">    <span class="comment">// 从 decoder 中把值解码出来</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Codable</span> <span class="operator">=</span> <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></span><br></pre></td></tr></table></figure></p>
<p>在使用示例中，我们可以看到，<strong>模型只要遵循了 Codable
协议就可以进行数据和模型的相互转换</strong>。不过，我们可能会产生一个疑问：<code>Student</code>
和 <code>Address</code> 类遵循了 <code>Codable</code>
协议，按道理应该需要去实现协议，为什么这里模型却没有实现协议？难道
Codable 协议存在默认实现？事实上，Codable 并没有默认实现，而是
<strong>编译器为遵循 <code>Codable</code>
协议的类自动生成了对应的实现方法</strong>。关于这一点，我们在下文还会进一步进行介绍。</p>
<h2 id="encoder-decoder">Encoder &amp; Decoder</h2>
<p><code>Encoder</code> 协议要求编码器必须提供 3 种类型的编码
container、编码路径、上下文缓存。</p>
<p><code>Decoder</code> 协议要求编码器必须提供 3 中类型的解码
container、解码路径、上下文缓存。</p>
<p>协议的具体定义如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Encoder</span> &#123;</span><br><span class="line">  <span class="comment">/// The path of coding keys taken to get to this point in encoding.</span></span><br><span class="line">  <span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="comment">/// Any contextual information set by the user for encoding.</span></span><br><span class="line">  <span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span>: <span class="keyword">Any</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">container</span>&lt;<span class="type">Key</span>&gt;(<span class="params">keyedBy</span> <span class="params">type</span>: <span class="type">Key</span>.<span class="keyword">Type</span>) -&gt; <span class="type">KeyedEncodingContainer</span>&lt;<span class="type">Key</span>&gt;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">unkeyedContainer</span>() -&gt; <span class="type">UnkeyedEncodingContainer</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">singleValueContainer</span>() -&gt; <span class="type">SingleValueEncodingContainer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Decoder</span> &#123;</span><br><span class="line">  <span class="comment">/// The path of coding keys taken to get to this point in decoding.</span></span><br><span class="line">  <span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="comment">/// Any contextual information set by the user for decoding.</span></span><br><span class="line">  <span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span>: <span class="keyword">Any</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">container</span>&lt;<span class="type">Key</span>&gt;(</span><br><span class="line">    <span class="params">keyedBy</span> <span class="params">type</span>: <span class="type">Key</span>.<span class="keyword">Type</span></span><br><span class="line">  ) <span class="keyword">throws</span> -&gt; <span class="type">KeyedDecodingContainer</span>&lt;<span class="type">Key</span>&gt;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">unkeyedContainer</span>() <span class="keyword">throws</span> -&gt; <span class="type">UnkeyedDecodingContainer</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">singleValueContainer</span>() <span class="keyword">throws</span> -&gt; <span class="type">SingleValueDecodingContainer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 JSON 的编解码，swift 默认提供了两个私有类实现了
<code>Encoder</code> 协议和 <code>Decoder</code> 协议。</p>
<ul>
<li><code>__JSONEncoder</code>：实现了 <code>Encoder</code> 协议。</li>
<li><code>__JSONDecoder</code>：实现了 <code>Decoder</code> 协议。</li>
</ul>
<h2 id="container">Container</h2>
<p>Codable 中包含三种类型的
container，由于还要同时支持编码和解码，因此总共有 6 种类型的
container，分别是：</p>
<ul>
<li><code>KeyedEncodingContainer&lt;Key&gt;</code></li>
<li><code>KeyedDecodingContainer&lt;Key&gt;</code></li>
<li><code>UnkeyedEncodingContainer</code></li>
<li><code>UnkeyedDecodingContainer</code></li>
<li><code>SingleValueEncodingContainer</code></li>
<li><code>SingleValueDecodingContainer</code></li>
</ul>
<p>Container 主要用于
<strong>缓存单个嵌套层级的编码/解码结果</strong>。例如，对于
<code>Student</code> 这样的嵌套模型（内部嵌套了
<code>Address</code>），它需要两个 container，一个用于缓存
<code>Student</code> 层级的编码/解码结果，一个用于缓存
<code>Address</code> 层级的编码/解码结果。</p>
<p>本质上，编码/解码的过程是根据数据/模型的嵌套层级递归计算完成的，每一层递归都会有一个
container
用于保存其运算结果，最终组成一个对应嵌套层级的编码/解码结果。</p>
<p>如果不区分编码和解码，那么 Codable 有 3 种类型的
container，我们分别简单介绍一下。</p>
<h3 id="keyedcontainerkey"><code>KeyedContainer&lt;Key&gt;</code></h3>
<p><code>KeyedContainer&lt;Key&gt;</code>
主要用于带键数据的编解码，比如，使用
<code>KeyedEncodingContainer&lt;Key&gt;</code> 能够编码得到类似
<code>&#123;"name": "baochuquan", "age": 18&#125;</code>
这样的结果。<code>KeyedContainer&lt;Key&gt;</code>
是泛型类型，其类型参数 <code>Key</code> 就是遵循 <code>CodingKey</code>
协议的类型。<code>KeyedContainer&lt;Key&gt;</code> 是最常用的
container，上述例子中 <code>Student</code> 和 <code>Address</code>
都是基于 <code>KeyedContainer&lt;Key&gt;</code> 完成的。</p>
<p>下图所示分别是 <code>KeyedEncodingContainer&lt;Key&gt;</code> 和
<code>KeyedDecodingContainer&lt;Key&gt;</code> 相关的类图。在《<a
href="http://chuquan.me/2021/10/10/swift-type-erase/">Swift
类型擦除</a>》文中，我们介绍了下面这种结构，它的主要作用是
<strong>对泛型协议进行类型擦除，从而能够实现泛型协议的存储</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-04.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-05.png?x-oss-process=image/resize,w_800" /></p>
<p>其中，<code>KeyedEncodingContainerProtocol</code> 和
<code>KeyedDecodingContainerProtocol</code>
是泛型协议。协议的真正实现者是 <code>__JSONKeyedEncodingContainer</code>
和
<code>__JSONKeyedDecodingContainer</code>，两者是泛型结构体。它们内部则分别调用了
<code>__JSONEncoder</code> 和 <code>__JSONDecoder</code>
内部的相关方法，从而完成编码和解码的核心逻辑。<code>__JSONEncoder</code>
和 <code>__JSONDecoder</code> 也正是 <code>Encoder</code> 协议和
<code>Decoder</code> 协议的实现者。</p>
<p>在图中，其他的类，包括：<code>KeyedEncodingContainer&lt;Key&gt;</code>、<code>_KeyedEncodingContainerBase</code>、<code>_KeyedEncodingContainerBox</code>
和
<code>KeyedDecodingContainer&lt;Key&gt;</code>、<code>_KeyedDecodingContainerBase</code>、<code>_KeyedDecodingContainerBox</code>，它们内部对方法调用进行了层层转发，目的是辅助解决类型擦除问题。</p>
<h3 id="unkeyedcontainer"><code>UnkeyedContainer</code></h3>
<p><code>UnkeyedContainer</code> 主要用于不带键数据的编解码，比如，使用
<code>UnkeyedEncodingContainer&lt;Key&gt;</code> 能够编码得到类似
<code>["baochuquan", 18]</code> 这样的结果。既然是
<code>Unkeyed</code>，那就是结果中只有 value，没有
key。总体来说，<code>UnkeyedContainer</code> 使用较少。</p>
<p>下图所示分别是 <code>UnkeyedEncodingContainer</code> 和
<code>UnkeyedDecodingContainer</code>
相关的类图。由于它们并不需要支持泛型，所以无需一堆辅助类来实现类型擦除。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-06.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-07.png?x-oss-process=image/resize,w_800" /></p>
<p>其中，<code>UnkeyedEncodingContainer</code> 和
<code>UnkeyedDecodingContainer</code> 的真正实现者分别是
<code>__JSONUnkeyedEncodingContainer</code> 和
<code>__JSONUnkeyedDecodingContainer</code>。它们内部则分别调用了
<code>__JSONEncoder</code> 和 <code>__JSONDecoder</code>
内部的相关方法，从而完成编码和解码的核心逻辑。</p>
<h3 id="singlevaluecontainer"><code>SingleValueContainer</code></h3>
<p><code>SingleValueContainer</code>
主要用于单个值数据的编解码，比如，使用
<code>SingleEncodingContainer</code> 能够编码得到类似
<code>"baochuquan"</code>
这样的结果。它只是一个值，并不是字典或数组。总体来说，用的也比较少。</p>
<p>下图所示分别是 <code>SingleValueEncodingContainer</code> 和
<code>SingleValueDecodingContainer</code>
的相关类图。同样，它们也不支持泛型，无需辅助类来实现类型擦除。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-08.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-09.png?x-oss-process=image/resize,w_800" /></p>
<p>这里，<code>SingleValueEncodingContainer</code> 和
<code>SingleValueDecodingContainer</code> 的真正实现者直接就是
<code>__JSONEncoder</code> 和 <code>__JSONDecoder</code>。</p>
<h3 id="小结">小结</h3>
<p>从上述三种 container
的类图中我们可以发现，<strong><code>__JSONEncoder</code> 和
<code>__JSONDecoder</code> 才是真正实现编码和解码的关键</strong>。</p>
<h1 id="核心逻辑">核心逻辑</h1>
<p>接下来，我们从上述两个例子开始，研究一下 Codable
编码和解码的核心逻辑。</p>
<h2 id="编码逻辑">编码逻辑</h2>
<p>如下所示，在编码过程中，首先会调用初始化一个 <code>JSONEncoder</code>
对象，然后调用其 <code>encode(_:)</code> 方法。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> encoder <span class="operator">=</span> <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">guard</span></span><br><span class="line">    <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> encoder.encode(student),</span><br><span class="line">    <span class="keyword">let</span> encodedString <span class="operator">=</span> <span class="type">String</span>(data: data, encoding: .utf8)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>JSONEncoder</code> 的 <code>encode(_:)</code>
方法内部逻辑如下所示，核心部分就是初始化一个 <code>__JSONEncoder</code>
对象，调用其 <code>box_(_:)</code> 方法。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">encode</span>&lt;<span class="type">T</span> : <span class="type">Encodable</span>&gt;(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> encoder <span class="operator">=</span> __JSONEncoder(options: <span class="keyword">self</span>.options)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> topLevel <span class="operator">=</span> <span class="keyword">try</span> encoder.box_(value) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">EncodingError</span>.invalidValue(value,</span><br><span class="line">                                         <span class="type">EncodingError</span>.<span class="type">Context</span>(codingPath: [], debugDescription: <span class="string">&quot;Top-level <span class="subst">\(T.<span class="keyword">self</span>)</span> did not encode any values.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> writingOptions <span class="operator">=</span> <span class="type">JSONSerialization</span>.<span class="type">WritingOptions</span>(rawValue: <span class="keyword">self</span>.outputFormatting.rawValue).union(.fragmentsAllowed)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data(withJSONObject: topLevel, options: writingOptions)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">EncodingError</span>.invalidValue(value,</span><br><span class="line">                                         <span class="type">EncodingError</span>.<span class="type">Context</span>(codingPath: [], debugDescription: <span class="string">&quot;Unable to encode the given top-level value to JSON.&quot;</span>, underlyingError: error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__JSONEncoder</code> 的 <code>box_(_:as:)</code>
方法，其内部逻辑如下所示。该方法内部会根据 <code>type</code>
的类型找到对应的 <code>box</code> 方法进行编码转换，如果是自定义类型，如
<code>Student</code>，那么会走到最后的
<code>value.encode(to: self)</code>，而这个方法就是
<code>Encodable</code> 协议所声明的方法。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">box_</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">Encodable</span>) <span class="keyword">throws</span> -&gt; <span class="type">NSObject</span>? &#123;</span><br><span class="line">    <span class="comment">// Disambiguation between variable and function is required due to</span></span><br><span class="line">    <span class="comment">// issue tracked at: https://bugs.swift.org/browse/SR-1846</span></span><br><span class="line">    <span class="keyword">let</span> type <span class="operator">=</span> <span class="type">Swift</span>.type(of: value)</span><br><span class="line">    <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">Date</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSDate</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="comment">// Respect Date encoding strategy</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.box((value <span class="keyword">as!</span> <span class="type">Date</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">Data</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSData</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="comment">// Respect Data encoding strategy</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.box((value <span class="keyword">as!</span> <span class="type">Data</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">URL</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSURL</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="comment">// Encode URLs as single strings.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.box((value <span class="keyword">as!</span> <span class="type">URL</span>).absoluteString)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">Decimal</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSDecimalNumber</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="comment">// JSONSerialization can natively handle NSDecimalNumber.</span></span><br><span class="line">        <span class="keyword">return</span> (value <span class="keyword">as!</span> <span class="type">NSDecimalNumber</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="keyword">is</span> _JSONStringDictionaryEncodableMarker &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.box(value <span class="keyword">as!</span> [String : <span class="type">Encodable</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The value should request a container from the __JSONEncoder.</span></span><br><span class="line">    <span class="keyword">let</span> depth <span class="operator">=</span> <span class="keyword">self</span>.storage.count</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> value.encode(to: <span class="keyword">self</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// If the value pushed a container before throwing, pop it back off to restore state.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.storage.count <span class="operator">&gt;</span> depth &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">self</span>.storage.popContainer()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The top container should be a new container.</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span>.storage.count <span class="operator">&gt;</span> depth <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.storage.popContainer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，<code>Student</code> 类并没有实现 <code>encode(to:)</code>
方法，这是一个疑问。</p>
<h2 id="解码逻辑">解码逻辑</h2>
<p>如下所示，在解码过程中，首先会调用初始化一个 <code>JSONDecoder</code>
对象，然后调用其 <code>decode(_:from:)</code> 方法。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">guard</span></span><br><span class="line">    <span class="keyword">let</span> jsonData <span class="operator">=</span> jsonString.data(using: .utf8),</span><br><span class="line">    <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> decoder.decode(<span class="type">Student</span>.<span class="keyword">self</span>, from: jsonData)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>JSONDecoder</code> 的 <code>decode(_:from:)</code>
方法内部逻辑如下所示，核心部分就是初始化一个 <code>__JSONDecoder</code>
对象，调用其 <code>unbox(_:as:)</code> 方法。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">decode</span>&lt;<span class="type">T</span> : <span class="type">Decodable</span>&gt;(<span class="keyword">_</span> <span class="params">type</span>: <span class="type">T</span>.<span class="keyword">Type</span>, <span class="params">from</span> <span class="params">data</span>: <span class="type">Data</span>) <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> topLevel: <span class="keyword">Any</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       topLevel <span class="operator">=</span> <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .fragmentsAllowed)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DecodingError</span>.dataCorrupted(<span class="type">DecodingError</span>.<span class="type">Context</span>(codingPath: [], debugDescription: <span class="string">&quot;The given data was not valid JSON.&quot;</span>, underlyingError: error))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> decoder <span class="operator">=</span> __JSONDecoder(referencing: topLevel, options: <span class="keyword">self</span>.options)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> value <span class="operator">=</span> <span class="keyword">try</span> decoder.unbox(topLevel, as: type) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">DecodingError</span>.valueNotFound(type, <span class="type">DecodingError</span>.<span class="type">Context</span>(codingPath: [], debugDescription: <span class="string">&quot;The given data did not contain a top-level value.&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__JSONDecoder</code> 的 <code>unbox(_:as:)</code>
方法内部直接转发至核心方法
<code>unbox_(_:as:)</code>，其内部逻辑如下所示。该方法内部会根据
<code>type</code> 的类型找到对应的 <code>unbox</code>
方法进行解码转换，如果是自定义类型，如
<code>Student</code>，那么会走到最后的
<code>type.init(from: self)</code>，而这个方法就是
<code>Decodable</code> 协议所声明的方法。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">unbox_</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="keyword">Any</span>, <span class="params">as</span> <span class="params">type</span>: <span class="type">Decodable</span>.<span class="keyword">Type</span>) <span class="keyword">throws</span> -&gt; <span class="keyword">Any</span><span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">Date</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSDate</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.unbox(value, as: <span class="type">Date</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">Data</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSData</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.unbox(value, as: <span class="type">Data</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">URL</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSURL</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> urlString <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">self</span>.unbox(value, as: <span class="type">String</span>.<span class="keyword">self</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: urlString) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">DecodingError</span>.dataCorrupted(<span class="type">DecodingError</span>.<span class="type">Context</span>(codingPath: <span class="keyword">self</span>.codingPath,</span><br><span class="line">                                                                    debugDescription: <span class="string">&quot;Invalid URL string.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> type <span class="operator">==</span> <span class="type">Decimal</span>.<span class="keyword">self</span> <span class="operator">||</span> type <span class="operator">==</span> <span class="type">NSDecimalNumber</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.unbox(value, as: <span class="type">Decimal</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> stringKeyedDictType <span class="operator">=</span> type <span class="keyword">as?</span> _JSONStringDictionaryDecodableMarker.<span class="keyword">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">self</span>.unbox(value, as: stringKeyedDictType)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.storage.push(container: value)</span><br><span class="line">        <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.storage.popContainer() &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> type.<span class="keyword">init</span>(from: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，<code>Student</code> 类并没有实现 <code>init(from:)</code>
方法，这又是一个疑问。</p>
<h2 id="sil">SIL</h2>
<p>上面，我们在追溯编码逻辑和解码逻辑中，抛出了两个问题：模型并没有实现
Codable
协议所声明的两个方法。我们推测可能是编译器生成的代码实现了这两个方法。</p>
<p>下面，我们可以通过如下命令，编译 <code>Student</code> 生成 SIL
来看看编译器到底做了什么额外的工作。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swiftc Student.swift -emit-sil &gt; Student.sil</span><br></pre></td></tr></table></figure></p>
<p>我们首先能看到编译器生成了 <code>Student</code> 和
<code>Address</code> 相关的代码，如下所示。对于未指定
<code>CodingKey</code>
的模型，编译器会自动生成一个嵌套类型，比如：<code>Address</code>
内部生成了一个枚举类型 <code>CodingKeys</code>。对于未实现
<code>Codable</code> 的模型，编译器会自动生成对应的方法。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Address</span> : <span class="title class_">Decodable</span> &amp; <span class="title class_">Encodable</span> &#123;</span><br><span class="line">  <span class="meta">@_hasStorage</span> <span class="keyword">var</span> province: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="meta">@_hasStorage</span> <span class="keyword">var</span> city: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">init</span>(<span class="params">province</span>: <span class="type">String</span>, <span class="params">city</span>: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">CodingKeys</span> : <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> province</span><br><span class="line">    <span class="keyword">case</span> city</span><br><span class="line">    <span class="meta">@_implements</span>(<span class="type">Equatable</span>, <span class="operator">==</span>(<span class="keyword">_</span>:<span class="keyword">_</span>:)) <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">__derived_enum_equals</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Address</span>.<span class="type">CodingKeys</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Address</span>.<span class="type">CodingKeys</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">hash</span>(<span class="params">into</span> <span class="params">hasher</span>: <span class="keyword">inout</span> <span class="type">Hasher</span>)</span><br><span class="line">    <span class="keyword">var</span> stringValue: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">stringValue</span>: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">var</span> intValue: <span class="type">Int</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">intValue</span>: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> : <span class="title class_">Decodable</span> &amp; <span class="title class_">Encodable</span> &#123;</span><br><span class="line">  <span class="meta">@_hasStorage</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="meta">@_hasStorage</span> <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="meta">@_hasStorage</span> <span class="keyword">var</span> address: <span class="type">Address</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">CodingKeys</span> : <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> name</span><br><span class="line">    <span class="keyword">case</span> age</span><br><span class="line">    <span class="keyword">case</span> address</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">RawValue</span> <span class="operator">=</span> <span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">rawValue</span>: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">var</span> rawValue: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> stringValue: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">stringValue</span>: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">var</span> intValue: <span class="type">Int</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">intValue</span>: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>, <span class="params">address</span>: <span class="type">Address</span>)</span><br><span class="line">  <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="编码逻辑补充">编码逻辑补充</h3>
<p>对于 Encodable，编译器为 <code>Student</code> 自动生成的
<code>encode(to:)</code> 方法，如下所示。内部使用 container
缓存编码结果，并调用 <code>__JSONKeyedEncodingContainer</code> 的
<code>encode(_:forKey:)</code> 方法，而 <code>encode(_:forKey:)</code>
方法则调用了 <code>__JSONEncoder</code> 中的 <code>encode(_:)</code>
方法。<code>encode(_:)</code> 方法又会执行 <code>box_(_:)</code>
方法，并生成新的 container。最终形成了一个递归调用。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student.encode(to:)</span></span><br><span class="line">sil hidden @<span class="variable">$s7StudentAAV6encode2toys7Encoder_p_tKF</span> : $<span class="meta">@convention</span>(method) (<span class="meta">@in_guaranteed</span> <span class="type">Encoder</span>, <span class="meta">@guaranteed</span> <span class="type">Student</span>) -&gt; <span class="meta">@error</span> <span class="type">Error</span> &#123;</span><br><span class="line"><span class="comment">// %0 &quot;encoder&quot;                                   // users: %6, %2</span></span><br><span class="line"><span class="comment">// %1 &quot;self&quot;                                      // users: %35, %24, %11, %3</span></span><br><span class="line">bb0(<span class="operator">%</span><span class="number">0</span> : $<span class="operator">*</span><span class="type">Encoder</span>, <span class="operator">%</span><span class="number">1</span> : <span class="variable">$Student</span>):</span><br><span class="line">  debug_value_addr <span class="operator">%</span><span class="number">0</span> : $<span class="operator">*</span><span class="type">Encoder</span>, <span class="keyword">let</span>, name <span class="string">&quot;encoder&quot;</span>, argno <span class="number">1</span> <span class="comment">// id: %2</span></span><br><span class="line">  debug_value <span class="operator">%</span><span class="number">1</span> : <span class="variable">$Student</span>, <span class="keyword">let</span>, name <span class="string">&quot;self&quot;</span>, argno <span class="number">2</span> <span class="comment">// id: %3</span></span><br><span class="line">  debug_value undef : <span class="variable">$Error</span>, <span class="keyword">var</span>, name <span class="string">&quot;$error&quot;</span>, argno <span class="number">3</span> <span class="comment">// id: %4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 KeyedEncodingContainer 内存布局</span></span><br><span class="line">  <span class="operator">%</span><span class="number">5</span> <span class="operator">=</span> alloc_stack <span class="variable">$KeyedEncodingContainer</span><span class="operator">&lt;</span><span class="type">Student</span>.<span class="type">CodingKeys</span><span class="operator">&gt;</span>, <span class="keyword">var</span>, name <span class="string">&quot;container&quot;</span> <span class="comment">// users: %52, %51, %74, %73, %66, %65, %60, %59, %10, %17, %29, %43</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取遵循 Encoder 协议的实体，即 __JSONEncoder</span></span><br><span class="line">  <span class="operator">%</span><span class="number">6</span> <span class="operator">=</span> open_existential_addr immutable_access <span class="operator">%</span><span class="number">0</span> : $<span class="operator">*</span><span class="type">Encoder</span> to $<span class="operator">*</span><span class="meta">@opened</span>(<span class="string">&quot;563EEE00-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Encoder</span> <span class="comment">// users: %10, %10, %9</span></span><br><span class="line">  <span class="operator">%</span><span class="number">7</span> <span class="operator">=</span> metatype $<span class="meta">@thin</span> <span class="type">Student</span>.<span class="type">CodingKeys</span>.<span class="keyword">Type</span></span><br><span class="line">  <span class="operator">%</span><span class="number">8</span> <span class="operator">=</span> metatype $<span class="meta">@thick</span> <span class="type">Student</span>.<span class="type">CodingKeys</span>.<span class="keyword">Type</span>   <span class="comment">// user: %10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 __JSONEncoder 的 container 方法</span></span><br><span class="line">  <span class="operator">%</span><span class="number">9</span> <span class="operator">=</span> witness_method $<span class="meta">@opened</span>(<span class="string">&quot;563EEE00-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Encoder</span>, #<span class="type">Encoder</span>.container : <span class="operator">&lt;</span><span class="keyword">Self</span> <span class="keyword">where</span> <span class="keyword">Self</span> : <span class="type">Encoder</span><span class="operator">&gt;&lt;</span><span class="type">Key</span> <span class="keyword">where</span> <span class="type">Key</span> : <span class="type">CodingKey</span><span class="operator">&gt;</span> (<span class="keyword">Self</span>) -&gt; (<span class="type">Key</span>.<span class="keyword">Type</span>) -&gt; <span class="type">KeyedEncodingContainer</span>&lt;<span class="type">Key</span>&gt;, <span class="operator">%</span><span class="number">6</span> : $<span class="operator">*</span><span class="meta">@opened</span>(<span class="string">&quot;563EEE00-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Encoder</span> : $<span class="meta">@convention</span>(witness_method: <span class="type">Encoder</span>) <span class="operator">&lt;</span>τ_0_0 <span class="keyword">where</span> τ_0_0 : <span class="type">Encoder</span><span class="operator">&gt;&lt;</span>τ_1_0 <span class="keyword">where</span> τ_1_0 : <span class="type">CodingKey</span><span class="operator">&gt;</span> (<span class="meta">@thick</span> τ_1_0.<span class="keyword">Type</span>, <span class="meta">@in_guaranteed</span> τ_0_0) -&gt; <span class="meta">@out</span> <span class="type">KeyedEncodingContainer</span>&lt;τ_1_0&gt; <span class="comment">// type-defs: %6; user: %10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 __JSONEncoder 的 container 方法</span></span><br><span class="line">  <span class="operator">%</span><span class="number">10</span> <span class="operator">=</span> apply <span class="operator">%</span><span class="number">9</span><span class="operator">&lt;</span><span class="meta">@opened</span>(<span class="string">&quot;563EEE00-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Encoder</span>, <span class="type">Student</span>.<span class="type">CodingKeys</span><span class="operator">&gt;</span>(<span class="operator">%</span><span class="number">5</span>, <span class="operator">%</span><span class="number">8</span>, <span class="operator">%</span><span class="number">6</span>) : $<span class="meta">@convention</span>(witness_method: <span class="type">Encoder</span>) <span class="operator">&lt;</span>τ_0_0 <span class="keyword">where</span> τ_0_0 : <span class="type">Encoder</span><span class="operator">&gt;&lt;</span>τ_1_0 <span class="keyword">where</span> τ_1_0 : <span class="type">CodingKey</span><span class="operator">&gt;</span> (<span class="meta">@thick</span> τ_1_0.<span class="keyword">Type</span>, <span class="meta">@in_guaranteed</span> τ_0_0) -&gt; <span class="meta">@out</span> <span class="type">KeyedEncodingContainer</span>&lt;τ_1_0&gt; <span class="comment">// type-defs: %6</span></span><br><span class="line">  <span class="operator">%</span><span class="number">11</span> <span class="operator">=</span> struct_extract <span class="operator">%</span><span class="number">1</span> : <span class="variable">$Student</span>, #<span class="type">Student</span>.name <span class="comment">// users: %58, %23, %19, %12</span></span><br><span class="line">  retain_value <span class="operator">%</span><span class="number">11</span> : <span class="variable">$String</span>                      <span class="comment">// id: %12</span></span><br><span class="line">  <span class="operator">%</span><span class="number">13</span> <span class="operator">=</span> metatype $<span class="meta">@thin</span> <span class="type">Student</span>.<span class="type">CodingKeys</span>.<span class="keyword">Type</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个 CodingKeys 内存，将 name 的枚举值写入</span></span><br><span class="line">  <span class="operator">%</span><span class="number">14</span> <span class="operator">=</span> <span class="keyword">enum</span> <span class="title class_">$Student</span>.<span class="title class_">CodingKeys</span>, #<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>.<span class="title class_">name</span>!<span class="title class_">enumelt</span> // <span class="title class_">user</span>: %16</span><br><span class="line">  %15 = <span class="title class_">alloc_stack</span> <span class="title class_">$Student</span>.<span class="title class_">CodingKeys</span>           // <span class="title class_">users</span>: %16, %22, %19, %57</span><br><span class="line">  <span class="title class_">store</span> %14 <span class="title class_">to</span> %15 : <span class="title class_">$</span>*<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>         // <span class="title class_">id</span>: %16</span><br><span class="line">  %17 = <span class="title class_">begin_access</span> [<span class="title class_">modify</span>] [<span class="title class_">static</span>] %5 : <span class="title class_">$</span>*<span class="title class_">KeyedEncodingContainer</span>&lt;<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>&gt; // <span class="title class_">users</span>: %21, %19, %56</span><br><span class="line"></span><br><span class="line">  // 获取 <span class="title class_">KeyedEncodingContainer</span> 的 <span class="title class_">encode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:) 方法，即 <span class="title class_">__JSONKeyedEncodingContainer</span> 的 <span class="title class_">encode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:)</span><br><span class="line">  // <span class="title class_">function_ref</span> <span class="title class_">KeyedEncodingContainer</span>.<span class="title class_">encode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:)</span><br><span class="line">  %18 = <span class="title class_">function_ref</span> @<span class="title class_">$ss22KeyedEncodingContainerV6encode_6forKeyySS_xtKF</span> : <span class="title class_">$</span>@<span class="title class_">convention</span>(<span class="title class_">method</span>) &lt;τ<span class="title class_">_0_0</span> <span class="title class_">where</span> τ<span class="title class_">_0_0</span> : <span class="title class_">CodingKey</span>&gt; (@<span class="title class_">guaranteed</span> <span class="title class_">String</span>, @<span class="title class_">in_guaranteed</span> τ<span class="title class_">_0_0</span>, @<span class="title class_">inout</span> <span class="title class_">KeyedEncodingContainer</span>&lt;τ<span class="title class_">_0_0</span>&gt;) -&gt; @<span class="title class_">error</span> <span class="title class_">Error</span> // <span class="title class_">user</span>: %19</span><br><span class="line"></span><br><span class="line">  // 执行 <span class="title class_">KeyedEncodingContainer</span> 的 <span class="title class_">encode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:) 方法，即 <span class="title class_">__JSONKeyedEncodingContainer</span> 的 <span class="title class_">encode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:)</span><br><span class="line">  <span class="title class_">try_apply</span> %18&lt;<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>&gt;(%11, %15, %17) : <span class="title class_">$</span>@<span class="title class_">convention</span>(<span class="title class_">method</span>) &lt;τ<span class="title class_">_0_0</span> <span class="title class_">where</span> τ<span class="title class_">_0_0</span> : <span class="title class_">CodingKey</span>&gt; (@<span class="title class_">guaranteed</span> <span class="title class_">String</span>, @<span class="title class_">in_guaranteed</span> τ<span class="title class_">_0_0</span>, @<span class="title class_">inout</span> <span class="title class_">KeyedEncodingContainer</span>&lt;τ<span class="title class_">_0_0</span>&gt;) -&gt; @<span class="title class_">error</span> <span class="title class_">Error</span>, <span class="title class_">normal</span> <span class="title class_">bb1</span>, <span class="title class_">error</span> <span class="title class_">bb4</span> // <span class="title class_">id</span>: %19</span><br><span class="line">  </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="解码逻辑补充">解码逻辑补充</h3>
<p>对于 Decodable，编译器为 <code>Student</code> 自动生成的
<code>init(from:)</code> 方法，如下所示。内部使用 container
缓存编码结果，并调用 <code>__JSONKeyedDecodingContainer</code> 的
<code>decode(_:forKey:)</code> 方法，而 <code>decode(_:forKey:)</code>
方法则调用了 <code>__JSONDecoder</code> 中的 <code>decode(_:)</code>
方法。<code>decode(_:)</code> 方法又会执行 <code>unbox_(_:)</code>
方法，并生成新的 container。最终形成了一个递归调用。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student.init(from:)</span></span><br><span class="line">sil hidden @<span class="variable">$s7StudentAAV4fromABs7Decoder_p_tKcfC</span> : $<span class="meta">@convention</span>(method) (<span class="meta">@in</span> <span class="type">Decoder</span>, <span class="meta">@thin</span> <span class="type">Student</span>.<span class="keyword">Type</span>) -&gt; (<span class="meta">@owned</span> <span class="type">Student</span>, <span class="meta">@error</span> <span class="type">Error</span>) &#123;</span><br><span class="line"><span class="comment">// %0 &quot;decoder&quot;                                   // users: %97, %70, %9, %6</span></span><br><span class="line"><span class="comment">// %1 &quot;$metatype&quot;</span></span><br><span class="line">bb0(<span class="operator">%</span><span class="number">0</span> : $<span class="operator">*</span><span class="type">Decoder</span>, <span class="operator">%</span><span class="number">1</span> : $<span class="meta">@thin</span> <span class="type">Student</span>.<span class="keyword">Type</span>):</span><br><span class="line">  <span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> alloc_stack <span class="variable">$Builtin</span>.<span class="type">Int3</span>                  <span class="comment">// users: %105, %98, %59, %27, %5, %115, %73</span></span><br><span class="line">  <span class="operator">%</span><span class="number">3</span> <span class="operator">=</span> alloc_stack [dynamic_lifetime] <span class="variable">$Student</span>, <span class="keyword">var</span>, name <span class="string">&quot;self&quot;</span> <span class="comment">// users: %56, %40, %24, %71, %101, %110, %114, %72</span></span><br><span class="line">  <span class="operator">%</span><span class="number">4</span> <span class="operator">=</span> integer_literal <span class="variable">$Builtin</span>.<span class="type">Int3</span>, <span class="number">0</span>           <span class="comment">// user: %5</span></span><br><span class="line">  store <span class="operator">%</span><span class="number">4</span> to <span class="operator">%</span><span class="number">2</span> : $<span class="operator">*</span><span class="type">Builtin</span>.<span class="type">Int3</span>                 <span class="comment">// id: %5</span></span><br><span class="line">  debug_value_addr <span class="operator">%</span><span class="number">0</span> : $<span class="operator">*</span><span class="type">Decoder</span>, <span class="keyword">let</span>, name <span class="string">&quot;decoder&quot;</span>, argno <span class="number">1</span> <span class="comment">// id: %6</span></span><br><span class="line">  debug_value undef : <span class="variable">$Error</span>, <span class="keyword">var</span>, name <span class="string">&quot;$error&quot;</span>, argno <span class="number">2</span> <span class="comment">// id: %7</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 KeyedDecodingContainer 内存布局</span></span><br><span class="line">  <span class="operator">%</span><span class="number">8</span> <span class="operator">=</span> alloc_stack <span class="variable">$KeyedDecodingContainer</span><span class="operator">&lt;</span><span class="type">Student</span>.<span class="type">CodingKeys</span><span class="operator">&gt;</span>, <span class="keyword">let</span>, name <span class="string">&quot;container&quot;</span> <span class="comment">// users: %65, %64, %52, %94, %93, %37, %87, %86, %21, %81, %80, %13, %76</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取遵循 Decoder 协议的实体，即 __JSONDecoder</span></span><br><span class="line">  <span class="operator">%</span><span class="number">9</span> <span class="operator">=</span> open_existential_addr immutable_access <span class="operator">%</span><span class="number">0</span> : $<span class="operator">*</span><span class="type">Decoder</span> to $<span class="operator">*</span><span class="meta">@opened</span>(<span class="string">&quot;563E18FE-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Decoder</span> <span class="comment">// users: %13, %13, %12</span></span><br><span class="line">  <span class="operator">%</span><span class="number">10</span> <span class="operator">=</span> metatype $<span class="meta">@thin</span> <span class="type">Student</span>.<span class="type">CodingKeys</span>.<span class="keyword">Type</span></span><br><span class="line">  <span class="operator">%</span><span class="number">11</span> <span class="operator">=</span> metatype $<span class="meta">@thick</span> <span class="type">Student</span>.<span class="type">CodingKeys</span>.<span class="keyword">Type</span>  <span class="comment">// user: %13</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 __JSONDecoder 的 container 方法的地址，该方法的类型是 &lt;Self where Self : Decoder&gt;&lt;Key where Key : CodingKey&gt; (Self) -&gt; (Key.Type) throws -&gt; KeyedDecodingContainer&lt;Key&gt;</span></span><br><span class="line">  <span class="operator">%</span><span class="number">12</span> <span class="operator">=</span> witness_method $<span class="meta">@opened</span>(<span class="string">&quot;563E18FE-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Decoder</span>, #<span class="type">Decoder</span>.container : <span class="operator">&lt;</span><span class="keyword">Self</span> <span class="keyword">where</span> <span class="keyword">Self</span> : <span class="type">Decoder</span><span class="operator">&gt;&lt;</span><span class="type">Key</span> <span class="keyword">where</span> <span class="type">Key</span> : <span class="type">CodingKey</span><span class="operator">&gt;</span> (<span class="keyword">Self</span>) -&gt; (<span class="type">Key</span>.<span class="keyword">Type</span>) <span class="keyword">throws</span> -&gt; <span class="type">KeyedDecodingContainer</span>&lt;<span class="type">Key</span>&gt;, <span class="operator">%</span><span class="number">9</span> : $<span class="operator">*</span><span class="meta">@opened</span>(<span class="string">&quot;563E18FE-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Decoder</span> : $<span class="meta">@convention</span>(witness_method: <span class="type">Decoder</span>) <span class="operator">&lt;</span>τ_0_0 <span class="keyword">where</span> τ_0_0 : <span class="type">Decoder</span><span class="operator">&gt;&lt;</span>τ_1_0 <span class="keyword">where</span> τ_1_0 : <span class="type">CodingKey</span><span class="operator">&gt;</span> (<span class="meta">@thick</span> τ_1_0.<span class="keyword">Type</span>, <span class="meta">@in_guaranteed</span> τ_0_0) -&gt; (<span class="meta">@out</span> <span class="type">KeyedDecodingContainer</span>&lt;τ_1_0&gt;, <span class="meta">@error</span> <span class="type">Error</span>) <span class="comment">// type-defs: %9; user: %13</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行 __JSONDecoder 的 container 方法</span></span><br><span class="line">  try_apply <span class="operator">%</span><span class="number">12</span><span class="operator">&lt;</span><span class="meta">@opened</span>(<span class="string">&quot;563E18FE-301D-11EC-B195-AC87A33022EC&quot;</span>) <span class="type">Decoder</span>, <span class="type">Student</span>.<span class="type">CodingKeys</span><span class="operator">&gt;</span>(<span class="operator">%</span><span class="number">8</span>, <span class="operator">%</span><span class="number">11</span>, <span class="operator">%</span><span class="number">9</span>) : $<span class="meta">@convention</span>(witness_method: <span class="type">Decoder</span>) <span class="operator">&lt;</span>τ_0_0 <span class="keyword">where</span> τ_0_0 : <span class="type">Decoder</span><span class="operator">&gt;&lt;</span>τ_1_0 <span class="keyword">where</span> τ_1_0 : <span class="type">CodingKey</span><span class="operator">&gt;</span> (<span class="meta">@thick</span> τ_1_0.<span class="keyword">Type</span>, <span class="meta">@in_guaranteed</span> τ_0_0) -&gt; (<span class="meta">@out</span> <span class="type">KeyedDecodingContainer</span>&lt;τ_1_0&gt;, <span class="meta">@error</span> <span class="type">Error</span>), normal bb1, error bb5 <span class="comment">// type-defs: %9; id: %13</span></span><br><span class="line"></span><br><span class="line">bb1(<span class="operator">%</span><span class="number">14</span> : $()):                                   <span class="comment">// Preds: bb0</span></span><br><span class="line">  <span class="operator">%</span><span class="number">15</span> <span class="operator">=</span> metatype $<span class="meta">@thin</span> <span class="type">String</span>.<span class="keyword">Type</span>               <span class="comment">// user: %21</span></span><br><span class="line">  <span class="operator">%</span><span class="number">16</span> <span class="operator">=</span> metatype $<span class="meta">@thin</span> <span class="type">Student</span>.<span class="type">CodingKeys</span>.<span class="keyword">Type</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个 CodinggKeys 内存，将 name 的枚举值写入</span></span><br><span class="line">  <span class="operator">%</span><span class="number">17</span> <span class="operator">=</span> <span class="keyword">enum</span> <span class="title class_">$Student</span>.<span class="title class_">CodingKeys</span>, #<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>.<span class="title class_">name</span>!<span class="title class_">enumelt</span> // <span class="title class_">user</span>: %19</span><br><span class="line">  %18 = <span class="title class_">alloc_stack</span> <span class="title class_">$Student</span>.<span class="title class_">CodingKeys</span>           // <span class="title class_">users</span>: %19, %23, %21, %79</span><br><span class="line">  <span class="title class_">store</span> %17 <span class="title class_">to</span> %18 : <span class="title class_">$</span>*<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>         // <span class="title class_">id</span>: %19</span><br><span class="line"></span><br><span class="line">  // 获取 <span class="title class_">KeyedDecodingContainer</span> 中的 <span class="title class_">decode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:) 方法，即 <span class="title class_">__JSONKeyedDecodingContainer</span> 的 <span class="title class_">decode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:)</span><br><span class="line">  // <span class="title class_">function_ref</span> <span class="title class_">KeyedDecodingContainer</span>.<span class="title class_">decode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:)</span><br><span class="line">  %20 = <span class="title class_">function_ref</span> @<span class="title class_">$ss22KeyedDecodingContainerV6decode_6forKeyS2Sm_xtKF</span> : <span class="title class_">$</span>@<span class="title class_">convention</span>(<span class="title class_">method</span>) &lt;τ<span class="title class_">_0_0</span> <span class="title class_">where</span> τ<span class="title class_">_0_0</span> : <span class="title class_">CodingKey</span>&gt; (@<span class="title class_">thin</span> <span class="title class_">String</span>.<span class="keyword">Type</span>, @<span class="title class_">in_guaranteed</span> τ<span class="title class_">_0_0</span>, @<span class="title class_">in_guaranteed</span> <span class="title class_">KeyedDecodingContainer</span>&lt;τ<span class="title class_">_0_0</span>&gt;) -&gt; (@<span class="title class_">owned</span> <span class="title class_">String</span>, @<span class="title class_">error</span> <span class="title class_">Error</span>) // <span class="title class_">user</span>: %21</span><br><span class="line"></span><br><span class="line">  // 执行 <span class="title class_">KeyedDecodingContainer</span> 中的 <span class="title class_">decode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:) 方法，即 <span class="title class_">__JSONKeyedDecodingContainer</span> 的 <span class="title class_">decode</span>(<span class="title class_">_</span>:<span class="title class_">forKey</span>:)</span><br><span class="line">  <span class="title class_">try_apply</span> %20&lt;<span class="title class_">Student</span>.<span class="title class_">CodingKeys</span>&gt;(%15, %18, %8) : <span class="title class_">$</span>@<span class="title class_">convention</span>(<span class="title class_">method</span>) &lt;τ<span class="title class_">_0_0</span> <span class="title class_">where</span> τ<span class="title class_">_0_0</span> : <span class="title class_">CodingKey</span>&gt; (@<span class="title class_">thin</span> <span class="title class_">String</span>.<span class="keyword">Type</span>, @<span class="title class_">in_guaranteed</span> τ<span class="title class_">_0_0</span>, @<span class="title class_">in_guaranteed</span> <span class="title class_">KeyedDecodingContainer</span>&lt;τ<span class="title class_">_0_0</span>&gt;) -&gt; (@<span class="title class_">owned</span> <span class="title class_">String</span>, @<span class="title class_">error</span> <span class="title class_">Error</span>), <span class="title class_">normal</span> <span class="title class_">bb2</span>, <span class="title class_">error</span> <span class="title class_">bb6</span> // <span class="title class_">id</span>: %21</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>至此为止，Codable
中编码和解码的逻辑就形成了闭环。总体而言，编码和解码的核心逻辑主要在
<code>__JSONEncoder</code> 和 <code>__JSONDecoder</code> 中，Container
则用于缓存编码和解码的结果，对于多层级嵌套的数据或模型，在编解码过程中会针对每个层级生成对应的
container。整个过程是递归完成的，在过程中会判断 container
所处的层级，从而决定是否结束递归。</p>
<p>另外很重要的一点是，Codable 之所以如此简单易用，是因为编译器为
Codable 协议自动生成了大量模板代码，从而简化了开发者的工作量，使得
Codable 变得简单易用。</p>
<p>最后，我们可以看到 Codable
的实现中采用了大量面向协议编程的思想，并解决了泛型协议的类型擦除问题。这些思想在我们实际开发中也是有极大的借鉴意义的。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://github.com/apple/swift/blob/56a1663c9859f1283904cb0be4774a4e79d60a22/stdlib/public/core/Codable.swift">Codable.swift</a></li>
<li><a
href="https://github.com/apple/swift/blob/56a1663c9859f1283904cb0be4774a4e79d60a22/stdlib/public/SDK/Foundation/JSONEncoder.swift">JSONEncoder.swift</a></li>
<li>《Flight School - Guide to Swift Codable》</li>
<li><a href="https://www.jianshu.com/p/08541b3e9c83">Swift 5
支持自定义编码的三种容器</a></li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>codable</tag>
        <tag>SIL</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器——序</title>
    <url>/2022/07/17/compiler-for-kaleidoscope-00/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>最近一直在学习编译原理，为了加深对于理论的理解，期间参考 LLVM
官方的相关教程进行实践，设计并实现一款简易的编译器。</p>
<span id="more"></span>
<p>一开始，我使用 LLVM 官方的 <a
href="https://staff.polito.it/silvano.rivoira/HowToWriteYourOwnCompiler.htm">《How
to write your own compiler》</a> 教程来进行尝试，该教程使用 <a
href="http://jflex.de/">JFlex</a> 作为
<strong>词法分析器生成器</strong>（Lexical Analyzer Generator），<a
href="http://www2.cs.tum.edu/projects/cup/">CUP</a> 作为
<strong>语法分析器生成器</strong>（Parser Generator），LLVM 2.7
作为编译后端。编译器整体采用 Java
编码实现，最终实现一门简易的面向对象编程语言 mjava。</p>
<p>一方面，由于年代久远，教程配套的源码其实还是存在挺多问题的，我花了很多时间用于解决工程问题，最终还是由于
LLVM 版本过低，LLVM IR
不兼容，放弃实践。另一方面，由于工业级编程语言几乎都是手工编码实现的编译前端，我意识到该教程与我的预期存在偏差，遂放弃。当然，如果有人感兴趣，可以在我的基础上继续实践——<a
href="https://github.com/baochuquan/implementing-mjava">源码地址</a>。</p>
<p>最终，我重新找了另一份官方教程——<a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html">《My
First Language Frontend with LLVM Tutorial》</a>。该教程基于 C++
语言，手动实现编译前端，调用 LLVM API 生成中间代码，并加入了 LLVM
提供的各种优化通道（Optimization Pass）进行优化，同时支持 JIT 和 AOT
模式，最终实现一门简易的编程语言 Kaleidoscope。</p>
<p>出于笔记和深度理解的目的，我对该教程进行了翻译，各个章节中都或多或少加入了一些自己的理解，如有纰漏或错误，欢迎留言指正。</p>
<h1 id="组织结构">组织结构</h1>
<p>在本系列教程中，我们将介绍并实现一门简单的编程语言——Kaleidoscope，教程的每一章都会逐步对其编译器进行完善。与此同时，我们会介绍编译原理相关的理论和知识，以及
LLVM
相关概念。在每一章中，我们会花费很大的篇幅对相关的代码实现进行解释。因此，强烈建议每一位读者亲自对代码进行实践。</p>
<p>教程总共分为十章，每一章包含不同的主题，各章之间属于循序渐进的关系，各章相关的代码，也是通过增量修改实现的。如下所示，为各章的主题与内容简介。</p>
<ul>
<li><strong>第 1 章 - Kaleidoscope
与词法分析器</strong>。介绍了我们的目标，以及实现的基本功能。词法分析器是为一门编程语言构建解析器的基础，我们使用
C++ 实现一个简单的词法分析器。</li>
<li><strong>第 2 章 - AST
与解析器</strong>。介绍了解析器相关技术，以及抽象语法树的构造。关于解析技术，本教程使用的是递归下降分析法和算符优先级分析法。</li>
<li><strong>第 3 章 - LLVM IR 代码生成</strong>。介绍了如何基于 AST 生成
LLVM IR，通过一种简单的方法将 LLVM 引入到编译器实现中。</li>
<li><strong>第 4 章 - JIT 与优化器支持</strong>。基于 LLVM 为
Kaleidoscope 实现 JIT 编译功能，同时加入对于优化器的支持。</li>
<li><strong>第 5 章 - 语言扩展：控制流</strong>。对 Kaleidoscope
进行语言扩展，实现控制流能力（<code>if</code> 语句和 <code>for</code>
语句）。同时，简单介绍了 SSA 的构造。</li>
<li><strong>第 6 章 - 语言扩展：自定义运算符</strong>。对 Kaleidoscope
进行语言扩展，实现自定义运算符能力，允许用户自定义一元运算符和二元运算符（支持运算符优先级）。</li>
<li><strong>第 7 章 - 语言扩展：可变变量</strong>。对 Kaleidoscope
进行语言扩展，实现局部变量和赋值操作符。同时，介绍了一种隐式的方法让
LLVM 自动构造 SSA。</li>
<li><strong>第 8 章 - 目标文件编译</strong>。介绍了如何基于 LLVM IR
编译生成目标文件。</li>
<li><strong>第 9 章 -
调试信息</strong>。支持调试器，添加调试信息，允许在 Kaleidoscope
函数中设置断点，打印参数变量和调用函数。</li>
<li><strong>第 10 章 -
总结</strong>。主要讨论语言扩展的进阶内容，比如指针、垃圾回收、异常、调试等。</li>
</ul>
<h1 id="环境搭建">环境搭建</h1>
<p>本文实践环境所使用的操作系统是 MacOS Monterey 12.5 版本，LLVM 14.0.0
版本。</p>
<p>下面，我们通过以下步骤生成工程，从而搭建调试环境。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆 llvm 工程</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/llvm/llvm-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换至 llvm 14.0.0 版本</span></span><br><span class="line">$ git checkout llvmorg-14.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line">$ <span class="built_in">cd</span> llvm-project/llvm/</span><br><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 Xcode 工程</span></span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Release -G Xcode ../llvm</span><br></pre></td></tr></table></figure></p>
<p>通过上述步骤，我们会在 <code>llvm-project/llvm/build/</code>
目录下生成一个 <code>LLVM.xcodeproj</code> 工程。使用 Xcode
打开该工程，我们可以看到项目中包含了非常多的 target，其中 Kaleidoscope
相关的 target 也在其中，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/kaleidoscope-01.png?x-oss-process=image/resize,w_800" /></p>
<p>环境搭建完成之后，我们可以真正开始跟着教程学习啦！</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://staff.polito.it/silvano.rivoira/HowToWriteYourOwnCompiler.htm">How
to write your own compiler</a></li>
<li><a href="http://jflex.de/">JFlex</a></li>
<li><a href="http://www2.cs.tum.edu/projects/cup/">CUP</a></li>
<li><a href="https://llvm.org/docs/CMake.html">Building LLVM with
CMake</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>Kaleidoscope</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(1)——Kaleidoscope、词法分析器</title>
    <url>/2022/07/24/compiler-for-kaleidoscope-01/</url>
    <content><![CDATA[<h1 id="kaleidoscope">Kaleidoscope</h1>
<p>本教程我们将从零开始设计一门玩具版编程语言——Kaleidoscope。Kaleidoscope
支持函数定义、条件语句、数学运算等。在教程的各个章节中，我们将对
Kaleidoscope 的语言特性进行扩展，支持 <code>if/then/else</code>
语句、<code>for</code> 循环、自定义操作符、JIT 编译、调试信息等。</p>
<span id="more"></span>
<p>为了简化数据类型，我们设计的 Kaleidoscope 只有一种数据类型是 64
位浮点类型，即 C 语言中的 <code>double</code>
类型。因此，所有值都是隐式双精度类型，并且无需进行类型声明。如下所示，为基于
Kaleidoscope 的斐波那契计算方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">40</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>此外，我们将支持 Kaleidoscope
调用标准库函数。因此，我们可以在使用函数之前使用 <code>extern</code>
关键字来定义函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">atan2</span><span class="params">(arg1 arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">atan2</span>(<span class="built_in">sin</span>(<span class="number">.4</span>), <span class="built_in">cos</span>(<span class="number">42</span>))</span><br></pre></td></tr></table></figure>
<p>下面，我们开始为 Kaleidoscope 语言逐步实现编译器吧！</p>
<h1 id="词法分析器">词法分析器</h1>
<p>事实上，实现编程语言的本质其实是实现编程语言的编译器。首先，我们要实现编译器的文本处理与内容识别能力，即
<strong>词法分析器</strong>（Lexer）。词法分析器将输入内容分解为
<strong>token</strong>。词法分析器返回的每个 token
都包含相关元数据，如：token 值、token 类型等。如下所示，为 token
定义类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    tok_eof = <span class="number">-1</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// commands</span></span><br><span class="line">    tok_def = <span class="number">-2</span>,</span><br><span class="line">    tok_extern = <span class="number">-3</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// primary</span></span><br><span class="line">    tok_identifier = <span class="number">-4</span>,</span><br><span class="line">    tok_number = <span class="number">-5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::string IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br></pre></td></tr></table></figure>
<p>词法分析器返回的 token 的类型可以分为两大类：</p>
<ul>
<li>预定义类型，即 <code>Token</code>
枚举中定义的枚举值，使用负整数表示。</li>
<li>未知字符，如：<code>+</code>，使用 <code>[0-255]</code>
正整数表示。</li>
</ul>
<p>当词法分析器解析到 <code>tok_identifier</code> 类型或
<code>tok_number</code> 类型的 token 时，会进行以下处理。</p>
<ul>
<li>如果当前 token 类型是 <code>tok_identifier</code> 时，则使用全局变量
<code>IdentifierStr</code> 保存标识符的名称，作为 token 值。</li>
<li>如果当前 token 类型是 <code>tok_number</code>，则使用全局变量
<code>NumVal</code> 保存数值，作为 token 值。</li>
</ul>
<blockquote>
<p><strong>注意，这里其实与 <code>lex</code> 工具使用 <code>yyval</code>
保存 token 值，<code>yytext</code>
保存标识符有着异曲同工之妙。</strong></p>
</blockquote>
<p>词法分析器的核心部分由 <code>gettok</code> 函数实现。每一次调用
<code>gettok</code> 函数都将从标准输入中返回下一个
token。<code>gettok</code> 的具体实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> LastChar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = <span class="built_in">getchar</span>())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    std::string NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = <span class="built_in">strtod</span>(NumStr.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; LastChar != <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">gettok</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don&#x27;t eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="type">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gettok</code> 函数使用 C 函数 <code>getChar()</code>
读取标准输入的字符，并通过 <code>while</code> 循环忽略 token
之间的空格。然后，根据第一个字符进行分类处理。</p>
<ul>
<li>如果第一个字符是字母，那么 <code>gettok</code>
开始识别标识符和关键字，并将标识符存入 <code>IdentifierStr</code>
全局变量，返回对应的 token 类型。</li>
<li>如果第一个字符是数字或 <code>.</code>，那么 <code>gettok</code>
开始识别数值，并将数值存入 <code>NumVal</code> 全局变量，返回 token 类型
<code>tok_number</code></li>
<li>如果第一个字符是 <code>#</code>，那么 <code>gettok</code>
识别注释，该符号之后整行内容均为注释内容，进行忽略处理。</li>
<li>如果第一个字符是 <code>EOF</code>，那么识别文件结束符，返回 token
类型 <code>token_eof</code>。</li>
<li>其它情况，则返回该字符的 ASCII 值。</li>
</ul>
<p>如下所示，为 <code>gettoken</code> 函数的工作原理示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-02.png?x-oss-process=image/resize,w_800" /></p>
<p>至此，我们实现了 Kaleidoscope
的词法分析器。下一章，我们将实现语法分析器（Parser），从而构建抽象语法树（Abstract
Syntax
Tree）。当实现了词法分析器和语义分析器后，我们会实现一个驱动器（Driver）来使两者协同进行工作，并进行测试。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html">Kaleidoscope:
Kaleidoscope Introduction and the Lexer</a></li>
<li><a
href="http://en.wikipedia.org/wiki/Kaleidoscope">Kaleidoscope</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>Kaleidoscope</tag>
        <tag>LLVM</tag>
        <tag>词法分析器</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(2)——解析器、抽象语法树</title>
    <url>/2022/07/31/compiler-for-kaleidoscope-02/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>本章，我们将基于词法分析器，为 Kaleidoscope
构建一个完整的解析器（Parser）。通过解析器，我们可以定义并构造抽象语法树（Abstract
Syntax Tree，AST）。</p>
<span id="more"></span>
<p>我们构造的解析器使用两种方法进行语法分析：</p>
<ul>
<li><strong>递归下降分析法（Recursive Descent
Parsing）</strong>：用于基本表达式的解析。</li>
<li><strong>算符优先分析法（Operator-Precedence
Parsing）</strong>：用于二元表达式的解析。</li>
</ul>
<p>在实现解析器之前，我们先来介绍一下解析器的输出——抽象语法树。</p>
<h1 id="抽象语法树">抽象语法树</h1>
<p><strong>抽象语法树（AST）为编译器后续的各个阶段提供了一种易于解释的表示形式</strong>，比如：代码生成。通常，我们希望编程语言中的每一种结构都有一个对应的表示对象。为了实现这种映射关系，我们使用
AST 对语言进行分析建模。</p>
<p>在 Kaleidoscope 的 AST 中，我们设计了三种结构，分别是：</p>
<ul>
<li><strong>表达式</strong></li>
<li><strong>原型</strong></li>
<li><strong>函数</strong></li>
</ul>
<h2 id="表达式">表达式</h2>
<p>如下所示，<code>ExprAST</code> 是 AST
中表达式的基类定义，其包含了多种子类定义，分别用于对应不同的具体表达式。由于
Kaleidoscope
只有一种数据类型——双精度浮点类型，因此我们没有必要存储类型信息。当然，现实的编程语言通常都包含多种类型，这种情况下
<code>ExprAST</code> 会包含一个用于存储类型信息的字段。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExprAST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如下所示为 <code>ExprAST</code> 的各种子类定义，分别是：</p>
<ul>
<li><code>NumberExprAST</code>：用于表示
<strong>数值表达式</strong>，其捕获字面量的数值保存于 <code>Val</code>
中。</li>
<li><code>VariableExprAST</code>：用于表示
<strong>变量表达式</strong>，其捕获变量名保存于 <code>Name</code>
中。</li>
<li><code>BinaryExprAST</code>：用于表示
<strong>二元表达式</strong>，其使用 <code>Op</code>
保存操作符，如：<code>+</code>。使用 <code>LHS</code> 和
<code>RHS</code> 分别保存左子表达式和右子表达式。</li>
<li><code>CallExprAST</code>：用于表示
<strong>函数调用表达式</strong>，其使用 <code>Callee</code>
保存函数名。使用 <code>Args</code> 数组变量保存函数的各个参数。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-03.png?x-oss-process=image/resize,w_800" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    <span class="type">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberExprAST</span>(<span class="type">double</span> Val) : <span class="built_in">Val</span>(Val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    std::string Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VariableExprAST</span>(<span class="type">const</span> std::string &amp;Name) : <span class="built_in">Name</span>(Name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    <span class="type">char</span> Op;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryExprAST</span>(<span class="type">char</span> op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : <span class="built_in">Op</span>(op), <span class="built_in">LHS</span>(std::<span class="built_in">move</span>(LHS)), <span class="built_in">RHS</span>(std::<span class="built_in">move</span>(RHS)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    std::string Callee;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CallExprAST</span>(<span class="type">const</span> std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args) : <span class="built_in">Callee</span>(Callee), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于仅包含基本功能的编程语言而言，上述为全部的 AST
表达式节点定义。由于不包含条件控制流，因此这并不是图灵完备的；对此，我们将在后面进一步对其进行优化。</p>
<h2 id="原型">原型</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-04.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示，<code>PrototypeAST</code> 为 AST
中原型（Prototype）的定义。原型用于表示一个函数的原型，用于捕获函数的名称，各个参数的名称等。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrototypeAST</span> &#123;</span><br><span class="line">    std::string Name;</span><br><span class="line">    std::vector&lt;std::string&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrototypeAST</span>(<span class="type">const</span> std::string &amp;name, std::vector&lt;std::string&gt; Args) : <span class="built_in">Name</span>(name), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp;<span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数">函数</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-05.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示，<code>FunctionAST</code> 为 AST
中函数的定义。函数由函数原型和函数体组成，其分别使用 <code>Proto</code>
和 <code>Body</code> 进行存储。其中函数体是一个 AST 表达式结构。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionAST</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;PrototypeAST&gt; Proto;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FunctionAST</span>(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : <span class="built_in">Proto</span>(std::<span class="built_in">move</span>(Proto)), <span class="built_in">Body</span>(std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="解析器基础">解析器基础</h1>
<p>上文，我们定义了 AST
的结构，包括各种类型的节点。下面，我们来介绍如何通过解析器构建
AST。例如，对于表达式 <code>x+y</code> 可以通过如下方式将其解析成 AST。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> LHS = std::<span class="built_in">make_unique</span>&lt;VariableExprAST&gt;(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> RHS = std::<span class="built_in">make_unique</span>&lt;VariableExprAST&gt;(<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> Result = std::<span class="built_in">make_unique</span>&lt;BinaryExprAST&gt;(<span class="string">&#x27;+&#x27;</span>, std::<span class="built_in">move</span>(LHS), std::<span class="built_in">move</span>(RHS));</span><br></pre></td></tr></table></figure> 为此，我们需要实现一些辅助函数，如下所示。我们通过
<code>CurToken</code> 作为词法分析器的输出 token
缓冲区。解析器内部每次调用词法分析器，输出一个
token，存储在缓冲区中。解析器则通过读取 <code>CurToken</code>
用于后续的解析。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CurTok = <span class="built_in">gettok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了处理错误，我们还定义了 <code>LogError</code>
函数。这里我们对于不同类型的错误处理均返回 <code>nullptr</code>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">LogError</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;LogError: %s\n&quot;</span>, Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::unique_ptr&lt;PrototypeAST&gt; <span class="title">LogErrorP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LogError</span>(Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="表达式解析">表达式解析</h1>
<p>Kaleidoscope
文法的每一个产生式，我们定义一个对应的解析函数。关于表达式的解析，其实可以分为以下几种类型：</p>
<ul>
<li><strong>数值表达式</strong>：解析 <code>NumberExprAST</code>。</li>
<li><strong>括号表达式</strong>：解析 <code>BinaryExprAST</code>。</li>
<li><strong>标识符表达式</strong>：解析两种 AST 类型
<code>VariableExprAST</code> 和 <code>CallExprAST</code>。</li>
</ul>
<p>下面我们分别进行介绍。</p>
<h2 id="数值表达式">数值表达式</h2>
<p>对于数值表达式，我们定义如下解析函数。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseNumberExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Result = std::<span class="built_in">make_unique</span>&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// consume the number</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当词法分析器分析当前 token 的类型为 <code>tok_number</code>
时，解析器会调用 <code>ParseNumberExpr</code> 解析函数，读取全局变量
<code>NumVal</code>，从而获取数值，最终创建并返回一个
<code>NumberExprAST</code> 节点。</p>
<p>在 <code>ParseNumberExpr</code>
解析函数中，它将读取所有与产生式相关的 token，并将下一个 token
写入词法分析器缓存 <code>CurTok</code>
中，以用于后续的分析。这其实是递归下降分析的标准方式，即
<strong>预测分析</strong>——提前读取下一个 token
进行分析，避免深度优先搜索带来回溯开销。</p>
<h2 id="括号表达式">括号表达式</h2>
<p>对于括号表达式，我们定义如下解析函数。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// parenexpr ::= &#x27;(&#x27; expression &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseParenExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;)&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在
<code>ParseParenExpr</code> 解析函数中，我们可以看到对于
<code>LogError</code> 的使用。当调用 <code>LogError</code> 时，表示当前
token 是 <code>(</code>，在解析完子表达式之后，发现并没有与之匹配的
<code>)</code>。比如，当我们使用 <code>(4 x</code> 替代 <code>(4)</code>
作为输入，解析器就会调用 <code>LogError</code> 进行报错处理。</p>
<p>除此之外，我们还可以发现内部递归调用了 <code>ParseExpression</code>
解析函数（后面我们会提到该函数）。通过递归调用，解析器能够处理递归语法，从而简化每一个文法产生式，最终返创建并返回一个
<code>BinaryExprAST</code> 节点。</p>
<p>注意，括号并不会构建 AST 节点，其最大的作用是辅助解析器进行分组。当
AST 构建完毕，括号也就不需要了。</p>
<h2 id="标识符表达式">标识符表达式</h2>
<p>对于标识符表达式，我们定义如下解析函数。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法表达式</span></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier &#x27;(&#x27; expression* &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseIdentifierExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat (</span></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = <span class="built_in">ParseExpression</span>())</span><br><span class="line">        Args.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;Expected &#x27;)&#x27; or &#x27;,&#x27; in argument list&quot;</span>);</span><br><span class="line">      <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the &#x27;)&#x27;.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;CallExprAST&gt;(IdName, std::<span class="built_in">move</span>(Args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 解析器会在当前
token 类型为 <code>tok_identifier</code> 时调用
<code>ParseIdentifierExpr</code>
解析函数。其内部同样实现了递归分析和错处处理，并且通过预测分析的方式来判断当前的标识符是变量引用表达式还是函数调用表达式，从而分别进行处理。这里的预测分析是通过判断当前
<code>token</code> 下一个 token 是否是 <code>(</code>
实现的，从而分别构建 <code>VariableExprAST</code> 节点和
<code>CallExprAST</code> 节点。</p>
<h2 id="主表达式">主表达式</h2>
<p>我们将四种类型的表达式统称为 <strong>主表达式（Primary
Expression）</strong>。
为了方便外部对各种类型的表达式进行解析，我们提供一个主表达式解析函数，对外隐藏细节，对内提供实现，该解析方法如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ParsePrimary</code> 解析函数的实现逻辑非常清晰，即通过读取
<code>CurTok</code> 进行预测分析，判断 token
类型，并调用对应解析函数，从而构建 AST。</p>
<h1 id="二元表达式解析">二元表达式解析</h1>
<p>二元表达式是表达式的一种，相比于其他三种表达式，二元表达式（Binary
Expression）解析会更加复杂，因为它们通常具有二义性。比如，当我们输入字符串
<code>x+y*z</code>，解析器可以解析成 <code>(x+y)*z</code> 或
<code>x+(y*z)</code>。基于数学定义，我们期望解析器能将其解析为后者，因为乘法
<code>*</code> 的优先级是高于加法 <code>+</code> 的。</p>
<p>处理二义性的方式很多，其中一种优雅且高效的方式是
<strong>算符优先分析法</strong>。这种分析技术通过为操作符定义优先级来辅助递归分析。比如，我们可以通过如下方式来定义优先级。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="type">static</span> std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it&#x27;s a declared binop.</span></span><br><span class="line">  <span class="type">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>;  <span class="comment">// highest.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们以二元运算符为键，优先级为值存储于哈希表中，便于进行扩展。在
Kaleidoscope 中，我们仅支持 4
种二元运算符。<code>GetTokPrecedence</code> 函数根据当前 token
从哈希表中读取对应的优先级，如果 token 不是二元运算符，则返回 -1。</p>
<p><strong>算符优先分析法的基本思想是：将具有二义性二元运算符的表达式分解为多个片段，依次进行解析</strong>。比如，对于表达式
<code>a+b+(c+d)*e*f+g</code>。算符优先分析法会将其视为一系列由二元运算符分隔的主表达式。因此，解析器会首先分析头部的主表达式
<code>a</code>，然后依次分析
<code>[+, b]</code>，<code>[+, (c+d)]</code>，<code>[*, e]</code>，<code>[*, f]</code>，<code>[+, g]</code>。由于括号表达式也是主表达式，因此二元表达式的解析并不需要关注类似
<code>(c+d)</code> 这样的嵌套子表达式。</p>
<p>下面，我们来看一下具体的实现。</p>
<p>首先，我们将表达式分解为
<strong>一个主表达式+多个<code>[binop, primaryexpr]</code></strong>
的形式，对应的解析函数如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = <span class="built_in">ParsePrimary</span>();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ParseBinOpRHS</span>(<span class="number">0</span>, std::<span class="built_in">move</span>(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ParseBinOpRHS</code> 函数用于解析
<code>[binop, primaryexpr]</code>
序列，其入参包含两个：<strong>优先级</strong>、<strong>已解析的表达式指针</strong>。值得注意的是，表达式
<code>x</code> 其实也是一个有效的表达式，在这种文法表达式
<code>binoprhs</code> 为空的情况下，<code>ParseBinOpRHS</code>
解析函数会将传入的已解析的表达式指针直接返回。</p>
<p><code>ParseBinOpRHS</code> 函数的优先级的参数表示
<strong>最小算符优先级</strong>（Minimal Operator
Precedence），即函数能够允许读取的运算符。比如，如果当前的分析内容是
<code>[+, x]</code>，而传入 <code>ParseBinOpRHS</code> 函数的优先级为
40，那么函数不会读取任何 token，因为 <code>+</code> 的优先级为 20。</p>
<p><code>ParseBinOpRHS</code> 函数的具体定义如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= (&#x27;+&#x27; primary)*</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseBinOpRHS</span><span class="params">(<span class="type">int</span> ExprPrec,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              std::unique_ptr&lt;ExprAST&gt; LHS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> TokPrec = <span class="built_in">GetTokPrecedence</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="type">int</span> BinOp = CurTok;</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the primary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = <span class="built_in">ParsePrimary</span>();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="type">int</span> NextPrec = <span class="built_in">GetTokPrecedence</span>();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = <span class="built_in">ParseBinOpRHS</span>(TokPrec + <span class="number">1</span>, std::<span class="built_in">move</span>(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;BinaryExprAST&gt;(BinOp, std::<span class="built_in">move</span>(LHS), std::<span class="built_in">move</span>(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在
<code>ParseBinOpRHS</code> 函数内部，它会首先读取当前 token
的优先级。如果优先级低于设定
<code>ExprPrec</code>，则直接返回传入的已解析的表达式
<code>LHS</code>。如果优先级符合设定，那么将解析操作符之后的主表达式。</p>
<p>此时，我们已经解析了表达式的左部以及 RHS
序列的一个分段。接下来，我们需要决定如何关联表达式。比如，这里有两种关联方式：<code>(a+b) binop &lt;未解析部分&gt;</code>
或
<code>a + (b binop &lt;未解析部分&gt;)</code>。为此，我们通过预测分析的方式，继续向前读取一个运算符的优先级，并与
<code>BinOp</code> 的优先级进行比较（例子中是 <code>+</code>）。</p>
<p>如果 <code>RHS</code>
右边的运算符的优先级小于或等于当前操作符，那么我们选择
<code>(a+b) binop &lt;未解析部分&gt;</code>
的关联方式。在例子中，当前的运算符和下一个运算符都是
<code>+</code>，具有相同的优先级。</p>
<p>在例子中，解析函数会将 <code>a+b+</code> 解析为
<code>(a+b)</code>，并在下一次循环中继续执行。接下来，它会将
<code>(c+d)</code> 作为主表达式进行解析，即直接解析
<code>[+, (c+d)]</code>。继续解析，则会遇到 <code>*</code> 运算符。由于
<code>*</code> 的优先级大于 <code>+</code>，因此将执行 <code>if</code>
语句的内部逻辑。其内部逻辑会对高优先级的部分作为进行整体解析，然后将其作为低优先级运算符右部。为此，我们递归地调用
<code>ParseBinOpRHS</code> 函数，并指定最低优先级为
<code>TokPrec+1</code>。在例子中，会将 <code>(c+d)*e*f</code> 作为
<code>+</code> 的 <code>RHS</code>。</p>
<p>最后，<code>[+, g]</code> 会在下一次循环中被解析。</p>
<p>此时，我们可以使用解析器对任意 token
序列进行解析并构建表达式。当检测到不属于表达式的 token 时停止解析。</p>
<h1 id="函数相关解析">函数相关解析</h1>
<p>关于函数相关的解析，其实可以分为几种类型：</p>
<ul>
<li><strong>函数原型</strong></li>
<li><strong>函数定义</strong></li>
<li><strong>外部原型</strong></li>
</ul>
<h2 id="函数原型">函数原型</h2>
<p>对于函数原型，我们定义如下解析函数。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id &#x27;(&#x27; id* &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParsePrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected function name in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::string FnName = IdentifierStr;</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the list of argument names.</span></span><br><span class="line">  std::vector&lt;std::string&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getNextToken</span>() == tok_identifier)</span><br><span class="line">    ArgNames.<span class="built_in">push_back</span>(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;)&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;PrototypeAST&gt;(FnName, std::<span class="built_in">move</span>(ArgNames));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数定义">函数定义</h2>
<p>对于函数定义，我们定义如下解析函数。其本质上就是函数原型与普通表达式的组合，后者用于表示函数体，如下图所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// definition ::= &#x27;def&#x27; prototype expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = <span class="built_in">ParsePrototype</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Proto) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>())</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="外部原型">外部原型</h2>
<p>对于外部原型，我们定义如下解析函数。其本质上就是 <code>extern</code>
关键字与函数原型的组合。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// external ::= &#x27;extern&#x27; prototype</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParseExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ParsePrototype</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="顶层表达式解析">顶层表达式解析</h1>
<p>为了允许用户输入任意的顶层表达式，并支持解析。我们定义一个匿名空值（零参数）函数来进行解析，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseTopLevelExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = std::<span class="built_in">make_unique</span>&lt;PrototypeAST&gt;(<span class="string">&quot;__anon_expr&quot;</span>, std::<span class="built_in">vector</span>&lt;std::string&gt;());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ParseTopLevelExpr</code> 解析函数会通过调用
<code>ParseExpression</code> 解析函数进行解析。当解析得到
<code>BinaryExprAST</code> 节点后，创建一个 <code>PrototypeAST</code>
节点，并使用 <code>FunctionAST</code>
节点将两者封装成一个匿名函数，最终返回 <code>FunctionAST</code>
节点。</p>
<p>至此，我们介绍了各种类型的表达式的解析，下面我们通过实现一个驱动器来对实际的代码进行解析。</p>
<h1 id="驱动器">驱动器</h1>
<p>驱动器（Driver）的实现如下所示，其仅仅是在一个顶层的循环中调用所有类型的表达式解析函数。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ParseDefinition</span>()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed a function definition.\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ParseExtern</span>()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed an extern\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ParseTopLevelExpr</span>()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed a top-level expr\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | &#x27;;&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ready&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      <span class="built_in">getNextToken</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      <span class="built_in">HandleDefinition</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      <span class="built_in">HandleExtern</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">HandleTopLevelExpression</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
值得注意的是，这里我们对顶层的分号进行了忽略处理。原因是，如果我们在命令行中输入
<code>4 + 5</code>，解析器并不是我们输入的内容是否结束。例如，我们可以在下一行输入
<code>def foo...</code>，在这种情况下，<code>4 + 5</code>
是顶层表达式的结尾，或者，我们可以输入 <code>* 6</code>
来续写表达式。对此，使用顶层分号，对应 <code>4 + 5;</code>
表达式，解析器才能知道表达式已经输入完成。</p>
<h1 id="总结">总结</h1>
<p>通过 400 多行代码，我们定义了一门简单的语言，包括词法分析器、解析器和
AST 构造器。完成之后，我们可以通过可执行文件来验证 Kaleidoscope
代码，从而判断代码是否存储语法语义错误。</p>
<p>如下所示，为验证步骤及其结果。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x y)</span> x+<span class="title">foo</span><span class="params">(y, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x y)</span> x+y y</span>;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">Parsed a top-level expr</span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x y)</span> x+y )</span>;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">Error: unknown token when expecting an expression</span><br><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(a)</span></span>;</span><br><span class="line">ready&gt; Parsed an <span class="keyword">extern</span></span><br><span class="line">ready&gt; ^C</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<p>当然，代码仍然具有很大的扩展空间。我们可以定义新的 AST
节点，并以多种方式对语言进行扩展等。下一章，我们将介绍如何从 AST 生成
LLVM 中间表示 <code>IR</code>。</p>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Parser</tag>
        <tag>AST</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(3)——LLVM IR 代码生成</title>
    <url>/2022/08/07/compiler-for-kaleidoscope-03/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>在上一章中，我们介绍了如何构建抽象语法树
AST。这一章，我们进一步将抽象语法树转换成 LLVM IR。此外，我们会简单介绍
LLVM 的工作原理和使用方法。</p>
<span id="more"></span>
<blockquote>
<p>注意：本章源码要求 LLVM 版本大于等于 3.7。</p>
</blockquote>
<h1 id="初始化设置">初始化设置</h1>
<p>为了支持 LLVM IR 代码生成，我们需要实现相关的初始化设置。</p>
<p>首先，我们在每一个 AST 类中定义虚拟代码生成方法，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExprAST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="type">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NumberExprAST</span>(<span class="type">double</span> Val) : <span class="built_in">Val</span>(Val) &#123;&#125;</span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure> <code>codegen()</code> 方法为对应 AST
节点及其所依赖的内容生成 IR，返回一个 LLVM <code>Value</code> 对象。</p>
<p><code>Value</code> 是 LLVM 中用于表示 <strong>静态单赋值（Static
Single Assignment，SSA）寄存器</strong> 或 <strong>SSA 形式</strong>
的类。静态单赋值，顾名思义，其要求每个变量只能赋值一次，并且每个变量在使用之前定义。因此，在重新计算之前，变量的值不会发生改变。</p>
<p>其次，我们实现了一个 <code>LogError</code>
方法，用于在代码生成期间报告错误，比如：未声明的参数。如下所示：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LogError</span>(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，我们定义了一系列全局静态变量，用于辅助代码生成，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;LLVMContext&gt; TheContext;</span><br><span class="line"><span class="type">static</span> std::unique_ptr&lt;IRBuilder&lt;&gt;&gt; Builder;</span><br><span class="line"><span class="type">static</span> std::unique_ptr&lt;Module&gt; TheModule;</span><br><span class="line"><span class="type">static</span> std::map&lt;std::string, Value *&gt; NamedValues;</span><br></pre></td></tr></table></figure> <code>TheContenxt</code> 是一个不透明的对象，它包含许多
LLVM
核心数据结构，比如类型和常量值表。我们不需要详细了解它，只需要一个单例来传递其所需的
API。</p>
<p><code>Builder</code> 对象是一个辅助对象，用于生成 LLVM
指令。<code>IRBuilder</code>
类模板的实例能够追踪插入指令的当前位置，并能够创建新指令。</p>
<p><code>TheModule</code> 是一个包含一系列函数和全局变量的 LLVM
数据结构。在许多方面，它是 LLVM IR
用来包含代码的顶层结构。其持有了生成的所有 IR 的内存，这也是
<code>codegen()</code> 方法返回 <code>Value*</code> 指针，而不是
<code>unique_ptr&lt;Value&gt;</code> 的原因。</p>
<p><code>NamedValues</code> 用于存储当前作用域内所定义的值及其 LLVM
表示形式。本质上就是代码的符号表。在 Kaleidoscope
中，唯一可以被引用的是函数参数。因此，在为函数体生成代码时，函数参数将存储在
<code>NamedValues</code> 中。</p>
<p>在介绍了代码生成的基础设置之后，下面我们开始介绍如何为每个表达式生成代码。</p>
<h1 id="表达式代码生成">表达式代码生成</h1>
<p>表达式节点的 LLVM IR 代码生成非常简单。下面，我们分别进行介绍。</p>
<h2 id="数值表达式">数值表达式</h2>
<p>如下所示，为数值表达式的代码生成方法定义，其创建并返回一个
<code>ConstantFP</code>。事实上，在 LLVM IR 中，数字常量由
<code>ConstantFP</code> 类表示，其内部将数值保存在 <code>APFloat</code>
中（<code>APFloat</code> 能够保存任意精度浮点常量）。注意，在 LLVM IR
中，常量都是唯一且共享的。因此，API 通常使用 <code>foo::get(...)</code>
的用法，而不是 <code>new foo(..)</code> 或
<code>foo::Create(..)</code>。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">NumberExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::<span class="built_in">get</span>(TheContext, <span class="built_in">APFloat</span>(Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="变量表达式">变量表达式</h2>
<p>如下所示，为变量表达式的代码生成方法定义，其仅检查指定变量是否在符号表
<code>NameValues</code>
中（如果没有，则引用未知变量）并返回它的值。在目前的定义中，我们在
<code>NamedValues</code>
中仅存储函数参数。在后续文章节中，我们将在符号表中支持
<strong>循环归纳变量</strong>（Loop Induction Variable）和
<strong>局部变量</strong>（Local Variable）。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VariableExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二元表达式">二元表达式</h2>
<p>如下所示，为二元表达式的代码生成方法定义，其基本思想是：<strong>分别为二元表达式的左部和右部递归生成代码，然后根据操作符的类型分别计算二元表达式的结果</strong>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *L = LHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  Value *R = RHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFAdd</span>(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFSub</span>(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFMul</span>(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    L = Builder.<span class="built_in">CreateFCmpULT</span>(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateUIToFP</span>(L, Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;invalid binary operator&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码实现中，我们通过 LLVM <code>Builder</code>
类的相关方法来生成代码，其内部知道在何处创建指令，我们要做的就是指定指令的类型（如：<code>CreateFAdd</code>），指定使用的操作数（如：<code>L</code>
和 <code>R</code>），指定生成指令的名称（如：<code>addtmp</code>）。</p>
<p>关于生成指令的名称，其实只是一个提示。比如如，上述代码中如果发出多个
<code>addtmp</code> 变量，LLVM
将自动为每个变量提供一个递增的、唯一的数字后缀。
指令的名称完全是可选的，它的作用仅仅是提高 LLVM IR 的可读性。</p>
<p>LLVM
指令有着严格规则约束，比如，加法指令的左右操作数的类型必须相同，加法的结果类型必须与操作数类型相同。由于
Kaleidoscope 中的所有值都是双精度值类型，这使得
<code>add</code>、<code>sub</code> 和 <code>mul</code>
的代码非常简单。</p>
<p>此外，LLVM 规定 <code>fcmp</code> 指令必须返回一个 <code>i1</code>
值（一个一位整数）。然而，我们定义的 Kaleidoscope 希望该值是 0.0 或
1.0（浮点数）。为了获得这些语义，我们将 <code>fcmp</code> 指令与
<code>uitofp</code>
指令结合起来。后者通可以将输入整数转换为浮点值。与此相反，如果我们使用
<code>sitofp</code> 指令，那么 Kaleidoscope 的 <code>&lt;</code>
运算符将根据输入值返回 0.0 和 -1.0。</p>
<h2 id="函数调用表达式">函数调用表达式</h2>
<p>如下所示，为函数调用表达式的代码生成方法定义。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = TheModule-&gt;<span class="built_in">getFunction</span>(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown function referenced&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;<span class="built_in">arg_size</span>() != Args.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Incorrect # arguments passed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, e = Args.<span class="built_in">size</span>(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.<span class="built_in">push_back</span>(Args[i]-&gt;<span class="built_in">codegen</span>());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.<span class="built_in">back</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(CalleeF, ArgsV, <span class="string">&quot;calltmp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述方法实现中，在 LLVM Module 的符号表中查找对应的函数。LLVM
Module 是 JIT
阶段存储函数的容器。通过为每个函数指定与用户指定的名称相同的名称，我们可以使用
LLVM 符号表为我们解析函数名称。</p>
<p>当发生调用函数时，我们递归地对每个入参进行代码生成，并创建一个 LLVM
函数调用指令。注意，LLVM 默认使用 C
调用规范，允许这些函数调用同时调用标准库函数，如 <code>sin</code> 和
<code>cos</code>。</p>
<h1 id="函数相关代码生成">函数相关代码生成</h1>
<p>函数和原型的代码生成涉及一系列的细节处理，这也使得其代码实现不如表达式代码生成实现那么简洁优雅。下面，我们来分别介绍函数原型和函数定义的代码生成。</p>
<h2 id="函数原型">函数原型</h2>
<p>函数原型的代码生成也可以应用于函数定义和外部原型。如下所示，为函数原型的代码生成方法定义。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">PrototypeAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">    <span class="function">std::vector&lt;Type *&gt; <span class="title">Doubles</span><span class="params">(Args.size(), Type::getDoubleTy(*TheContext))</span></span>;</span><br><span class="line">    FunctionType *FT = FunctionType::<span class="built_in">get</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Function *F = Function::<span class="built_in">Create</span>(FT, Function::ExternalLinkage, Name, TheModule.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set names for all arguments.</span></span><br><span class="line">    <span class="type">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;<span class="built_in">args</span>())</span><br><span class="line">        Arg.<span class="built_in">setName</span>(Args[Idx++]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>PrototypeAST::codegen</code> 函数返回的类型是
<code>Function *</code>，而不是
<code>Value</code>。本质上，原型用于描述函数的外部接口，而不是表达式计算的值，因此其返回代码生成时对应的
LLVM 函数，即 <code>Function *</code> 类型。</p>
<p><code>FunctionType::get</code> 函数为原型创建函数类型
<code>FunctionType</code>。由于 Kaleidoscope
中的所有函数参数都是双精度类型，因此在调用
<code>FunctionType::get</code> 之前，我们根据参数的数量
<code>Args.siz()</code> 创建了一个包含 <code>N</code> 个 LLVM
双精度类型的向量。然后，使用 <code>FunctionType::get</code>
方法创建一个函数类型，该函数类型接受 <code>N</code>
个双精度类型的值作为参数，返回一个双精度类型的值作为结果。</p>
<p><code>Function::Create</code> 函数使用函数类型创建 IR
函数，其指定函数类型、链接和名称，以及写入的目标模块。<strong>外部链接（External
Linkage）</strong>
表示该函数可以在当前模块外部进行定义，或者可以被模块外部的函数所调用。传入的
<code>Name</code> 参数表示用户指定的名称，由于指定了
<code>TheModule</code>，因此该名称会被注册在 <code>TheModule</code>
的符号表中。</p>
<p>最后，我们为每个函数参数设置名称。这个步骤并非必要，但保持名称一致会使
IR 更具有更好的可读性，并且允许后续代码直接引用参数名称，而不必在原型的
AST 中进行查找。</p>
<h2 id="函数定义">函数定义</h2>
<p>如下所示，为函数定义的代码生成方法定义。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First, check for an existing function from a previous &#x27;extern&#x27; declaration.</span></span><br><span class="line">    Function *TheFunction = TheModule-&gt;<span class="built_in">getFunction</span>(Proto-&gt;<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">        TheFunction = Proto-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">    BasicBlock *BB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">    Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">    NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>())</span><br><span class="line">        NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = &amp;Arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">        <span class="comment">// Finish off the function.</span></span><br><span class="line">        Builder-&gt;<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">        <span class="built_in">verifyFunction</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TheFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">    TheFunction-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于函数定义，我们首先在模块的符号表中查找该函数的已有版本。如果
<code>Module::getFunction</code> 返回 <code>null</code>
则表示不存在，因此我们将通过 <code>Proto-&gt;codegen</code> 来生成。</p>
<p>然后，我们对 <code>Builder</code> 进行设置，具体分为两个步骤：</p>
<ul>
<li>通过 <code>BasicBlock::Create</code> 函数创建一个
<strong>基本块</strong>（Basic Block），基本块随后被插入到
<code>TheFunction</code> 中。</li>
<li>通过 <code>Builder-&gt;SetInsertPoint</code>
函数设置基本块的末尾为指令的插入位置。LLVM 中的基本块是定义
<strong>控制流图</strong>（Control Flow Graph）中的函数的重要组成部分。
由于我们没有任何控制流语句，我们的函数此时只包含一个基本块。</li>
</ul>
<p>随后，我们将函数参数添加到 <code>NamedValues</code> 符号表中，以便
<code>VariableExprAST</code> 节点进行访问。</p>
<p>当设置了代码插入点并注册了 <code>NamedValues</code>
符号表后，我们开始对函数体执行 <code>codegen()</code>
方法。如果没有发生错误，我们会进而创建一个 LLVM <code>ret</code>
指令，表示函数的终止。当函数构建完成后，我们调用 LLVM 的
<code>verifyFunction</code>
函数对生成的代码进行各种一致性检查，以确保我们的编译器是否一切正常。<code>verifyFunction</code>
函数非常重要，它能够检测出很多
bug。检测完毕且无错误，我们返回构造的函数。</p>
<p>最后的实现逻辑是错误处理。当错误发生时，我们仅通过调用
<code>eraseFromParent</code>
函数来删除过程中生成的函数。这样能够允许用户重新定义他们之前输入的错误函数，如果我们不删除它，它将存在于符号表中，并且无法重新定义。</p>
<h1 id="驱动器适配">驱动器适配</h1>
<p>为了进行测试，我们对驱动器了进行简单的适配，将对 <code>codegen</code>
的调用插入到 <code>HandleDefinition</code>、<code>HandleExtern</code>
等函数，并在其内部打印 LLVM IR。</p>
<p>对于顶层二元表达式，LLVM IR
的代码生成结果如下所示。我们可以看到解析器如何为将顶层表达式转换为匿名函数的，这对于我们后续支持
JIT 是非常有用的。此外，我们可以看到生成的 IR
是逐字翻译的，除了常量合并，没有作其他任何优化。在后续的文章中，我们会显式地进行优化。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="number">4</span>+<span class="number">5</span>;</span><br><span class="line">Read top-level expression:</span><br><span class="line">define <span class="type">double</span> @__anon_expr() &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret <span class="type">double</span> <span class="number">9.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于简单的函数定义，如下所示，分别是 LLVM IR
的代码生成结果，以及生成过程的示意图。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(a b)</span> a*a + 2*a*b + b*b</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %a, <span class="type">double</span> %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul <span class="type">double</span> %a, %a</span><br><span class="line">  %multmp1 = fmul <span class="type">double</span> <span class="number">2.000000e+00</span>, %a</span><br><span class="line">  %multmp2 = fmul <span class="type">double</span> %multmp1, %b</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %multmp, %multmp2</span><br><span class="line">  %multmp3 = fmul <span class="type">double</span> %b, %b</span><br><span class="line">  %addtmp4 = fadd <span class="type">double</span> %addtmp, %multmp3</span><br><span class="line">  ret <span class="type">double</span> %addtmp4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-06.png?x-oss-process=image/resize,w_800" /></p>
<p>对于简单的函数调用，LLVM IR的代码生成结果如下所示。当我们调用
<code>bar</code>
函数时，其会消耗比较长的时间执行完毕。后续，我们添加条件控制流来优化递归。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">bar</span><span class="params">(a)</span> <span class="title">foo</span><span class="params">(a, <span class="number">4.0</span>)</span> + <span class="title">bar</span><span class="params">(<span class="number">31337</span>)</span></span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">bar</span>(<span class="type">double</span> %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %a, <span class="type">double</span> <span class="number">4.000000e+00</span>)</span><br><span class="line">  %calltmp1 = call <span class="type">double</span> @<span class="built_in">bar</span>(<span class="type">double</span> <span class="number">3.133700e+04</span>)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp1</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为声明外部 <code>cos</code> 函数以及调用 <code>cos</code>
函数的 IR 代码。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">cos</span>(<span class="number">1.234</span>);</span><br><span class="line">Read top-level expression:</span><br><span class="line">define <span class="type">double</span> @__anon_expr() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span> <span class="number">1.234000e+00</span>)</span><br><span class="line">  ret <span class="type">double</span> %calltmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们退出测试进程时（MacOS 系统，输入
<code>cmd+D</code>），其会打印生成的 Module 的所有 IR
代码。我们可以看到很多方法相互引用，如下所示： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ready&gt; ^D</span><br><span class="line">; ModuleID = <span class="string">&#x27;my cool jit&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;my cool jit&quot;</span></span><br><span class="line"></span><br><span class="line">define double @foo(double %a, double %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul double %a, %a</span><br><span class="line">  %multmp1 = fmul double 2.000000e+00, %a</span><br><span class="line">  %multmp2 = fmul double %multmp1, %b</span><br><span class="line">  %addtmp = fadd double %multmp, %multmp2</span><br><span class="line">  %multmp3 = fmul double %b, %b</span><br><span class="line">  %addtmp4 = fadd double %addtmp, %multmp3</span><br><span class="line">  ret double %addtmp4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define double @bar(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @foo(double %a, double 4.000000e+00)</span><br><span class="line">  %calltmp1 = call double @bar(double 3.133700e+04)</span><br><span class="line">  %addtmp = fadd double %calltmp, %calltmp1</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> double @cos(double)</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>本文，我们为解析器支持了 LLVM IR 代码生成功能，后续在此基础上，为
Kaleidoscope 支持 JIT 代码生成以及优化器。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.html">Kaleidoscope:
Code generation to LLVM IR</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static
single-assignment form</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>LLVM IR</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(4)——代码优化器、JIT 编译器</title>
    <url>/2022/08/14/compiler-for-kaleidoscope-04/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>前面几章我们介绍了如何实现一门简单的编程语言，同时支持了 LLVM IR
代码生成。本文，我们将介绍并实现两类技术：</p>
<ul>
<li><strong>代码优化器</strong></li>
<li><strong>JIT 编译器</strong></li>
</ul>
<span id="more"></span>
<h1 id="常量合并优化">常量合并优化</h1>
<p>在第 3 章中，我们实现了 LLVM IR
代码生成的能力。不过，生成的代码仍然具有很大的优化空间。当然，我们所使用的
<code>IRBuider</code> 对代码也进行了一定程度的优化，如下所示。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) 1+2+x;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double %x, 3.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中，<code>IRBuilder</code>
对代码进行了常量合并优化。如果根据输入内容进行 AST
构建，基于字面含义生成的代码则将如下所示。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) 1+2+x;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double 2.000000e+00, 1.000000e+00</span><br><span class="line">  %addtmp1 = fadd double %addtmp, %x</span><br><span class="line">  ret double %addtmp1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>常量合并</strong>（Contants
Folding）是一种非常常见且重要的优化方法，几乎所有编程语言都在其 AST
中实现了常量合并优化。</p>
<p>在使用 LLVM 时，我们无需显式地开启常量合并优化功能，<strong>因为 LLVM
IR 构造器内部会自动检测并执行常量合并</strong>。</p>
<p>事实上，我们通常建议使用 <code>IRBuilder</code>
来生成代码。<code>IRBuilder</code> 在构建过程中没有
<strong>语法开销</strong>（Syntactic
Overhead），即无需显式指定编译器进行常量检查。此外，还能够显著减少某些情况下的
LLVM IR 代码量。</p>
<p>当然，<code>IRBuilder</code>
也有一定的限制，其在生成代码时将所有分析的代码进行内联，从而会导致无法探测到某些优化点。比如：
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) (1+2+x)*(x+(1+2));</span><br><span class="line">ready&gt; Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double 3.000000e+00, %x</span><br><span class="line">  %addtmp1 = fadd double %x, 3.000000e+00</span><br><span class="line">  %multmp = fmul double %addtmp, %addtmp1</span><br><span class="line">  ret double %multmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在上述这种情况下，乘法操作的 <code>LHS</code> 和
<code>RHS</code> 是相同的值。我们期望生成的代码是
<code>tmp = x+3; result = tmp * tmp</code>，而不是计算两次
<code>x+3</code>。</p>
<p>遗憾的是，本地分析很难探测并纠正类似的优化点。这里，我们需要两种优化方式才能消除例子中冗余的
<code>fadd</code> 指令，分别是：</p>
<ul>
<li><strong>表达式重联</strong>（Reassociation Of Expression）</li>
<li><strong>公共子表达式消除</strong>（Common Subexpression
Elimination）</li>
</ul>
<p>对此，LLVM 以 <strong>通道（Pass）</strong>
的形式提供了各种类型的优化，其中就包含上述的两种优化方式。</p>
<h1 id="代码优化器">代码优化器</h1>
<p>LLVM 为各种类型的优化提供了对应的优化通道（下文简称
<code>Pass</code>）。与其他系统不同，LLVM
并没有错误地认为某一组优化适用于所有编程语言和所有情况。相反，LLVM
允许编译器开发者自定义选择哪些优化、以哪种顺序优化、在哪种情况下优化。</p>
<p>比如，LLVM 提供了 <code>whole module</code>
Pass，其能够尽可能多地查看代码体（通常是整个文件，如果在链接时执行，那么它可能是整个程序的很大一部分）。LLVM
还支持 <code>per-function</code>
Pass，其一次只对一个函数进行操作，而不查看其他函数。关于 Pass
的更多细节，可以查看官方文档——<a
href="https://llvm.org/docs/WritingAnLLVMPass.html">How to Write a
Pass</a>、<a href="https://llvm.org/docs/Passes.html">LLVM’s Analysis
and Transform Passes</a>。</p>
<p>现阶段，当用户输入代码时，我们会实时生成 LLVM
IR。在实时解析过程中，我们会在用户输入代码时运行
<code>per-function</code> Pass
进行优化。如果我们想实现一个“静态编译器”，我们可以完全使用现有的代码，不同的是，我们只会在整个文件被解析完成之后，才运行优化器。</p>
<p>为了执行 <code>per-function</code> Pass，我们需要设置一个
<code>FunctionPassManager</code> 来管理我们希望运行的 LLVM 优化通道。当
<code>FunctionPassManager</code>
设置完成后，我们可以向其注册一组优化通道来执行。对于每一个
Module，需要创建一个对应的
<code>FunctionPassManager</code>，因此我们可以实现一个函数来为完成创建并初始化模块和通道管理器，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = std::<span class="built_in">make_unique</span>&lt;Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = std::<span class="built_in">make_unique</span>&lt;legacy::FunctionPassManager&gt;(TheModule.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createInstructionCombiningPass</span>());</span><br><span class="line">  <span class="comment">// Reassociate expressions.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createReassociatePass</span>());</span><br><span class="line">  <span class="comment">// Eliminate Common SubExpressions.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createGVNPass</span>());</span><br><span class="line">  <span class="comment">// Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createCFGSimplificationPass</span>());</span><br><span class="line"></span><br><span class="line">  TheFPM-&gt;<span class="built_in">doInitialization</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先初始化了全局模块 <code>TheModule</code> 和通道管理器
<code>TheFPM</code>，后者被附加到了 <code>TheModule</code>
中。当通道管理器初始化完毕，我们通过调用 <code>add</code>
方法来添加一系列 LLVM 优化通道。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-07.png?x-oss-process=image/resize,w_800" /></p>
<p>这里，我们添加了 4
种优化通道，包括：<strong>窥孔优化</strong>、<strong>表达式重联</strong>、<strong>公共子表达式消除</strong>、<strong>控制流图简化</strong>
等。这是一组非常标准的代码清理优化，可用于各种代码。</p>
<p>当通道管理器初始化完毕后，我们会在
<code>FunctionAST::codegen()</code>
方法的末尾来调用并执行通道管理器，最终将优化结果返回，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">  <span class="comment">// Finish off the function.</span></span><br><span class="line">  Builder.<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">  <span class="built_in">verifyFunction</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optimize the function.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">run</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TheFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，通道管理器的执行非常简单。<code>FunctionPassageManager</code>
直接对 LLVM Funtion*
进行优化和更新。我们可以对它进行简单的测试，如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">test</span><span class="params">(x)</span> <span class="params">(<span class="number">1</span>+<span class="number">2</span>+x)</span>*<span class="params">(x+(<span class="number">1</span>+<span class="number">2</span>))</span></span>;</span><br><span class="line">ready&gt; Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">test</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, <span class="number">3.000000e+00</span></span><br><span class="line">  %multmp = fmul <span class="type">double</span> %addtmp, %addtmp</span><br><span class="line">  ret <span class="type">double</span> %multmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
相比之前，生成的 LLVM IR 代码得到了预期的优化，去掉了冗余的
<code>fadd</code> 指令。</p>
<p>LLVM 为不同的场景提供了各种类型的优化。官方文档 <a
href="https://llvm.org/docs/Passes.html">LLVM’s Analysis and Transform
Passes</a>
列出了一部分优化相关的通道，但不是非常完整。此外，我们也可以查看 Clang
启动时所执行的通道，还可以通过 <code>opt</code> 工具来试验通道。</p>
<h1 id="jit-编译器">JIT 编译器</h1>
<p>LLVM 提供了非常多的工具，以支持操作 LLVM IR。例如：我们可以对 LLVM IR
执行各种类型的优化（如上文所示），可以将 LLVM IR
转换成文本形式或二进制形式，可以将 LLVM IR
编译成特定架构的汇编代码，可以对 LLVM IR 进行即时编译（JIT，Just In
Time）。<strong>LLVM IR
的核心作用是作为编译器不同部分之间的通用传递形式</strong>。</p>
<p>在这一节中，我们将为 Kaleidoscope 实现 JIT 编译器。<strong>JIT
的基本思想是：当用户输入代码时，即时分析并评估其顶层表达式</strong>。比如：当用户输入
<code>1+2;</code> 时，我们将输出 <code>3</code>。</p>
<p>对此，我们首先准备相关环境，包括：</p>
<ul>
<li><strong>初始化本机目标（Native Target）</strong>：通过调用
<code>InitializeNativeTarget</code> 相关方法实现。</li>
<li><strong>初始化 JIT</strong>：通过设置 <code>KaleidoscopeJIT</code>
类型的 <code>TheJIT</code> 全局变量实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmParser</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;=&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ready&gt; &quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  TheJIT = <span class="built_in">ExitOnErr</span>(KaleidoscopeJIT::<span class="built_in">Create</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main &quot;interpreter loop&quot; now.</span></span><br><span class="line">  <span class="built_in">MainLoop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，我们还需要为 JIT 设置数据内存布局，如下所示： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Open a new module.</span></span><br><span class="line">  TheContext = std::<span class="built_in">make_unique</span>&lt;LLVMContext&gt;();</span><br><span class="line">  TheModule = std::<span class="built_in">make_unique</span>&lt;Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, *TheContext);</span><br><span class="line">  TheModule-&gt;<span class="built_in">setDataLayout</span>(TheJIT-&gt;<span class="built_in">getDataLayout</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = std::<span class="built_in">make_unique</span>&lt;legacy::FunctionPassManager&gt;(TheModule.<span class="built_in">get</span>());</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p><code>KaleidoscopeJIT</code> 类表示针对 Kaleidoscope 语言的
JIT。在后续的章节中，我们将介绍它是如何工作的，并使用新功能对其进行扩展。它的
API 非常简单，包括：</p>
<ul>
<li><code>addModule</code>：用于向 JIT 注册 LLVM IR
module，使其函数可用于执行。</li>
<li><code>lookup</code>：允许我们查找指向已编译代码的指针。</li>
</ul>
<p>我们在顶层表达式解析函数中调用 <code>KaleidoscopeJIT</code> 的
AIP，如下所示： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = <span class="built_in">ParseTopLevelExpr</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FnAST-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">      <span class="comment">// Create a ResourceTracker to track JIT&#x27;d memory allocated to our</span></span><br><span class="line">      <span class="comment">// anonymous expression -- that way we can free it after executing.</span></span><br><span class="line">      <span class="keyword">auto</span> RT = TheJIT-&gt;<span class="built_in">getMainJITDylib</span>().<span class="built_in">createResourceTracker</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> TSM = <span class="built_in">ThreadSafeModule</span>(std::<span class="built_in">move</span>(TheModule), std::<span class="built_in">move</span>(TheContext));</span><br><span class="line">      <span class="built_in">ExitOnErr</span>(TheJIT-&gt;<span class="built_in">addModule</span>(std::<span class="built_in">move</span>(TSM), RT));</span><br><span class="line">      <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Search the JIT for the __anon_expr symbol.</span></span><br><span class="line">      <span class="keyword">auto</span> ExprSymbol = <span class="built_in">ExitOnErr</span>(TheJIT-&gt;<span class="built_in">lookup</span>(<span class="string">&quot;__anon_expr&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the symbol&#x27;s address and cast it to the right type (takes no</span></span><br><span class="line">      <span class="comment">// arguments, returns a double) so we can call it as a native function.</span></span><br><span class="line">      <span class="built_in">double</span> (*FP)() = (<span class="built_in">double</span> (*)())(<span class="type">intptr_t</span>)ExprSymbol.<span class="built_in">getAddress</span>();</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Evaluated to %f\n&quot;</span>, <span class="built_in">FP</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Delete the anonymous expression module from the JIT.</span></span><br><span class="line">      <span class="built_in">ExitOnErr</span>(RT-&gt;<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上述代码中，如果解析成功且代码生成，那么会将包含顶层表达式的 module
注册至 JIT 中。我们通过调用 <code>addModule</code> 方法实现，该方法会为
module 中的所有函数生成代码，并将 module
与一个资源追踪器进行绑定，以用于后续从 JIT 中移除 module。当 module
注册完成后，将无法对其进行修改，因此我们需要创建一个新的 module
用于持有后续的代码，通过调用
<code>InitializeModuleAndPassManager()</code> 方法实现。</p>
<p>当 module
注册完毕后，我们需要获取一个指向最终生成代码的指针。为此，我们调用 JIT
的 <code>lookup</code>
方法，并传递顶层表达式函数的名称：<code>__anon_expr</code>。</p>
<p>接下来，我们通过该符号调用 <code>getAddress()</code> 来获取
<code>__anon_expr</code>
函数的内存地址。回想一下，我们将顶层表达式编译成一个自包含的 LLVM
函数，该函数不接受任何参数并返回计算的双精度值。由于 LLVM JIT
编译器与本机平台 ABI
匹配，因此我们可以将结果指针转换为该类型的函数指针并直接调用它。这意味着，JIT
编译代码和静态链接到应用程序的本机机器代码之间没有区别。</p>
<p>最后，由于我们不支持重新评估顶层表达式，所以当我们完成释放相关内存时，我们会从
JIT 中删除 module。然而，我们之前创建的 module（通过
<code>InitializeModuleAndPassManager</code>）仍然打开并等待添加新代码。</p>
<p>如下所示，为我们对 JIT
的测试代码。顶层表达式使用无参函数进行表示，返回了一个 double 类型的值。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="number">4</span>+<span class="number">5</span>;</span><br><span class="line">Evaluated to <span class="number">9.000000</span></span><br></pre></td></tr></table></figure></p>
<p>下面，我们再来测试 JIT 下的函数的定义与调用，如下所示：
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">testfunc</span><span class="params">(x y)</span> x + y*2</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">testfunc</span>(<span class="type">double</span> %x, <span class="type">double</span> %y) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul <span class="type">double</span> %y, <span class="number">2.000000e+00</span></span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, %multmp</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">testfunc</span>(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">Evaluated to <span class="number">24.000000</span></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">testfunc</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">ready&gt; Error: Unknown function referenced</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，在第二次调用 <code>testfunc</code> 函数时，LLVM
提示找不到 <code>testfunc</code> 函数，这是怎么回事？从前面介绍 JIT 的
API 中我们可以知道，module 是 JIT 的分配单元，<code>testfunc</code>
的定义与 <code>testfunc</code> 的调用（匿名表达式）处于同一个 moudle
中，当我们从 JIT 中删除 module 以释放匿名表达式时的内存时，module 中
<code>testfunc</code> 的定义也被删除了。因此，当我们再次尝试调用
<code>testfunc</code> 时，JIT 提示找不到该函数。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-08.png?x-oss-process=image/resize,w_800" /></p>
<p>一种简单的解决方法是：<strong>将匿名表达式与函数定义放在不同的 module
中</strong>。每个函数原型都会提前注册至 JIT 中，当执行函数调用时，JIT
会进行跨 module 查找。通过将匿名表达式放在不同的 module
中，我们可以在不影响其他功能的情况下将其释放。如下所示，为该解决方法的示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-09.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，我们可以进一步进行优化，将每个函数定义存储在其对应的 module
中。这样的话，我们可以实现更加真实的 REPL 环境：同名函数可以多次添加至
JIT 中。当通过 KaleidoscopeJIT
查找符号时，它将返回最新的函数定义，最终达到如下所示的效果。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x)</span> x + 1</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, <span class="number">1.000000e+00</span></span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">Evaluated to <span class="number">3.000000</span></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x)</span> x + 2</span>;</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, <span class="number">2.000000e+00</span></span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">Evaluated to <span class="number">4.000000</span></span><br></pre></td></tr></table></figure></p>
<p>为了让每个函数定义能够存储在其对应的 module
中，我们需要一种方法来重新生成函数声明，并将它们存储至新的 module
中。具体实现，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(std::string Name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, see if the function has already been added to the current module.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;<span class="built_in">getFunction</span>(Name))</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If not, check whether we can codegen the declaration from some existing</span></span><br><span class="line">  <span class="comment">// prototype.</span></span><br><span class="line">  <span class="keyword">auto</span> FI = FunctionProtos.<span class="built_in">find</span>(Name);</span><br><span class="line">  <span class="keyword">if</span> (FI != FunctionProtos.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> FI-&gt;second-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no existing prototype exists, return null.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = <span class="built_in">getFunction</span>(Callee);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">  Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>如下所示，为调整后的设计原理示意图。由于每个函数定义都对应一个模块，而
<code>TheModule</code> 仅仅指向当前模块。因此，无法通过
<code>TheModule</code>
查找其他模块中是否存在特定的函数定义。为了解决这个问题，引入了
<code>FunctionProtos</code>
来存储所有模块定义的函数原型，方便进行查找。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-10.png?x-oss-process=image/resize,w_800" /></p>
<p>我们首先设置一个全局的
<code>FunctionProtos</code>，用于存储每个函数的原型，支持覆盖。此外，我们还定义一个便利方法
<code>getFunction()</code> 用于替换
<code>TheModule-&gt;getFunction()</code> <code>getFunction()</code>
的核心逻辑如下所示。</p>
<ul>
<li>首先，在 <code>TheModule</code> 中查找函数声明。</li>
<li>如果存在，则返回。</li>
<li>如果不存在，则在 <code>FunctionProtos</code>
中继续查找函数声明。</li>
</ul>
<p>在 <code>CallExprAST::codegen()</code> 中，我们只需要将
<code>TheModule-&gt;getFunction()</code> 替换成
<code>getFunction()</code> 即可。</p>
<p>在 <code>FunctionAST::codegen()</code> 中，我们首先更新
<code>FunctionProtos</code>，然后调用 <code>getFunction()</code>
即可。</p>
<p>之后，我们就可以在当前 module 中查找并调用之前声明的函数。</p>
<p>为此，我们还需要进行如下改造。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = <span class="built_in">ParseDefinition</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Read function definition:&quot;</span>);</span><br><span class="line">      FnIR-&gt;<span class="built_in">print</span>(<span class="built_in">errs</span>());</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      <span class="built_in">ExitOnErr</span>(TheJIT-&gt;<span class="built_in">addModule</span>(<span class="built_in">ThreadSafeModule</span>(std::<span class="built_in">move</span>(TheModule), std::<span class="built_in">move</span>(TheContext))));</span><br><span class="line">      <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = <span class="built_in">ParseExtern</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Read extern: &quot;</span>);</span><br><span class="line">      FnIR-&gt;<span class="built_in">print</span>(<span class="built_in">errs</span>());</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      FunctionProtos[ProtoAST-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(ProtoAST);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在
<code>HandleDefinition</code>
函数中，我们新增了两行代码：将定义的函数注册至 JIT
中并初始化一个新的模块与通道管理器。</p>
<p>在 <code>HandleExtern</code>
函数中，我们新增了一行代码：将函数原型添加至 <code>FunctionProtos</code>
中。</p>
<p>完成上述修改后，我们再来测试一下，如下所示。此时，函函数重复定义后，能够自动匹配最新定义的函数。<strong>注意：由于
LLVM 9.0 及以后版本不支持不同模块定义相同符号，因此 LLVM 9.0
及以后版本并不支持本文所示的覆盖函数定义的能力。</strong>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ready&gt; def foo(x) x + 1;</span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 3.000000</span><br><span class="line"></span><br><span class="line">ready&gt; def foo(x) x + 2;</span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 4.000000</span><br></pre></td></tr></table></figure></p>
<p>最后，我们再来测试一下能否调用外部函数。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">sin</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">sin</span>(<span class="number">1.0</span>);</span><br><span class="line">Evaluated to <span class="number">0.841471</span></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x)</span> <span class="title">sin</span><span class="params">(x)</span>*<span class="title">sin</span><span class="params">(x)</span> + <span class="title">cos</span><span class="params">(x)</span>*<span class="title">cos</span><span class="params">(x)</span></span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">sin</span>(<span class="type">double</span> %x)</span><br><span class="line">  %multmp = fmul <span class="type">double</span> %calltmp, %calltmp</span><br><span class="line">  %calltmp2 = call <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span> %x)</span><br><span class="line">  %multmp4 = fmul <span class="type">double</span> %calltmp2, %calltmp2</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %multmp, %multmp4</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">foo</span>(<span class="number">4.0</span>);</span><br><span class="line">Evaluated to <span class="number">1.000000</span></span><br></pre></td></tr></table></figure>
从上述执行结果来看，JIT 是能够查找到外部函数 <code>sin</code> 和
<code>cos</code>。这是如何做到的？事实上，<code>KaleidoscopeJIT</code>
内部有一个简单的符号解析规则，用于查找所注册 module
中不存在的符号：首先搜索已添加到 JIT 的所有 module，找到函数定义。如果
JIT 中没有找到定义，那么它将到 Kaleidoscope 进程自身上调用
<code>dlsym("sin")</code>。由于 <code>sin</code> 是在 JIT
的地址空间中定义的，它将 module 中对 <code>sin</code> 函数的调用转换成对
libm 版本的 <code>sin</code>
函数的调用。在某些情况下，它会更进一步，因为 <code>sin</code> 和
<code>cos</code> 是标准的数学函数名称，当使用上面的
<code>sin(1.0)</code> 时，常量合并优化器能够直接返回其计算结果。</p>
<p>后续，我们将介绍如何调整 <code>KaleidoscopeJIT</code>
中的这套符号解析规则，从而启用各种功能，从安全性（限制 JIT
代码可用的符号集）到基于符号名称的动态代码生成、以及懒编译（Lazy
Compilation）。</p>
<h1 id="总结">总结</h1>
<p>至此，我们完成了对 Kaleidoscope 的 JIT
和优化器的支持。我们可以实现一门非图灵完备的编程语言，以用户驱动的方式对齐进行优化和
JIT
编译。后续，我们将研究使用控制流结构扩展编程语言，并在此过程中解决一些
LLVM IR 相关的问题。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.html">Kaleidoscope:
Adding JIT and Optimizer Support</a></li>
<li><a href="https://llvm.org/docs/WritingAnLLVMPass.html">How to Write
a Pass</a></li>
<li><a href="https://llvm.org/docs/Passes.html">LLVM’s Analysis and
Transform Passes</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>JIT</tag>
        <tag>Pass</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(5)——语言扩展：控制流</title>
    <url>/2022/08/21/compiler-for-kaleidoscope-05/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>在前 4 章中，我们介绍了 Kaleidoscope 语言的实现，包括支持 LLVM IR
代码生成、优化器、JIT 编译器等。然而，目前我们设计的 Kaleidoscope
的功能非常简单，除了函数调用和返回外，甚至不包含控制流的能力。这意味着我们在代码中无法使用条件分支，因此极大地限制了编程语言的能力。本章，我们将对
Kaleidoscope 进行扩展，使其支持 <code>if/then/else</code> 语句和
<code>for</code> 语句。</p>
<span id="more"></span>
<h1 id="ifthenelse">if/then/else</h1>
<p>为 Kaleidoscope 进行语言扩展 <code>if/then/else</code>
语句其实非常简单。我们只需要修改词法分析器、解析器、AST、LLVM
代码生成器就可以实现这个新的特性。</p>
<p>在我们介绍如何实现该特性之前，我们首先需要清楚这个特性是什么。本质上，我们其实就是就是希望
Kaleidoscope 能够支持如下所示的代码。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在第 2 章中，我们为 Kaleidoscope 的 AST 设计了三种结构，分别是
<strong>表达式</strong>、<strong>原型</strong>、<strong>函数</strong>。其中，表达式结构均会返回一个值，而
<code>if/then/else</code>
同样也会返回一个值。本质上，<code>if/then/else</code>
语句是先对条件进行计算，然后根据条件的结果选择返回 <code>then</code> 或
<code>else</code> 的值。因此，我们定义一个表达式子类用于表示
<code>if/then/else</code> 语句。</p>
<p><code>if/then/else</code>
的语义是将条件的计算结果作为一个布尔等价值：0.0 表示
<code>false</code>，其他值则为 <code>true</code>。如果条件为
<code>true</code>，则计算并返回第一个子表达式；如果条件为
<code>false</code>，则计算并返回第二个子表达式。</p>
<p>下面，我们来对各个部分进行扩展从而实现 <code>if/then/else</code>
表达式。</p>
<h2 id="词法分析器扩展">词法分析器扩展</h2>
<p>词法分析器的扩展非常简单。首先，我们需要新增几种 token
类型，如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control</span></span><br><span class="line">tok_if = <span class="number">-6</span>,</span><br><span class="line">tok_then = <span class="number">-7</span>,</span><br><span class="line">tok_else = <span class="number">-8</span>,</span><br></pre></td></tr></table></figure></p>
<p>然后，我们分别为这些 token 类型定义 token 值，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_def;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_extern;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;if&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_if;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;then&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_then;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;else&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_else;</span><br><span class="line"><span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure></p>
<h2 id="ast-扩展">AST 扩展</h2>
<p>为了表示 <code>if/then/else</code> 语句，我们定义一个表达式子类的 AST
节点类型 <code>IFExprAST</code>，如下所示。<code>IFExprAST</code>
节点包含三个指针，分别指向 <code>Cond</code> 子表达式、<code>Then</code>
子表达式、<code>Else</code> 子表达式。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// IfExprAST - Expression class for if/then/else.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IfExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IfExprAST</span>(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then,</span><br><span class="line">            std::unique_ptr&lt;ExprAST&gt; Else)</span><br><span class="line">    : <span class="built_in">Cond</span>(std::<span class="built_in">move</span>(Cond)), <span class="built_in">Then</span>(std::<span class="built_in">move</span>(Then)), <span class="built_in">Else</span>(std::<span class="built_in">move</span>(Else)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="解析器扩展">解析器扩展</h2>
<p>至此，我们已经有了针对 <code>if/then/else</code> 的 token 的定义和
AST 节点定义。接下来，我们来对解析器进行扩展。</p>
<p>首先，我们来定义一个对应的解析函数。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ifexpr ::= &#x27;if&#x27; expression &#x27;then&#x27; expression &#x27;else&#x27; expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseIfExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat the if.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition.</span></span><br><span class="line">  <span class="keyword">auto</span> Cond = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Cond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_then)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected then&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat the then</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Then = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Then)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_else)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected else&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Else = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Else)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;IfExprAST&gt;(std::<span class="built_in">move</span>(Cond), std::<span class="built_in">move</span>(Then), std::<span class="built_in">move</span>(Else));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们将解析函数加入到主表达式解析函数中，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="llvm-ir">LLVM IR</h2>
<p>至此，我们已经解析并构造了 AST。接下来，我们来为
<code>if/then/else</code> 支持 LLVM IR
代码生成。上述扩展的相关代码在之前的章节中都已经进行了详细的介绍，而这部分的扩展，我们将引入一些新的概念。</p>
<p>我们首先来看一个简单的例子，如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">def <span class="title">baz</span><span class="params">(x)</span> <span class="keyword">if</span> x then <span class="title">foo</span><span class="params">()</span> <span class="keyword">else</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果，我们不进行代码优化，生成的代码会是如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">declare <span class="type">double</span> @<span class="built_in">foo</span>()</span><br><span class="line"></span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">bar</span>()</span><br><span class="line"></span><br><span class="line">define <span class="type">double</span> @<span class="built_in">baz</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %ifcond = fcmp one <span class="type">double</span> %x, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:       ; preds = %entry</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">foo</span>()</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:       ; preds = %entry</span><br><span class="line">  %calltmp1 = call <span class="type">double</span> @<span class="built_in">bar</span>()</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line">ifcont:     ; preds = %<span class="keyword">else</span>, %then</span><br><span class="line">  %iftmp = phi <span class="type">double</span> [ %calltmp, %then ], [ %calltmp1, %<span class="keyword">else</span> ]</span><br><span class="line">  ret <span class="type">double</span> %iftmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于上述 LLVM IR 代码，我们可以将其转换成如下所示的控制流图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-12.png?x-oss-process=image/resize,w_800" /></p>
<p>在 LLVM IR 中，<code>entry</code>
基本块对条件表达式进行计算（结果存储在 <code>x</code> 中），并使用
<code>fcmp one</code>（<code>one</code> 表示
<code>Ordered and Ont Equal</code>）命令将结果值与 <code>0.0</code>
进行比较。然后，根据表达式的结果决定代码跳转至 <code>then</code>
基本块或 <code>else</code> 基本块。</p>
<p>当 <code>then/else</code> 基本块执行完毕，它们均会进入
<code>ifcont</code> 基本块，从而执行 <code>if/then/else</code>
表达式后续的代码。在例子中，我们只需返回至函数调用者即可。</p>
<h3 id="φ-函数">φ 函数</h3>
<p>在上述例子中，我们最终会向函数调用者返回一个表达式，那么问题来了：代码是否如何知道应该返回哪个表达式？答案是通过
phi 操作实现。</p>
<p>在第 3 章，我们提到 LLVM 的 <code>Value</code> 是用来表示
<strong>静态单赋值形式（SSA form）</strong> 的类型，LLVM IR 则是 SSA
的指令表示形式。当我们对基于 SSA
形式的控制流图进行分析时，如果有两条控制流边汇合到一起时，如何使每个变量只有一次赋值就不是那么显而易见的了。如下所示
(a) 图中，如果我们在基本块 1 和基本块 3 中分别为 a
实现了一次定值，那么基本块 4 该使用哪个值呢？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-13.png?x-oss-process=image/resize,w_800" /></p>
<p>为了解决这个问题，我们引入一个虚构符号，称为
<strong>φ函数</strong>。如上所示 (b) 图中，使用
<code>a3 &lt;- φ(a1, a2)</code> 来合并 <code>a1</code>（基本块 1
中的定值）和 <code>a2</code>（基本块 3 中的定值）。 如果控制流沿边 2
-&gt; 4 到达基本块 4，φ(a1, a2) 产生 a1；如果控制流沿边 3 -&gt; 4
到达基本块 4，φ(a1, a2) 产生 a2。</p>
<p>在 LLVM IR 中，使用 <code>phi</code> 指令实现 φ
函数。在例子中，如果控制流来自 <code>then</code> 基本块，那么
<code>phi</code> 指令会读取 <code>calltmp</code> 的值，如果控制流来自
<code>else</code> 基本块，那么 <code>phi</code> 指令会读取
<code>calltmp1</code> 的值。</p>
<h2 id="代码生成">代码生成</h2>
<p>如下所示为 <code>IFExprAST</code> 类的 <code>codegen</code>
方法，用于 LLVM IR 代码生成。我们依次对这个方法的各个部分进行介绍。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">IfExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *CondV = Cond-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!CondV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">  CondV = Builder-&gt;<span class="built_in">CreateFCmpONE</span>(</span><br><span class="line">      CondV, ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">0.0</span>)), <span class="string">&quot;ifcond&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-14.png?x-oss-process=image/resize,w_800" /></p>
<p>首先，我们解析得到条件表达式，并通过将其值与 0.0
进行比较，从而转换成一个布尔类型。上图所示，展示了这部分逻辑生成的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();</span><br><span class="line"></span><br><span class="line">// Create blocks for the then and else cases.  Insert the &#x27;then&#x27; block at the</span><br><span class="line">// end of the function.</span><br><span class="line">BasicBlock *ThenBB = BasicBlock::Create(*TheContext, &quot;then&quot;, TheFunction);</span><br><span class="line">BasicBlock *ElseBB = BasicBlock::Create(*TheContext, &quot;else&quot;);</span><br><span class="line">BasicBlock *MergeBB = BasicBlock::Create(*TheContext, &quot;ifcont&quot;);</span><br><span class="line"></span><br><span class="line">Builder-&gt;CreateCondBr(CondV, ThenBB, ElseBB);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-15.png?x-oss-process=image/resize,w_800" /></p>
<p>其次，分别为 <code>if/then/else</code>
语句创建相关基本块，如：<code>ThenBB</code>、<code>ElseBB</code>、<code>MergeBB</code>。这里，其首先获取当前正在构建的
<code>Function</code> 对象。基于 <code>Function</code>
对象，创建三个基本块。注意，这里将 <code>TheFunction</code> 传入
<code>then</code> 基本块的构造函数，其用于将新创建的基本块插入到指定函数
<code>TheFunction</code>
的末尾。其他两个基本块创建后并没有立即插入函数。当基本块创建完成后，我们通过
<code>Builder-&gt;CreateCondBr</code> 方法创建条件分支。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Emit then value.</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(ThenBB);</span><br><span class="line"></span><br><span class="line">Value *ThenV = Then-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"><span class="keyword">if</span> (!ThenV)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Builder-&gt;<span class="built_in">CreateBr</span>(MergeBB);</span><br><span class="line"><span class="comment">// Codegen of &#x27;Then&#x27; can change the current block, update ThenBB for the PHI.</span></span><br><span class="line">ThenBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-16.png?x-oss-process=image/resize,w_800" /></p>
<p>随后，我们设置 <code>Builder</code> 中基本块的插入点并开始插入
<code>then</code>
基本块。严格来说，它会将插入点移动到指定基本块的末尾。但是，由于此时
<code>then</code> 基本块是空的，所以它也是在块的开头开始插入。</p>
<p>当插入点设置完成后，我们递归地为 <code>then</code>
表达式生成代码。为了完成 <code>then</code> 基本块，我们为无条件分支创建
<code>merge</code> 基本块。LLVM IR 要求所有基本块都使用诸如返回
<code>ret</code> 或分支 <code>br</code>
的控制流指令来终止。这意味着我们必须在 LLVM IR 中明确所有控制流，包括
<code>fall through</code>。如果我们没有遵循这个规则，后续的验证器会报错。</p>
<p>这里的最后一行非常微妙，但也非常重要。这里的问题在于，当我们在
<code>merge</code> 基本块中创建 phi 节点时，我们需要设置 phi
要处理的块/值对。然而，phi
节点希望控制流图中每个基本块都有一个入口。那么，我们为什么要执行
<code>ThenBB</code> 之前的 5 行代码呢？问题是 <code>Then</code>
表达式本身可能实际上改变了 <code>Builder</code>
生成的基本块，比如，它包含了一个嵌套的 <code>if/then/else</code>
表达式。因为递归调用 <code>codegen()</code>
可以任意修改当前基本块，所以我们需要获取将设置 phi
节点的代码的最新值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Emit else block.</span></span><br><span class="line">TheFunction-&gt;<span class="built_in">getBasicBlockList</span>().<span class="built_in">push_back</span>(ElseBB);</span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(ElseBB);</span><br><span class="line"></span><br><span class="line">Value *ElseV = Else-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"><span class="keyword">if</span> (!ElseV)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Builder-&gt;<span class="built_in">CreateBr</span>(MergeBB);</span><br><span class="line"><span class="comment">// Codegen of &#x27;Else&#x27; can change the current block, update ElseBB for the PHI.</span></span><br><span class="line">ElseBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-17.png?x-oss-process=image/resize,w_800" /></p>
<p><code>else</code> 基本块的代码生成与 <code>then</code>
基本块的代码生成基本相同。唯一的区别在于第一行，它将 <code>else</code>
基本块添加到了函数中。至此，<code>then</code> 基本块和 <code>else</code>
基本块都已创建完成，接下来我们可以进行合并。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Emit merge block.</span></span><br><span class="line">  TheFunction-&gt;<span class="built_in">getBasicBlockList</span>().<span class="built_in">push_back</span>(MergeBB);</span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(MergeBB);</span><br><span class="line">  PHINode *PN = Builder-&gt;<span class="built_in">CreatePHI</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), <span class="number">2</span>, <span class="string">&quot;iftmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  PN-&gt;<span class="built_in">addIncoming</span>(ThenV, ThenBB);</span><br><span class="line">  PN-&gt;<span class="built_in">addIncoming</span>(ElseV, ElseBB);</span><br><span class="line">  <span class="keyword">return</span> PN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-18.png?x-oss-process=image/resize,w_800" /></p>
<p>这里的前两行代码我们很熟悉：</p>
<ul>
<li>第一行将 <code>merge</code> 基本块添加到 <code>Funciton</code>
对象</li>
<li>第二行修改插入点，以便新创建的代码将进入 <code>merge</code>
基本块</li>
</ul>
<p>然后，我们创建 phi 节点，并为它设置块/值对。</p>
<p>最后，<code>codegen</code> 方法将 phi 节点作为
<code>if/then/else</code>
表达式的值进行返回。在上述例子中，该返回值将输入到顶级函数的代码中，该函数将创建返回指令。</p>
<h1 id="for-循环">for 循环</h1>
<p>通过上面的实践，我们了解了如何为编程语言扩展控制流结构。接下来，我们来继续为
Kaleidoscope 支持 <code>for</code> 循环，如下所示。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern putchard(char);</span><br><span class="line">def printstar(n)</span><br><span class="line">  for i = 1, i &lt; n, 1.0 in</span><br><span class="line">    putchard(42);  # ascii 42 = &#x27;*&#x27;</span><br><span class="line"></span><br><span class="line"># print 100 &#x27;*&#x27; characters</span><br><span class="line">printstar(100);</span><br></pre></td></tr></table></figure></p>
<p><code>for</code>
语句定义了一个新的变量，变量从起始值开始迭代，当条件为真时，使用步长值进行递增。如果省略步长值，则默认为
1.0。当条件为真时，执行内部的表达式。</p>
<p>下面，我们来看一下如何进行扩展。</p>
<h2 id="词法分析器扩展-1">词法分析器扩展</h2>
<p>与 <code>if/then/else</code> 扩展类似，对于 <code>for</code>
语句，我们为词法分析器新增了两个 token 类型和 token 值，如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... in <span class="keyword">enum</span> <span class="title class_">Token</span> ...</span><br><span class="line"><span class="comment">// control</span></span><br><span class="line">tok_if = <span class="number">-6</span>, tok_then = <span class="number">-7</span>, tok_else = <span class="number">-8</span>,</span><br><span class="line">tok_for = <span class="number">-9</span>, tok_in = <span class="number">-10</span></span><br><span class="line"></span><br><span class="line">... in gettok ...</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_def;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_extern;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;if&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_if;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;then&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_then;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;else&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_else;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;for&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_for;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_in;</span><br><span class="line"><span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure></p>
<h2 id="ast-扩展-1">AST 扩展</h2>
<p>为了表示 <code>for</code> 语句，我们定义一个表达式子类的 AST 节点类型
<code>ForExprAST</code>。<code>ForExprAST</code> 包含四个指针，分别指向
<code>Start</code>，<code>End</code>，<code>Step</code>，<code>Body</code>
子表达式，此外还包含一个变量 <code>VarName</code>。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ForExprAST - Expression class for for/in.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  std::string VarName;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ForExprAST</span>(<span class="type">const</span> std::string &amp;VarName, </span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Start,</span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; End, </span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Step,</span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Body)</span><br><span class="line">    : <span class="built_in">VarName</span>(VarName), <span class="built_in">Start</span>(std::<span class="built_in">move</span>(Start)), <span class="built_in">End</span>(std::<span class="built_in">move</span>(End)),</span><br><span class="line">      <span class="built_in">Step</span>(std::<span class="built_in">move</span>(Step)), <span class="built_in">Body</span>(std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-19.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="解析器扩展-1">解析器扩展</h2>
<p>如下所示为 <code>for</code> 表达式的解析函数。<code>for</code>
表达式支持可选的步长值，对此，解析函数通过检查是否存在第二个逗号来进行处理步长值。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// forexpr ::= &#x27;for&#x27; identifier &#x27;=&#x27; expr &#x27;,&#x27; expr (&#x27;,&#x27; expr)? &#x27;in&#x27; expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseForExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat the for.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected identifier after for&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::string IdName = IdentifierStr;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;=&#x27; after for&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;=&#x27;.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Start = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Start)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;,&#x27; after for start value&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> End = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!End)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The step value is optional.</span></span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Step;</span><br><span class="line">  <span class="keyword">if</span> (CurTok == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    Step = <span class="built_in">ParseExpression</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Step)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;in&#x27; after for&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;in&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ForExprAST&gt;(IdName, std::<span class="built_in">move</span>(Start),</span><br><span class="line">                                       std::<span class="built_in">move</span>(End), std::<span class="built_in">move</span>(Step),</span><br><span class="line">                                       std::<span class="built_in">move</span>(Body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与 <code>if/then/else</code> 相同，我们也把 <code>ParseForExpr</code>
解析函数方法插入到主表达式的解析函数 <code>ParsePrimary</code> 中。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_for:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseForExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="llvm-ir-1">LLVM IR</h2>
<p>下面，我们来为 <code>for</code> 表达式生成 LLVM
IR。我们将上面的例子进行转换成得到如下所示的 LLVM IR 代码。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">declare <span class="type">double</span> @<span class="built_in">putchard</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">define <span class="type">double</span> @<span class="built_in">printstar</span>(<span class="type">double</span> %n) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; initial value = <span class="number">1.0</span> (inlined into phi)</span><br><span class="line">  br label %loop</span><br><span class="line"></span><br><span class="line">loop:       ; preds = %loop, %entry</span><br><span class="line">  %i = phi <span class="type">double</span> [ <span class="number">1.000000e+00</span>, %entry ], [ %nextvar, %loop ]</span><br><span class="line">  ; body</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">putchard</span>(<span class="type">double</span> <span class="number">4.200000e+01</span>)</span><br><span class="line">  ; increment</span><br><span class="line">  %nextvar = fadd <span class="type">double</span> %i, <span class="number">1.000000e+00</span></span><br><span class="line"></span><br><span class="line">  ; termination test</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %i, %n</span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %loopcond = fcmp one <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %loopcond, label %loop, label %afterloop</span><br><span class="line"></span><br><span class="line">afterloop:      ; preds = %loop</span><br><span class="line">  ; loop always returns <span class="number">0.0</span></span><br><span class="line">  ret <span class="type">double</span> <span class="number">0.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中，LLVM IR 包含了与 <code>if/then/else</code>
中相同的结构：一个 phi
节点、几个表达式和一些基本块。下面，让我们看看它们是如何组合在一起的。</p>
<h2 id="代码生成-1">代码生成</h2>
<p><code>codegen</code> 的第一部分非常简单，为 <code>Start</code>
表达式生成代码，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">ForExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Emit the start code first, without &#x27;variable&#x27; in scope.</span></span><br><span class="line">  Value *StartVal = Start-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!StartVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>随后，我们为循环体的开始设置 LLVM
基本块。在上面的例子中，整个循环体是一个基本块，而循环体代码本身可以由多个基本块组成（例如，如果它包含嵌套的
<code>if/then/else</code> 或 <code>for/in</code> 表达式）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make the new basic block for the loop header, inserting after current</span></span><br><span class="line"><span class="comment">// block.</span></span><br><span class="line">Function *TheFunction = Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">BasicBlock *PreheaderBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br><span class="line">BasicBlock *LoopBB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;loop&quot;</span>, TheFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert an explicit fall through from the current block to the LoopBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">CreateBr</span>(LoopBB);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-20.png?x-oss-process=image/resize,w_800" /></p>
<p>第二部分的代码与 <code>if/then/else</code> 非常相似。由于我们需要创建
phi
节点，因此要记住会进入循环的基本块。当我们获取到此基本块后，我们创建一个实际启动循环的基本块
<code>PreheaderBB</code> ，并为两个基本块创建一个无条件分支。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start insertion in LoopBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(LoopBB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the PHI node with an entry for Start.</span></span><br><span class="line">PHINode *Variable = Builder-&gt;<span class="built_in">CreatePHI</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), <span class="number">2</span>, VarName);</span><br><span class="line">Variable-&gt;<span class="built_in">addIncoming</span>(StartVal, PreheaderBB);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-21.png?x-oss-process=image/resize,w_800" /></p>
<p>至此，我们已经设置了循环的 <code>PreheaderBB</code>
基本块，我们开始为循环体生成代码。首先，我们移动插入点，并为循环归纳变量创建
phi 节点。由于我们已经知道起始值的传入值，我们将其加入至 phi
节点。注意，phi
节点最会获得第二个值作为另一个边界，但是，目前我们还无法进行设置，因为它不存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Within the loop, the variable is defined equal to the PHI node.  If it</span></span><br><span class="line"><span class="comment">// shadows an existing variable, we have to restore it, so save it now.</span></span><br><span class="line">Value *OldVal = NamedValues[VarName];</span><br><span class="line">NamedValues[VarName] = Variable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Emit the body of the loop.  This, like any other expr, can change the</span></span><br><span class="line"><span class="comment">// current BB.  Note that we ignore the value computed by the body, but don&#x27;t</span></span><br><span class="line"><span class="comment">// allow an error.</span></span><br><span class="line"><span class="keyword">if</span> (!Body-&gt;<span class="built_in">codegen</span>())</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-22.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，<code>for</code> 将会向符号表中引入循环变量
<code>VarName</code>，从而使得符号表能够包含函数参数、循环变量等。为此，我们在为循环体生成代码之前，必须要将循环变量加入符号表，并存储其当前的值。注意，在外层作用域中有可能存在同名的变量
<code>VarName</code>，这里将符号表中的外部同名变量的值暂存至
<code>OldVal</code> 局部变量中，当代码生成完毕后，再进行恢复。</p>
<p>当循环变量存入符号表后，我们为循环体生成代码。这允许循环体使用循环变量：任何对于循环变量的引用都会通过符号表进行查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Emit the step value.</span></span><br><span class="line">Value *StepVal = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (Step) &#123;</span><br><span class="line">  StepVal = Step-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!StepVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// If not specified, use 1.0.</span></span><br><span class="line">  StepVal = ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *NextVar = Builder-&gt;<span class="built_in">CreateFAdd</span>(Variable, StepVal, <span class="string">&quot;nextvar&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-23.png?x-oss-process=image/resize,w_800" /></p>
<p>至此，循环体代码生成完毕，我们将通过增加步长值（如果没有则为
1.0）来计算迭代变量的下一个值。<code>NextVar</code>
将是循环的下一次迭代时循环变量的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compute the end condition.</span></span><br><span class="line">Value *EndCond = End-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"><span class="keyword">if</span> (!EndCond)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">EndCond = Builder-&gt;<span class="built_in">CreateFCmpONE</span>(</span><br><span class="line">    EndCond, ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">0.0</span>)), <span class="string">&quot;loopcond&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-24.png?x-oss-process=image/resize,w_800" /></p>
<p>最后，我们计算循环的退出值，从而决定循环是否退出。这与
<code>if/then/else</code> 语句的条件判断类似。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the &quot;after loop&quot; block and insert it.</span></span><br><span class="line">BasicBlock *LoopEndBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br><span class="line">BasicBlock *AfterBB =</span><br><span class="line">    BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;afterloop&quot;</span>, TheFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert the conditional branch into the end of LoopEndBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">CreateCondBr</span>(EndCond, LoopBB, AfterBB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any new code will be inserted in AfterBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(AfterBB);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-25.png?x-oss-process=image/resize,w_800" /></p>
<p>当循环体代码生成完成，我们只需要处理结束后的控制流。这里，首先创建一个基本块用于循环退出（<code>afterloop</code>）。基于退出条件的值，创建一个条件分支用于选择再次执行循环或退出循环。后续的代码则位于
<code>afterloop</code> 基本块中，因此设置了对应的插入点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Add a new entry to the PHI node for the backedge.</span></span><br><span class="line">  Variable-&gt;<span class="built_in">addIncoming</span>(NextVar, LoopEndBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the unshadowed variable.</span></span><br><span class="line">  <span class="keyword">if</span> (OldVal)</span><br><span class="line">    NamedValues[VarName] = OldVal;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    NamedValues.<span class="built_in">erase</span>(VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for expr always returns 0.0.</span></span><br><span class="line">  <span class="keyword">return</span> Constant::<span class="built_in">getNullValue</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-26.png?x-oss-process=image/resize,w_800" /></p>
<p>最后一部分代码则进行了各种清理操作。至此，我们有了
<code>NextVar</code> 的值，因此我们可以将传入的值加入到 phi
节点中。之后，我们将循环变量从符号表中删除，使得其不属于循环以外的作用域。最后，循环的代码生成会返回
<code>0.0</code>，即 <code>ForExprAST::codegen()</code> 的返回值。</p>
<h1 id="总结">总结</h1>
<p>至此，我们为 Kaleidoscope 实现了控制流能力，包括
<code>if/then/else</code> 和 <code>for/in</code>
两种结构。我们通过实现这两种控制流，并介绍了 LLVM IR 相关的概念，如：φ
函数。下一章，我们将进一步对 Kaleidoscope
进行扩展，支持自定义运算符的能力。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.html">Kaleidoscope:
Extending the Language: Control Flow</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static
Single Assignment</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>JIT</tag>
        <tag>Optimizer</tag>
        <tag>LLVM Pass</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(6)——语言扩展：自定义运算符</title>
    <url>/2022/08/28/compiler-for-kaleidoscope-06/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>目前为止，Kaleidoscope
已经是一门功能齐全且有用的编程语言了。但是，它仍然存在一个很大的问题。当前的
Kaleidoscope 缺少很多有用的运算符，比如：取反、比较等。</p>
<span id="more"></span>
<p>本章，我们将为 Kaleidoscope 支持自定义运算符，从而让 Kaleidoscope
具备更强大的编程能力。</p>
<h1 id="目标">目标</h1>
<p>我们希望为 Kaleidoscope 支持的 <strong>运算符重载</strong>（Operator
Overloading）能够比 C++ 等语言更加通用。在 C++
中，我们只能够重新定义已存在的运算符，我们不能以编程方式修改其语法，也不能引入新的运算符、修改运算符优先级等。在本章中，我们将为
Kaleidoscope 支持这种更加强大的能力。</p>
<p>目前为止，我们通过手写的方式实现了一个递归下降的解析器，能够解析目前我们所定义的表达式，包括语法、运算符优先级等。通过运算符优先级解析，我们可以非常简单地引入新的运算符。</p>
<p>本文我们将扩展两种运算符：</p>
<ul>
<li><strong>一元运算符</strong>（Unary Operator）</li>
<li><strong>二元运算符</strong>（Binary Operator）</li>
</ul>
<p>如下所示，为 Kaleidoscope 中自定义一元运算符和二元运算符的示例。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Logical unary <span class="keyword">not</span>.</span><br><span class="line">def unary!(v)</span><br><span class="line">  <span class="keyword">if</span> v then</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Define &gt; with the same precedence as &lt;.</span><br><span class="line">def binary&gt; <span class="number">10</span> (LHS RHS)</span><br><span class="line">  RHS &lt; LHS;</span><br><span class="line"></span><br><span class="line"># Binary <span class="string">&quot;logical or&quot;</span>, (note that it does <span class="keyword">not</span> <span class="string">&quot;short circuit&quot;</span>)</span><br><span class="line">def binary| <span class="number">5</span> (LHS RHS)</span><br><span class="line">  <span class="keyword">if</span> LHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> RHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># Define = with slightly lower precedence than relationals.</span><br><span class="line">def binary= <span class="number">9</span> (LHS RHS)</span><br><span class="line">  !(LHS &lt; RHS | LHS &gt; RHS);</span><br></pre></td></tr></table></figure>
很多语言希望能够在语言本身中实现其标准运行时库。在本章中，我们会在
Kaleidoscope 中将自定义运算符在其标准库中实现。</p>
<h1 id="词法分析器扩展">词法分析器扩展</h1>
<p>无论是一元运算符还是二元运算符，对于词法分析器而言，两者只不过是关键词不同，分别是：<code>unary</code>
和 <code>binary</code>。因此，我们为 <code>unary</code> 和
<code>binary</code> 分别定义对应的 token 类型和 token 值，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// operators</span></span><br><span class="line">  tok_binary = <span class="number">-11</span>,</span><br><span class="line">  tok_unary = <span class="number">-12</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;for&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_for;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;binary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;unary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure>
<h1 id="运算符的定义解析">运算符的定义解析</h1>
<p>从上述的目标可以看出，一元运算符和二元运算符均使用函数的方式进行定义。与普通函数定义不同的是，一元运算符和二元运算符的函数原型略有不同。因此，我们需要对
<code>PrototypeAST</code> 进行修改，从而支持解析两种类型的运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,</span></span><br><span class="line"><span class="comment">/// which captures its argument names as well as if it is an operator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrototypeAST</span> &#123;</span><br><span class="line">  std::string Name;</span><br><span class="line">  std::vector&lt;std::string&gt; Args;</span><br><span class="line">  <span class="type">bool</span> IsOperator;</span><br><span class="line">  <span class="type">unsigned</span> Precedence;  <span class="comment">// Precedence if a binary op.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrototypeAST</span>(<span class="type">const</span> std::string &amp;name, std::vector&lt;std::string&gt; Args,</span><br><span class="line">               <span class="type">bool</span> IsOperator = <span class="literal">false</span>, <span class="type">unsigned</span> Prec = <span class="number">0</span>)</span><br><span class="line">  : <span class="built_in">Name</span>(name), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)), <span class="built_in">IsOperator</span>(IsOperator),</span><br><span class="line">    <span class="built_in">Precedence</span>(Prec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string &amp;<span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isUnaryOp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.<span class="built_in">size</span>() == <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isBinaryOp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.<span class="built_in">size</span>() == <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">getOperatorName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isUnaryOp</span>() || <span class="built_in">isBinaryOp</span>());</span><br><span class="line">    <span class="keyword">return</span> Name[Name.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="title">getBinaryPrecedence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Precedence; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-27.png?x-oss-process=image/resize,w_800" /></p>
<p>我们在原始的 <code>PrototypeAST</code>
定义的基础上，新增两个属性用于表示普通的函数原型和自定义运算符。</p>
<ul>
<li><code>IsOperator</code> 表示是否是运算符。</li>
<li><code>Precedence</code>
表示运算符的优先级。优先级仅用于二元运算符。</li>
</ul>
<p>通过修改
<code>PrototypeAST</code>，使其支持识别一元运算符和二元运算符的定义后，我们来进一步实现具体的解析逻辑，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id &#x27;(&#x27; id* &#x27;)&#x27;</span></span><br><span class="line"><span class="comment">///   ::= binary LETTER number? (id, id)</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParsePrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string FnName;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> Kind = <span class="number">0</span>;  <span class="comment">// 0 = identifier, 1 = unary, 2 = binary.</span></span><br><span class="line">  <span class="type">unsigned</span> BinaryPrecedence = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected function name in prototype&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    FnName = IdentifierStr;</span><br><span class="line">    Kind = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> tok_unary:</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected unary operator&quot;</span>);</span><br><span class="line">    FnName = <span class="string">&quot;unary&quot;</span>;</span><br><span class="line">    FnName += (<span class="type">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_binary:</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected binary operator&quot;</span>);</span><br><span class="line">    FnName = <span class="string">&quot;binary&quot;</span>;</span><br><span class="line">    FnName += (<span class="type">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the precedence if present.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok == tok_number) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NumVal &lt; <span class="number">1</span> || NumVal &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Invalid precedence: must be 1..100&quot;</span>);</span><br><span class="line">      BinaryPrecedence = (<span class="type">unsigned</span>)NumVal;</span><br><span class="line">      <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getNextToken</span>() == tok_identifier)</span><br><span class="line">    ArgNames.<span class="built_in">push_back</span>(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;)&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify right number of names for operator.</span></span><br><span class="line">  <span class="keyword">if</span> (Kind &amp;&amp; ArgNames.<span class="built_in">size</span>() != Kind)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Invalid number of operands for operator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;PrototypeAST&gt;(FnName, std::<span class="built_in">move</span>(ArgNames), Kind != <span class="number">0</span>,</span><br><span class="line">                                         BinaryPrecedence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ParsePrototype</code> 的解析逻辑中，我们通过解析运算符得到
<code>FnName</code> 变量，将其作为自定义运算符的构建名称，比如：为
<code>@</code> 操作符构建 <code>binary@</code> 的名称。由于 LLVM
符号表中的符号允许包含任何字符，所以我们可以将构建名称（如：<code>binary@</code>）存入符号表。</p>
<p>这里，一元运算符和二元运算符的定义的解析逻辑非常相似，唯一的区别在于，二元运算符需要额外解析运算符优先级。</p>
<h1 id="运算符的表达式解析">运算符的表达式解析</h1>
<p>上一节，我们介绍了如何解析运算符定义。本节，我们来介绍如何解析运算符表达式。</p>
<p>在第 2 章中，我们已经介绍了 Kaleidoscope 中定义的三种类型的 AST
结构，分别是：<strong>表达式</strong>、<strong>原型</strong>、<strong>函数</strong>。其中，我们已经定义了一种表达式子类型
<code>BinaryExprAST</code>，用于表示二元运算符表达式。因此，我们只需要额外定义一种新的表达式子类型
<code>UnaryExprAST</code> 表示一元运算符表达式即可。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-28.png?x-oss-process=image/resize,w_800" /></p>
<p><code>UnaryExprAST</code>
的具体定义如下所示。其中，<code>Opcode</code>
表示运算符符号，<code>Operand</code> 表示运算符所作用的操作数。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// UnaryExprAST - Expression class for a unary operator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnaryExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="type">char</span> Opcode;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UnaryExprAST</span>(<span class="type">char</span> Opcode, std::unique_ptr&lt;ExprAST&gt; Operand)</span><br><span class="line">    : <span class="built_in">Opcode</span>(Opcode), <span class="built_in">Operand</span>(std::<span class="built_in">move</span>(Operand)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们来分别看有一下二元运算符和一元运算符的代码生成实现逻辑。</p>
<h2 id="二元表达式代码生成">二元表达式代码生成</h2>
<p>如下所示，为二元表达式实现代码生成的逻辑。我们仅仅是在原有的代码生成逻辑中进行了扩展。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *L = LHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  Value *R = RHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFAdd</span>(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFSub</span>(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFMul</span>(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    L = Builder.<span class="built_in">CreateFCmpULT</span>(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateUIToFP</span>(L, Type::<span class="built_in">getDoubleTy</span>(TheContext),</span><br><span class="line">                                <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it wasn&#x27;t a builtin binary operator, it must be a user defined one. Emit</span></span><br><span class="line">  <span class="comment">// a call to it.</span></span><br><span class="line">  Function *F = <span class="built_in">getFunction</span>(std::<span class="built_in">string</span>(<span class="string">&quot;binary&quot;</span>) + Op);</span><br><span class="line">  <span class="built_in">assert</span>(F &amp;&amp; <span class="string">&quot;binary operator not found!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Value *Ops[<span class="number">2</span>] = &#123; L, R &#125;;</span><br><span class="line">  <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(F, Ops, <span class="string">&quot;binop&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在解析二元表达式时，我们需要处理两种情况：</p>
<ul>
<li>处理
<strong>默认运算符</strong>，比如：<code>+</code>、<code>-</code>、<code>*</code>、<code>&lt;</code>
等。我们只需要调用 <code>Builder</code> 生成对应的 LLVM IR 即可。</li>
<li>处理
<strong>自定义运算符</strong>，比如：<code>@</code>、<code>|</code>
等。我们只需要在符号表中查找对应的运算符，并生成对函数（如：<code>binary@</code>）的调用，从而生成
LLVM
IR。由于自定义运算符只是作为普通函数构建的，所以不存在额外的特殊逻辑。</li>
</ul>
<h2 id="一元表达式代码生成">一元表达式代码生成</h2>
<p>如下所示，为一元表达式实现代码生成的逻辑。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">UnaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *OperandV = Operand-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!OperandV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Function *F = <span class="built_in">getFunction</span>(std::<span class="built_in">string</span>(<span class="string">&quot;unary&quot;</span>) + Opcode);</span><br><span class="line">  <span class="keyword">if</span> (!F)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown unary operator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(F, OperandV, <span class="string">&quot;unop&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其生成逻辑非常简单，通过在符号表中查找对应的运算符，并生成对函数（如：<code>binary!</code>）的调用，从而生成
LLVM IR。</p>
<h2 id="通用表达式解析优化">通用表达式解析优化</h2>
<p>由于现在我们新增了一种表达式类型
<code>UnaryExprAST</code>，因此，我们需要对原始的通用表达式解析函数进行优化，以支持解析一元表达式。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= unary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = <span class="built_in">ParseUnary</span>();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ParseBinOpRHS</span>(<span class="number">0</span>, std::<span class="built_in">move</span>(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>ParseExpression</code> 的实现逻辑非常简单，使用
<code>ParseUnary</code>
解析左操作数。然后继续解析结果，再解析右操作数。</p>
<p>由于表达式的右部可能也包含一元表达还是，因此，我们还需要修改
<code>ParseBinOpRHS</code>，支持解析一元运算符，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= (&#x27;+&#x27; unary)*</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseBinOpRHS</span><span class="params">(<span class="type">int</span> ExprPrec,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              std::unique_ptr&lt;ExprAST&gt; LHS)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// Parse the unary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = <span class="built_in">ParseUnary</span>();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的修改最终都会调用 <code>ParseUnary</code>
解析函数，其具体实现如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// unary</span></span><br><span class="line"><span class="comment">///   ::= primary</span></span><br><span class="line"><span class="comment">///   ::= &#x27;!&#x27; unary</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseUnary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If the current token is not an operator, it must be a primary expr.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok) || CurTok == <span class="string">&#x27;(&#x27;</span> || CurTok == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParsePrimary</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a unary operator, read it.</span></span><br><span class="line">  <span class="type">int</span> Opc = CurTok;</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Operand = <span class="built_in">ParseUnary</span>())</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;UnaryExprAST&gt;(Opc, std::<span class="built_in">move</span>(Operand));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>ParseUnary</code>
解析函数的实现非常简单。当我们在解析主表达式时遇到一元运算符时，我们会将运算符符作为前缀，并将剩余部分作为另一个一元运算符进行解析。这样使得我们能够处理多个一元运算符串联的场景，比如：
<code>!!x</code>。注意，一元运算符不能像二元运算符那样具有二义性的解析，因此不需要设置优先级。</p>
<h2 id="运算符函数调用">运算符函数调用</h2>
<p>无论是一元运算符还是二元运算符，最终的实现逻辑均由函数体实现。因此，我们需要通过扩展
<code>FunctionAST</code> 的解析函数
<code>codegen()</code>，从而生成对应的 LLVM IR，具体如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">  Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">    BinopPrecedence[P.<span class="built_in">getOperatorName</span>()] = P.<span class="built_in">getBinaryPrecedence</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (P.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">    BinopPrecedence.<span class="built_in">erase</span>(P.<span class="built_in">getOperatorName</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p>
<p>其主要是在为 <code>FunctionAST</code>
生成代码时，判断是否是自定义运算符的函数定义，如果是，则设置运算符优先级，并在代码生成后移除对应的运算符优先级。通过这种方式，我们可以同时实现一元运算符和二元运算符的底层代码生成逻辑。</p>
<h1 id="测试">测试</h1>
<p>通过以上简单的扩展，我们开发出了一门真正的语言。基于
Kaleidoscope，我们可以做很多有趣的事情，包括：I/O、数学运算等。比如，我们添加一个串联操作符，如下所示。注意：<code>printd</code>
用于打印指定值或换行符。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">printd</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">printd</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; def binary : <span class="number">1</span> (x y) <span class="number">0</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="string">&quot;binary:&quot;</span>(<span class="type">double</span> %x, <span class="type">double</span> %y) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret <span class="type">double</span> <span class="number">0.000000e+00</span></span><br><span class="line">&#125;</span><br><span class="line">ready&gt; <span class="built_in">printd</span>(<span class="number">123</span>) : <span class="built_in">printd</span>(<span class="number">456</span>) : <span class="built_in">printd</span>(<span class="number">789</span>);</span><br><span class="line"><span class="number">123.000000</span></span><br><span class="line"><span class="number">456.000000</span></span><br><span class="line"><span class="number">789.000000</span></span><br><span class="line">Evaluated to <span class="number">0.000000</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以定义一系列的原始操作符，如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Logical unary <span class="keyword">not</span>.</span><br><span class="line">def unary!(v)</span><br><span class="line">  <span class="keyword">if</span> v then</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Unary negate.</span><br><span class="line">def unary-(v)</span><br><span class="line">  <span class="number">0</span>-v;</span><br><span class="line"></span><br><span class="line"># Define &gt; with the same precedence as &lt;.</span><br><span class="line">def binary&gt; <span class="number">10</span> (LHS RHS)</span><br><span class="line">  RHS &lt; LHS;</span><br><span class="line"></span><br><span class="line"># Binary logical <span class="keyword">or</span>, which does <span class="keyword">not</span> <span class="type">short</span> circuit.</span><br><span class="line">def binary| <span class="number">5</span> (LHS RHS)</span><br><span class="line">  <span class="keyword">if</span> LHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> RHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># Binary logical <span class="keyword">and</span>, which does <span class="keyword">not</span> <span class="type">short</span> circuit.</span><br><span class="line">def binary&amp; <span class="number">6</span> (LHS RHS)</span><br><span class="line">  <span class="keyword">if</span> !LHS then</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    !!RHS;</span><br><span class="line"></span><br><span class="line"># Define = with slightly lower precedence than relationals.</span><br><span class="line">def binary = <span class="number">9</span> (LHS RHS)</span><br><span class="line">  !(LHS &lt; RHS | LHS &gt; RHS);</span><br><span class="line"></span><br><span class="line"># Define <span class="string">&#x27;:&#x27;</span> <span class="keyword">for</span> sequencing: as a low-precedence <span class="keyword">operator</span> that ignores operands</span><br><span class="line"><span class="meta"># and just returns the RHS.</span></span><br><span class="line">def binary : <span class="number">1</span> (x y) y;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>至此，Kaleidoscope 开始成为一种真实而强大的语言。</p>
<p>通过本章，我们增强了 Kaleidoscope
语言，在库中添加了扩展语言的能力。此时，Kaleidoscope
可以构建各种功能性的应用程序，并且可以调用具有副作用的函数，但它实际上不能定义和改变变量本身。</p>
<p>然而，变量更新是大多数编程语言的一个重要特性。下一章，我们将描述如何在不在前端构建
SSA 的情况下支持变量更新。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html">Kaleidoscope:
Extending the Language: User-defined Operators</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(7)——语言扩展：可变变量</title>
    <url>/2022/09/04/compiler-for-kaleidoscope-07/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>通过第 1 章至第 6
章，我们实现了一门简单的函数式编程语言。在这个过程中，我们学习了解析器相关的技术，如何构建并表示
AST，如何构建 LLVM IR，如何对生成代码进行优化，如何使用 JIT
进行编译等等。</p>
<span id="more"></span>
<p>Kaleidoscope
是一门函数式编程语言，函数式的特点之一是变量不可重复赋值，这使得 LLVM IR
代码生成非常容易。特别是，函数式编程语言能够直接以 SSA 形式构建 LLVM
IR。由于 LLVM 要求输入代码使用 SSA
形式，虽然这是一个非常好的特性，但是会让新手不知道如何为命令式编程语言中的可变变量生成代码。</p>
<h1 id="可变变量的实现难点">可变变量的实现难点</h1>
<p>那么，为什么可变变量难以构建 SSA
呢？下面，我们先来看一个例子，如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> G, H;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(_Bool Condition)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> X;</span><br><span class="line">  <span class="keyword">if</span> (Condition)</span><br><span class="line">    X = G;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    X = H;</span><br><span class="line">  <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在例子中，我们有一个 <code>X</code>
变量，其值取决于程序的执行路径。由于这里有两个潜在的目标值，我们需要插入一个
phi 节点来合并这两个值。因此，我们希望生成的 LLVM IR 如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@G = weak global i32 <span class="number">0</span>   ; type of @G is i32*</span><br><span class="line">@H = weak global i32 <span class="number">0</span>   ; type of @H is i32*</span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">test</span>(i1 %Condition) &#123;</span><br><span class="line">entry:</span><br><span class="line">  br i1 %Condition, label %cond_true, label %cond_false</span><br><span class="line"></span><br><span class="line">cond_true:</span><br><span class="line">  %X<span class="number">.0</span> = load i32, i32* @G</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_false:</span><br><span class="line">  %X<span class="number">.1</span> = load i32, i32* @H</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_next:</span><br><span class="line">  %X<span class="number">.2</span> = phi i32 [ %X<span class="number">.1</span>, %cond_false ], [ %X<span class="number">.0</span>, %cond_true ]</span><br><span class="line">  ret i32 %X<span class="number">.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在生成的 LLVM IR 通过 <code>load</code>
指令显式地加载全局变量 <code>G</code> 和 <code>H</code>，分别用于
<code>if</code> 语句的 <code>then/else</code> 分支逻辑
<code>cond_true</code> 和 <code>cond_false</code>
基本块。为了将传入值进行合并，<code>cond_next</code> 基本块中的 phi 节点
<code>X.2</code> 根据控制流选择正确值。如果控制流来自
<code>cond_false</code> 基本块，则 <code>X.2</code> 使用
<code>X.1</code> 的值；如果控制流来自 <code>cond_true</code> 基本块，则
<code>X.2</code> 使用 <code>X.0</code> 的值。</p>
<p>这里的问题在于：<strong>当对可变变量进行赋值时，由谁来负责插入 phi
节点</strong>？</p>
<p>事实上，通过编译前端创建并插入 phi
节点是一个非常复杂且低效的操作。相对而言，通过编译前端实现控制流的 phi
节点还算简单。</p>
<h1 id="llvm-内存模型">LLVM 内存模型</h1>
<p>那么，我们该如何实现可变变量呢？事实上，我们可以借助内存模型原理来解决这个问题。</p>
<p>我们知道，LLVM 要求所有的寄存器值必须采用 SSA 形式，但是 LLVM
并不要求内存对象必须采用 SSA 形式。</p>
<p>基于此，我们可以为函数中的每个可变对象创建一个栈变量（它存在于内存中，因为它在栈上）。为了理解这种方法，我们首先介绍一下
LLVM 如何是表示栈变量的。</p>
<p>在 LLVM 中，所有内存访问都是显式的，使用 <code>load</code> /
<code>store</code> 指令，没有（或不需要）<code>address-of</code>
运算符。注意，<code>@G</code> / <code>@H</code> 全局变量的类型实际上是
<code>i32*</code>，即使该变量被定义为 <code>i32</code>。 这意味着
<code>@G</code> 为全局数据区域中的 <code>i32</code>
定义了内存空间，但它的名称实际上是指该内存空间的地址。
<strong>栈变量的工作方式类似，只是它们并不使用全局变量进行声明，而使用
<code>alloca</code> 指令进行声明</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">define i32 @<span class="built_in">example</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %X = alloca i32           ; type of %X is i32*.</span><br><span class="line">  ...</span><br><span class="line">  %tmp = load i32, i32* %X  ; load the stack value %X from the stack.</span><br><span class="line">  %tmp2 = add i32 %tmp, <span class="number">1</span>   ; increment it</span><br><span class="line">  store i32 %tmp2, i32* %X  ; store it back</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>上述代码展示了如何在 LLVM IR 中声明和操作栈变量。使用
<code>alloca</code>
指令分配的栈内存是完全通用的，我们可以将栈槽的地址传递给函数，也可以将其存储在其他变量中。下面，我们通过
<code>alloca</code> 指令来代替使用 phi 节点，具体如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@G = weak global i32 <span class="number">0</span>   ; type of @G is i32*</span><br><span class="line">@H = weak global i32 <span class="number">0</span>   ; type of @H is i32*</span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">test</span>(i1 %Condition) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %X = alloca i32           ; type of %X is i32*.</span><br><span class="line">  br i1 %Condition, label %cond_true, label %cond_false</span><br><span class="line"></span><br><span class="line">cond_true:</span><br><span class="line">  %X<span class="number">.0</span> = load i32, i32* @G</span><br><span class="line">  store i32 %X<span class="number">.0</span>, i32* %X   ; Update X</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_false:</span><br><span class="line">  %X<span class="number">.1</span> = load i32, i32* @H</span><br><span class="line">  store i32 %X<span class="number">.1</span>, i32* %X   ; Update X</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_next:</span><br><span class="line">  %X<span class="number">.2</span> = load i32, i32* %X  ; Read X</span><br><span class="line">  ret i32 %X<span class="number">.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过基于栈变量的方式，我们无需创建 phi
节点也能够处理任意可变变量，具体包含以下几个点。</p>
<ul>
<li><strong>将可变变量转换成栈变量</strong></li>
<li><strong>将读取可变变量转换成加载栈变量</strong></li>
<li><strong>将更新可变变量转换成存储栈变量</strong></li>
<li><strong>将读取可变变量地址转换成读取栈变量地址</strong></li>
</ul>
<p><strong>简而言之，我们通过一个额外的栈变量来存储不同分支所计算得到值，从而避免手动构建
phi 节点。</strong></p>
<p>虽然基于栈变量的方法解决了我们当前的问题，但是它引入了另一个问题。很显然，这种情况下，对于非常简单和常见的操作，我们也会引入了大量的栈操作，从而引发性能问题。幸运的是，LLVM
优化器有一个名为 <code>mem2reg</code>
的优化通道能够对此进行优化，该优化通道能将类似的栈分配提优化为寄存器，并在适当的时候插入
phi 节点。例如，我们通过执行 <code>mem2reg</code>
Pass，可以得到如下所示的代码。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ llvm-as &lt; example.ll | opt -mem2reg | llvm-dis</span><br><span class="line">@G = weak global i32 <span class="number">0</span></span><br><span class="line">@H = weak global i32 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">test</span>(i1 %Condition) &#123;</span><br><span class="line">entry:</span><br><span class="line">  br i1 %Condition, label %cond_true, label %cond_false</span><br><span class="line"></span><br><span class="line">cond_true:</span><br><span class="line">  %X<span class="number">.0</span> = load i32, i32* @G</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_false:</span><br><span class="line">  %X<span class="number">.1</span> = load i32, i32* @H</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_next:</span><br><span class="line">  %X<span class="number">.01</span> = phi i32 [ %X<span class="number">.1</span>, %cond_false ], [ %X<span class="number">.0</span>, %cond_true ]</span><br><span class="line">  ret i32 %X<span class="number">.01</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/kaleidoscope-29.png?x-oss-process=image/resize,w_800" /></p>
<p><code>mem2reg</code> Pass 实现了用于构造 SSA 的标准
<strong>迭代支配边界</strong>（Iterated Dominance
Frontier）算法，并包含大量优化手段。<code>mem2reg</code>
优化通道可以用来处理可变变量，我们强烈建议使用它。注意，<code>mem2reg</code>
仅在某些情况下适用于可变变量：</p>
<ul>
<li><code>mem2reg</code> 是 <code>alloca</code> 驱动的，其查找
<code>alloca</code>
指令，如果可以处理，则对它们进行优化。它不适用于全局变量或堆分配。</li>
<li><code>mem2reg</code> 仅在函数的入口块中查找 <code>alloca</code>
指令。在入口块即保证了 <code>alloca</code>
只会执行一次，这样能够使分析更加简单。</li>
<li><code>mem2reg</code> 只优化用于直接加载和存储的 <code>alloca</code>
指令。如果将栈对象的地址传递给函数，或者涉及任何指针运算，则不会优化
<code>alloca</code>。</li>
<li><code>mem2reg</code>
仅适用于一等类型的值的分配（例如指针、标量和向量），并且仅当分配的数组大小为
1（或 .ll 文件丢失）时。 <code>mem2reg</code>
不能将结构体或数组优化为寄存器。 注意，LLVM
还有其他更加强大的优化通道，如：<code>sroa</code>
Pass，其能够在很多情况下可以优化结构体、联合体、数组。</li>
</ul>
<p>我们强烈建议使用上述方式来构建 SSA，通过额外的栈变量避免手动构建 phi
节点，然后使用 LLVM 优化通道进行优化，内部自动构建 phi
节点，如：<code>mem2reg</code>
Pass。推荐使用这种方式主要有几个原因：</p>
<ul>
<li>具备良好的验证和测试。经典的 Clang
编译器就采用该方法来处理局部可变变量。</li>
<li>构建速度快。<code>mem2reg</code> 支持在多种场景下进行加速构建。</li>
<li>支持生成调试所需信息。LLVM
中的调试信息依赖于公开变量的地址，基于变量地址才能将调试信息附加至变量中。这种技术与这种调试信息风格非常自然地吻合。</li>
</ul>
<p>这种方式能够让我们的编译前端的启动和运行变得更加容易，并且实现起来非常简单。下面，让我们在
Kaleidoscope 中扩展可变变量！</p>
<h1 id="可变变量">可变变量</h1>
<p>上文，我们介绍了可变变量的实现难点，以及一种基于栈变量的解决方案。接下来，我们来进行实战，为
Kaleidoscope 进行语言扩展，支持可变变量。</p>
<p>为了支持可变变量，我们期望实现两个功能：</p>
<ul>
<li><strong>基于 <code>=</code> 运算符实现已有变量可变</strong></li>
<li><strong>基于 <code>var/in</code>
关键词实现局部变量定义</strong></li>
</ul>
<p>如下所示，是我们期望实现的最终目标。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Define <span class="string">&#x27;:&#x27;</span> <span class="keyword">for</span> sequencing: as a low-precedence <span class="keyword">operator</span> that ignores operands</span><br><span class="line"><span class="meta"># and just returns the RHS.</span></span><br><span class="line">def binary : <span class="number">1</span> (x y) y;</span><br><span class="line"></span><br><span class="line"># Recursive fib, we could <span class="keyword">do</span> <span class="keyword">this</span> before.</span><br><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(x &lt; <span class="number">3</span>)</span> then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"># Iterative fib.</span><br><span class="line"><span class="function">def <span class="title">fibi</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  var a </span>= <span class="number">1</span>, b = <span class="number">1</span>, c <span class="built_in">in</span></span><br><span class="line">  (<span class="keyword">for</span> i = <span class="number">3</span>, i &lt; x in</span><br><span class="line">     c = a + b :</span><br><span class="line">     a = b :</span><br><span class="line">     b = c) :</span><br><span class="line">  b;</span><br><span class="line"></span><br><span class="line"># Call it.</span><br><span class="line"><span class="built_in">fibi</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="已有变量可变">已有变量可变</h1>
<p>首先，我们来实现第一个功能——已有变量可变。</p>
<p>在我们之前的实现中，Kaleidoscope 在代码生成时的符号表是由
<code>NamedValues</code> 负责管理。符号表存储的键值对，键位变量名，值为
LLVM <code>Value*</code>。</p>
<p>为了实现已有变量可变，我们需要修改一下 <code>NamedValues</code>
存储的键值对的类型，使得 <code>NamedValues</code>
能够保存可变变量的内存位置。</p>
<p>目前，Kaleidoscope
只支持两种类型的变量：函数的传入参数、<code>for</code>
循环的归纳变量。为了保持一致性，除了其他用户定义的变量外，我们还允许对这些变量进行更新。
这意味着它们都需要占用内存空间。</p>
<p>对此，我们首先对符号表 <code>NamedValues</code>
进行修改，将键值对中值的类型修改为 <code>AllocaInst*</code>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::map&lt;std::string, AllocaInst*&gt; NamedValues;</span><br></pre></td></tr></table></figure></p>
<p>由于我们需要创建 <code>alloca</code>
指令，我们还需要一个辅助函数来保证 <code>alloca</code>
指令在函数入口块创建。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of</span></span><br><span class="line"><span class="comment">/// the function.  This is used for mutable variables etc.</span></span><br><span class="line"><span class="function"><span class="type">static</span> AllocaInst *<span class="title">CreateEntryBlockAlloca</span><span class="params">(Function *TheFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::string &amp;VarName)</span> </span>&#123;</span><br><span class="line">  IRBuilder&lt;&gt; <span class="built_in">TmpB</span>(&amp;TheFunction-&gt;<span class="built_in">getEntryBlock</span>(),</span><br><span class="line">                 TheFunction-&gt;<span class="built_in">getEntryBlock</span>().<span class="built_in">begin</span>());</span><br><span class="line">  <span class="keyword">return</span> TmpB.<span class="built_in">CreateAlloca</span>(Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="number">0</span>,</span><br><span class="line">                           VarName.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码创建了一个 <code>IRBuilder</code>
对象，它指向入口块的第一条指令（<code>.begin()</code>）。然后创建一个具有指定名称的
<code>alloca</code> 并返回。由于 Kaleidoscope
中的所有值都是双精度类型，所以不需要传入要使用的类型。</p>
<p>接下来，我们分别对变量表达式、<code>for</code>
表达式、函数表达式的代码生成逻辑进行修改，从而支持已有变量可变。</p>
<h2 id="variableexprast-代码生成">VariableExprAST 代码生成</h2>
<p>首先，对于变量，我们需要修改引用方式。基于栈变量的实现中，变量存储于栈中，因此，我们必须通过加载栈槽，从而引用栈变量。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VariableExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  AllocaInst *A = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!A)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the value.</span></span><br><span class="line">  <span class="keyword">return</span> Builder-&gt;<span class="built_in">CreateLoad</span>(A-&gt;<span class="built_in">getAllocatedType</span>(), A, Name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="forexprast-代码生成">ForExprAST 代码生成</h2>
<p><code>VariableExprAST</code>
实现了栈变量的读取逻辑，那么如何实现写入逻辑呢？由于 <code>for</code>
表达式包含了归纳变量，因此，我们首先了修改 <code>ForExprAST</code>
的代码生成逻辑。</p>
<p>如下所示，首先，我们在入口块创建一个栈变量，当设置初始值时，通过
<code>Builder</code> 的 <code>CreateStore()</code>
方法将初始值写入栈变量。当归纳变量迭代时，通过 <code>Builder</code> 的
<code>CreateLoad()</code>
方法读取栈变量，并与步长值相加，然后再写入栈变量。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">ForExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Function *TheFunction = Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an alloca for the variable in the entry block.</span></span><br><span class="line">  AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the start code first, without &#x27;variable&#x27; in scope.</span></span><br><span class="line">  Value *StartVal = Start-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!StartVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the value into the alloca.</span></span><br><span class="line">  Builder-&gt;<span class="built_in">CreateStore</span>(StartVal, Alloca);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Compute the end condition.</span></span><br><span class="line">  Value *EndCond = End-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!EndCond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reload, increment, and restore the alloca.  This handles the case where</span></span><br><span class="line">  <span class="comment">// the body of the loop mutates the variable.</span></span><br><span class="line">  Value *CurVar =</span><br><span class="line">      Builder-&gt;<span class="built_in">CreateLoad</span>(Alloca-&gt;<span class="built_in">getAllocatedType</span>(), Alloca, VarName.<span class="built_in">c_str</span>());</span><br><span class="line">  Value *NextVar = Builder-&gt;<span class="built_in">CreateFAdd</span>(CurVar, StepVal, <span class="string">&quot;nextvar&quot;</span>);</span><br><span class="line">  Builder-&gt;<span class="built_in">CreateStore</span>(NextVar, Alloca);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="functionast-代码生成">FunctionAST 代码生成</h2>
<p>为了让函数的入参支持可变，我们还需要对 <code>FunctionAST</code>
的代码逻辑进行修改。如下所示，我们遍历函数的入参，为每一个参数创建一个栈变量，并存储初始值，同时将入参的变量名写入符号表。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, Arg.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="优化通道">优化通道</h2>
<p>最后，我们向通道管理器注册一部分优化通道，包括
<code>mem2reg</code>，从而能够生成优化后的 LLVM IR。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promote allocas to registers.</span></span><br><span class="line">TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createPromoteMemoryToRegisterPass</span>());</span><br><span class="line"><span class="comment">// Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class="line">TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createInstructionCombiningPass</span>());</span><br><span class="line"><span class="comment">// Reassociate expressions.</span></span><br><span class="line">TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createReassociatePass</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="llvm-ir-对比">LLVM IR 对比</h2>
<p>我们以递归版本的 <code>fib</code> 函数作为测试用例，来对比
<code>mem2reg</code> 优化通道执行前后的 LLVM IR。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(x &lt; <span class="number">3</span>)</span> then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为执行 <code>mem2reg</code> 前生成的 LLVM
IR。其中，只有一个函数入参变量 <code>x</code>。在入口块中，LLVM
创建了一个 <code>alloca</code> 指令，并将初始输入值存入其中。
对变量的每个引用都会从栈中进行加载。由于我们没有修改
<code>if/then/else</code> 表达式，所以在 <code>ifcont</code>
基本块中仍然插入了一个 <code>phi</code> 节点。对于
<code>if/then/else</code> 表达式，其实我们也可以为它创建
<code>alloca</code> 指令，不过，为它构建一个 <code>phi</code>
节点反而会更容易，所以这里我们仍然手动构建 <code>phi</code>。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">define <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %x1 = alloca <span class="type">double</span></span><br><span class="line">  store <span class="type">double</span> %x, <span class="type">double</span>* %x1</span><br><span class="line">  %x2 = load <span class="type">double</span>, <span class="type">double</span>* %x1</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %x2, <span class="number">3.000000e+00</span></span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %ifcond = fcmp one <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:       ; preds = %entry</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:       ; preds = %entry</span><br><span class="line">  %x3 = load <span class="type">double</span>, <span class="type">double</span>* %x1</span><br><span class="line">  %subtmp = fsub <span class="type">double</span> %x3, <span class="number">1.000000e+00</span></span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp)</span><br><span class="line">  %x4 = load <span class="type">double</span>, <span class="type">double</span>* %x1</span><br><span class="line">  %subtmp5 = fsub <span class="type">double</span> %x4, <span class="number">2.000000e+00</span></span><br><span class="line">  %calltmp6 = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp5)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp6</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line">ifcont:     ; preds = %<span class="keyword">else</span>, %then</span><br><span class="line">  %iftmp = phi <span class="type">double</span> [ <span class="number">1.000000e+00</span>, %then ], [ %addtmp, %<span class="keyword">else</span> ]</span><br><span class="line">  ret <span class="type">double</span> %iftmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为执行 <code>mem2reg</code> 后生成的 LLVM
IR。很明显，<code>mem2reg</code> 对大量的 <code>alloc</code> 和
<code>store</code> 指令进行了优化，将它们优化成寄存器操作。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">define <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %x, <span class="number">3.000000e+00</span></span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %ifcond = fcmp one <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  %subtmp = fsub <span class="type">double</span> %x, <span class="number">1.000000e+00</span></span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp)</span><br><span class="line">  %subtmp5 = fsub <span class="type">double</span> %x, <span class="number">2.000000e+00</span></span><br><span class="line">  %calltmp6 = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp5)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp6</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line">ifcont:     ; preds = %<span class="keyword">else</span>, %then</span><br><span class="line">  %iftmp = phi <span class="type">double</span> [ <span class="number">1.000000e+00</span>, %then ], [ %addtmp, %<span class="keyword">else</span> ]</span><br><span class="line">  ret <span class="type">double</span> %iftmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为所有优化通道执行完毕之后的 LLVM IR。很显然，LLVM IR
得到了进一步的优化。其中，<code>simplifycfg</code>
优化通道将返回指令拷贝至 <code>else</code>
基本块的末尾，从而消除部分分支代码和 <code>phi</code> 节点。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">define <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %x, <span class="number">3.000000e+00</span></span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %ifcond = fcmp ueq <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %<span class="keyword">else</span>, label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  %subtmp = fsub <span class="type">double</span> %x, <span class="number">1.000000e+00</span></span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp)</span><br><span class="line">  %subtmp5 = fsub <span class="type">double</span> %x, <span class="number">2.000000e+00</span></span><br><span class="line">  %calltmp6 = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp5)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp6</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line"></span><br><span class="line">ifcont:</span><br><span class="line">  ret <span class="type">double</span> <span class="number">1.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="赋值运算符">赋值运算符</h2>
<p>至此，我们已经将符号表的引用修改为栈变量。接下来，我们来添加赋值运算符
<code>=</code>，从而实现变量可变。</p>
<p>基于当前的框架，添加一个新的赋值运算符非常简单。首先，我们对赋值运算符设置优先级。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;=&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于赋值运算符是一个二元运算符，且赋值运算符已经设置了运算符优先级。因此，我们只需要修改
<code>BinaryExprAST</code>
的代码生成逻辑，使其支持赋值运算符。具体如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special case &#x27;=&#x27; because we don&#x27;t want to emit the LHS as an expression.</span></span><br><span class="line">  <span class="keyword">if</span> (Op == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Assignment requires the LHS to be an identifier.</span></span><br><span class="line">    <span class="comment">// This assume we&#x27;re building without RTTI because LLVM builds that way by</span></span><br><span class="line">    <span class="comment">// default.  If you build LLVM with RTTI this can be changed to a</span></span><br><span class="line">    <span class="comment">// dynamic_cast for automatic error checking.</span></span><br><span class="line">    VariableExprAST *LHSE = <span class="built_in">static_cast</span>&lt;VariableExprAST *&gt;(LHS.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (!LHSE)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;destination of &#x27;=&#x27; must be a variable&quot;</span>);</span><br><span class="line">    <span class="comment">// Codegen the RHS.</span></span><br><span class="line">    Value *Val = RHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Val)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look up the name.</span></span><br><span class="line">    Value *Variable = NamedValues[LHSE-&gt;<span class="built_in">getName</span>()];</span><br><span class="line">    <span class="keyword">if</span> (!Variable)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(Val, Variable);</span><br><span class="line">    <span class="keyword">return</span> Val;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与其他二元运算符不同，赋值运算符不遵循 “<strong>生成 LHS，生成
RHS，再进行计算</strong>”
的模型。因此，对于赋值运算符，我们要对它进行特殊处理。此外，赋值运算符要求
LHS 必须是一个变量，比如：<code>(x+1) = expr</code>
语句是无效的，<code>x = expr</code> 是有效的。</p>
<p>因此，<code>BinaryExprAST::codegen</code> 的解析逻辑中，会先检查 LHS
是否有效。如果有效，则将 LHS 注册至符号表并进一步计算 RHS，最终将 RHS
的结果存入变量。</p>
<h2 id="测试">测试</h2>
<p>至此，我们为 Kaleidoscope
扩展支持了变量可变的能力。下面，我们来进行一个简单的测试。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Function to print a <span class="type">double</span>.</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">printd</span><span class="params">(x)</span></span>;</span><br><span class="line"></span><br><span class="line"># Define <span class="string">&#x27;:&#x27;</span> <span class="keyword">for</span> sequencing: as a low-precedence <span class="keyword">operator</span> that ignores operands</span><br><span class="line"><span class="meta"># and just returns the RHS.</span></span><br><span class="line">def binary : <span class="number">1</span> (x y) y;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="title">printd</span><span class="params">(x)</span> :</span></span><br><span class="line"><span class="function">  x =</span> <span class="number">4</span> :</span><br><span class="line">  <span class="built_in">printd</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure> 当输入测试代码后，程序先打印了
<code>123</code>，然后打印了
<code>4</code>，运行结果证明了变量的值发生了变化！</p>
<h1 id="局部变量定义">局部变量定义</h1>
<p>我们的第二个目标功能是：基于 <code>var/in</code>
关键词实现局部变量定义，使其能够编写如下所示的代码。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibi</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  var a </span>= <span class="number">1</span>, b = <span class="number">1</span>, c <span class="built_in">in</span></span><br><span class="line">  (<span class="keyword">for</span> i = <span class="number">3</span>, i &lt; x in</span><br><span class="line">     c = a + b :</span><br><span class="line">     a = b :</span><br><span class="line">     b = c) :</span><br><span class="line">  b;</span><br></pre></td></tr></table></figure></p>
<p>下面，我们分别对编译器的各个部分进行扩展。</p>
<h2 id="词法分析器扩展">词法分析器扩展</h2>
<p>首先，我们要为 Kaleidoscope 扩展关键词 <code>var</code> 和
<code>in</code>。这里，我们只需要新增 <code>var</code>
关键词即可，<code>in</code> 关键词在 <code>for/in</code>
语句中已经支持了。具体扩展如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// var definition</span></span><br><span class="line">  tok_var = <span class="number">-13</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="built_in">gettok</span>() &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;binary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;unary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;var&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_var;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2 id="ast-扩展">AST 扩展</h2>
<p>为了表示 <code>var/in</code> 语句，我们定义一个表达式子类的 AST
节点类型 <code>VarExprAST</code>，具体如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// VarExprAST - Expression class for var/in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VarExprAST</span>(std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames,</span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Body)</span><br><span class="line">    : <span class="built_in">VarNames</span>(std::<span class="built_in">move</span>(VarNames)), <span class="built_in">Body</span>(std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-30.png?x-oss-process=image/resize,w_800" /></p>
<p>我们扩展的 <code>var/in</code>
允许一次定义一组变量，并且每个变量都可以有一个初始值。因此，我们通过
<code>VarNames</code> 数组来存储多个变量。此外，<code>var/in</code>
支持设置一个表达式体，用于对变量进行初始化。同时，表达式体能够访问
<code>var/in</code> 所定义的变量。</p>
<h2 id="解析器扩展">解析器扩展</h2>
<p>接下来，我们为 <code>var/in</code>
表达式定义解析函数，具体如下所示。在 <code>ParseVarExpr</code>
解析函数中，我们首先对 token 进行遍历，将局部变量存入
<code>VarNames</code> 中。然后解析表达式体，将其存入 <code>Body</code>
中。最后返回表达式的 AST 节点。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseVarExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat the var.</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At least one variable name is required.</span></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected identifier after var&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    std::string Name = IdentifierStr;</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the optional initializer.</span></span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; Init = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (CurTok == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">getNextToken</span>(); <span class="comment">// eat the &#x27;=&#x27;.</span></span><br><span class="line"></span><br><span class="line">      Init = <span class="built_in">ParseExpression</span>();</span><br><span class="line">      <span class="keyword">if</span> (!Init)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VarNames.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(Name, std::<span class="built_in">move</span>(Init)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of var list, exit loop.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// eat the &#x27;,&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected identifier list after var&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point, we have to have &#x27;in&#x27;.</span></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;in&#x27; keyword after &#x27;var&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat &#x27;in&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;VarExprAST&gt;(std::<span class="built_in">move</span>(VarNames), std::<span class="built_in">move</span>(Body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与其他表达式相同，我们也把 <code>ParseForExpr</code>
解析函数方法插入到主表达式的解析函数 <code>ParsePrimary</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="comment">///   ::= ifexpr</span></span><br><span class="line"><span class="comment">///   ::= forexpr</span></span><br><span class="line"><span class="comment">///   ::= varexpr</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_for:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseForExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_var:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseVarExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码生成">代码生成</h2>
<p>下面，我们来为 <code>VarExprAST</code> 实现代码生成的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VarExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;AllocaInst *&gt; OldBindings;</span><br><span class="line"></span><br><span class="line">  Function *TheFunction = Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register all variables and emit their initializer.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, e = VarNames.<span class="built_in">size</span>(); i != e; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> std::string &amp;VarName = VarNames[i].first;</span><br><span class="line">    ExprAST *Init = VarNames[i].second.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the initializer before adding the variable to scope, this prevents</span></span><br><span class="line">    <span class="comment">// the initializer from referencing the variable itself, and permits stuff</span></span><br><span class="line">    <span class="comment">// like this:</span></span><br><span class="line">    <span class="comment">//  var a = 1 in</span></span><br><span class="line">    <span class="comment">//    var a = a in ...   # refers to outer &#x27;a&#x27;.</span></span><br><span class="line">    Value *InitVal;</span><br><span class="line">    <span class="keyword">if</span> (Init) &#123;</span><br><span class="line">      InitVal = Init-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">      <span class="keyword">if</span> (!InitVal)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// If not specified, use 0.0.</span></span><br><span class="line">      InitVal = ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">0.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, VarName);</span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(InitVal, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember the old variable binding so that we can restore the binding when</span></span><br><span class="line">    <span class="comment">// we unrecurse.</span></span><br><span class="line">    OldBindings.<span class="built_in">push_back</span>(NamedValues[VarName]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember this binding.</span></span><br><span class="line">    NamedValues[VarName] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Codegen the body, now that all vars are in scope.</span></span><br><span class="line">  Value *BodyVal = Body-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!BodyVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop all our variables from scope.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, e = VarNames.<span class="built_in">size</span>(); i != e; ++i)</span><br><span class="line">    NamedValues[VarNames[i].first] = OldBindings[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the body computation.</span></span><br><span class="line">  <span class="keyword">return</span> BodyVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>VarExprAST</code> 代码生成的基本逻辑包括以下几部分：</p>
<ul>
<li>遍历所有变量，对于每个变量，将其存入符号表，并使用
<code>OldBindings</code> 保存旧值，因为存在嵌套的同名变量。</li>
<li>对于每个变量，构造对应的 <code>alloca</code>
指令，并更新符号表，使该变量指向生成的 <code>alloca</code> 指令，即
<code>AllocaInst</code>。</li>
<li>当所有变量都保存至符号表后，对 <code>var/in</code>
语句中的表达式体进行代码生成。</li>
<li>在返回之前，通过 <code>OldBindings</code> 恢复旧值。</li>
</ul>
<p>通过这部分的扩展，我们实现了在作用域中定义局部变量的功能。类似的，我们也可以对实现的程序进行测试，输入迭代版本的
<code>fib</code> 函数，查看最终的执行结果以及生成的 LLVM IR。</p>
<h1 id="总结">总结</h1>
<p>通过本章，我们进一步扩展了 Kaleidoscope
语言，实现了可变变量的能力。至此，Kaleidoscope
已经具备了工业级编程语言的基本雏形。下一章，我们来进一步增加
Kaleidoscope 的能力。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">Kaleidoscope:
Extending the Language: Mutable Variables</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>可变变量</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(8)——目标文件编译</title>
    <url>/2022/09/11/compiler-for-kaleidoscope-08/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>本章，我们将使用自制的编译器将 Kaleidoscope
代码编译成目标文件，并结合 C++ 代码进行混编。</p>
<span id="more"></span>
<h1 id="目标选择">目标选择</h1>
<p>LLVM
支持交叉编译，因此可以将源代码编译成任意目标架构的可执行文件。本章，我们将本机架构作为目标架构，编译可执行文件。</p>
<p>那么，如何获取本机架构的信息呢？我们使用一个字符串来表示，也称为
<strong>Target Triple</strong>，其采用
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>
格式来表示目标架构的基本信息。详细信息可见 <a
href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Cross-Compilation
using Clang</a>。</p>
<p>如下所示，我们可以通过 clang 的相关命令获取本机的 target
triple。对于不同的目标架构和操作系统，target triple 的值也不同。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ clang --version | grep Target</span><br><span class="line">Target: x86_64-apple-darwin21.6.0</span><br></pre></td></tr></table></figure></p>
<p>在实际开发中，我们不需要为本机架构硬编码 target triple。LLVM 提供了
<code>sys::getDefaultTargetTriple</code> 以支持动态获取本机的 target
triple。</p>
<!--LLVM 不要求我们链接所有目标功能。比如，如果我们只使用 JIT，我们就不需要汇编打印功能。同样，如果我们只针对某些架构，我们只能链接这些架构的功能。-->
<p>在我们的编译器实现中，首先注册所有平台的目标信息，从而支持用户指定任意目标进行编译，具体如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">InitializeAllTargetInfos</span>();</span><br><span class="line"><span class="built_in">InitializeAllTargets</span>();</span><br><span class="line"><span class="built_in">InitializeAllTargetMCs</span>();</span><br><span class="line"><span class="built_in">InitializeAllAsmParsers</span>();</span><br><span class="line"><span class="built_in">InitializeAllAsmPrinters</span>();</span><br></pre></td></tr></table></figure></p>
<p>当所有平台的目标信息注册完成后，我们获取本机的目标进行，并设置模块的目标为本机目标。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> TargetTriple = sys::<span class="built_in">getDefaultTargetTriple</span>();</span><br><span class="line">TheModule-&gt;<span class="built_in">setTargetTriple</span>(TargetTriple);</span><br></pre></td></tr></table></figure></p>
<p>然后，我们基于本机目标的 target triple 来获取一个
<code>Target</code>，如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string Error;</span><br><span class="line"><span class="keyword">auto</span> Target = TargetRegistry::<span class="built_in">lookupTarget</span>(TargetTriple, Error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print an error and exit if we couldn&#x27;t find the requested target.</span></span><br><span class="line"><span class="comment">// This generally occurs if we&#x27;ve forgotten to initialise the</span></span><br><span class="line"><span class="comment">// TargetRegistry or we have a bogus target triple.</span></span><br><span class="line"><span class="keyword">if</span> (!Target) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; Error;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="目标机器">目标机器</h1>
<p>除了 target triple，我们还需要更加完整的目标机器的信息。对此，LLVM
提供了一个 <code>TargetMachine</code>
的类，用于描述目标机器的完整信息。如果我们希望指定一个特定特性（如：SSE）或特定
CPU（如：Intel 的 Sandylake），我们就可以基于 <code>TargetMachine</code>
进行配置。</p>
<p>为了查看 LLVM 支持的所有的特性和 CPU，我们可以通过 <code>llc</code>
命令进行查看。比如，我们可以查看 x86 相关的信息。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ llc -march=x86 -mattr=<span class="built_in">help</span></span><br><span class="line">Available CPUs <span class="keyword">for</span> this target:</span><br><span class="line"></span><br><span class="line">  alderlake      - Select the alderlake processor.</span><br><span class="line">  amdfam10       - Select the amdfam10 processor.</span><br><span class="line">  athlon         - Select the athlon processor.</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">Available features <span class="keyword">for</span> this target:</span><br><span class="line"></span><br><span class="line">  16bit-mode                      - 16-bit mode (i8086).</span><br><span class="line">  32bit-mode                      - 32-bit mode (80386).</span><br><span class="line">  3dnow                           - Enable 3DNow! instructions.</span><br><span class="line">  3dnowa                          - Enable 3DNow! Athlon instructions.</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>在我们的编译器实现中，我们使用通用的
CPU，并且不包含任何额外的特性、选项或重定位模型，具体的设置如下所示。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> CPU = <span class="string">&quot;generic&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> Features = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">TargetOptions opt;</span><br><span class="line"><span class="keyword">auto</span> RM = <span class="built_in">Optional</span>&lt;Reloc::Model&gt;();</span><br><span class="line"><span class="keyword">auto</span> TheTargetMachine = Target-&gt;<span class="built_in">createTargetMachine</span>(TargetTriple, CPU, Features, opt, RM);</span><br></pre></td></tr></table></figure></p>
<h1 id="模块配置">模块配置</h1>
<p>下面，我们来对模块进行配置，指定目标和数据布局。虽然模块配置不是必须的，但是官方教程推荐进行配置。配置模块，指定目标和数据布局，有利于后续进行优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TheModule-&gt;<span class="built_in">setDataLayout</span>(TargetMachine-&gt;<span class="built_in">createDataLayout</span>());</span><br><span class="line">TheModule-&gt;<span class="built_in">setTargetTriple</span>(TargetTriple);</span><br></pre></td></tr></table></figure>
<h1 id="目标代码生成">目标代码生成</h1>
<p>至此，我们已经完成了代码生成的前期准备和设置。下面，我们来定义输出文件。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> Filename = <span class="string">&quot;output.o&quot;</span>;</span><br><span class="line">std::error_code EC;</span><br><span class="line"><span class="function">raw_fd_ostream <span class="title">dest</span><span class="params">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EC) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Could not open file: &quot;</span> &lt;&lt; EC.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 最后，我们定义了一个通道用于进行代码生成，并最终调用执行。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">legacy::PassManager pass;</span><br><span class="line"><span class="keyword">auto</span> FileType = CGFT_ObjectFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TheTargetMachine-&gt;<span class="built_in">addPassesToEmitFile</span>(pass, dest, <span class="literal">nullptr</span>, FileType)) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;TheTargetMachine can&#x27;t emit a file of this type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pass.<span class="built_in">run</span>(*TheModule);</span><br><span class="line">dest.<span class="built_in">flush</span>();</span><br></pre></td></tr></table></figure></p>
<h1 id="混合编译">混合编译</h1>
<p>下面，我们来编译代码，生成编译器，并进行测试。我们输入基于
Kaleidoscope 编写的 <code>average</code> 函数，并输入 <code>Ctr-D</code>
退出执行。此时编译器编译生成一个 <code>output.o</code> 文件。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./Kaleidoscope-Ch8</span><br><span class="line">ready&gt; def average(x y) (x + y) * 0.5;</span><br><span class="line">^D</span><br><span class="line">Wrote output.o</span><br></pre></td></tr></table></figure></p>
<p>至此，我们生成了一个基于 Kaleidoscope 编写的 <code>average</code>
函数的 <code>output.o</code> 目标文件。接下来，我们使用 C++
编写一个简单的程序 <code>main.cpp</code>，并调用 Kaleidoscope 编写的
<code>average</code> 函数。C++ 程序如下所示。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;average of 3.0 and 4.0: &quot;</span> &lt;&lt; <span class="built_in">average</span>(<span class="number">3.0</span>, <span class="number">4.0</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们编译 <code>main.cpp</code> 文件，链接 <code>output.o</code>
文件，并运行最终的可执行文件。如下所示，最终的可执行文件
<code>main</code> 的执行结果与我们的预期是一致的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ clang++ main.cpp output.o -o main</span><br><span class="line">$ ./main</span><br><span class="line">average of 3.0 and 4.0: 3.5</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本章，我们为本机架构配置目标信息，并基于此构建 Kaleidoscope
编译器。我们通过该编译器，对一段 Kaleidoscope
代码进行编译，生成了一个目标文件。最终，对一段 C++ 代码进行编译，链接
Kaleidoscope 目标文件，实现混合编译。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Cross-Compilation
using Clang</a></li>
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html">Kaleidoscope:
Compiling to Object Code</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>clang</tag>
        <tag>混编</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(9)——调试信息</title>
    <url>/2022/09/17/compiler-for-kaleidoscope-09/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>通过 8
章的教程，我们实现了一门支持函数和变量的编程语言。那么，如果代码运行或编译出错时，我们该如何调试程序呢？</p>
<span id="more"></span>
<p>本质上，源码调试是基于 <strong>格式化数据</strong>
实现的，<strong>格式化数据可以辅助调试器实现二进制和机器状态转换至程序员编写的源码</strong>。在
LLVM 中，我们通常使用一种称为 <strong>DWARF</strong>
的格式。<strong>DWARF
是一种紧凑的编码，可以表示类型、源码位置、变量位置</strong>。</p>
<p>本章，我们将介绍如何基于 DWARF 为 Kaleidoscope 实现调试能力。</p>
<blockquote>
<p>目前我们无法通过 JIT
进行调试，因此我们需要将我们的程序编译为小型且独立的东西。作为其中的一部分，我们将对语言的运行和程序的编译方式进行一些修改。
这意味着我们将拥有一个源文件，其中包含一个用 Kaleidoscope
编写的简单程序，而不是交互式
JIT。它确实涉及一个限制，即我们一次只能有一个“顶级”命令，以减少必要的更改数量。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fib</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h1 id="实现难点">实现难点</h1>
<p>编译器支持调试信息的主要实现难点在于
<strong>已优化的代码</strong>。</p>
<p>首先，编译器代码优化使得保留源码位置更加困难。在 LLVM IR
中，我们为每个 IR
级指令保留源码位置。优化通道同样也会保存新创建指令的源码位置，但合并的指令只能保留一个位置，这可能会导致在单步执行优化程序时出现跳转。</p>
<p>其次，部分优化通道可能会移动变量的位置，从而导致变量难以追溯。</p>
<h1 id="源码位置">源码位置</h1>
<p>从实现难点中我们可以看出，实现调试的关键在于
<strong>源码位置</strong>。因此，我们定义了 <code>SourceLocation</code>
数据结构，用于存储源码位置信息，同时使用两个全局变量 <code>CurLoc</code>
和 <code>LexLoc</code> 分别存储词法分析时的当前位置信息和 token
位置信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SourceLocation</span> &#123;</span><br><span class="line">  <span class="type">int</span> Line;</span><br><span class="line">  <span class="type">int</span> Col;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> SourceLocation CurLoc;</span><br><span class="line"><span class="type">static</span> SourceLocation LexLoc = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让 AST 支持存储源码位置，我们对 <code>ExprAST</code> 扩展了
<code>Loc</code>
字段，用于保存对应表达式的位置信息，如下所示。同时，<code>ExprAST</code>
提供了几个便利方法，用于读取行和列的信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExprAST</span> &#123;</span><br><span class="line">  SourceLocation Loc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ExprAST</span>(SourceLocation Loc = CurLoc) : <span class="built_in">Loc</span>(Loc) &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getLine</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Loc.Line; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCol</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Loc.Col; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> raw_ostream &amp;<span class="title">dump</span><span class="params">(raw_ostream &amp;out, <span class="type">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; <span class="built_in">getLine</span>() &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; <span class="built_in">getCol</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-31.png?x-oss-process=image/resize,w_800" /></p>
<p>那么源码位置在哪里读取呢？很显然，在词法分析阶段进行读取。因此，我们实现了一个新的词法分析输入器
<code>advance()</code>，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> LastChar = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">&#x27;\n&#x27;</span> || LastChar == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">    LexLoc.Line++;</span><br><span class="line">    LexLoc.Col = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    LexLoc.Col++;</span><br><span class="line">  <span class="keyword">return</span> LastChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们将词法分析器的输入器 <code>getchar()</code> 替换成
<code>advance()</code>，从而实现了字符、位置等信息的读取。</p>
<h1 id="调试信息">调试信息</h1>
<p>接下来，我们定义一个 <code>DebugInfo</code>
结构用于表示调试信息，其主要包含三个字段：</p>
<ul>
<li><code>TheCU</code>：<code>DICompileUnit *</code>
类型，用于表示一个编译单元。在编译过程中，一个源文件对应一个编译单元。</li>
<li><code>DblTy</code>：<code>DIType *</code>
类型，用于表示一个数据类型。由于 Kaleidoscope 只包含一种类型
<code>double</code>，因此这里只定义一个字段。</li>
<li><code>LexicalBlocks</code>：<code>vector&lt;DIScope *&gt;</code>
类型，用于表示一个作用域栈，栈顶的作用域表示当前作用域。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DebugInfo</span> &#123;</span><br><span class="line">  DICompileUnit *TheCU;</span><br><span class="line">  DIType *DblTy;</span><br><span class="line">  std::vector&lt;DIScope *&gt; LexicalBlocks;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emitLocation</span><span class="params">(ExprAST *AST)</span></span>;</span><br><span class="line">  <span class="function">DIType *<span class="title">getDoubleTy</span><span class="params">()</span></span>;</span><br><span class="line">&#125; KSDbgInfo;</span><br><span class="line"></span><br><span class="line"><span class="function">DIType *<span class="title">DebugInfo::getDoubleTy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (DblTy)</span><br><span class="line">    <span class="keyword">return</span> DblTy;</span><br><span class="line"></span><br><span class="line">  DblTy = DBuilder-&gt;<span class="built_in">createBasicType</span>(<span class="string">&quot;double&quot;</span>, <span class="number">64</span>, dwarf::DW_ATE_float);</span><br><span class="line">  <span class="keyword">return</span> DblTy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DebugInfo::emitLocation</span><span class="params">(ExprAST *AST)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!AST)</span><br><span class="line">    <span class="keyword">return</span> Builder-&gt;<span class="built_in">SetCurrentDebugLocation</span>(<span class="built_in">DebugLoc</span>());</span><br><span class="line">  DIScope *Scope;</span><br><span class="line">  <span class="keyword">if</span> (LexicalBlocks.<span class="built_in">empty</span>())</span><br><span class="line">    Scope = TheCU;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Scope = LexicalBlocks.<span class="built_in">back</span>();</span><br><span class="line">  Builder-&gt;<span class="built_in">SetCurrentDebugLocation</span>(DILocation::<span class="built_in">get</span>(</span><br><span class="line">      Scope-&gt;<span class="built_in">getContext</span>(), AST-&gt;<span class="built_in">getLine</span>(), AST-&gt;<span class="built_in">getCol</span>(), Scope));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了确保每条指令都能获得正确的源码位置，当处于新的源码位置时，我们必须通知
<code>IRBuilder</code>。为此，我们通过 <code>DebugInfo</code>
提供一个辅助方法 <code>emitLocation</code>。</p>
<h1 id="dwarf-生成设置">DWARF 生成设置</h1>
<p>对于支持 LLVM IR，我们通过 <code>IRBuilder</code>
来实现代码生成。对于支持调试信息，我们通过 <code>DIBuilder</code> 来构建
<strong>调试元数据</strong>。</p>
<p>这里，我们使用 <code>DIBuilder</code> 来构建所有的 IR 级别描述。基于
<code>DIBuilder</code> 构建 LLVM IR
的前提是必须构建一个模块。因此，我们在构建模块之后立即构建
<code>DIBuilder</code>，并将其作为全局静态变量，以便于使用，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;DIBuilder&gt; DBuilder;</span><br></pre></td></tr></table></figure>
<h1 id="主流程">主流程</h1>
<p>上面，我们让词法分析器支持读取位置信息，并且定义了
<code>DebugInfo</code> 类型用于表示调试信息。</p>
<p>下面，我们来修改编译器的主流程。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmParser</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;=&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  TheJIT = <span class="built_in">ExitOnErr</span>(KaleidoscopeJIT::<span class="built_in">Create</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitializeModule</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the current debug info version into the module.</span></span><br><span class="line">  TheModule-&gt;<span class="built_in">addModuleFlag</span>(Module::Warning, <span class="string">&quot;Debug Info Version&quot;</span>,</span><br><span class="line">                           DEBUG_METADATA_VERSION);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Darwin only supports dwarf2.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Triple</span>(sys::<span class="built_in">getProcessTriple</span>()).<span class="built_in">isOSDarwin</span>())</span><br><span class="line">    TheModule-&gt;<span class="built_in">addModuleFlag</span>(llvm::Module::Warning, <span class="string">&quot;Dwarf Version&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct the DIBuilder, we do this here because we need the module.</span></span><br><span class="line">  DBuilder = std::<span class="built_in">make_unique</span>&lt;DIBuilder&gt;(*TheModule);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the compile unit for the module.</span></span><br><span class="line">  <span class="comment">// Currently down as &quot;fib.ks&quot; as a filename since we&#x27;re redirecting stdin</span></span><br><span class="line">  <span class="comment">// but we&#x27;d like actual source locations.</span></span><br><span class="line">  KSDbgInfo.TheCU = DBuilder-&gt;<span class="built_in">createCompileUnit</span>(</span><br><span class="line">      dwarf::DW_LANG_C, DBuilder-&gt;<span class="built_in">createFile</span>(<span class="string">&quot;fib.ks&quot;</span>, <span class="string">&quot;.&quot;</span>),</span><br><span class="line">      <span class="string">&quot;Kaleidoscope Compiler&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main &quot;interpreter loop&quot; now.</span></span><br><span class="line">  <span class="built_in">MainLoop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finalize the debug info.</span></span><br><span class="line">  DBuilder-&gt;<span class="built_in">finalize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print out all of the generated code.</span></span><br><span class="line">  TheModule-&gt;<span class="built_in">print</span>(<span class="built_in">errs</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在主流程中，当模块初始化完毕之后，我们基于模块构造
<code>DIBuilder</code>。然后通过 <code>DIBuilder</code>
构造一个编译单元，并存储在全局变量 <code>KSDgbInfo</code> 的
<code>TheCU</code> 字段中。中间开始执行代码的编译。最后，通过调用
<code>DBuilder-&gt;finalize()</code> 确定调试信息。</p>
<p>这里有几点值得注意：</p>
<ul>
<li>首先，当我们为一种 Kaleidoscope 语言生成编译单元时，我们使用了 C
语言常量。这是因为调试器不一定能理解它无法识别的语言的调用或
ABI，相对而言，我们在 LLVM 代码生成中使用 C
ABI，这是比较准确的。这能够确保我们可以真正从调试器调用函数并让它们执行。</li>
<li>其次，我们在 <code>createCompileUnit</code> 调用中看到
<code>fib.ks</code>。这里是一个默认的硬编码值，因为我们使用 shell
重定向将源代码输入 Kaleidoscope
编译器。在常规的编译前端中，我们会有一个输入文件名。</li>
</ul>
<p>在主流程中，<code>MainLoop()</code>
包含了编译器的核心逻辑。接下来，我们来看看其中函数的定义与调用是如何支持调试信息的。</p>
<h1 id="函数">函数</h1>
<p>上面，我们介绍了编译单元和源码位置。现在，我们为函数定义支持调试信息中。如下所示，我们对
<code>FunctionAST::codegen()</code> 进行了改造，使其支持插入调试信息。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">  Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">    BinopPrecedence[P.<span class="built_in">getOperatorName</span>()] = P.<span class="built_in">getBinaryPrecedence</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a subprogram DIE for this function.</span></span><br><span class="line">  DIFile *Unit = DBuilder-&gt;<span class="built_in">createFile</span>(KSDbgInfo.TheCU-&gt;<span class="built_in">getFilename</span>(),</span><br><span class="line">                                      KSDbgInfo.TheCU-&gt;<span class="built_in">getDirectory</span>());</span><br><span class="line">  DIScope *FContext = Unit;</span><br><span class="line">  <span class="type">unsigned</span> LineNo = P.<span class="built_in">getLine</span>();</span><br><span class="line">  <span class="type">unsigned</span> ScopeLine = LineNo;</span><br><span class="line">  DISubprogram *SP = DBuilder-&gt;<span class="built_in">createFunction</span>(</span><br><span class="line">      FContext, </span><br><span class="line">      P.<span class="built_in">getName</span>(), </span><br><span class="line">      <span class="built_in">StringRef</span>(), </span><br><span class="line">      Unit, </span><br><span class="line">      LineNo,</span><br><span class="line">      <span class="built_in">CreateFunctionType</span>(TheFunction-&gt;<span class="built_in">arg_size</span>(), Unit), </span><br><span class="line">      ScopeLine,</span><br><span class="line">      DINode::FlagPrototyped, </span><br><span class="line">      DISubprogram::SPFlagDefinition</span><br><span class="line">  );</span><br><span class="line">  TheFunction-&gt;<span class="built_in">setSubprogram</span>(SP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push the current scope.</span></span><br><span class="line">  KSDbgInfo.LexicalBlocks.<span class="built_in">push_back</span>(SP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unset the location for the prologue emission (leading instructions with no</span></span><br><span class="line">  <span class="comment">// location in a function are considered part of the prologue and the debugger</span></span><br><span class="line">  <span class="comment">// will run past them when breaking on a function)</span></span><br><span class="line">  KSDbgInfo.<span class="built_in">emitLocation</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">unsigned</span> ArgIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, Arg.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a debug descriptor for the variable.</span></span><br><span class="line">    DILocalVariable *D = DBuilder-&gt;<span class="built_in">createParameterVariable</span>(</span><br><span class="line">        SP, Arg.<span class="built_in">getName</span>(), ++ArgIdx, Unit, LineNo, KSDbgInfo.<span class="built_in">getDoubleTy</span>(),</span><br><span class="line">        <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    DBuilder-&gt;<span class="built_in">insertDeclare</span>(Alloca, D, DBuilder-&gt;<span class="built_in">createExpression</span>(),</span><br><span class="line">                            DILocation::<span class="built_in">get</span>(SP-&gt;<span class="built_in">getContext</span>(), LineNo, <span class="number">0</span>, SP),</span><br><span class="line">                            Builder-&gt;<span class="built_in">GetInsertBlock</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = Alloca;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> 在 <code>FunctionAST::codegen()</code>
中关于调试信息相关的逻辑如下</p>
<ul>
<li>基于编译单元 <code>KSDbgInfo.TheCU</code> ，调用
<code>DBuilder-&gt;createFile</code> 方法，构造 <code>DIFile</code>
调试文件。</li>
<li>根据函数行号、函数名、函数作用域、<code>DIFile</code> 等信息，调用
<code>DBuilder-&gt;createFunction</code> 方法，构造
<code>DISubprogram</code>
调试函数，其包含了对函数多有元数据的引用，可用于辅助支持调试。</li>
<li>开始解析函数内容。由于函数支持嵌套作用域。因此，将当前的函数作用域向
<code>KSDbgInfo.LexicalBlocks</code> 作用域栈压栈。</li>
<li>开始解析函数参数。为了避免为函数原型生成行信息，我们调用
<code>KSDbgInfo.emitLocation(nullptr)</code> 对源码位置进行复位。</li>
<li>函数参数解析过程，对于每一个参数，调用
<code>DBuilder-&gt;createParameterVariable</code> 方法，构造
<code>DILocalVariable</code> 调试变量。基于调试变量，调用
<code>DBuilder-&gt;insertDeclare</code>
方法（lvm.dbg.declare），声明引用一个 <code>alloca</code>
指令分配的变量，并设置源码位置。</li>
<li>结束解析函数参数，开始解析函数体。我们调用
<code>KSDbgInfo.emitLocation(Body.get())</code>
对源码位置进行设置。</li>
<li>结束解析函数内容。将当前作用域从
<code>KSDbgInfo.LexicalBlocks</code> 作用域栈中出栈。</li>
</ul>
<p>注意，并不是所有代码都需要包含行信息。在
<code>FunctionAST::codegen()</code> 方法中，我们专门通过
<code>KSDbgInfo.emitLocation(nullptr)</code>
避免为函数原型生成行信息。</p>
<h1 id="aot-编译模式">AOT 编译模式</h1>
<p>之前，我们实现的编译器始终是基于 JIT
编译模式，现在，我们实现的编译器将基于 AOT
编译模式。对此，我们在源码中删除交互式输入的相关逻辑，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="comment">// fprintf(stderr, &quot;ready&gt; &quot;);</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试">测试</h1>
<p>最后，我们可以通过以下命令行将 Kaleidoscope
代码编译为可执行程序。然后，输入 Kaleidoscope 源码文件，生成 LLRVM
IR，其中包含了 DWARF 调试信息。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$ Kaleidoscope-Ch9 &lt; fib.ks </span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>本文，我们对 Kaleidoscope 进行了改造，使其能够支持 DWARF
调试信息。DWARF
调试信息作用非常大，可以辅助我们进行代码调试，后续有机会，我们将继续深入了解一下
DWARF。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html">Kaleidoscope:
Adding Debug Information</a></li>
<li><a href="https://dwarfstd.org/">The DWARF Debugging
Standard</a></li>
<li><a href="https://llvm.org/docs/SourceLevelDebugging.html">Source
Level Debugging with LLVM</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>DWARF</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 LLVM 自制编译器(10)——总结</title>
    <url>/2022/09/17/compiler-for-kaleidoscope-10/</url>
    <content><![CDATA[<h1 id="展望">展望</h1>
<p>本章是本系列教程的最后一章。通过本教程，我们实现并扩展 Kaleidoscope
编程语言，使其语言的特性和功能不断增强。</p>
<span id="more"></span>
<p>在这个过程中，我们构建了词法分析器、解析器、AST、代码生成器、REPL、JIT，并为可执行文件支持了调试信息。所有的功能仅仅用了
1000 行左右代码就实现了。</p>
<p>我们的语言支持几个有趣的特性，比如：支持自定义的二元运算符和一元运算符，支持
JIT 编译并执行，支持构造控制流等。</p>
<p>本教程的初衷是为了向开发者展示定义、构建、使用语言是如此简单和有趣，编译器的实现也并不是难如登天！现在，我们已经了解了自制编译器的一些基础知识，这里强烈建议开发者能够使用代码对其进行魔改。比如，可以尝试支持以下这些特性：</p>
<ul>
<li><strong>全局变量</strong>：虽然全局变量在软件工程中并不是一个非常有价值的特性，但是将它应用于
Kaleidoscope 中，其实是非常有用的。在目前的实现中，我们可以非常容易地为
Kaleidoscope
支持全局变量：只需要在全局变量符号表中查找未解析的变量即可。如果要创建全局变量，请使用
LLVM <code>GlobalVariable</code> 类。</li>
<li><strong>类型变量</strong>：目前，Kaleidoscope 只支持一种数据类型
<code>double</code>。由于只支持一种类型，因此无需指定变量类型。如果要支持多种数据类型，最简单的方法是要求用户为每个变量定义指定类型，并在符号表中记录变量的类型及其值。</li>
<li><strong>数组、结构体、向量</strong>：一旦支持了多种类型，我们可以通过各种方式对类型系统进行扩展。对于数组、结构体、向量等类型，其核心是基于
LLVM <code>getelementptr</code> 进行实现。</li>
<li><strong>标准运行时</strong>：目前，Kaleidoscope
运行用于访问任意外部函数，比如：<code>printd</code>、<code>putchard</code>
等。当我们扩展语言以支持更高级的特性时，可以考虑实现运行时。比如：对于实现哈希表，哈希表底层封装了一系列实现，如果将这些实现内联至代码中，那么每定义一个哈希表会生成底层的实现代码，如果我们将哈希表的底层实现作为一个子程序定义在运行时，那么将会非常具有优化意义。</li>
<li><strong>内存管理</strong>：目前，Kaleidoscope 只能访问栈内存。如果为
Kaleidoscope 支持通过调用标准的 libc
<code>malloc</code>/<code>free</code>
接口或使用垃圾收集器来分配堆内存，那么也能够极大地增强语言的能力。对此，LLVM
是完全支持精准垃圾收集（Accurate Garbage
Collection）功能的，包括对象移动、栈扫描与更新等算法。</li>
<li><strong>异常处理</strong>：LLVM
支持生成零开销异常。此外，我们还可以隐式地使每个函数返回一个错误值并检查，从而生成代码。我们还可以显式地使用
<code>setjmp</code>/<code>longjmp</code>。</li>
<li><strong>面向对象、泛型、数据库访问、复数、几何编程...</strong>：我们可以为语言扩展任何特性。</li>
<li><strong>其他领域</strong>：我们可以将 LLVM
应用至很多领域，从而构建特定语言。当然，还有很多其他领域会利用编译相关技术，比如：LLVM
被用于实现 OpenGL图形加速、C++ 代码转换为 ActionScript
等等。甚至，也许你将是第一个使用 LLVM 将正则表达式解释器 JIT
编译成本机代码的人！</li>
</ul>
<h1 id="llvm-ir-属性">LLVM IR 属性</h1>
<p>对于 LLVM
IR，我们经常会有一些疑问。本章，我们梳理了一些常见的问题，并进行解答。</p>
<h2 id="目标独立">目标独立</h2>
<p>Kaleidoscope 是<strong>可移植语言</strong> 的一个例子：任何用
Kaleidoscope
编写的程序都可以在它运行的任何目标上以相同的方式工作。绝大多数编程语言都具有此属性，如：lisp、java、haskell、javascript、python
等。但需要注意的是，虽然这些语言是可移植的，但并非所有的库都是如此。</p>
<p>LLVM 有一个特性是它通常能够在 IR 中保持目标独立：我们可以将 LLVM IR
用于 Kaleidoscope 编译的程序并在 LLVM
支持的任何目标上运行它。简而言之，Kaleidoscope
编译器生成与目标无关的代码，因为它在生成代码时不会查询任何特定于目标的信息。</p>
<h2 id="安全保证">安全保证</h2>
<p>上面提到的一些编程语言，很多都是 <strong>安全</strong>
的语言。比如，用 Java 编写的程序不可能破坏其地址空间并使进程崩溃（假设
JVM 没有错误）。
安全性是一个有趣的属性，它需要结合语言设计、运行时支持以及操作系统支持。</p>
<p>在 LLVM 中实现安全语言是完全可以的，但 LLVM IR
本身并不能保证安全。LLVM IR
允许不安全的指针转换、释放错误后使用、缓冲区溢出和各种其他问题。要实现安全的特性，我们需要在
LLVM 之上构建一个层来实现。</p>
<h2 id="语言特定优化">语言特定优化</h2>
<p>和其他工具一样，LLVM
不能在一个系统中解决所有的问题。对此，很多开发者会抱怨 LLVM
无法执行高级语言的特定优化，因为 LLVM
丢失了太多信息。对此，本章给出了如下的一些看法。</p>
<p>首先，LLVM 确实会丢失信息。例如，在撰写本教程时，在 LLVM IR
中无法区分 SSA 值是来自 ILP32 机器上的 C <code>int</code> 还是 C
<code>long</code>（调试信息除外）。两者都被编译为 <code>i32</code>
值，并且关于它来自什么的信息丢失了。这里更普遍的问题是 LLVM 类型系统使用
“结构等价” 而不是
“命名等价”。另一个让人感到惊讶的地方是，如果我们在高级语言中有两种具有相同结构的类型（例如，两个具有单个
<code>int</code> 字段的不同结构），那么这些类型将被编译成单个 LLVM
类型。</p>
<p>其次，虽然 LLVM 确实会丢失信息，但 LLVM
并不是一个固定的目标：我们会继续以许多不同的方式增强和改进它。除了添加新功能（LLVM
并不总是支持异常或调试信息）外，我们还扩展了 IR
以捕获重要信息以进行优化（例如，参数是符号扩展还是零扩展、指针别名信息等）。许多增强功能都是用户驱动的：开发者希望
LLVM 包含一些特定功能，为此，开发者们一直在对它进行扩展。</p>
<p>第三，添加特定于语言的优化是可能且容易的。举一个简单的例子，我们可以很容易地添加特定于语言的优化通道，从而为一种语言编译的代码。对于
C 系列，有一个标准 C 库函数的优化通道。如果我们在 <code>main()</code>
中调用 <code>exit(0)</code>，它会知道将其优化为 <code>return 0;</code>
是安全的。</p>
<p>此外，还可以将各种其他语言特定的信息嵌入到 LLVM IR
中。即使在最坏的情况下，我们也可以将 LLVM
视为纯粹的代码生成器，并在特定于语言的 AST
上在编译前端实现我们想要的高级优化。</p>
<h1 id="提示与技巧">提示与技巧</h1>
<p>在使用 LLVM
之后，我们会了解到许多有用的提示与技巧，这些技巧和技巧乍一看并不明显。这里，我们只讨论其中的一些问题。</p>
<h2 id="实现可移植的-offsetofsizeof">实现可移植的 offsetof/sizeof</h2>
<p>如果我们希望让编译器生成的代码保持
<strong>目标独立</strong>，那么会出现一件有趣的事情，那就是我们经常需要知道某些
LLVM 类型的大小或 llvm 结构中某些字段的偏移量。
例如，我们可能需要将类型的大小传递给分配内存的函数。</p>
<p>不幸的是，这在不同目标之间可能会有很大差异：例如，指针的宽度是特定于目标的。不过，有一种巧妙的方法，即使用
<code>getelementptr</code> 指令，它允许我们以可移植的方式计算它。</p>
<h2 id="垃圾回收栈帧">垃圾回收栈帧</h2>
<p>某些语言想要显式地管理栈帧，通常是为了支持垃圾收集栈帧或允许实现闭包。事实上，通常有比显式管理栈帧更好的方法来实现这些功能，但如果我们执意这么做，LLVM
也是支持的。
这需要我们的编译前端将代码转换为连续传递样式并使用尾调用（LLVM
也支持）。</p>
<h1 id="总结">总结</h1>
<p>本系列教程通过基于 LLVM 自制一款针对 Kaleidoscope
编程语言的编译器，在这个过程中，展示了自制编程语言或编译器所涉及的一些相关概念和知识，从而产生一个系统的认知。至此，本教程结束了！如果希望有更进一步探索，建议大家着手开始
LLVM，毕竟代码才是真理！</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.html">Conclusion
and other useful LLVM tidbits</a></li>
<li><a
href="https://llvm.org/docs/LangRef.html#getelementptr-instruction">getelementptr</a></li>
<li><a href="https://llvm.org/docs/GetElementPtr.html">The Often
Misunderstood GEP Instruction</a></li>
<li><a
href="https://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt">clever
way to use the getelementptr instruction</a></li>
</ol>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>运行时</tag>
        <tag>内存管理</tag>
        <tag>类型系统</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理工具系列(1)——lex</title>
    <url>/2022/06/22/compiler-principle-tool-lex/</url>
    <content><![CDATA[<p>在编译过程中，词法分析器的主要作用是将代码文件的文本内容 token
化（又称扫描），token
化后再通过语法分析器进行语法分析，构造语法树，从而完成后续的一系列操作。</p>
<span id="more"></span>
<p>宏观层面，词法分析器基于一系列正则表达式识别并构造不同的
token。原理层面，正则表达式是通过确定性有穷自动机（Deterministic Finite
Automator, DFA）实现内容匹配的。微观层面，token
化是基于一系列重复繁琐的操作实现的。</p>
<p>lex
是一款词法分析器生成器，通过输入自定义的描述文件（包括正则表达式），我们可以生成特定的词法分析器，从而可以避免手写底层重复繁琐的实现代码。</p>
<p>本文，我们简单介绍一下 lex 的工作原理和基本用法。</p>
<h1 id="工作原理">工作原理</h1>
<p>正如上文所说，lex
是一款词法分析器生成器。其输入为描述文件，输出为词法分析器。其中，词法分析器的所有逻辑由
<code>yylex()</code> 函数实现。</p>
<p>lex 的工作原理示意图如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/lex-01.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="描述文件">描述文件</h1>
<p>描述文件是 lex
生成词法分析器的核心依据，因此，我们来重点介绍一下描述文件的组成结构。描述文件的基本结构如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;定义&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;规则&gt;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&lt;代码&gt;</span><br></pre></td></tr></table></figure></p>
<p>如下所示为一个 lex 描述文件的示例，文件名为 <code>count.l</code>。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="type">int</span> charcount=<span class="number">0</span>,linecount=<span class="number">0</span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">. charcount++;</span><br><span class="line">\n &#123;linecount++; charcount++;&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    yylex();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;There were %d characters in %d lines\n&quot;</span>, charcount,linecount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用如下命令即可生成词法分析器。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lex -t count.l &gt; count.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -c -o count.o count.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -o count count.o -ll</span></span><br></pre></td></tr></table></figure>
我们可以执行 <code>./count</code>，通过控制台输入文本，最后输入结束符
Ctrl+D，查看统计结果。</p>
<p>描述文件使用 <code>%%</code>
对不同的部分进行分隔，其主要包含三部分内容，分别是：</p>
<ul>
<li><strong>定义</strong>（Definitions）：可选</li>
<li><strong>规则</strong>（Rules）：必选</li>
<li><strong>代码</strong>（Codes）：可选</li>
</ul>
<h2 id="定义">定义</h2>
<p>定义部分主要包含三部分内容，分别是：</p>
<ul>
<li><strong>C 代码定义</strong></li>
<li><strong>命名正则表达式定义</strong></li>
<li><strong>指令定义</strong></li>
</ul>
<h3 id="c-代码定义">C 代码定义</h3>
<p>C 代码定义基本格式如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">codes</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure> 在 <code>%&#123;</code> 和
<code>%&#125;</code> 之间定义 C 代码，lex
会将这些代码直接拷贝至输出文件中。一般会在这里定义变量，include
语句等。</p>
<h3 id="命名正则表达式定义">命名正则表达式定义</h3>
<p>命名正则表达式定义为一系列命名的正则表达式，用于描述不同的标识符，如：<code>function</code>、<code>let</code>、<code>import</code>，其基本格式如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">name expression</span><br></pre></td></tr></table></figure>
命名与正则表达式之间使用空格进行分隔。由于为正则表达式提供了命名，我们可以在其他地方直接引用该命名，引用方式为
<code>&#123;name&#125;</code>。如下所示为一个简单的示例： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">letter   [a-zA-Z]</span><br><span class="line">digit    [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">punct    [,.:;!?]</span><br><span class="line">nonblank [^ \t]</span><br><span class="line">name     &#123;letter&#125;(&#123;letter&#125;│&#123;digit&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="指令定义">指令定义</h3>
<p>指令定义则是通过 lex 提供的一系列以 <code>%</code>
开头的指令来修改内置变量的默认值。比如：</p>
<ul>
<li><code>%array</code>：将内置的 <code>yytext</code> 变量的类型设置为
<code>char</code> 数组类型。</li>
<li><code>%pointer</code>：将内置的 <code>yytext</code> 标量的类型设置为
<code>char</code> 数组指针类型。</li>
<li><code>%s STATE</code>：定义一个 <code>STATE</code>
状态，<code>STATE</code> 可以是任意字符串。lex 默认以
<code>INITIAL</code> 作为初始状态。</li>
<li><code>%e size</code>：定义内置的 NFA 表项的数量。默认值是
1000。</li>
<li><code>%n size</code>：定义内置的 DFA 表项的数量。默认值是 500。</li>
<li><code>%p size</code>：定义内置的 move 表项的数量。默认值是
2500。</li>
</ul>
<h2 id="规则">规则</h2>
<p>规则部分定义了一系列的 <strong>词法翻译规则</strong>（Lexical
Translation
Rules），每一条词法翻译规则可以分为两部分：<strong>模式</strong> 和
<strong>动作</strong>。</p>
<ul>
<li>模式：用于描述词法规则的正则表达式</li>
<li>动作：模式匹配时要执行的 C 代码</li>
</ul>
<p>词法翻译规则的基本格式如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pattern action</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">pattern &#123;</span><br><span class="line">    action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="匹配">匹配</h3>
<p><strong>当词法翻译规则的模式匹配成功时，lex 默认会将匹配的 token
值存储在 <code>yytext</code> 变量，将匹配的 token 长度存储在
<code>yyleng</code>
变量</strong>。如下所示，我们使用翻译规则来统计代码的字符数、单词数、行数。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="type">int</span> charcount=<span class="number">0</span>, linecount=<span class="number">0</span>, wordcount=<span class="number">0</span>;</span><br><span class="line">%&#125;</span><br><span class="line">letter [^ \t\n]</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">&#123;letter&#125;+     &#123;wordcount++; charcount+=yyleng;&#125;</span><br><span class="line">.             charcount++;</span><br><span class="line">\n            &#123;linecount++; charcount++;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在很多场景下，词法分析器必须将识别结果返回给调用者。比如，在编译器中，当识别一个标识符时，必须同时返回
<strong>符号表表项的索引</strong> 和 <strong>token 号</strong>。由于 C
语言的 return 语句只能返回一个值，我们可以通过内置的 <code>yylval</code>
变量存储 token 值（即符号表项的索引）和 token 号。如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;name&#125; &#123; yyval = lookup(yytext); <span class="keyword">return</span>(NAME); &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="状态">状态</h2>
<p>如果词法翻译规则的模式的匹配依赖上下文，那么我们可以有不同的方式来处理。我们可以根据其所依赖上下文的相对位置，分为：<strong>左状态</strong>（Left
State） 和 <strong>右状态</strong>（Right State）两种。</p>
<h3 id="左状态">左状态</h3>
<p>左状态的基本格式如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;STATE&gt;(pattern) &#123; action; BEGIN OTHERSTATE; &#125;</span><br></pre></td></tr></table></figure> 其中 <code>STATE</code>
为定义部分的状态定义所定义的状态，使用 <code>%s STATE</code>
进行定义。</p>
<h3 id="右状态">右状态</h3>
<p>右状态的基本格式如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pattern/context &#123;action&#125;</span><br></pre></td></tr></table></figure> 当匹配到
<code>pattern</code> 时，且紧随其后是
<code>context</code>，那么才算匹配成功。在这种情况下，<code>/</code>
后面的内容仍然位于输入流中，它们可以作为下一个匹配的输入。</p>
<h2 id="代码">代码</h2>
<p>代码部分用于定义自定义代码，如果希望单独使用
lex，那么我们可以在代码部分里包含 <code>main</code>
入口函数。如果代码部分为空，那么 lex 会自动添加默认的 <code>main</code>
入口函数，如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    yylex();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>注意，<code>yylex</code>
包含了我们上述所定义的所有逻辑</strong>。</p>
<h1 id="案例">案例</h1>
<p>假如我们希望对一段文本内容的空格进行规范化，文本如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This    text (all of it   )has occasional lapses , in punctuation(sometimes pretty bad) ,( sometimes not so).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(Ha!) Is this: fun? Or what!</span><br></pre></td></tr></table></figure>
空格规范化的要求包括：</p>
<ul>
<li>对于多个连续的空行，只能保留一个</li>
<li>对于多个连续的空格，只能保留一个</li>
<li>标点符号前，删除空格</li>
<li>标点符号后，添加空格</li>
<li>左括号后，右括号前，删除空格</li>
<li>左括号前，右括号后，添加空格</li>
<li>后括号可以紧跟标点符号</li>
</ul>
<h2 id="右状态方案">右状态方案</h2>
<p>如下所示，为右状态方案。我们通过匹配多余的空格，并通过操作
<code>yytext</code> 来删除空格。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">punct [,.;:!?]</span><br><span class="line">text [a-zA-Z]</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;)&quot;</span><span class="string">&quot; &quot;</span>+/&#123;punct&#125;         &#123;<span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);&#125;</span><br><span class="line"><span class="string">&quot;)&quot;</span>/&#123;text&#125;              &#123;<span class="built_in">printf</span>(<span class="string">&quot;) &quot;</span>);&#125;</span><br><span class="line">&#123;text&#125;+<span class="string">&quot; &quot;</span>+/<span class="string">&quot;)&quot;</span>         &#123;<span class="keyword">while</span> (yytext[yyleng<span class="number">-1</span>]==’ ’) yyleng--; ECHO;&#125;</span><br><span class="line"></span><br><span class="line">(&#123;punct&#125;|&#123;text&#125;+)/<span class="string">&quot;(&quot;</span>   &#123;ECHO; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);&#125;</span><br><span class="line"><span class="string">&quot;(&quot;</span><span class="string">&quot; &quot;</span>+/&#123;text&#125;          &#123;<span class="keyword">while</span> (yytext[yyleng<span class="number">-1</span>]==’ ’) yyleng--; ECHO;&#125;</span><br><span class="line"></span><br><span class="line">&#123;text&#125;+<span class="string">&quot; &quot;</span>+/&#123;punct&#125;     &#123;<span class="keyword">while</span> (yytext[yyleng<span class="number">-1</span>]==’ ’) yyleng--; ECHO;&#125;</span><br><span class="line"></span><br><span class="line">^<span class="string">&quot; &quot;</span>+                   ;</span><br><span class="line"><span class="string">&quot; &quot;</span>+                    &#123;<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);&#125;</span><br><span class="line">.                       &#123;ECHO;&#125;</span><br><span class="line">\n/\n\n                 ;</span><br><span class="line">\n                      &#123;ECHO;&#125;</span><br><span class="line"></span><br><span class="line">%% </span><br></pre></td></tr></table></figure></p>
<h2 id="左状态方案">左状态方案</h2>
<p>如下所示，为左状态方案。在右状态方案中，我们需要覆盖每一种情况，很容易遗漏。翻译规则的数量可能会随着我们在空格前后识别的类别数量乘积式增长。通过使用左状态方案可以避免翻译规则乘积式增长。</p>
<p>使用左状态，我们在 lex
内部实现了一个有限自动机，并且指定在不同的状态转移过程中如何处理空格。某些情况下，删除空格；某些情况下，掺入空格。</p>
<p>在左状态方案中，我们定义了 4
种状态，分别对应左括号、右括号、文本、标点符号。不同状态下，匹配相同的内容，其状态转移操作不同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">punct [,.;:!?]</span><br><span class="line">text [a-zA-Z]</span><br><span class="line"></span><br><span class="line">%s OPEN</span><br><span class="line">%s CLOSE</span><br><span class="line">%s TEXT</span><br><span class="line">%s PUNCT</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; &quot;</span>+ ;</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;<span class="string">&quot;(&quot;</span>            &#123;ECHO; BEGIN OPEN;&#125;</span><br><span class="line">&lt;TEXT&gt;<span class="string">&quot;(&quot;</span>               &#123;<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); ECHO; BEGIN OPEN;&#125;</span><br><span class="line">&lt;PUNCT&gt;<span class="string">&quot;(&quot;</span>              &#123;<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); ECHO; BEGIN OPEN;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;)&quot;</span>                     &#123;ECHO ; BEGIN CLOSE;&#125;</span><br><span class="line"></span><br><span class="line">&lt;INITIAL&gt;&#123;text&#125;+        &#123;ECHO; BEGIN TEXT;&#125;</span><br><span class="line">&lt;OPEN&gt;&#123;text&#125;+           &#123;ECHO; BEGIN TEXT;&#125;</span><br><span class="line">&lt;CLOSE&gt;&#123;text&#125;+          &#123;<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); ECHO; BEGIN TEXT;&#125;</span><br><span class="line">&lt;TEXT&gt;&#123;text&#125;+           &#123;<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); ECHO; BEGIN TEXT;&#125;</span><br><span class="line">&lt;PUNCT&gt;&#123;text&#125;+          &#123;<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); ECHO; BEGIN TEXT;&#125;</span><br><span class="line"></span><br><span class="line">&#123;punct&#125;+                &#123;ECHO; BEGIN PUNCT;&#125;</span><br><span class="line"></span><br><span class="line">\n                      &#123;ECHO; BEGIN INITIAL;&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本文简单介绍了词法分析器生成器 lex
的基本原理，重点介绍了其描述文件的基本结构，以便后续在接触此类文件时了解其相关的结构和概念，从而能够快速上手。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.ibm.com/docs/en/zos/2.5.0?topic=services-zos-unix-system-programming-tools">z/OS
UNIX System Services Programming Tools</a></li>
<li><a
href="https://www.csie.cgu.edu.tw/~jhchen/course/PLP/Lex/lextut.pdf">A
Lex Tutorial</a></li>
<li><a
href="https://www.csie.cgu.edu.tw/~jhchen/course/PLP/Yacc.pdf">Yacc</a></li>
<li><a
href="https://www2.cs.arizona.edu/~debray/Teaching/CSc453/DOCS/tutorial-large.pdf">Lex
and Yacc: A Brisk Tutorial</a></li>
</ol>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>lex</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理工具系列(2)——yacc</title>
    <url>/2022/07/10/compiler-principle-tool-yacc/</url>
    <content><![CDATA[<p>前一篇文章我们介绍了词法分析器生成器
lex，本文我们来介绍语法/语义分析器生成器 yacc。</p>
<span id="more"></span>
<p>在编译流程中，词法分析器会扫描代码文件，并将其 token
化。语法/语义分析器则会扫描 token
化后的内容，从而建立语法树，生成语义信息。</p>
<p>下面，我们简单介绍一下 yacc 的工作原理和基本用法。</p>
<h1 id="工作原理">工作原理</h1>
<p>下图所示为 lex 和 yacc 协同工作的示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/yacc-01.png?x-oss-process=image/resize,w_800" /></p>
<p>lex 和 yacc 分别使用各自的描述文件生成词法分析器 <code>yylex()</code>
和语法/语义分析器 <code>yyparse()</code>。</p>
<p><code>yyparse()</code> 自身并不进行词法分析，而是调用
<code>yylex()</code> 进行词法分析。<code>yylex()</code> 返回一个 token
号，表示 token 的类型。token 值则存储在 <code>yylval</code>
变量中。比如：token 的类型为 <strong>算术运算符</strong>，token 的值为
<strong>+</strong>。<code>yyparse()</code> 则通过读取
<code>yylex()</code> 的返回值以及 <code>yylval</code> 变量分别获取 token
类型和 token 值。</p>
<p><code>yyparse()</code> 函数的返回值有两种：</p>
<ul>
<li>当返回值为 0 时，表示解析正确</li>
<li>当返回值为 1 时，表示解析错误</li>
</ul>
<h1 id="描述文件">描述文件</h1>
<p>yacc 描述文件的基本结构与 lex 基本一致，如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义</span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line"></span><br><span class="line">规则</span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line"></span><br><span class="line">代码</span><br></pre></td></tr></table></figure></p>
<p>描述文件使用 <code>%%</code>
对不同的部分进行分隔，其主要包含三部分内容，分别是：</p>
<ul>
<li><strong>定义</strong>（Definitions）：可选</li>
<li><strong>规则</strong>（Rules）：必选</li>
<li><strong>代码</strong>（Codes）：可选</li>
</ul>
<h2 id="定义">定义</h2>
<p>定义部分包含三种类型的定义，分别是：</p>
<ul>
<li>token 定义</li>
<li>优先级与关联性定义</li>
<li>变量与函数定义：用于后续的语法分析</li>
</ul>
<h3 id="token-定义">token 定义</h3>
<p>词法分析器会将所有的字符识别成一个个的 token，语法分析器则会将 token
进行分类处理。因此两者之间必须统一 token 的类型。通常，token
的类型会放在 yacc 描述文件中定义。</p>
<p>token 类型使用 <code>%token</code> 指令进行定义，其一般格式如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%token name1 name2 name3 ...</span><br></pre></td></tr></table></figure> 比如，我们可以定义整型类型的 token，如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%token INTEGER</span><br></pre></td></tr></table></figure></p>
<p>yacc 会将 <code>%token</code> 指令转换成 C 语言宏定义
<code>#define</code>。默认，yacc 内部宏定义占用了 0-256
宏定义常量值，因此，<code>%token</code> 命令转换后的宏定义常量值会从 257
开始，依次累加。</p>
<h3 id="优先级与关联性定义">优先级与关联性定义</h3>
<p>语法分析器分析包含
<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>
等算术运算符的表达式时，必须根据优先级和关联性来进行分析。</p>
<ul>
<li>对于优先级，<code>*</code>、<code>/</code> 运算符的优先级高于
<code>+</code>、<code>-</code>。</li>
<li>对于关联性，当一个表达式中包含多个相同优先级操作符，语法分析器必须根据关联性来决定左关联（Left
Associative）还是右关联（Right Associative）。比如：对于 C
语言，采用左关联；对于 FORTRAN，采用右关联。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A - B - C</span><br><span class="line"></span><br><span class="line"><span class="comment">// C equals to</span></span><br><span class="line">(A - B) - C</span><br><span class="line"></span><br><span class="line"><span class="comment">// FORTRAN</span></span><br><span class="line">A - (B - C)</span><br></pre></td></tr></table></figure>
<p>关于优先级和关联性的定义，yacc 提供了下几个指令：</p>
<ul>
<li><code>%left</code>：表示左关联。先定义的优先级低于后定义的优先级。</li>
<li><code>%right</code>：表示右关联。先定义的优先级高于后定义的优先级。</li>
<li><code>%nonassoc</code>：表示无关联。</li>
</ul>
<p>如下所示为一个简单的算术表达式的优先级和关联性定义。由于
<code>=</code> 为右关联，所以 <code>A = B = C</code> 等同于
<code>A = (B = C)</code>。<code>+</code>、<code>-</code> 比
<code>*</code>、<code>/</code>、<code>%</code> 后定义，所以优先级更低。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%right <span class="string">&#x27;=&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> <span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="变量与函数定义">变量与函数定义</h3>
<p>定义部分还可以定义基于 C 语言的变量与函数，后续的操作均可以引用。yacc
约定使用 <code>%&#123;</code> 和 <code>%&#125;</code> 进行定义，如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> x = <span class="number">1.0</span>;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure> 变量与函数的定义均会被拷贝至 yacc
生成的分析器代码文件的开头部分。</p>
<h2 id="规则">规则</h2>
<p>规则部分定义了一系列的
<strong>语法翻译规则</strong>，每一条语法翻译规则可以分为两部分：<strong>标识符</strong>
和 <strong>定义</strong>。</p>
<ul>
<li><strong>标识符</strong>：一个非终结符。<strong>对应文法产生式的左部</strong>。</li>
<li><strong>定义</strong>：一个或多个终结符或非终结符。<strong>对应文法产生式的右部</strong>。
<ul>
<li>定义中的每个终结符或非终结符，可选地支持定义一个
<strong>语义动作</strong>（Sematic
Action），即终结符或非终结符匹配时要执行的 C
代码，<strong>用于进行语义分析</strong>。</li>
</ul></li>
</ul>
<p>语法翻译规则的基本格式如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个标识符包含一个定义</span></span><br><span class="line">identifier: definition</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个标识符包含多个定义</span></span><br><span class="line">identifier: definition</span><br><span class="line">          | definition</span><br><span class="line">          | ...</span><br><span class="line">          ;</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为一个算术运算的语法翻译规则。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">intexp : <span class="string">&#x27;(&#x27;</span> intexp <span class="string">&#x27;)&#x27;</span>       &#123; $$ = $<span class="number">2</span>; &#125;</span><br><span class="line">       | intexp <span class="string">&#x27;+&#x27;</span> intexp    &#123; $$ = $<span class="number">1</span> + $<span class="number">3</span>; &#125;</span><br><span class="line">       | intexp <span class="string">&#x27;-&#x27;</span> intexp    &#123; $$ = $<span class="number">1</span> - $<span class="number">3</span>; &#125;</span><br><span class="line">       | intexp <span class="string">&#x27;*&#x27;</span> intexp    &#123; $$ = $<span class="number">1</span> * $<span class="number">3</span>; &#125;</span><br><span class="line">       | intexp <span class="string">&#x27;/&#x27;</span> intexp    &#123; $$ = $<span class="number">1</span> / $<span class="number">3</span>; &#125;</span><br><span class="line">       | INTEGER</span><br><span class="line">       ;</span><br></pre></td></tr></table></figure></p>
<p>每个语法翻译规则的定义包含一个或多个终结符或非终结符。当定义匹配时，yacc
默认将第一个匹配符号存储在 <code>$1</code>，第二个匹配符号存储在
<code>$2</code>，以此类推。如果符号是一个终结符（token）时，其值来自于
<code>yylex()</code> 所设置的 <code>yylval</code>
变量。当基于定义归约得到标识符时，将匹配的标识符存储在 <code>$$</code>
变量中。</p>
<p>默认，规则部分定义的第一个非终结符为 <strong>开始符号</strong>（Start
Symbol）。语法分析器最终生成的语法分析树，其根节点就是开始符号。yacc
提供了 <code>%start</code> 指令，允许用户自定义开始符号。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%start name</span><br></pre></td></tr></table></figure></p>
<h2 id="代码">代码</h2>
<p>类似于 lex，yacc 的代码部分也是用于定义 C 代码。yacc
会将这部分代码拷贝至语法分析器代码文件的末尾。当然，yacc
也支持为这部分代码生成一个独立的文件，以支持独立编译。对于大型的编译模块，尤其推荐使用这种独立生成的方式。</p>
<p>比如，对于 <code>yylex()</code>，每次识别一个 token
时，<code>yylex()</code> 都会向 <code>yyparse()</code>
返回一个值表示已识别的 token 的类型。显然，<code>yylex()</code> 和
<code>yyparse()</code> 必须统一对于 token 类型的认知。因此 yacc
可以独立生成一个仅包含 token 宏定义的文件。编译时，我们可以使用
<code>-D</code>
选项来指定编译常量所在的文件，包括：<code>#include</code>、<code>#define</code>
等预编译指令。</p>
<h1 id="案例">案例</h1>
<p>下面，我们通过 lex 和 yacc，生成一个能分析加法和乘法表达式的程序。
lex 描述文件 <code>test.l</code> 如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%%</span><br><span class="line"></span><br><span class="line">\*                             &#123; <span class="keyword">return</span> (<span class="string">&#x27;*&#x27;</span>); &#125;</span><br><span class="line">\+                             &#123; <span class="keyword">return</span> (<span class="string">&#x27;+&#x27;</span>); &#125;</span><br><span class="line">\(                             &#123; <span class="keyword">return</span> (<span class="string">&#x27;(&#x27;</span>); &#125;</span><br><span class="line">\)                             &#123; <span class="keyword">return</span> (<span class="string">&#x27;)&#x27;</span>); &#125;</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]*                         &#123; yylval = atoi(yytext); <span class="keyword">return</span> (NUMBER); &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure></p>
<p>yacc 描述文件 <code>test.y</code> 如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">yylex</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">line    : expr                 &#123; <span class="built_in">printf</span>(<span class="string">&quot;Value = %d&quot;</span>, $<span class="number">1</span>); &#125;</span><br><span class="line">        ;</span><br><span class="line">expr    : expr <span class="string">&#x27;+&#x27;</span> term        &#123; $$ = $<span class="number">1</span> + $<span class="number">3</span>; &#125;</span><br><span class="line">        | term                 &#123; $$ = $<span class="number">1</span>; &#125;</span><br><span class="line">        ;</span><br><span class="line">term    : term <span class="string">&#x27;*&#x27;</span> factor      &#123; $$ = $<span class="number">1</span> * $<span class="number">3</span>; &#125;</span><br><span class="line">        | factor</span><br><span class="line">        ;</span><br><span class="line">factor  : <span class="string">&#x27;(&#x27;</span> expr <span class="string">&#x27;)&#x27;</span>         &#123; $$ = $<span class="number">2</span>; &#125;</span><br><span class="line">        | NUMBER               &#123; $$ = $<span class="number">1</span>; &#125;</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">%% </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lex.yy.c&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过以下编译命令可以生成一个可执行文件
<code>test</code>，我们运行该可执行程序，可以输入一行代码，包含多个算术操作。在输入结束符
<code>ctrl + D</code> 后，程序会通过语义动作打印计算结果。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lex input.l</span><br><span class="line">$ yacc input.y</span><br><span class="line">$ cc y.tab.c -ly -ll -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>本文我们简单介绍了一下 yacc 与 lex
协同工作的分工与原理，重点介绍了一下 yacc
的描述文件的基本组成，最后介绍了一个结合 lex 和 yacc
开发一个小工具的例子。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.ibm.com/docs/en/zos/2.5.0?topic=services-zos-unix-system-programming-tools">z/OS
UNIX System Services Programming Tools</a></li>
<li><a
href="https://www.csie.cgu.edu.tw/~jhchen/course/PLP/Yacc.pdf">Syntax
Directed Translation and YACC</a></li>
<li><a
href="https://www2.cs.arizona.edu/~debray/Teaching/CSc453/DOCS/tutorial-large.pdf">Lex
and Yacc: A Brisk Tutorial</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/143867739">Lex与YACC详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>yacc</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(3)——程序构建及编译原理</title>
    <url>/2018/05/12/compiler-principle/</url>
    <content><![CDATA[<p>最近在看《程序员的自我修养——链接、装载与库》一书，这本书以前看过一部分，由于难啃，当时没有坚持下去。现在工作了，每天接触的都是业务开发，对底层的一些东西感觉越来越陌生。于是，又把此书翻了出来拜读。为了加深阅读的印象，打算对书中的一些有价值的内容进行整理，也方便后续回顾。</p>
<span id="more"></span>
<h1 id="程序构建流程">程序构建流程</h1>
<p>下面以“Hello World”程序为例，来介绍程序的编译与链接过程。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Linux下，可以直接使用GCC来编译Hello World程序： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<p>GCC编译命令隐藏了构建过程中的一些复杂的步骤，主要有4个步骤，如下图所示。</p>
<ul>
<li><strong>预处理（Propressing）</strong></li>
<li><strong>编译（Compilation）</strong></li>
<li><strong>汇编（Assembly）</strong></li>
<li><strong>链接（Linking）</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/code-compile-process.png" /></p>
<h2 id="预编译">预编译</h2>
<p>预编译步骤将源代码文件 <code>hello.c</code>
以及相关头文件，如：<code>stdio.h</code>
等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。</p>
<p>预编译步骤相当于执行如下命令（选项-E表示只进行预编译） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
或 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></p>
<p><strong>预编译</strong>
主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下：</p>
<ul>
<li>将所有的“#define”删除，并且展开所有的宏定义。</li>
<li>处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。</li>
<li>删除所有的注释“//”和“/* */”。</li>
<li>添加行号和文件名标识，比如#2 “hello.c”
2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。</li>
<li>保留所有的#pragma编译器指令，因为编译器须要试用他们。</li>
</ul>
<p>预编译生成的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p>
<h2 id="编译">编译</h2>
<p><strong>编译</strong>
就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p>编译步骤相当于执行如下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure> 或 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></p>
<p>现在版本的GCC把预编译和编译两个步骤合并成了一个步骤，使用一个叫cc1的程序来完成。该程序位于“<code>/usr/lib/gcc/x86_64-linux-gnu/4.8/</code>”，我们可以直接调用cc1来完成它：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c</span><br></pre></td></tr></table></figure></p>
<p>事实上，对于不同的语言，预编译与编译的程序是不同的，如下所示： -
C：<strong>cc1</strong> - C++：<strong>cc1plus</strong> -
Objective-C：<strong>cc1obj</strong> - Fortran：<strong>f771</strong> -
Java：<strong>jc1</strong></p>
<p>GCC是对这些后台程序的封装，它会根据不同的参数来调用预编译程序cc1、汇编器as、链接器ld。</p>
<h2 id="汇编">汇编</h2>
<p><strong>汇编</strong>
就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。</p>
<p>汇编步骤相当执行如下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure> 或 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure>
GCC本质上是调用汇编器as来完成汇编步骤的，我们可以直接调用as来完成该步骤：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure></p>
<h2 id="链接">链接</h2>
<p><strong>链接</strong>
主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。</p>
<h1 id="编译器工作原理">编译器工作原理</h1>
<p>编译过程可以分为6个步骤，如下图所示。</p>
<ul>
<li><strong>扫描（Scanning）</strong>（又称词法分析）</li>
<li><strong>语法分析（Syntax analysis）</strong></li>
<li><strong>语义分析（Semantic Analysis）</strong></li>
<li><strong>源代码优化（Source Code Optimization）</strong></li>
<li><strong>目标代码生成（Target Code Generation）</strong></li>
<li><strong>目标代码优化（Target Code Optimization）</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-detail-process.png" /></p>
<p>下面我们以一行简单的C语言代码为例，简单描述从 <strong>源代码（Source
Code）</strong> 到 <strong>最终目标代码</strong> 的过程。代码示例如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)</span><br></pre></td></tr></table></figure> ## 扫描（词法分析） 首先源代码被输入到
<strong>扫描器（Scanner）</strong>，扫描器的任务很简单，只是简单地进行词法分析，运用一种类似于
<strong>有限状态机（Finite State Machine）</strong>
的算法将源代码的字符序列分割成一系列的
<strong>记号（Token）</strong>。</p>
<p>以上述代码为例，总共包含了28个非空字符，经过扫描后，产生了16个记号。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">记号</th>
<th style="text-align: left;">类型</th>
<th style="text-align: left;">记号</th>
<th style="text-align: left;">类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">array</td>
<td style="text-align: left;">标识符</td>
<td style="text-align: left;">[</td>
<td style="text-align: left;">左方括号</td>
</tr>
<tr class="even">
<td style="text-align: left;">index</td>
<td style="text-align: left;">标识符</td>
<td style="text-align: left;">]</td>
<td style="text-align: left;">右方括号</td>
</tr>
<tr class="odd">
<td style="text-align: left;">=</td>
<td style="text-align: left;">赋值</td>
<td style="text-align: left;">(</td>
<td style="text-align: left;">左圆括号</td>
</tr>
<tr class="even">
<td style="text-align: left;">index</td>
<td style="text-align: left;">标识符</td>
<td style="text-align: left;">+</td>
<td style="text-align: left;">加号</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">数字</td>
<td style="text-align: left;">)</td>
<td style="text-align: left;">右圆括号</td>
</tr>
<tr class="even">
<td style="text-align: left;">*</td>
<td style="text-align: left;">乘号</td>
<td style="text-align: left;">(</td>
<td style="text-align: left;">左圆括号</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">数字</td>
<td style="text-align: left;">+</td>
<td style="text-align: left;">加号</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;">数字</td>
<td style="text-align: left;">)</td>
<td style="text-align: left;">右圆括号</td>
</tr>
</tbody>
</table>
<p>词法分析产生的记号一般可以分为一下几类：<strong>关键字</strong>、<strong>字面量</strong>（包含数字、字符串等）和
<strong>特殊符号</strong>（如加号、等号）。</p>
<p>在识别记号的同时，扫描器也完成了其他工作。如：将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p>
<p>有一个名为lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。正因为有这样一个程序存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。</p>
<h2 id="语法分析">语法分析</h2>
<p><strong>语法分析器（Grammar Parser）</strong>
将对由扫描器产生的记号进行语法分析。从而产生 <strong>语法树（Syntax
Tree）</strong>。整个分析过程采用了
<strong>上下文无关语法（Context-freeGrammar）</strong>
的分析手段。简单地讲，由语法分析器生成的语法树是以
<strong>表达式（Expression）</strong> 为节点的树。</p>
<p>以上述代码为例，其中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句，下图所示为该语句经过语法分析器后生成的语法树。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-syntax-tree.png" /></p>
<p>在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如：乘法表达式的优先级比加法高，圆括号表达式的优先级比乘法高，等等。另外，有些符号具有多重含义，如“*”在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，因此语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。</p>
<p>有一个名为yacc（Yet Another Compiler
Compiler）的工具可以实现语法分析。其根据用户给定的语法规则对输入的记号序列进行解析，从而构建出语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器编写一个语法分析器。因此，其也称为“编译器编译器（Compiler
Compiler）”</p>
<h2 id="语义分析">语义分析</h2>
<p>语法分析仅仅完成了对表达式的语法层面的分析，但它并不了解这个语句的真正含义，如：C语言里两个指针做乘法运算是没有意义的，但这个语句在语法上是合法的。编译器所能分析的语义是
<strong>静态语义（Static
Semantic）</strong>，所谓静态语义是指在编译期间可以确定的语义，与之对应的
<strong>动态语义（Dynamic Semantic）</strong>
就是只有在运行期才能确定的语义。</p>
<p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型的转换过程，语义分析过程中需要完成该步骤。比如讲一个浮点赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p>
<p>经过语义分析阶段之后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。下图所示为标记语义后的语法树。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-commented-syntax-tree.png" /></p>
<h2 id="源代码优化中间代码生成">源代码优化（中间代码生成）</h2>
<p>现代编译器有着很多层次的优化，<strong>源码优化器（Source Code
Optimizer）</strong> 则是在源代码级别进行优化。上述例子中，（2 +
6）这个表达式可以被优化掉。因为它的值在编译期就可以被确定。下图所示为优化后的语法树。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-optimized-syntax-tree.png" /></p>
<p>事实上，直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成
<strong>中间代码（Intermediate
Code）</strong>，它是语法树的顺序表示，其实它已经非常接近目标代码了。但它一般与目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等。</p>
<p>中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：<strong>三地址码（Three-address
Code）</strong>、<strong>P-代码（P-Code）</strong>。以三地址码为例，最基本的三地址码如下所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = y op z</span><br><span class="line"># 表示将变量y和z进行op操作后，赋值给x。</span><br></pre></td></tr></table></figure></p>
<p>因此，可以将上述例子的代码翻译成三地址码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = index + 4</span><br><span class="line">t3 = t2 * t1</span><br><span class="line">array[index] = t3</span><br></pre></td></tr></table></figure>
为了使所有的操作符合三地址码形式，这里使用了几个临时变量：t1、t2和t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1
= 6。因此，进一步优化后可以得到如下的代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t2 = index + 4</span><br><span class="line">t2 = t2 * 8</span><br><span class="line">array[index] = t2</span><br></pre></td></tr></table></figure>
中间代码将编译器分为 <strong>前端（Front End）</strong> 和
<strong>后端（Back
End）</strong>。编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码。这样，对于一些可跨平台的编译器，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。比如clange就是一个前端工具，而LLVM则负责后端处理。GCC则是一个套装，包揽了前后端的所有任务。</p>
<hr />
<h2 id="目标代码生成">目标代码生成</h2>
<p>目标代码生成主要由 <strong>代码生成器（Code Generator）</strong>
完成。代码生成器将中间代码转换成目标机器代码，该过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。</p>
<p>上述例子的中间代码，经过代码生成器的处理之后可能会生成如下所示的代码序列（以x86汇编为例，假设index的类型为int型，array的类型为int型数组）：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl index, %ecx            ; value of index to ecx</span><br><span class="line">addl $4, %ecx               ; ecx = ecx + 4</span><br><span class="line">mull $8, %ecx               ; ecx = ecx * 8</span><br><span class="line">movl index, %eax            ; value of index to eax</span><br><span class="line">movl %ecx, array(,%eax,4)    ; array[index] = ecx</span><br></pre></td></tr></table></figure></p>
<h2 id="目标代码优化">目标代码优化</h2>
<p>目标代码生成后，由 <strong>目标代码优化器（Target Code
Optimizer）</strong>
来进行优化。比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p>
<p>上述例子中，乘法由一条相对复杂的 <strong>基址比例变址寻址（Base Index
Scale Addressing）</strong>
的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。如下所示为优化后的目标代码：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(,%edx,8), %eax</span><br><span class="line">movl %eax, array(,%edx,4)</span><br></pre></td></tr></table></figure></p>
<h1 id="结尾">结尾</h1>
<p>经过扫描、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化等一系列步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题：</p>
<blockquote>
<p>index和array的地址还没有确定</p>
</blockquote>
<p>如果我们把目标代码使用汇编器编译成真正能够在机器上运行的指令，那么index和array的地址来自哪里？<br />
如果index和array定义在跟上面的源代码同一个编译单元里，那么编译器可以为index和array分配空间，确定地址；但如果是定义在其他的程序模块呢？</p>
<p>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由编译器最终将这些目标文件链接起来形成可执行文件。</p>
<p>后面，我们将继而探讨链接的原理。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(2)——开机启动过程</title>
    <url>/2016/12/14/computer-boot-process/</url>
    <content><![CDATA[<p>首先用一张图来大致了解一下计算机启动的整个过程。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/computer-boot-process.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<h1 id="上电">上电</h1>
<p>按下主机的电源键后，计算机开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动
CPU。如果启动失败（例如 CPU
坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。</p>
<p>如果前一个阶段未出错，就开始加电工作，在多 CPU 或多核 CPU
情况下，某一个 CPU 会被随机选取作为启动 CPU（bootstrap
processor，BSP）运行 BIOS 内部的程序。其余的 CPU（application
processor，AP）保持停机直到操作系统内核显式地使用它们。</p>
<blockquote>
<p>2000 年以前的计算机主板上均使用 <a
href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a>，如今绝大多数计算机采用的是
<a
href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">EFI</a>（Mac
用的就是 EFI）或 <a
href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a>，BIOS
正在逐步被淘汰。基于 EFI、UEFI
的开机过程与传统的BIOS不尽相同，本文将以传统的 BIOS，Intel CPU
为例介绍开机过程。</p>
</blockquote>
<p>此时 CPU 工作模式为实模式，该模式下地址总线是 20 位，寻址范围是
<code>0x00000</code>~<code>0xFFFFF</code> 的 1M 范围。这也就解释了为什么
BIOS 的容量只有 1MB。</p>
<blockquote>
<p>Intel CPU 用三种运行模式: 实模式、32 位保护模式、64
位保护模式。实模式: Intel 8086
的寻址方案，为了商业连续性，兼容了这古老的方案；保护模式:
采用了虚实地址转换方案。</p>
</blockquote>
<p>BIOS 启动之初，内存是空的。此时 CPU
处于实模式，内存的地址映射均为硬连接的设备。内存映射图如下图所示: <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/real-mode-memory.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="重置向量">重置向量</h1>
<p>CPU
启动后其大多数寄存器会被初始化为预定的值，包括指令寄存器（instruction
pointer, EIP），它保存着 CPU 将要执行指令的内存地址。此时 CPU
会有一个特殊行为，其会对 EIP 的初始值加上一个基址寄存器的值，生成一个 32
位的地址 <code>0xFFFFFFF0</code>。之所以称为特殊行为，是因为实模式下 CPU
只能寻址 1MB 地址空间，而这个 32 位地址已经大于 1MB
的内存限制。因此，<code>0xFFFFFFF0</code> 也被称为重置向量（reset
vector），参考上图 <code>0xFFFFFFF0</code> 处的标识。</p>
<p>于是，CPU 开始执行 <code>0xFFFFFFF0</code>
地址处的指令，该地址处是一条 <code>JUMP</code>
指令，这条指令清空了基址寄存器的值，并让指令跳回到 BIOS
开始处（物理地址为 <code>0xF0000</code>，参考上图 <code>0xF0000</code>
处的标识）以执行 BIOS。</p>
<blockquote>
<p>BIOS 内部可以分成两个区块: code block（普通程序）、boot
block（引导程序）。上电后，boot block 会先被执行，它会检查 code block
的代码是否正确，如果正确，就会转到 code block 继续执行下去。</p>
</blockquote>
<h1 id="bios-初始化">BIOS 初始化</h1>
<p><code>0xF0000</code> 地址实际上是 BIOS 中的 boot block
的开始处。在这个阶段，会初始化部分硬件。系统的 CPU、USB
只有部分被初始化。</p>
<h1 id="bios-post加电自检">BIOS POST（加电自检）</h1>
<p>初始化完成后，CPU 跳转到 <code>0xA0000</code> 地址处（参考上图 640KB
处）进行 BIOS 加电自检（power on self test,
POST）。这个过程会检查计算机的各项组件，如
CPU、显卡、内存、鼠标、键盘等。如果找不到内存或者键盘都有可能让BIOS停止工作并且打印一些相关的错误信息，如果找不到显卡
BIOS 会发出蜂鸣警告（因为无法显示画面） 当 CPU 执行到
<code>0xC0000</code> 地址处（参考上图 768KB 处），开始寻找其他设备的
ROM，如果找到任何其他设备的 BIOS，它们也会被执行。 下一步，显卡就会显示
BIOS 界面，并进行更深入的检查。</p>
<h1 id="bios-记录系统设定值">BIOS 记录系统设定值</h1>
<p>检查完成后，BIOS
会根据自己的“系统资源表”，对系统进行进一步确认，从而确定计算机配有哪些资源或设备。例如
BIOS 支持随插即用，它会检测并配置随插即用设备。 然后 BIOS
会遵循高级配置电源接口（Advanced Configuration Power
Interface，ACPI）在内存中设置好一系列的数据来描述硬件信息，以便被操作系统内核利用。</p>
<h1 id="搜索-mbr">搜索 MBR</h1>
<p>到这一步，BIOS
开始尝试加载操作系统。它会从硬盘，光驱，软驱，网络等几个地方依次寻找操作系统（用户可以在
BIOS 设定中修改查找的优先级）。如果找不到操作系统，BIOS
会停机并给出错误信息。</p>
<p>假设在硬盘上找到了操作系统，它会首先读取硬盘上的大小为 512 Bytes 的
<strong>0号扇区</strong>，这个扇区被称为 <a
href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a>（master
boot record，MBR），其包含三部分：</p>
<ol type="1">
<li><strong>引导程序（Boot Loader）</strong></li>
<li><strong>硬盘分区表（Partition Table）</strong></li>
<li><strong>结束标志字</strong></li>
</ol>
<p>BIOS 读完磁盘上的 MBR 之后会把它拷贝到内存 <code>0x7C00</code>
地址处，然后 CPU 跳转到该内存地址执行 MBR
里的指令。事实上，被复制到物理内存的内容就是 Boot Loader。常见的 Boot
Loader 有 grub、lilo、spfdisk。下图可以帮助大家理解 MBR 的结构。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/computer-boot-mbr.png?x-oss-process=image/resize,w_800" /></p>
<p>关于磁盘、分区表等基础知识，可参见 <a
href="http://chuquan.me/2019/04/05/linux-disk-introduce/">计算机那些事(1)——磁盘</a>。</p>
<h1 id="boot-loader-执行">Boot Loader 执行</h1>
<p>以常见的 Linux Boot Loader —— grub 为例。</p>
<p>Grub 加载后首先进行 <strong>内存盘初始化</strong>。Boot Loader
会将存储介质中的 <code>initrd</code>
文件加载到内存，内核启动时会在访问真正的根文件系统之前先访问内存中的
<code>initrd</code> 文件系统。</p>
<blockquote>
<p>关于 initrd<br />
Linux
内核需要适应多种不同的硬件架构，但是将所有的硬件驱动编入内核是不切实际的，而且内核也不可能每新出一种硬件结构，就将该硬件的设备驱动写入内核。实际上，Linux
的内核镜像仅包含了基本的硬件驱动，在系统安装过程中检测系统的硬件信息，根据安装信息和系统硬件信息将一部分设备驱动写入
initrd（bootloader initialized RAM disk。</p>
</blockquote>
<p>内存盘初始化完毕之后， grub 会根据配置文件
<code>/boot/grub/grub.cfg</code> 设定的内核镜像 <code>vmlinuz</code>
所在的路径，加载内核镜像，并进行解压缩操作。此时，屏幕一般会出现
“Uncompressing Linux” 的提示。当解压缩内核完成后，屏幕一般会输出 “OK,
booting the kernel”。</p>
<p>内核加载至内存完成后，grub 将控制权转交给内核。</p>
<h1 id="内核启动">内核启动</h1>
<p>在 Boot Loader 配置了 initrd 的情况下，内核启动被分成了两个阶段：</p>
<ol type="1">
<li>执行 initrd 的文件系统中的 <code>init</code>
脚本。此阶段，内核会将控制权交给 <code>init</code>
文件处理。<code>init</code>
主要是加载各种存储介质相关的设备驱动。当所需的驱动程序加载完毕，就会创建一个根设备，然后将根文件系统
<code>rootfs</code>
以只读的方式挂载。这一步完成后，释放未使用的内存，并转换到真正的根文件系统中，进行第
2 阶段的处理。</li>
<li>执行真正的根文件系统中的 <code>/sbin/init</code> 进程，即系统的 1
号进程。此后，系统的控制权就全权交给 <code>/sbin/init</code>
进程了。</li>
</ol>
<h1 id="系统初始化">系统初始化</h1>
<p><code>/sbin/init</code>
进程是系统其它所有进程的父进程，当它接管了系统控制权后，它会根据
<code>/etc/inittab</code>
文件来执行相应的脚本，从而完成一系列的系统初始化操作。主要包括以下步骤：</p>
<ol type="1">
<li>设置运行等级。Linux 有运行等级如下：
<ul>
<li>0：关机</li>
<li>1：单用户模式</li>
<li>2：无网络支持的多用户模式</li>
<li>3：有网络支持的多用户模式</li>
<li>4：保留，未使用</li>
<li>5：有网络支持、有 X-Window 支持的多用户模式</li>
<li>6：重新引导系统，即重启</li>
</ul></li>
<li>执行 <code>rc.sysinit</code>。运行等级设置完成后，Linux
系统执行的第一个用户层文件是 <code>/etc/rc.d/rc.sysinit</code>
脚本程序，其完成的初始化操作主要包括：设置
<code>PATH</code>、设置网络配置<code>/etc/sysconfig/network</code>、启动
<code>swap</code> 分区、设置 <code>/proc</code> 等。</li>
<li>执行不同运行级别的脚本程序。根据运行级别的不同，系统会运行
<code>rc0.d</code> ~ <code>rc6.d</code>
中对应的脚本，从而完成对应的初始化工作，启动对应的服务。</li>
<li>执行 <code>/etc/rc.d/rc.local</code>。<code>rc.local</code> 是 Linux
运行用户进行个性化设置的脚本。</li>
<li>执行
<code>/bin/login</code>。进入登录状态。此时，系统已经进入到等待用户输入
<code>username</code> 和 <code>password</code> 的阶段。</li>
</ol>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="http://duartes.org/gustavo/blog/post/how-computers-boot-up/">How
Computers Boot Up</a></li>
<li><a
href="http://www.techbang.com/posts/4359">即将换掉传统BIOS的UEFI</a></li>
<li><a
href="http://roclinux.cn/?p=1301">Linux启动过程详解-《别怕Linux编程》之八</a></li>
<li>《Linux 系统架构与目录解析》</li>
<li><a href="http://smilejay.com/2011/10/initrd/">INITRD 详解</a></li>
<li><a
href="https://www.cnblogs.com/zhaopengcheng/p/5806379.html">inux中init.d文件夹的说明</a></li>
<li>Linux启动过程分析与优化，浙江大学硕士毕业论文</li>
<li><a
href="http://bbs.chinaunix.net/thread-835918-1-1.html">深入理解linux启动过程</a></li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>开机原理</tag>
        <tag>BIOS</tag>
        <tag>Linux 启动过程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(4)——ELF文件结构</title>
    <url>/2018/05/21/elf-introduce/</url>
    <content><![CDATA[<p><a
href="http://chuquan.me/2018/05/12/compiler-principle/#more">前文</a>结尾说到编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，而目标文件经过编译器链接之后得到的就是<strong>可执行文件</strong>。那么目标文件到底是什么？它和可执行文件又有什么区别？链接到底又做了什么呢？接下来，我们将探索一下目标文件的本质。</p>
<span id="more"></span>
<h1 id="目标文件的格式">目标文件的格式</h1>
<p>目前，PC平台流行的 <strong>可执行文件格式（Executable）</strong>
主要包含如下两种，它们都是 <strong>COFF（Common File Format）</strong>
格式的变种。</p>
<ul>
<li>Windows下的 <strong>PE（Portable Executable）</strong></li>
<li>Linux下的 <strong>ELF（Executable Linkable Format）</strong></li>
</ul>
<p><strong>目标文件就是源代码经过编译后但未进行链接的那些中间文件（Windows的<code>.obj</code>和Linux的<code>.o</code>），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储</strong>。在Windows下采用<strong>PE-COFF</strong>文件格式；Linux下采用<strong>ELF</strong>文件格式。</p>
<p>事实上，除了<strong>可执行文件</strong>外，<strong>动态链接库（DDL，Dynamic
Linking Library）</strong>、<strong>静态链接库（Static Linking
Library）</strong>
均采用可执行文件格式存储。它们在Window下均按照PE-COFF格式存储；Linux下均按照ELF格式存储。只是文件名后缀不同而已。</p>
<ul>
<li>动态链接库：Windows的<code>.dll</code>、Linux的<code>.so</code></li>
<li>静态链接库：Windows的<code>.lib</code>、Linux的<code>.a</code></li>
</ul>
<p>下面，我们将以ELF文件为例进行介绍。</p>
<h1 id="elf文件结构">ELF文件结构</h1>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-file-format.png" /></p>
<p><strong>注意：段（<code>Segment</code>）与节（<code>Section</code>）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</strong></p>
<p>如图所示，为ELF文件的基本结构，其主要由四部分组成：</p>
<ul>
<li>ELF Header</li>
<li>ELF Program Header Table (或称Program Headers、程序头)</li>
<li>ELF Section Header Table (或称Section Headers、节头表)</li>
<li>ELF Sections</li>
</ul>
<p>从图中，我们就能看出它们各自的数据结构以及相互之间的索引关系。下面我们依次进行介绍。</p>
<hr />
<h2 id="elf-header">ELF Header</h2>
<p>我们可以使用readelf工具来查看ELF Header。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -h hello.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          672 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure>
ELF文件结构示意图中定义的<code>Elf_Ehdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">成员</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">e_ident</td>
<td style="text-align: left;">Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00
00 00 00 00</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">Class: ELF32</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Data: 2's complement, little end</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">Version: 1(current)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">OS/ABI: UNIX - System V</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ABI Version: 0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e_type</td>
<td style="text-align: left;">Type: REL (Relocatable file)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ELF文件类型</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e_machine</td>
<td style="text-align: left;">Machine: Advanced Micro Devices
X86-64</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ELF文件的CPI平台属性</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e_version</td>
<td style="text-align: left;">Version: 0x1</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ELF版本号。一般为常数1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e_entry</td>
<td style="text-align: left;">Entry point address: 0x0</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td
style="text-align: left;"><strong>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位指令一般没有入口地址，则该值为0</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">e_phoff</td>
<td style="text-align: left;">Start of program headers: 0(bytes into
file)</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_shoff</td>
<td style="text-align: left;">Start of section headers: 672 (bytes into
file)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Section Header Table 在文件中的偏移</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_word</td>
<td style="text-align: left;">Flags: 0x0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td
style="text-align: left;">ELF标志位，用来标识一些ELF文件平台相关的属性。</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_ehsize</td>
<td style="text-align: left;">Size of this header: 64 (bytes)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">ELF Header本身的大小</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_phentsize</td>
<td style="text-align: left;">Size of program headers: 0 (bytes)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">e_phnum</td>
<td style="text-align: left;">Number of program headers: 0</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_shentsize</td>
<td style="text-align: left;">Size of section headers: 64 (bytes)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">单个Section Header大小</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_shnum</td>
<td style="text-align: left;">Number of section headers: 13</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Section Header的数量</td>
</tr>
<tr class="even">
<td style="text-align: left;">e_shstrndx</td>
<td style="text-align: left;">Section header string table index: 10</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">Section Header字符串表在Section Header
Table中的索引</td>
</tr>
</tbody>
</table>
<h3 id="elf魔数">ELF魔数</h3>
<p>每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，通常被称为<strong>魔数（Magic
Number）</strong>。通过对魔数的判断可以确定文件的格式和类型。如：ELF的可执行文件格式的头4个字节为<code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头4个字节为<code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是<code>#!/bin/sh</code>或<code>#!/usr/bin/perl</code>或<code>#!/usr/bin/python</code>，此时前两个字节<code>#</code>和<code>!</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。</p>
<h3 id="elf文件类型">ELF文件类型</h3>
<p>ELF文件主要有三种类型，可以通过ELF
Header中的<code>e_type</code>成员进行区分。</p>
<ul>
<li><strong>可重定位文件（Relocatable
File）</strong>：<code>ETL_REL</code>。一般为<code>.o</code>文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。</li>
<li><strong>可执行文件（Executable
File）</strong>：<code>ET_EXEC</code>。可以直接执行的程序。</li>
<li><strong>共享目标文件（Shared Object
File）</strong>：<code>ET_DYN</code>。一般为<code>.so</code>文件。有两种情况可以使用。
<ul>
<li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li>
<li>动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像。</li>
</ul></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png" /></p>
<h2 id="elf-section-header-table">ELF Section Header Table</h2>
<p>ELF
节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</strong></p>
<p>我们可以使用readelf工具来查看节头表。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -S hello.o</span><br><span class="line"></span><br><span class="line">There are 13 section headers, starting at offset 0x2a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000001f0</span><br><span class="line">       0000000000000030  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  00000055</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  00000062</span><br><span class="line">       0000000000000035  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000097</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000098</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000220</span><br><span class="line">       0000000000000018  0000000000000018   I      11     8     8</span><br><span class="line">  [10] .shstrtab         STRTAB           0000000000000000  00000238</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  000000d0</span><br><span class="line">       0000000000000108  0000000000000018          12     9     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  000001d8</span><br><span class="line">       0000000000000013  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></p>
<p>ELF文件结构示意图中定义的<code>Elf_Shdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">成员</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">sh_name</td>
<td style="text-align: left;">节名</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td
style="text-align: left;">节名是一个字符串，保存在一个名为<code>.shstrtab</code>的字符串表（可通过Section
Header索引到）。sh_name的值实际上是其节名字符串在<code>.shstrtab</code>中的偏移值</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sh_type</td>
<td style="text-align: left;">节类型</td>
</tr>
<tr class="even">
<td style="text-align: left;">sh_flags</td>
<td style="text-align: left;">节标志位</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sh_addr</td>
<td style="text-align: left;">节地址：节的虚拟地址</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td
style="text-align: left;">如果该节可以被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sh_offset</td>
<td style="text-align: left;">节偏移</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td
style="text-align: left;"><strong>如果该节存在于文件中，则表示该节在文件中的偏移；否则无意义，如sh_offset对于BSS
节来说是没有意义的</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">sh_size</td>
<td style="text-align: left;">节大小</td>
</tr>
<tr class="even">
<td style="text-align: left;">sh_link、sh_info</td>
<td style="text-align: left;">节链接信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">sh_addralign</td>
<td style="text-align: left;">节地址对齐方式</td>
</tr>
<tr class="even">
<td style="text-align: left;">sh_entsize</td>
<td style="text-align: left;">节项大小</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td
style="text-align: left;">有些节包含了一些固定大小的项，如符号表，其包含的每个符号所在的大小都一样的，对于这种节，sh_entsize表示每个项的大小。<strong>如果为0，则表示该节不包含固定大小的项。</strong></td>
</tr>
</tbody>
</table>
<h3 id="节类型sh_type">节类型（sh_type）</h3>
<p>节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）。</p>
<p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。常见的节类型如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">常量</th>
<th style="text-align: left;">值</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SHT_NULL</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">无效节</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_PROGBITS</td>
<td style="text-align: left;">1</td>
<td
style="text-align: left;"><strong>程序节</strong>。代码节、数据节都是这种类型。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_SYMTAB</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;"><strong>符号表</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_STRTAB</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;"><strong>字符串表</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_RELA</td>
<td style="text-align: left;">4</td>
<td
style="text-align: left;"><strong>重定位表</strong>。该节包含了重定位信息。</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_HASH</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;"><strong>符号表的哈希表</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_DYNAMIC</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">动态链接信息</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_NOTE</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">提示性信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_NOBITS</td>
<td style="text-align: left;">8</td>
<td
style="text-align: left;">表示该节在文件中没有内容。如<code>.bss</code>节</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_REL</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">该节包含了重定位信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_SHLIB</td>
<td style="text-align: left;">10</td>
<td style="text-align: left;">保留</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_DNYSYM</td>
<td style="text-align: left;">11</td>
<td style="text-align: left;"><strong>动态链接的符号表</strong></td>
</tr>
</tbody>
</table>
<h3 id="节标志位sh_flag">节标志位（sh_flag）</h3>
<p>节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以<code>SHF_</code>开头。常见的节标志位如下表所示：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">常量</th>
<th style="text-align: left;">值</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SHF_WRITE</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">表示该节在进程空间中可写</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHF_ALLOC</td>
<td style="text-align: left;">2</td>
<td
style="text-align: left;">表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHF_EXECINSTR</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">表示该节在进程空间中可以被执行</td>
</tr>
</tbody>
</table>
<h3 id="节链接信息sh_linksh_info">节链接信息（sh_link、sh_info）</h3>
<p>如果节的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的节，这两个成员没有意义。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">sh_type</th>
<th style="text-align: left;">sh_link</th>
<th style="text-align: left;">sh_info</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SHT_DYNAMIC</td>
<td
style="text-align: left;">该节所使用的<strong>字符串表</strong>在节头表中的下标</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_HASH</td>
<td
style="text-align: left;">该节所使用的<strong>符号表</strong>在节头表中的下标</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_REL</td>
<td
style="text-align: left;">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td>
<td style="text-align: left;">该重定位表所作用的节在节头表中的下标</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_RELA</td>
<td
style="text-align: left;">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td>
<td style="text-align: left;">该重定位表所作用的节在节头表中的下标</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SHT_SYMTAB</td>
<td style="text-align: left;">操作系统相关</td>
<td style="text-align: left;">操作系统相关</td>
</tr>
<tr class="even">
<td style="text-align: left;">SHT_DYNSYM</td>
<td style="text-align: left;">操作系统相关</td>
<td style="text-align: left;">操作系统相关</td>
</tr>
<tr class="odd">
<td style="text-align: left;">other</td>
<td style="text-align: left;">SHN_UNDEF</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="elf-sections">ELF Sections</h2>
<h3 id="节的分类">节的分类</h3>
<p>上述ELF Section Header
Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。</p>
<h4 id="text节">.text节</h4>
<p><code>.text</code>节是保存了程序代码指令的<strong>代码节</strong>。<strong>一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中</strong>。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h4 id="rodata节">.rodata节</h4>
<p><code>rodata</code>节保存了只读的数据，如一行C语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h4 id="plt节过程链接表">.plt节（过程链接表）</h4>
<p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage
Table）</strong>，<strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码</strong>。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h4 id="data节">.data节</h4>
<p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h4 id="bss节">.bss节</h4>
<p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本省的空间。<strong><code>.bss</code>节保存了未进行初始化的全局数据</strong>。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p>
<h4
id="got.plt节全局偏移表-过程链接表">.got.plt节（全局偏移表-过程链接表）</h4>
<p><code>.got</code>节保存了<strong>全局偏移表</strong>。<strong><code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改</strong>。由于<code>.got.plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h4 id="dynsym节动态链接符号表">.dynsym节（动态链接符号表）</h4>
<p><code>.dynsym</code>节保存在<code>text</code>段中。<strong>其保存了从共享库导入的动态符号表</strong>。节类型为<code>SHT_DYNSYM</code>。</p>
<h4 id="dynstr节动态链接字符串表">.dynstr节（动态链接字符串表）</h4>
<p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p>
<h4 id="rel.节重定位表">.rel.*节（重定位表）</h4>
<p>重定位表保存了重定位相关的信息，<strong>这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改</strong>。由于重定位表保存了重定位相关的数据，所以节类型为<code>SHT_REL</code>。</p>
<h4 id="hash节">.hash节</h4>
<p><code>.hash</code>节也称为<code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p>
<h4 id="symtab节符号表">.symtab节（符号表）</h4>
<p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p>
<h4 id="strtab节字符串表">.strtab节（字符串表）</h4>
<p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p>
<h4 id="ctors节和.dtors节">.ctors节和.dtors节</h4>
<p><code>.ctors</code>（<strong>构造器</strong>）节和<code>.dtors</code>（<strong>析构器</strong>）节分别保存了指向构造函数和析构函数的函数指针，<strong>构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码</strong>。</p>
<h3 id="符号表">符号表</h3>
<p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p>
<p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p>
<p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。<strong><code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号</strong>。如全局变量，代码中定义的本地函数等。</p>
<p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p>
<p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p>
<p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。<strong><code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号</strong>。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-symtab-strtab.png" /></p>
<p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">成员</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">st_name</td>
<td
style="text-align: left;">符号名。该值为该符号名在字符串表中的偏移地址。</td>
</tr>
<tr class="even">
<td style="text-align: left;">st_value</td>
<td
style="text-align: left;">符号对应的值。存放符号的值（可能是地址或位置偏移量）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">st_size</td>
<td style="text-align: left;">符号的大小。</td>
</tr>
<tr class="even">
<td style="text-align: left;">st_other</td>
<td style="text-align: left;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">st_shndx</td>
<td style="text-align: left;">符号所在的节</td>
</tr>
<tr class="even">
<td style="text-align: left;">st_info</td>
<td style="text-align: left;">符号类型及绑定属性</td>
</tr>
</tbody>
</table>
<p>使用readelf工具我们也能够看到符号表的相关信息。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -s hello.o</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串表">字符串表</h3>
<p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p>
<p>ELF文件中所有字符表的结构基本一致，如上图所示。</p>
<h3 id="重定位表">重定位表</h3>
<p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p>
<p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -r hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000005 R_X86_64_32       .rodata</span><br><span class="line">000000000000000a R_X86_64_PC32     puts-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p>
<p>重定位表是一个<code>Elf_Rel</code>类型的数组结构，每一项对应一个需要进行重定位的项。
其成员含义如下表所示：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">成员</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">r_offset</td>
<td style="text-align: left;">重定位入口的偏移。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td
style="text-align: left;">对于<strong>可重定位文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td
style="text-align: left;">对于<strong>可执行文件或共享对象文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td>
</tr>
<tr class="even">
<td style="text-align: left;">r_info</td>
<td style="text-align: left;">重定位入口的类型和符号</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td
style="text-align: left;">因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td
style="text-align: left;">对于<strong>可执行文件和共享目标文件</strong>来说，它们的重定位入口是动态链接类型的。</td>
</tr>
</tbody>
</table>
<p>重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>Executable and Linkable Format (ELF)</li>
<li>《Linux 二进制分析》</li>
<li>《深入理解计算机系统》</li>
<li>《程序员的自我修养——链接、装载与库》</li>
<li><a
href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
and Linkable Format</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>ELF文件</tag>
        <tag>目标文件</tag>
        <tag>可执行文件</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(6)——可执行文件的装载与运行</title>
    <url>/2018/06/17/executable-file-load-and-execution/</url>
    <content><![CDATA[<p>当我们在 Linux 的 bash 中输入命令执行某个 ELF
可执行文件时，如下所示。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./hello.out</span><br></pre></td></tr></table></figure>
<p>那么，Linux 系统是如何装载该 ELF
文件并执行的呢？这个过程可以分为以下这些步骤：</p>
<ul>
<li>创建新进程</li>
<li>检查可执行文件类型</li>
<li>搜索匹配装载处理过程</li>
<li>装载执行可执行文件</li>
</ul>
<h1 id="创建新进程">创建新进程</h1>
<p>首先在用户层面，bash 进程会调用 <code>fork()</code>
系统调用创建一个新的进程。其次，新的进程通过调用 <code>execve()</code>
系统调用来执行指定的 ELF 文件。原先的 bash
进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。</p>
<p><code>execve()</code> 系统调用被定义在
<code>unistd.h</code>，其原型如下所示。其中的三个参数分别对应被执行程序的
<strong>程序文件名</strong>、<strong>执行参数</strong>、<strong>环境变量</strong>。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure></p>
<h1 id="检查可执行文件类型">检查可执行文件类型</h1>
<p>当进入 <code>execve()</code> 系统调用之后，Linux
内核就开始进行真正的装载工作。在内核中，<code>execve()</code>
系统调用相应的入口是
<code>sys_execve()</code>。<code>sys_execve()</code>
进行一些参数的检查复制之后，调用
<code>do_execve()</code>。<code>do_execve()</code>
会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。</p>
<p>为什么要先读取文件的前 128 个字节？这是因为Linux支持的可执行文件不止
ELF 一种，还包括 <strong>a.out</strong>、<strong>Java
程序</strong>、<strong>以 <code>#!</code>
开头的脚本程序</strong>。<code>do_execve()</code>通过读取前 128
个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前4个字节，被称为
<strong>魔数（Magic Number）</strong>。比如：ELF的可执行文件格式的头 4
个字节为
<code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头
4 个字节为
<code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果是解释型语言的脚本，则第一行通常是
<code>#!/bin/sh</code> 或 <code>#!/user/bin/python</code>，其中
<code>#</code> 和 <code>!</code>
构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p>
<h1 id="搜索匹配装载处理过程">搜索匹配装载处理过程</h1>
<p>当 <code>do_execve()</code> 读取了128个字节的文件头部之后，调用
<code>search_binary_handle()</code>
去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux
中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，<code>search_binary_handler()</code>
会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.</p>
<ul>
<li>ELF 可执行文件：<code>load_elf_binary()</code></li>
<li>a.out 可执行文件：<code>load_aout_binary()</code></li>
<li>可执行脚本程序：<code>load_script()</code></li>
</ul>
<h1 id="装载执行可执行文件">装载执行可执行文件</h1>
<p>以 ELF 的装载处理过程 <code>load_elf_binary()</code>
为例，其所包含的步骤如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-load-process.png" /></p>
<ol type="1">
<li>操作系统读取可执行文件 ELF 的
<code>Header</code>，检查文件的有效性。</li>
<li>操作系统读取可执行文件 ELF的 <code>Program Header Table</code>
中读取每个 <code>Segment</code> 的虚拟地址、文件地址、属性等。</li>
<li>操作系统根据 <code>Program Header Table</code> 将可执行文件 ELF
映射至内存。</li>
<li>如果是静态链接的情况，则直接跳转至第 7
步；如果是动态链接的情况，操作系统将查找 <code>.interp</code> 节，找到
<strong>动态链接器（Dynamic Linker）</strong>
的位置，并启动动态链接器。在 Linux 下，动态链接器 <code>ld.so</code>
是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。</li>
<li>动态链接器获得控制权后，开始执行一系列初始化操作。</li>
<li>动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。</li>
<li>控制权被转交到可执行文件的入口地址，程序开始正式执行。</li>
</ol>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《程序员的自我修养——链接、装载与库》</li>
<li>《深入理解计算机系统》</li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>装载</tag>
        <tag>静态链接</tag>
        <tag>动态链接</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 状态管理实践</title>
    <url>/2020/06/06/flutter-state-management-action/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ui-equals-function-of-state.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>iOS 和 Android
的原生开发模式是命令式编程模式。命令式编程要求开发者一步步描述整个构建过程，从而引导程序去构建用户界面。</p>
<p>Flutter
则采用了声明式编程模式，框架隐藏了具体的构建过程，开发者只需要声明状态，框架会自动构建用户界面。这也就意味着
Flutter 构建的用户界面就是当前的状态。</p>
<h1 id="状态管理">状态管理</h1>
<p>App
在运行中总是会更新用户界面，因此我们需要对状态进行有效的管理。状态管理本质上就是
<strong>如何解决状态读/写的问题</strong>。对此，我们将从两个方面去评估状态管理方案：</p>
<ul>
<li><strong>状态访问</strong></li>
<li><strong>状态更新</strong></li>
</ul>
<p>此外，根据 Flutter 原生支持的情况，我们将 Flutter
状态管理方案分为两类：</p>
<ul>
<li><strong>Flutter 内置的状态管理方案</strong></li>
<li><strong>基于 Pub 的状态管理方案</strong></li>
</ul>
<p>下文，我们将以 Flutter 官方的计数器例子来介绍 Flutter
中的状态管理方案，并逐步进行优化。</p>
<p>关于本文涉及的源码，见<a
href="https://github.com/baochuquan/state_manager_demo">【Demo
传送门】</a>。</p>
<h2 id="flutter-内置的状态管理方案">Flutter 内置的状态管理方案</h2>
<h3 id="直接访问-直接更新">直接访问 + 直接更新</h3>
<p>Flutter 模板工程就是【直接访问 +
直接更新】的状态管理方案。这种方案的状态访问/更新示意图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-direct.png?x-oss-process=image/resize,w_800" /></p>
<p>很显然，【直接访问 + 直接更新】方案只适合于在单个
<code>StatefulWidget</code> 中进行状态管理。那么对于多层级的 Widget
结构该如何进行状态管理呢？</p>
<h3 id="状态传递-闭包传递">状态传递 + 闭包传递</h3>
<p>对于多层级的 Widget 结构，状态是无法直接访问和更新的。因为 Widget 和
State 是分离的，并且 State 一般都是私有的，所以子 Widget
是无法直接访问/更新父 Widget 的 State。</p>
<p>对于这种情况，最直观的状态管理方案就是：【状态传递 +
闭包传递】。对于状态访问，父 Widget 在创建子 Widget 时就将状态传递给子
Widget；对于状态更新，父 Widget 将更新状态的操作封装在闭包中，传递给子
Widget。</p>
<p>这里存在一个问题：当 Widget 树层级比较深时，如果中间有些 Widget
并不需要访问或更新父 Widget 的状态时，这些中间 Widget
仍然需要进行辅助传递。很显然，这种方案在 Widget
树层级较深时，效率比较低，只适合于较浅的 Widget 树层级。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-state-block.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="状态传递-notification">状态传递 + Notification</h3>
<p>那么如何优化多层级 Widget
树结构下的状态管理方案呢？我们首先从状态更新方面进行优化。</p>
<p>【状态传递 + Notification】方案采用 Notification
定向地优化了状态更新的方式。</p>
<p>通知（Notification）是 Flutter 中一个重要的机制，在 Widget
树种，每个节点都可以分发通知，通知会沿着当前节点向上传递，所有父节点都可以通过
<code>NotificationListener</code> 来监听通知。Flutter
中将这种由子向父的传递通知的机制称为
<strong>通知冒泡</strong>（Notification
Bubbling）。通知冒泡和用户触摸事件冒泡是相似的，但有一点不同：<strong>通知冒泡可以中止，而用户触摸事件无法中止</strong>。</p>
<p>下图所示为这种方案的状态访问/更新示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-state-notification.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的实现源码如下所示：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与 父 Widget 绑定的 State</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PassStateNotificationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">PassStateNotificationDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 父 Widget 使用 NotificationListener 监听通知</span></span><br><span class="line">    <span class="keyword">return</span> NotificationListener&lt;IncrementNotification&gt;(</span><br><span class="line">      onNotification: (notification) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _incrementCounter();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// true: 阻止冒泡；false: 继续冒泡</span></span><br><span class="line">      &#125;,</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        ...</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子 Widget</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IncrementButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IncrementButton(<span class="keyword">this</span>.counter);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">        onTap: () =&gt; IncrementNotification(<span class="string">&quot;加一操作&quot;</span>).dispatch(context),   <span class="comment">// 点击按钮触发通知派发</span></span><br><span class="line">        child: ...)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义通知</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> msg;</span><br><span class="line">  IncrementNotification(<span class="keyword">this</span>.msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="inheritedwidget-notification">InheritedWidget +
Notification</h3>
<p>【传递传递 +
Notification】方案定向优化了状态的更新，那么如何进一步优化状态的访问呢？</p>
<p>【InheritedWidget + Notification】方案采用
<code>InhertiedWidget</code> 实现了在多层级 Widget
树中直接访问状态的能力。</p>
<p><code>InheritedWidget</code> 是 Flutter
中非常重要的一个功能型组件，其提供了一种数据在 Widget
树中从上到下传递、共享的方式。这与 Notification
的传递方向正好相反。我们在父 Widget 中通过 <code>InheritedWidget</code>
共享一个数据，那么任意子 Widget 都能够直接获取到共享的数据。</p>
<p>下图所示为这种方案的状态访问/更新示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-inherited-notification.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的源码实现如下所示：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">与父 Widget 绑定的 State</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedWidgetNotificationDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InheritedWidgetNotificationDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CounterInheritedWidget(</span><br><span class="line">      counter: _counter,</span><br><span class="line">      child: NotificationListener&lt;IncrementNotification&gt;(</span><br><span class="line">        onNotification: (notification) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            _incrementCounter();</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// true: 阻止冒泡；false: 继续冒泡</span></span><br><span class="line">        &#125;,</span><br><span class="line">        child: Scaffold(</span><br><span class="line">                ...</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子 Widget</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IncrementButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  _IncrementButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 直接获取状态</span></span><br><span class="line">    <span class="keyword">final</span> counter = CounterInheritedWidget.of(context).counter;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">        onTap: () =&gt; IncrementNotification(<span class="string">&quot;加一&quot;</span>).dispatch(context),   <span class="comment">// 派发通知</span></span><br><span class="line">        child: ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">对使用自定义的 InheritedWidget 子类对状态进行封装</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要在子树中共享的数据，保存点击次数</span></span><br><span class="line">  CounterInheritedWidget(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.counter, Widget child&#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个便捷方法，方便子树中的widget获取共享数据</span></span><br><span class="line">  <span class="keyword">static</span> CounterInheritedWidget of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;CounterInheritedWidget&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(CounterInheritedWidget old) &#123;</span><br><span class="line">    <span class="comment">// 如果返回true，则子树中依赖(build函数中有调用)本widget</span></span><br><span class="line">    <span class="comment">// 的子widget的`state.didChangeDependencies`会被调用</span></span><br><span class="line">    <span class="keyword">return</span> old.counter != counter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="inheritedwidget-eventbus">InheritedWidget + EventBus</h3>
<p>虽然【InheritedWidget +
Notification】方案在状态访问和状态更新方面都进行了优化，但是从其状态管理示意图上看，状态的更新仍然具有优化空间。</p>
<p>【InheritedWidget + EventBus】方案则采用了
<strong>事件总线</strong>（Event Bus）的方式管理状态更新。</p>
<p>事件总线是 Flutter
中的一种全局广播机制，可以实现跨页面事件通知。事件总线通常是一种订阅者模式，其包含发布者和订阅者两种角色。</p>
<p>【InheritedWidget + EventBus】方案将子 Widget 作为发布者，父 Widget
作为订阅者。当子 Widget 进行状态更新时，则发出事件，父 Widget
监听到事件后进行状态更新。</p>
<p>下图所示为这种方案的状态访问/更新示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-inherited-event.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的源码实现如下所示：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">与父 Widget 绑定的状态</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedWidgetEventBusDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InheritedWidgetEventBusDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 订阅事件</span></span><br><span class="line">    bus.<span class="keyword">on</span>(EventBus.incrementEvent, (_) &#123;</span><br><span class="line">      _incrementCounter();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    bus.off(EventBus.incrementEvent);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子 Widget</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IncrementButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  _IncrementButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> counter = CounterInheritedWidget.of(context).counter;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">        onTap: () =&gt; bus.emit(EventBus.incrementEvent), <span class="comment">// 发布事件</span></span><br><span class="line">        child: ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种方案的对比">两种方案的对比</h4>
<p>【InheritedWidget + Notification】和【InheritedWidget +
EventBus】的区别主要在于状态更新。两者对于状态的更新其实并没有达到最佳状态，都是通过一种间接的方式实现的。</p>
<p>相比而言，事件总线是基于全局，逻辑难以进行收敛，并且还要管理监听事件、取消订阅。从这方面而言，【InheritedWidget
+ Notification】方案更优。</p>
<p>从状态管理示意图而言，显然【InheritedWidget +
Notification】还有进一步的优化空间。这里，我们可能会想：状态能否直接提供更新方法，当子
Widget 获取到状态后，直接调用状态的更新方法呢？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p>
<p>对此，官方推荐了一套基于第三方 Pub 的 Provider 状态管理方案。</p>
<h2 id="基于-pub-的状态管理方案">基于 Pub 的状态管理方案</h2>
<h3 id="provider">Provider</h3>
<p>【Provider】的本质是 <strong>基于 <code>InheritedWidget</code> 和
<code>ChangeNotifier</code>
进行了封装</strong>。此外，使用缓存提升了性能，避免不必要的重绘。</p>
<p>下图所示为这种方案的状态访问/更新示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-provider.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的源码实现如下所示：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">与父 Widget 绑定的 State</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ProviderDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ProviderDemoPage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ChangeNotifierProvider&lt;CounterProviderState&gt;(</span><br><span class="line">      create: (_) =&gt; CounterProviderState(),    <span class="comment">// 创建状态</span></span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(widget.title),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(</span><br><span class="line">                <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">              ),</span><br><span class="line">              <span class="comment">// 使用 provider 提供的 builder 使用状态</span></span><br><span class="line">              Consumer&lt;CounterProviderState&gt;(builder: (context, counter, _) =&gt; Text(<span class="string">&quot;<span class="subst">$&#123;counter.value&#125;</span>&quot;</span>, style: Theme.of(context).textTheme.display1)),</span><br><span class="line">              _IncrementButton(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子 Widget</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IncrementButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  _IncrementButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 访问状态</span></span><br><span class="line">    <span class="keyword">final</span> _counter = Provider.of&lt;CounterProviderState&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">        onTap: () =&gt; _counter.incrementCounter(),   <span class="comment">// 更新状态</span></span><br><span class="line">        child: ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义的状态，继承自 ChangeNotifier</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterProviderState</span> <span class="title">with</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态提供的更新方法</span></span><br><span class="line">  <span class="keyword">void</span> incrementCounter() &#123;</span><br><span class="line">    _counter++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Flutter 社区早期使用的 Scoped Model 方案与 Provider
的实现原理基本是一致的。</p>
</blockquote>
<h3 id="redux">Redux</h3>
<p>对于声明式（响应式）编程中的状态管理，Redux
是一种常见的状态管理方案。【Redux】方案的状态管理示意图与【Provider】方案基本上是一致的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-provider.png?x-oss-process=image/resize,w_800" /></p>
<p>在这个基础上，<strong>Redux
对于状态更新的过程进行了进一步的细分和规划</strong>，使得其数据的流动过程如下所示。</p>
<ul>
<li>所有的状态都存储在 Store 中。一般会把 Store 放在 App 顶层。</li>
<li>View 获取 Store 中存储的状态。</li>
<li>当事件发生时，发出一个 action。</li>
<li>Reducer 接收到 action，遍历 action 表，找到匹配的 action，根据
action 生成新的状态存储到 Store 中。</li>
<li>Store 存储新状态后，通知依赖该状态的 view 更新。</li>
</ul>
<p>一个 Store 存储多个状态，适合用于全局状态管理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/redux-pattern.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的实现源码如下所示。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">与父 Widget 绑定的 State</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ReduxDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ReduxDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 Store，该过程包括了对 State 的初始化</span></span><br><span class="line">  <span class="keyword">final</span> store = Store&lt;CounterReduxState&gt;(reducer, initialState: CounterReduxState.initState());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> StoreProvider&lt;CounterReduxState&gt;(</span><br><span class="line">      store: store,</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(widget.title),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(</span><br><span class="line">                <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">              ),</span><br><span class="line">              <span class="comment">// 通过 StoreConnector 访问状态</span></span><br><span class="line">              StoreConnector&lt;CounterReduxState, <span class="built_in">int</span>&gt;(</span><br><span class="line">                converter: (store) =&gt; store.state.value,</span><br><span class="line">                builder: (context, count) &#123;</span><br><span class="line">                  <span class="keyword">return</span> Text(<span class="string">&quot;<span class="subst">$count</span>&quot;</span>, style: Theme.of(context).textTheme.display1);</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">              _IncrementButton(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子 Widget</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IncrementButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  _IncrementButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> StoreConnector&lt;CounterReduxState, VoidCallback&gt;(</span><br><span class="line">      converter: (store) &#123;</span><br><span class="line">        <span class="keyword">return</span> () =&gt; store.dispatch(Action.increment);  <span class="comment">// 发出 Action 以进行状态更新</span></span><br><span class="line">      &#125;,</span><br><span class="line">      builder: (context, callback) &#123;</span><br><span class="line">        <span class="keyword">return</span> GestureDetector(</span><br><span class="line">            onTap: callback,</span><br><span class="line">            child: StoreConnector&lt;CounterReduxState, <span class="built_in">int</span>&gt;(</span><br><span class="line">              converter: (store) =&gt; store.state.value,</span><br><span class="line">              builder: (context, count) &#123;</span><br><span class="line">                <span class="keyword">return</span> ...;</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义状态</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterReduxState</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; _counter;</span><br><span class="line"></span><br><span class="line">  CounterReduxState(<span class="keyword">this</span>._counter);</span><br><span class="line"></span><br><span class="line">  CounterReduxState.initState() &#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义 Action</span></span></span><br><span class="line"><span class="keyword">enum</span> Action&#123;</span><br><span class="line">  increment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义 Reducer</span></span></span><br><span class="line">CounterReduxState reducer(CounterReduxState state, <span class="built_in">dynamic</span> action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action == Action.increment) &#123;</span><br><span class="line">    <span class="keyword">return</span> CounterReduxState(state.value + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bloc">BLoC</h3>
<p>【BLoC】方案是谷歌的两位工程师 Paolo Soares 和 Cong Hui
提出的一种状态管理方案，其状态管理示意图同样与【Provider】方案是一致的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/state-manage-of-provider.png?x-oss-process=image/resize,w_800" /></p>
<p>【BLoC】方案的底层实现与【Provider】是非常相似的，也是基于
<code>InheritedWidget</code>
进行状态访问，并且对状态进行了封装，从而提供直接更新状态的方法。</p>
<p>但是，BLoC 的核心思想是
<strong>基于流来管理数据</strong>，并且将业务逻辑均放在 BLoC
中进行，从而实现视图与业务的分离。</p>
<ul>
<li>BLoC 使用 Sink 作为输入，使用 Stream 作为输出。</li>
<li>BLoC 内部会对输入进行转换，产生特定的输出。</li>
<li>外部使用 StreamBuilder 监听 BLoC 的输出（即状态）。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/bloc-pattern.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的实现源码如下所示。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">与父 Widget 绑定的 State</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocDemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocDemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 创建状态</span></span><br><span class="line">  <span class="keyword">final</span> bloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 以 InheritedWidget 的方式提供直接方案</span></span><br><span class="line">    <span class="keyword">return</span> BlocProvider(</span><br><span class="line">      bloc: bloc,</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(widget.title),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(</span><br><span class="line">                <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">              ),</span><br><span class="line">              <span class="comment">// 状态访问</span></span><br><span class="line">              StreamBuilder&lt;<span class="built_in">int</span>&gt;(stream: bloc.value, initialData: <span class="number">0</span>, builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">&quot;<span class="subst">$&#123;snapshot.data&#125;</span>&quot;</span>, style: Theme.of(context).textTheme.display1);</span><br><span class="line">              &#125;,),</span><br><span class="line">              _IncrementButton(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子 Widget</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_IncrementButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  _IncrementButton();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">        onTap: () =&gt; BlocProvider.of(context).increment(),  <span class="comment">// 状态更新</span></span><br><span class="line">        child: ClipOval(child: Container(width: <span class="number">50</span>, height: <span class="number">50</span>, alignment: Alignment.center,color: Colors.blue, child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(stream: BlocProvider.of(context).value, initialData: <span class="number">0</span>, builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot) &#123;</span><br><span class="line">          <span class="comment">// 状态访问</span></span><br><span class="line">          <span class="keyword">return</span> Text(<span class="string">&quot;<span class="subst">$&#123;snapshot.data&#125;</span>&quot;</span>, textAlign: TextAlign.center,style: TextStyle(fontSize: <span class="number">24</span>, color: Colors.white));</span><br><span class="line">        &#125;,),),)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义 BLoC Provider，继承自 InheritedWidget </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CounterBloc bloc;</span><br><span class="line"></span><br><span class="line">  BlocProvider(&#123;<span class="keyword">this</span>.bloc, Key key, Widget child&#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_) =&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> CounterBloc of(BuildContext context) =&gt; (context.inheritFromWidgetOfExactType(BlocProvider) <span class="keyword">as</span> BlocProvider).bloc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义的状态</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController;</span><br><span class="line"></span><br><span class="line">  CounterBloc() &#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _counterController = StreamController&lt;<span class="built_in">int</span>&gt;.broadcast();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> value =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  increment() &#123;</span><br><span class="line">    _counterController.sink.add(++_counter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispose() &#123;</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>一般而言，对于普通的项目来说【Provider】方案是一种非常容易理解，并且实用的状态管理方案。</p>
<p>对于大型的项目而言，【Redux】
有一套相对规范的状态更新流程，但是模板代码会比较多；对于重业务的项目而言，【BLoC】能够将复杂的业务内聚到
BLoC 模块中，实现业务分离。</p>
<p>总之，各种状态管理方案都有着各自的优缺点，这些需要我们在实践中去发现和总结，从而最终找到一种适合自己项目的状态管理方案。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/options">状态
(State) 管理参考</a></li>
<li><a
href="https://juejin.im/post/5bac54c45188255c681589d3#heading-5">[译]让我来帮你理解和选择Flutter状态管理方案</a></li>
<li><a
href="https://juejin.im/post/5cd91bb0f265da034e7eaca3#heading-4">Flutter状态管理
- 初探与总结</a></li>
<li><a href="https://juejin.im/post/5b97fa0d5188255c5546dcf8">Flutter |
状态管理探索篇——Scoped Model（一）</a></li>
<li><a href="https://juejin.im/post/5ba26c086fb9a05ce57697da">Flutter |
状态管理探索篇——Redux（二）</a></li>
<li><a href="https://juejin.im/post/5bb6f344f265da0aa664d68a">Flutter |
状态管理探索篇——BLoC（三）</a></li>
<li>《Flutter 实战》</li>
<li><a
href="https://juejin.im/post/5baa4b90e51d450e6d00f12e#heading-13">Dart |
什么是Stream</a></li>
<li><a href="https://dart.cn/tutorials/language/streams">异步编程：使用
stream</a></li>
<li><a href="https://www.bilibili.com/video/av55808989/">使用 Flutter
构建响应式移动应用</a></li>
<li><a
href="https://juejin.im/post/5b6cfcade51d451915575b7b#heading-15">Flutter入门三部曲(3)
- 数据传递/状态管理 | 掘金技术征文</a></li>
</ol>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>状态管理</tag>
        <tag>Provider</tag>
        <tag>BLoC</tag>
        <tag>Redux</tag>
        <tag>InheritedWidget</tag>
        <tag>Notification</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（1）——线性代数</title>
    <url>/2024/01/15/foundation-of-computer-graphic-01/</url>
    <content><![CDATA[<p>最近对计算机图形学比较感兴趣，刷了一遍《计算机图形学入门：3D渲染指南》，看了一遍《GAMES
101》。本文对计算机图形学的线性代数相关基础进行了梳理和总结，以便后续进行复习和回顾。</p>
<span id="more"></span>
<h1 id="点">点</h1>
<p><strong>点</strong>（Point）表示坐标系中的一个特定位置，其具体表示和抽象表示分别如下。</p>
<ul>
<li>使用 <strong>大写字母</strong> 的方式来抽象表示一个点，如：<span
class="math inline">\(P\)</span>。</li>
<li>使用 <strong>圆括号 + 数字序列</strong>
的方式来具体表示一个点，如：<span class="math inline">\((4,
3)\)</span>。</li>
</ul>
<p>在具体表示中，数字序列的顺序很重要。按照惯例，在 2D 平面中依次表示
<span class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span> 轴的值；在 3D 空间中依次表示 <span
class="math inline">\(x\)</span>、<span
class="math inline">\(y\)</span>、<span class="math inline">\(z\)</span>
轴的值。对此，我们也可以结合两种方式来表示一个抽象的点，比如：<span
class="math inline">\((P_x, P_y)\)</span>。</p>
<h1 id="向量">向量</h1>
<p><strong>向量</strong>（Vector）表示两个点所构成线段的长度和方向，其具体表示和抽象表示分别如下。</p>
<ul>
<li>向量的抽象表示一般有三种，分别是：
<ul>
<li>使用 <strong>小写字母 + 箭头上标</strong> 的方式，如：<span
class="math inline">\(\vec{a}\)</span>。</li>
<li>使用 <strong>加粗小写字母</strong> 的方式，如：<span
class="math inline">\(\textbf{a}\)</span>。</li>
<li>使用 <strong>两个点 + 箭头上标</strong> 的方式，如：<span
class="math inline">\(\overrightarrow{AB} = B -
A\)</span>。注：大写字母表示点。</li>
</ul></li>
<li>向量的具体表示中，默认以坐标原点作为起点，因此只需要描述终点即可。向量一般使用矩阵来表示，包含两种方式，分别是：</li>
</ul>
<span class="math display">\[\begin{aligned}
列向量表示法：&amp;
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right)
\\
行向量表示法：&amp;
\left(
\begin{matrix}
x &amp; y
\end{matrix}
\right)
\end{aligned}\]</span>
<p>在定义中我们提到向量包含了两个点之间的长度和方向两种信息。对此，我们可以各自使用一种方式来表示这两种信息。</p>
<ul>
<li>使用 <strong>小写字母 + <code>^</code> 上标</strong> 的方式表示
<strong>单位向量</strong>（Unit Vector），即长度等于 1 的向量，如：<span
class="math inline">\(\widehat{a}\)</span>。一般用来表示方向。</li>
<li>使用 <strong>向量 + 双竖线</strong> 的方式表示
<strong>向量长度</strong>（Vector Length），如：<span
class="math inline">\(|\vec{a}|\)</span>。</li>
</ul>
<p>单位向量可以通过向量除以向量长度的方式计算得到，如下所示。</p>
<span class="math display">\[\begin{aligned}
\widehat{a} = \vec{a} / |\vec{a}|
\end{aligned}\]</span>
<p>在计算机图形学中，单位向量的应用非常多，比如：法线向量。在计算光线的折射和反射时，法线必不可少。</p>
<h2 id="向量的加减运算">向量的加减运算</h2>
<p>向量的加减运算可以使用 <strong>平行四边形法则</strong> 或
<strong>三角形法则</strong> 进行计算，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-01.png?x-oss-process=image/resize,w_800" /></p>
<p>向量的加减运算非常简单，只需要把两个向量的对应坐标的值进行加减运算即可，如下所示。</p>
<span class="math display">\[\begin{aligned}
\vec{a} + \vec{b}
=
\left(
\begin{matrix}
a_x &amp; a_y
\end{matrix}
\right)
+
\left(
\begin{matrix}
b_x &amp; b_y
\end{matrix}
\right)
=
\left(
\begin{matrix}
a_x + b_x &amp; a_y + b_y
\end{matrix}
\right)
\\
\vec{a} - \vec{b}
=
\left(
\begin{matrix}
a_x &amp; a_y
\end{matrix}
\right)
-
\left(
\begin{matrix}
b_x &amp; b_y
\end{matrix}
\right)
=
\left(
\begin{matrix}
a_x - b_x &amp; a_y - b_y
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="向量的乘法运算">向量的乘法运算</h2>
<p>向量的乘法运算比较特殊，它有两种乘法运算，分别是：</p>
<ul>
<li><strong>点积</strong>（Dot Product），或称
<strong>点乘</strong></li>
<li><strong>叉积</strong>（Cross Product），或称
<strong>叉乘</strong></li>
</ul>
<h3 id="点积">点积</h3>
<p>两个向量之间的点积是一个数值，一般使用 <strong>点运算符</strong>
表示。</p>
<p>点积的运算非常简单，只要将每个向量对应的坐标值相乘并求和即可，如下所示为一个点积的示例。</p>
<span class="math display">\[\begin{aligned}
\vec{a} \cdot \vec{b}
=
\left(
\begin{matrix}
a_x &amp; a_y &amp; a_z
\end{matrix}
\right)
\left(
\begin{matrix}
b_x \\
b_y \\
b_z \\
\end{matrix}
\right)
=
a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z
\end{aligned}\]</span>
<p>向量点积的特性</p>
<ul>
<li>符合交换律，即 <span class="math inline">\(\vec{a} \cdot \vec{b} =
\vec{b} \cdot \vec{a}\)</span></li>
<li>符合分配律，即 <span class="math inline">\(\vec{a} \cdot (\vec{b} +
\vec{c}) = \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}\)</span></li>
<li>不符合结合律。点乘的结果是一个标量，不是向量，因此无法与另一个向量继续进行点乘运算。</li>
</ul>
<p>在计算机图形学中，点积的应用非常广泛，主要包括：</p>
<ul>
<li><strong>计算两个向量之间的夹角</strong></li>
<li><strong>计算一个向量在另一个向量上的投影</strong></li>
<li><strong>计算一个向量正交分解后的两个向量</strong></li>
<li><strong>判断一个向量相对于另一个向量是正向还是反向</strong></li>
</ul>
<p>下面，我们来看一下这几种应用是如果通过计算实现的。</p>
<p>首先，如何计算两个向量之间的夹角？在几何上，两个向量的点积与它们的长度以及它们之间的夹角
<span class="math inline">\(a\)</span>
有关，确切的公式巧妙地将线性代数和三角函数联系在了一起，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-02.png?x-oss-process=image/resize,w_800" /></p>
<span class="math display">\[\begin{aligned}
\vec{a} \cdot \vec{b} =&amp; |\vec{a}| \cdot |\vec{b}| \cdot cos\theta
\\
cos\theta =&amp; \frac{\vec{a} \cdot \vec{b}}{|\vec{a}| \cdot |\vec{b}|}
\\
cos\theta =&amp; \widehat{a} \cdot \widehat{b}
\end{aligned}\]</span>
<p>其次，如何计算一个向量在另一个向量上的投影？如下所示，求向量 <span
class="math inline">\(\vec{b}\)</span> 在向量 <span
class="math inline">\(\vec{a}\)</span> 上的投影 <span
class="math inline">\(\vec{b}_\bot\)</span>，很显然，<span
class="math inline">\(\vec{b}_\bot\)</span> 与 <span
class="math inline">\(\vec{a}\)</span>
的方向是一致的，只是长度可能不同。因此，我们可以通过前面提到的方式计算两者之间的夹角，然后计算投影长度，并使用该长度乘以单位向量
<span class="math inline">\(\widehat{a}\)</span> 即可。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-03.png?x-oss-process=image/resize,w_800" /></p>
<span class="math display">\[\begin{aligned}
\vec{b}_\bot =&amp; k \cdot \widehat{a}
\\
k =&amp; |\vec{b_\bot}| = |\vec{b}| \cdot cos\theta = |\vec{b}| \cdot
\widehat{a} \cdot \widehat{b}
\\
\end{aligned}\]</span>
<p>接着，如何计算一个向量正交分解后的两个向量？上面我们在计算一个向量在另一个向量上的投影时，已经计算得到了一个方向的分解向量，另一个方向的分解向量我们只需通过向量减法即可得到，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-04.png?x-oss-process=image/resize,w_800" /></p>
<p>最后，如何判断一个向量相对于另一个向量是正向还是反向？判断两个向量的方向关系，本质上是看两者之间的夹角，如果是锐角，则认为是正向，如果是钝角，则认为是反向，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-05.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="叉积">叉积</h3>
<p>两个向量之间的叉积是一个向量，一般使用 <strong>叉乘符号</strong>
表示。</p>
<p>叉积是一个垂直于两个向量的向量，其方向可以通过
<strong>右手螺旋定则</strong> 确定。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-06.png?x-oss-process=image/resize,w_800" /></p>
<span class="math display">\[\begin{aligned}
\vec{c}
= &amp;
\vec{a} \times \vec{b}
\\
= &amp;
\left(
\begin{matrix}
a_x &amp; a_y &amp; a_z
\end{matrix}
\right)
\left(
\begin{matrix}
b_x \\
b_y \\
b_z \\
\end{matrix}
\right)
\\
= &amp;
\left(
\begin{matrix}
a_y \cdot b_z - a_z \cdot b_y \\
a_z \cdot b_x - a_x \cdot b_z \\
a_x \cdot b_y - a_y \cdot b_x \\
\end{matrix}
\right)
\\
即：
\\
c_x =&amp; a_y \cdot b_z - a_z \cdot b_y
\\
c_y =&amp; a_z \cdot b_x - a_x \cdot b_z
\\
c_z =&amp; a_x \cdot b_y - a_y \cdot b_x
\end{aligned}\]</span>
<p>向量叉积的特性</p>
<ul>
<li>符合分配律，即 <span class="math inline">\(\vec{a} \times (\vec{b} +
\vec{c}) = \vec{a} \times \vec{b} + \vec{a} \times \vec{c}\)</span></li>
<li>不符合结合律，即 <span class="math inline">\((\vec{a} \times
\vec{b}) \times \vec{c} \neq \vec{a} \times (\vec{b} \times
\vec{c})\)</span></li>
<li>不符合交换律，即 <span class="math inline">\(\vec{a} \times \vec{b}
\neq \vec{b} \times \vec{a}\)</span></li>
</ul>
<p>在计算机图形学中，乘积的应用主要包括一下这些：</p>
<ul>
<li><strong>判断一个向量相对于另一个向量的左右关系</strong></li>
<li><strong>判断一个向量相对于一个三角形的内外关系</strong></li>
</ul>
<p>那么，如何判断一个向量相对于另一个向量的左右关系？可以直接判断两个向量叉积的正负值。如下所示，在一个
3D 坐标中，<span class="math inline">\(\vec{a}\)</span> 和 <span
class="math inline">\(\vec{b}\)</span>
的叉乘符合右手螺旋定则的方向（图中与 Y 轴方向相同），则表示 <span
class="math inline">\(\vec{A}\)</span> 在 <span
class="math inline">\(\vec{B}\)</span> 的右边，反之则表示 <span
class="math inline">\(\vec{A}\)</span> 在 <span
class="math inline">\(\vec{B}\)</span> 的左边。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-07.png?x-oss-process=image/resize,w_800" /></p>
<p>以及，如何判断一个向量相对于一个三角形的内外关系？事实上，我们可以利用上面这种左右关系判断的方法来组合判断。如下所示，我们可以分别判断
<span class="math inline">\(\overrightarrow{AP}\)</span> 和 <span
class="math inline">\(\overrightarrow{AB}\)</span> 的左右关系，<span
class="math inline">\(\overrightarrow{BP}\)</span> 和 <span
class="math inline">\(\overrightarrow{BC}\)</span> 的左右关系，<span
class="math inline">\(\overrightarrow{CP}\)</span> 和 <span
class="math inline">\(\overrightarrow{CA}\)</span>
的左右关系，如果前者都在后者的一边（左边或右边），那么 <span
class="math inline">\(P\)</span> 就在三角形内；否则，在三角形外。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-08.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="矩阵">矩阵</h1>
<p>矩阵是一个 <span class="math inline">\(m\)</span> 行 <span
class="math inline">\(n\)</span> 列的数字阵列，通常我们使用一个
<strong>加粗的大写字母</strong>
抽象表示一个矩阵。在计算机图形学中，它被广泛应用于各种变换计算中，比如：平移、旋转、缩放等。</p>
<h2 id="矩阵的乘法运算">矩阵的乘法运算</h2>
<p>矩阵的乘法必须满足一个前提：矩阵 <span
class="math inline">\(A\)</span> 的列数等于矩阵 <span
class="math inline">\(B\)</span> 的行数，即
<code>(M x N)(N x P) = (M x P)</code>。</p>
<p>矩阵 <span class="math inline">\(A\)</span> 乘以矩阵 <span
class="math inline">\(B\)</span> 得到矩阵 <span
class="math inline">\(C\)</span>，其中矩阵 <span
class="math inline">\(C\)</span> 中的任意元素 <code>(i, j)</code>
的值等于 <span class="math inline">\(A\)</span> 中第 <code>i</code> 行与
<span class="math inline">\(B\)</span> 中第 <code>j</code>
列的点积，如下所示是一个矩阵乘法的示例。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
1 &amp; 3 \\
5 &amp; 2 \\
0 &amp; 4 \\
\end{matrix}
\right)

\left(
\begin{matrix}
3 &amp; 6 &amp; 9 &amp; 4 \\
2 &amp; 7 &amp; 8 &amp; 3 \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
9 &amp; 27 &amp; 33 &amp; 13 \\
19 &amp; 44 &amp; 61 &amp; 26 \\
8 &amp; 28 &amp; 32 &amp; 12 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>矩阵乘法的特性</p>
<ul>
<li>不符合交换律，即 <span class="math inline">\(AB \neq
BA\)</span></li>
<li>符合分配律，即 <span class="math inline">\(A(B + C) = AB +
BA\)</span></li>
<li>符合结合律，即 <span class="math inline">\((AB)C =
A(BC)\)</span></li>
</ul>
<p>在计算机图形学中，向量也会使用矩阵（行矩阵或列矩阵）来表示，向量之间的乘法以及向量与矩阵的乘法都符合矩阵乘法的基本规则。</p>
<h2 id="矩阵的转置运算">矩阵的转置运算</h2>
<p>矩阵的转置本质上就是沿着主对角线（从左上角至右下角）的对角线将 i x j
的矩阵翻转成 j x i 的矩阵。一般我们使用一个 <strong>上标 T</strong>
表示一个矩阵的转置，如：<span class="math inline">\(A^T\)</span>。</p>
<p>如下所示，是一个矩阵转置运算的示例。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
1 &amp; 2 \\
3 &amp; 4 \\
5 &amp; 6 \\
\end{matrix}
\right)^T

=

\left(
\begin{matrix}
1 &amp; 3 &amp; 5 \\
2 &amp; 4 &amp; 6 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>矩阵转置的特性</p>
<ul>
<li><span class="math inline">\((AB)^T = B^TA^T\)</span></li>
</ul>
<h2 id="矩阵的类型">矩阵的类型</h2>
<p>下面，我们来介绍各种不同类型的矩阵。</p>
<h3 id="对角矩阵">对角矩阵</h3>
<p>对角矩阵，其主对角线（从左上角到右下角）上的元素都是非
0，其他元素都为 0。</p>
<h3 id="单位矩阵">单位矩阵</h3>
<p>单位矩阵，其主对角线（从左上角到右下角）上的元素都为 1，其余元素都为
0，一般使用大写字母 <span class="math inline">\(I\)</span>
来表示。单位矩阵是一个特殊的对角矩阵。如下所示，是一个单位矩阵实例。</p>
<span class="math display">\[\begin{aligned}
I_{3 \times 3}
=
\left(
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h3 id="逆矩阵">逆矩阵</h3>
<p>给定一个矩阵 <span
class="math inline">\(A\)</span>，如果存在一个与之维度相同的矩阵，使得这两个矩阵相乘的结果是一个单位矩阵，那么我们称这个矩阵为矩阵
<span class="math inline">\(A\)</span> 的逆矩阵，使用 <span
class="math inline">\(A^{-1}\)</span>
表示。如下所示，为逆矩阵的示例。</p>
<span class="math display">\[\begin{aligned}
A A^{-1} =&amp; A^{-1}A = I
\\
(AB)^{-1} =&amp; B^{-1}A^{-1}
\end{aligned}\]</span>
<h2 id="矩阵的应用">矩阵的应用</h2>
<p>上述我们介绍的向量的两种运算，其实完全可以使用矩阵的乘法来实现。</p>
<p>关于向量的点积，我们可以使用如下矩阵乘法来表示。</p>
<span class="math display">\[\begin{aligned}
\vec{a} \cdot \vec{b}
=
\vec{a}^T \cdot \vec{b}
=
\left(
\begin{matrix}
a_x &amp; a_y &amp; a_z
\end{matrix}
\right)
\left(
\begin{matrix}
b_x \\
b_y \\
b_z \\
\end{matrix}
\right)
=
a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z
\end{aligned}\]</span>
<p>关于向量的叉积，我们可以使用如下矩阵乘法来表示，如下所示。其中 <span
class="math inline">\(A^*\)</span> 为矩阵 <span
class="math inline">\(A\)</span> 的对偶矩阵。</p>
<span class="math display">\[\begin{aligned}
\vec{a} \times \vec{b}
=
A^* b
=
\left(
\begin{matrix}
0    &amp; -a_z &amp; a_y \\
a_z  &amp; 0    &amp; -a_x \\
-a_y &amp; a_x  &amp; 0 \\
\end{matrix}
\right)

\left(
\begin{matrix}
b_x \\
b_y \\
b_z \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
a_y \cdot b_z - a_z \cdot b_y \\
a_z \cdot b_x - a_x \cdot b_z \\
a_x \cdot b_y - a_y \cdot b_x \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h1 id="总结">总结</h1>
<p>本文介绍了点、向量、矩阵的基本定义和运算方法。向量的乘法包含两种：点积和叉积，两者被广泛应用在了在计算机图形学中。</p>
<p>点积和叉积的具体运算可以通过矩阵运算来实现，这也是为什么我们常说计算机图形学中包含了大量矩阵运算。</p>
<p>下文，我们将探讨矩阵在图形的变换中的应用，敬请期待吧~</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
<li>《计算机图形学入门：3D渲染指南》</li>
<li><a
href="https://blog.csdn.net/weixin_42782150/article/details/104878759">史上最全Markdown公式、符号总结</a></li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>向量</tag>
        <tag>矩阵</tag>
        <tag>点积</tag>
        <tag>叉积</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（2）——变换</title>
    <url>/2024/01/18/foundation-of-computer-graphic-02/</url>
    <content><![CDATA[<p>上一篇<a
href="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">文章</a>我们介绍了计算机图形学中的线性代数基础，包括：点、向量、矩阵等。本文，我们将介绍向量和矩阵的进一步应用——变换。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>计算机图形学中，我们可能会对图形进行各种变换（Transform），如：</p>
<ul>
<li>缩放（Scale）</li>
<li>平移（Transation）</li>
<li>旋转（Rotation）</li>
<li>切变（Shear）</li>
</ul>
<h1 id="d-变换">2D 变换</h1>
<p>首先，我们来介绍一下 2D
变换，以便了解变换是如何通过矩阵变换来实现的。</p>
<h2 id="缩放变换">缩放变换</h2>
<p>对于缩放变换，它主要包含两种：等比例缩放、非等比缩放。</p>
<h3 id="等比例缩放">等比例缩放</h3>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-01.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为等比例缩放的示意图。根据等比例缩放的规则，我们可以根据缩放前
<span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p>
<span class="math display">\[\begin{aligned}
x&#39; =&amp; sx \\
y&#39; =&amp; sy \\
\end{aligned}\]</span>
<p>根据此关系式，我们可以进一步推导出缩放矩阵及关系式，如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39;
\end{matrix}
\right)
=
\left(
\begin{matrix}
s &amp; 0 \\
0 &amp; s \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right)
\end{aligned}\]</span>
<h3 id="非等比缩放">非等比缩放</h3>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-02.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为非等比缩放的示意图。根据非比缩放的规则，我们可以根据缩放前
<span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的值，得到另一组关系式，如下所示。</p>
<span class="math display">\[\begin{aligned}
x&#39; =&amp; s_xx \\
y&#39; =&amp; s_yy \\
\end{aligned}\]</span>
<p>根据此关系式，我们可以进一步推导出缩放矩阵及关系式，如下所示。对比一下，非等比缩放与等比例缩放的关系式非常相似。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
s_x &amp; 0 \\
0 &amp; s_y \\
\end{matrix}
\right)

\left(
\begin{matrix}
x \\
y \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="镜像变换">镜像变换</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-03.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为镜像变换的示意图。我们可以根据原始的 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p>
<span class="math display">\[\begin{aligned}
x&#39; =&amp; -x \\
y&#39; =&amp; y \\
\end{aligned}\]</span>
<p>根据此关系式，我们可以进一步推导出镜像矩阵及关系式，如下所示。本质上，镜像变换是一种特殊的缩放变换。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
-1 &amp; 0 \\
0 &amp; 1 \\
\end{matrix}
\right)

\left(
\begin{matrix}
x \\
y
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="切变变换">切变变换</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-04.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为切变变换的示意图。切变变换相对复杂一点，其 <span
class="math inline">\(y\)</span> 坐标值与 <span
class="math inline">\(x\)</span>
坐标值成一个比例关系。不过，我们仍然可以根据原始的 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p>
<span class="math display">\[\begin{aligned}
x&#39; =&amp; x + ay \\
y&#39; =&amp; y \\
\end{aligned}\]</span>
<p>根据此关系式，我们可以进一步推导出镜像矩阵及关系式，如下所示。本质上，镜像变换是一种特殊的缩放变换。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
1 &amp; a \\
0 &amp; 1 \\
\end{matrix}
\right)

\left(
\begin{matrix}
x \\
y \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="旋转变换">旋转变换</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-05.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为旋转变换的示意图。旋转变换的坐标推导需要借助三角函数，最终可得到如下一组关系式。</p>
<span class="math display">\[\begin{aligned}
x&#39; = cos{\theta}x - sin{\theta}y \\
y&#39; = sin{\theta}x + cos{\theta}y \\
\end{aligned}\]</span>
<p>根据此关系式，我们可以进一步推导出旋转矩阵及关系式，如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
cos\theta &amp; -sin\theta \\
sin\theta &amp; cos\theta \\
\end{matrix}
\right)

\left(
\begin{matrix}
x \\
y \\
\end{matrix}
\right)

\end{aligned}\]</span>
<h2 id="平移变换">平移变换</h2>
<p>截止目前位置，所有的的变换都可以通过推导得出一个变换矩阵，以此矩阵乘以任意点（以矩阵表示），都可以得到转换后的点（以矩阵表示），符合线性变换。</p>
<p>下面，我们来看一下比较特殊的平移变换。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-06.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为平移变换的示意图，同样，我们也可以可得到如下一组关系式。</p>
<span class="math display">\[\begin{aligned}
x&#39; = x + t_x \\
y&#39; = y + t_y \\
\end{aligned}\]</span>
<p>但是，我们进一步推导，得到的关系式与之前的变换不同，它有额外的偏移量，不符合线性变换，如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
1 &amp; 0 \\
0 &amp; 1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
\end{matrix}
\right)
+
\left(
\begin{matrix}
t_x \\
t_y \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>我们总是希望能使用一个统一的关系式来描述各种变换，然而，平移变换打破了我们的美好预期。那么该如何解决呢？为此，我们引入了齐次坐标。</p>
<h1 id="齐次坐标">齐次坐标</h1>
<p>为了能够统一表示所有变换，我们引入了
<strong>齐次坐标</strong>（Homogenous
Coordinates）。这里的核心思想是为每一个点或向量添加一个额外的 <span
class="math inline">\(w\)</span> 坐标。</p>
<span class="math display">\[\begin{aligned}
2D 点的齐次坐标表示：
\left(
\begin{matrix}
x \\
y \\
1
\end{matrix}
\right)
\\
\\
2D 向量的齐次坐标表示：
\left(
\begin{matrix}
x \\
y \\
0 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>此时，我们再来尝试推导平移变换矩阵以及其关系式，可以得到如下所示内容。很显然，原来关系式中的偏移量没有了。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
w&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y \\
0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
1 \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
x+t_x \\
y+t_y \\
1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="仿射变换与线性变换">仿射变换与线性变换</h2>
<p>我们将线性变换和平移变换的组合，称为
<strong>仿射变换</strong>（Affine
Transform），如下所示。在未引入齐次坐标之前，我们推导出来的平移变换就是一种仿射变换。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
a &amp; b \\
c &amp; d \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
\end{matrix}
\right)
+
\left(
\begin{matrix}
t_x \\
t_y \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>当引入齐次坐标之后，所有的变换都可以统一使用线性变换来表示，如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
1 \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
a &amp; b &amp; t_x \\
c &amp; d &amp; t_y \\
0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>如下所示，是引入齐次坐标后，缩放变换，旋转变换，平移变换所对应的变换矩阵。</p>
<span class="math display">\[\begin{aligned}
缩放变换：&amp;
S(s_x, s_y) =
\left(
\begin{matrix}
s_x &amp; 0 &amp; 0 \\
0 &amp; s_y &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\\
\\
旋转变换：&amp;
R(\alpha) =
\left(
\begin{matrix}
cos\alpha &amp; -sin\alpha &amp; 0 \\
sin\alpha &amp; cos\alpha &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\\
\\
平移变换：&amp;
T(t_x, t_y) =
\left(
\begin{matrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y \\
0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h1 id="逆变换">逆变换</h1>
<p>我们将所有的反向变换都称为 <strong>逆变换</strong>（Inverse
Transform），比如：我们将从 A 平移到 B 称为平移变换，那么从 B 平移到 A
则可称为逆变换，其他的缩放变换、旋转变换同样如此。</p>
<p>上一节，我们引入了齐次坐标后，所有的变换都可以转换成线性变换，其中以
<span class="math inline">\(M\)</span>
为变换矩阵。而这些变换的逆变换，同样可以使用线性变换来表示，并以 <span
class="math inline">\(M\)</span> 的逆矩阵 <span
class="math inline">\(M^{-1}\)</span> 为变换矩阵。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-07.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="组合变换">组合变换</h1>
<p>在真实情况下，我们遇到的变换大多数都是组合变换，也就是同时包含了缩放、旋转、平移等多种变换。</p>
<p>多种变换组合时，变换的顺序其实是非常重要的，我们以如下一个例子来进行介绍。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-08.png?x-oss-process=image/resize,w_800" /></p>
<p>对于上面这种变换，如果我们先平移，再旋转，那么最终会变成如下所示的。这里的根本原因在于旋转变换时，仍然是以坐标原点为锚点进行旋转。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-09.png?x-oss-process=image/resize,w_800" /></p>
<p>对此，正确的顺序应该是先旋转，后平移，这样才能达到预期的效果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-10.png?x-oss-process=image/resize,w_800" /></p>
<p>不同的顺序，矩阵变换的结果完全不同。前一篇文章我们提到过矩阵乘法不符合交换律，从这一点其实也能够解释这个现象。</p>
<p>在实际开发中，遇到这种类似的情况，我们一般都会先将目标平移至原点，然后进行各种其他变换，然后再通过逆变换平移回去。</p>
<h1 id="d-变换-1">3D 变换</h1>
<p>关于 3D 变换，本质上与 2D
变换一样，只不过在矩阵表示上多了一个维度而已。</p>
<p>当我们引入齐次坐标之后，3D 的点和向量可以采用如下方式表示。</p>
<span class="math display">\[\begin{aligned}
3D点的齐次坐标表示：&amp;
\left(
\begin{matrix}
x \\
y \\
z \\
1 \\
\end{matrix}
\right)
\\
\\
3D向量的齐次坐标表示：&amp;
\left(
\begin{matrix}
x \\
y \\
z \\
0 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>与此对应，3D 变换的矩阵变换关系式为如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39; \\
z&#39; \\
1 \\
\end{matrix}
\right)

=

\left(
\begin{matrix}
a &amp; b &amp; c &amp; t_x \\
d &amp; e &amp; f &amp; t_y \\
g &amp; h &amp; i &amp; t_z \\
0 &amp; 0 &amp; 0 &amp;1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
z \\
1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="缩放变换-1">缩放变换</h2>
<p>如下所示，为 3D 空间中的缩放变换的变换矩阵的定义。</p>
<span class="math display">\[\begin{aligned}
S(s_x, s_y, s_z)

=

\left(
\begin{matrix}
s_x &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; s_y &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; s_z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="平移变换-1">平移变换</h2>
<p>如下所示，为 3D 空间中的平移变换的变换矩阵的定义。</p>
<span class="math display">\[\begin{aligned}
T(t_x, t_y, t_z)

=

\left(
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; 0 &amp; t_y \\
0 &amp; 0 &amp; 1 &amp; t_z \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h2 id="旋转变换-1">旋转变换</h2>
<p>如下所示，为 3D
空间中的旋转变换的变换矩阵的定义，沿着不同的轴旋转，变换矩阵的定义也有所不同。</p>
<span class="math display">\[\begin{aligned}
R_x(\alpha)

=

\left(
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; cos\alpha &amp; -sin\alpha &amp; 0 \\
0 &amp; sin\alpha &amp; cos\alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\\
\\
R_y(\alpha)

=

\left(
\begin{matrix}
cos\alpha &amp; 0 &amp; sin\alpha &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
-sin\alpha &amp; 0 &amp; cos\alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\\
\\
R_z(\alpha)

=

\left(
\begin{matrix}
cos\alpha &amp; -sin\alpha &amp; 0 &amp; 0 \\
sin\alpha &amp; cos\alpha &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h1 id="总结">总结</h1>
<p>本文我们简单梳理了一下缩放、旋转、平移几种变换对应的矩阵关系式。其中，平移变换比较特殊，为了能够统一关系式，我们引入了齐次坐标，在点、向量的矩阵表示中增加了一个维度。然后，我们介绍了一下在组合变换中变换顺序的重要性。最后，我们简单总结了
3D 变换的矩阵关系式。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
<li>《计算机图形学入门：3D渲染指南》</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>缩放变换</tag>
        <tag>平移变换</tag>
        <tag>旋转变换</tag>
        <tag>切变变换</tag>
        <tag>仿射变换</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（3）——观测变换</title>
    <url>/2024/03/23/foundation-of-computer-graphic-03/</url>
    <content><![CDATA[<p>上一篇文章我们介绍了计算机图形学中的数学基础，包括：2D 变换、3D
变换、齐次坐标等。本文，我们则来介绍将三维模型投影到二维屏幕的数学原理。</p>
<span id="more"></span>
<h1 id="观测变换">观测变换</h1>
<p>我们将三维模型投影到二维屏幕的过程称之为
<strong>观测变换</strong>（Viewing Transformation）。</p>
<p>事实上，观测变换和我们平时拍照一样，总体可以分成三个步骤：</p>
<ul>
<li>摆放物体。在图形学中称为 <strong>模型变换</strong>（Model
Transformation）</li>
<li>摆放相机。在图形学中称为 <strong>视图变换</strong>（View
Transformation）</li>
<li>拍照。在图形学中称为 <strong>投影变换</strong>（Project
Transformation）</li>
</ul>
<p>根据这三个步骤的英文缩写，观测变换也可以称为 <strong>MVP
变换</strong>。不过在图形学中，并不是严格按照这个顺序来执行的，而是先进行视图变换，再进行模型变换。至于为什么，我们稍后再解释。</p>
<p>下面，我们来分别介绍这三种变换。</p>
<h1 id="视图变换">视图变换</h1>
<p>视图变换也称为相机变换（Camera
Transformation），视图的内容本质上是由相机的位置决定的，因此这里我们真正要做的是相机变换。</p>
<p>首先，我们使用如下三个向量来描述相机的
<strong>原始位置</strong>，从而唯一确定其位置、观测方向、画面方向。</p>
<ul>
<li>位置：<span class="math inline">\(\vec{e}\)</span></li>
<li>观测方向：<span class="math inline">\(\hat{g}\)</span></li>
<li>向上方向：<span class="math inline">\(\hat{t}\)</span></li>
</ul>
<p>为了方便后续的计算，我们将相机放置到空间坐标系的原点，具体如下：</p>
<ul>
<li>位置：原点坐标</li>
<li>观测方向：<code>-Z</code></li>
<li>向上方向：<code>Y</code></li>
</ul>
<p>这里我们将变换后的观测方向设置为
<code>-Z</code>，而在有些渲染引擎中观测方向为
<code>Z</code>。这主要取决于空间坐标系的定义，本文我们使用的是右手坐标系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="如何变换">如何变换？</h2>
<p>那么具体我们该如何进行变换呢？一种非常直观的方法，按照四个步骤进行变换：</p>
<ul>
<li>将 <span class="math inline">\(\vec{e}\)</span> 平移变换至原点</li>
<li>将 <span class="math inline">\(\hat{g}\)</span> 旋转变换至
<code>-Z</code></li>
<li>将 <span class="math inline">\(\hat{t}\)</span> 旋转变换至
<code>Y</code></li>
<li>将 <span class="math inline">\(\hat{g} \times \hat{t}\)</span>
旋转变换至 <code>X</code></li>
</ul>
<p>很显然，变换矩阵为平移变换和旋转变换的组合，即 <span
class="math inline">\(M_{view} =
R_{view}T_{view}\)</span>。其中，我们很容易就能求解平移变换的变换矩阵，如下。</p>
<span class="math display">\[\begin{aligned}
T_{view}
=
\left(
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -x_e \\
0 &amp; 1 &amp; 0 &amp; -y_e \\
0 &amp; 0 &amp; 1 &amp; -z_e \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>这里的难点在于求解几个旋转变换的变换矩阵 <span
class="math inline">\(R_{view}\)</span>。那么，该如何求解呢？这里我们转换一下思路，考虑将位于原点的目标位置逆向转换至原始位置。通过这种方式我们可以得到
<span class="math inline">\(R_{view}\)</span> 的逆矩阵 <span
class="math inline">\(R_{view}^{-1}\)</span>。具体求解过程如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
? &amp; ? &amp; ? &amp; 0 \\
? &amp; ? &amp; ? &amp; 0 \\
? &amp; ? &amp; ? &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
1 \\
0 \\
0 \\
0 \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
x_{\hat{g} \times \hat{t}} \\
y_{\hat{g} \times \hat{t}} \\
z_{\hat{g} \times \hat{t}} \\
0 \\
\end{matrix}
\right)

\\
\\

\left(
\begin{matrix}
? &amp; ? &amp; ? &amp; 0 \\
? &amp; ? &amp; ? &amp; 0 \\
? &amp; ? &amp; ? &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
0 \\
1 \\
0 \\
0 \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
x_{t} \\
y_{t} \\
z_{t} \\
0 \\
\end{matrix}
\right)

\\
\\

\left(
\begin{matrix}
? &amp; ? &amp; ? &amp; 0 \\
? &amp; ? &amp; ? &amp; 0 \\
? &amp; ? &amp; ? &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\left(
\begin{matrix}
0 \\
0 \\
1 \\
0 \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
x_{-g} \\
y_{-g} \\
z_{-g} \\
0 \\
\end{matrix}
\right)

\\
\\
解得：
R_{view}^{-1}
= &amp;
\left(
\begin{matrix}
x_{\hat{g} \times \hat{t}} &amp; x_{t} &amp; x_{-g} &amp; 0 \\
y_{\hat{g} \times \hat{t}} &amp; y_{t} &amp; y_{-g} &amp; 0 \\
z_{\hat{g} \times \hat{t}} &amp; z_{t} &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>由于旋转矩阵是正交矩阵，所以旋转矩阵的逆矩阵就是它的转置矩阵。由此得到：</p>
<span class="math display">\[\begin{aligned}
R_{view}
=
\left(
\begin{matrix}
x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp;
z_{\hat{g} \times \hat{t}} &amp; 0 \\
x_{t} &amp; y_{t} &amp; z_{t} &amp; 0 \\
x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h1 id="模型变换">模型变换</h1>
<p>根据相对性原理，相机完成了特定的变换后，我们也需要对模型进行同样的变换，这样通过相机投影得到的画面才会相对不变。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-02.png?x-oss-process=image/resize,w_800" /></p>
<p>根据上述的相机变换，我们得到了对应的变换矩阵。根据此变换矩阵，我们再对空间中的所有模型进行变换，即完成了模型变换。之后，我们即可进行投影变换。</p>
<p>由模型和相机要进行相同的变换，因此也将模型变换和视图变换统称为
<strong>模型视图变换</strong>（ModelView Transformation）。</p>
<h1 id="投影变换">投影变换</h1>
<p>投影变换本质上就是将 3D 模型投影到 2D
画布的过程，具体可以分为两种：</p>
<ul>
<li>正交投影（Orthographic
Projection）：一般用于工程制图软件，不具有近大远小的透视效果。</li>
<li>透视投影（Perspective
Projection）：一般用于游戏引擎、渲染引擎，模拟真实的效果。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-03.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，正交投影可以认为是一种特殊的透视投影，即相机位于无限远的位置，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-04.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="正交投影">正交投影</h2>
<p>下面，我们先来介绍一下正交投影的两种方法。</p>
<h3 id="方法一">方法一</h3>
<p>方法一非常直观，即丢弃 Z 坐标，直接转换成二维坐标系，然后再将其缩放至
<span class="math inline">\([-1, 1]^2\)</span>
的矩形区域，如下所示。为什么要缩放至 <span class="math inline">\([-1,
1]^2\)</span>
的矩形区域？事实上，这也是为了方便后续计算，是一种约定俗成的做法。当然，这种方式也存在一个问题，无法直接判断模型之间的远近关系，这个我们后续再讨论。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-05.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="方法二">方法二</h3>
<p>不过，更普遍的做法是方法二，包括后续的透视投影也采用了这种方法。</p>
<p>方法二提出了一个 <strong>观测空间</strong>（View
Volumne）的概念，这一点非常重要。对于正交投影，它的观测空间是一个无限长的长方体，其中以
2D 画布为近面，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-09.png?x-oss-process=image/resize,w_800" /></p>
<p>由于 2D
画布可能是任意比例的矩形，为了方便计算，我们将这个长方体的观测空间转换成成一个规范立方体（Canonical
Cube），即 <span class="math inline">\([-1, 1]^3\)</span> 的空间。</p>
<p>在将观测空间转换成规范立方体的过程中，我们会组合平移、缩放等变换，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-06.png?x-oss-process=image/resize,w_800" /></p>
<p>很显然，要将模型转换成标准立方体，我们必须计算出变换矩阵 <span
class="math inline">\(M_{ortho}\)</span>。由于投影变换不涉及旋转，因此变换矩阵相对而言比较容易求解，如下所示。</p>
<span class="math display">\[\begin{aligned}
M_{ortho}
=
S_{ortho}T_{ortho}
=
\left(
\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)

\left(
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\
0 &amp; 0 &amp; 1  &amp; -\frac{n+f}{2} \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>在将观测空间转换成规范立方体的过程中，我们计算得到了变换矩阵 <span
class="math inline">\(M_{ortho}\)</span>。根据相对不变性原理，我们要使用
<span class="math inline">\(M_{ortho}\)</span>
对空间中所有物体进行同样的变换。这个过程，这里我们不再赘述。</p>
<h2 id="透视投影">透视投影</h2>
<p>透视投影则借鉴了正交投影的做法，只不过相对而言，它多了一步压缩过程，也就是说，透视投影
= 压缩 + 正交投影。</p>
<p>下面，我们重点介绍一下压缩。</p>
<h3 id="压缩">压缩</h3>
<p>透视投影不同于正交投影，它的观测空间是一个无限长的纺锤体，其中以 2D
画布为近面，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-10.png?x-oss-process=image/resize,w_800" /></p>
<p>压缩的本质就是将透视投影的观测空间压缩成正交投影的观测空间，即将纺锥体转换成长方体。然后，透视投影就换转化成了正交投影了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-11.png?x-oss-process=image/resize,w_800" /></p>
<!--模型压缩本质上并不是真正对模型进行压缩，而是一种透视压缩。如下图所示，透视投影将空间中的一个点投影到一个 2D 的画布上，坐标点 `(x, y, z)` 中 `x` 和 `y` 的值会产生压缩效应，变成 `x'` 和 `y'`。-->
<!--![](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-07.png?x-oss-process=image/resize,w_800)-->
<!--因此，我们可以想像画布上的投影点和空间点构成一个纺椎体，然后对这个纺椎体进行压缩，如下图所示。`(x, y, z)` 经过压缩后会变成 `(x', y', z)`，再经过正交投影后会得到 `(x', y', z')`。-->
<p>那么，我们该如何求解压缩变换的变换矩阵 <span
class="math inline">\(M_{persp-&gt;ortho}\)</span> 呢？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-07.png?x-oss-process=image/resize,w_800" /></p>
<p>首先，由相似三角形定理，如上图所示，我们可以得出：</p>
<span class="math display">\[\begin{aligned}
y^{&#39;}
=
\frac{n}{z}y
;
x^{&#39;}
=
\frac{n}{z}x
\end{aligned}\]</span>
<p>然后，我们基于齐次坐标，结合三角形定理，计算得出投影点的坐标：</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x^{&#39;} \\
y^{&#39;} \\
z^{&#39;} \\
1 \\
\end{matrix}
\right)
=
\left(
\begin{matrix}
nx/z \\
ny/z \\
? \\
1 \\
\end{matrix}
\right)
=
\left(
\begin{matrix}
nx \\
ny \\
? \\
z \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>接下来，我们准备求解变换矩阵 <span
class="math inline">\(M_{persp-&gt;ortho}^{4 \times
4}\)</span>，得出一下关系式：</p>
<span class="math display">\[\begin{aligned}
M_{persp-&gt;ortho}
\left(
\begin{matrix}
x \\
y \\
z \\
1 \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
nx \\
ny \\
? \\
z \\
\end{matrix}
\right)
\\
解得：
M_{persp-&gt;ortho}
= &amp;
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
? &amp; ? &amp; ? &amp; ? \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>最后，我们来求解第三行的值。我们基于两个以下两个依据：</p>
<ul>
<li>近平面上的点的值不会变化，即 2D 画布上的值不变。</li>
<li>远平面上的点 Z 坐标不会变化。</li>
</ul>
<p>根据第一个依据，我们可以得出以下关系式。即将 <code>z</code> 替换成
<code>n</code>。</p>
<span class="math display">\[\begin{aligned}
M_{persp-&gt;ortho}
\left(
\begin{matrix}
x \\
y \\
z \\
1 \\
\end{matrix}
\right)
=
M_{persp-&gt;ortho}
\left(
\begin{matrix}
x \\
y \\
n \\
1 \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
x \\
y \\
n \\
1 \\
\end{matrix}
\right)
=
\left(
\begin{matrix}
nx \\
ny \\
n^2 \\
n \\
\end{matrix}
\right)
\\
推导：
\left(
\begin{matrix}
? &amp; ? &amp; ? &amp; ? \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
n \\
1 \\
\end{matrix}
\right)
= &amp;
n^2
\\
解得：
\left(
\begin{matrix}
? &amp; ? &amp; ? &amp; ? \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
0 &amp; 0 &amp; ? &amp; ? \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>我们使用 <code>(0, 0, A, B)</code> 抽象表示
<code>(0, 0, ?, ?)</code>。根据两条依据，我们可以得到一个二元一次方程组，如下所示。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
0 &amp; 0 &amp; A &amp; B \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
n \\
1 \\
\end{matrix}
\right)
= &amp;
n^2
=&gt; &amp;
An + B = n^2

\\

\left(
\begin{matrix}
0 &amp; 0 &amp; A &amp; B \\
\end{matrix}
\right)
\left(
\begin{matrix}
0 \\
0 \\
f \\
1 \\
\end{matrix}
\right)
= &amp;
\left(
\begin{matrix}
0 \\
0 \\
f^2 \\
f \\
\end{matrix}
\right)
=&gt; &amp;
Af + B = f^2

\\
解得：
A
= &amp;
n + f
\\
B
= &amp;
-nf
\end{aligned}\]</span>
<p>综上述，求解得出压缩变换的变换矩阵如下所示，其中 f
是一个动态值，即空间点 <code>(x, y, z)</code> 的 <code>z</code> 值。</p>
<span class="math display">\[\begin{aligned}
M_{persp-&gt;ortho}
=
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; n+f &amp; -nf \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<p>对于透视投影，我们首先求解观测空间的压缩变换的变换矩阵 <span
class="math inline">\(M_{persp-&gt;ortho}\)</span>，然后再利用在将转换后的长方体观测空间转换成规范立方体，即上文正交投影中求解的
<span class="math inline">\(M_{ortho}\)</span>。</p>
<p>当然，根据相对不变性原理，我们还要将这两个变换矩阵应用到空间中所有的物体上，对它们进行变换。</p>
<h1 id="屏幕映射">屏幕映射</h1>
<p>当 MVP 变换完成之后，我们则要开始将投影内容绘制到 2D
画布中，其中包含了裁剪和视口变换两个步骤。</p>
<h2 id="裁剪">裁剪</h2>
<p>无论是正交投影还是透视投影，我们都将观测空间转换成了一个规范立方体，同时将转换矩阵应用到空间中的所有物体中。</p>
<p>之后，我们就可以通过规范立方体对空间进行裁剪，只保留规范立方体内的物体，如下所示。很显然，只有在规范立方体中的部分才是我们可以看见的部分。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-12.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="视口变换">视口变换</h2>
<p>视口（Viewport）本质上就是我们所说的 2D
画布，即屏幕。我们知道屏幕有各种各样的分辨率，宽高比。为了处理这种情况，我们将
2D 画布抽象成一个 <span class="math inline">\([-1, 1]^2\)</span>
的规范平面。然后通过视口变换将它映射到真正的视口中。</p>
<p>假设真实视口的宽度是 <span
class="math inline">\(width\)</span>，高度是 <span
class="math inline">\(height\)</span>，那么视口变换就是将 <span
class="math inline">\([-1, 1]^2\)</span> 的平面转换成 <span
class="math inline">\([0, width] \times [0, height]\)</span>
的平面。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-13.png?x-oss-process=image/resize,w_800" /></p>
<p>对此，我们很容易求解变换矩阵，如下所示。</p>
<span class="math display">\[\begin{aligned}
M_{viewport}
=
\left(
\begin{matrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
\end{matrix}
\right)
\end{aligned}\]</span>
<h1 id="总结">总结</h1>
<p>本文，我们主要介绍了观测变换的几个重点内容，包括视图变换、投影变换。其中，我们重点介绍了投影变换中的两种：正交投影和透视投影。</p>
<p>投影变换中提到了一个重要概念——观测空间。我们会将观测空间转换成一个规范立方体，根据相对不变性原理，对空间中所有物体做同样的变换。其中透视投影稍有复杂一点，我们会将纺锤体的观测空间转换成长方体的观测空间。</p>
<p>最后，我们将规范立方体以外的内容进行裁剪，并采用视口变换将内容映射到具体的屏幕上。</p>
<p>后面，我们将基于本章的内容继续介绍计算机图形学的相关基础。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
<li>Image Processing and Computer Graphics——Rendering Pipeline, Matthias
Teschner.</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>观测变换</tag>
        <tag>投影变换</tag>
        <tag>正交投影</tag>
        <tag>透视投影</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（4）——光栅化</title>
    <url>/2024/03/30/foundation-of-computer-graphic-04/</url>
    <content><![CDATA[<p>上一篇 <a
href="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">文章</a>
我们介绍了矩阵变换在计算机图形学中的应用，包括：视图变换、模型变换、投影变换。此外，我们还详细介绍了投影变换中的正交投影和透视投影，以及屏幕映射过程中的视口变换。</p>
<span id="more"></span>
<p>本文，我们来介绍一下计算机图形学中最重要的内容之一——光栅化。</p>
<h1 id="栅格显示">栅格显示</h1>
<p>光栅化（Rasterization）中光栅（Raster）一词来源于德语，表示栅格的意思。我们现在用的显示设备基本上都是由像素点阵构成的栅格显示设备。因此，我们很容易理解光栅化的含义，即在栅格显示设备上绘制图形。</p>
<p>这里我们先介绍一下常见的栅格显示设备。</p>
<p>旧式的阴极射线管（Cathode Ray Tube，CRT）电视，它的基本原理是
<strong>通过射线管将电子射到屏幕进行逐行扫描</strong>，如下图所示。在实际应用中，会借助视觉暂留效应，对屏幕进行
<strong>隔行扫描</strong>，从而降低扫描的计算量。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-01.png?x-oss-process=image/resize,w_800" /></p>
<p>现代平板显示器（Flat Panel Displays）中最常用的是液晶显示器（Liquid
Crystal Display，LCD），它的基本原理是
<strong>通过扭转偏振来阻挡或传输光线</strong>，如下图所示。在实际应用中，会使用
<strong>帧缓冲</strong>（Frame
Buffer）来提前缓存画面的帧数据，从而提高显示流畅度。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="光栅化">光栅化</h1>
<h2 id="基本单元">基本单元</h2>
<p>光栅化的基本单元是三角形，采用三角形作为基本单元的原因是：</p>
<ul>
<li>三角形是最基本的多边形。</li>
<li>三角形具有平面性。</li>
<li>三角形可以明确定义内部和外部。我们可以通过向量叉积来判断，详见 <a
href="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">计算机图形学基础（1）——线性代数</a>。</li>
<li>任意多边形可以拆分成 N 个三角形。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-07.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="采样绘制">采样绘制</h2>
<p>2D
屏幕是一个离散的像素阵列，空间中的三角形则是一个连续的函数。采样绘制的本质则是对一个函数进行离散化。具体的做法是：</p>
<ul>
<li>遍历像素阵列，判断每一个像素阵列是否位于三角形的投射区域内</li>
<li>如果是，进行绘制像素；否则，不绘制。</li>
</ul>
<p>如下所示为采样绘制的伪代码和示意图。注意，像素本身是一个矩形区域，因此判断像素是否在三角形内部时，采用的是像素点的中心作为参照。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inside</span><span class="params">(t, x, y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">point</span><span class="params">(x, y)</span> in <span class="title">triangle</span><span class="params">(t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y) &#123;</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x + <span class="number">0.5</span>, y + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-03.png?x-oss-process=image/resize,w_800" /></p>
<p>在绘制三角形时，一般不会对整个屏幕的像素点进行扫描，而是仅仅对三角形的
<strong>包围盒</strong>（Bounding
Box）区域内的像素进行扫描和绘制，从而有效降低算法复杂度。对于一些窄长三角形，甚至可以进一步优化算法，如下图右侧所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-04.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="核心问题">核心问题</h2>
<p>我们观察上述这种简单的采样绘制方式，可以发现一个很明显的问题——<strong>锯齿</strong>（Jaggies）。这个问题根本上是采样导致的，对于这种现象我们称之为
<strong>走样</strong>（Aliasing）。走样会带来很多奇怪的现象，比如：锯齿、摩尔纹（Moire
Patterns）、车轮效应等，如下图所示。</p>
<p>光栅化要解决的核心问题就是走样问题，即
<strong>反走样</strong>（Antialiasing）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-05.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-06.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="解决方法">解决方法</h2>
<p>计算机图形学中解决走样问题的最常用方法是：<strong>先模糊，后采样</strong>。模糊，从字面上理解就是将图片虚化，从数学上理解则是
<strong>滤波</strong>，关于滤波，我们将在下一节中进行介绍。</p>
<p>下图所示，为「直接采样」和「先模糊，后采样」的流程对比图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-08.png?x-oss-process=image/resize,w_800" /></p>
<p>在具体实践中，通过这种方式能够有效解决光栅化中的锯齿问题，如下所示为反走样前后的效果对比图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-09.png?x-oss-process=image/resize,w_800" /></p>
<p>这里，我们可能会产生疑问：</p>
<ul>
<li>出现走样的根本原因是什么？</li>
<li>为什么先模糊（滤波）后采样能够实现反走样？</li>
</ul>
<p>要讲明白这些内容，我们必须要介绍一下采样理论。</p>
<h1 id="采样理论">采样理论</h1>
<p>采样理论是信号系统中非常重要的一个理论，它在数字信号处理、数字通信、图像处理等众多领域都有着广泛的应用。</p>
<p>在实际应用中，我们通过一定的采样率把连续信号转换为离散信号，然后再对离散信号进行处理。处理完后，我们又可以通过一定的重构方法把离散信号转换回连续信号，以便在实际系统中使用。</p>
<h2 id="傅里叶级数">傅里叶级数</h2>
<p>那么如何表示任意一种信号呢？法国数学家傅里叶认为，任何周期函数（信号）都可以用正弦函数和余弦函数构成的无穷级数来表示，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-10.png?x-oss-process=image/resize,w_800" /></p>
<p>对于上图中的信号，使用傅里叶级数展开的表示如下所示。其中，这里 <span
class="math inline">\(t\)</span> 表示时间，<span
class="math inline">\(A\)</span> 表示振幅，<span
class="math inline">\(w\)</span> 表示角频率。</p>
<span class="math display">\[\begin{aligned}
f(x) = \frac{2Acos(tw)}{\pi} - \frac{2Acos(3tw)}{3\pi} +
\frac{2Acos(5tw)}{5\pi} - \frac{2Acos(7tw)}{7\pi} + ...
\end{aligned}\]</span>
<h2 id="时域与频域">时域与频域</h2>
<p>基于傅里叶级数，我们可以对信号的时域（以时间为横坐标）和频域（以频率为横坐标）进行相互转换：</p>
<ul>
<li>时域转换成频域：采用 <strong>傅里叶变换</strong>（Fourier
Transform）</li>
<li>频域转换成时域：采用 <strong>逆傅里叶变换</strong>（Inverse Fourier
Transform）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="走样原理">走样原理</h2>
<p>了解了信号的时域和频域之后，我们再来介绍走样的原理。</p>
<p>理想情况下，对一个连续信号进行采样后得到的离散信号，应该能够近似重构原始信号。然而，当采样频率低于原始信号的频率时，就会很容易出现走样的问题。换句话说，就是采样得到的离散信号无法近似重构原始信号。</p>
<p>下图所示，我们列举了几种信号，信号频率依次从高到低，我们使用相同的频率对这些信号进行采样。很显然，我们对低频信号进行采样时，由于采样频率大于信号频率，得到的离散信号可以近似重构原始信号；但是，我们对高频信号采样时，由于采样频率小于信号频率，得到的离散信号则无法近似重构原始信号。</p>
<p>因此走样的根本原因就是 <strong>采样频率小于信号频率</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-12.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="滤波">滤波</h1>
<p>由于滤波在反走样中起到了重要作用，因此我们简单介绍一下图像处理中滤波。</p>
<p>如下图所示，通过傅里叶变换将左侧的像素空间（空间域）变为右侧的频谱（频域）。对于二维信号，其频谱的表示如下：</p>
<ul>
<li>高频部分代表细节、边缘、噪声</li>
<li>低频占据绝大多数能量，其中直流分量（零频）能量占比最大</li>
<li>频率分部具有中心对称性</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-13.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们来介绍一下几种常见的滤波。</p>
<h2 id="高通滤波">高通滤波</h2>
<p>高通滤波（High-pass
filter），保留高频信号。在图像中，轮廓的边缘会发生剧烈变化，属于高频信号。经过高通滤波后，图像只会保留一些轮廓信息，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-14.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="低通滤波">低通滤波</h2>
<p>低通滤波（Low-pass
filter），保留低频信号。在图像中，颜色变化平缓的区域属于低频信号。经过低通滤波后，图像会抹去轮廓信息，如下图所示。模糊处理基于低通滤波实现的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-15.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="带通滤波">带通滤波</h2>
<p>带通滤波（Band-pass
filter），顾名思义，只保留一部分频率范围内的信号。对图像滤波后的效果取决于带通滤波所选择的频率范围。下图所示，为两种不同频率范围的带通滤波。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-16.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-17.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="卷积">卷积</h2>
<p>那么如何实现滤波呢？卷积（Convolution）就是实现滤波的主要数学工具和底层原理。滤波器的基本原理是
<strong>响应函数与输入信号进行卷积运算</strong>，因此滤波器也可以称为
<strong>卷积核</strong>。</p>
<p>如下所示，是卷积的数学定义，两个函数的 <span
class="math inline">\(f\)</span> 和 <span
class="math inline">\(g\)</span> 卷积 <span class="math inline">\(f *
g(n)\)</span>。</p>
<span class="math display">\[\begin{aligned}
连续形式：&amp;
(f * g)(n) = \int_{-\infty}^{\infty}f(\tau)g(n-\tau)d\tau
\\
离散形式：&amp;
(f * g)(n) = \sum_{-\infty}^{\infty}f(\tau)g(n-\tau)

\end{aligned}\]</span>
<p>观察 <span class="math inline">\(f(\tau)\)</span> 和 <span
class="math inline">\(g(n-\tau)\)</span> 的关系，可以发现是对
<code>g</code> 函数进行了「翻转」，这就是「卷」的来源。同时，对两个函数
<code>f</code> 和 <code>g</code> 进行积分，这就是「积」的来源。</p>
<p>卷积本身是一个很难解释的数学定义，如果你想深入理解卷积，这里推荐一篇知乎高赞回答——<a
href="https://www.zhihu.com/question/22298352/answer/228543288">传送门</a>。简而言之，<strong>两个函数的卷积，会先将一个函数翻转，然后进行滑动叠加</strong>。本质上可以将卷积理解成加权平均。</p>
<p>下图所示，是对图像进行滤波（卷积）的过程，实现模糊处理。基于傅里叶变换，我们可以实现时域（空间域）与频域之间的相互转换。<strong>时域（空间域）上对两个信号进行卷积，等同于频域上对两个信号的频率进行乘积</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-18.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="反走样原理">反走样原理</h1>
<p>在「走样原理」一节中，我们提到了走样的根本原因是
<strong>采样频率小于信号频率</strong>。在不提高采样频率的前提下，通过
<strong>先滤波，后采样</strong>
的方式可以实现反走样，这里的底层逻辑又是什么呢？</p>
<p>简单的理解就是，<strong>滤波（低通滤波，即模糊处理）会过滤掉信号中大于采样频率的信号分量</strong>。滤波后，剩余的信号分量的频率满足
<strong>采样频率 &gt;= 信号频率</strong> 的条件，因此实现了反走样。</p>
<p>实现反走样的方法主要就是围绕两个角度来实现：</p>
<ul>
<li>提高采样频率。如：超采样技术（Supersampling）、多重采样抗锯齿（MSAA）、超分辨率</li>
<li>过滤高频信号。如：先模糊后采样（Pre-Filter）</li>
</ul>
<h1 id="遮挡与可见">遮挡与可见</h1>
<p>上述内容介绍了光栅化一个三角形的场景，以及其会遇到的问题——走样。下面，我们来介绍光栅化多个三角形会遇到的问题——遮挡与可见问题。</p>
<p>在 3D
空间中，三角形之间存在着前后遮挡关系，那么三角形绘制的先后顺序应该是什么样的呢？</p>
<h2 id="画家算法">画家算法</h2>
<p>对此，我们先介绍一个经常被提到的算法：<strong>画家算法</strong>（Painter's
Algorithm）。</p>
<p>画家算法，顾名思义，按照画家绘画时的先后顺序来执行，远的物体先绘制，进的物体后绘制，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-22.png?x-oss-process=image/resize,w_800" /></p>
<p>虽然画家算法适用于绝大多数场景，但是在某些场景下它仍然无法解决可见性问题。如下图所示，三个相互嵌套的三角形，使用画家算法则无法对三角形进行排序，因此无法准确实现光栅化。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-23.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="深度缓冲算法">深度缓冲算法</h2>
<p>那么上述问题该如何解决呢？于是出现了
<strong>深度缓冲算法</strong>（Z-Buffer Algorithm），其基本原理是：</p>
<ul>
<li>光栅化采用两个缓冲区
<ul>
<li>原有的 <strong>帧缓冲区</strong>（Frame
Buffer）存储每个像素颜色值</li>
<li>附加的
<strong>深度缓冲区</strong>（Z-Buffer）存储每个像素深度值</li>
</ul></li>
<li>深度缓冲区存储每个像素当前的
<strong>最小深度值</strong>（Z-Value）</li>
</ul>
<p>如下所示，为深度缓冲算法的伪代码实现。注意：我们会初始化深度值为无穷大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (each triangle T) &#123;</span><br><span class="line">    <span class="keyword">for</span> (each <span class="built_in">sample</span> (x, y, z) in T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z &lt; zbuffer[x, y]) &#123;            <span class="comment">// 处理深度更小的采样点</span></span><br><span class="line">            framebuffer[x, y] = rgb;        <span class="comment">// 更新颜色值</span></span><br><span class="line">            zbuffer[x, y] = z;              <span class="comment">// 更新深度值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图所示，使用深度缓冲算法光栅化两个三角形的示意图。当光栅化红色三角形时，我们遍历红色三角形的每一个像素的深度值，并与当前深度值进行比较。由于当前深度值均为无穷大，所以红色三角形的每一个像素都可以绘制。当光栅化蓝色三角形时，同样会遍历蓝色三角形每一个像素的深度值，并与当前深度值变换，深度值大于当前深度值，则不绘制；否则，绘制并更新当前深度值。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-24.png?x-oss-process=image/resize,w_800" /></p>
<p>注意，这里的深度值比较取决于坐标系是如何建立的。按照我们之前的介绍，相机是沿着
-Z 轴方向观测，因此深度越大，则 Z 值越小。</p>
<h1 id="总结">总结</h1>
<p>本文，我们主要介绍了光栅化技术。首先介绍了光栅化的含义以及栅格设备。其次，我们介绍了光栅化的基本单元——三角形。</p>
<p>在绘制单个三角形时，我们会遇到走样问题。对此我们介绍了反走样的两种方法：提高采样频率、过滤信号频率。我们着重介绍了后者，先滤波（模糊）后采样，并介绍了其中涉及的原理。</p>
<p>在绘制多个三角形时，我们会遇到遮挡问题。对此我们介绍了两种算法：画家算法、深度缓冲算法。</p>
<p>后续，我们还会继续介绍计算机图形学的其他内容，敬请期待吧~</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
<li><a
href="https://www.zhihu.com/question/22298352/answer/228543288">如何通俗易懂地解释卷积</a></li>
<li><a
href="https://www.zhihu.com/tardis/zm/art/54946461?source_id=1003">傅里叶变换与图像的频域处理</a></li>
<li><a
href="https://dezeming.top/wp-content/uploads/2022/04/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86.pdf">采样定理</a></li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>画家算法</tag>
        <tag>深度缓冲算法</tag>
        <tag>采样</tag>
        <tag>走样</tag>
        <tag>滤波</tag>
        <tag>傅里叶级数</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（5）——着色</title>
    <url>/2024/04/05/foundation-of-computer-graphic-05/</url>
    <content><![CDATA[<p>上一篇 <a
href="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">文章</a>
我们介绍了光栅化所涉及的基本内容。通过光栅化，我们可以实现将 3D
空间模型的投影绘制到 2D
屏幕。然而，仅仅实现光栅化，还不足以让渲染结果具有真实感，如下图左部所示。我们希望能够模拟光线所带来的的明暗效果，如下图右部所示。</p>
<span id="more"></span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-01.png?x-oss-process=image/resize,w_800" /></p>
<p>在计算机图形学中，<strong>着色</strong>（Shading）就是通过计算来决定三维模型表面每个像素的颜色和亮度的过程。本质而言，着色就是
<strong>对不同物体应用不同材质</strong>。</p>
<h1 id="着色模型">着色模型</h1>
<h2 id="着色局部性">着色局部性</h2>
<p>具体分析着色时，我们会分析光线照射到物体表面的每一个点，也称
<strong>着色点</strong>（Shading
Point）。对于每个着色点，我们将其视为一个微平面（或称单位平面），由此我们可以构建法线。整体而言，着色的最终结果受以下几种输入影响，分别是：</p>
<ul>
<li>观测方向 <span class="math inline">\(v\)</span></li>
<li>表面法向 <span class="math inline">\(n\)</span></li>
<li>光线方向 <span class="math inline">\(l\)</span></li>
<li>表面参数，如：颜色、材质。</li>
</ul>
<blockquote>
<p>注意：对于着色过程，我们只考虑光照对于物体表面的影响，而不考虑其他物体的阴影对本物体产生的影响。</p>
</blockquote>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="布林-冯反射模型">布林-冯反射模型</h2>
<p>关于光线与物体表面的作用，根据我们的认知，其实可以分为三种类型：</p>
<ul>
<li><strong>漫反射</strong>（Diffuse）</li>
<li><strong>高光</strong>（Specular）</li>
<li><strong>环境光</strong>（Ambient）</li>
</ul>
<p>在计算机图形学中，有一种广泛使用的光照和颜色计算模型——<strong>布林-冯反射模型</strong>（Blinn-Phong
Relectance
Model），其考虑了上述三种光照的叠加效果对物体表面颜色的影响。</p>
<p>下面，我们分别来介绍这三种光照类型。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-02.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="漫反射">漫反射</h3>
<p>当光线照射到一个点时，光线会向各个方向发生反射，这种现象称为
<strong>漫反射</strong>。漫反射的反射光强主要受到光照角度、光照强度、漫反射系数等因素的影响。</p>
<h4 id="光照角度">光照角度</h4>
<p>在图形学中，<strong>兰伯特余弦定理</strong>（Lambert's cosine
law）详细描述了光照角度对于表面接收光照照射量的影响。下图所示，列举了三种光照角度。</p>
<ul>
<li>情况一，入射角度为 <span
class="math inline">\(90^{\circ}\)</span>，单位平面会接收全部光照。</li>
<li>情况二，入射角度为 <span
class="math inline">\(30^{\circ}\)</span>，单位平面只会接收到一半光照。</li>
<li>情况三，入射角度为 <span
class="math inline">\(90^{\circ}-\theta\)</span>，单位平面接收到的光照占全部光照的比例为
<span class="math inline">\(cos{\theta} = \hat{l} \cdot
\hat{n}\)</span>。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-04.png?x-oss-process=image/resize,w_800" /></p>
<p>基于兰伯特余弦定理，我们可以推导出一个函数表示单位平面接收的光照照射量占全部光照的比例，如下所示。由于
<span class="math inline">\(cos\theta\)</span>
可能会负数，但这没有意义，所以我们使用 <span
class="math inline">\(max(0, cos\theta)\)</span> 来保证其值大于等于
0。</p>
<span class="math display">\[\begin{aligned}
f(\theta) = max(0, cos\theta) = max(0, \hat{l} \cdot \hat{n})
\end{aligned}\]</span>
<h4 id="光照强度">光照强度</h4>
<p>对于光照强度，我们考虑如下所示 3D
空间中的一个点光源。根据能量守恒定理，以光源为球心，任意距离为半径的球体，球面所覆盖的光线强度是相等的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-34.png?x-oss-process=image/resize,w_800" /></p>
<p>由此，我们可以推导光照强度与光源距离之间的关系。假设半径 <span
class="math inline">\(r\)</span> 为 <code>1</code>
时，球面一个点的光照强度为 <span
class="math inline">\(I\)</span>。那么当半径为任意值 <span
class="math inline">\(r\)</span> 时，我们可以根据能量守恒定理得到：</p>
<span class="math display">\[\begin{aligned}
单位球面光照强度：&amp;
4{\pi}I
\\
任意球面光照强度：&amp;
4{\pi}r^2I_r
\\
根据能量守恒定理：&amp;
4{\pi}r^2I_r = 4{\pi}I
\\
任意点的光照强度：&amp;
I_r
=
I/r^2
\end{aligned}\]</span>
<h4 id="漫反射系数">漫反射系数</h4>
<p>不同的材质具有不同的漫反射系数，我们将漫反射系数定义为 <span
class="math inline">\(k_d\)</span>。如下所示，<span
class="math inline">\(k_d\)</span>
越大，反射的光线强度越大，看到的物体越亮。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-05.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="漫反射公式">漫反射公式</h4>
<p>漫反射光线的计算公式其实就是由上述三部分组成，如下所示。</p>
<span class="math display">\[\begin{aligned}
L_d = k_d(I/r^2)max(0, \hat{l} \cdot \hat{n})
\end{aligned}\]</span>
<h3 id="高光">高光</h3>
<p>高光反射，当观测向量趋近于光线的反射向量时，我们可以看到镜面反射所产生的高光，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-06.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="高光区域">高光区域</h4>
<p>那么如何判断高光区域呢？我们可以通过计算光照方向向量和观测方向向量之间的
<strong>半程向量</strong>（Half
Vector）。然后再计算半程向量与平面法线之间的夹角，判断两者是否接近。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-07.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示为半程向量的计算公式，有了半程向量之后，我们可以计算法向量与半程向量之间的夹角。</p>
<span class="math display">\[\begin{aligned}
\hat{h} = bisector(\hat{v}, \hat{l}) = \frac{\hat{v} + \hat{l}}{|\hat{v}
+ \hat{l}|}
\end{aligned}\]</span>
<h4 id="高光突变">高光突变</h4>
<p>根据日常经验，我们可以发现当法向量与半程向量之间的夹角大于某个阈值之后，高光效应会发生突变。如果我们使用
<span class="math inline">\(cos\theta\)</span>
来描述这种突变，显示是不合适的。在布林-冯模型中，我们对 <span
class="math inline">\(cos^p\theta\)</span> 来描述高光突变，其中 <span
class="math inline">\(p\)</span> 是一个经验值。下图所示，展示了不同
<span class="math inline">\(p\)</span> 值随角度变化的曲线。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-08.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="高光系数">高光系数</h4>
<p>类似于漫反射系数，对于高光，这里也有一个高光系数，使用 <span
class="math inline">\(k_s\)</span> 表示。下图所示为不同 <span
class="math inline">\(k_s\)</span> 和不同 <span
class="math inline">\(p\)</span>
的情况下，高光效果的对比。可以看出，高光系数越大，观测的效果越明亮。高光突变的
<span class="math inline">\(p\)</span> 值越大，高光区域则越小。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-09.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="高光公式">高光公式</h4>
<p>高光的计算公式其实也是由三部分组成：高光系数、光线强度、高光突变，具体公式如下所示。</p>
<span class="math display">\[\begin{aligned}
L_s = k_s(I/r^2)max(0, \hat{n} \cdot \hat{h})^p
\end{aligned}\]</span>
<h3 id="环境光">环境光</h3>
<p>在现实世界中，我们知道即使没有光源直接照射物体，物体也并不是完全是黑色的。对此，布林-冯着色模型也近似处理了这种情况，即环境光。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-10.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="环境光公式">环境光公式</h4>
<p>环境光的计算公式非常简单，由环境光系数和环境光强度组成，具体公式如下所示。</p>
<span class="math display">\[\begin{aligned}
L_a = k_aI_a
\end{aligned}\]</span>
<h3 id="光线反射公式">光线反射公式</h3>
<p>布林-冯反射模型定义了一个光线反射公式，该公式由上述三种光照反射类型的计算公式组合，具体公式如下所示。</p>
<span class="math display">\[\begin{aligned}
L = L_a + L_d + L_s = k_aI_a + k_d(I/r^2)max(0, \hat{n} \cdot \hat{l}) +
k_s(I/r^2)max(0, \hat{n} \cdot \hat{h})^p
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-11.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="着色频率">着色频率</h1>
<p>在布林-冯反射模型中，我们以着色点（单位平面）为单位介绍三种光照反射类型。那么在真实着色过程中，以什么为单位进行着色呢？考虑到着色性能的开销，实际上可以分为三种类型，分别是：</p>
<ul>
<li><strong>平面着色</strong>（Flat Shading）</li>
<li><strong>顶点着色</strong>（Gouraud Shading）</li>
<li><strong>像素着色</strong>（冯-着色，Phong Shading）</li>
</ul>
<h2 id="平面着色">平面着色</h2>
<p>平面着色会对每一个平面做一次着色。相对而言，着色频率低，性能开销小，但是着色效果不够丝滑，会有明显的棱边效果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-12.png?x-oss-process=image/resize,w_800" /></p>
<p>在布林-冯反射模型中，着色点的法向量是计算着色的关键变量。对于平面着色而言，我们可以通过三角形的任意两条边所构成的向量，计算叉积，即可得到法向量。</p>
<h2 id="顶点着色">顶点着色</h2>
<p>顶点着色会对三角形的三个顶点进行着色。对于三角形内部的点，则基于三个顶点的颜色，使用速度更快的插值法进行计算。相比平面着色，着色频率略高，性能开销略大，但是着色效果会好一点，会有细微的棱边效果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-13.png?x-oss-process=image/resize,w_800" /></p>
<p>对于顶点着色，我们需要计算三个顶点各自的法向量。通常有两种选择：</p>
<ul>
<li>当平面属于一个规则几何体的局部表面时，可以通过规则几何体的整体出发，计算对应平面的法向量。</li>
<li>其他情况时，可以基于周围平面的法向量，求解平均值，计算对应平面的法向量。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-15.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="像素着色">像素着色</h2>
<p>像素着色，也称冯-着色，它会对每一个像素进行着色。这种方式着色频率很高，性能开销很大，但是着色效果非常丝滑。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-14.png?x-oss-process=image/resize,w_800" /></p>
<p>对于像素着色，我们首先以上述方式计算三角形顶点的法向量，对于三角形内部的点，则通过
<strong>重心插值法</strong>（Barycentric
Interpolation）来计算。关于重心插值法，我们稍后进行介绍。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-16.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="实时渲染管线">实时渲染管线</h1>
<p>实时渲染管线（Real-time Rendering），也称图形管线（Graphics
Pipeline），其描述了 3D 场景转换成 2D 图像的完整流程，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-17.png?x-oss-process=image/resize,w_800" /></p>
<p>实时渲染管线可以分为五个阶段，分别是：</p>
<ul>
<li><strong>顶点处理</strong>（Vertex Processing）</li>
<li><strong>三角形处理</strong>（Triangle Processing）</li>
<li><strong>光栅化</strong>（Rasterization）</li>
<li><strong>片段处理</strong>（Fragment Processing）</li>
<li><strong>帧缓冲操作</strong>（Framebuffer Operations）</li>
</ul>
<h2 id="顶点处理">顶点处理</h2>
<p>顶点处理的输入是 3D 空间中的顶点。为什么是顶点而不是 3D
模型？这是因为 3D
空间的所有模型都是以三角形为基本单元进行表示的，而三角形则可以通过顶点和连线来描述，3D
模型的本质就是大量顶点和连线的定义。</p>
<p>在顶点处理阶段，我们会对顶点进行观测变换，即 <a
href="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">《计算机图形学基础（3）——观测变换》</a>
中所介绍的 MVP 变换。最终输出经过观测变换的顶点。</p>
<h2 id="三角形处理">三角形处理</h2>
<p>在某些文章中，会将这个阶段定义成 <strong>图元处理</strong>（Primitive
Processing），三角形处理只是其中的一个子集，它还会处理点和线。这里我们为了突出重点，将其称为三角形处理。</p>
<p>由于顶点处理阶段只对顶点进行变换，而 3D
模型还包括连线的定义，三角形处理阶段就是根据连线的定义，将顶点装配成三角形（也称图元）。</p>
<h2 id="光栅化">光栅化</h2>
<p>当顶点处理和三角形处理完成之后，我们得到了经过观测变换后的三角形。此时三角形仍然处于
3D 空间中，不过我们可以通过正交投影快速获取它们在 2D 空间中的投影。</p>
<p>光栅化则是将连续的 2D 投影进行采样，转换成离散的 2D
投影，这是因为屏幕由一个离散的二维像素矩阵所构成。关于光栅化具体要做的事情以及可能遇到的问题，我们在
<a
href="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">《计算机图形学（4）——光栅化》</a>
中进行了详细的介绍。</p>
<p>在实际的 GPU
设计中，为了支持可编程、并行计算，实时渲染管线中的光栅化的主要任务是对连续的图形进行采样，使其离散化。</p>
<h2 id="片段处理">片段处理</h2>
<p>片段处理，也称像素处理，它会对每个片段的颜色、纹理坐标、深度值等进行计算，期间会大量应用插值法进行计算。严格意义上说，片段处理也属于光栅化的一部分。</p>
<h2 id="帧缓冲操作">帧缓冲操作</h2>
<p>帧缓冲操作包含了颜色混合、模板测试、深度测试、透明度检查等一系列操作，最终结果会保存在帧缓冲区，显示器会定时读取帧缓冲区，并将内容呈现在屏幕上。</p>
<h2 id="关于着色">关于着色</h2>
<p>整体而言，实时渲染管线包含观测变换、光栅化、着色三大部分。</p>
<p>然而，着色其实在顶点处理和片段处理阶段都可以存在，这取决于着色频率。如果我们采用顶点着色，那么着色可以发生在顶点处理阶段；如果我们采用像素着色，那么着色可以发生在片段处理阶段。</p>
<p>在现代 GPU
中，实时渲染管线的部分阶段是支持可编程的，比如顶点处理阶段和片段处理阶段。在这些可编程阶段中，我们可以编写着色器（Shader）程序，从而生成自定义的着色结果。</p>
<h3 id="着色器">着色器</h3>
<p>在实时渲染领域，大部分从业者做的事情就是在写各种各样的着色器。如下所示，是
OpenGL 中的一个片段着色器程序，其采用 GLSL
着色语言编写。着色器程序最终由 GPU
调用，对于每个像素都会执行并生成着色结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uniform sampler2D myTexture;    <span class="comment">// program parameter</span></span><br><span class="line">uniform vec3 lightDir;          <span class="comment">// program parameter</span></span><br><span class="line">varying vec2 uv;                <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line">varying vec3 norm;              <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">diffuseShader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec3 kd;                                </span><br><span class="line">    kd = <span class="built_in">texture2d</span>(myTexture, uv);                  <span class="comment">// material color from texture</span></span><br><span class="line">    kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);    <span class="comment">// Lambertian shading model</span></span><br><span class="line">    gl_FragColor = <span class="built_in">vec4</span>(kd, <span class="number">1.0</span>);                   <span class="comment">// output fragment color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="纹理">纹理</h1>
<p>在介绍着色模型中，我们提到着色点的材质会影响最终的着色结果，比如各种反射系数
<span class="math inline">\(k_d\)</span>、<span
class="math inline">\(k_s\)</span>、<span
class="math inline">\(k_a\)</span>
等。除此之外，着色点的原始颜色、法线等属性也都会影响着色结果。</p>
<p>为了能够为着色点定义属性，提出了
<strong>纹理</strong>（Texture）的概念，使用纹理来记录每个着色点的各种属性。通常情况下，我们会把纹理等同于贴图（图片），这是因为大多数情况下会使用纹理来定义颜色。不过从严格意义上说，贴图只是纹理的一种而已。</p>
<h2 id="纹理映射">纹理映射</h2>
<p>纹理映射的本质就是将纹理定义的属性映射到 3D 模型的各个着色点。</p>
<p>如下图所示，我们定义了一个模型和一个纹理，中间的模型经过纹理映射后渲染得到了我们期望的效果。在建模时，我们会将模型分割成一个个三角形。与模型所绑定的纹理，我们也会将其分割成一个个三角形。两者之间的三角形会一一对应。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-18.png?x-oss-process=image/resize,w_800" /></p>
<p>为了方便映射，我们会建立 <strong>纹理坐标系</strong>（Texture
Coordinate），横坐标用 <span class="math inline">\(u\)</span>
表示，纵坐标用 <span class="math inline">\(v\)</span> 表示。<span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> 的值都在 <code>[0, 1]</code>
之间，这是一个约定俗成的规定。模型中的每个顶点都会设定一个纹理坐标，通过这种方式可以实现纹理映射。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-19.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="重心坐标">重心坐标</h2>
<p>虽然模型和纹理是绑定的，但是绑定是基于顶点实现的。因此在纹理映射中，对于模型三角形的顶点，我们可以直接使用绑定的纹理坐标找到纹理中对应坐标的属性。但是模型三角形内部的点该如何获取纹理属性呢？为了解决这个问题，提出了
<strong>重心坐标</strong>（Barycentric Coordinate）的概念。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-20.png?x-oss-process=image/resize,w_800" /></p>
<p>以上图中的三角形为例，重心坐标定义了三角形内部任意一个点 <span
class="math inline">\((x, y)\)</span> 具有以下几个特性。</p>
<span class="math display">\[\begin{aligned}
\begin{cases}
(x, y) = {\alpha}A + {\beta}B + {\gamma}C
\\
\alpha + \beta + \gamma = 1
\\
\alpha &gt;= 0;
\beta &gt;= 0;
\gamma &gt;= 0;
\end{cases}
\end{aligned}\]</span>
<p>最终，我们可以计算得到三角形内任意一个点的重心坐标 <span
class="math inline">\((\alpha, \beta,
\gamma)\)</span>。此时，我们可以使用重心坐标，结合顶点属性，计算得到该点的属性。这里的属性可以是位置、纹理坐标、颜色、法线、深度、材质等各种属性。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-21.png?x-oss-process=image/resize,w_800" /></p>
<p>需要注意的是，在投影时三角形的形状会发生变化，所以在着色时应该基于三维空间的坐标计算重心坐标，然后再做插值。</p>
<h2 id="纹理查询">纹理查询</h2>
<p>上面我们介绍了使用重心坐标表示三角形中的任意点。那么具体该如何应用重心坐标来查找对应的纹理属性呢？如下所示，我们使用伪代码描述了这个查找过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each rasterized screen <span class="title">sample</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    (u, v) = evaluate texture coordinate <span class="built_in">at</span> (x, y)</span><br><span class="line">    texcolor = texture.<span class="built_in">sample</span>(u, v)</span><br><span class="line">    set sample<span class="number">&#x27;</span>s color to texcolor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先说明一个前提：在光栅化阶段，即当三角形被转换为屏幕上的像素时，每个像素的纹理坐标会通过插值方式在三角形的顶点之间计算出来。此时，我们得到的是每个像素的屏幕坐标以及对应的纹理坐标。</p>
<p>上述伪代码所描述的流程是：</p>
<ul>
<li>遍历光栅化得到的屏幕采样点，比如一个三角形 <span
class="math inline">\(ABC\)</span> 的区域内的某个像素点 <span
class="math inline">\((x, y)\)</span>。</li>
<li>基于上述前提，有了像素的屏幕坐标 <span class="math inline">\((x,
y)\)</span>，我们可以直接获取对应的纹理坐标。</li>
<li>当得到像素点的纹理坐标后，我们就可以在纹理中查找对应的属性，伪代码中查找的是颜色属性。</li>
<li>最后我们用纹理颜色来给像素着色。</li>
</ul>
<p>本质上，这是一个纹理采样过程。一旦涉及采样，就可能会出现走样问题。下面，我们来分情况讨论。</p>
<h3 id="纹理太小问题">纹理太小问题</h3>
<p>对于纹理太小的情况，那么会出现多个像素映射到一个
<strong>纹素</strong>（Texel），即纹理中的一个点或像素。此时，就会出现锯齿问题。</p>
<p>为了解决锯齿问题，我们可以通过求均值的方式来解决。如下所示，为最近采样、双线性插值、双三次插值的对比结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-22.png?x-oss-process=image/resize,w_800" /></p>
<p>双线性插值的原理非常简单，就是去临近的 4
个像素，通过三次插值计算得到一个颜色平均值。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-23.png?x-oss-process=image/resize,w_800" /></p>
<p>双三次插值的原理与双线性插值类似，区别在于前者使用周围的 16
个像素求插值，后者使用周围的 4 个像素求插值。</p>
<h3 id="纹理太大问题">纹理太大问题</h3>
<p>对于纹理太大的情况，会出现摩尔纹、锯齿等情况。本质上是采样频率低于信号频率，我们在
<a
href="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">计算机图形学基础（4）——光栅化</a>
中介绍过两种解决思路，一种是超采样，一种是过滤高频信号。</p>
<p>这两种思路，在这种场景下都存在开销过大的问题。于是，在图形学中提出了范围查询的方法，即
<strong>Mipmap</strong>，从而避开了采样所带来的问题。</p>
<h4 id="点查询-范围查询">点查询 &amp; 范围查询</h4>
<p>本质上，采样就是点查询。当纹理太大时，屏幕上一个点对应到纹理上可能是一个很大的区域。然而，从这个区域中取一个点来代表整个区域的颜色，这显然是不合适的。对比而言，范围查询相当于提前计算出一个合适的值来代表这个区域。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-24.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="mipmap">Mipmap</h4>
<p>Mipmap
正是范围查询的一种实现方案，它会为一张纹理生成多个不同层级的纹理，如下图所示。Mipmap
虽然生成了多个不同层级的纹理，但是整体的存储量只增加了不到 1/3。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-25.png?x-oss-process=image/resize,w_800" /></p>
<p>既然 Mipmap
生成了多个不同层级的纹理，那么在纹理查询时，我们应该查询哪个层级的纹理呢？</p>
<p>如下图所示，对于屏幕上的一个像素点，考虑其相邻的两个点，获取它们的纹理坐标。根据纹理坐标计算相邻的距离，由此近似得到像素对应的矩形区域。我们获取矩形区域较大的边长
<span class="math inline">\(L\)</span>。然后对 <span
class="math inline">\(L\)</span>
求对数，即可计算得出要查询的纹理的层级。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-26.png?x-oss-process=image/resize,w_800" /></p>
<span class="math display">\[\begin{aligned}
L = &amp;
max(\sqrt{(\frac{du}{dx})^2 + (\frac{du}{dx})^2},
\sqrt{(\frac{du}{dy})^2 + (\frac{du}{dy})^2})
\\
D = &amp;
log_2L
\end{aligned}\]</span>
<h4 id="各向异性过滤">各向异性过滤</h4>
<p>事实上，Mipmap
也并不是万能的。在有些场景下，也会出现过度模糊的问题，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-27.png?x-oss-process=image/resize,w_800" /></p>
<p>根本原因是，Mipmap
的范围查询所覆盖的区域是正方形。如果屏幕像素点代表了纹理中
的一个长方形区域，那么范围查询就无法准确代表长方形区域内的值，因此会出现走样，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-28.png?x-oss-process=image/resize,w_800" /></p>
<p>那么如何解决呢？方法是各项异性过滤（Anisotropic
Filtering）。具体的技术是：除了生成针对正方形区域的范围查询的纹理外，还要生成其他形状（比如长方形）的范围查询的纹理。通过这种方式，纹理的存储量会增加
3 倍，不过能够降低着色走样的概率。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-29.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="纹理应用">纹理应用</h2>
<p>至此，我们基本了解了纹理及其工作原理，本质而言，纹理 = 内存存储 +
范围查询。上述内容我们主要介绍了通过纹理记录颜色，事实上纹理还能记录其他很多属性，比如：环境光、微几何、法向量、高度偏移等等。</p>
<p>下面，我们来介绍纹理的其他几种应用。</p>
<h3 id="环境贴图">环境贴图</h3>
<p>纹理应用最多的就是 <strong>环境贴图</strong>（Environment
Map），这里又有非常多的类型。</p>
<p><strong>立方体环境贴图</strong>（Cube Environment
Map），它是将环境映射到一个立方体的六个面上，可以用于实现镜面反射和环境光照。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-30.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>光照环境贴图</strong>（Light Environment
Map），它在渲染过程中预先计算和存储环境光照信息，以提高实时渲染效率和质量的技术</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-31.png?x-oss-process=image/resize,w_800" /></p>
<p>除此之外，还有很多环境贴图，比如：球谐环境贴图、镜面反射环境贴图、辐射度环境贴图、天空盒环境贴图等等。</p>
<h3 id="凹凸贴图">凹凸贴图</h3>
<p>假如我们希望渲染一个表面凹凸不同的球状体，如果使用三角形来表示，那么需要大量三角形，而且结构非常复杂。对于这种情况，我们可以凹凸贴图（Bump
Map），它可以定义点的相对高度，从而改变法线，进而影响着色结果，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-32.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="位移贴图">位移贴图</h3>
<p>凹凸贴图改变了着色时所使用的法向量，但并没有真正改变模型的形状。一种更现代化的
<strong>位移贴图</strong>（Displacement
Mapping），则定义了顶点高度的偏移量，使得真真正改变了模型的形状，从而实现更加逼真的效果。下图所示，为凹凸贴图和位移贴图的对比效果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-33.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了着色相关的内容。</p>
<p>首先，我们介绍了着色模型，具体介绍了经典的布林-冯反射模型，其由漫反射、高光、环境光三部分组成。</p>
<p>其次，我们介绍了几种着色频率，包括平面着色、顶点着色、像素着色，简单对比了它们之间的差异。</p>
<p>然后，我们简单介绍了实时渲染管线的 5
个阶段，包括顶点处理、三角形处理、光栅化、片段处理、帧缓冲操作等。</p>
<p>最后，我们详细介绍了着色中最重要的一部分——纹理。纹理查询是是如何通过重心坐标、纹理坐标查找对应的纹理属性。当然，纹理查询也属于采样，其中也会遇到走样的问题。于是，我们引入了线性插值、Mipmap、各向异性过滤等解决方案。除此之外，我们还介绍了纹理的几种应用，包括：环境贴图、凹凸贴图、位移贴图等。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
<li><a href="http://shadertop.com">Shadertoy</a></li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>Mipmap</tag>
        <tag>各向异性过滤</tag>
        <tag>纹理</tag>
        <tag>重心坐标</tag>
        <tag>纹理坐标</tag>
        <tag>布林-冯模型</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（6）——几何</title>
    <url>/2024/04/10/foundation-of-computer-graphic-06/</url>
    <content><![CDATA[<p>前面我们介绍了观测变换、光栅化、着色等几个图形学中比较复杂的主题，本文我们稍微放松一下，介绍一个相对比较简单的主题——几何。</p>
<span id="more"></span>
<h1 id="几何表示">几何表示</h1>
<p>通过图形学建模表示现实生活中的各种物体，要解决的第一个问题就是如何定义物体形状，而这就涉及到了几何。</p>
<p>物体的形状非常多，那么如何通过几何方法表示物体呢？对此，图形学中定义了两种几何表示方法：</p>
<ul>
<li><strong>隐式几何表示</strong>（Implicit Representations of
Geometry）</li>
<li><strong>显示几何表示</strong>（Explicit Representations of
Geometry）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="隐式几何表示">隐式几何表示</h2>
<p>隐式几何表示是一种 <strong>使用数学关系式来描述几何形状</strong>
的方法，而不是直接描述其顶点和边界等元素。在隐式几何表示法中，几何形状被定义为方程的解集，即满足某些条件的一组点的集合。比如，下面的关系式定义了一个圆环结构。</p>
<span class="math display">\[\begin{aligned}
f(x, y, z) = (2 - \sqrt{x^2 + y^2})^2 + z^2 - 1
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-02.png?x-oss-process=image/resize,w_800" /></p>
<p>隐式几何表示的常用技术有以下这些：</p>
<ul>
<li><strong>代数曲面</strong>（Algebraic Surface）</li>
<li><strong>构造实体几何</strong>（Constructive Solid Geometry）</li>
<li><strong>距离函数</strong>（Distance Function）</li>
<li><strong>水平集</strong>（Level Set）</li>
<li><strong>分形</strong>（Fractals）</li>
</ul>
<p>下面，我们来介绍一下这些常用的隐式几何表示技术。</p>
<h3 id="代数曲面">代数曲面</h3>
<p>代数曲面是通过一组参数方程定义的曲线和表面。它适用于一些简单的，可以使用数学关系式表示的几何体。下图所示，这些几何体就比较适合使用代数曲面来表示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-04.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="构造实体几何">构造实体几何</h3>
<p>构造实体几何是通过布尔运算来组合不同的几何体。下图所示，一些复杂的几何体可以通过简单的几何体来组合构造。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-05.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="距离函数">距离函数</h3>
<p>距离函数描述空间中任何一个点到几何体表面的最小距离。一种特殊的距离函数，符号距离函数（Signed
Distance
Function），其以空间中任意一个点作为输入，根据距离函数的返回值，可以进行判断：</p>
<ul>
<li>当距离函数的值大于 0，表示点在几何体外部</li>
<li>当距离函数的值小于 0，表示点在几何体内部</li>
<li>当距离函数的值等于 0，表示点在几何体表面</li>
</ul>
<h3 id="水平集">水平集</h3>
<p>对于表面规则的几何体，我们可以使用距离函数来表示；对于表面复杂的几何体，距离函数难以适用，此时，我们可以使用水平集来表示。</p>
<p>水平集的核心思想与距离函数一样，区别在于：距离函数使用通过输入空间点来计算该点到几何体表面的距离，水平集则存储了一系列距离值，我们可以通过插值法找到距离为
0 的位置，拟合出一条曲面用于表示几何体的表面。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-06.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="分形">分形</h3>
<p>分形，类似于递归，即局部和整体的形状相似，如下图所示。分形通过迭代函数系统（IFS）来生成。IFS是一种迭代的过程，该过程将函数反复应用于某个起始点或起始数据。这些函数通常是缩放、旋转、平移等操作，同时保持自相似性。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-07.png?x-oss-process=image/resize,w_800" /></p>
<!--缺点：难以判断哪些点属于关系式-->
<!--优点：容易判断点是否在几何的表面-->
<h2 id="显示几何表示">显示几何表示</h2>
<p>显式几何表示是一种
<strong>直接或间接（通过参数映射的方式）定义点、线、面等元素集合</strong>
的方法。在显式几何表示中，各元素的位置通常由坐标值直接给出，各元素之间的关系通常由数据结构来表示。比如，下面的关系式通过参数映射的方式间接定义了点的集合。</p>
<span class="math display">\[\begin{aligned}
f: R^2 \rightarrow &amp;
R^3
\\
(u, v) \rightarrow &amp;
(x, y, z)
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-03.png?x-oss-process=image/resize,w_800" /></p>
<p>显式几何表示的常用技术有以下这些：</p>
<ul>
<li><strong>点云</strong>（Point Cloud）</li>
<li><strong>网格模型</strong>（Polygon Mesh）</li>
</ul>
<p>下面，我们来介绍一下这两种显式几何表示技术。</p>
<!--缺点：难以判断是否在内部或外部-->
<h3 id="点云">点云</h3>
<p>点云是显式几何表示中最简单的技术，其核心思想是使用大量的点来表示几何体的表面。点的密度越高，几何体的精度越高。由于点云的缺点很明显，内存占用大，因此一般会被再次转换成多边形网格。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-08.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="多边形网格">多边形网格</h3>
<p>多边形网格是图形学中最常用的几何表示方法，它存储点和多边形（一般是三角形或四边形），这种形式非常容易处理、模拟、采样。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-09.png?x-oss-process=image/resize,w_800" /></p>
<p>在 3D 建模中，我们经常会用到 <code>.obj</code>
格式的模型文件，其本质上是一个文本文件，记录了顶点、法线、纹理坐标、连接关系，由此构成几何体的形状。如下所示，是一个立方体结构的表示。</p>
<ul>
<li><code>v</code> 表示顶点</li>
<li><code>vn</code> 表示法线（多了两条是因为建模误差）</li>
<li><code>vt</code> 表示纹理坐标</li>
<li><code>f</code> 表示面，比如 <code>f 5/1/1 1/2/1 4/3/1</code>
表示三角形面是由第 5、1、4 个顶点组成，三个点的纹理坐标是第 1、2、3
对应的纹理坐标，面的法线是第 1 条法线。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-10.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="曲线">曲线</h1>
<p>曲线（Curves）在图形学中应用非常广泛，比如：相机的拍摄路径、物体的移动路径、动画曲线、矢量字体等。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="贝塞尔曲线">贝塞尔曲线</h2>
<p>贝塞尔曲线是通过一系列控制点进行定义的曲线。如下图所示，4
个控制点定义了一条贝塞尔曲线，起始方向沿着 <span
class="math inline">\(p_0p_1\)</span>，结束方向沿着 <span
class="math inline">\(p_2p_3\)</span>，曲线不必经过所有控制点，但必须经过起始点和结束点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-12.png?x-oss-process=image/resize,w_800" /></p>
<!--特性：-->
<!--- 必须过起点和终点-->
<!--- 仿射不变性-->
<!--- 凸包性质-->
<h3 id="绘制算法">绘制算法</h3>
<p>那么控制点是如何影响曲线的呢？贝塞尔曲线绘制算法的原理是什么呢？</p>
<p>贝塞尔曲线的绘制算法是 <strong>De Casteljau's
Algorithm</strong>，算法的基本思想是利用线性插值的原理，将高阶贝塞尔曲线转化为一阶贝塞尔曲线的组合。对于一个
N
阶贝塞尔曲线，首先构建一系列的二维点，然后在这些点上构建线段，以此类推，直到计算出贝塞尔曲线上的一个点。重复这个过程就可以得到贝塞尔曲线上的所有点，从而绘制出完整的贝塞尔曲线。</p>
<p>下面，我们以 3 个控制点绘制贝塞尔曲线的例子来进行介绍。</p>
<p>N 个控制点绘制的贝塞尔曲线，称为 <strong>N-1
阶贝塞尔曲线</strong>。如下所示，我们定义了 3
个控制点，由此绘制的贝塞尔曲线称之为
<strong>二阶贝塞尔曲线</strong>（Quadratic Bezier）。对于这 3
个控制点，我们首先对相邻控制点进行连线。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-13.png?x-oss-process=image/resize,w_800" /></p>
<p>我们定义一个变量 <code>t</code>，其值的范围为
<code>[0, 1]</code>，作为算法的输入值。当 <code>t = 0</code>
时，表示贝塞尔曲线起始点的输入值，当 <code>t = 1</code>
时，表示贝塞尔曲线结束点的输入值。随后，我们在控制点所构成的各个连线上定义一个点，这个点的位置取决于
<code>t</code> 的值，即一个比例值。比如：<span
class="math inline">\(b_0b_1\)</span> 连线上定义点 <span
class="math inline">\(b_{0}^{1}\)</span>，<span
class="math inline">\(b_1b_2\)</span> 连线上定义点 <span
class="math inline">\(b_{1}^{1}\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-14.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，我们继续对 <span class="math inline">\(b_{0}^{1}\)</span> 和
<span class="math inline">\(b_{1}^{1}\)</span>
进行连线，并按照上述规则，在 <span
class="math inline">\(b_{0}^{1}b_{1}^{1}\)</span> 连线上定义点 <span
class="math inline">\(b_{0}^{2}\)</span>，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-15.png?x-oss-process=image/resize,w_800" /></p>
<p>当新定义的点只有一个时，我们可以将 <code>t</code> 的值逐步从
<code>0</code> 变到 <code>1</code>。在这个过程中，<span
class="math inline">\(b_{0}^{1}\)</span>、<span
class="math inline">\(b_{0}^{2}\)</span>、<span
class="math inline">\(b_{1}^{1}\)</span> 的位置都会随着 <code>t</code>
的变化而变化。对于最终的贝塞尔曲线，我们只需要关注最后定义的点 <span
class="math inline">\(b_{0}^{2}\)</span> 的路径即可，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-16.png?x-oss-process=image/resize,w_800" /></p>
<p>当我们扩展至更多控制点时，比如 4
个控制点时，我们仍然按照上述规则来处理，将高阶贝塞尔曲线转化为一阶贝塞尔曲线的组合，最终绘制曲线。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-17.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="代数公式">代数公式</h3>
<p>对于上述通过 3
个控制点绘制贝塞尔曲线，我们可以用代数的方式来表示，如下所示。</p>
<span class="math display">\[\begin{aligned}
b_{0}^{1}(t) = &amp;
(1 - t)b_0 + tb_1
\\
b_{1}^{1}(t) = &amp;
(1 - t)b_1 + tb_2
\\
b_{0}^{2}(t) = &amp;
(1 - t)b_{0}^{1} + tb_{1}^{1}
\\
b_{0}^{2}(t) = &amp;
(1 - t)^2b_0 + 2t(1 - t)b_1 + t^2b_2

\end{aligned}\]</span>
<p>由此，我们可以推导出 N 阶贝塞尔曲线的代数公式，如下所示。其中，<span
class="math inline">\(n\)</span> 表示 N 阶贝塞尔曲线，<span
class="math inline">\(b_j\)</span> 表示控制点，<span
class="math inline">\(B_i^n(t)\)</span> 为伯恩斯坦多项式（Bernstein
Polynomials）。</p>
<span class="math display">\[\begin{aligned}
b^n(t) = &amp;
b_{0}^{n}(t) = \sum_{j=0}^{n}b_jB_{j}^{n}(t)
\\
B_i^n(t) = &amp;
\left(
\begin{matrix}
n \\
i \\
\end{matrix}
\right)
t^i(1-t)^{n-i}
\end{aligned}\]</span>
<h3 id="曲线性质">曲线性质</h3>
<p>贝塞尔曲线具有以下几个特性：</p>
<ul>
<li>一定过起点和终点。</li>
<li>不受仿射变换影响，受投影变换影响。</li>
<li>凸包（Convex Hull）性质：贝塞尔曲线在所有控制点的凸包范围内。</li>
</ul>
<h2 id="分段贝塞尔曲线">分段贝塞尔曲线</h2>
<p>根据贝塞尔曲线绘制算法，我们可以知道，改变任意一个控制点的位置都会影响整个贝塞尔曲线。因此，当控制点比较多时，我们很难进行精准的控制和调整。于是就有了分段贝塞尔曲线，即采用多条贝塞尔曲线进行串联。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-18.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="曲面">曲面</h1>
<p>曲面（Surface）在图形学中应用同样非常广泛，可以用它来表示各种三维物体。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-19.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="贝塞尔曲面">贝塞尔曲面</h2>
<p>贝塞尔曲线控制点都是在同一平面内，由此进行扩展，贝塞尔曲面的控制点则是分部在三维空间中。下图所示，展示了空间中
4 x 4 个控制点所构成的贝塞尔曲面。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-20.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="绘制算法-1">绘制算法</h3>
<p>贝塞尔曲面的绘制算法本质上还是基于 De Casteljau's Algorithm
进行多次绘制。以下图为例，首先基于预设的所有控制点（比如：4 x 4
的控制点），绘制 4
条贝塞尔曲线。然后在与曲线垂直的平面中开始绘制曲线，按照固定间距，以 4
条贝塞尔曲线上的点作为控制点，绘制贝塞尔曲线。以此类推，最终得到一个贝塞尔曲面。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-21.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="曲面处理">曲面处理</h2>
<p>根据上述绘制算法，我们可以得到基于多边形网格的曲面。在实际应用中，我们会对曲面进行进一步的处理。常见的曲面处理操作有以下两种：</p>
<ul>
<li><strong>网格细分</strong>（Mesh Subdivision）</li>
<li><strong>网格简化</strong>（Mesh Simplification）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-22.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="网格细分">网格细分</h3>
<p>网格细分就是把一个多边形拆分成多个多边形。这里我们介绍两种细分算法：Loop
细分和 Catmull-Clark 细分。</p>
<h4 id="loop-细分">Loop 细分</h4>
<p>Loop 细分只适用于三角形面的细分，具体可以分为两步：</p>
<ul>
<li>将一个三角形拆分成四个三角形</li>
<li>更新新顶点和旧顶点的位置，使模型变得更加光滑</li>
</ul>
<p>三角形的拆分非常简单，连接每条边的中点，即可将拆分成四个三角形，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-23.png?x-oss-process=image/resize,w_800" /></p>
<p>对于新顶点的更新，它会基于周围四个旧顶点求加权平均，离它近的顶点权重大，设为
3/8，离它远的顶点权重小，设为 1/8，如下所示，白点为待更新的新顶点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-24.png?x-oss-process=image/resize,w_800" /></p>
<p>对于旧顶点的更新，它会基于周围几个旧顶点求加权平均，其中各个点的权重值与待更新点的度（Degree）有关，最终可以得到如下所示的更新方法。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-25.png?x-oss-process=image/resize,w_800" /></p>
<p>Loop 细分只针对三角形面进行细分，整体效果如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-29.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="catmull-clark-细分">Catmull-Clark 细分</h4>
<p>相比对 Loop 细分，Catmull-Clark
细分是一种更加通用的细分方法，适用于各种多边形网格曲面。Catmull-Clark
细分涉及到一个概念 <strong>奇异点</strong>（Extraordinary
Vertex），即度不为 4 的点。</p>
<p>Catmull-Clark 细分的第一步同样是拆分多边形，主要包含以下几点：</p>
<ul>
<li>对于边，取其中点；对于面，也取其一个点（比如：重心）</li>
<li>连接边的中点和面的中点</li>
</ul>
<p>我们可以发现，当对非四边形进行一次细分后，所有的非四边形都消失了。不过，一次细分后，会引入两个新的奇异点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-26.png?x-oss-process=image/resize,w_800" /></p>
<p>对于新顶点的更新，可以分为两种情况，分别边上的点和面中的点，其规则如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-27.png?x-oss-process=image/resize,w_800" /></p>
<p>对于旧顶点的更新，其更新规则如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-28.png?x-oss-process=image/resize,w_800" /></p>
<p>Catmull-Clark 适用于任何多边形网格面，整体效果如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-30.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="网格简化">网格简化</h3>
<p>网格简化与网格细分正好相反，其目的是为了减少三角形数量，从而提升性能。对于近的物体三角形多，远的物体三角形少。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-31.png?x-oss-process=image/resize,w_800" /></p>
<p>网格简化是通过 <strong>边坍缩</strong>（Edge
Collapse）实现的，它会减少边的数量，并更新相关顶点的位置。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-32.png?x-oss-process=image/resize,w_800" /></p>
<p>那么边坍缩的底层依据是什么呢？这里涉及到
<strong>二次度量误差</strong>（Quadirc Error
Metrics）的概念。二次度量误差用来表示网格简化带来的误差大小，其计算方法是新顶点与它关联的面的垂直距离的平方和，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-33.png?x-oss-process=image/resize,w_800" /></p>
<p>当删除一条边时，我们会引入一个新的顶点，当新顶点调整至二次度量误差最小时，我们将其设置为边坍缩后的新顶点。利用这种贪心思想，就能实现网格简化。</p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了计算机图形学中的几何相关部分。首先，我们介绍了几何的几种表示方法：隐式几何表示和显式集合表示，两者各自又有着很多实现方法。</p>
<p>然后，我们介绍了曲线，特别是贝塞尔曲线，详细介绍了其绘制算法 De
Casteljau's Algorithm。由此延伸值曲面的绘制，特别是贝塞尔曲面。</p>
<p>最后，我们介绍了曲面的两种常见的处理方式：网格细分和网格简化。</p>
<p>至此，几何相关的内容均已介绍完毕。后续，我们将探讨光线追踪渲染器的相关内容。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>几何</tag>
        <tag>Loop Subdivision</tag>
        <tag>Catmull-Clark Subdivision</tag>
        <tag>贝塞尔曲线</tag>
        <tag>De Casteljau&#39;s Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（7）——辐射度量学</title>
    <url>/2024/04/20/foundation-of-computer-graphic-07/</url>
    <content><![CDATA[<p>在介绍光线追踪之前，我们先来学习一下其所涉及的重要内容——辐射度量学。由于该内容相对独立，这里单开一篇文章来进行介绍。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>本质上，辐射度量学是在物理层面准确定义光照的方法。在 <a
href="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">《计算机图形学基础（5）——着色》</a>
一文中我们提到了光照强度，我们将半径为 <span
class="math inline">\(r\)</span> 时，对应的球面的一个点的光照强度为
<span
class="math inline">\(I\)</span>，那么具体它的单位是什么呢？在了解辐射度量学之后，这个疑问就能得到解答。</p>
<p>在辐射度量学中涉及了很多相关术语，这里我将它们分为两部分进行介绍。</p>
<h1 id="几何">几何</h1>
<p>首先我们来看几何的相关术语，主要包含以下几个：</p>
<ul>
<li><strong>角（Angles）</strong></li>
<li><strong>立体角（Solid Angles）</strong></li>
<li><strong>微分立体角（Differential Solid Angles）</strong></li>
</ul>
<h2 id="角">角</h2>
<p>在平面几何中，角的定义是弧长与半径的比值，其中 <span
class="math inline">\(\theta\)</span> 表示角，<span
class="math inline">\(l\)</span> 表示弧长，<span
class="math inline">\(r\)</span> 表示圆的半径，如下所示。圆自身的角度为
<span class="math inline">\(2\pi\)</span>。</p>
<span class="math display">\[\begin{aligned}
\theta = \frac{l}{r}
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="立体角">立体角</h2>
<p>在立体几何中，立体角的定义则是弧面积与半径平方的比值，其中 <span
class="math inline">\(\Omega\)</span> 表示立体角，<span
class="math inline">\(A\)</span> 表示弧面积，<span
class="math inline">\(r\)</span>
表示球的半径，如下所示。球自身的立体角为 <span
class="math inline">\(4\pi\)</span>。立体角主要用于描述空间中的一个锥体的张开角度。</p>
<span class="math display">\[\begin{aligned}
\Omega = \frac{A}{r^2}
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-02.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="微分立体角">微分立体角</h2>
<p>微分立体角通过两个角度来定义球面上的一个唯一的方向，如下所示。其中，两个角度分别是：</p>
<ul>
<li>与 <span class="math inline">\(z\)</span> 轴形成的夹角 <span
class="math inline">\(\theta\)</span></li>
<li>绕 <span class="math inline">\(z\)</span> 轴形成的夹角 <span
class="math inline">\(\phi\)</span></li>
</ul>
<p>计算微分立体角，我们首先两个角度在球面所形成方向所占据的单位面积
<span
class="math inline">\(dA\)</span>。按照微分的思想，我们认为该面积等同于矩形的面积，因此我们要计算它的长和宽，分别为
<span class="math inline">\(rsin{\theta}d\phi\)</span> 和 <span
class="math inline">\(rd\theta\)</span>，由此可以计算该单位面积。从而进一步求解微分立体角
<span class="math inline">\(d\omega\)</span>，如下所示。</p>
<span class="math display">\[\begin{aligned}
dA = &amp;
(r d\theta)(r sin{\theta} d\phi) = r^2 sin\theta d\theta d\phi
\\
d\omega = &amp;
\frac{dA}{r^2} = sin\theta d\theta d\phi
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-03.png?x-oss-process=image/resize,w_800" /></p>
<p>在辐射度量学中，我们通常用 <span
class="math inline">\(\omega\)</span>
来表示三维空间中的一个方向。我们可以使用 <span
class="math inline">\(\theta\)</span> 和 <span
class="math inline">\(\phi\)</span> 来确定其方向，并且还可以结合 <span
class="math inline">\(d\theta\)</span> 和 <span
class="math inline">\(d\phi\)</span> 来计算其微分立体角。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-04.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="光学物理">光学物理</h1>
<p>在辐射度量学中，主要涉及以下几个光学物理相关术语。</p>
<ul>
<li><strong>辐射能量（Radiant Energy）</strong></li>
<li><strong>辐射通量（Radiant Flux）</strong></li>
<li><strong>辐射强度（Radiant Intensity）</strong></li>
<li><strong>辐射照度（Irradiance）</strong></li>
<li><strong>辐射亮度（Radiance）</strong></li>
</ul>
<h2 id="辐射能量">辐射能量</h2>
<p>辐射能量（Radiant Energy）表示电磁辐射的能量，用符号 <span
class="math inline">\(Q\)</span> 表示，以 <strong>焦耳</strong>（J =
Joule）为单位。</p>
<span class="math display">\[\begin{aligned}
Q
\\
unit: [J = Joule]
\end{aligned}\]</span>
<h2 id="辐射通量">辐射通量</h2>
<p>辐射通量（Radiant
Flux）表示单位时间内流通（发射、反射、传输、接收）的能量，用符号 <span
class="math inline">\(\Phi\)</span> 表示，以 <strong>瓦特</strong>（W =
Watt）或 <strong>流明</strong>（lm =
lumen）为单位。<strong>在实际应用中，我们经常将辐射通量称为能量，本质上是因为辐射通量可以结合时间快速计算出辐射能量</strong>。</p>
<span class="math display">\[\begin{aligned}
\Phi = \frac{dQ}{dt}
\\
unit: [W = Watt]/[lm = lumen]
\end{aligned}\]</span>
<p>在光学物理中，我们也将辐射通量定义为
<strong>单位时间辐射出光子的数量</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="辐射强度">辐射强度</h2>
<p>辐射强度（Radiant Intensity）表示
<strong>单位立体角的辐射通量</strong>。其中 <span
class="math inline">\(\Phi\)</span> 表示辐射通量，<span
class="math inline">\(\omega\)</span>
表示立体角。我们可以用辐射强度描述一束光线，即形成一个锥体角度的光线，在单位时间内流通的能量。</p>
<span class="math display">\[\begin{aligned}
I(\omega) = \frac{d\Phi}{d\omega}
\\
unit:
[\frac{W}{sr}][\frac{lm}{sr} = cd = candela]
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-06.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="辐射照度">辐射照度</h2>
<p>辐射照度（Irradiance）表示
<strong>单位（正交）面积的辐射通量</strong>。注意，这里计算的辐射通量必须与面垂直，如果光照不垂直于面，则计算其垂直分量。其中
<span class="math inline">\(\Phi\)</span> 表示辐射通量，<span
class="math inline">\(A\)</span> 表示正交面积，$$ 表示位置。</p>
<span class="math display">\[\begin{aligned}
E(p) = \frac{d\Phi(p)}{dA}
\\
unit: [\frac{W}{m^2}][\frac{lm}{m^2} = lux]
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-07.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，我们回顾 <a
href="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">《计算机图形学基础（5）——着色》</a>
文中的兰伯特余弦定理，可以计算辐射照度，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-08.png?x-oss-process=image/resize,w_800" /></p>
<p>同样，我们还可以计算空间中一个点光源在空间中辐射的衰减到底是什么？如下所示，其实我们可以发现辐射照度随着半径增加而指数级衰减，辐射强度并没有发生变化。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-09.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="辐射亮度">辐射亮度</h2>
<p>辐射亮度（Radiance）表示
<strong>单位立体角、单位（正交）面积的辐射通量</strong>。辐射亮度一般用于描述光线在传输过程中的属性。我们可以用辐射亮度来描述某个面光源在某个（锥形）方向的辐射通量。</p>
<p>从定义上看，辐射亮度在立体角、正交面积两个维度做了两次微分。其中，<span
class="math inline">\(cos\theta\)</span>
表示光线在单位面积垂直方向上的角度分量，<span
class="math inline">\(p\)</span> 表示位置，<span
class="math inline">\(\omega\)</span> 表示立体角。</p>
<span class="math display">\[\begin{aligned}
L(p, \omega) = \frac{d^2\Phi(p, \omega)}{d{\omega}dA cos\theta}
\\
unit: [\frac{W}{sr m^2}][\frac{cd}{m^2} = \frac{lm}{sr m^2} = nit]
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-10.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们回顾一下辐射强度和辐射照度的定义。</p>
<ul>
<li>辐射强度：单位立体角的辐射通量。</li>
<li>辐射照度：单位（正交）面积的辐射通量</li>
</ul>
<p>结合辐射强度和辐射照度的定义，我们可以将辐射亮度的定义进行转换，<strong>单位立体角的辐射照度</strong>
或
<strong>单位（正交）面积的辐射强度</strong>。这两种定义正好可以应用到两种不同方向的辐射亮度，分别是
<strong>入射辐射亮度</strong> 和 <strong>出射辐射亮度</strong>。</p>
<h3 id="入射辐射亮度">入射辐射亮度</h3>
<p>入射辐射亮度（Incident
Radiance）即单位立体角的辐射照度。我们可以理解从某个方向向一个面进行辐射，该面所接收的辐射照度，如下图所示。如果我们进一步考虑来自四面八方的辐射，比如环境光，那么可以计算得到这个面所接收的全部辐射照度。</p>
<span class="math display">\[\begin{aligned}
L(p, \omega) = \frac{dE{p}}{d{\omega} cos\theta}
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-11.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="出射辐射亮度">出射辐射亮度</h3>
<p>出射辐射亮度（Exiting
Radiance）即单位（正交）面积的辐射强度。我们可以理解一个面向某个方向进行辐射，该方向所发射的辐射强度，如下所示。如果我们进一步考虑一个面向四面八方的辐射，那么可以计算得到这个面所发射的全部辐射强度。</p>
<span class="math display">\[\begin{aligned}
L(p, \omega) = \frac{dI(p, \omega)}{dA cos\theta}
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-10.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="辐射照度-vs.-辐射亮度">辐射照度 vs. 辐射亮度</h2>
<p>在图形学中，辐射照度（Irradiance）和辐射亮度（Radiance）用的非常多。在下图所示的场景中，辐射照度表示
<span class="math inline">\(dA\)</span> 接收的所有能量；辐射亮度表示
<span class="math inline">\(dA\)</span>
从某个方向接收的能量。相比而言，辐射亮度是一个更细粒度的分析属性。这样，我们就把辐射照度和辐射亮度联系起来了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-12.png?x-oss-process=image/resize,w_800" /></p>
<p>对于上图所示的场景，我们可以计算得到某个位置的辐射照度，如下所示，其中
<span class="math inline">\(H^2\)</span> 表示单位半球面积。</p>
<span class="math display">\[\begin{aligned}
dE(p, \omega) = &amp;
L_{i}(p, \omega) cos\theta d\omega
\\
E(p) = &amp;
\int_{H^2} L_{i}(p, \omega) cos\theta d{\omega}
\end{aligned}\]</span>
<h1 id="应用">应用</h1>
<h2 id="双反射分布函数">双反射分布函数</h2>
<p>已知入射光线的能量和角度，当辐射到物体表面后，光线会向各个角度反射，且各个角度反射的能量是不同的。双反射分布函数（Bidirectional
Reflectance Distribution
Function，BRDF）就是用于计算这种场景下各个角度的反射能量。</p>
<p>如下所示，是一个入射和反射的场景，我们从辐射度量学的角度分别进行分析。</p>
<ul>
<li>入射阶段：当入射光线从 <span
class="math inline">\({\omega}_i\)</span>
角度辐射到物体表面的一个位置时，可以认为该位置吸收了所有的光线能量，用辐射照度来表示，即
<span class="math inline">\(dE({\omega}_i)\)</span>。</li>
<li>反射阶段：可以认为该位置将光线能量向各个方向进行辐射。对于方向 <span
class="math inline">\({\omega}_i\)</span>
的光线能量，用辐射亮度来表示，即 <span class="math inline">\(dL_r(x,
{\omega}_r)\)</span>。</li>
</ul>
<span class="math display">\[\begin{aligned}
dE({\omega}_i) = &amp;
L({\omega}_i) cos{\theta}_i d{\omega}_i
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-13.png?x-oss-process=image/resize,w_800" /></p>
<p>本质上，BRDF 就是表示由入射方向 <span
class="math inline">\({\omega}_i\)</span> 向反射方向 <span
class="math inline">\({\omega}_r\)</span> 辐射能量的比例函数 <span
class="math inline">\(fr({\omega}_i \rightarrow
{\omega}_r)\)</span>，其定义如下所示。</p>
<span class="math display">\[\begin{aligned}

BRDF: f_r({\omega}_i \rightarrow {\omega}_r) =
\frac{dL_r({\omega}_r)}{dE_i({\omega}_i)} =
\frac{dL_r({\omega}_r)}{L_i({\omega}_i) cos{\theta}_i d{\omega}_i}

\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-14.png?x-oss-process=image/resize,w_800" /></p>
<p>在实际应用中，对于镜面反射，BRDF
定义反射方向包含所有能量，其他方向均为 0；对于漫反射，BRDF
定义所有方向的能量分布相同。事实上，BRDF
就是描述了光线和物体表面的作用，也就是决定了物体的材质。</p>
<h2 id="反射方程">反射方程</h2>
<p>基于 BRDF，我们可以进一步推导出 <strong>反射方程</strong>（The
Reflection Equation）。</p>
<p>由于 BRDF 定义了一个入射方向 <span
class="math inline">\({\omega}_i\)</span> 向一个反射方向 <span
class="math inline">\({\omega}_r\)</span>
反射时的能量比例。那么，我们可以通过积分计算所有方向对一个反射方向 <span
class="math inline">\({\omega}_r\)</span>
的能量聚合。因此，我们可以推导得出如下所示的反射方程。</p>
<span class="math display">\[\begin{aligned}

L_r(p, {\omega}_r) = \int_{H^2}f_r(p, {\omega}_i \rightarrow {\omega}_r)
L_i(p, {\omega}_i) cos{\theta}_i d{\omega}_i

\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-14.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="渲染方程">渲染方程</h2>
<p>基于反射方程，我们还可以进一步推导出 <strong>渲染方程</strong>（The
Rendering Equation）。</p>
<p>这里我们只需要额外考虑物体本身会发光的情况，于是增加一个发光项即可得到渲染方程，如下所示。其中，<span
class="math inline">\(cos{\theta}_i\)</span>
转换成了法向量和入射方向的点积 <span class="math inline">\(n \cdot
{\omega}_i\)</span>。现代图形学中，所有基于表面反射的渲染都是基于该渲染方程实现的。</p>
<span class="math display">\[\begin{aligned}

L_r(p, {\omega}_r) = L_e(p, {\omega}_r) + \int_{H^2} L_i(p, {\omega}_i)
f_r(p, {\omega}_i, {\omega}_r)(n \cdot {\omega}_i) d{\omega}_i

\end{aligned}\]</span>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了辐射度量学中的几个概念：辐射能量、辐射通量、辐射强度、辐射照度、辐射亮度等。基于这些概念，我们引入了
BRDF 的定义。然后依次推导出反射方程和渲染方程。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>Radiance</tag>
        <tag>Irradiance</tag>
        <tag>Intensity</tag>
        <tag>立体角</tag>
        <tag>微分立体角</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学基础（8）——光线追踪</title>
    <url>/2024/04/27/foundation-of-computer-graphic-08/</url>
    <content><![CDATA[<p>之前我们介绍了在游戏领域中广泛使用的实时渲染技术——光栅化，本文我们来介绍一下在特效领域中广泛使用的离线渲染技术——光线追踪。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>那么有了光栅化渲染技术，为什么还要用光线追踪呢？根本原因在于光栅化的着色局部性，使得它无法解决很多全局效果，比如：</p>
<ul>
<li><strong>软阴影</strong>（Soft shadows）</li>
<li><strong>光泽反射</strong>（Glossy reflection）</li>
<li><strong>间接光照</strong>（Indirect illumination）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-01.png?x-oss-process=image/resize,w_800" /></p>
<p>软阴影的产生是由于光源的大小和距离。一个面积较大的光源照射一个物体，可以从多个角度投射光线到物体上。当光线从不同角度照射时，阴影边缘的重叠区域会因光线部分遮挡而出现阴影的渐变效果。</p>
<p>光泽反射是一种既不完全镜面反射也不完全漫反射的光反射现象。光泽度高、粗糙度低的表面产生的反射相对清晰，接近镜面反射；而光泽度低、粗糙度高的表面，反射图像就会更加模糊，趋向漫反射。</p>
<p>间接光照是一个场景中光线经过一次或多次反射后照射到物体表面的光照效果。在真实世界中，一个房间只通过一扇窗投过光照，但是房间里没有一个地方是完全黑色的，这就是光的多次反射造成的。</p>
<h1 id="底层依据">底层依据</h1>
<p>光线追踪依赖以下几个基本的底层依据，分别是：</p>
<ul>
<li><strong>光线沿直线传播</strong>：在微观角度，光是沿着波形传播；在宏观角度，光是沿着直线传播。</li>
<li><strong>光线相互不碰撞</strong>：当光线的传播路径发生交叠时，我们认为光线的传播互不干扰。</li>
<li><strong>光线具有可逆性</strong>：真实世界中，视觉成像是因为物体发射或反射光线，进入视网膜；在图形学中，屏幕成像是因为从相机向像素建立了反向的光线传播路径，采集路径上的所有着色信息。</li>
</ul>
<h1 id="基本原理">基本原理</h1>
<p>光线追踪的基本原理非常简单，其采用了
<strong>针孔相机模型</strong>（Pinhole Camera Model），分为
<strong>视线生成</strong> 和 <strong>像素着色</strong> 两个阶段。</p>
<p>对于视线生成，以相机为起点，以像素为锚点，利用光的可逆性，建立一条视觉射线，如下所示。此时，我们需要找到视线与空间中的物体所产生的最近的交点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-02.png?x-oss-process=image/resize,w_800" /></p>
<p>对于像素着色，当我们找到视线与物体之间的最近交点时，随即建立交点与光源的连线，判断交点是否在阴影之中，并根据结果来计算着色，写回像素结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-03.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="光线追踪">光线追踪</h1>
<p>上述基本原理只考虑了光源的直接影响，没有考虑间接影响。在实际情况中，光线会经过空间中物体的多次弹射，汇聚至交点上，从而对着色产生间接影响。</p>
<p>对此，<strong>经典光线追踪</strong>，也称
<strong>惠特式光线追踪</strong>（Whitted-Style Ray Tracing）或
<strong>递归光线追踪</strong>（Recursive Ray
Tracing），引入了间接光照的处理。</p>
<p>在视线生成之后，我们找到最近的交点，然后根据光线的可逆性，找到反射光线（Reflected
Ray）与折射光线（Refracted Ray）所产生的交点，依次类推，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-08.png?x-oss-process=image/resize,w_800" /></p>
<p>之后，我们将所有交点分别与光源进行连线，判断这些交点是否在阴影之中，并根据结果计算着色，写回像素结果。当然，在反射和折射过程中会存在能量折损，因此，在计算着色时也会考虑光线折损的影响。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-09.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="技术细节">技术细节</h1>
<p>光线追踪的整体原理非常简单，下面，我们来考虑其中所涉及到的一些技术细节。</p>
<h2 id="交点判定原理">交点判定原理</h2>
<p>光线追踪中最重要的技术是交点判定，其中包含光线表示和几何表示两部分。</p>
<p>对于光线表示，我们只需要使用原点、方向向量即可进行表示，如下所示。</p>
<span class="math display">\[\begin{aligned}

\vec{r}(t) = \vec{o} + t\vec{d}

\end{aligned}\]</span>
<p>对于几何表示，在 <a
href="http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/">《计算机图形学基础（6）——几何》</a>
中，我们提到隐式几何表示和显式几何表示两种。</p>
<h3 id="隐式几何的交点">隐式几何的交点</h3>
<p>隐式几何使用数学关系式表示，因此我们可以结合光线表示来求解方程组，即可计算得到交点，如下所示。其中，<span
class="math inline">\(f\)</span>
为隐式几何的数学关系式，将光线表示作为参数代入，求解 <span
class="math inline">\(t\)</span> 即可得到交点。</p>
<span class="math display">\[\begin{aligned}

f(\vec{o} + t\vec{d}) = 0

\end{aligned}\]</span>
<h3 id="显式几何的交点">显式几何的交点</h3>
<p>显式几何直接或间接（通过参数映射的方式）定义点、线、面等元素集合，基本上最终都会转换成多边形网格来表示。这里，我们介绍平面和三角形两种情况下的交点判定技术。</p>
<h4 id="平面交点判定">平面交点判定</h4>
<p>对于任意一个平面，我们可以使用一个向量和一个点来定义。其中，向量是法向量，平面上任意一个点与
<span class="math inline">\(\vec{p&#39;}\)</span>
所构成的向量都与法向量垂直，两者的点积为
0，因此得到如下所示的平面定义。</p>
<span class="math display">\[\begin{aligned}

(\vec{p} - \vec{p&#39;}) \cdot \vec{N} = 0

\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-10.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，我们再结合平面定义和光线表示得到如下所示的方程组，进而解得
<span class="math inline">\(t\)</span> 的值，即交点。</p>
<span class="math display">\[\begin{aligned}

(\vec{o} + t \vec{d} - \vec{p&#39;}) \cdot \vec{N} = 0

\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-11.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="三角形交点判定">三角形交点判定</h4>
<p>对于三角形交点，我们可以通过 Moller Trumbore Algorithm
快速求解。算法利用重心坐标定义三角形内的一个点，以此得到如下关系式。</p>
<span class="math display">\[\begin{aligned}

\vec{o} + t \vec{d} = (1 - b_1 - b_2)\vec{P_0} + b_1\vec{P_1} +
b_2\vec{P_2}

\end{aligned}\]</span>
<p>根据重心坐标的特性，当 <span class="math inline">\(1- b_1 - b_2 =
0\)</span> 时，点在三角形内，因此关系式中存在三个变量 <span
class="math inline">\(t\)</span>、<span
class="math inline">\(b_1\)</span>、<span
class="math inline">\(b_2\)</span>。由于关系式中的向量都是三维空间中的向量，因此每个向量都由三个坐标值构成，可以进一步得到三个线性方程组，从而求解各个变量。</p>
<h2 id="交点判定加速">交点判定加速</h2>
<p>在实际应用中，三维空间可能包含非常多的物体，每个物体可能包含非常多的三角形。假如，我们要判断光线与一个物体的交点，那么需要遍历物体的每一个三角形，如下所示。很显然，这是一个非常耗时的操作，尤其是场景中物体非常多的情况下。对此，图形学中也有一些针对交点判定加速的优化方法。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-12.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="包围盒">包围盒</h3>
<p><strong>包围盒</strong>（Bounding
Box）的原理是使用一个简单的几何体包围一个复杂的物体，如果光线与包围盒没有交点，那么必然与内部物体没有交点，从而达到交点判定加速的目的。</p>
<h4 id="轴对齐包围盒">轴对齐包围盒</h4>
<p>包围盒通常是长方体。对于长方体，我们将它理解成
<strong>三对不同的平行面形成的交集</strong>，在实际应用中，我们会使用一种特殊的长方体，即三对面各自与坐标系的轴对齐，因此称为
<strong>轴对齐包围盒</strong>（Axis-Aligned Bounding Box，AABB）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-13.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="交点判定">交点判定</h4>
<p>很显然，接下来的问题就是如何判断光线是否与轴对齐包围盒相交。这里，我们首先考虑
2D 情况下的交点判定，然后进一步延伸至 3D 情况下的交点判定。</p>
<p>对于 2D 的情况，如下所示，分为三个步骤：</p>
<ul>
<li>考虑光线与 <span class="math inline">\(x_0\)</span>、<span
class="math inline">\(x_1\)</span>
两个面的交点，根据方程组可以计算出一组 <span
class="math inline">\(t_{min}\)</span> 和 <span
class="math inline">\(t_{max}\)</span>。</li>
<li>考虑光线与 <span class="math inline">\(y_0\)</span>、<span
class="math inline">\(y_1\)</span>
两个面的交点，根据方程组又可以计算出一组 <span
class="math inline">\(t_{min}\)</span> 和 <span
class="math inline">\(t_{max}\)</span>。</li>
<li>对于两组 <span class="math inline">\(t_{min}\)</span> 和 <span
class="math inline">\(t_{max}\)</span>，我们必须保证 <span
class="math inline">\(t_{min}\)</span> 大于
0，否则表示交点在光源的背后，没有实际意义。两组 <span
class="math inline">\(t_{min}\)</span> 和 <span
class="math inline">\(t_{max}\)</span>
各自构成一个线段，我们只需要计算两者的交集，即可得到光线在长方形内的传播路径，而传播路径的两个端点正是光线与长方形的两个交点。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-14.png?x-oss-process=image/resize,w_800" /></p>
<p>对于 3D 的情况，我们只需要额外延伸一步即可。</p>
<ul>
<li>考虑光线与 <span class="math inline">\(z_0\)</span>、<span
class="math inline">\(z_1\)</span>
两个面的交点，根据方程组又可以计算出一组 <span
class="math inline">\(t_{min}\)</span> 和 <span
class="math inline">\(t_{max}\)</span>。</li>
<li>求解三组 <span class="math inline">\(t_{min}\)</span> 和 <span
class="math inline">\(t_{max}\)</span>
各自构成的线段，求线段的交集即可得到光线在包围盒内的传播路径，传播路径的两个端点正是光线与包围盒的两个交点。</li>
</ul>
<p>最终求解得到的 <span class="math inline">\(t_{enter}\)</span> 和
<span class="math inline">\(t_{exit}\)</span>
的值可能存在一下几种情况：</p>
<ul>
<li>当 <span class="math inline">\(t_{exit}\)</span> &lt; 0
时，表示包围盒在光源的背后，没有交点。</li>
<li>当 <span class="math inline">\(t_{enter}\)</span> &lt; 0 且 <span
class="math inline">\(t_{exit}\)</span> &gt;= 0
时，表示光线在包围盒的内部。</li>
<li>当且仅当 <span class="math inline">\(t_{enter}\)</span> &lt; <span
class="math inline">\(t_{exit}\)</span>，<span
class="math inline">\(t_{exit}\)</span> &gt;= 0
时，光线和包围盒存在交点。</li>
</ul>
<h3 id="统一网格">统一网格</h3>
<p>统一网格（Uniform
grids）是包围盒技术的延伸，它对包围盒内部的空间进行预处理。</p>
<ul>
<li>将包围盒拆分成统一的立体网格</li>
<li>将与物体发生重叠的网格进行标识</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-15.png?x-oss-process=image/resize,w_800" /></p>
<p>在判断光线与包围盒内部物体的交点时，会先遍历所有网格。当网格与光线有交点时，会继续判断网格内的物体是否与光线有交点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-16.png?x-oss-process=image/resize,w_800" /></p>
<p>关于网格的划分，不同的划分方法，加速效果存在差异。</p>
<ul>
<li>当只有一个网格时，没有加速效果。</li>
<li>当网格划分非常密集时，计算交点时遍历网格的开销会增大，甚至会出现性能降低的情况。</li>
</ul>
<p>相对而言，一个加速效果良好的网格划分经验是：网格的数量等于物体的数量乘以一个常数（经验值是
27）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-17.png?x-oss-process=image/resize,w_800" /></p>
<p>然而，统一网格划分并不是万能的，它只适用于一些物体分布均匀的场景。如下所示的场景中，在餐桌上方存在大量没有物体的空间，此时使用统一网格划分的效果并不好。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-18.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="空间划分">空间划分</h3>
<p>空间划分（Spatial
partitions）主要是为了解决空间中物体分布不均匀的问题，其主要有
<strong>Oct-Tree</strong>、<strong>KD-Tree</strong>、<strong>BSP-Tree</strong>
等几种技术。</p>
<p>Oct-Tree，又称八叉树，其基本原理是把立方体分割成八等份，递归进行分割，直到格子为空或者物体足够少。</p>
<p>KD-Tree，与 Oct-Tree
类似，区别在于每次只将格子一分为二，总是沿着有个轴进行分割。相比于
Oct-Tree，其节点数量的复杂度不会随着维度而指数型增长。</p>
<p>BSP-Tree，对空间一分为二，每次选择一个方向进行分割。相比于
KD-Tree，其切割的方向并不一定与轴平行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-19.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="kd-tree">KD-Tree</h4>
<p>这里我们着重介绍一下 KD-Tree 的工作原理。</p>
<p>首先，KD-Tree
会对包围盒空间进行预处理，对包围盒空间进行二分，同时构建二叉树，如下所示。其中，非叶子节点表示二分之前的整体空间，它不会存储物体；叶子节点表示存储物体的真实空间。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-20.png?x-oss-process=image/resize,w_800" /></p>
<p>在进行交点判定时，本质上就是对二叉树进行先序遍历。对于上图中的例子，我们判定光线是否与整体的空间
A 有交点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-22.png?x-oss-process=image/resize,w_800" /></p>
<p>显然，上述例子中光线与空间 A 存在交点，那么它会节点 A 的两个叶子节点
1 和 B
分别进行交点判定，如下所示。如果交点存在则进一步判断内部物体是否与光线有交点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-23.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-28.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示，当与空间 B 存在交点时，则进一步遍历空间 B 的子节点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-24.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-25.png?x-oss-process=image/resize,w_800" /></p>
<p>以此类推，空间 C
与光线仍然存在交点，则继续遍历二叉树，直到判定光线与物体之间存在交点或不存在交点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-26.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-27.png?x-oss-process=image/resize,w_800" /></p>
<p>直观而言，KD-Tree 确实能够有效加速交点判定。但是 KD-Tree
也存在一些无法解决的问题，比如：</p>
<ul>
<li>存在无法判定的例子，比如：三角形反包围了包围盒。</li>
<li>同一物体被划分在多个包围盒中，会有重复判断的问题。</li>
</ul>
<h3 id="物体划分">物体划分</h3>
<p>针对空间划分无法解决的问题，图形学采用物体划分来解决。下面，我们来介绍物体划分的典型技术——BVH。</p>
<h4 id="bvh">BVH</h4>
<p>BVH（Bounding Volume Hierarchy）的整体原理与 KD-Tree
类似，唯一的区别在于对于空间划分的方式不同。KD-Tree
是对空间进行划分，BVH 是对物体进行划分。</p>
<p>如下所示，空间中的物体彼此之间非常靠近。如果我们采用 KD-Tree
的划分方式，那么一个物体可能会包含在多个空间中，进而存在重复判定的情况。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-29.png?x-oss-process=image/resize,w_800" /></p>
<p>对此，BVH
对物体进行划分，并重新计算包围盒，形成根节点的子节点。以此类推，最终在所有叶子节点存储物体列表。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-30.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="交点渲染原理">交点渲染原理</h2>
<p>当我们获取到光线直射、反射至物体表面的交点之后，我们可以进一步计算这些交点的着色，从而完成渲染。</p>
<h3 id="光线追踪的问题">光线追踪的问题</h3>
<p>关于经典光线追踪，即 Whitted-Style Ray
Tracing，对光线作出了如下假设。</p>
<ul>
<li><strong>光线只进行镜面反射和折射</strong></li>
<li><strong>光线在漫反射面停止弹射</strong></li>
</ul>
<p>对于第一种情况，经典光线追踪只能渲染镜面反射，无法渲染磨砂反射，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-33.png?x-oss-process=image/resize,w_800" /></p>
<p>对于第二种情况，对于漫反射物体，光线转播至表面时会停止弹射，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-34.png?x-oss-process=image/resize,w_800" /></p>
<p>既然经典光线追踪是存在问题的，那么我们该如何对交点进行渲染呢？答案是渲染方程。</p>
<h3 id="渲染方程定义">渲染方程定义</h3>
<p>关于渲染，我们在 <a
href="http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/">上一篇文章</a>
中介绍了辐射度量学，文中我们提到了渲染方程，如下所示。</p>
<span class="math display">\[\begin{aligned}
L_r(p, {\omega}_r) = L_e(p, {\omega}_r) + \int_{H^2}L_i(p, {\omega}_i)
f_r(p, {\omega}_i, {\omega}_r) (n \cdot {\omega}_i) d{\omega}_i
\end{aligned}\]</span>
<h3 id="渲染方程展开">渲染方程展开</h3>
<p>渲染方程经过一系列变换可以简化成如下表达式。</p>
<span class="math display">\[\begin{aligned}

l(u) = e(u) + \int l(v) K(u, v) dv

\end{aligned}\]</span>
<p>我们将 <span class="math inline">\(K\)</span>
作为反射操作符，可以进一步将简化为如下表达式，<span
class="math inline">\(L\)</span> 是一个递归项。</p>
<span class="math display">\[\begin{aligned}

L = E + KL

\end{aligned}\]</span>
<p>我们的目的是求解 <span class="math inline">\(L\)</span>，前面说 <span
class="math inline">\(K\)</span>
是一个反射操作符，其实我们也可以将其理解为反射次数，反射次数越多，展开项越多，比如：<span
class="math inline">\(K^2\)</span> 表示光在空间中弹射两次。</p>
<span class="math display">\[\begin{aligned}

L = &amp; E + KL
\\
IL - KL = &amp; E
\\
(I - K)L = &amp; E
\\
L = &amp; (I - K)^{-1}E
\\
L = &amp; (I + K + K^2 + K^3 + ...)E
\\
L = &amp; E + KE + K^{2}E + K^{3}E + ...
\\

\end{aligned}\]</span>
<p>我们可以非常容易地理解展开后的渲染方程中的各个项，如下所示。全局光照由
<strong>光源</strong>、<strong>直接光照</strong>、<strong>间接光照</strong>
组合而成，其中光栅化只包含了光源和直接光照两部分，难以实现间接光照；光线追踪则包含了全局光照。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-31.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示，展示了全局光照包含不同数量的光照项的渲染对比效果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-32.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="求解理论基础">求解理论基础</h3>
<p>关于如何求解渲染方程，我们首先介绍两部分与之相关的内容。</p>
<ul>
<li>概率论基础</li>
<li>蒙特卡洛积分</li>
</ul>
<h4 id="概率论基础">概率论基础</h4>
<p>这里我们主要介绍概率、概率分布函数、期望等几个概念。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-35.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示是一个的连续的概率分布曲线 <span class="math inline">\(X \sim
p(x)\)</span>，横坐标表示目标值 <span
class="math inline">\(x\)</span>，纵坐标表示目标值为 <span
class="math inline">\(x\)</span> 的概率 <span
class="math inline">\(p(x)\)</span>，即
<strong>概率分布函数</strong>（Probability Distribution
Function，PDF），那么我们可以得到如下两个关系式：</p>
<ul>
<li>所有取值的概率之和为 <span class="math inline">\(1\)</span></li>
<li>期望为概率与目标值乘积的积分 <span
class="math inline">\(E[X]\)</span></li>
</ul>
<span class="math display">\[\begin{aligned}

\int p(x) dx = &amp; 1; &amp;&amp;  p(x) \geq 0
\\
E[X] = &amp; \int x p(x) dx

\end{aligned}\]</span>
<h4 id="蒙特卡洛积分">蒙特卡洛积分</h4>
<p>假设我们希望求解如下所示的不定积分，那么该如何求解？答案是蒙特卡洛积分。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-36.png?x-oss-process=image/resize,w_800" /></p>
<p>蒙特卡洛积分（Monte Carlo
Integration）的基本思想是：在积分域内不断采样 <span
class="math inline">\(f(x)\)</span>，不断地与 <span
class="math inline">\(ab\)</span>
构成一个个长方形，然后对所有的长方形的面积之和求平均值。由此我们可以得到离散形式的蒙特卡洛方程，如下所示。</p>
<span class="math display">\[\begin{aligned}

F_N = \frac{1}{N} \sum^{1}_{i=1} \frac{f(x_i)}{p(x_i)}

\end{aligned}\]</span>
<p>我们将其进一步表示为更加通用的连续形式的蒙特卡洛方程，如下所示。</p>
<span class="math display">\[\begin{aligned}

\int_{a}^{b} f(x) dx = \frac{1}{N} \sum_{i=1}^{N} \frac{f(x_i)}{p(x_i)}

\end{aligned}\]</span>
<p>对于蒙特卡洛积分，当 <span class="math inline">\(N\)</span>
越大，求解的结果越精准。</p>
<h3 id="渲染方程求解">渲染方程求解</h3>
<p>在了解了概率论基础和蒙特卡洛积分之后，我们来正式求解渲染方程。</p>
<h4 id="求解过程分析">求解过程分析</h4>
<p>假设，我们只考虑一个像素点的着色过程，如下图所示。其中，<span
class="math inline">\({\omega}_o\)</span>
为观测方向，即从着色点到观测点的方向；<span
class="math inline">\({\omega}_i\)</span>
为光线入射方向，即从光源到着色点的方向。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-37.png?x-oss-process=image/resize,w_800" /></p>
<p>同时，我们先忽略着色点本身的发光项，那么可以得到一个简化的渲染方程，如下所示。</p>
<span class="math display">\[\begin{aligned}

L_o(p, {\omega}_o) = \int_{H^2} L_i(p, {\omega}_i) f_r(p, {\omega}_i,
{\omega}_o) (n \cdot {\omega}_i) d{\omega}_i

\end{aligned}\]</span>
<p>我们将渲染等价为在半球面上进行采样。因此，任意一点的采样概率 <span
class="math inline">\(p({\omega}_i)\)</span> 为 <span
class="math inline">\(1/2\pi\)</span>，即概率分布函数（PDF）。对应，采样值
<span class="math inline">\(f({\omega}_i)\)</span> 为 <span
class="math inline">\(L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o)
(n \cdot
{\omega}_i)\)</span>。由此可以用蒙特卡洛积分来求解渲染方程，如下所示。</p>
<span class="math display">\[\begin{aligned}

L_o(p, {\omega}_o) = &amp;
\int_{H^2}L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o) (n \cdot
{\omega}_i) d{\omega}_i
\\
\approx &amp;
\frac{1}{N} \sum_{i=1}^{N} \frac{f({\omega}_i)}{p({\omega}_i)}
\\
\approx &amp;
\frac{1}{N} \sum_{i=1}^{N} \frac{L_i(p, {\omega}_i) f_r(p, {\omega}_i,
{\omega}_o) (n \cdot {\omega}_i) }{p({\omega}_i)}

\end{aligned}\]</span>
<p>根据上述的渲染方程的求解关系式，我们可以实现对应的伪代码，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-38.png?x-oss-process=image/resize,w_800" /></p>
<p>上述，我们只处理了光的一次弹射，而全局光照还包括二次弹射、三次弹射...我们该如何处理呢？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-39.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，我们希望计算 Q 点反射到 P
点的光线。对此，我们可以转换一下思路：Q 点反射到 P 点的光线，不就等于从
P 点观测 Q 点，Q
点的着色吗？于是全局光照就转换成了一个递归着色的过程。如下所示，我们加入了处理全局光照的递归着色。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-40.png?x-oss-process=image/resize,w_800" /></p>
<p>至此，着色算法的整体框架已经实现了，但是还存在两个问题：</p>
<ul>
<li>分治爆炸问题</li>
<li>无限递归问题</li>
</ul>
<h4 id="分治爆炸问题">分治爆炸问题</h4>
<p>在上述算法实现中，对于每一个点的着色，我们都会采样各个方向，而每一个方向所经过的反射点又会采样各个方向。如果我们对于每个点采样
100 个方向，那么在下一次递归中将会采样 10000
个方向，依次类推，产生分治爆炸问题。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-41.png?x-oss-process=image/resize,w_800" /></p>
<p>那么如何解决这个问题？很显然，只有当采样数量为 1
时，递归时才不会出现分治爆炸问题。在计算机图形学中，对于每个着色点，只通过一条射线进行光线追踪的方式被称为
<strong>路径追踪</strong>（Path Tracing）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-42.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示，为解决了分支爆炸问题的着色算法。我们不再采样各个方向，而是随机采样一个方向，进而计算着色。然而，我们知道在蒙特卡洛积分中，采样数越小，准确性越低。算法中将采样数降至
1，很显然，会出现很大的噪声。那么这又该如何解决呢？</p>
<p>对此，有一种方法另辟蹊径：<strong>每个像素生成多条光线，进行多次路径追踪，并求解平均值</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-43.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示，我们定义了一个 <code>ray_generation</code>
方法，它以相机位置和像素点作为参数，内部对这个像素点进行多次路径追踪，即调用
<code>shade</code> 方法，最终求解平均值。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-44.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="无限递归问题">无限递归问题</h4>
<p>对于无限递归问题，很显然，我们必须要找到一个停止递归的策略。对此，图形学借鉴了
<strong>俄罗斯轮盘赌</strong>（Russion Roulette，RR）的思想。</p>
<p>俄罗斯轮盘赌的基本原理是设定一个概率值 <span class="math inline">\(0
&lt; P &lt; 1\)</span>。</p>
<ul>
<li>射出光线的概率为 <span
class="math inline">\(P\)</span>，由此返回的着色结果为 <span
class="math inline">\(L_0/P\)</span></li>
<li>不射出光线的概率为 <span
class="math inline">\(1-P\)</span>，由此返回的着色结果为 <span
class="math inline">\(0\)</span></li>
</ul>
<p>使用这种方式，我们仍然可以期望得到 <span
class="math inline">\(L_0\)</span>，如下所示为俄罗斯轮盘赌的期望公式.</p>
<span class="math display">\[\begin{aligned}
E = P * (L_0 / P) + (1 - P) * 0 = L_0
\end{aligned}\]</span>
<p>于是，我们可以进一步优化着色算法，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-45.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="光源采样问题">光源采样问题</h4>
<p>经过上述改进，着色算法是正确了，但是它并不高效。如下所示，像素采样必须达到一定阈值才能得到相对高质量的结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-46.png?x-oss-process=image/resize,w_800" /></p>
<p>这里的根本原因在于均匀采样，其中只有极少数方向能够打到光源，大多数方向则浪费掉了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-47.png?x-oss-process=image/resize,w_800" /></p>
<p>对此，我们可以考虑直接对光源进行采样。考虑到我们在求解蒙特卡洛积分时是在立体角进行采样，因此我们将空间中的面光源投影到球面上，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-48.png?x-oss-process=image/resize,w_800" /></p>
<p>我们得到立体角和光源微分面积的关系如下所示。</p>
<span class="math display">\[\begin{aligned}

d\omega = \frac{dA cos{\theta}&#39;}{||x&#39; - x||^2}

\end{aligned}\]</span>
<p>然后，我们微分立体角代入渲染方程，如下所示。</p>
<span class="math display">\[\begin{aligned}

L_o(p, {\omega}_o) = &amp;
\int_{H^2}L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o) cos\theta
d{\omega}_i
\\
= &amp;
\int_{H^2} L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o)
\frac{cos\theta cos{\theta}&#39;}{||x&#39; - x||^2} dA

\end{aligned}\]</span>
<p>现在，我们认为着色结果来源于两部分：</p>
<ul>
<li>光源的直接作用：直接采样光源，无需俄罗斯轮盘赌</li>
<li>光源的间接作用：反射、漫反射，需要俄罗斯轮盘赌</li>
</ul>
<p>由此，我们结合两部分得到如下所示的优化算法。当然，对于光源的直接作用，我们需要判断光源与着色点之间是否存在遮挡，这一点一定要注意。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-49.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了光线追踪的原理。首先，我们我们介绍了光线追踪的基本原理，其主要包括：视线生成和像素着色两个阶段。</p>
<p>然后，我们介绍了经典光线追踪技术，也称为 Whitted-Style
光线追踪，其引入了间接光照的处理。</p>
<p>在光线追踪中，主要设计两个关键技术，分别是交点判定和交点渲染。对于交点判定，我们介绍了包围盒原理、统一网格、空间划分、物体划分等技术；对于交点渲染，我们在经典光线追踪的基础上引入了漫反射的处理，整体围绕渲染方程进行展开，使用蒙特卡洛积分进行求解。</p>
<p>在实现渲染方程算法的过程中，我们遇到了分治爆炸、无限递归、光源采样等问题，对此我们也依次进行了处理。最终实现了一个完整的着色算法。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《GAMES 101》</li>
</ol>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>Whitted-Stype Ray Tracing</tag>
        <tag>交点判定</tag>
        <tag>交点渲染</tag>
        <tag>包围盒</tag>
        <tag>轴对齐包围盒</tag>
        <tag>KD-Tree</tag>
        <tag>BVH</tag>
        <tag>蒙特卡洛积分</tag>
        <tag>路径追踪</tag>
        <tag>光线追踪</tag>
        <tag>俄罗斯轮盘赌</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程——Functor、Applicative、Monad</title>
    <url>/2020/07/06/fp-functor-applicative-monad/</url>
    <content><![CDATA[<p>了解函数式编程的同学可能或多或少都听说过
<strong>函子</strong>（Functor）、<strong>适用函子</strong>（Applicative）、<strong>单子</strong>（Monad）等概念，但是，能真正理解的人可能就比较少了。网上有很多相关的文章，甚至有一些书籍也开辟了章节进行了介绍，但是能解释清楚的，寥寥无几。最近，我出于阅读
RxSwift
源码，花时间研究了这几个概念。本文是我在理解函子、适用函子、单子等概念之后作出的总结。</p>
<span id="more"></span>
<p>本文使用的示例编程语言为 Swift。</p>
<h1 id="基本概念">基本概念</h1>
<h2 id="类型构造体">类型构造体</h2>
<p><strong>类型构造体</strong>（Type
Constructor），简而言之，即：<strong>以泛型作为参数来构建具体类型的类型</strong>，可以简称为泛型类。通过类型构造体，我们能够抽象出更加通用的数据类型。Swift
中内置的 <code>Optional&lt;Wrapped&gt;</code> 和
<code>Array&lt;Element&gt;</code> 都是类型构造体。</p>
<h2 id="不相交联合体">不相交联合体</h2>
<p><strong>不相交联合体</strong>（Disjoint Union）类似于 C 语言中的
<strong>联合体</strong>（Union）数据类型，可以认为是一种包装类型，能够在同一个位置上容纳不同类型的单个实例。函数式编程中常用的数据结构
<code>Either</code> 类型就是一种不相交联合体类型，如下所示为一个容纳
<code>Int</code> 类型的 <code>Either</code> 类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Either</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> left(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> right(<span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型不相交联合体">泛型不相交联合体</h2>
<p>当我们将 <strong>类型构造体</strong> 和 <strong>不相交联合体</strong>
组合在一起使用时，能够抽象出更加通用的泛型不相交联合体类型。如下所示，<code>Either</code>
类可以通过为 <code>L</code> 和 <code>R</code>
绑定不同的泛型类型来定义一个包装类。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Either</span>&lt;<span class="title class_">L</span>, <span class="title class_">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> left(<span class="type">L</span>)</span><br><span class="line">    <span class="keyword">case</span> right(<span class="type">R</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Swift 中，内置的 <code>Optional</code>
类型就是一种可以通过泛型进行绑定的包装类，如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="title class_">Wrapped</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> none</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Swift 中的 <code>Array</code>
也是一种特殊包装类，不过，<code>Array</code> 只能绑定一种泛型类型。</p>
<p>下文，我们将通过自定义一种不相交联合体 <code>Result</code>
类型，分别介绍函子、适用函子、单子。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="functor">Functor</h1>
<p>在普通情况下，使用函数对一个值进行操作，如：对 <code>Int</code>
值进行 <code>+3</code> 操作，我们可以定义一个 <code>plusThree</code>
函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">plusThree</span>(<span class="keyword">_</span> <span class="params">addend</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addend <span class="operator">+</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 <code>plusThree</code> 能够对 <code>Int</code> 类型进行
<code>+3</code> 操作，但似乎无法对包装类 <code>Result</code>
进行同样的操作。那么如何解决这个问题呢？<strong>函子</strong>（Functor）就是用于解决该场景下的问题。</p>
<p><strong>函子能够将普通函数应用到一个包装类型</strong>。</p>
<p>Swift 中，默认实现了 <code>map</code> 方法（在 Haskell 中是
<code>fmap</code>）的类型就是函子，即 <code>map</code>
方法能够将普通函数应用到一个包装类型。如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span>.success(<span class="number">2</span>).map(plusThree)</span><br><span class="line"><span class="comment">// =&gt; .success(5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用尾随闭包语法</span></span><br><span class="line"><span class="type">Result</span>.success(<span class="number">2</span>).map &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">3</span> &#125;</span><br><span class="line"><span class="comment">// =&gt; .success(5)</span></span><br></pre></td></tr></table></figure>
<p>我们以 <code>Result</code> 类型为例，通过实现 <code>map</code>
方法，使其成为函子。如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="comment">// 满足 Functor 的条件：map 方法能够将 普通函数 应用到包装类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">f</span>: (<span class="type">T</span>) -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> x): <span class="keyword">return</span> .success(f(x))</span><br><span class="line">        <span class="keyword">case</span> .failure: <span class="keyword">return</span> .failure</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>map</code>
实现的具体原理是：通过模式匹配将取出包装类中的值，并将普通函数应用到该值上，最终将计算结果再放到包装类中用于返回。其过程如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/fp-map.png" /></p>
<p>出于简化目的，我们可以为 <code>map</code> 方法定义一个中缀运算符
<code>&lt;^&gt;</code>（在 Haskell 中则是
<code>&lt;$&gt;</code>），具体实现如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precedencegroup</span> <span class="title">ChaningPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">higherThan</span>: <span class="type">TernaryPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;^&gt;</span>: <span class="type">ChaningPrecedence</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;^&gt;&lt;</span><span class="type">T</span>, <span class="type">U</span><span class="operator">&gt;</span>(f: (<span class="type">T</span>) -&gt; <span class="type">U</span>, a: <span class="type">Optional</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.map(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;^&gt;</code> 的使用方法如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 <span class="operator">=</span> plusThree <span class="operator">&lt;^&gt;</span> <span class="type">Result</span>.success(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// =&gt; success(13)</span></span><br></pre></td></tr></table></figure>
<p>在 Swift 中，内置的 <code>Array</code> 类型就是函子，其默认实现的
<code>map</code> 方法可以将普通方法应用到 <code>Array</code>
类型，最终返回一个 <code>Array</code> 类型。如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayA <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> arrayB <span class="operator">=</span> arrayA.map &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">3</span> &#125; </span><br><span class="line"><span class="comment">// =&gt; [4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure></p>
<p>在 RxSwift 中，<code>Observable</code> 类型也是函子，其默认实现的
<code>map</code> 方法可以将普通方法应用到 <code>Observable</code>
类型，最终返回一个 <code>Observale</code> 类型。如下所示：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observe <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.just(<span class="number">1</span>).map &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="applicative">Applicative</h1>
<p>函子能够将普通函数应用到包装类中，那么如何将包装函数应用到包装类中呢？何为包装函数？包装函数可以理解为使用包装类将普通函数进行了封装。如下所示：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数作为值，封装在 Result 类中</span></span><br><span class="line"><span class="keyword">let</span> wrappedFunction <span class="operator">=</span> <span class="type">Result</span>.success(&#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">3</span> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>那么如何解决这个问题呢？<strong>适用函子</strong>（Applicative）就是用于解决该场景下的问题。</p>
<p><strong>适用函子能够将包装函数应用到一个包装类型</strong>。</p>
<p>Swift 中，默认实现了 <code>apply</code> 方法的类型就是适用函子，即
<code>apply</code> 方法能够将包装函数应用到一个包装类型。</p>
<p>我们以 <code>Result</code> 类型为例，通过实现 <code>apply</code>
方法，使其成为适用函子。如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="comment">// 满足 Applicative 的条件：apply 方法能够将 包装函数 应用到包装类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">f</span>: <span class="type">Result</span>&lt;(<span class="type">T</span>) -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> f &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> normalF): <span class="keyword">return</span> map(normal)</span><br><span class="line">        <span class="keyword">case</span> .failure: <span class="keyword">return</span> .failure</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>apply</code>
实现的具体原理是：通过模式匹配分别从包装函数和包装类型中取出普通函数和值，将普通函数应用于值上，再将得到的结果放入包装类型，最终将返回包装类型。其过程如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/fp-applicative.png" /></p>
<p>出于简化目的，我们可以为 <code>apply</code> 方法定义一个中缀运算符
<code>&lt;*&gt;</code>，具体实现如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;*&gt;</span>: <span class="type">ChainingPrecedence</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;*&gt;&lt;</span><span class="type">T</span>, <span class="type">U</span><span class="operator">&gt;</span>(f: <span class="type">Result</span>&lt;(<span class="type">T</span>) -&gt; <span class="type">U</span>&gt;, a: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.apply(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;*&gt;</code> 的使用方法如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wrappedFunction: <span class="type">Result</span>&lt;(<span class="type">Int</span>) -&gt; <span class="type">Int</span>&gt; <span class="operator">=</span> .success(plusThree)</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> wrappedFunction <span class="operator">&lt;*&gt;</span> <span class="type">Result</span>.success(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// =&gt; success(13)</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便日常开发，我们可以为 Swift 的常用的 <code>Optional</code> 和
<code>Array</code> 类型实现 <code>apply</code>
方法，从而成为适用函子。如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Optional</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">f</span>: <span class="type">Optional</span>&lt;(<span class="type">Wrapped</span>) -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> f &#123;</span><br><span class="line">        <span class="keyword">case</span> .some(<span class="keyword">let</span> someF): <span class="keyword">return</span> <span class="keyword">self</span>.map(someF)</span><br><span class="line">        <span class="keyword">case</span> .none: <span class="keyword">return</span> .none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">apply</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">fs</span>: [(<span class="type">Element</span>) -&gt; <span class="type">U</span>]) -&gt; [<span class="type">U</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> [<span class="type">U</span>]()</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs &#123;</span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span>.map(f) &#123;</span><br><span class="line">                result.append(element)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="monad">Monad</h1>
<p>函子可以将普通函数应用到包装类型；使用函子可以将包装函数应用到包装类型；<strong>单子</strong>（Monad）则可以将会返回包装类型的普通函数应用到包装类型。</p>
<p><strong>适用函子能够回返回包装类型的普通函数应用到一个包装类型。</strong></p>
<p>Swift 中，默认实现了 <code>flatMap</code> 方法（或称为
<code>bind</code>）的类型就是单子，即 <code>flatMap</code>
方法能够会返回包装类型的普通函数应用到一个包装类型。很多人喜欢用
<strong>降维</strong> 来形容 <code>flatMap</code> 的能力，其实
<code>flatMap</code> 能做的，不止如此。</p>
<p>我们以 <code>Result</code> 类型为例，通过实现 <code>flatMap</code>
方法，使其成为单子。如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">flatMap</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">f</span>: (<span class="type">T</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> x): <span class="keyword">return</span> f(x)</span><br><span class="line">        <span class="keyword">case</span> .failure: <span class="keyword">return</span> .failure</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于简化目的，我们可以为 <code>flatMap</code> 方法定义一个中缀运算符
<code>&gt;&gt;-</code>（在 Haskell 中则是
<code>&gt;&gt;=</code>），具体实现如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;*&gt;&lt;</span><span class="type">T</span>, <span class="type">U</span><span class="operator">&gt;</span>(f: <span class="type">Result</span>&lt;(<span class="type">T</span>) -&gt; <span class="type">U</span>&gt;, a: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.apply(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;=</code> 的使用方法如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyFive</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;.success(a <span class="operator">*</span> <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="type">Result</span>.success(<span class="number">10</span>) <span class="operator">&gt;&gt;-</span> multiplyFive <span class="operator">&gt;&gt;-</span> multiplyFive</span><br><span class="line"><span class="comment">// =&gt; success(250)</span></span><br></pre></td></tr></table></figure></p>
<p>在 RxSwift 中，<code>Observable</code> 类型也是单子，其默认实现的
<code>flatMap</code> 方法可以将会返回 <code>Observable</code>
类型的方法应用到 <code>Observable</code> 类型，最终返回一个
<code>Observale</code> 类型。如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observe <span class="operator">=</span> <span class="type">Observable</span>.just(<span class="number">1</span>).flatMap &#123; num <span class="keyword">in</span></span><br><span class="line">    <span class="type">Observable</span>.just(<span class="string">&quot;The number is <span class="subst">\(num)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>最后，我们总结一下函子、适用函子、单子的定义：</p>
<ul>
<li>函子：可以通过 <code>map</code> 或 <code>&lt;^&gt;</code>
将普通函数应用到包装类型</li>
<li>适用函子：可以通过 <code>apply</code> 或 <code>&lt;*&gt;</code>
将包装函数应用到包装类型</li>
<li>单子：可以通过 <code>flatMap</code> 或 <code>&gt;&gt;-</code>
将会返回包装类型的普通函数应用到包装类型</li>
</ul>
<p>通过对函子、适用函子、单子进行组合应用，我们可以最大化地释放出函数式编程的魅力。在
RxSwift
中，同样大量应用了函子、试用函子、单子。在后面的文章中，我们将进一步探索
RxSwift 是如何利用它们来构建一个函数响应式框架的。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://www.haskell.org/">Haskell</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a></li>
<li><a
href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors,
Applicatives, And Monads In Pictures</a></li>
<li><a
href="http://adit.io/posts/2013-06-10-three-useful-monads.html">Three
Useful Monads</a></li>
<li><a
href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/">Swift
Functors, Applicative, and Monads in Pictures</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1371274">什么是
Monad (Functional Programming)？函子到底是什么?ApplicativeMonad</a></li>
<li><a
href="http://www.yinwang.org/blog-cn/2013/03/31/purely-functional">函数式语言的宗教</a></li>
<li><a href="https://fsharpforfunandprofit.com/fppatterns/">Functional
Programming Design Patterns</a></li>
<li><a href="https://fsharpforfunandprofit.com/rop/">Railway Oriented
Programming</a></li>
<li><a href="https://www.jianshu.com/p/001ff0dd3c30">函数式编程 -
一篇文章概述Functor(函子)、Monad(单子)、Applicative)</a></li>
<li><a
href="https://github.com/apple/swift-evolution/blob/master/proposals/0077-operator-precedence.md">Improved
operator declarations</a></li>
</ol>
]]></content>
      <categories>
        <category>编程范式</category>
      </categories>
      <tags>
        <tag>函子</tag>
        <tag>适用函子</tag>
        <tag>单子</tag>
        <tag>Functor</tag>
        <tag>Applicative</tag>
        <tag>Monad</tag>
      </tags>
  </entry>
  <entry>
    <title>Future 和 Promise</title>
    <url>/2022/12/05/future-and-promise/</url>
    <content><![CDATA[<p>从异步与并发编程兴起以来，学术界与工业界提出了非常多的解决方案，本文将要介绍的
Future 和 Promise 正是其中的两种解决方案。Future 和 Promise
的实现理念非常相似，两者在发展过程中相互借鉴，相互融合。目前，很多流行的语言和框架都引入了
Future 和 Promise 的概念，如：JavaScript、Node.js、Scala、Java、C++
等。</p>
<span id="more"></span>
<p>本文，我们来简单聊一聊 Future 和 Promise
历史和设计，以及两者之间的关系与区别。</p>
<h1 id="历史简介">历史简介</h1>
<h2 id="thunk">1962. Thunk</h2>
<p>关于 Future 和 Promise 的起源，最早可以追溯到 1961 年的
Thunk。根据创造者 P.Z. Ingerman 的描述，<strong>Thunk
是提供地址的一段代码</strong>。</p>
<p>Thunk 被设计为一种将实际参数绑定到 Algol-60
过程调用中的正式定义的方法。如果用表达式代替形式参数调用过程，编译器会生成一个
thunk，它将执行表达式并将结果的地址留在某个标准位置。</p>
<p>目前，thunk 的用法仍然非常广泛，我在 <a
href="http://chuquan.me/2021/09/25/swift-generic-protocol/">《Swift
泛型协议》</a> 一文中也提到过 thunk 的释义。</p>
<h2 id="future">1977. Future</h2>
<p>1977 年，Henry C. Baker 和 Hewitt 在论文《The Incremental Garbage
Collection of Process》中首次提到 Future。</p>
<p>他们提出了一个新的术语 <code>call-by-future</code>，用于描述一种基于
Future 的调用形式。当将表达式提供给执行器时，将返回该表达式的
<code>.future</code>。如果表达式返回类型为值类型，那么当未来表达式计算得到值时，会将值返回。这里会为每一个
<code>future</code>
都会创建一个进程，并立即执行表达式。如果表达式已完成，则值立即可用；如果表达式未完成，则请求进程等待表达式执行完成。</p>
<p>在论文中，Future 主要由三部分组成：</p>
<ul>
<li><strong>进程（Process）</strong>：用于执行表达式的进程。</li>
<li><strong>单元（Cell）</strong>：可写入值的内存地址，用于存储表达式的未来值。</li>
<li><strong>队列（Queue）</strong>：等待未来值的进程列表。</li>
</ul>
<p>从 Future 的概念我们可以看出，论文所提到的 Future 几乎已经和现代的
Future 概念非常接近了。</p>
<h2 id="multilisp">1985. Multilisp</h2>
<p>1985 年，Robert H. Halstead 在论文《Multilisp: A Language for
Concurrent Symbolic Computation》中提出的 Multilisp 语言支持了基于
<code>future</code> 注解的 <code>call-by-future</code> 能力。</p>
<p>在 Multilisp 中，如果变量绑定到 Future
的表达式，则会自动创建一个新的进程。表达式会在新的进程中执行，一旦执行完成，则将计算结果保存至变量引用中。通过这种方式，Multilisp
支持在新进程中同时计算任意表达式的能力。因此，也支持无需等待 Future
完成，继续执行其他计算的能力。这样的话，如果 Future
的值从未使用过，那么整个进程就不会被阻塞，从而消除了潜在的死锁源。</p>
<p>相比于 1977 年提出的 Future，Mutilisp 实现的 Future
支持在特定情况下不阻塞进程，从而一定程度上优化了程序的执行效率。</p>
<h2 id="promise">1988. Promise</h2>
<p>1988 年，Liskov 和 Shrira 在论文《Distributed Programming in
Argus》中提出的 Argus 语言设计了一种称为 Promises 的结构。</p>
<p>与 Multilisp 中的 Future 类似，Argus 中的 Promise
也提供一个用于存储未来值的占位符。Promise 的特别之处在于，当调用 Promise
时，会立即创建并返回一个 Promise，并在新进程中进行类型安全的异步 PRC
调用。当异步 PRC 调用执行完毕，由调用者设置返回值。</p>
<h1 id="设计理念">设计理念</h1>
<p>经过数十年的发展，Future 和 Promise
的设计理念整体上非常相似，但是在不同的语言和框架实现中又存在一定的区别，对此，这里我们基于最广泛的定义进行介绍。</p>
<h2 id="整体实现">整体实现</h2>
<p>在 Scala、C++ 等编程语言中，同时包含两种结构分别对应 Future 和
Promise。作为整体实现，Future 和 Promise
可被视为同一异步编程技术中的两个部分：</p>
<ul>
<li><strong>Future</strong>：表示异步任务的
<strong>返回值</strong>，表示一个未来值的占位符，即
<strong>值的消费者</strong>。</li>
<li><strong>Promise</strong>：表示异步任务的
<strong>执行过程</strong>，表示一个值的生产过程，即
<strong>值的生产者</strong>。</li>
</ul>
<p>在同时包含 Future 和 Promise 的实现中，一般 Promise
对象会有一个关联的 Future 对象。当 Promise 创建时，Future
对象会自动实例化。当异步任务执行完毕，Promise
在内部设置结果，从而将值绑定至 Future 的占位符中。Future
则提供读取方法</p>
<p>将异步操作分成 Future 和 Promise 两个部分的主要原因是
<strong>为了实现读写分离，对外部调用者只读，对内部实现者只写</strong>。</p>
<p>下面，我们以几种语言中的实现来分别进行介绍。</p>
<h3 id="c-future-promise">C++ Future &amp; Promise</h3>
<p>在 C++ 中，Future 和 Promise 是一个异步操作的两个部分。</p>
<ul>
<li><code>std::future</code>：作为异步操作的消费者。</li>
<li><code>std::promise</code>：作为异步操作的生产者。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;std::string&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> producer = std::<span class="built_in">thread</span>([&amp;]</span><br><span class="line">&#123;</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> consumer = std::<span class="built_in">thread</span>([&amp;]</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; future.<span class="built_in">get</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">producer.<span class="built_in">join</span>();</span><br><span class="line">consumer.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出，C++ Promise 包含了 Future，可以通过
<code>get_future</code> 方法获取 Future 对象。两者有明确的分工，Promise
提供了 <code>set_value</code> 方法支持写操作，Future 提供了
<code>get</code> 方法支持读操作。</p>
<h3 id="scala-future-promise">Scala Future &amp; Promise</h3>
<p>在 Scala 中，同样如此，Future 和 Promise
可作为同一个异步操作的两个部分。</p>
<ul>
<li><code>Future</code>
作为一个可提供只读占位符，用于存储未来值的对象。</li>
<li><code>Promise</code> 作为一个实现一个
Future，并支持可写操作的单一赋值容器。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.&#123; <span class="type">Future</span>, <span class="type">Promise</span> &#125;</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">T</span>]()</span><br><span class="line"><span class="keyword">val</span> f = p.future</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> producer = <span class="type">Future</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> r = produceSomething()</span><br><span class="line">  p success r</span><br><span class="line">  continueDoingSomethingUnrelated()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = <span class="type">Future</span> &#123;</span><br><span class="line">  startDoingSomething()</span><br><span class="line">  f onSuccess &#123;</span><br><span class="line">    <span class="keyword">case</span> r =&gt; doSomethingWithResult()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出，Scala Promise 同样包含了 Future，可以通过
<code>future</code> 属性获取 Future 对象。Promise 提供了
<code>success</code>、<code>failure</code> 等方法来更新状态。Future
提供了 <code>onSuccess</code>、<code>onFailure</code>
等方法来监听未来值。</p>
<h2 id="独立实现">独立实现</h2>
<p>其他很多编程语言中，并不同时包含 Future 和 Promise
两种结构，比如：Dart 只包含 Future，JavaScript 只包含
Promise，甚至有些编程语言混淆了 Future 和 Promise 的原始区别。</p>
<p>在独立实现中，Future 和 Promise
各自都有着相对比较统一的表示形式，在实现方面的差异也相对比较一致，主要包括以下几个方面区别：</p>
<ul>
<li><strong>状态表示</strong></li>
<li><strong>状态更新</strong></li>
<li><strong>返回机制</strong></li>
</ul>
<h3 id="状态表示">状态表示</h3>
<p>在状态表示方面，Future 只有两种状态：</p>
<ul>
<li><code>uncomplete</code>：表示未完成状态，即未来值还未计算出来。</li>
<li><code>completed</code>：表示已完成状态，即未来值已经计算出来。当然计算结果可以分为值或错误两种情况。</li>
</ul>
<p>对于 Promise，一般使用三种状态进行表示：</p>
<ul>
<li><code>pending</code>：待定状态，即 Promise 的初始状态。</li>
<li><code>fulfilled</code>：满足状态，表示任务执行成功。</li>
<li><code>rejected</code>：拒绝状态，表示任务执行失败。</li>
</ul>
<p>无论是 Future 还是 Promise，状态转移的过程都是不可逆的。</p>
<h3 id="状态更新">状态更新</h3>
<p>在状态更新方面，Future 的状态由
<strong>内部进行自动管理</strong>。当异步任务执行完成或抛出错误时，其状态将隐式地自动从
<code>uncomplete</code> 状态更新为 <code>completed</code> 状态。</p>
<p>对于 Promise，其状态由
<strong>外部进行手动管理</strong>。通常由开发者根据控制流逻辑，执行特定的状态更新方法显式地从
<code>pending</code> 状态更新为 <code>fulfilled</code> 或
<code>rejected</code> 状态。</p>
<h3 id="返回机制">返回机制</h3>
<p>在返回机制方面，Future 以传统的 <code>return</code>
方式返回结果。如下所示为 Dart 中 Future
的返回机制示例，其返回正如普通的方法一样，通过 <code>return</code>
完成。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; _readFileAsync() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> file = File(filename);</span><br><span class="line">  <span class="keyword">final</span> contents = <span class="keyword">await</span> file.readAsString();</span><br><span class="line">  <span class="keyword">return</span> contents.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 Promise
通常将结果作为闭包参数进行传递，并执行闭包从而实现返回。如下所示为
JavaScript 中 Promise 的返回机制示例，<code>resolve</code>
是一个只接受成功值的闭包，其参数为 <code>Image</code>
类型；<code>reject</code> 是一个只接受错误值的闭包，其参数为
<code>Error</code> 类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语言实现">语言实现</h3>
<p>下面，我们来看一下各种编程语言是如何独立实现 Future 或 Promise
的。</p>
<h4 id="dart">Dart</h4>
<p>Dart 内置提供了标准 <code>Future</code> 实现，其同时提供了
<code>async</code> 和 <code>await</code>
关键字分别用于描述异步函数和等待异步函数。如下所示，为 Dart 中的 Future
应用示例。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; createOrderMessage() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order = <span class="keyword">await</span> fetchUserOrder();</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Your order is: <span class="subst">$order</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; fetchUserOrder() &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),</span><br><span class="line">      () =&gt; <span class="string">&#x27;Large Latte&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c">C</h4>
<p>C# 提供了 <code>Task</code>，其本质上类似于一种 Future 实现。此外，C#
还提供了异步函数关键字 <code>async</code> 和
<code>await</code>，分别用于描述异步函数和等待异步函数。如下所示，为 C#
中的使用示例。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AccessTheWebAsync</span>()</span> &#123;   </span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();  </span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; getStringTask = client.GetStringAsync(<span class="string">&quot;http://msdn.microsoft.com&quot;</span>);  </span><br><span class="line">    DoIndependentWork();  </span><br><span class="line">    <span class="built_in">string</span> urlContents = <span class="keyword">await</span> getStringTask;  </span><br><span class="line">    <span class="keyword">return</span> urlContents.Length;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> urlContents = <span class="keyword">await</span> client.GetStringAsync();</span><br></pre></td></tr></table></figure>
<h4 id="swift">Swift</h4>
<p>Swift 提供了 <code>Task</code>，其本质是一种加强版的 Future
实现。Swift 通过提供额外的 <code>TaskGroup</code>
的概念，使其同时支持结构化并发和非结构化并发。此外，Swift 也提供的
<code>async</code> <code>await</code> 关键字支持异步函数，基于此，Swift
也能够实现和其他语言一样的 Future 实现。如下所示，为 Swift 中类似于
Future 的使用示例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newPhoto <span class="operator">=</span> <span class="comment">// ... some photo data ...</span></span><br><span class="line"><span class="keyword">let</span> handle <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> add(newPhoto, toGalleryNamed: <span class="string">&quot;Spring Adventures&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> handle.value</span><br></pre></td></tr></table></figure>
<h4 id="java">Java</h4>
<p>Java 1.5 提供了 <code>Future</code> 和 <code>FutureTask</code>，其中
<code>Future</code> 是一个接口，<code>FutureTask</code>
是一种实现，它们提供了一种相对标准的 Future 实现。其通过
<code>Runnable</code> 和 <code>Callable</code>
进行实例化，有一个无参构造器，<code>Future</code> 和
<code>FutureTask</code> 支持外部只读，<code>FutureTask</code> 的 set
方法是
<code>protected</code>，未来值只能由内部进行设置。如下所示，为基于
<code>FutureTask</code> 的一个应用示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task result: &quot;</span>+ futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 提供了 <code>CompletableFuture</code>，其本质上是一种 Promise
的实现。按照我们之前的定义，Future 是只读的，Promise 是可写的，而
<code>CompletableFuture</code>
提供了可由外部调用的状态更新方法，因此可以将其归类为
Promise。另一方面，<code>CompletableFuture</code> 又实现了 Future
的读取方法 <code>get</code>。整体上，<code>CompletableFuture</code>
混合了 Future 和 Promise 的能力。如下所示，为
<code>CompletableFuture</code> 的一个应用示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; momsPurse = ()-&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//mom is busy</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">ex</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; promise =  </span><br><span class="line">CompletableFuture.supplyAsync(momsPurse, ex);</span><br><span class="line">promise.thenAccept(u-&gt;System.out.println(<span class="string">&quot;Thank you mom for $&quot;</span> + u ));</span><br><span class="line">promise.complete(<span class="number">10</span>); </span><br></pre></td></tr></table></figure>
<h4 id="javascript">JavaScript</h4>
<p>从 ES6 开始，JavaScript 支持了 Promise 的经典实现，同时支持了
<code>async</code> 和 <code>await</code> 关键字用于描述异步任务。使用
<code>async</code> 关键字修饰函数的返回值是一个 <code>Promise</code>
对象。<code>await</code> 关键字修饰一个 <code>Promise</code>
对象，表示等待异步任务的值，有点类似等待 Future。如下所示，为 JavaScript
中 <code>Promise</code> 的使用示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">timeout</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timeout</span> = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime),</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timeout</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sleepTime = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sleepTime);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本文简单介绍了一下 Future 和 Promise
的发展历史。然后，分别介绍了两者在实现中的关系和区别。同时，介绍了
Future 和 Promise 在各种编程语言中的实现。</p>
<p>后续有时间，我们在来深入研究一下编程语言层面是如何支持 Future 和
Promise 。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>Multilisp: A Language for Concurrent Symbolic Computation</li>
<li>The Incremental Garbage Collection of Process</li>
<li><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures
and Promises</a></li>
<li><a href="http://dist-prog-book.com/chapter/2/futures.html">Futures
and Promises</a></li>
<li><a
href="https://blog.yorkfish.me/2020/Future%E5%92%8CPromise%E7%9A%84%E5%8C%BA%E5%88%AB/readme/">Future和Promise的区别</a></li>
<li><a
href="https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise">What's
the difference between a Future and a Promise?</a></li>
<li><a href="https://www.youtube.com/watch?v=CITVS-gwySo">Futures and
Promises</a></li>
<li><a
href="https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift/">Under
the hood of Futures and Promises in Swift</a></li>
<li><a
href="https://stackoverflow.com/questions/12620186/futures-vs-promises">Futures
vs. Promises</a></li>
<li><a
href="https://stackoverflow.com/questions/11004273/what-is-stdpromise/12335206">What
is std::promise?</a></li>
<li><a
href="https://cplusplus.com/reference/future/promise/">std::promise</a></li>
<li><a
href="https://putridparrot.com/blog/threads-promises-futures-async-c/">threads,
promises, futures, async, C++</a></li>
<li><a
href="https://docs.scala-lang.org/zh-cn/overviews/core/futures.html">FUTURE和PROMISE</a></li>
<li><a
href="https://www.cnblogs.com/dolphin0520/p/3949310.html">Java并发编程：callable、Future和FutureTask</a></li>
<li><a
href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html">Class
FutureTask<V></a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/async">ECMAScript 6
入门</a></li>
<li><a
href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/concurrent/Promise.java">Netty
Promise</a></li>
<li><a href="https://www.cnblogs.com/rickiyang/p/12742091.html">Netty
中的异步编程 Future 和 Promise</a></li>
<li><a href="https://thunk.org/">So what's a thunk?</a></li>
</ol>
]]></content>
      <categories>
        <category>异步与并发</category>
      </categories>
      <tags>
        <tag>Future</tag>
        <tag>Promise</tag>
        <tag>await</tag>
        <tag>async</tag>
        <tag>Task</tag>
        <tag>Thunk</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD 原理详解</title>
    <url>/2018/12/01/gcd-introduce/</url>
    <content><![CDATA[<h1 id="gcd-简介">GCD 简介</h1>
<p>GCD（Grand Central Dispatch）是 Apple
开发的一个多核编程的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。</p>
<span id="more"></span>
<h1 id="gcd-基本概念">GCD 基本概念</h1>
<p>GCD 主要包含两个核心概念：<strong>任务</strong> 和
<strong>队列</strong>。</p>
<h2 id="任务">任务</h2>
<p><strong>任务</strong>：即要在线程中执行的那段代码。GCD 将任务定义在
block 中。</p>
<p>任务的执行主要有两种方式：<strong>同步执行（sync）</strong> 和
<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列中的任务执行结束，是否具备开启新线程的能力</strong>。因此，根据任务的执行方式可以将任务分成两种类型：</p>
<p><strong>同步任务（sync）</strong></p>
<ul>
<li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li>
<li>只能在当前线程中执行任务，不具备开启新线程的能力。</li>
</ul>
<p><strong>异步任务（async）</strong></p>
<ul>
<li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li>
<li>可以在新的线程中执行任务，具备开启新线程的能力。</li>
</ul>
<blockquote>
<p>注意： <strong>异步任务（async）</strong>
虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p>
</blockquote>
<h2 id="队列">队列</h2>
<p><strong>队列（Dispatch
Queue）</strong>：即用来存放任务的队列。队列是一种特殊的线性表，采用
FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic07.png?x-oss-process=image/resize,w_800" /></p>
<p>在 GCD 中有两种队列：<strong>串行队列</strong> 和
<strong>并发队列</strong>。两者的主要区别是：<strong>执行顺序不同，开启线程数不同</strong>。</p>
<p><strong>串行队列</strong></p>
<ul>
<li>每次只有一个任务被执行。（只开启一个线程，一个任务执行完毕后，在执行下一个任务）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic08.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>并发队列</strong></p>
<ul>
<li>允许多个任务（同时）执行。（可以开启多个线程，并同时执行任务）</li>
<li><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic09.png?x-oss-process=image/resize,w_800" /></li>
</ul>
<blockquote>
<p>注意：<strong>并发队列</strong>
的并发功能只有在异步（dispatch_async）函数下才有效。</p>
</blockquote>
<h1 id="gcd-使用方法">GCD 使用方法</h1>
<p>GCD 的使用主要包含两个步骤：</p>
<ol type="1">
<li>创建一个队列（串行队列或并发队列）</li>
<li>将任务追加到任务的等待队列中，然后系统会根据任务类型执行任务（同步执行或异步执行）</li>
</ol>
<h2 id="队列的创建获取">队列的创建/获取</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t</span><br><span class="line">dispatch_queue_create(const char *_Nullable label,</span><br><span class="line">		dispatch_queue_attr_t _Nullable attr)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>label</code>：表示队列的唯一标识符，用于 DEBUG，可为空。</li>
<li><code>attr</code>：表示队列的类型。<code>DISPATCH_QUEUE_SERIAL</code>
表示串行队列；<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>对于串行队列，GCD 提供了一种特殊的串行队列：<strong>主队列（Main
Dispatch Queue）</strong>。</p>
<ul>
<li><strong>所有放在主队列的任务，都会在主线程执行</strong>。</li>
<li>可使用 <code>dispatch_get_main_queue()</code> 获取主队列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<p>对于并发队列，GCD 默认提供了 <strong>全局并发队列（Global Dispatch
Queue）</strong>。</p>
<ul>
<li>可使用 <code>dispatch_get_global_queue</code>
获取全局并发队列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<p>GCD 提供了 4 个
<strong>全局并发队列</strong>，分别对应不同的优先级。</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台队列</li>
</ul>
<h2 id="任务的创建">任务的创建</h2>
<p>GCD 提供了同步执行任务的创建方法 <code>dispatch_sync</code>
和异步执行任务创建方法 <code>dispatch_async</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 同步任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="gcd-使用组合">GCD 使用组合</h1>
<p>GCD
有两种队列（串行队列/并发队列），两种任务（同步任务/异步任务），可以得到
4 种不同的使用组合。</p>
<blockquote>
<ol type="1">
<li>同步任务 + 并发队列</li>
<li>异步任务 + 并发队列</li>
<li>同步任务 + 串行队列</li>
<li>异步任务 + 串行队列</li>
</ol>
</blockquote>
<p>实际上，前文还提到两种特殊的队列：全局并发队列、主队列。全局并发队列可作为普通并发队列使用。但是主队列比较特殊，因此又得到
2 种组合：</p>
<blockquote>
<ol start="5" type="1">
<li>同步任务 + 主队列</li>
<li>异步任务 + 主队列</li>
</ol>
</blockquote>
<h2 id="同步执行-并发队列">同步执行 + 并发队列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 并发队列</span><br><span class="line"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);          // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic01.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 <code>同步任务 + 并发队列</code> 的工作原理。</p>
<ul>
<li><code>syncConcurrent</code> 被添加至主队列中，在主线程执行。</li>
<li>同步任务被添加至并行队列，并行队列允许多任务同时执行，但由于加入的队列是同步任务，不会开启新线程，在主线程执行。</li>
<li><code>syncConcurrent</code> 会被同步任务阻塞。</li>
</ul>
<p>执行结果： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---begin</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---end</span><br></pre></td></tr></table></figure></p>
<h2 id="异步任务-并发队列">异步任务 + 并发队列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 并发队列</span><br><span class="line"> * 特点：可以开启多个线程，任务交替（同时）执行。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic02.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 <code>异步任务 + 并行队列</code> 的工作原理。</p>
<ul>
<li><code>asyncConcurrent</code> 被添加至主队列中，在主线程执行。</li>
<li>异步任务被添加至并行队列，并行队列允许多任务同时执行，且异步任务可以开启新线程，因此每个异步任务都能启动一个独立的线程执行。</li>
<li><code>asyncConcurrent</code> 不会被异步任务阻塞。</li>
</ul>
<p>执行结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600003e6d580&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncConcurrent---begin</span><br><span class="line">asyncConcurrent---end</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="同步任务-串行队列">同步任务 + 串行队列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 串行队列</span><br><span class="line"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic03.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 <code>同步任务 + 串行队列</code> 的工作原理。</p>
<ul>
<li><code>syncSerial</code> 被添加至主队列中，在主线程执行。</li>
<li>同步任务被添加至串行队列，串行队列不允许多任务同时执行，因此同步任务在当前线程执行（主线程）。</li>
<li><code>syncSerial</code> 会被同步任务阻塞。</li>
</ul>
<h2 id="异步任务-串行队列">异步任务 + 串行队列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 串行队列</span><br><span class="line"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic04.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 <code>异步任务 + 串行队列</code> 的工作原理。</p>
<ul>
<li><code>asyncSerial</code> 被添加至主队列中，在主线程执行。</li>
<li>异步任务被添加至串行队列，异步任务能开启新线程，但是串行队列不允许多任务，所以只能开启一条新线程。</li>
<li><code>asyncSerial</code> 不会被异步任务阻塞。</li>
</ul>
<p>执行结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600001ef5d00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncSerial---begin</span><br><span class="line">asyncSerial---end</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="同步任务-主队列">同步任务 + 主队列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 主队列</span><br><span class="line"> * 特点(主线程调用)：互等卡主不执行。</span><br><span class="line"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic05.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 <code>同步任务 + 主队列</code> 的工作原理。</p>
<ul>
<li><code>syncMain</code> 被添加至主队列中，在主线程执行。</li>
<li>同步任务被添加至主队列，同步任务不会开启新线程，且主队列（属于串行队列）中的任务只能在主线程执行。</li>
<li><code>syncMain</code> 会被同步任务阻塞。但是需要注意的是
<code>syncMain</code> 和同步任务均在主队列中，同步任务需要等待
<code>syncMain</code> 执行完毕，因此产生死锁。</li>
</ul>
<p>执行结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">崩溃</span><br></pre></td></tr></table></figure></p>
<p>对于这种情况，可以将 <code>syncMain</code>
放置新线程执行以避免产生死锁： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure></p>
<h2 id="异步任务-主队列">异步任务 + 主队列</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 主队列</span><br><span class="line"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic06.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 <code>异步任务 + 主队列</code> 的工作原理。</p>
<ul>
<li><code>asyncMain</code> 被添加至主队列中，在主线程执行。</li>
<li>异步任务被添加至主队列，异步任务能开启新线程，但是主队列（属于串行队列）中的任务只能在主线程执行。</li>
<li><code>asyncMain</code> 不会被异步任务阻塞。</li>
</ul>
<p>执行结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncMain---begin</span><br><span class="line">asyncMain---end</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="gcd-应用">GCD 应用</h1>
<h2 id="线程间通信">线程间通信</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic10.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为线程间通信的工作原理。</p>
<ul>
<li><code>communication</code> 被添加至主队列中，在主线程执行。</li>
<li>异步任务被添加至全局队列（并行队列），异步任务能开启新线程，因此异步任务在新线程执行。</li>
<li><code>communication</code> 不会被异步任务阻塞。</li>
<li>当异步任务执行完成后，再将一个异步任务添加至主队列，主队列中的任务都在主线程执行，所以该异步任务在主线程执行。从而达到线程间通信的目的。</li>
</ul>
<p>执行结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000022ddd00&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://juejin.im/post/5a90de68f265da4e9b592b40">iOS多线程：『GCD』详尽总结</a></li>
<li><a href="https://www.jianshu.com/p/fbe6a654604c">细说GCD（Grand
Central Dispatch）如何用</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——getopt</title>
    <url>/2022/04/04/getopt/</url>
    <content><![CDATA[<p>作为程序员的你是否有过疑问：为什么命令行工具用法都差不多？事实上，这是因为早期基于
C/C++ 开发的命令行工具都使用了 <code>getopt</code>
工具来进行选项和参数的解析。</p>
<span id="more"></span>
<p><code>getopt</code>
定义了命令行的两种选项：<strong>长选项</strong>、<strong>短选项</strong>，其分别以
<code>-</code> 和 <code>--</code>
作为前缀，从而使得命令行工具的使用方式基本都差不多。</p>
<p>为了便于认知，后期使用其他编程语言（如：ruby、python）开发的命令行工具，也都延续了这种选项和参数的风格。</p>
<p>本文，我们来通过阅读源码，了解一下 <code>getopt</code>。相关源码详见
<a href="https://github.com/baochuquan/analyze-getopt">传送门</a>。</p>
<h1 id="基本功能">基本功能</h1>
<p><code>getopt</code> 主要用于
<strong>解析命令行中的选项和参数</strong>，以便于检查实际的选项和参数是否符合预期。</p>
<p><code>getopt</code> 的参数主要分为两部分：</p>
<ul>
<li><strong>内置的选项格式</strong>，包括：长选项或短选项等</li>
<li><strong>待解析的所有参数</strong></li>
</ul>
<p><code>getopt</code> 内置提供了两个选项
<code>-o</code>/<code>--options</code> 和
<code>-l</code>/<code>--longoptions</code>，分别用于定义待解析参数的所支持的短选项和长选项的格式。基于这两项格式，<code>getopt</code>
才能判断待解析的参数是否符合预期。</p>
<h1 id="选项类型">选项类型</h1>
<p><code>getopt</code> 定义了三种类型的命令行选项，分别是：</p>
<ul>
<li><strong>标志选项</strong>：该选项仅作为一个标志位，其后面不带参数。</li>
<li><strong>带参选项</strong>：该选项用于标识一个特定的参数，其后面必须带参数。</li>
<li><strong>可选选项</strong>：该选项是一个可选选项，其后面可以选择不带参数或带参数（参数和选项之间没有空格）。</li>
</ul>
<p>如下所示，为三种命令行选项的示例。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标志位选项</span></span><br><span class="line">$ <span class="built_in">ls</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选选项 &amp; 带参选项</span></span><br><span class="line"><span class="comment"># -D 是可选选项，TEST 是参数。对于可选选项，选项和参数之间没有空格。</span></span><br><span class="line"><span class="comment"># -o 是带参选项，getopt 是参数</span></span><br><span class="line">$ gcc -DTEST getopt.c -o getopt</span><br></pre></td></tr></table></figure></p>
<p>为了实现三种选项的格式，<code>getopt</code> 设计了一套
DSL，分别用于描述这三种选项类型。下面，下面来看一个例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 短选项格式：--options hxab:c:: </span></span><br><span class="line"><span class="comment"># 长选项格式：--longoptions help,debug,a-long,b-long:,c-long::</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- --a-long -carg0 --b-long arg1</span><br></pre></td></tr></table></figure>
<p>对于短选项，规定只能用一个字符来表示。</p>
<ul>
<li><strong>标志选项</strong> 末尾不带冒号，上述定义了三个标志短选项：
<code>-h</code>，<code>-x</code>，<code>-a</code>。</li>
<li><strong>带参选项</strong>
末尾带一个冒号，上述定义了一个带参短选项：<code>-b</code>。</li>
<li><strong>可选选项</strong>
末尾带两个冒号。上述定义了一个可选短选项：<code>-c</code>。</li>
</ul>
<p>对于长选项，规定可以用多个字符来表示，使用逗号或空格进行分隔。</p>
<ul>
<li><strong>标志选项</strong> 末尾不带冒号，上述定义了三个标志长选项：
<code>--help</code>，<code>--debug</code>，<code>--a-long</code>。</li>
<li><strong>带参选项</strong>
末尾带一个冒号，上述定义了一个带参长选项：<code>--b-long</code>。</li>
<li><strong>可选选项</strong>
末尾带两个冒号。上述定义了一个可选长选项：<code>--c-long</code>。</li>
</ul>
<p>注意，上述例子中 <code>--</code> 右边的部分就是待解析参数，即
<code>--a-long -carg0 --b-long arg1</code>。</p>
<hr />
<h1 id="实现原理">实现原理</h1>
<h2 id="数据结构">数据结构</h2>
<p><code>getopt</code>
内部定义了两个关键的数据结构：<code>struct option</code> 和
<code>struct getopt_control</code>。</p>
<p><code>struct option</code>
用于描述一个长选项，包括：名称，是否带参数，短选项标志等。其定义如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;       <span class="comment">// 长选项的命名</span></span><br><span class="line">	<span class="type">int</span> has_arg;            <span class="comment">// 选项是否带参数</span></span><br><span class="line">	<span class="type">int</span> *flag;              <span class="comment">// 如果不为 NULL，当发现选项时，将 *flag 设置为 val</span></span><br><span class="line">	<span class="type">int</span> val;                <span class="comment">// 如果 flag 不为 NULL，此为要设置 *flag 的值；否则，返回该值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>struct getopt_control</code>
是一个顶层数据结构，主要用于描述外部选项的格式。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">getopt_control</span> &#123;</span></span><br><span class="line">	<span class="type">shell_t</span> shell;			        <span class="comment">/* the shell we generate output for */</span></span><br><span class="line">	<span class="type">char</span> *optstr;			        <span class="comment">/* getopt(3) optstring */</span></span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">option</span> *<span class="title">long_options</span>;</span>	<span class="comment">/* long options */</span></span><br><span class="line">	<span class="type">int</span> long_options_length;	    <span class="comment">/* length of options array */</span></span><br><span class="line">	<span class="type">int</span> long_options_nr;		    <span class="comment">/* number of used elements in array */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">		compatible:<span class="number">1</span>,		        <span class="comment">/* compatibility mode for &#x27;difficult&#x27; programs */</span></span><br><span class="line">		quiet_errors:<span class="number">1</span>,		        <span class="comment">/* print errors */</span></span><br><span class="line">		quiet_output:<span class="number">1</span>,		        <span class="comment">/* print output */</span></span><br><span class="line">		quote:<span class="number">1</span>;		            <span class="comment">/* quote output */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="核心流程">核心流程</h2>
<p><code>getopt</code> 的核心流程分为三部分：</p>
<ul>
<li><strong>内置选项/参数解析</strong>：主要针对 <code>getopt</code>
自身所支持的选项进行解析。</li>
<li><strong>外部选项格式注册</strong>：主要基于
<code>内置选项/参数解析</code> 的解析结果，比如：基于
<code>-o/--options</code> 和 <code>-l/--longoptions</code> 选项的 DSL
参数，注册外部选项格式。</li>
<li><strong>外部选项/参数校验</strong>：基于外部选项格式，对剩余参数进行解析校验，判断外部选项是否符合预期。</li>
</ul>
<p>如下所示，为 <code>getopt</code> 的核心流程的代码实现。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">getopt_control</span> <span class="title">ctl</span> =</span> &#123;</span><br><span class="line">        .shell = BASH,</span><br><span class="line">        .quote = <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内置的长选项和短选项</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *shortopts = <span class="string">&quot;+ao:l:n:qQs:TuhV&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">longopts</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;options&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;longoptions&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;quiet&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;q&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;quiet-output&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;Q&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;shell&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;test&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;T&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;unquoted&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;u&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;alternative&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;name&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;version&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;V&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地化及其他设置</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ctl 的部分字段</span></span><br><span class="line">    add_longopt(&amp;ctl, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* init */</span></span><br><span class="line">    <span class="comment">// 设置函数指针</span></span><br><span class="line">    getopt_long_fp = getopt_long;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内置选项/参数解析</span></span><br><span class="line">    <span class="keyword">while</span> ((opt =</span><br><span class="line">                getopt_long(argc, argv, shortopts, longopts, <span class="literal">NULL</span>)) != EOF)</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            getopt_long_fp = getopt_long_only;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">            <span class="comment">// 设置外部短选项格式</span></span><br><span class="line">            add_short_options(&amp;ctl, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">            <span class="comment">// 设置外部长选项格式</span></span><br><span class="line">            add_long_options(&amp;ctl, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="built_in">free</span>(ctl.name);</span><br><span class="line">            <span class="comment">// 设置外部程序的命名</span></span><br><span class="line">            ctl.name = xstrdup(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">            ctl.quiet_errors = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">            ctl.quiet_output = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            ctl.shell = shell_type(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">            <span class="built_in">free</span>(ctl.long_options);</span><br><span class="line">            <span class="keyword">return</span> TEST_EXIT_CODE;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            ctl.quote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">            print_version(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            parse_error(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            usage();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            parse_error(_(<span class="string">&quot;internal error, contact the author.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部选项/参数校验</span></span><br><span class="line">    <span class="keyword">return</span> generate_output(&amp;ctl, argv + optind - <span class="number">1</span>, argc - optind + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，进行内置选项/参数解析，可以看到 <code>getopt</code>
自身长选项和短选项格式如下所示。由于长选项和短选项直接存在映射关系，所以可以看到长选项初始化时的
<code>val</code> 域正好对应一个短选项字符。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getopt 自身短选项格式</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *shortopts = <span class="string">&quot;+ao:l:n:qQs:TuhV&quot;</span>;</span><br><span class="line"><span class="comment">// getopt 自身长选项格式</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">longopts</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;options&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;longoptions&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;quiet&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;q&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;quiet-output&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;Q&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;shell&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;test&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;T&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;unquoted&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;u&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;alternative&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;version&quot;</span>, no_argument, <span class="literal">NULL</span>, <span class="string">&#x27;V&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>内置选项/参数解析的核心是通过一个 <code>while</code>
循环，依次解析每一个选项和参数。这里通过调用 <code>getopt_long</code>
方法来进行解析。</p>
<p><code>getopt_long</code> 会返回一个 ASCII 码值，通过
<code>switch case</code> 选择不同的处理方法。对于 <code>l</code>
则注册外部长选项格式，存储于 <code>ctl.long_options</code> 数组中；对于
<code>o</code> 则注册外部短选项格式，存储于 <code>ctl.optstr</code>
字符串中。</p>
<p>最后，通过 <code>ctl</code>
中已注册的外部选项格式，对剩余的参数进行校验，并打印最终结果。</p>
<h2 id="选项参数解析">选项/参数解析</h2>
<p>选项/参数解析的核心方法是
<code>getopt_long</code>，它是一个带副作用的函数，其内部会读写多个全局变量，包括：<code>optind</code>、<code>optarg</code>、<code>optpos</code>
等。每次调用，执行结果都不一样，从而达到依次遍历 ARGV 的目的。</p>
<p><code>getopt_long</code>
包含两部分逻辑：长选项及其参数的识别，短选项及其参数的识别。</p>
<p>如果 ARGV 的一个元素以 <code>--</code>
作为前缀，那么它是一个长选项。如果 ARGV 的一个元素以 <code>-</code>
作为前缀（且不以 <code>--</code> 作为前缀），那么它是一个短选项。</p>
<p>对于带参选项的参数解析，<code>getopt</code>
支持两种格式，如下所示。</p>
<ul>
<li>选项和参数之间使用 <strong>空格</strong> ' ' 进行分隔</li>
<li>选项和参数之间使用 <strong>等号</strong> '=' 进行分隔</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带参长选项，空格分隔选项和参数</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- --b-long arg1</span><br><span class="line"> --b-long <span class="string">&#x27;arg1&#x27;</span> --</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带参短选项，空格分隔选项和参数</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- -b arg1</span><br><span class="line"> --b-long <span class="string">&#x27;arg1&#x27;</span> --</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带参长选项，等号分隔选项和参数</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- --b-long=arg1</span><br><span class="line"> --b-long <span class="string">&#x27;arg1&#x27;</span> --</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带参短选项，等号分隔选项和参数</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- -b=arg1</span><br><span class="line">--b-long <span class="string">&#x27;arg1&#x27;</span> --</span><br></pre></td></tr></table></figure>
<p>对于可选选项的参数解析，<code>getopt</code> 略有不同，如下所示。</p>
<ul>
<li>对于短选项，选项和参数之间不包含任何其他字符</li>
<li>对于长选项，选项和参数之间只包含 <strong>等号</strong> '='。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可选短选项，选项和参数之间不包含任何其他字符</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- -carg0</span><br><span class="line"> -c <span class="string">&#x27;arg0&#x27;</span> --</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可选长选项，选项和参数之间只包含等号</span></span><br><span class="line">$ getopt --options hxab:c:: --longoptions <span class="built_in">help</span>,debug,a-long,b-long:,c-long:: -- --c-long=arg0</span><br><span class="line"> --c-long <span class="string">&#x27;arg0&#x27;</span> --</span><br></pre></td></tr></table></figure>
<p>值得注意的是，很多命令行工具都使用 <code>getopt_long</code>
方法来进行选项/参数解析，比如 <code>util-linux</code>
项目中各种常见的命令工具——<a
href="https://github.com/util-linux/util-linux">传送门</a>。</p>
<h2 id="选项格式注册">选项格式注册</h2>
<p>选项格式注册的核心方法有两个，<code>add_long_options</code> 和
<code>add_short_options</code>，分别对应长选项和短选项预。</p>
<p><code>add_long_options</code> 的定义如下所示，其本质就是对
<code>ctl</code> 的
<code>long_options</code>、<code>long_options_length</code>
等字段进行初始化。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 注册长选项</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_longopt</span><span class="params">(<span class="keyword">struct</span> getopt_control *ctl, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> has_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="type">int</span> nr = ctl-&gt;long_options_nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 ctl-&gt;long_options_length 进行修改，并为 ctl-&gt;long_options 增加内存</span></span><br><span class="line">    <span class="keyword">if</span> (ctl-&gt;long_options_nr == ctl-&gt;long_options_length)</span><br><span class="line">    &#123;</span><br><span class="line">        ctl-&gt;long_options_length += REALLOC_INCREMENT;</span><br><span class="line">        ctl-&gt;long_options = xrealloc(ctl-&gt;long_options,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(<span class="keyword">struct</span> option) *</span><br><span class="line">                                         ctl-&gt;long_options_length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选项有名称，则进行存储</span></span><br><span class="line">    <span class="keyword">if</span> (name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Not for init! */</span></span><br><span class="line">        ctl-&gt;long_options[nr].has_arg = has_arg;</span><br><span class="line">        ctl-&gt;long_options[nr].flag = &amp;flag;</span><br><span class="line">        ctl-&gt;long_options[nr].val = ctl-&gt;long_options_nr;</span><br><span class="line">        ctl-&gt;long_options[nr].name = xstrdup(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，置空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* lets use add_longopt(ct, NULL, 0) to terminate the array */</span></span><br><span class="line">        ctl-&gt;long_options[nr].name = <span class="literal">NULL</span>;</span><br><span class="line">        ctl-&gt;long_options[nr].has_arg = <span class="number">0</span>;</span><br><span class="line">        ctl-&gt;long_options[nr].flag = <span class="literal">NULL</span>;</span><br><span class="line">        ctl-&gt;long_options[nr].val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>add_short_options</code> 的定义如下所示，其本质就是对
<code>ctl</code> 的 <code>optstr</code> 字段进行初始化。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 注册短选项</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_short_options</span><span class="params">(<span class="keyword">struct</span> getopt_control *ctl, <span class="type">char</span> *options)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将短选项存入 ctl</span></span><br><span class="line">    <span class="built_in">free</span>(ctl-&gt;optstr);</span><br><span class="line">    <span class="keyword">if</span> (*options != <span class="string">&#x27;+&#x27;</span> &amp;&amp; getenv(<span class="string">&quot;POSIXLY_CORRECT&quot;</span>))</span><br><span class="line">        ctl-&gt;optstr = strconcat(<span class="string">&quot;+&quot;</span>, options);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ctl-&gt;optstr = xstrdup(options);</span><br><span class="line">    <span class="keyword">if</span> (!ctl-&gt;optstr)</span><br><span class="line">        err_oom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选项参数校验">选项/参数校验</h2>
<p>外部选项/参数校验的核心是调用了 <code>generate_output</code>
方法。该方法的实现如下所示，其本质上还是基于选项/参数解析方法
<code>getopt_long</code>
对参数进行解析，判断是否符合预期。和内置选项/参数解析的区别在于其校验的标准存储在了
<code>ctl</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">generate_output</span><span class="params">(<span class="keyword">struct</span> getopt_control *ctl, <span class="type">char</span> *argv[], <span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> exit_code = EXIT_SUCCESS; <span class="comment">/* Assume everything will be OK */</span></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="type">int</span> longindex;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *charptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctl-&gt;quiet_errors)</span><br><span class="line">        <span class="comment">/* No error reporting from getopt(3) */</span></span><br><span class="line">        opterr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Reset getopt(3) */</span></span><br><span class="line">    optind = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = (getopt_long_fp(argc, argv, ctl-&gt;optstr, (<span class="type">const</span> <span class="keyword">struct</span> option *)ctl-&gt;long_options, &amp;longindex))) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;?&#x27;</span> || opt == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">            exit_code = GETOPT_EXIT_CODE;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!ctl-&gt;quiet_output)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opt)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> LONG_OPT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; --%s&quot;</span>, ctl-&gt;long_options[longindex].name);</span><br><span class="line">                <span class="keyword">if</span> (ctl-&gt;long_options[longindex].has_arg)</span><br><span class="line">                    print_normalized(ctl, optarg ? optarg : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NON_OPT:</span><br><span class="line">                print_normalized(ctl, optarg ? optarg : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; -%c&quot;</span>, opt);</span><br><span class="line">                charptr = <span class="built_in">strchr</span>(ctl-&gt;optstr, opt);</span><br><span class="line">                <span class="keyword">if</span> (charptr != <span class="literal">NULL</span> &amp;&amp; *++charptr == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">                    print_normalized(ctl, optarg ? optarg : <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ctl-&gt;quiet_output)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; --&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (optind &lt; argc)</span><br><span class="line">            print_normalized(ctl, argv[optind++]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (longindex = <span class="number">0</span>; longindex &lt; ctl-&gt;long_options_nr; longindex++)</span><br><span class="line">        <span class="built_in">free</span>((<span class="type">char</span> *)ctl-&gt;long_options[longindex].name);</span><br><span class="line">    <span class="built_in">free</span>(ctl-&gt;long_options);</span><br><span class="line">    <span class="built_in">free</span>(ctl-&gt;optstr);</span><br><span class="line">    <span class="built_in">free</span>(ctl-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> exit_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p><code>getopt</code>
定义了一套命令行选项和参数的使用规范，这套规范一直被沿用至今。<code>getopt</code>
的工作原理主要包含三个步骤：</p>
<ul>
<li><strong>内置选项/参数解析</strong></li>
<li><strong>外部选项格式注册</strong></li>
<li><strong>外部选项/参数校验</strong></li>
</ul>
<p>其中 <strong>内置选项/参数解析</strong> 的核心实现方法
<code>getop_long</code>
被很多命令行工具所引用，从而使得各种命令行工具的选项和参数的使用规范基本一致，也降低了使用者的学习成本。</p>
<p>关于 <code>getopt</code> 在实际中的用途，如果希望开发基于 C/C++
的命令行工具，可以像其他 Linux 内置的工具一样，使用 <code>getopt</code>
提供的 API
来进行选项校验；如果希望开发基于其他语言的命令行工具，可以调用
<code>getopt</code> 命令行工具来进行选项/参数校验。通过
<code>getopt</code>，我们可以极大地减少选项/参数的定义与校验相关的开发工作量。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://github.com/util-linux/util-linux">util-linux</a></li>
<li><a href="https://en.wikipedia.org/wiki/Util-linux">util-linux
wikipedia</a></li>
<li><a
href="https://www.maizure.org/projects/decoded-gnu-coreutils/">Decoded:
GNU coreutils</a></li>
<li><a
href="https://www.cnblogs.com/embedded-linux/p/5801999.html">C之attribute用法</a></li>
<li><a
href="https://www.libspf2.org/docs/html/getopt__long__only_8c-source.html">getopt_long_only.c</a></li>
<li><a
href="https://gist.github.com/attractivechaos/a574727fb687109a2adefcd75655d9ea">Implementation
of getopt() and getopt_long() from musl</a></li>
</ol>
]]></content>
      <categories>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title>初识协程</title>
    <url>/2021/05/05/getting-to-know-coroutine/</url>
    <content><![CDATA[<p>工作中经常会听到 “协程”
这个概念，第一次听到时，我就去查阅相关教材，发现根本就没有介绍“协程”的。于是上网查阅了相关的解释，当时大概理解了它是干什么的，但是深入的细节并不了解。为了搞明白协程，趁着假期我好好研究了一下协程，然后产出本文作为学习笔记进行总结，以用于后续进行回顾。</p>
<span id="more"></span>
<p>要说明白“协程”，我们得先从进程和线程开始进行介绍。</p>
<h1 id="进程-线程">进程 &amp; 线程</h1>
<p>进程的本质就是
<strong>一个程序的执行实例</strong>。<strong>在进程模型中，进程拥有对内存、I/O
通道、I/O 设备和文件等资源的控制权</strong>。</p>
<p>线程则是为了解决进程的执行效率而提出的。对于多核
CPU，多线程进程可以充分利用多核的特性，成倍地提升执行效率。</p>
<p>在现代操作系统中，我们可以认为线程是进程的更小粒度的划分，即进程包含了一个或多个线程。下图所示为，分别是单线程的进程模型和多线程的进程模型。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-single-multi-thread-process-model.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="用户态线程-内核态线程">用户态线程 &amp; 内核态线程</h1>
<h2 id="用户态线程">用户态线程</h2>
<p>在线程的概念提出时，操作系统并不支持线程，为了验证线程的可行性，研究人员就编写了一个线程的函数库，用函数库来实现线程。这个线程库包含了
<strong>创建线程</strong>、<strong>终止线程</strong>
等，开发者可以通过调用这些函数来实现所需的功能，如：<code>pthread_create</code>、<code>pthread_exit</code>、<code>pthread_join</code>、<code>pthread_yeild</code>。</p>
<p>此时，操作系统内核对这个库一无所知，从内核的角度开，它还是按照正常的方式进行管理，即
<strong>只能一次在一个 CPU
核上运行</strong>。事实上，这也是用户态线程的缺点，这些线程只能占用一个核，无法做到并行加速，而且由于用户态线程对操作系统透明，操作系统无法主动切换线程。对此，开发者需要为用户态线程定制调度算法。</p>
<h2 id="内核态线程">内核态线程</h2>
<p>现代操作系统都已经支持内核态线程了，为了实现线程，内核里就需要有用来记录系统中所有线程的线程表。当需要创建一个新的线程时，就需要进行一次
<strong>系统调用</strong>，然后由操作系统对线程表进行更新。</p>
<p>相比于用户态线程，由于操作系统知道内核态线程的存在，它就可以自由调度各个线程，从而充分利用多核，实现真正的并行。</p>
<p>不过，内核态线程也有缺点。每当操作系统进行线程调度时，就需要陷入内核态，而操作系统从
<strong>用户态到内核态</strong>
的切换是由开销的，所以说，<strong>内核态线程切换的代价要比用户态线程大</strong>，这些开销主要包括以下几个方面：</p>
<ul>
<li>上下文切换：即寄存器切换</li>
<li>特权模式切换：即调度算法中的动态特权级</li>
<li>内核检查：内核代码对用户不信任，需要进行额外的检查</li>
</ul>
<p>除此之外，线程表是存储在操作系统中固定的堆栈空间中，因此内核态线程的数量是有限的，扩展性比不上用户态线程。</p>
<h2 id="对比">对比</h2>
<p>由于用户态线程和内核态线程的存在，我们也就能够理解教科书中所说的三种线程模型了，如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-user-kernel-thread.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="协程">协程</h1>
<p>那么，协程到底是什么呢？事实上，协程就是
<strong>用户态线程</strong>。协程的调度完全由开发者进行控制，因此实现协程的关键也就是
<strong>实现一个用户态线程的调度器</strong>。由于协程是在用户态中实现调度，避免了内核态的上下文切换造成的性能损失，从而突破了线程在
IO 上的性能瓶颈。</p>
<h2 id="适用场景">适用场景</h2>
<p>在理解了用户态线程后，其实不难看出，一个线程多个协程的情况下，在内核看来只有一个线程在运行，这些协程事实上是在串行运行，只能使用一个
CPU 核。因此，<strong>想要高效利用
CPU，我们还是得使用线程</strong>。协程最大的优势在于
<strong>协程的切换比线程的切度更快</strong>。那么，什么场景下更适合使用协程呢？</p>
<p>答案是：<strong>IO 密集型任务</strong>。IO 密集型任务的特点是 CPU
消耗少，其大部分时间都是在等待 IO
操作完成。对于这样的场景，一个线程足矣，因此适合采用协程。</p>
<h2 id="挂起恢复">挂起/恢复</h2>
<p>相比于函数，协程最大的特点就是支持
<strong>挂起/恢复</strong>。什么意思？我们来看下面这个场景就能明白。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-example.png?x-oss-process=image/resize,w_800" /></p>
<p>上图中，控制流会在 <code>foo()</code> 和 <code>bar()</code>
之间进行切换。比如，在第 3 阶段时，控制流从 <code>foo()</code>
中再次转移到了 <code>bar()</code>
中，此时并不是简单的函数调用，而是从上一次离开 <code>bar()</code> 的位置
<code>std::cout &lt;&lt; "1"</code> 之后继续执行。</p>
<p>由此可见，协程与简单的函数调用之间的区别。实现协程的这种能力的关键，就是要实现
<strong>挂起/恢复</strong> 的能力。</p>
<h2 id="协程分类">协程分类</h2>
<p>现代编程语言中，有很多都支持协程，虽然它们在实现细节上差异较大，但是总体而言仍然有章可循。</p>
<h2 id="按调用栈分类">按调用栈分类</h2>
<p>由于协程必须支持
<strong>挂起/恢复</strong>，因此对于挂起点的状态保存就显得极其关键。我们知道，线程在切换时，它的中断状态会保存在调用栈中。事实上，协程的中断状态也可以通过开辟相应的调用栈来保存。因此，<strong>按照是否开辟相应的调用栈</strong>，我们可以将协程分为两类：</p>
<ul>
<li><strong>有栈协程</strong>（Stackful
Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈。</li>
<li><strong>无栈协程</strong>（Stackless
Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。</li>
</ul>
<p>类似微信的 libco、阿里的 cooobjc、Golang 中的 goroutine、Lua
中的协程都是有栈协程；类似 ES6、Dart 中的 await/async、Python 的
Generator、Kotlin 中的协程、C++20 中的 cooroutine 都是无栈协程。</p>
<h3 id="有栈协程">有栈协程</h3>
<p>有栈协程的一般实现是：在内存中给每个协程开辟一个栈内存，当协程挂起时会将它的运行时上下文（即栈空间）从系统栈中保存至其所分配的栈内存中，当协程恢复时会将其运行时上下文从栈内存中恢复至系统栈中。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-stackful.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为在协程 <code>foo()</code> 和 <code>bar()</code>
之间切换时，栈空间的变化。很显然，<strong>有栈协程会改变函数调用栈</strong>。由于有栈协程需要保存各个协程自己的运行时上下文，一般会通过堆来分类内存空间。如果内存分配过小，可能会产生栈溢出；如果内存分配过大，可能会产生内存浪费。因此，很多编程语言对此进行了各种优化。</p>
<p>另一方面，当协程恢复时，需要将运行时上下文从堆中拷贝至栈中，这里也存在一定的开销。</p>
<p>虽然，有栈协程有上述的缺点，但是它可以在
<strong>任意函数调用层级的位置进行挂起</strong>，并转移调度权。事实上，这也是有栈协程的重要特定之一。</p>
<h3 id="无栈协程">无栈协程</h3>
<p>与有栈协程相反，无栈协程不会为各个协程开辟相应的调用栈。无栈协程通常是
<strong>基于状态机或闭包</strong> 来实现。</p>
<p>基于状态机的解决方案一般是通过状态机，记录上次协程挂起时的位置，并基于此决定协程恢复时开始执行的位置。这个状态必须存储在栈以外的地方，从而避免状态与栈一同销毁。</p>
<p>以 <code>bar()</code>
为例，可以通过类似如下的方式实现挂起和恢复。从这种实现方式的角度来看，协程与函数无异，只不过前者会记录上次终端的位置，从而可以实现恢复执行的能力。当然，在实际过程中，恢复后的执行流可能会用到中断前的状态，因此无栈协程会将保存完整的状态，这些状态会被存储到堆上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">goto</span> LABEL0;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">goto</span> LABEL1;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">goto</span> LABEL2;</span><br><span class="line">    &#125;</span><br><span class="line">    LABEL0:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    LABEL1:</span><br><span class="line">    <span class="built_in">std</span>::count &lt;&lt; <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    LABEL2:</span><br><span class="line">    <span class="built_in">std</span>::count &lt;&lt; <span class="string">&quot;3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述只是一个简单的例子，具体场景中，无栈协程的控制流会依靠对协程本身编译生成的状态机的状态流来实现，变量保存也会通过闭包语法来实现。</p>
<p>相比于有栈协程，无栈协程不需要修改调用栈，也无需额外的内存来保存调用栈，因此它的开销会更小。但是，相比于保存运行时上下文这种实现方式，无栈协程的实现还是存在比较多的限制，最大缺点就是，它无法实现在任意函数调用层级的位置进行挂起。</p>
<h2 id="按调度方式分类">按调度方式分类</h2>
<p>在调度过程中，根据协程调度权的目标，又可以将协程分为以下两种：</p>
<ul>
<li><strong>对称协程</strong>（Symmetric
Coroutine）：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。</li>
<li><strong>非对称协程</strong>（Asymmetric
Coroutine）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。</li>
</ul>
<h3 id="对称协程">对称协程</h3>
<p>对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine
可以通过读写不同的 channel 来实现控制权的自由转移。</p>
<h3 id="非对称协程">非对称协程</h3>
<p>非对称协程的调用关系更加符合我们的思维方式，<strong>常见的语言对协程的实现大多是非对称协程</strong>，比如
Lua 的协程中当前协程调用 <code>yield</code> 总是会将调度权转移给
<code>resume</code> 它的协程。此外，还有 <code>async</code> 和
<code>await</code>，<code>await</code>
会将调度权转移到异步调用中。异步调用返回结果或抛出异常时总是会将调度权转回到
<code>await</code> 的位置。</p>
<p>从实现角度来看，非对称协程的实现更加自然，也相对容易。事实上，我们只要对非对称协程稍作修改，即可实现对称协程的能力。我们可以在非对称协程的基础上，添加一个中立的第三方作为协程调度权的分发中心，所有的协程在挂起时都将控制权转移到分发中心，分发中心根据参数来决定将调度权转移给哪个协程，如
Lua 的第三方库 coro，以及 kotlin 协程框架中基于 Channel 的通信等。</p>
<h1 id="小结">小结</h1>
<p>本文对协程进行了初步的介绍。根据不同的维度，对协程进行分类讨论。事实上，不管怎么分类，<strong>协程的本质就是处理自身挂起和恢复的用户态线程</strong>。</p>
<p>后续，有时间的话，希望能够深入研究一下几种编程语言中协程的具体实现。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>Design of a Separable Transition-Diagram Compiler. Melvin
Conway.</li>
<li><a
href="https://www.cyhone.com/articles/analysis-of-cloudwu-coroutine/">云风coroutine协程库源码分析</a></li>
<li><a
href="https://www.boost.org/doc/libs/1_61_0/libs/coroutine/doc/html/coroutine/intro.html">Introduction
- 1.61.0 - Boost C++ Libraries</a></li>
<li><a
href="https://juejin.cn/post/6844903962504593421">用户级线程和内核级线程，你分得清吗？</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/94018082">从头到尾理解有栈协程实现原理</a></li>
<li><a
href="https://juejin.cn/post/6844903960759762958">线程的来龙去脉，你了解吗？</a></li>
<li><a href="https://en.wikipedia.org/wiki/Melvin_Conway">Melvin
Conway</a></li>
<li><a
href="https://juejin.cn/post/6844903832061739021">深入理解Flutter多线程</a></li>
<li><a
href="https://blog.youxu.info/2014/12/04/coroutine/">编程珠玑番外篇-Q
协程的历史，现在和未来</a></li>
<li><a
href="https://blog.csdn.net/weixin_43705457/article/details/106857068">协程入门，这可能是全网最简单易懂的扫盲贴了</a></li>
<li><a
href="https://blog.csdn.net/weixin_43705457/article/details/106924435">有栈协程与无栈协程</a></li>
<li><a
href="https://mthli.xyz/coroutines-in-c/">使用C语言实现协程</a></li>
<li><a
href="https://www.bennyhuo.com/2019/12/01/coroutine-implementations/">破解
Kotlin 协程 番外篇(2) - 协程的几类常见的实现</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>有栈协程</tag>
        <tag>无栈协程</tag>
        <tag>对称协程</tag>
        <tag>非对称协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 分支模型</title>
    <url>/2017/09/10/git-branching-model/</url>
    <content><![CDATA[<p>我们公司的软件产品迭代采用的是scrum敏捷开发流程，代码使用git进行版本管理。在新人最初的几次开发任务中，我对于git的使用也仅限于一些基本的命令，包括：add、commit、rebase、cherry-pick、push、checkout等等。</p>
<span id="more"></span>
<p>直到有一天，我发现远程分支上存在着一些历史feature分支，这对于我这个初入职场的小白来说还是有些好奇：feature分支在本地建立不就行了吗？为何还需要推送到远程仓库？</p>
<p>带着这一些列的疑问，我仔细研究了一些我们基于gerrit的code
review流程，终于明白了为何会有feature远程分支。这一切都与git的分支模型有关。<br />
期间，我在一个英文博客上看到了一篇关于<a
href="http://nvie.com/posts/a-successful-git-branching-model/">git分支模型</a>的介绍，看完后觉得不错，对其进行简要地整理，以呈现给大家。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-branch-model.png?x-oss-process=image/resize,w_500" /></p>
<h2 id="分权集中">分权集中</h2>
<p>下图中心的仓库，是我们建立并在使用的仓库，具有分支模型，其通常会被认为是“真正的中心仓库”。然而，事实上，其仅仅是被<strong>认为</strong>是中心仓库而已，因为git作为一个分布式版本控制系统（DVCS），在技术层面并不存在哪个仓库是中心仓库。而这个被认为是“中心”的仓库，我们更愿意称之为<strong>origin</strong>，这个名字对于所有git用户都是很熟悉的。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-center-decenter.png?x-oss-process=image/resize,w_400" /></p>
<p>每个开发者都会从origin进行pull或向其进行push操作。但是除了与origin具有push-pull关系之外，开发者们还可能从其他同级的伙伴那里pull最新的改动，从而形成一个sub
team。比如，对于两个以上的开发者，在过早地向origin推送开发进展之前，其可以开辟一个新的feature分支来共同工作。如上图所示，存在着这样几个开发小组：Alice
&amp; Bob，Alice &amp; David，Clair &amp; David。</p>
<p>从技术角度而言，这仅仅意味着Alice定义了一个远程仓库，名字是Bob，其指向了Bob的仓库，反之亦然，仅此而已。</p>
<h2 id="主分支">主分支</h2>
<p>归根到底，开发模型也受到了上述思想的影响。在中心仓库中，在其无限的生命周期中，始终存在着两条主分支：</p>
<ul>
<li><strong>master</strong></li>
<li><strong>develop</strong></li>
</ul>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-main-branches.png?x-oss-process=image/resize,w_250" /></p>
<p>大家对<strong>origin</strong>上的<strong>master</strong>分支应该并不陌生。而另一个与之平行的分支，我们称之为<strong>develop</strong>分支。</p>
<p><strong>origin/master</strong>：在这个分支上，源代码的<strong>HEAD</strong>指针的指向始终都是就绪/可发布的产品状态。</p>
<p><strong>origin/develop</strong>：在这个分支上，源代码的<strong>HEAD</strong>指针的指向始终都是下一个版本的产品状态。</p>
<p>当<strong>develop</strong>分支的源代码到达某一个可发布的稳定点时，所有的改动都应该合并到<strong>master</strong>分支，然后打上版本的tag标签。</p>
<p>因此，每次将改动合并至<strong>master</strong>分支时，意味着一个新版本的诞生。我们往往对这个过程控制得非常严格。所以每次<strong>master</strong>分支上有commit时，我们都应该使用git
hook脚本来自动编译、发布软件至产品服务器上。</p>
<h2 id="支持分支">支持分支</h2>
<p>与主分支<strong>master</strong>、<strong>develop</strong>相邻的则是各种支持分支，用于帮助团队成员之间进行平行开发，跟踪功能，准备产品发布以及帮助修复在线产品的一些Bug。与主分支不同，这些分支总是具有有限的生命周期，因为它们最终都是要被删除的。</p>
<p>我们可能用到的几种不同的支持分支：</p>
<ul>
<li><strong>Feature分支</strong></li>
<li><strong>Release分支</strong></li>
<li><strong>Hotfix分支</strong></li>
</ul>
<p>上述的每一个分支都具有特定的目的，并且必须遵守严格的规则。比如：哪些分支可以是它们的源头分支，哪些分支必须是它们的合并目标。</p>
<p>当然，从技术角度来说，这些分支并没有什么特殊之处。所谓的分支类型只是我们根据如何使用它们而进行分类的。</p>
<h3 id="feature分支">Feature分支</h3>
<p><strong>规则</strong>：<br />
&gt; 可以源自<strong>develop</strong>分支<br />
&gt; 必须合并到<strong>develop</strong>分支<br />
&gt;
命名：除<strong>master</strong>，<strong>develop</strong>，<strong>release-*</strong>，<strong>hotfix-*</strong>之外</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-feature-branches.png?x-oss-process=image/resize,w_125" /></p>
<p>Feature分支（也称：topic分支）用来为即将发布的版本或更远的版本开发新的feature。当开发一个新的功能的时候，我们不知道这个功能会被纳入哪个目标版本。Feature分支的本质就是，只要该功能处于开发阶段，feature分支就会存在，并最终会被合并至<strong>develop</strong>分支（以确保将新功能添加到即将发布的版本中）或者丢弃（在实验失败的情况下）。</p>
<p>Feature分支通常只存在与开发者自己的仓库中，而不是<strong>origin</strong>。</p>
<h4 id="创建feature分支">创建feature分支</h4>
<p>当开始开发一个新的功能时，需要从<strong>develop</strong>主分支中开辟一个新分支。<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b myfeature develop //表示切换到一个新的分支“myfeature”</span><br></pre></td></tr></table></figure></p>
<h4 id="将完成的功能纳入develop">将完成的功能纳入develop</h4>
<p>完成的功能可以合并至develop分支，以加入即将发布的版本之中。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout develop  //切换至develop分支</span><br><span class="line">$ git merge --no-ff myfeature //</span><br><span class="line">$ git branch -d myfeature   //删除myfeature分支</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure></p>
<p><strong>--no-ff</strong>选项会在合并分支时创建一个新的commit对象，即使合并可以是一次fast-forward操作。这可以避免丢失feature分支的历史存在信息，并将该feature分支上的所有commit放在在一起。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-merge-no-ff-comare.png?x-oss-process=image/resize,w_400" /></p>
<p>如上图所示，相比较而言，后面一种情况是不可能从git历史记录中看到哪些提交对象一起实现了一个功能，你必须手动读取所有日志信息。在后一种情况下，恢复整个功能（即一组提交）是非常困难的，而如果使用了<strong>--no-ff</strong>选项，则很容易实现。</p>
<p>当然，这会创建一些空的commit对象，但收益远大于成本。</p>
<h3 id="release分支">Release分支</h3>
<p><strong>规则</strong> &gt; 可以源自<strong>develop</strong>分支<br />
&gt;
必须合并到<strong>develop</strong>分支和<strong>master</strong>分支<br />
&gt; 命名：<strong>release-*</strong></p>
<p>Release分支用于支持准备新的产品版本，它们允许对版本进行小错误修复和元数据准备（版本号，构建日期等）。通过在Release分支上进行所有这些工作，<strong>develop</strong>分支会被清理以接收下一个大版本的功能。</p>
<p>当<strong>develop</strong>分支达到了新版本的期望状态时，即可从<strong>develop</strong>分支开辟新的release分支。当然，必须要等到所有待发布的功能合并至<strong>develop</strong>分支之后才可以。</p>
<p>正是在release分支的开始，即将发布的版本会被分配版本号。直到这一刻起，<strong>develop</strong>分支“下一个版本”的改动。但是“下一个版本”会变为0.3还是1.0，需要等到release分支开始才知道。这是在release分支开始时，由版本规则决定的。</p>
<h4 id="创release分支">创release分支</h4>
<p>Release分支从<strong>develop</strong>分支创建而来。例如，1.1.5版本是当前的产品版本，我们即将有一个大的版本。<strong>develop</strong>已经为“下一个版本”准备就绪了，并且我们已经决定这将成为1.2版本（而不是1.1.6或2.0）。所以我们开辟一个分支，并予以相应的版本号。<br />
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop å</span><br><span class="line">$ ./bump-version.sh 1.2 </span><br><span class="line">$ git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="结束release分支">结束release分支</h4>
<p>当release分支的状态已经准备好成为y一个真正的版本，需要完成一些操作。首先，将release分支合并至<strong>master</strong>分支（<strong>master</strong>上的每一个commit都是一个新的版本）。然后，<strong>master</strong>上的commit必须被打上标签，以便参考历史版本。最后，将在release分支上作出的改动合并到<strong>develop</strong>分支上，以便未来的版本还包含这些错误修复。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// step 1</span><br><span class="line">$ git checkout master å</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">// step 2</span><br><span class="line">$ git tag -a 1.2</span><br><span class="line">// step 3</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">// 完成后，我们可以将release分支删除</span><br><span class="line">$ git branch -d release-1.2</span><br></pre></td></tr></table></figure>
<h3 id="hotfix分支">Hotfix分支</h3>
<p><strong>规则</strong> &gt; 可以源自<strong>develop</strong>分支<br />
&gt;
必须合并到<strong>develop</strong>分支和<strong>master</strong>分支<br />
&gt; 命名：<strong>hotfix-*</strong></p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/git-hotfix-branches.png?x-oss-process=image/resize,w_250" /></p>
<p>Hotfix分支与release分支非常相似，其也是用于为新的产品版本做准备，尽管是计划之外的。它们是对发布版本的不良状态作出的回应。当产品版本中的一个关键bug必须要被修复时，可以从<strong>master</strong>分支上相应的tag标签中开辟一个hotfix分支。</p>
<p>Hotfix分支的本质是可以使<strong>develop</strong>分支上的工作得以继续，而另外有人进行bug修复。</p>
<h4 id="创建hotfix分支">创建hotfix分支</h4>
<p>Hotfix分支从<strong>master</strong>分支创建而来。例如，1.2版本是当前产品的版本号，正在在线运行，由于服务器bug出现了一些问题。但是<strong>develop</strong>分支上的改动还不稳定。我们需要开辟一个hotfix分支来进行bug修复。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">$ ./bump-version.sh</span><br><span class="line">$ git commit -a m <span class="string">&quot;Bumped version number to 1.2.1&quot;</span></span><br><span class="line">// 修复bug并commit</span><br><span class="line">$ git commit -m <span class="string">&quot;Fixed server production problem&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="结束hotfix分支">结束hotfix分支</h4>
<p>当完成bug修复之后，hotfix分支需要合并到<strong>master</strong>分支，当然也需要合并至<strong>develop</strong>分支，这与release分支是非常相似的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// step 1: 合并至master，打上版本标签</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">$ git tag -a 1.2.1</span><br><span class="line">// step 2: 合并至develop</span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">// step 3: 删除hotfix分支</span><br><span class="line">$ git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure>
<p>这里有一个例外需要注意，<strong>当一个release分支当前还存在时，hotfix分支的修改应该合并至release分支，而不是develop分支</strong>。因为release分支完成后，需要合并至<strong>develop</strong>分支。</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>分支模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Git rebase与merge的区别</title>
    <url>/2017/10/10/git-rebase-merge/</url>
    <content><![CDATA[<h1 id="git场景">Git场景</h1>
<p>在基于Git版本控制的团队协作开发中，当同伴先于自己将新的提交push到远程分支上时，如果要想将自己新的提交push的远程分支，则需要先执行<code>git pull</code>来获取同伴的提交，如果有冲突则先处理完冲突，然后才能将自己的提交push到远程分支。这种情形是非常常见的。</p>
<span id="more"></span>
<p>然而执行<code>git pull</code>，在默认情况下，如果远程分支与本地分支的提交线图有分叉（即不是<code>fast-forward</code>，如上述这种情形），git会执行一次merge操作（即相当于执行了<code>git pull --merge</code>），而这会产生一次没有意义的提交记录。久而久之，项目的提交线图会非常混乱，其中会有很多由merge生成的无意义提交。</p>
<h1 id="解决方案">解决方案</h1>
<p>为了避免这种情况的出现，在将提交push到远程分支之前，我们一般会执行如下命令：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase</span><br></pre></td></tr></table></figure>
通过上述命令，Git会采用rebase策略来代替默认的merge策略。从而避免生成无意义的提交。</p>
<h1 id="分析对比">分析对比</h1>
<p>这时候，我们可能就会想：既然merge操作会生成无意义的提交，那它是不是没有什么价值了呢？是不是任何场景下都应该使用rebase操作？</p>
<p>所以，我们对rebase和merge进行分析和对比。了解清楚了两者的区别，我们才能更好地运用这两个策略。</p>
<h2 id="场景设想">场景设想</h2>
<p>假设在执行pull之前的提交线图如下所示： <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-rebase-merge-example.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="merge操作">Merge操作</h2>
<p>如果执行<code>git pull</code>（git默认会执行<code>git pull --merge</code>），提交线图会变成如下所示：
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-rebase-merge-example-merge.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>分析</strong><br />
提交线图中多出了一个没有必要的提交<code>H</code></p>
<h2 id="rebase操作">Rebase操作</h2>
<p>如果执行<code>git pull --rebase</code>，提交线图会变成如下所示： <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-rebase-merge-example-rebase.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>分析</strong><br />
提交线图中，本地的新提交<code>F</code>，<code>G</code>变成了两个新的提交<code>F'</code>，<code>G'</code>，拼接在了<code>C</code>后面，多余的分叉也删除了。提交线变得非常清晰。</p>
<h1 id="小结">小结</h1>
<p>从上述对比可以看出，rebase操作会将本分支的新提交删除并生成新的提交。所以rebase操作比较适用于将一些零碎的提交进行合并清理。比如：在push之前进行整理。</p>
<p>那么merge操作意义何在呢？</p>
<p>merge操作与rebase操作相反，它可以保留了提交线图的分叉，并生成一个新的提交。这种场景适合用于大的分支合并。这样，我们可以在提交线图中看到项目开发迭代过程中经历过哪些feature分支等等。</p>
<p><strong>注意</strong>
如果执行merge操作之前，提交线图是分叉的（即不是<code>fast-forward</code>，如<strong>场景设想</strong>的情形），执行<code>git merge</code>操作，是会达保留分支的目的。</p>
<p>但是执行merge操作之前，提交线图不是分叉的（即是<code>fast-forward</code>，如下上图所示），此时执行<code>git merge</code>操作的效果如下下图所示，分支是不会保留的。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example01.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example03.png?x-oss-process=image/resize,w_800" /></p>
<p>在<code>fast-forward</code>情况下进行合并，我们需要执行如下命令来保留分支。执行后的提交线图如下所示。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff</span><br></pre></td></tr></table></figure> <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/git-rebase-merge-example02.png?x-oss-process=image/resize,w_800" /></p>
<p>（完）</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>merge</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title>如何找到最合适的代码审查者？</title>
    <url>/2024/05/11/git-reviewer/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>我的日常工作中有相当一部分时间会用于审查团队成员所提交的代码，即 Code
Review。然而，由我来审查所有代码并不合适，毕竟很多时候我并不了解代码改动的上下文。如果让我重新熟悉别人写的原始逻辑，然后再审查代码改动，很显然是一件费时费力的事情。对此，最好的办法是，针对一次代码提交，合理地找出其最合适的代码审查者。</p>
<p>为了解决这个问题，我开发了一个 Git 插件——<a
href="https://github.com/baochuquan/git-reviewer">Git Reviewer</a>。</p>
<h1 id="功能">功能</h1>
<h2 id="核心功能">核心功能</h2>
<p>我们知道 Git
使用新增和删除两种操作来表示代码改动。事实上，我们还可以从新增和删除两种操作的排列关系中得出第三种操作——编辑。当删除操作和新增操作相互紧邻，那么我们可以将其归为编辑操作。如下所示的代码差异中包含了新增、编辑、删除三种操作。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-03.png?x-oss-process=image/resize,w_800" /></p>
<p>Git Reviewer 正是基于这三种操作进行了分析：</p>
<ul>
<li><p>对于删除类型，Git Reviewer
认为删除行的原始作者应该作为每一行的审查者。</p></li>
<li><p>对于编辑类型，Git Reviewer
认为此部分中的新增内容应该全部由紧邻的最后删除行的原始作者作为审查者。注意，为什么是最后删除行？因为
Git 所采用的 Myers
差分算法默认差分内容优先展示删除操作，其次才是新增操作。因此，从最后的删除行开始，展示的是新增的内容。</p></li>
<li><p>对于新增类型，Git Reviewer 的策略是基于
<code>.gitreviewer.yml</code>
配置文件进行分析。<code>.gitreviewer.yml</code> 文件定义了项目所有者
<code>project owner</code>、目录所有者
<code>folder owner</code>、文件所有者 <code>file owner</code>。此时，Git
Reviewer 会对新增行的文件与 <code>.gitreviewer.yml</code>
所定义的内容进行匹配。</p>
<ul>
<li>如果该文件匹配到了文件所有者，那么相关新增类型优先由文件所有者审查。</li>
<li>如果该文件匹配到了目录所有者，那么相关新增类型其次由目录所有者审查。</li>
<li>如果前两者均没有匹配该文件，那么将由项目所有者来进行审查。</li>
</ul></li>
</ul>
<p>基于对上述三种操作类型进行分析，Git Reviewer
最终将生成一个分析表格，其中罗列了审查者、文件数量、文件占比、代码行数量、代码行占比等信息。Git
Reviewer 建议以代码行占比为依据，对审查者进行排序。</p>
<p>如下所示，为核心功能的分析结果示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|                 Suggested reviewers <span class="keyword">for</span> code changes                   |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| Suggested Reviewer | File Count | File Ratio | Line Count | Line Ratio |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerA         | 5          | 50.0%      | 1000       | 50.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerB         | 3          | 30.0%      | 500        | 25.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerC         | 2          | 20.0%      | 500        | 25.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure>
<h2 id="附加功能">附加功能</h2>
<p>Git Reviewer
还提供了分析代码改动的所涉及的作者分布的功能。此功能相对简单，其分析了所有删除行的原始作者和新增行的现有作者，并同样以表格的形式呈现，罗列作者、文件数量、文件占比、代码行数量、代码行占比等信息，以供用户进行评估和参考。</p>
<p>如下所示，为附加功能的分析结果示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|             Relevant authors involved <span class="keyword">in</span> code changes              |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| Related Author | File Count | File Ratio | Line Count | Line Ratio |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerA     | 5          | 50.0%      | 2000       | 66.6%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerB     | 3          | 30.0%      | 500        | 16.7%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerC     | 2          | 30.0%      | 500        | 16.7%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure>
<h1 id="安装">安装</h1>
<p>Git Reviewer 支持通过 Homebrew
进行安装，命令如下所示。当然，这也是建议的安装方式。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ brew install baochuquan/tap/git-reviewer</span><br></pre></td></tr></table></figure>
<p>或者，也可以通过 Ruby Gem 进行安装，命令如下所示。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gem install git-reviewer</span><br></pre></td></tr></table></figure>
<h1 id="使用">使用</h1>
<p>对于任意 Git 项目，在使用 Git Reviewer
之前应该先在根目录下执行初始化命令，如下所示。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reviewer --init</span><br></pre></td></tr></table></figure>
<p>该命令会自动创建一个 <code>.gitreviewer.yml</code> 文件，内部定义了
<code>project_owner</code>，<code>folder_owner</code>，<code>file_owner</code>
等字段，其中后两者是数组类型，我们可以定义多个
<code>path</code>、<code>owner</code>
字段，从而对项目进行更精准的划分。</p>
<p>此外，<code>.gitreviewer.yml</code> 文件还包含
<code>ignore_folders</code>、<code>ignore_files</code>
字段，它们可以定义一系列目录或文件，以避免加入分析，从而影响分析结果。</p>
<p>如下所示，是一个 <code>.gitreviewer.yml</code>
的示例，我们可以编辑相关字段，从而实现更精准的分析。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">project_owner: admin,</span><br><span class="line">folder_owner:</span><br><span class="line">- owner: developerA,</span><br><span class="line">  path: /path/to/folderA</span><br><span class="line">- owner: developerB</span><br><span class="line">  path: /path/to/folderB</span><br><span class="line"> </span><br><span class="line">file_owner:</span><br><span class="line">- owner: developerC</span><br><span class="line">  path: /path/to/fileC</span><br><span class="line">- owner: developerD</span><br><span class="line">  path: /path/to/fileD</span><br><span class="line"> </span><br><span class="line">ignore_files:</span><br><span class="line">- path/to/file1</span><br><span class="line">- path/to/file2</span><br><span class="line"> </span><br><span class="line">ignore_review_folders:</span><br><span class="line">- path/to/folder1</span><br><span class="line">- path/to/folder2</span><br></pre></td></tr></table></figure>
<h2 id="分析">分析</h2>
<p>Git Reviewer 基于两个 Git 分支进行分析，分别是源分支和目标分支。</p>
<p>源分支，即代码修改所在的分支。默认情况下，Git Reviewer
自动获取当前所在分支作为源分支。当然，也可以使用选项来指定源分支
<code>--source=&lt;source-branch&gt;</code>。除了分支名，Git Reviewer
也支持 Commit ID。</p>
<p>目标分支，即准备合入的目标分支。对此，Git Reviewer 提供了相关选项
<code>--target=&lt;target-branch&gt;</code>。</p>
<p>如下所示是使用 Git Reviewer 进行分析的命令示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reviewer --target=main</span><br></pre></td></tr></table></figure>
<p>默认情况下，Git Reviewer
会同时展示核心功能和附加功能的分析结果。如果我们只希望查看核心功能的结果，可以指定选项
<code>--reviewer</code>；如果我们只希望查看附加功能的结果，可以指定选项
<code>--author</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reviewer --target=main --reviewer</span><br><span class="line"></span><br><span class="line">$ git reviewer --target=main --author</span><br></pre></td></tr></table></figure>
<p>为了查看更多分析信息，我们可以加上 --verbose 选项。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git reviewer --target=main --verbose</span><br></pre></td></tr></table></figure>
<h1 id="后续">后续</h1>
<p>目前，Git Reviewer
仅仅经历了我自己的自测，未来我会在项目上进行实践。如果遇到问题也会逐步进行修复。当然，在使用过程中还会遇到不足之处或者新的痛点，因此会逐步进行完善和迭代。</p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>git-reviewer</tag>
        <tag>Myers</tag>
      </tags>
  </entry>
  <entry>
    <title>写在入职两个月之际</title>
    <url>/2017/09/17/graduated-for-two-month/</url>
    <content><![CDATA[<p>学生生涯结束至今已有两月有余，偶尔还是会念想在北大那些瞬间，好在入职的公司在各方面都非常令我满意，不至于用怀念来解忧生活。</p>
<span id="more"></span>
<h2 id="关于工作"># 关于工作</h2>
<p>说说现在的公司吧，一家处于成长期的K12在线教育创业公司——猿辅导，坐落在阜通站旁的利星行中心。公司主要有粉笔网、猿题库、猿辅导、小猿搜题等几款在线教育App。</p>
<p>7月10日刚入职，我被安排到小猿搜题研发部的iOS开发岗。作为一名无任何iOS开发经验的应届毕业生，我的压力还是蛮大的，毕竟这对我来说是一个全新的挑战。好在我的同事们都非常nice，尤其是我的mentor——展哥，还有坐我旁边的元老级程序媛——琳洁。每每我在学习以及开发过程中有任何问题，他们都会不厌其烦地给我讲解，真的非常感谢他们！相比我之前实习的那家公司（某度），就同事间的关系来说，真是不知道高到哪里去了。</p>
<p>我们研发部研发人员大概不到20人，4个iOS，3个安卓，5个后台，3个前端，3个测试，当然其中也有些人前后端都做，小组内同事大都是硕士以上学历。研发部内部分为三个小团体：产品、客户端、服务器端。iOS、安卓、测试共同组成一个客户端，组内气氛每天都很欢乐，不至于每天工作得很压抑。</p>
<p>公司的工作制度也是比较和谐的。朝十晚七，不打卡，无KPI，不提倡加班。每天上午会有一个几分钟的站会，每个人说一下自己前一天的任务完成情况，以及当天的任务安排。我们平时也没有那么多的会，除非PM有新的产品需求，并且不提倡大家携带笔记本开会，从而提高开会效率。在某度，几乎每天都有各种会议，开会的时候大家基本都会携带笔记本，自己干自己的事。过多的会议真的会严重碎片会工作时间，降低工作效率。在某度实习期间，一个月的代码量都不如我现在一个星期的代码量。</p>
<p>周二下午我们小组会对PM提出的产品需求汇集、拆分，并进行难度评分，最后予以分配。站会也是就是对这些任务进展的汇报及安排。如此一套Scrum开发流程，可以极大地提高我们的工作效率。工作效率高了，也就没有必要加班了，生活也不是那么枯燥乏味了。</p>
<p>入职两个月以来，我能感受到自己的成长非常大。真正的项目实践总是能让你对一些东西有更深入的理解，比如git、gerrit等。公司对于项目管理使用了很多开源的工具，并进行了重组。希望在之后的日子里，我能对这些工具平台也有更深一步的了解。</p>
<h2 id="关于生活"># 关于生活</h2>
<p>女票家给她在塘溪津门买了一套房，首付30%，2.2w/平米。接下来由我们两来还房贷，我每个月还贷1w，房租3k多，虽说生活还没到捉襟见肘的地步，但是能省则省吧。公积金也准备提出来了，只有这样，生活还能够多出一些积蓄来。当自身背负了如此沉重的房贷后，事业的发展总是会受到一定的影响，在面临选择的时候，会变得格外谨慎、犹豫，未来的我也许也会面临这样的情境。</p>
<p>该吐槽的还是要得吐槽。政府现在真的是把人往绝境里逼，虽说出台了一套又一套的房价抑制政策，然而所谓的政策只不过是稳定人心的幌子，韭菜该割还是要割，房价只是减速增长而已。房价的增长比工资的增长还快，买不起房的人永远都买不起房。</p>
<p>今年北京市的高考状元接受采访时的言论真的是一针见血。在教育方面上，他们享受着农村孩子无法想象的资源优势，进入名校对他们来说只是水到渠成的问题。事实上，在北大求学期间，我也意识到这个问题：周围的同学，尤其是本科生，大多数的家庭要么是高识分子，要么是高收入家庭，农村而来学生真的很少。现在社会频频出现学生入学如调查家庭背景的案例，很明显，学校在区分学生家庭所处的社会阶级，这样的情况在未来还会继续蔓延。富人越富，穷人愈穷，下一代亦是如此，阶级的固化正在酝酿。也许我们这一代还有不少能从底层往上爬，但后来的人真的将越来越难...</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(8)——图形图像渲染原理</title>
    <url>/2018/08/26/graphics-rending-principle-gpu/</url>
    <content><![CDATA[<p>最近在 iOS
开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS
动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。</p>
<span id="more"></span>
<p>本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识储备。</p>
<h1 id="引言">引言</h1>
<p>作为程序员，我们或多或少知道可视化应用程序都是由 CPU 和 GPU
协作执行的。那么我们就先来了解一下两者的基本概念：</p>
<ul>
<li><strong>CPU（Central Processing
Unit）</strong>：现代计算机的三大核心部分之一，作为整个系统的运算和控制单元。CPU
内部的流水线结构使其拥有一定程度的并行计算能力。</li>
<li><strong>GPU（Graphics Processing
Unit）</strong>：一种可进行绘图运算工作的专用微处理器。GPU 能够生成
2D/3D
的图形图像和视频，从而能够支持基于窗口的操作系统、图形用户界面、视频游戏、可视化图像应用和视频播放。GPU
具有非常强的并行计算能力。</li>
</ul>
<p>这时候可能会产生一个问题：CPU 难道不能代替 GPU
来进行图形渲染吗？答案当然是肯定的，不过在看了下面这个视频就明白为什么要用
GPU 来进行图形渲染了。</p>
<p><a
href="http://ugcydzd.qq.com/uwMRJfz-r5jAYaQXGdGnC2_ppdhgmrDlPaRvaV7F2Ic/a0310ca26r9.m701.mp4?vkey=40961BB7F3520A37C85D4E4B4130DD91374BFB11499862930CE40B3E09D41D06125BC9EFC73A98DDDE2E5A64EAEB896492064C775F5C82ECD1D72D91D30C53F874EF2C404B480B719C6B8FAA1FA012CEF8743749150271333535195D599FE9F4E8E5FADC8C1A4FBEE74E1C81AA4206F408DE82EE359B3193&amp;br=29&amp;platform=2&amp;fmt=auto&amp;level=0&amp;sdtfrom=v1010&amp;guid=f401ea7eb4e13983f11cfe58f689e34d">GPU
CPU 模拟绘图视频</a></p>
<p>使用 GPU 渲染图形的根本原因就是：速度。GPU
的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。</p>
<p>那么像素是如何绘制在屏幕上的？计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为
<strong>渲染</strong>。渲染过程中最常用的技术就是
<strong>光栅化</strong>。</p>
<p>关于光栅化的概念，以下图为例，假如有一道绿光与存储在内存中的一堆三角形中的某一个在三维空间坐标中存在相交的关系。那么这些处于相交位置的像素都会被绘制到屏幕上。当然这些三角形在三维空间中的前后关系也会以遮挡或部分遮挡的形式在屏幕上呈现出来。一句话总结：光栅化就是将数据转化成可见像素的过程。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-rasterization-basic-concept.png?x-oss-process=image/resize,w_300" /></p>
<p>GPU
则是执行转换过程的硬件部件。由于这个过程涉及到屏幕上的每一个像素，所以
GPU 被设计成了一个高度并行化的硬件部件。</p>
<p>下面，我们来简单了解一下 GPU 的历史。</p>
<h1 id="gpu-历史">GPU 历史</h1>
<p>GPU 还未出现前，PC 上的图形操作是由 <strong>视频图形阵列（VGA，Video
Graphics Array）</strong> 控制器完成。VGA
控制器由连接到一定容量的DRAM上的存储控制器和显示产生器构成。</p>
<p>1997 年，VGA 控制器开始具备一些 3D 加速功能，包括用于
<strong>三角形生成</strong>、<strong>光栅化</strong>、<strong>纹理贴图</strong>
和 <strong>阴影</strong>。</p>
<p>2000
年，一个单片处图形处理器继承了传统高端工作站图形流水线的几乎每一个细节。因此诞生了一个新的术语
GPU 用来表示图形设备已经变成了一个处理器。</p>
<p>随着时间的推移，GPU
的可编程能力愈发强大，其作为可编程处理器取代了固定功能的专用逻辑，同时保持了基本的
3D 图形流水线组织。</p>
<p>近年来，GPU
增加了处理器指令和存储器硬件，以支持通用编程语言，并创立了一种编程环境，从而允许使用熟悉的语言（包括
C/C++）对 GPU 进行编程。</p>
<p>如今，GPU 及其相关驱动实现了图形处理中的 <code>OpenGL</code> 和
<code>DirectX</code>
模型，从而允许开发者能够轻易地操作硬件。<code>OpenGL</code>
严格来说并不是常规意义上的 API，而是一个第三方标准（由 khronos
组织制定并维护），其严格定义了每个函数该如何执行，以及它们的输出值。至于每个函数内部具体是如何实现的，则由
OpenGL 库的开发者自行决定。实际 OpenGL
库的开发者通常是显卡的生产商。<code>DirectX</code> 则是由 Microsoft
提供一套第三方标准。</p>
<h1 id="gpu-图形渲染流水线">GPU 图形渲染流水线</h1>
<p>GPU 图形渲染流水线的主要工作可以被划分为两个部分：</p>
<ul>
<li>把 3D 坐标转换为 2D 坐标</li>
<li>把 2D 坐标转变为实际的有颜色的像素</li>
</ul>
<p>GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示。</p>
<ul>
<li><strong>顶点着色器（Vertex Shader）</strong></li>
<li><strong>形状装配（Shape Assembly）</strong>，又称
<strong>图元装配</strong></li>
<li><strong>几何着色器（Geometry Shader）</strong></li>
<li><strong>光栅化（Rasterization）</strong></li>
<li><strong>片段着色器（Fragment Shader）</strong></li>
<li><strong>测试与混合（Tests and Blending）</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/opengl-graphics-pipeline.png" /></p>
<p>第一阶段，顶点着色器。该阶段的输入是 <strong>顶点数据（Vertex
Data）</strong> 数据，比如以数组的形式传递 3 个 3D
坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把
3D 坐标转为另一种 3D
坐标，同时顶点着色器可以对顶点属性进行一些基本处理。</p>
<p>第二阶段，形状（图元）装配。该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图中则是一个三角形。<strong>图元（Primitive）</strong>
用于表示如何渲染顶点数据，如：点、线、三角形。</p>
<p>第三阶段，几何着色器。该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<p>第四阶段，光栅化。该阶段会把图元映射为最终屏幕上相应的像素，生成片段。<strong>片段（Fragment）</strong>
是渲染一个像素所需要的所有数据。</p>
<p>第五阶段，片段着色器。该阶段首先会对输入的片段进行
<strong>裁切（Clipping）</strong>。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。</p>
<p>第六阶段，测试与混合。该阶段会检测片段的对应的深度值（<code>z</code>
坐标），判断这个像素位于其它物体的前面还是后面，决定是否应该丢弃。此外，该阶段还会检查
<code>alpha</code> 值（ <code>alpha</code>
值定义了一个物体的透明度），从而对物体进行混合。因此，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<p>关于混合，GPU 采用如下公式进行计算，并得出最后的颜色。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R = S + D * (1 - Sa)</span><br></pre></td></tr></table></figure>
<p>关于公式的含义，假设有两个像素 S(source) 和 D(destination)，S 在
<code>z</code> 轴方向相对靠前（在上面），D 在 <code>z</code>
轴方向相对靠后（在下面），那么最终的颜色值就是 <strong>S（上面像素）
的颜色 + D（下面像素） 的颜色 * （1 - S（上面像素）
颜色的透明度）</strong>。</p>
<p>上述流水线以绘制一个三角形为进行介绍，可以为每个顶点添加颜色来增加图形的细节，从而创建图像。但是，如果让图形看上去更加真实，需要足够多的顶点和颜色，相应也会产生更大的开销。为了提高生产效率和执行效率，开发者经常会使用
<strong>纹理（Texture）</strong> 来表现细节。<strong>纹理是一个 2D
图片（甚至也有 1D 和 3D 的纹理）</strong>。<strong>纹理</strong>
一般可以直接作为图形渲染流水线的第五阶段的输入。</p>
<p>最后，我们还需要知道上述阶段中的着色器事实上是一些程序，它们运行在
GPU
中成千上万的小处理器核中。这些着色器允许开发者进行配置，从而可以高效地控制图形渲染流水线中的特定部分。由于它们运行在
GPU 中，因此可以降低 CPU 的负荷。着色器可以使用多种语言编写，OpenGL
提供了 GLSL（OpenGL Shading Language） 着色器语言。</p>
<h1 id="gpu-存储系统">GPU 存储系统</h1>
<p>早期的 GPU，不同的着色器对应有着不同的硬件单元。如今，GPU
流水线则使用一个统一的硬件来运行所有的着色器。此外，nVidia 还提出了
<strong>CUDA（Compute Unified Device Architecture）</strong>
编程模型，可以允许开发者通过编写 C 代码来访问 GPU
中所有的处理器核，从而深度挖掘 GPU 的并行计算能力。</p>
<p>下图所示为 GPU 内部的层级结构。最底层是计算机的系统内存，其次是 GPU
的内部存储，然后依次是两级 cache：L2 和 L1，每个 L1 cache 连接至一个
<strong>流处理器（SM，stream processor）</strong>。</p>
<ul>
<li>SM L1 Cache 的存储容量大约为 16 至 64KB。</li>
<li>GPU L2 Cache 的存储容量大约为几百 KB。</li>
<li>GPU 的内存最大为 12GB。</li>
</ul>
<p>GPU 上的各级存储系统与对应层级的计算机存储系统相比要小不少。</p>
<p>此外，GPU
内存并不具有一致性，也就意味着并不支持并发读取和并发写入。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-hierarchy.png?x-oss-process=image/resize,w_400" /></p>
<h1 id="gpu-流处理器">GPU 流处理器</h1>
<p>下图所示为 GPU 中每个流处理器的内部结构示意图。每个流处理器集成了一个
L1 Cache。顶部是处理器核共享的寄存器堆。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-stream-processor.png?x-oss-process=image/resize,w_400" /></p>
<h1 id="cpu-gpu-异构系统">CPU-GPU 异构系统</h1>
<p>至此，我们大致了解了 GPU 的工作原理和内部结构，那么实际应用中 CPU 和
GPU 又是如何协同工作的呢？</p>
<p>下图所示为两种常见的 CPU-GPU 异构架构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cpu-gpu-architecture.png" /></p>
<p>左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e
总线进行连接。这种结构的缺点在于 PCI-e
相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p>
<p>右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU
采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p>
<p>注意，目前很多 SoC 都是集成了CPU 和
GPU，事实上这仅仅是在物理上进行了集成，并不意味着它们使用的就是耦合式结构，大多数采用的还是分离式结构。耦合式结构是在系统上进行了集成。</p>
<p>在存储管理方面，分离式结构中 CPU 和 GPU
各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU
没有独立的内存，与 GPU 共享系统内存，由 MMU 进行存储管理。</p>
<p>图形应用程序调用 <code>OpenGL</code> 或 <code>Direct3D</code> API
功能，将 GPU 作为协处理器使用。API 通过面向特殊 GPU 优化的图形设备驱动向
GPU 发送命令、程序、数据。</p>
<h1 id="gpu-资源管理模型">GPU 资源管理模型</h1>
<p>下图所示为分离式异构系统中 GPU 的资源管理模型示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-management-model.png" /></p>
<ol type="1">
<li><strong>MMIO（Memory-Mapped I/O）</strong>
<ul>
<li>CPU 通过 MMIO 访问 GPU 的寄存器状态。</li>
<li>通过 MMIO 传送数据块传输命令，支持 DMA
的硬件可以实现块数据传输。</li>
</ul></li>
<li><strong>GPU Context</strong>
<ul>
<li>上下文表示 GPU 的计算状态，在 GPU
中占据部分虚拟地址空间。多个活跃态下的上下文可以在 GPU 中并存。</li>
</ul></li>
<li><strong>CPU Channel</strong>
<ul>
<li>来自 CPU 操作 GPU 的命令存储在内存中，并提交至 GPU channel
硬件单元。</li>
<li>每个 GPU 上下文可拥有多个 GPU Channel。每个 GPU 上下文都包含 GPU
channel 描述符（GPU 内存中的内存对象）。</li>
<li>每个 GPU Channel 描述符存储了channel 的配置，如：其所在的页表。</li>
<li>每个 GPU Channel 都有一个专用的命令缓冲区，该缓冲区分配在 GPU
内存中，通过 MMIO 对 CPU 可见。</li>
</ul></li>
<li><strong>GPU 页表</strong>
<ul>
<li>GPU 上下文使用 GPU
页表进行分配，该表将虚拟地址空间与其他地址空间隔离开来。</li>
<li>GPU 页表与 CPU 页表分离，其驻留在 GPU 内存中，物理地址位于 GPU
通道描述符中。 通过 GPU channel 提交的所有命令和程序都在对应的 GPU
虚拟地址空间中执行。</li>
<li>GPU 页表将 GPU 虚拟地址不仅转换为 GPU
设备物理地址，还转换为主机物理地址。这使得 GPU 页面表能够将 GPU
存储器和主存储器统一到统一的 GPU
虚拟地址空间中，从而构成一个完成的虚拟地址空间。</li>
</ul></li>
<li><strong>PFIFO Engine</strong>
<ul>
<li>PFIFO 是一个提交 GPU 命令的特殊引擎。</li>
<li>PFIFO 维护多个独立的命令队列，即 channel。</li>
<li>命令队列是带有 put 和 get 指针的环形缓冲器。</li>
<li>PFIFO 引擎会拦截多有对通道控制区域的访问以供执行。</li>
<li>GPU 驱动使用一个通道描述符来存储关联通道的设置。</li>
</ul></li>
<li><strong>BO</strong>
<ul>
<li>缓冲对象（Buffer
Object）。一块内存，可以用来存储纹理，渲染对象，着色器代码等等。</li>
</ul></li>
</ol>
<h1 id="cpu-gpu-工作流">CPU-GPU 工作流</h1>
<p>下图所示为 CPU-GPU 异构系统的工作流，当 CPU
遇到图像处理的需求时，会调用 GPU
进行处理，主要流程可以分为以下四步：</p>
<ol type="1">
<li>将主存的处理数据复制到显存中</li>
<li>CPU 指令驱动 GPU</li>
<li>GPU 中的每个运算单元并行处理</li>
<li>GPU 将显存结果传回主存</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/cuda_processing_flow.png" /></p>
<h1 id="屏幕图像显示原理">屏幕图像显示原理</h1>
<p>介绍屏幕图像显示的原理，需要先从 CRT 显示器原理说起，如下图所示。CRT
的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal
synchronization），简称
<strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical
synchronization），简称
<strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是
VSync
信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" /></p>
<p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容提交至
GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照
<code>VSync</code>
信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_700" /></p>
<p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU
通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。在这种情况下，GPU
会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU
会直接把视频控制器的指针指向第二个缓冲器。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png" /></p>
<p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU
将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" /></p>
<p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是
V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync
信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.cs.utah.edu/~jeffp/teaching/MCMD/S20-GPU.pdf">GPU
Architecture and Models</a></li>
<li>计算机组成与设计：硬件、软件接口</li>
<li><a
href="https://learnopengl-cn.readthedocs.io/zh/latest/">欢迎来到OpenGL的世界</a></li>
<li><a
href="https://pdfs.semanticscholar.org/presentation/52d1/963f6a3409aff1f8d73ba1819a187f39f6e1.pdf">AMD
APU Series</a></li>
<li><a
href="http://m.elecfans.com/article/713834.html">一文详解GPU结构及工作原理</a></li>
<li><a
href="https://www.slideshare.net/mohamedragabslideshare/p12-29046493">Revisting
Co-Processing for Hash Joins on the Coupled CPU-GPU
Architecture</a></li>
<li><a
href="https://insujang.github.io/2017-04-27/gpu-architecture-overview/">GPU
Architecture Overview</a></li>
<li><a href="https://zh.wikipedia.org/wiki/CUDA">CUDA</a></li>
<li><a
href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS
保持界面流程的技巧</a></li>
<li><a href="https://segmentfault.com/a/1190000000390012">iOS
开发：绘制像素到屏幕</a></li>
</ol>
<h1 id="扩展阅读">扩展阅读</h1>
<ol type="1">
<li><a href="https://slideplayer.com/slide/11059244/">Rendering
pipeline: The hardware side</a></li>
<li><a
href="http://meseec.ce.rit.edu/551-projects/spring2015/3-2.pdf">Graphics
Processing Unit(GPU) Memory Hierarchy</a></li>
<li><a href="http://www.d.umn.edu/~data0003/Talks/gpuarch.pdf">Graphics
Processing Unit Architecture(GPU Arch) With a focus on NVIDIA GeForce
6800 GPU</a></li>
<li><a
href="https://www.jianshu.com/p/d05d19f70bac">iOS动画篇：核心动画</a></li>
<li><a
href="https://www.anandtech.com/show/7335/the-iphone-5s-review/7">The
iPhone 5s Review</a></li>
<li><a href="https://www.realworldtech.com/apple-custom-gpu/">A Look
Inside Apple’s Custom GPU for the iPhone</a></li>
<li><a
href="https://appleinsider.com/articles/17/04/17/one-apple-gpu-one-giant-leap-in-graphics-for-iphone-8">One
Apple GPU, one giant leap in graphics for iPhone 8</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 CLAide 开发命令行工具？</title>
    <url>/2021/11/21/how-to-develop-command-line-tool-with-claide/</url>
    <content><![CDATA[<p>在 <a href="http://chuquan.me/2021/11/04/claide/">CLAide</a>
一文中，我们了解到 CocoaPods 是基于 CLAide
开发的一款依赖管理工具，也是一款命令行工具。本文，我们将基于 CLAide
开发一款简易的命令行工具——饮料制作器（BeverageMaker）。</p>
<span id="more"></span>
<p>在本项目中，我们将使用 bundler
作为项目管理工具和依赖管理工具，其实本质上就是使用 bundle 开发一个 gem
工具。</p>
<p>本文代码传送门 <a
href="https://github.com/baochuquan/BeverageMaker">https://github.com/baochuquan/BeverageMaker</a>。</p>
<h1 id="目标">目标</h1>
<p>我们希望饮料制作器（BeverageMaker）能够制作两种类型的饮料：咖啡、茶。对此，我们需要分别实现两个子命令：<code>coffee</code>、<code>tea</code>。</p>
<p>对于咖啡，我们提供多种口味，如：BlackEye、Affogato、CaPheSuaDa、RedTux。对此，我们希望为
<code>coffee</code>
提供多个子命令，分别是：<code>black-eye</code>、<code>affogato</code>、<code>ca-phe-sua-da</code>、<code>red-tux</code>。</p>
<p>对于茶，我们提供多种口味，如：Black、Green、Oolong、White。这里，我们希望为
<code>tea</code>
提供多个参数，分别是：<code>black</code>、<code>green</code>、<code>oolong</code>、<code>white</code>。</p>
<p>无论是咖啡还是茶，我们都希望两者支持选择是够添加牛奶、添加糖或蜂蜜作为甜味剂。对此，我们希望支持一个标志
<code>--no-milk</code> 表示是否添加牛奶，支持一个选项
<code>--sweetener</code>，其值为 <code>super</code> 或
<code>honey</code>。</p>
<p>此外，对于茶，我们希望它支持一个额外的标志 <code>--iced</code>
表示是否加冰。</p>
<h1 id="生成模版项目">生成模版项目</h1>
<p>首先，我们使用 <code>bundle gem GEM_NAME</code>
命令生成一个模版项目，项目名为：<code>BeverageMaker</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bundle gem BeverageMaker</span></span><br></pre></td></tr></table></figure>
<p>上述命令会在当前目录下生成一个项目，项目的目录结构如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/beverage-maker-01.png?x-oss-process=image/resize,w_800" /></p>
<p>命令会自动生成一个脚手架模板项目，主要包含以下文件：</p>
<ul>
<li><strong><code>BeverageMaker.gemspec</code></strong>：Gem
Specification 文件，定义 Rubygem 的基本信息，如：名称、描述信息、gem
主页、 所需要的依赖等等。</li>
<li><strong><code>CODE_OF_CONDUCT.md</code></strong>：关于代码贡献者需要遵循的行为准则。</li>
<li><strong><code>Gemfile</code></strong>：用于管理项目依赖。该文件中有一行代码是
<code>gemspec</code>，其会调用
<code>BeverageMaker.gemspec</code>，从而导入项目的依赖项。因此，最佳实践是在
<code>gemspec</code> 中指定项目所依赖的所有 gem。</li>
<li><strong><code>LICENSE.txt</code></strong>：默认指定项目为 MIT
协议。</li>
<li><strong><code>Rakefile</code></strong>：Ruby 中的构建脚本，类似于
C/C++ 中的 Makefile。通过 <code>Bundler::GemHelper.install_tasks</code>
可以添加 <code>build</code>、<code>install</code>、<code>release</code>
等任务。
<ul>
<li><strong><code>build</code> 任务</strong>：构建当前版本的
gem，并将其存储在 <code>pkg</code> 目录下。</li>
<li><strong><code>install</code> 任务</strong>：构建
gem，并将其安装在我们的系统中。</li>
<li><strong><code>release</code> 任务</strong>：将 gem 推送到
Rubygems，从而对外公开发布。</li>
</ul></li>
<li><strong><code>lib/BeverageMaker.rb</code></strong>：定义 gem
代码的主文件。当 gem 被加载时，Bundler 会请求这个文件。该文件定义了一个
<code>module</code>，其可以作为 gem
代码的命名空间。因此，最佳实践是把代码定义在 <code>module</code>
中。</li>
<li><strong><code>lib/BeverageMaker</code> 目录</strong>：该目录下包含了
gem 的所有代码。<code>lib/BeverageMaker.rb</code> 文件用于设置 gem
的环境，而它的所有代码都在 <code>lib/BeverageMaker</code> 目录下。如果
gem 有多种功能，我们可以进一步对其拆分子目录。</li>
<li><strong><code>lib/BeverageMaker/version.rb</code></strong>：内部通过一个
<code>VERSION</code> 常量定义 gem 的版本。文件由
<code>BeverageMaker.gemspec</code> 进行加载，从而为 gem
指定版本。当发布新版本时，可以修改 <code>VERSION</code>
的值来指定新的版本号。</li>
<li><strong><code>spec</code> 目录</strong>：用于存放测试文件。</li>
</ul>
<h1 id="修改-gemspec-配置">修改 gemspec 配置</h1>
<p>初始化模板项目后，我们需要对 <code>BeverageMaker.gemspec</code>
文件所包含的 <code>TODO</code>
字段进行替换。此外，我们还需要添加项目依赖：<code>'claide', '&gt;= 1.0.2', '&lt; 2.0'</code>
和 <code>'colored2', '~&gt; 3.1'</code>。</p>
<blockquote>
<p><code>colored2</code> 用于 banner 信息的 ANSI
转义，从而能够支持以富文本格式在终端输出。</p>
</blockquote>
<p>修改后的 <code>BeverageMaker.gemspec</code> 配置如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">require_relative <span class="string">&#x27;lib/BeverageMaker/version&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Gem::Specification</span>.new <span class="keyword">do</span> |<span class="params">spec</span>|</span><br><span class="line">  spec.name          = <span class="string">&quot;BeverageMaker&quot;</span></span><br><span class="line">  spec.version       = <span class="title class_">BeverageMaker</span><span class="symbol">:</span><span class="symbol">:VERSION</span></span><br><span class="line">  spec.authors       = [<span class="string">&quot;baochuquan&quot;</span>]</span><br><span class="line">  spec.email         = [<span class="string">&quot;baochuquan@163.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">  spec.summary       = <span class="string">&quot;Beverage Maker&quot;</span></span><br><span class="line">  spec.description   = <span class="string">&quot;A Command Line Tool Example&quot;</span></span><br><span class="line">  spec.homepage      = <span class="string">&quot;https://github.com/baochuquan/BeverageMaker&quot;</span></span><br><span class="line">  spec.license       = <span class="string">&quot;MIT&quot;</span></span><br><span class="line">  spec.required_ruby_version = <span class="title class_">Gem::Requirement</span>.new(<span class="string">&quot;&gt;= 2.3.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">  spec.metadata[<span class="string">&quot;homepage_uri&quot;</span>] = spec.homepage</span><br><span class="line">  spec.metadata[<span class="string">&quot;source_code_uri&quot;</span>] = <span class="string">&quot;https://github.com/baochuquan/BeverageMaker&quot;</span></span><br><span class="line">  spec.metadata[<span class="string">&quot;changelog_uri&quot;</span>] = <span class="string">&quot;https://github.com/baochuquan/BeverageMaker&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Specify which files should be added to the gem when it is released.</span></span><br><span class="line">  <span class="comment"># The `git ls-files -z` loads the files in the RubyGem that have been added into git.</span></span><br><span class="line">  spec.files         = <span class="title class_">Dir</span>.chdir(<span class="title class_">File</span>.expand_path(<span class="string">&#x27;..&#x27;</span>, <span class="variable constant_">__FILE__</span>)) <span class="keyword">do</span></span><br><span class="line">    <span class="string">`git ls-files -z`</span>.split(<span class="string">&quot;\x0&quot;</span>).reject &#123; |<span class="params">f</span>| f.match(<span class="regexp">%r&#123;^(test|spec|features)/&#125;</span>) &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  spec.bindir        = <span class="string">&quot;exe&quot;</span></span><br><span class="line">  spec.executables   = <span class="string">&quot;beverage-maker&quot;</span></span><br><span class="line">  spec.require_paths = [<span class="string">&quot;lib&quot;</span>]</span><br><span class="line"></span><br><span class="line">  spec.add_dependency <span class="string">&#x27;claide&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.3&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="定义命令行入口">定义命令行入口</h1>
<p>我们通过修改 <code>BeverageMaker.gemspec</code>
来定义命令行入口的位置和名称，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">spec.bindir         = <span class="string">&quot;exe&quot;</span></span><br><span class="line">spec.executables    = <span class="string">&quot;beverage-maker&quot;</span></span><br></pre></td></tr></table></figure>
<p>模板自动生成的 <code>BeverageMaker.gemspec</code>
配置中，<code>bindir</code> 默认为
<code>exe</code>，表示二进制（binary）文件的存储目录为项目根目录下的
<code>exe</code> 目录；<code>executables</code> 默认为
<code>spec.files.grep(%r&#123;^exe/&#125;) &#123; |f| File.basename(f) &#125;</code>，表示
<code>exe</code> 目录下的所有文件。我们可以将其改写成指定名称
<code>beverage-maker</code>，该文件也是命令行的入口文件。</p>
<p>定义好命令行的入口与名称后，我们需要在 <code>exe</code>
目录下创建一个同名的文件
<code>beverage-maker</code>，将其作为命令行入口，其定义如下：
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;BeverageMaker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">BeverageMaker</span><span class="symbol">:</span><span class="symbol">:Command</span>.run(<span class="variable constant_">ARGV</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意，由于 <code>beverage-maker</code>
是可执行文件，需要确保其具有可执行权限，我们通过执行
<code>chmod +x beverage-maker</code> 命令为其添加可执行权限。</p>
<h1 id="实现根命令">实现根命令</h1>
<p>上述命令入口中，<code>BeverageMaker::Command</code> 是
<code>CLAide::Command</code>
的子类，作为根命令，它也是一个抽象类。由于，<code>coffee</code> 和
<code>tea</code> 子类都支持 <code>--no-milk</code> 和
<code>--sweetener</code>
选项，我们可以将这些选项定义在根命令的类中。</p>
<p>对此，我们新建一个文件 <code>command.rb</code>，并定义
<code>Beverage::Command</code> 根命令，如下所示： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># command.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">BeverageMaker</span></span><br><span class="line">  <span class="keyword">require</span> <span class="string">&#x27;claide&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Command</span> &lt; <span class="title class_ inherited__">CLAide::Command</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">require</span> <span class="string">&#x27;beveragemaker/command/coffee&#x27;</span></span><br><span class="line">    <span class="keyword">require</span> <span class="string">&#x27;beveragemaker/command/tea&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.abstract_command = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.description = <span class="string">&#x27;Make delicious beverages from the comfort of your&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;terminal.&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This would normally default to `beverage-maker`, based on the class’ name.</span></span><br><span class="line">    <span class="variable language_">self</span>.command = <span class="string">&#x27;beverage-maker&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">self</span>.options</span><br><span class="line">      [</span><br><span class="line">        [<span class="string">&#x27;--no-milk&#x27;</span>, <span class="string">&#x27;Don’t add milk to the beverage&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;--sweetener=[sugar|honey]&#x27;</span>, <span class="string">&#x27;Use one of the available sweeteners&#x27;</span>],</span><br><span class="line">      ].concat(<span class="variable language_">super</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">argv</span>)</span><br><span class="line">      <span class="variable">@add_milk</span> = argv.flag?(<span class="string">&#x27;milk&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">      <span class="variable">@sweetener</span> = argv.option(<span class="string">&#x27;sweetener&#x27;</span>)</span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate!</span></span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@sweetener</span> &amp;&amp; !<span class="string">%w(sugar honey)</span>.<span class="keyword">include</span>?(<span class="variable">@sweetener</span>)</span><br><span class="line">        help! <span class="string">&quot;`<span class="subst">#&#123;<span class="variable">@sweetener</span>&#125;</span>&#x27; is not a valid sweetener.&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span></span><br><span class="line">      puts <span class="string">&#x27;* Boiling water…&#x27;</span></span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@add_milk</span></span><br><span class="line">        puts <span class="string">&#x27;* Adding milk…&#x27;</span></span><br><span class="line">        sleep <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@sweetener</span></span><br><span class="line">        puts <span class="string">&quot;* Adding <span class="subst">#&#123;<span class="variable">@sweetener</span>&#125;</span>…&quot;</span></span><br><span class="line">        sleep <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
我们通过覆写 <code>self.options</code>
自定义支持的选项：<code>--no-milk</code> 和
<code>--sweetener</code>。通过设置 <code>self.description</code>
指定命令的描述信息。通过设置 <code>self.abstract_command</code> 为
<code>true</code> 将其置为抽象命令。</p>
<p>在构造方法 <code>initialize</code> 中，我们通过
<code>argv</code>（<code>ARGV</code> 类的实例）
读取对应的标志和选项进行实例化。</p>
<p>在校验方法 <code>validate!</code> 中，我们需要对
<code>--sweetener</code> 选项进行校验，因为它只支持 <code>sugar</code>
和 <code>honey</code>
两个值，当传入的值不符合预定义时，则抛出帮助提示。</p>
<p>在运行方法 <code>run</code> 中，我们定义饮料生产的通用逻辑，并根据
<code>--no-milk</code> 标志和 <code>--sweetener</code>
选项决定是否指定特殊逻辑。</p>
<h1 id="实现子命令">实现子命令</h1>
<p>接下来，我们需要实现子命令 <code>coffee</code> 和
<code>tea</code>，为了能够对功能进行分类，我们新建一个
<code>lib/BeverageMaker/command</code> 目录，并新建
<code>coffee.rb</code> 和 <code>tea.rb</code>
文件用于实现对应的命令类。</p>
<h2 id="coffee-子命令">Coffee 子命令</h2>
<p><code>Coffee</code> 子命令类的定义如下所示，其继承自
<code>BeverageMaker::Command</code> 抽象类，内部通过设置
<code>self.abstract_command</code>、<code>self.summary</code>、<code>self.description</code>
等属性进行自定义配置。通过覆写 <code>run</code>
方法，定义制作咖啡时的特定逻辑，注意内部会调用 <code>super</code>
以执行饮料制作的通用逻辑。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coffee.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">BeverageMaker</span></span><br><span class="line">  <span class="comment"># Unlike the Tea command, this command uses subcommands to specify the</span></span><br><span class="line">  <span class="comment"># flavor.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># Which one makes more sense is up to you.</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Coffee</span> &lt; <span class="title class_ inherited__">Command</span></span><br><span class="line">    <span class="variable language_">self</span>.abstract_command = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.summary = <span class="string">&#x27;Drink brewed from roasted coffee beans&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.description = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">      Coffee is a brewed beverage with a distinct aroma and flavor</span></span><br><span class="line"><span class="string">      prepared from the roasted seeds of the Coffea plant.</span></span><br><span class="line"><span class="string">    DESC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span></span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">      puts <span class="string">&quot;* Grinding <span class="subst">#&#123;<span class="variable language_">self</span>.<span class="keyword">class</span>.command&#125;</span> beans…&quot;</span></span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">      puts <span class="string">&#x27;* Brewing coffee…&#x27;</span></span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">      puts <span class="string">&#x27;* Enjoy!&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BlackEye</span> &lt; <span class="title class_ inherited__">Coffee</span></span><br><span class="line">      <span class="variable language_">self</span>.summary = <span class="string">&#x27;A Black Eye is dripped coffee with a double shot of &#x27;</span> \</span><br><span class="line">        <span class="string">&#x27;espresso&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Affogato</span> &lt; <span class="title class_ inherited__">Coffee</span></span><br><span class="line">      <span class="variable language_">self</span>.summary = <span class="string">&#x27;A coffee-based beverage (Italian for &quot;drowned&quot;)&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CaPheSuaDa</span> &lt; <span class="title class_ inherited__">Coffee</span></span><br><span class="line">      <span class="variable language_">self</span>.summary = <span class="string">&#x27;A unique Vietnamese coffee recipe&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">RedTux</span> &lt; <span class="title class_ inherited__">Coffee</span></span><br><span class="line">      <span class="variable language_">self</span>.summary = <span class="string">&#x27;A Zebra Mocha combined with raspberry flavoring&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还定义了 <code>Coffee</code>
类的子类，包括：<code>BlackEye</code>、<code>Affogato</code>、<code>CoPheSuaDa</code>、<code>RedTux</code>。基于
Ruby 的语言特性，在运行时，这些子类会自动被标记为 <code>Coffee</code>
的子命令（内部由 <code>self.inherited</code>
命令支持）。这些子类各自定义了不同的命令摘要。</p>
<h2 id="tea-子命令">Tea 子命令</h2>
<p><code>Tea</code> 子命令类的定义如下所示，其继承自
<code>BeverageMaker::Command</code> 抽象类，内部通过设置
<code>self.summary</code>、<code>self.description</code>
等属性进行自定义配置。</p>
<p><code>Tea</code> 子命令类覆写了 <code>self.arguments</code>
属性，这个属性定义了命令的参数，在打印帮助信息时，会使用这里所定义的内容。</p>
<p><code>Tea</code> 子命令类覆写了 <code>self.options</code>
属性，这个属性定义了 <code>tea</code> 子命令所特有的选项
<code>--iced</code>。</p>
<p><code>Tea</code> 通过覆写构造方法 <code>initialize</code> 从
<code>argv</code> 中按顺序读取参数和标志。</p>
<p>在 <code>validate!</code>
方法中，它对口味参数进行校验，判断其是否属于预定义的几种类型之一，如果不符合，则打印帮助提示。</p>
<p>在 <code>run</code> 方法，定义制作茶饮的特定逻辑，注意内部会调用
<code>super</code> 以执行饮料制作的通用逻辑。 <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tea.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">BeverageMaker</span></span><br><span class="line">  <span class="comment"># This command uses an argument for the extra parameter, instead of</span></span><br><span class="line">  <span class="comment"># subcommands for each of the flavor.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Tea</span> &lt; <span class="title class_ inherited__">Command</span></span><br><span class="line">    <span class="variable language_">self</span>.summary = <span class="string">&#x27;Drink based on cured leaves&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.description = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">      An aromatic beverage commonly prepared by pouring boiling hot</span></span><br><span class="line"><span class="string">      water over cured leaves of the Camellia sinensis plant.</span></span><br><span class="line"><span class="string">      The following flavors are available: black, green, oolong, and white.</span></span><br><span class="line"><span class="string">    DESC</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.arguments = [</span><br><span class="line">      <span class="title class_">CLAide::Argument</span>.new(<span class="string">&#x27;FLAVOR&#x27;</span>, <span class="literal">true</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">self</span>.options</span><br><span class="line">      [[<span class="string">&#x27;--iced&#x27;</span>, <span class="string">&#x27;the ice-tea version&#x27;</span>]].concat(<span class="variable language_">super</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">argv</span>)</span><br><span class="line">      <span class="variable">@flavor</span> = argv.shift_argument</span><br><span class="line">      <span class="variable">@iced</span> = argv.flag?(<span class="string">&#x27;iced&#x27;</span>)</span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate!</span></span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@flavor</span>.<span class="literal">nil</span>?</span><br><span class="line">        help! <span class="string">&#x27;A flavor argument is required.&#x27;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">unless</span> <span class="string">%w(black green oolong white)</span>.<span class="keyword">include</span>?(<span class="variable">@flavor</span>)</span><br><span class="line">        help! <span class="string">&quot;`<span class="subst">#&#123;<span class="variable">@flavor</span>&#125;</span>&#x27; is not a valid flavor.&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span></span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">      puts <span class="string">&quot;* Infuse <span class="subst">#&#123;<span class="variable">@flavor</span>&#125;</span> tea…&quot;</span></span><br><span class="line">      sleep <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="variable">@iced</span></span><br><span class="line">        puts <span class="string">&#x27;* Cool off…&#x27;</span></span><br><span class="line">        sleep <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      puts <span class="string">&#x27;* Enjoy!&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h1 id="加载根命令">加载根命令</h1>
<p>在 <code>exe/beverage-maker</code> 中，我们通过
<code>require 'BeverageMaker'</code> 导入 gem，此时 Bundler 会请求同名的
<code>BeverageMaker.rb</code> 文件，而 <code>BeverageMaker.rb</code>
中并没有 <code>exe/beverage-maker</code> 所需的
<code>BeverageMaker::Command</code> 类。因此我们需要加载
<code>BeverageMaker::Command</code> 类，我们可以通过
<code>autoload</code> 方法加载，如下所示。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BeverageMaker.rb</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&quot;BeverageMaker/version&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">BeverageMaker</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Error</span> &lt; <span class="title class_ inherited__">StandardError</span>; <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># Your code goes here...</span></span><br><span class="line">  autoload <span class="symbol">:Command</span>, <span class="string">&#x27;BeverageMaker/command&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="调试">调试</h1>
<p>本文使用 RubyMine 进行开发，RubyMine
提供了一系列调试功能，我们可以选中 <code>exe/beverage-maker</code>
文件，右击选择【Debug 'beverage-maker'】，RubyMine 将自动以调试模式运行
<code>beverage-maker</code>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/beverage-maker-02.png?x-oss-process=image/resize,w_800" /></p>
<p>运行 <code>beverage-maker</code>
后，控制台将输出运行结果，如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/beverage-maker-03.png?x-oss-process=image/resize,w_800" /></p>
<p>由于 <code>beverage-maker</code>
是入口程序，我们可以修改其代码，传入不同的参数进行调试，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env ruby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;BeverageMaker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BeverageMaker::Command.run(ARGV)</span></span><br><span class="line"><span class="title class_">BeverageMaker</span><span class="symbol">:</span><span class="symbol">:Command</span>.run([<span class="string">&quot;tea&quot;</span>, <span class="string">&quot;oolong&quot;</span>, <span class="string">&quot;--iced&quot;</span>, <span class="string">&quot;--no-milk&quot;</span>])</span><br><span class="line">print<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="title class_">BeverageMaker</span><span class="symbol">:</span><span class="symbol">:Command</span>.run([<span class="string">&quot;coffee&quot;</span>, <span class="string">&quot;ca-phe-sua-da&quot;</span>, <span class="string">&quot;--sweetener=sugar&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>其调试运行结果如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/beverage-maker-04.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="构建">构建</h1>
<p>在调试通过后，我们可以对 gem 进行构建，构建命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rake build</span></span><br></pre></td></tr></table></figure></p>
<p>构建命令会根据 <code>BeverageMaker.gemspec</code> 生成一个对应版本的
gem，这里生成的是 <code>BeverageMaker-0.1.0.gem</code>，并存放在
<code>pkg</code> 目录下。</p>
<blockquote>
<p>注：也可以使用 <code>gem build BeverageMaker.gemspec</code>
进行构建。</p>
</blockquote>
<h1 id="安装">安装</h1>
<p>在构建生成 gem 后，我们可以对它进行安装，安装命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rake install</span></span><br></pre></td></tr></table></figure></p>
<p>安装命令默认将 gem 安装在当前使用的 ruby 版本的目录下，我当前的 ruby
版本是 <code>2.6.5</code>。对此，安装结果如下。</p>
<ul>
<li>可执行文件 <code>beverage-maker</code> 安装在
<code>~/.rvm/gems/ruby-2.6.5/bin/</code> 目录下</li>
<li>BeverageMaker gem 包安装在 <code>~/.rvm/gems/ruby-2.6.5/gems/</code>
目录下</li>
<li>BeverageMaker 的 gemspec 安装在
<code>~/.rvm/gems/ruby-2.6.5/specifications/</code> 目录下。</li>
</ul>
<blockquote>
<p>注：也可以使用 <code>gem install pkg/BeverageMaker-0.1.0.gem</code>
命令进行安装。</p>
</blockquote>
<p>安装完毕，我们就可以在控制台中使用 <code>beverage-maker</code>
命令行工具了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/beverage-maker-07.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="发布">发布</h1>
<p>一切就绪后，我们可以对 gem 进行发布，发布命令如下：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rake release</span></span><br></pre></td></tr></table></figure></p>
<p><code>rake release</code> 发布命令包含几个步骤：</p>
<ul>
<li>构建 gem，并存放至 <code>pkg</code> 目录下，准备推送至
Rubygems.org。</li>
<li>在当前的 commit 上打上 tag，指定为当前版本号。</li>
<li>将代码推送至远程的 git 仓库。</li>
</ul>
<p>执行结果如下所示： <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/beverage-maker-08.png?x-oss-process=image/resize,w_800" /></p>
<blockquote>
<p>注：也可以使用 <code>gem push pkg/BeverageMaker-0.1.0.gem</code>
命令进行发布。</p>
</blockquote>
<p>在发布前，我们需要注册一个 rubygems.org
的账户，否则发布命令会报错。</p>
<h1 id="总结">总结</h1>
<p>本文通过一个具体的需求，基于 CLAide 开发了一个 gem
命令行工具。在这个过程中，我们介绍了模板项目中各个文件的作用，了解了 gem
开发的一般步骤：开发、调试、构建、安装、发布。</p>
<p>另一方面，通过这样一个项目，我们大致也能够理解 cocoapods
的整个项目结构、设计理念。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://www.bundler.cn/v1.16/guides/creating_gem.html">How
to create a Ruby gem with Bundler</a></li>
<li><a href="https://github.com/CocoaPods/CLAide">CLAide</a></li>
<li><a
href="http://chuquan.me/2021/11/04/claide/">源码解析——CLAide</a></li>
<li><a
href="https://looseyi.github.io/post/sourcecode-cocoapods/03-cocoapods-claide/">CocoaPods
命令解析 - CLAide</a></li>
<li><a
href="https://stackoverflow.com/questions/20824049/rake-release-fail-using-gem-bundler">rake
release fail (using gem bundler)</a></li>
</ol>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>bundle</tag>
        <tag>gem</tag>
        <tag>rake</tag>
        <tag>rakefile</tag>
        <tag>gemspec</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Swift Package Manager 开发命令行工具？</title>
    <url>/2021/08/25/how-to-develop-command-line-tool-with-spm/</url>
    <content><![CDATA[<p>最近准备魔改一下 R.swift 以支持 Pod 库生成对应的
<code>R.generated.swift</code> 文件。经研究后发现，R.swift 的本质是使用
Swift Package Manager（简称 SPM） 开发了一个命令行工具
<code>rswift</code>。很显然，要想魔改 R.swift，必须要学习如何使用 Swift
Package Manager
来开发命令行工具。本文，则通过一个简单的例子来对此进行介绍。</p>
<span id="more"></span>
<h1 id="初始化">初始化</h1>
<p>假设，我们要开发一个命令行工具：<code>filecreator</code>，能够根据输入的文件名创建对应的文件。</p>
<p>首先，我们可以通过以下命令来创建并初始化项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> FileCreator</span><br><span class="line">$ <span class="built_in">cd</span> FileCreator</span><br><span class="line">$ swift package init --<span class="built_in">type</span> executable</span><br></pre></td></tr></table></figure>
<p>其中，<code>--type executable</code>
表示我们要创建的是一个可执行文件（本文创建一个命令行工具），而不是一个
framework。</p>
<p>当初始化完毕之后，项目目录下会生成一系列文件：</p>
<ul>
<li><code>Package.swift</code>：一个描述文件，定义了 Package
的基本信息以及依赖。</li>
<li><code>Sources/</code>：源码目录。初始化时会自动生成一个
<code>main.swift</code> 文件，即
<strong>命令行工具的入口</strong>。</li>
<li><code>Tests/</code>：测试目录，存放测试代码。</li>
<li><code>.gitignore</code>：默认忽略了 SPM 的编译目录
<code>.build</code> 以及 Xcode 项目相关文件。</li>
</ul>
<h1 id="代码拆分">代码拆分</h1>
<p>对于开发 SPM 可执行文件，一般建议将源代码拆分为两部分，分别用于创建
framework
和可执行文件。这样做不但可以让测试变得更加简单，而且可以让包含核心功能的
framework 作为其他工具的依赖库。</p>
<p>对此，我们可以在 <code>Sources</code> 目录下创建一个用于 framework
的目录，如下所示： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Sources</span><br><span class="line">$ <span class="built_in">mkdir</span> FileCreatorCore</span><br></pre></td></tr></table></figure></p>
<p>由于 SPM
使用文件系统作为编译参照，我们可以通过创建一个新的目录来定义一个新的模块。</p>
<p>接下来，更新 <code>Package.swift</code> 来定义两个 target：一个用于
<code>FileCreator</code>，一个用于
<code>FileCreatorCore</code>，如下所示： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> package = Package(</span><br><span class="line">    name: <span class="string">&quot;FileCreator&quot;</span>,</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">&quot;FileCreator&quot;</span>,</span><br><span class="line">            dependencies: [<span class="string">&quot;FileCreatorCore&quot;</span>]</span><br><span class="line">        ),</span><br><span class="line">        .target(name: <span class="string">&quot;FileCreatorCore&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>其中，描述文件中定义了 <code>FileCreator</code> 依赖
<code>FileCreatorCore</code>。</p>
<h1 id="基于-xcode-开发">基于 Xcode 开发</h1>
<p>由于 Xcode 支持代码补全、调试、运行等功能，开发者会倾向于使用 Xcode
进行开发。对此，SPM 提供了一条命令可以让我们快速生成一个 xcode
项目。与之对应，<code>.gitignore</code> 文件也默认忽略了相关的 xcode
文件。</p>
<p>在项目的根目录下，我们可以通过如下命令生成 Xcode 项目。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">$ swift package generate<span class="operator">-</span>xcodeproj</span><br></pre></td></tr></table></figure></p>
<h1 id="程序入口">程序入口</h1>
<p>我们知道在 c 语言开发中所有程序都有一个 <code>main</code>
入口函数。这里，虽然没有定义 <code>main</code> 函数，但是定义了一个
<code>main.swift</code> 文件（因此我们不能修改 <code>main.swift</code>
的文件名）。一般而言，我们建议将核心实现逻辑放在单独一个文件中，而核心调用逻辑则放在
<code>main.swift</code> 中。</p>
<p>对此，我们在 <code>Sources/FileCreatorCore</code>
目录下创建一个核心实现文件 <code>FileCreatorCore.swift</code>。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sources/FileCreatorCore/FileCreatorCore.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FileCreator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> arguments: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">arguments</span>: [<span class="type">String</span>] <span class="operator">=</span> <span class="type">CommandLine</span>.arguments) &#123; </span><br><span class="line">        <span class="keyword">self</span>.arguments <span class="operator">=</span> arguments</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">run</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，在 <code>main.swift</code> 中调用 <code>run()</code> 方法。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FileCreatorCore</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tool <span class="operator">=</span> <span class="type">FileCreator</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> tool.run()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Whoops! An error occurred: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="编译运行">编译运行</h1>
<p>接下来，我们来对项目进行编译并运行，命令分别如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build</span><br><span class="line">$ swift run</span><br><span class="line">&gt; Hello world</span><br></pre></td></tr></table></figure></p>
<h1 id="添加依赖">添加依赖</h1>
<p>和 iOS 开发一样，我们开发 swift package 时也会依赖第三方的 swift
package 或 framework。依赖关系则定义在 <code>Package.swift</code>
中，如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PackageDescription</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> package <span class="operator">=</span> <span class="type">Package</span>(</span><br><span class="line">    name: <span class="string">&quot;FileCreator&quot;</span>,</span><br><span class="line">    dependencies: [</span><br><span class="line">        .package(</span><br><span class="line">            name: <span class="string">&quot;Files&quot;</span>,</span><br><span class="line">            url: <span class="string">&quot;https://github.com/johnsundell/files.git&quot;</span>,</span><br><span class="line">            from: <span class="string">&quot;4.0.0&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">    targets: [</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">&quot;FileCreator&quot;</span>,</span><br><span class="line">            dependencies: [<span class="string">&quot;FileCreatorCore&quot;</span>]</span><br><span class="line">        ),</span><br><span class="line">        .target(</span><br><span class="line">            name: <span class="string">&quot;FileCreatorCore&quot;</span>,</span><br><span class="line">            dependencies: [<span class="string">&quot;Files&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>Files</code> 是一个基于 swift
编写的第三方框架，支持简单的处理文件和目录。我们在
<code>fileCreator</code> 中使用 <code>Files</code>
实现在当前目录下创建文件。</p>
<h1 id="安装依赖">安装依赖</h1>
<p>当声明的依赖发生变化后，我们可以使用 SPM
来解析并安装依赖，然后重新生成 Xcode 项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift package update</span><br><span class="line">$ swift package generate-xcodeproj</span><br></pre></td></tr></table></figure>
<p>安装完依赖后，会生成一个 <code>Package.resolved</code> 文件，这是 SPM
生成的锁存文件，记录了依赖更新后的全版本列表。</p>
<h1 id="读取参数">读取参数</h1>
<p>接下来，我们来修改
<code>Sources/FileCreatorCore/FileCreator.swift</code>，替换掉
<code>print "Hello world"</code>，实现通过传入参数创建文件的功能。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Files</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FileCreator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> arguments: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">arguments</span>: [<span class="type">String</span>] <span class="operator">=</span> <span class="type">CommandLine</span>.arguments) &#123; </span><br><span class="line">        <span class="keyword">self</span>.arguments <span class="operator">=</span> arguments</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">run</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> arguments.count <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.missingFileName</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fileName <span class="operator">=</span> arguments[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="type">Folder</span>.current.createFile(at: fileName)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">Error</span>.failedToCreateFile</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">FileCreator</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Error</span>: <span class="title class_">Swift</span>.<span class="title class_">Error</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> missingFileName</span><br><span class="line">        <span class="keyword">case</span> failedToCreateFile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试">测试</h1>
<p>由于之前我们将命令行工具的实现才分为了两部分：framework
和可执行文件，因此，测试也变得非常简单。我们要做的仅仅是运行并断言创建了相应的文件即可。</p>
<p>首先，我们在 <code>Package.swift</code>
中声明一个测试模块，如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.testTarget(</span><br><span class="line">    name: <span class="string">&quot;FileCreatorTests&quot;</span>,</span><br><span class="line">    dependencies: [<span class="string">&quot;FileCreatorCore&quot;</span>, <span class="string">&quot;Files&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后，重新生成 Xcode 项目。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift package generate-xcodeproj</span><br></pre></td></tr></table></figure></p>
<p>重新使用 Xcode 打开项目，修改 <code>FileCreatorTests.swift</code>。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="keyword">import</span> Files</span><br><span class="line"><span class="keyword">import</span> FileCreatorCore</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileCreatorTests</span>: <span class="title class_">XCTestCase</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">testCreatingFile</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="comment">// Setup a temp test folder that can be used as a sandbox</span></span><br><span class="line">        <span class="keyword">let</span> tempFolder <span class="operator">=</span> <span class="type">Folder</span>.temporary</span><br><span class="line">        <span class="keyword">let</span> testFolder <span class="operator">=</span> <span class="keyword">try</span> tempFolder.createSubfolderIfNeeded(</span><br><span class="line">            withName: <span class="string">&quot;FileCreatorTests&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Empty the test folder to ensure a clean state</span></span><br><span class="line">        <span class="keyword">try</span> testFolder.empty()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the temp folder the current working folder</span></span><br><span class="line">        <span class="keyword">let</span> fileManager <span class="operator">=</span> <span class="type">FileManager</span>.default</span><br><span class="line">        fileManager.changeCurrentDirectoryPath(testFolder.path)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an instance of the command line tool</span></span><br><span class="line">        <span class="keyword">let</span> arguments <span class="operator">=</span> [testFolder.path, <span class="string">&quot;Hello.swift&quot;</span>]</span><br><span class="line">        <span class="keyword">let</span> tool <span class="operator">=</span> <span class="type">FileCreator</span>(arguments: arguments)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the tool and assert that the file was created</span></span><br><span class="line">        <span class="keyword">try</span> tool.run()</span><br><span class="line">        <span class="type">XCTAssertNotNil</span>(<span class="keyword">try?</span> testFolder.file(named: <span class="string">&quot;Hello.swift&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，执行 <code>swift test</code> 即可进行测试。</p>
<h1 id="安装命令行工具">安装命令行工具</h1>
<p>截止现在，我们已经构建并测试了我们的命令行工具，接下来我们来安装它，使得能够在命令行进行全局调用。对此，我们需要使用
release 配置进行构建，然后将编译产出的二进制放到
<code>/usr/local/bin</code> 目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ swift build -c release</span><br><span class="line">$ <span class="built_in">cd</span> .build/release</span><br><span class="line">$ <span class="built_in">cp</span> FileCreator /usr/local/bin/filecreator</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/mac-cain13/R.swift">R.swift</a></li>
<li><a href="https://www.jianshu.com/p/d05884810956">swiftc:
强大的命令行工具</a></li>
<li><a
href="https://www.swiftbysundell.com/articles/building-a-command-line-tool-using-the-swift-package-manager/">Building
a command line tool using the Swift Package Manager</a></li>
<li><a href="https://jblevins.org/log/swift">Scripting and Compiling
Swift on the Command Line</a></li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift Package Manager</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地管理你的 shell 脚本？</title>
    <url>/2021/04/05/how-to-manage-your-shell-scripts-gracefully/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/nox/nox-logo.png" /></p>
<span id="more"></span>
<p>几乎所有的程序员都或多或少接触过 shell 脚本，在 shell
脚本的使用过程中，我们会遇到一些痛点，比如：执行方式、使用方法等。</p>
<p>本文，我们将简要分析一下这些痛点，并最终给出一种优雅的解决方式。</p>
<h1 id="执行方式">执行方式</h1>
<p>一般我们执行脚本的方式主要分为两种：</p>
<ul>
<li>路径调用，如：<code>./path/to/script.sh</code>、<code>sh ./path/to/script.sh</code></li>
<li>全局调用，如：将 shell 脚本代码直接写入 <code>~/.zshrc</code> 或使用
<code>alias</code> 指定具体的脚本路径，从而实现全局调用。</li>
</ul>
<p>不过，这两种方式显然不够优雅，下面我们来具体分析一下。</p>
<h2 id="路径调用">路径调用</h2>
<p>绝大多数人都会采用这种方式来执行脚本。路径调用的优点是操作简单易懂；但是缺点也很明显——我们需要提前知道每个脚本在文件系统中的位置。</p>
<p>在交叉调用的场景下，通过相对路径很难进行操作，只能通过绝对路径来进行调用。比如：在
<code>~/chuquan/Develop/A/</code> 目录下调用
<code>~/chuquan/Github/B/script.sh</code>
时，只能通过绝对路径进行调用。</p>
<h2 id="全局调用">全局调用</h2>
<p>为了解决路径调用的所存在的问题，有些人可能会采用以下几种方式来解决。</p>
<p>第一种方式是：<strong>将 shell 脚本的代码写入 shell 配置文件中，如：
<code>~/.zshrc</code></strong>。比如，将下面的函数加到
<code>~/.zshrc</code> 末尾，然后执行 <code>source ~/.zshrc</code>
或重启终端后，我们就能进行全局调用 <code>chuquan</code> 这段 shell
脚本。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ~/.zshrc 的末尾</span><br><span class="line">func chuquan() &#123;</span><br><span class="line">    echo &quot;Hello, CHUQUAN&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局调用 chuquan</span><br><span class="line">$ chuquan</span><br><span class="line">Hello, CHUQUAN</span><br></pre></td></tr></table></figure>
<p>上述方式的原理是：在终端启动时，系统会根据其所指定的 shell
加载对应的配置文件。如果默认 shell 是 zsh，那么会加载
<code>~/.zshrc</code> 配置文件。我们在 <code>~/.zshrc</code> 中写入
shell 函数会成为全局函数，从而实现 shell 脚本的全局调用。</p>
<p>这种方式的主要缺点在于：</p>
<ul>
<li><code>~/.zshrc</code>
中不能存在同名的脚本函数，如果存在，后者会覆盖前者。</li>
<li>如果脚本代码特别多，会导致 <code>~/.zshrc</code> 文件变大，最终
shell 启动时加载 <code>~/.zshrc</code> 的时间也会相应变长。</li>
</ul>
<p>第二种方式是：<strong>使用 alias
针对每一个脚本及其绝对路径，定义一个别名</strong>。比如，通过
<code>alias</code> 命令为 <code>~/chuquan/hello.sh</code> 指定一个别名
<code>hello</code>，从而实现全局调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ alias hello=~/chuquan/hello.sh</span><br></pre></td></tr></table></figure>
<p>这种方式可以解决第一种方式的缺点。当时它并不够优雅，如果脚本非常多，对应的别名也会非常多，对于用户而言，我们真的都能记住吗？</p>
<h1 id="使用方法">使用方法</h1>
<p>关于使用方法，我们经常会遇到这样的情况：当别人写了一个非常牛逼的脚本后，我们想要使用它时却并不清楚其确切的作用，甚至不知道它执行时需要哪些参数。在这种情况下，我们经常会与一些可以提升工作效率的脚本工具失之交臂。对此，最好的解决方式就是脚本的作者在脚本中给出使用提示、参数提示。</p>
<h1 id="nox">NOX</h1>
<p>为了解决上述的问题，我写了一个基于 zsh 的脚本管理工具——<a
href="https://github.com/baochuquan/nox">NOX</a>。</p>
<p>NOX 主要有一下这些特点：</p>
<ul>
<li><strong>系统调用</strong>：NOX 实现了一个唯一的主命令
<code>nox</code>，并将用户脚本的存放路径和脚本名称转换为子命令，从而实现全局调用。比如：通过
<code>nox poker ace</code> 命令来调用 <code>scripts/poker/ace.sh</code>
脚本。</li>
<li><strong>自动补全</strong>：如果说用户手动输入类似
<code>nox poker ace</code> 这样的命令会很费时，那么 NOX
也实现了一种优雅的解决方案——<strong>支持 Tab 自动补全</strong>。通过 Tab
自动补全，从而加速命令的索引和调用。</li>
<li><strong>帮助选项</strong>：为了解决用户不知道脚本如何使用的问题，NOX
提供的 <code>nox system create</code>
命令可以为开发者快速创建一个默认支持 <code>--help</code>（或
<code>-h</code>）
选项的脚本模板。脚本开发者只需要修改脚本模板中关于脚本使用用法的描述即可。</li>
<li><strong>调试模式</strong>：为了方便用户进行脚本调试，NOX
在脚本模板中默认支持了 <code>--debug</code>（或
<code>-x</code>）选项，可以轻松将脚本执行模式切换至调试模式。</li>
<li><strong>私有命令</strong>：NOX
可以作为一个开发团队的工具箱，同时为了支持私有命令，NOX 默认不会将以
<code>_</code> 为前缀的目录或脚本名称加入 git 管理。</li>
</ul>
<h2 id="使用示例">使用示例</h2>
<p>下图所示是一个通过 NOX 调用 <code>scripts/poker/ace.sh</code>
脚本的示例。示例中使用 <code>nox poker ace --count 10</code>
命令，期间结合 tab 自动补全进行快速索引，最终调用
<code>scripts/poker/ace.sh</code> 脚本，并传入脚本选项
<code>--count</code> 和参数 <code>10</code>。</p>
<p>是不是很酷炫？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/nox/nox-poker-ace-demo.gif" /></p>
<h2 id="系统命令">系统命令</h2>
<p>NOX 的本质是一个脚本管理工具，它的目标还是为脚本服务。为此，NOX
提供了 3 个内置的系统命令供用户进行使用，分别如下：</p>
<ul>
<li><code>nox system create</code>：用于创建符合规范的目录或脚本</li>
<li><code>nox system build</code>：用于编译自动补全逻辑</li>
<li><code>nox system update</code>：用于更新系统功能</li>
</ul>
<h3 id="nox-system-create"><code>nox system create</code></h3>
<p>NOX 提供了
<code>nox system create</code>，该命令能够创建一个符合规范的模板目录或模板脚本，具体使用选项进行区分。</p>
<ul>
<li><code>nox system create --dir &lt;dirname&gt;</code>：可以创建一个脚本目录，默认会在该目录下创建一个
<code>.description</code> 文件，用于描述该目录分类下的脚本的功能。</li>
<li><code>nox system create --script &lt;script-name-without-suffix&gt;</code>：可以创建一个模板脚本，该脚本默认符合
NOX 开发规范，用户只需要修改对该脚本进行定制修改即可。</li>
</ul>
<h3 id="nox-system-build"><code>nox system build</code></h3>
<p>自动补全功能的核心是一个描述自动补全逻辑的自动补全文件，对此，NOX
提供了一个命令 <code>nox system build</code>
以供编译生成对应的自动补全文件。该命令会生成一个 <code>_nox</code>
文件，并存放在 <code>fpath/</code> 目录下。</p>
<p>当我们创建一个目录或脚本后，需要执行 <code>nox system build</code>
命令，从而生成一个新的自动补全文件。然后，我们需要执行
<code>source ~/.zshrc</code> 或重启终端以更新自动补全逻辑。</p>
<h3 id="nox-system-update"><code>nox system update</code></h3>
<p>NOX
可用于团队协作，当其他开发者贡献了一些新的脚本后，我们可以通过执行
<code>nox system update</code> 来更新 NOX 仓库，从而享受最新的功能。</p>
<h2 id="开发指南">开发指南</h2>
<p>NOX
能够将自己编写的脚本转换成系统命令，这是一个非常酷炫的特点，此时的你想必也跃跃欲试。这里有一个简单的例子，详细介绍了如何开发一个符合
NOX 规范的脚本，详见 <a
href="https://github.com/baochuquan/nox/blob/main/docs/how-to-add-commands-to-nox.md">传送门</a>。</p>
<h1 id="总结">总结</h1>
<p>NOX 提供了一种优雅地管理 shell 脚本的解决方案，它将 shell
脚本转换成了系统命令，并提供了强大的自动补全功能。欢迎大家来安装、使用并提出修改意见~</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/baochuquan/nox">nox</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>zsh</tag>
        <tag>自动补全</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个 zsh 补全脚本</title>
    <url>/2020/11/28/how-to-write-a-zsh-completion-script/</url>
    <content><![CDATA[<p>本文对 zsh
补全系统进行了简单的介绍，然后分析了一个完整的示例，该示例可以作为一个新的补全脚本的起点。剩余内容对示例补全脚本进行了简要的分析和介绍。</p>
<span id="more"></span>
<h1 id="zsh-completion-system">zsh completion system</h1>
<p>zsh completion system（<code>compsys</code>）是 zsh
的重要组成部分，当我们在 shell 中输入命令时可以通过制表符（tab
键）进行补全。我们可以在此处找到完整的<a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">文档</a>，也可以查看<a
href="https://github.com/zsh-users/zsh/blob/master/Completion/Base/Core/_main_complete">源代码</a>。这里，<code>_main_complete</code>
函数非常关键，由于它比较冗长，这里我会简单进行介绍一下。</p>
<blockquote>
<p>补全系统需要激活。如果你使用了
<code>oh-my-zsh</code>，那么它已经被激活了，否则需要在
<code>~/.zshrc</code> 中增加以下代码来进行激活。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autoload -U compinit  </span><br><span class="line">compinit  </span><br></pre></td></tr></table></figure>
<p>当我们在 shell 中输入 <code>foobar &lt;tab&gt;</code> 时，zsh
会调用针对 <code>foobar</code> 的补全函数。补全函数通过调用一系列
compsys 内建函数来为 zsh 提供了补全项。</p>
<p>补全函数可以通过直接调用 <code>compdef</code>
函数来手动进行注册，如：<code>compdef &lt;function-name&gt; &lt;program&gt;</code>。更为常规方法是将补全函数定义在一个独立的文件（也称
<strong>补全脚本</strong>）中。按照惯例，定义了补全函数的文件的命名通常是以下划线
"_" 为前缀，拼接目标程序的名称。当通过 <code>compinit</code>
初始化补全系统时，zsh 会查找 <code>fpath</code>
变量指定路径下的所有文件，并读取第一行。因此，我们只需要将补全脚本放在
<code>fpath</code>
变量所指定的路径下即可，当然，还需要确保文件的第一行包含了
<code>compdef</code> 命令，如：<code>#compdef _foobar foobar</code>.</p>
<blockquote>
<p><code>fpath</code> 变量类似于 <code>PATH</code>
变量，指定了一系列的路径。zsh 根据 <code>fpath</code>
来查找函数。我们可以通过 <code>echo $fpath</code> 来查找
<code>fpath</code> 变量所指定的值。如果想要新增一个路径，只需要重新设置
<code>fpath</code>
变量即可，如：<code>fpath=($fpath &lt;path-to-folder&gt;)</code></p>
</blockquote>
<h1 id="补全脚本示例">补全脚本示例</h1>
<p>假设我们有一个程序 <code>hello</code>，其调用接口如下所示：
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello -h | --help</span><br><span class="line">hello quietly [--slient] &lt;message&gt;</span><br><span class="line">hello loudly [--repeat=&lt;number&gt;] &lt;message&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>hello</code> 有两个子命令 <code>quietly</code> 和
<code>loudly</code>，两者各自有着不同的参数。理想情况下，当没有提供任何命令时，我们希望补全脚本能够补全
<code>-h</code>，<code>--help</code>，<code>quietly</code>，<code>loudly</code>。一旦输入
<code>quietly</code> 或
<code>loudly</code>，补全脚本会根据上下文提供特定的补全项。</p>
<p>如下所示的补全脚本实现了上述的补全功能。本文的其余部分，我将对该补全脚本进行解释，并深入探讨其他一些内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#compdef _hello hello</span><br><span class="line"></span><br><span class="line">function _hello &#123;</span><br><span class="line">    local line</span><br><span class="line"></span><br><span class="line">    _arguments -C \</span><br><span class="line">        &quot;-h[Show help information]&quot; \</span><br><span class="line">        &quot;--h[Show help information]&quot; \</span><br><span class="line">        &quot;1: :(quietly loudly)&quot; \</span><br><span class="line">        &quot;*::arg:-&gt;args&quot;</span><br><span class="line"></span><br><span class="line">    case $line[1] in</span><br><span class="line">        loudly)</span><br><span class="line">            _hello_loudly</span><br><span class="line">        ;;</span><br><span class="line">        quietly)</span><br><span class="line">            _hello_quietly</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _hello_quietly &#123;</span><br><span class="line">    _arguments \</span><br><span class="line">        &quot;--silent[Dont output anything]&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _hello_loudly &#123;</span><br><span class="line">    _arguments \</span><br><span class="line">        &quot;--repeat=[Repat the &lt;message&gt; any number of times]&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有几个需要注意的地方，特别是传递给 <code>_arguments</code>
函数的参数，以及 <code>local</code>
的使用。不过，让我们先来看一下补全脚本的整体结构。</p>
<h2 id="整体结构">整体结构</h2>
<p>事实上，zsh 补全脚本并没有什么特别的。它只不过是一个使用了
<code>#compdef &lt;function&gt; &lt;program&gt;</code>
命令来将自己注册给 <code>program</code> 的普通 zsh
脚本，因此我们可以自由选择合适的脚本结构，不过我发现以下的结构很有帮助。</p>
<p>定义一个函数，并将其命名为
<code>_&lt;program&gt;</code>，提供默认的补全项。对于每一个子命令，为其定义一个
<code>_&lt;program&gt;_&lt;sub-command&gt;</code>
函数，提供子命令的补全项。以我的实践经验来看，这样写会非常直观。</p>
<h2 id="arguments-的使用"><code>_arguments</code> 的使用</h2>
<p>脚本通过调用 <code>_arguments</code> 函数来向 zsh
提供可能的补全项。当然，zsh 还提供了很多其他函数可以达到该目的。<a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">查看更多</a>。</p>
<p>在上述这个例子中，关于 <code>_arguments</code>
函数的使用，有两个有趣的地方。字符串参数被称为
<code>specs</code>，当我们第一次用时会觉得有点捉摸不透——在 zsh
中我们没有太多抽象方式，因此所有有点复杂的内容都在字符串中进行编码，这使得我们能够在更小的范围内学习这种
DSL。在上述这个例子中，<code>specs</code> 使用了两种形式：</p>
<ul>
<li>option specs：<code>OPT[DESCRIPTION]:MESSAGE:ACTION</code></li>
<li>command specs：<code>N:MESSAGE:ACTION</code>。<code>N</code> 表示第
N 个参数。</li>
</ul>
<p><code>ACTION</code> 部分还是其自己的 DSL。在<a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">官方文档</a>中搜索
<code>specs: overview</code> 可以查看有全部的内容。</p>
<p><code>-C</code> 标志位和 spec 为 "<code>*::arg:-&gt;args</code>" 的
<code>ACTION</code> 进行组合也很有趣。下面是文档中关于 <code>-C</code>
标志位的描述：</p>
<blockquote>
<p>在这种格式中，<code>_arguments</code>
处理参数和选项，用参数更新状态以表示处理完毕，然后返回控制流返回给调用者（函数）；然后，调用者自行生成补全项。</p>
</blockquote>
<p>这里面涉及到的参数包括： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local context state state_descr line</span><br><span class="line">typeset -A opt_args</span><br></pre></td></tr></table></figure></p>
<p>我们可以认为是 <code>_arguments</code>
函数放回了多个值——事实上，<code>_arguments</code>
函数只是修改了全局变量，但由于使用了 <code>typeset -A</code> 和局部变量
<code>local</code>，因此只是在当前作用域中进行了修改。<code>typeset</code>
的 <code>-A</code> 选项告诉 zsh 参数是一个关联数组。</p>
<p>因此，<code>-C</code>
标志位使得我们能够检查补全状态，并根据用户提供特定于上下文的补全项。在上述这个例子中，我们使用
<code>switch</code> 语句来匹配 <code>line</code>
变量输入的子命令，然后调用对应的补全函数来为子命令提供补全项。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://mads-hartmann.com/2017/08/06/writing-zsh-completion-scripts.html">Writing
zsh completion scripts</a></li>
<li><a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">Completion
System</a></li>
<li><a
href="https://github.com/zsh-users/zsh/blob/master/Completion/Base/Core/_main_complete">_main_complete</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>zsh</tag>
        <tag>补全脚本</tag>
        <tag>补全系统</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS原理</title>
    <url>/2017/01/08/https-principle/</url>
    <content><![CDATA[<h1 id="https概述">HTTPS概述</h1>
<p>在互联网领域，安全永远是一个重点关注的方向。现阶段HTTPS的安全指数显然要比HTTP高很多，前者也是互联网发展的必然趋势。为了鼓励全球网站的HTTPS实现，Google甚至调整了其搜索引擎算法，提升HTTPS网站的搜索排名。<br />
那HTTPS和HTTP到底有什么区别呢？简单而言，HTTPS可以认为是HTTP+TLS/SSL。</p>
<span id="more"></span>
<h1 id="ssltls">SSL/TLS</h1>
<h2 id="作用">作用</h2>
<p>我们都知道不使用SSL/TLS的HTTP通信，即不加密的通信。其具有以下几个潜在的风险：<br />
&gt; (1)
<strong>窃听风险</strong>（eavesdropping）：第三方可获知通信内容。<br />
&gt; (2)
<strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。<br />
&gt; (3)
<strong>冒充风险</strong>（pretending）：第三方可以冒充他人进行通信。</p>
<p>而SSL/TLS的作用就是解决上述几个潜在的风险： &gt; (1)
所有信息都是<strong>加密传播</strong>，第三方无法窃听。<br />
&gt; (2)
具备<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。<br />
&gt; (3) 配备<strong>身份整数</strong>，防止身份被冒充。</p>
<h2 id="历史">历史</h2>
<p>互联网加密通信协议的历史，几乎与互联网的历史一样长。<br />
&gt; 1994年，NetScape公司设计了SSL协议（Secure Socket
Layer）的1.0版本，但是未发布。 &gt; 1995年，NetScape公司发布SSL
2.0版，很快发现有严重漏洞。<br />
&gt; 1996年，SSL 3.0版本问世，得到大规模应用。<br />
&gt; 1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版<a
href="https://en.wikipedia.org/wiki/Secure_Sockets_Layer">TLS</a>
1.0版本。<br />
&gt; 2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版本和TLS
1.2版本。最新的变动是2011年TLS 1.2的<a
href="https://tools.ietf.org/html/rfc6176">修订版</a></p>
<p>目前，应用最广泛的是TLS 1.0，然后是SSL
3.0。不过，主流浏览器都已经实现了对TLS 1.2的支持。<br />
通常，TLS 1.0会被标示为SSL 3.1，TLS 1.1会被标示为TLS 1.2会被标示为SSL
3.3。</p>
<h2 id="原理">原理</h2>
<p>SSL/TLS协议的基本思路是采用<a
href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，即：客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，使用私钥解密。<br />
而这个过程中需要解决两个问题：</p>
<ol type="1">
<li>如何保证公钥不被篡改？<br />
</li>
</ol>
<ul>
<li><strong>解决方法</strong>：将公钥放在<a
href="https://en.wikipedia.org/wiki/Public_key_certificate">数字证书</a>中。只要证书是可信的，公钥就是可信的。</li>
</ul>
<ol start="2" type="1">
<li>公钥加密法作为一种非对称加密算法，计算量比对称加密算法大很多，如何减少耗费时间？<br />
</li>
</ol>
<ul>
<li><strong>解决方法</strong>：每次会话（session），客户端和服务器端都生成一个"<strong>会话密钥</strong>"（session
key），用它来加密信息。这里，客户端仅用公钥加密"会话密钥"，而通信过程中的大量信息则用"会话密钥"来加密，由于大量使用对称加密算法，所以可以大幅减少加密运算的时间。</li>
</ul>
<p>因此，SSL/TLS协议的基本过程如下：<br />
&gt; (1) 客户端向服务器索取并验证公钥。<br />
&gt; (2) 双方协商生成"会话密钥"。<br />
&gt; (3) 双方采用"会话密钥"进行加密通信。</p>
<p>其中，(1)(2)又称为"<strong>握手阶段</strong>"（handshake）。</p>
<h2 id="握手阶段">握手阶段</h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/SSL-TLS-handshake.png" />
</div>
<p>如上图所示，"握手阶段"包含<strong>4次通信</strong>。而"握手阶段"的所用通信都是<strong>明文</strong>的。<br />
下面分别介绍"握手阶段"的4次通信过程。</p>
<h3 id="客户端发出请求clienthello">客户端发出请求(ClientHello)</h3>
<p><strong>ClientHello请求</strong>:
客户端（通常是浏览器）先向服务器发出加密通信的请求。<br />
在这一步，客户端主要向服务器提供以下信息：<br />
&gt; (1) 支持的协议版本，如TLS 1.0版本。<br />
&gt; (2) 一个客户端生成的随机数，稍后用于生成"会话密钥"。<br />
&gt; (3) 支持的加密方法，如RSA公钥加密。<br />
&gt; (4) 支持的压缩方法。</p>
<p>需要注意的是，客户端发送的信息之中不包括服务器的域名。即理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>但是，这对于虚拟主机用户来说，极为不便。为此，2006年，TLS协议加入了一个<a
href="https://tools.ietf.org/html/rfc4366">Server Name
Indication扩展</a>，允许客户端向服务器提供它所请求的域名。</p>
<h3 id="服务器回应serverhello">服务器回应(ServerHello)</h3>
<p><strong>ServerHello</strong>:
服务器收到客户端请求后，向客户端发出回应。<br />
在这一步，服务器端的回应包含以下内容：<br />
&gt; (1) 确认使用的加密通信协议版本，比如TLS
1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br />
&gt; (2) 一个服务器生成的随机数，稍后用于生成"会话密钥"。<br />
&gt; (3) 确认使用的加密方法，如RSA公钥加密。<br />
&gt; (4) 服务器证书。</p>
<p>除了以上信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h3 id="客户端回应">客户端回应</h3>
<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。<br />
&gt; (1) 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br />
&gt; (2)
编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br />
&gt; (3)
客户端握手结束通知，表示客户端的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。</p>
<p>此过程中出现的随机数是整个握手阶段出现的第三个随机数，又称"<strong>premaster
secret</strong>"。经过这个过程之后，服务器端和客户端就同时拥有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"<strong>会话密钥</strong>"。</p>
<p>但是为什么一定要用三个随机数来生成"会话密钥"呢？CSDN的<a
href="http://blog.csdn.net/dog250/article/details/5717162">dog250</a>给出如下解释：<br />
&gt;
"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入随机因素来保证协商出来的密钥的随机性。<br />
&gt; 对于RSA密钥交换算法来说，premaster
secret本身就是一个随机数，再加上hello消息中的随机数，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br />
&gt; Premaster
secret的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么premaster
secret就有可能被才出来，那么仅适用premaster
secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上premaster
secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机数可能完全不随机，可是三个伪随机数就十分接近随机了。"</p>
<p>此外，如果前一步，服务器要求客户端提供证书，客户端会在这一步发送证书及其相关信息。</p>
<h3 id="服务器回应">服务器回应</h3>
<p>服务器收到客户端的第三个随机数premaster
secret之后，计算本次会话所需的"会话密钥"。<br />
然后，向客户端发送以下信息：<br />
&gt; (1)
编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br />
&gt; (2)
服务器握手结束通知，表示服务器的握手阶段已经结束。本项的值为前面发送的所有内容的hash值，用于服务器校验，以防被篡改。</p>
<p>至此，整个握手阶段全部结束。
接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。</p>
<h2 id="数字签名和数字证书">数字签名和数字证书</h2>
<p>我们回顾一下SSL/TLS握手阶段的整个过程的一些关键点，来看看其中是否还有潜在的风险。<br />
&gt; (1) 客户端产生一个随机数A，以明文方式发给服务器。<br />
&gt; (2)
服务器产生一个随机数B，以明文方式发给客户端。此外，服务器还将公钥放入证书中发送给客户端。<br />
&gt; (3)
此时客户端拥有随机数A，B以及证书（公钥）。服务器拥有随机数A，B以及其私钥。<br />
&gt; (4)
客户端产生一个随机数C，使用公钥加密，发送给服务器，服务器以私钥解密，得到随机数C。此过程使用公钥加密法（非对称加密）。<br />
&gt; (5)
此时客户端和服务器使用三个随机数A，B，C，生成相同的成对的"会话密钥"。<br />
&gt; (6)
此后，客户端和服务器端进行通信采用"会话密钥"进行加密通信（对称加密），可以减少加解密时间，提高通信速度。</p>
<p>那么问题来了，步骤(2)中的证书是如何防止被窃听和篡改的呢？这个过程中似乎没有采用任何算法对其进行加密保护。我们知道随机数A，B作为明文可以被窃听，而如果证书也被篡改，恶意的第三方甚至就可以向用户提供自己的证书（公钥），将自己伪装成客户端想要通信的对象。最终可以获取用户的信息，达到其进一步的目的。</p>
<p>因此，客户端需要一种机制来确认其请求的服务器是否伪造的。而数字证书就像身份证一样可以证明服务器的真伪。</p>
<h3 id="数字证书">数字证书</h3>
<p>数字证书由专门的机构"<strong>证书中心</strong>"（Certificate
authority，简称CA）颁发。证书中心用自己的私钥，将服务器的公钥及其相关信息进行加密，生成"<strong>数字证书</strong>"（Digital
Certificate）。</p>
客户端（浏览器）的"<strong>证书管理器</strong>"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-list.png" />
</div>
如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-warning.png" />
</div>
如果这张数字证书不是由受信任的机构颁发，浏览器会发出另一种警告。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-confirm.jpg" />
</div>
<p>如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，从而进行后续的通信加密相关操作。</p>
<h3 id="数字签名">数字签名</h3>
<p>除了数字证书以外，我们经常还能看到的"<strong>数字签名</strong>"（Digital
signature）又是什么呢？</p>
<p>数字签名是将公钥密码反过来使用。签名者将信息用私钥加密（这是一种反用，因为通常私钥是用于解密）；验证者使用公钥解密信息。也就是说，客户端向服务器端发送消息是一种正向的公钥加密法（公钥加密，私钥解密）；而服务器端向客户端发送消息则是一种公钥加密法的反向实现（私钥加密，公钥解密）。</p>
数字签名的目的是为了防止通信内容被修改。<br />
通信过程中，信息发送方对通信内容进行hash，并将产生hash值作为通信内容的摘要（digest）。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/hash-digest.png" />
</div>
然后，使用私钥将摘要进行加密，得到数字签名。而接收端使用公钥即可解密得到摘要。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/digest-signature.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/signature-digest.png" />
</div>
最终，客户端将通信内容进行hash，并与解密后得到的摘要进行比对，如果一致则表示内容未被篡改。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/digest-compare.png" />
</div>
<p>（完）</p>
<p>参考 [1] <a
href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a><br />
[2] <a
href="http://blog.csdn.net/dog250/article/details/5717162">SSL协议中的DH算法的pre-master-secret</a><br />
[3] <a
href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a><br />
[4] <a
href="https://zh.wikipedia.org/zh-hans/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0">数字签名</a><br />
[5] <a
href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">图解SSL/TLS</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 泛型底层实现原理</title>
    <url>/2020/04/20/implementing-swift-generic/</url>
    <content><![CDATA[<p>在《Swift 性能优化(2)——协议与泛型的实现》中我们介绍了 Swift
是如何管理协议类型与泛型类型的生命周期与方法调用。本文我们将进一步介绍
Swift 泛型的底层实现原理。</p>
<span id="more"></span>
<h1 id="回顾">回顾</h1>
<p>协议类型在内存中的存储形式是 Existential Container，Existential
Container 占 5 个内存单元（也称 <strong>词</strong>），其作用如下：</p>
<ul>
<li>3 个词作为 <strong>Value Buffer</strong>。</li>
<li>1 个词作为 <strong>Value Witness Table</strong>
的索引，主要用于管理生命周期。</li>
<li>1 个词作为 <strong>Protocol Witness Table</strong>
的索引，主要用于管理方法调用。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/existential-container.png?x-oss-process=image/resize,w_800" /></p>
<p>泛型类型由于在调用时能够确定具体的类型，所以不需要使用 Existential
Container。在调用泛型方法时，只需要将 Value Witness Table/Protocol
Witness Table 作为额外参数进行传递。</p>
<h1 id="内存管理">内存管理</h1>
<p>泛型类型使用 VWT 进行内存管理，VWT 由编译器生成，其存储了该类型的
size、aligment（对齐方式）以及针对该类型的基本内存操作。其结构如下所示（以
C 代码表示）： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">value_witness_table</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> size, align;</span><br><span class="line">    <span class="type">void</span> (*copy_init)(opaque *dst, <span class="type">const</span> opaque *src, type *T);</span><br><span class="line">    <span class="type">void</span> (*copy_assign)(opaque *dst, <span class="type">const</span> opaque *src, type *T);</span><br><span class="line">    <span class="type">void</span> (*move_init)(opaque *dst, <span class="type">const</span> opaque *src, type *T);</span><br><span class="line">    <span class="type">void</span> (*move_assign)(opaque *dst, <span class="type">const</span> opaque *src, type *T);</span><br><span class="line">    <span class="type">void</span> (*destroy)(opaque *val, type *T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码中，VTW 中定义的方法与《Swift
性能优化(2)——协议与泛型的实现》中定义的方法有所出入。从功能上而言，它们都是属于基本的内存操作，可以相互转化，我们无需拘泥于细节差异。</p>
<p>当对泛型类型进行内存操作（如：内存拷贝）时，最终会调用对应泛型类型的
VWT 中的基本内存操作。泛型类型不同，其对应的 VWT
也不同。下图所示为一个小的值类型和一个引用类型的 VWT。</p>
<p>对于一个小的值类型，如：integer。该类型的 copy 和 move
操作会进行内存拷贝；destroy 操作则不进行任何操作。</p>
<p>对于一个引用类型，如：class。该类型的 copy 操作会对引用计数加
<code>1</code>；move 操作会拷贝指针，而不会更新引用计数；destroy
操作会对引用计数减 <code>1</code>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/value-witness-table-example.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="方法调用">方法调用</h1>
<p>上一节，我们介绍了泛型的内存管理。那么，泛型的方法调用又是如何实现的呢？</p>
<p>我们以如下一个泛型函数为例进行介绍。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">f</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">t</span>: <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> copy <span class="operator">=</span> t</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器对上述的泛型函数进行编译后，会得到如下代码（以 C 代码代替 LLVM
IR）。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T: 泛型参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(opaque *result, opaque *t, type *T)</span> &#123;</span><br><span class="line">    opaque *copy = alloca(T-&gt;vwt-&gt;size);</span><br><span class="line">    T-&gt;vwt-&gt;copy_init(copy, t, T);</span><br><span class="line">    T-&gt;vwt-&gt;move_init(result, copy, T);</span><br><span class="line">    T-&gt;vwt-&gt;destroy(t, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 从生成的代码中可以看出，方法运行时会传入一个
<code>type *T</code>。很明显，这是一个类型参数，描述泛型类型所绑定的具体类型的元信息，包括对
VWT 的索引信息。</p>
<p><code>f&lt;T&gt;</code>
是一个对泛型类型进行拷贝的方法，囊括了上述介绍的内存管理的过程，下面我们来简要分析其编译后的源码:</p>
<ol type="1">
<li>局部变量是分配在栈上的，并且对于该类型，我们不知道要分配多少内存空间，所以需要通过
VWT 获取到 <code>T</code> 的 <code>size</code> 才能进行内存分配。</li>
<li>内存空间分配完之后，通过 VWT 中的 <code>copy</code> 方法，以输入值
<code>t</code> 来初始化局部变量。</li>
<li>局部变量初始化完毕之后，通过 VWT 中的 <code>move</code>
方法，将局部变量移到 <code>result</code> 缓冲区以返回结果。</li>
<li>返回时，通过 VWT 中的 <code>destroy</code> 方法销毁局部变量。</li>
</ol>
<p>上述泛型函数的实现中，<code>type *T</code>
是整个函数能够顺利运行的关键。那么 <code>type *T</code>
到底是什么呢？</p>
<h2 id="type-metadata">Type Metadata</h2>
<p>事实上，编译器在会尽量在编译时为每一个类型生成一个类型元信息对象——Type
Metadata，也就是上述的 <code>type *T</code>。</p>
<p>Type Metadata 携带的类型元信息主要包含：<strong>类型的
VWT</strong>、<strong>类型的反射信息</strong>。如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/type-metadata-and-vwt.png?x-oss-process=image/resize,w_800" /></p>
<p>《Swift 性能优化(2)——协议与泛型的实现》文中提到每个对象初始化时就有的
<code>type</code> 字段其实就是 Type Medata 对象。因此对于不使用
Existential Container 进行表示的泛型类型来说，通过 Type Metadata
也可以索引到 VWT。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/polymorphism-through-v-table-dispatch.png?x-oss-process=image/resize,w_800" /></p>
<p>每一种类型，在全局只有一个 Type Metadata，供全局共享。</p>
<p>对于内建基本值类型，如：<code>Integer</code>，编译器会在标准库中生成对应的
Type Metadata 和 VWT。其中，VWT 是针对小的值类型 VWT。</p>
<p>对于引用类型，如：<code>UIView</code>，编译器也会在标准库中生成 Type
Metadata 和 VWT。其中，VWT 是针对引用类型的标准 VWT。</p>
<p>对于自定义的引用类型，Type Metadata 会在我们的程序中生成，VWT
则由所有引用类型共享，即上述针对引用类型的标准 VWT。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/type-metadata-and-vwt-example.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们再以上述 <code>f&lt;T&gt;</code>
函数的具体调用来进行介绍编译后的代码是如何使用 Type Metadata
的。如下所示为两种类型对 <code>f&lt;T&gt;</code> 的调用。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">f(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b, c, d: <span class="type">UInt8</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="type">MyStruct</span>())</span><br></pre></td></tr></table></figure>
当使用 <code>int</code> 类型和 <code>MyStruct</code> 类型调用
<code>f&lt;T&gt;</code> 时，编译器生成的代码如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">extern</span> type *Int_metadata;</span><br><span class="line">f(&amp;val, Int_metadata);</span><br><span class="line"></span><br><span class="line">MyStruct val;</span><br><span class="line">type *MyStruct_metadata = &#123; ... &#125;;</span><br><span class="line">f(&amp;val, MyStruct_metadata);</span><br></pre></td></tr></table></figure>
两者的区别在于：<code>int</code> 类型使用标准库中的 Type
Metadata；自定义类型则使用针对自身生成的 Type Metadata。</p>
<p>事实上，上述 Type Metadata
之所以能够在编译时生成，是因为我们在调用时就能通过类型推导得出其类型。如果，在调用时无法推断其类型，则需要在运行时动态生成
Type Metadata。</p>
<p>为了了解 Type Metadata 的动态生成，我们需要先了解 Metadata
Pattern。</p>
<h2 id="metadata-pattern">Metadata Pattern</h2>
<p>事实上，对于泛型类型，编译器会在编译时生成一个 Metadata
Pattern。Metadata Pattern 与 Type Metadata
的关系其实就是类与对象的关系。</p>
<p>以如下自定义泛型类结构为例。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> first: <span class="type">T</span></span><br><span class="line">    <span class="keyword">var</span> second: <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于运行时才能确定的泛型类型，运行时根据绑定类型的 Type
Metadata，结合 Metadata Pattern，生成最终的确定类型的 Type
Metadata。如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/metadata-pattern-of-int.png?x-oss-process=image/resize,w_800" /></p>
<p>对于 <code>Pair&lt;Int&gt;</code>，运行时会计算
<code>Pair&lt;Int&gt;</code> 的
<code>size</code>，并计算出各个域的偏移。</p>
<p>下面，我们通过一个泛型属性访问的例子来看看运行时是如何使用 Metadata
Pattern 来生成 Type Metadata。以如下代码为例： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getSecond</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">pair</span>: <span class="type">Pair</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pair.second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器生成的代码如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getSecond</span><span class="params">(opaque *result, opaque *<span class="built_in">pair</span>, type *T)</span> &#123;</span><br><span class="line">    type *PairOfT = get_generic_metadata(&amp;Pair_pattern, T);     <span class="comment">// 实例化 type metadata</span></span><br><span class="line">    <span class="type">const</span> opaque *second = (<span class="built_in">pair</span> + PairOfT-&gt;fields[<span class="number">1</span>]);</span><br><span class="line">    T-&gt;vwt-&gt;copy_init(result, second, T);</span><br><span class="line">    PairOfT-&gt;vwt-&gt;destroy(<span class="built_in">pair</span>, PairOfT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其步骤如下：</p>
<ol type="1">
<li>运行时，根据 Metadata Pattern，结合绑定的类型 <code>T</code> 的 Type
Medata（如 Int Type Metadata）生成 <code>Pair&lt;T&gt;</code> 的 Type
Metadata 实例。</li>
<li>根据 <code>Pair&lt;T&gt;</code> 的 Type Metadata 获得
<code>second</code> 在内存中的位置。</li>
<li>拷贝 <code>second</code> 躲在位置的内存到 <code>result</code>
缓存区。</li>
<li>返回前，销毁局部变量。</li>
</ol>
<h2 id="编译优化">编译优化</h2>
<p>上述代码是在编译时无法推断出泛型类型的情况下生成的通用型代码。然而，如果在编译时就能推导出泛型类型，编译器则会进行优化，在真正运行时避免通过传递
Type Metadata 来查找各个域的偏移，从而提高运行性能。</p>
<p>如下代码，就可以在编译时进行类型推导。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getSecond</span>(<span class="keyword">_</span> <span class="params">pair</span>: <span class="type">Pair</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pair.second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="高阶函数">高阶函数</h1>
<p>下面，我们再来看看高阶泛型函数是如何进行编译的。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">apply</span>&lt;<span class="type">T</span>&gt;(<span class="params">value</span>: <span class="type">T</span>, <span class="params">fn</span>: (<span class="type">T</span>) -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器编译将得到如下代码： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">apply</span><span class="params">(apaque *ret, </span></span><br><span class="line"><span class="params">           opaque *value, </span></span><br><span class="line"><span class="params">           <span class="type">void</span> (*func_invoke)(opaque *ret, opaque *arg, <span class="type">void</span> *context), </span></span><br><span class="line"><span class="params">           <span class="type">void</span> *fn_context, </span></span><br><span class="line"><span class="params">           type *T)</span> &#123;</span><br><span class="line">    fn_invoke(ret, value, fn_context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>func_invoke</code>
是闭包的函数指针，由于闭包可以捕获外部作用域，入参 <code>context</code>
就是用于传递作用域上下文。</p>
<p>为了调用闭包，执行 <code>fn_invoke(ret, value, fn_context)</code>
就是调用函数执行，并将上下文 <code>fn_context</code>
作为参数传进去。</p>
<p>下面，我们来看一个调用 <code>apply&lt;T&gt;</code> 的例子。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">apply(<span class="number">0</span>, &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure> 由于能够在编译时推导出类型，上述代码就相当于如下代码：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Int <span class="title function_">closure</span><span class="params">(Int $<span class="number">0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">0</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">apply(..., closure, <span class="literal">NULL</span>, ...);</span><br><span class="line"><span class="comment">// we have: Int (*func_invoke)(Int arg, void *ctxt)</span></span><br><span class="line"><span class="comment">// we need: void (*func_invoke)(opaque *ret, opaque *arg, void *ctxt)</span></span><br></pre></td></tr></table></figure> 然而，事实上，我们不能将以推导出的
<code>Int (*func_invoke)(Int arg, void *ctxt)</code> 闭包直接传递到
<code>apply</code> 中，而是需要将已确定类型的闭包转换成
<code>void (*func_invoke)(opaque *ret, opaque *arg, void *ctxt)</code>
闭包的形式间接传递到 <code>apply</code> 中。</p>
<p>那么，在确定类型的情况下，这里为什么仍然要做一次间接的转换与传递呢？</p>
<p>对此，我们需要首先介绍一个概念——<strong>重抽象（Reabstract）</strong>。</p>
<h2 id="reabstract">Reabstract</h2>
<p>Swift 中的所有类型都存在多个抽象级别。比如：一个 <code>Int</code>
值是一个具体类型，可以传递给确定类型的函数。但是 <code>Int</code>
值也可能传递给类型为泛型 <code>T</code>
的函数，此时该泛型函数希望能够间接接收该参数，从而适应其他可能的泛型类型，如：<code>Float</code>、<code>String</code>
等。当 <code>Int</code> 值传递给泛型函数时，它被认为比其为
<code>Int</code>
时处于更高的抽象级别。这种在抽象级别之间进行转化的过程被称为是
<strong>重抽象</strong>。</p>
<blockquote>
<p>计算机科学中的每个问题都可以用一间接层解决。</p>
</blockquote>
<p>事实上，上述 <code>apply</code>
采用间接传递的思想，本质上就是为了实现对类型进行重抽象的一种抽象模式。</p>
<p>这里通过 <code>thunk</code>
来实现对闭包的值进行重抽象，从而匹配函数的抽象模式。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Int</span> closure(<span class="type">Int</span> <span class="variable">$0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thunk(<span class="type">Int</span> <span class="operator">*</span>ret, <span class="type">Int</span> <span class="operator">*</span>arg, void <span class="operator">*</span>thunk_ctxt) &#123;</span><br><span class="line">    <span class="comment">// 1. 从 thunk 上下文中获取原始的 函数指针</span></span><br><span class="line">    <span class="type">Int</span> (<span class="operator">*</span>fn_invoke)(<span class="type">Int</span>, void<span class="operator">*</span>) <span class="operator">=</span> thunk_ctxt-&gt;<span class="operator">...</span>;</span><br><span class="line">    <span class="comment">// 2. 从 thunk 上下文中获取原始的 context</span></span><br><span class="line">    void <span class="operator">*</span>fn_context <span class="operator">=</span> thunk_ctxt-&gt;<span class="operator">...</span>;</span><br><span class="line">    <span class="comment">// 3. 在调用函数前，我们将需要间接的结果转换为直接的结果，通过 *arg。</span></span><br><span class="line">    <span class="comment">// 4. 最后将 fn_invoke 返回的直接值转换为间接值，通过 *ret = </span></span><br><span class="line">    <span class="operator">*</span>ret <span class="operator">=</span> fn_invoke(<span class="operator">*</span>arg, fn_context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="operator">*</span>thunk_ctxt <span class="operator">=</span> allocate(<span class="operator">...</span>, closure, <span class="type">NULL</span>);    <span class="comment">// allocate a context</span></span><br><span class="line">apply(<span class="operator">...</span>, thunk, thunk_ctxt, <span class="operator">...</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>到此，我们对 Swift
泛型的底层实现有了一定的理解了。那么协议的底层实现又是如何呢？其实，本质上协议就是受约束的泛型，具体的实现思想和形式也和泛型差不多。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://github.com/apple/swift/blob/master/docs/ABI/TypeMetadata.rst">TypeMetadata</a></li>
<li><a
href="https://github.com/apple/swift/blob/master/docs/Generics.rst">Generics
in Swift</a></li>
<li><a
href="https://github.com/apple/swift/blob/269d306b9d275aab5bd10f380a999e51901c5832/docs/ABIStabilityManifesto.md#abstraction-levels">Abstraction-levels</a></li>
<li><a
href="https://github.com/apple/swift/blob/269d306b9d275aab5bd10f380a999e51901c5832/docs/ABIStabilityManifesto.md#lowering-higher-order-functions">Lowering
Higher-Order Functions</a></li>
<li>LLVM Developer’s Meeting: “Implementing Swift Generics”.</li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>泛型</tag>
        <tag>Type Metadata</tag>
        <tag>Metadata Pattern</tag>
        <tag>Reabstract</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地管理你的定时任务？</title>
    <url>/2023/07/30/introduction-to-taskloop/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>在日常开发中，我们经常会使用一些定时任务来辅助完成某些事情。对此，绝大多数人都会选择使用
crontab 来配置定时任务。</p>
<p>不可否认，crontab
的确是管理定时任务的经典利器，但是你是否和我一样，踩过不少 crontab
的坑呢？</p>
<p>下面，我将介绍一下个人认为 crontab
的一些痛点和坑。最终，给出另一种优化的解决方案。</p>
<h1 id="crontab">crontab</h1>
<p>提到 crontab，这里必须要介绍一下它的配置规则，如下所示。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.---------------- 分 (0 - 59)</span><br><span class="line">|  .------------- 时 (0 - 23)</span><br><span class="line">|  |  .---------- 日 (1 - 31) </span><br><span class="line">|  |  |  .------- 月 (1 - 12) </span><br><span class="line">|  |  |  |  .---- 星期 (0 - 6) (星期日可为0或7) </span><br><span class="line">|  |  |  |  | </span><br><span class="line">*  *  *  *  * 执行的命令</span><br></pre></td></tr></table></figure> crontab 的配置规则可以分为 5 列，其作用分别是：</p>
<ul>
<li>第一列单位为分，表示每时第几分钟，范围为 0-59</li>
<li>第二列单位为时，表示每天第几小时，范围为 0-23</li>
<li>第三列单位为日，表示每月第几天，范围为 1-31</li>
<li>第四列单位为月，表示每年第几月，范围为 1-12</li>
<li>第五列单位为星期，表示每星期第几天，范围 0-7，0 与 7
表示星期日，其他分别为星期 1-6</li>
</ul>
<p>整体而言，crontab
对于不同的单位（除了星期），均支持了三种配置规则：</p>
<ul>
<li>指定时间</li>
<li>指定范围</li>
<li>指定步长</li>
</ul>
<p>通过组合这些配置规则，crontab 可以实现非常多的定时配置。</p>
<p>在使用 crontab 很长时间之后，我发现 crontab
还是存在着一些使用痛点的，主要有以下几点，下面分别进行介绍。</p>
<h2 id="输出重定向">输出重定向</h2>
<p>默认为情况下，crontab
会将任务输出默认写入到执行用户的邮件中。如果任务有大量输出，则会大量占用磁盘资源，甚至导致系统宕机。</p>
<p>如下所示，我们配置一个输出当前日志的定时任务。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span></span><br></pre></td></tr></table></figure>
<p>我们可以查看当前用户的邮件，如下所示。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /var/mail/<span class="variable">$USER</span></span><br><span class="line">...</span><br><span class="line">Tue Aug  1 22:11:22 CST 2023</span><br></pre></td></tr></table></figure></p>
<p>关于这个问题，实践经验都是建议采用如下的方式对任务的输出进行重定向。很显然，这对于新手是非常不友好的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span> &gt;&gt; /dev/null/ 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h2 id="环境变量">环境变量</h2>
<p>在实践中，我们可以发现 crontab
的环境变量与控制台的环境变量是存在差异的。因此，经常会出现这样的情景：在控制台中调试完成的任务，在
cron
中执行时，其结果会与预期不相符。事实上，产生这种差异的根本原因就是环境变量。</p>
<p>此外，crontab
中环境变量不会全局共享。因此，当我们配置多个任务时，可能需要为每个任务单独配置环境变量。很显然，这是一个重复而又繁琐的问题。</p>
<h2 id="规则语法">规则语法</h2>
<p>关于 crontab
的规则语法，这是个仁者见仁智者见智的问题。对于老手来说，可能比较简单；对于新人来说，在使用时得去查询各个位置的单位以及不同规则的写法。我觉得
crontab
的规则语法不容易理解的根本原因是缺少语义。如果能优化其规则语法的语义，那就更好不过了。</p>
<p>另一方面，对于某些极客来说，crontab
的规则可能还不够完备。比如：预期一个定时任务从某个时刻开始或停止执行，或者，预期一个任务循环执行
n 次后结束。对于这种规则，crontab
无法一次性满足，只能通过配置多个任务来辅助完成。</p>
<h2 id="运行日志">运行日志</h2>
<p>在实际应用中，我们经常需要借助任务的运行日志来排查问题。此时，我们就需要修改
crontab，将任务的输出重定向至某个文件，从而方便后续进行查看。当任务非常多的时候，我们很难记住每个任务对应的日志文件是哪个。这也是
crontab 的一个痛点。</p>
<h1 id="taskloop">taskloop</h1>
<p>为了解决 crontab
的诸多痛点，我在业余时间开发了一款优化版的定时任务管理器——<a
href="https://github.com/baochuquan/taskloop">taskloop</a>。</p>
<p>taskloop 底层运行在 cron 守护进程之上，基于 crontab
配置了最小粒度的调度规则，实现了一个中间层，从而解决了 crontab
的诸多痛点。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="命令">命令</h2>
<p>taskloop
提供了一系列的命令，实现了一个相对完整（如有缺失，补充实现）的工作流，其主要包含以下这些特性。</p>
<h3 id="环境变量-1">环境变量</h3>
<p><code>taskloop env</code>
命令提供了查看、导入、删除环境变量的功能。</p>
<p>如下所示，为环境变量查看的使用示例。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> </span><br><span class="line"></span><br><span class="line">PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5/bin:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global/bin:/Users/baochuquan/.rvm/rubies/ruby-2.6.5/bin:/usr/local/texlive/2023basic/bin/universal-darwin:/Users/baochuquan/.nvm/versions/node/v18.16.0/bin:/usr/local/opt/sqlite/bin:/usr/local/sbin:/usr/local/opt/gettext/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Users/baochuquan/.rvm/bin:/Users/baochuquan/Flutter/bin:/Users/baochuquan/Library/Android/sdk/tools</span><br><span class="line">RUBY_VERSION=ruby-2.6.5</span><br><span class="line">GEM_PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global</span><br><span class="line">GEM_HOME=/Users/baochuquan/.rvm/gems/ruby-2.6.5</span><br><span class="line">IRBRC=/Users/baochuquan/.rvm/rubies/ruby-2.6.5/.irbrc</span><br><span class="line">NOX_ROOT=/Users/baochuquan/Develop/nox</span><br><span class="line">NOX_NAME=nox</span><br><span class="line">NOX_COMMON=/Users/baochuquan/Develop/nox/common</span><br><span class="line">NOX_CONFIG=/Users/baochuquan/Develop/nox/config</span><br><span class="line">NOX_SCRIPTS=/Users/baochuquan/Develop/nox/scripts</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为环境变量导入的使用示例。示例中，我导入了两个环境变量
<code>JAVA_HOME</code> 和 <code>GROOVY_HOME</code>。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --import=JAVA_HOME,GROOVY_HOME</span><br><span class="line"></span><br><span class="line">importing JAVA_HOME ...</span><br><span class="line">    JAVA_HOME=/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">importing GROOVY_HOME ...</span><br><span class="line">    GROOVY_HOME=/usr/local/opt/groovy/libexec</span><br><span class="line"></span><br><span class="line">import global environment variables complete.</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为环境变量删除的使用示例。示例中，我删除了
<code>GROOVY_HOME</code> 环境变量。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --remove=GROOVY_HOME</span><br><span class="line"></span><br><span class="line">remove global environment variables complete.</span><br></pre></td></tr></table></figure></p>
<p>经过一系列导入、删除操作之后，我们可以通过 <code>taskloop env</code>
命令来查看导入结果是否正确。</p>
<h3 id="启动关闭">启动/关闭</h3>
<p>taskloop 具有一个全局的开关，即启动和关闭的能力。前面我们提到
taskloop 底层是运行在 cron 守护进程之上，对此，启动功能的本质就是将
taskloop 注册至 crontab；关闭功能的本质就是将 taskloop 从 crontab
注销。</p>
<p>如下所示，为启动 taskloop 的使用示例。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$  taskloop launch</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has launched successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>如下所示，为关闭 taskloop 的使用示例。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop shutdown</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has shutdown successfully.</span><br><span class="line"></span><br><span class="line">    byeeeeeeeeeeeeeeeee !</span><br></pre></td></tr></table></figure></p>
<h3 id="初始化">初始化</h3>
<p>taskloop 通过读取注册的 Taskfile 来执行所有的任务，Taskfile
中可以定义一系列用户自定义的任务。为了便于使用，taskloop
提供了一个初始化命令，可以自动创建一个 Taskfile
模板，从而供用户进行修改和定制。</p>
<p>如下所示，为初始化的使用示例。<code>taskloop init</code>
方法创建了一个 Taskfile
模板，并定义了所有支持的属性，我们可以自定义任务，包括任务的路径、名称、执行规则等。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop init</span><br><span class="line">$ <span class="built_in">cat</span> Taskfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># env to set environment variables which are shared by all tasks defined in the Taskfile. &lt;Optional&gt;</span></span><br><span class="line"><span class="comment"># env &quot;ENV_NAME&quot;, &quot;ENV_VALUE&quot;</span></span><br><span class="line"></span><br><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="发布撤销">发布/撤销</h3>
<p>当我们完成了对 Taskfile
的定义之后，可以进行发布。发布过程中，taskloop 会检查 Taskfile
中的语法规则，如果不符合将抛出异常，并提示错误；如果符合规则，则完成发布。Taskfile
将正式生效，后续的任务执行将以此为准。</p>
<p>如下所示，为发布的使用示例。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop deploy</span><br><span class="line"></span><br><span class="line">                       (@&amp;/////%@@@@@@@@@@@@@<span class="comment">#</span></span><br><span class="line">                          @@&amp;@&amp;////////////////(@@<span class="comment">#</span></span><br><span class="line">                         /@(///////////////////////%@/</span><br><span class="line">                       *@////////////////////////////<span class="comment">#@,</span></span><br><span class="line">                      @&amp;///////////////////////////////@%</span><br><span class="line">                     @&amp;//////////////(@////@&amp;<span class="comment">#/////////(@</span></span><br><span class="line">                     @////////////@@  @////@    ,.@////@@</span><br><span class="line">                    /@//////////&amp;@  ,@@////@@@&amp;.  *///@@</span><br><span class="line">                    ,@/////////(@@@   @///&amp;@     /@@///@@</span><br><span class="line">                     @%////////@@     @@@&amp;           @@/@<span class="comment">#</span></span><br><span class="line">                      @<span class="comment">#///////@           ,</span></span><br><span class="line">                       @@//////@&amp;      @(//@</span><br><span class="line">                         @@/////%@    @////@</span><br><span class="line">                            @@/////<span class="comment">#@@@////@</span></span><br><span class="line">                                &amp;@@@&amp;<span class="comment">#((&amp;@@</span></span><br><span class="line">                          /&amp;<span class="comment">#         @///@@</span></span><br><span class="line">                       ,///,*.        @////@</span><br><span class="line">                   &amp;<span class="comment">#  %/,@           @@///@</span></span><br><span class="line">                 (, .*/&amp;*%/*%///&amp;       (@@@         ,*/////*.</span><br><span class="line">           %/<span class="comment">#@, ////&amp;  @  % .&amp;  /@%/(/    /#/#@(                 #@#/&amp;</span></span><br><span class="line">        (/&amp;               .           .////,                           &amp;//</span><br><span class="line">       &amp;(//@                         &amp;//////&amp;                         @///@</span><br><span class="line">         (@%//////<span class="comment">#&amp;@@@@@@@@@@%///////@@  @@///////%@@@@@@@@@@&amp;#//////#@#</span></span><br><span class="line">                %@@@@&amp;@@@@@&amp;&amp;@@@@/              /@@@@&amp;&amp;@@@@@&amp;@@@@&amp;</span><br><span class="line"></span><br><span class="line">                              Taskfile deploy success!</span><br></pre></td></tr></table></figure></p>
<p>当然，在某些情况下，我们需要撤销已经发布的
Taskfile。此时，我们可以执行如下命令进行撤销。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop undeploy</span><br><span class="line"></span><br><span class="line">Taskfile <span class="keyword">in</span> &lt;/Users/baochuquan/Github/taskloop&gt; has been undeployed successfully.</span><br></pre></td></tr></table></figure>
<h3 id="任务查看">任务查看</h3>
<p>为了便于查看当前已发布的任务，taskloop
提供了一个命令方便用户进行查询。如下所示，为任务查看的使用示例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop list</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Tasks above are defined <span class="keyword">in</span> Taskfile of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">  &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt;</span><br><span class="line">    t.name        = haha</span><br><span class="line">    t.path        = ./test/Test01.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; specific: Aug</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; scope: between 25, 30</span><br><span class="line">    t.loop        = unit: loop; default rule</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br><span class="line">  &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt;</span><br><span class="line">    t.name        = baocq</span><br><span class="line">    t.path        = ./test/Test02.rb</span><br><span class="line">    t.year        = unit: year; default rule</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; interval: 1</span><br><span class="line">    t.loop        = unit: loop; loop: 3</span><br><span class="line">    t.start_point = unit: full; boundary: start from 2023-7-31 22:31:00</span><br><span class="line">    t.end_point   = unit: full; boundary: end to 2023-7-31 22:35:00</span><br><span class="line">  &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt;</span><br><span class="line">    t.name        = chuquan</span><br><span class="line">    t.path        = ./test/Test03.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; scope: after 22</span><br><span class="line">    t.minute      = unit: minute; interval: 10</span><br><span class="line">    t.loop        = unit: loop; loop: 1</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br></pre></td></tr></table></figure>
<h3 id="日志查看">日志查看</h3>
<p>为了解决 crontab 的日志查询问题，taskloop
同样提供了一个命令支持查询不同维度的日志，包括：系统日志（即 taskloop
运行日志）、任务日志。</p>
<p>如下所示，为查看系统日志的使用示例。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --cron</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Log of cron:</span><br><span class="line"></span><br><span class="line">Trigger Time: &lt;2023-08-03 08:24:00 +0800&gt;</span><br><span class="line">Checking: &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p>
<p>如下所示，为查看任务日志的使用示例。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --task-name=baocq</span><br><span class="line">=============================</span><br><span class="line">Project of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">Log of &lt;Task.name: haha&gt; above:</span><br><span class="line">&lt;Trigger Time: 2023-08-03 08:27:16 +0800&gt;</span><br><span class="line">Test0101</span><br><span class="line"></span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p>
<h2 id="语法规则">语法规则</h2>
<p><code>taskloop init</code> 命令会创建一个 Taskfile 文件，我们可以在
Taskfile 文件中自定义不同的任务与规则。这里，taskloop
定义了一套语法规则，我们将基于如下所示的 Taskfile 模板进行介绍。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>模板中列出了任务支持的所有属性，首先有两个必要属性 <code>name</code>
和 <code>path</code>。</p>
<ul>
<li><code>name</code>：用于指出任务的名称，同一个 Taskfile
中不能有同名的任务，主要用于日志查询时指定名称。</li>
<li><code>path</code> 用于指出任务的路径，taskloop
会根据此路径加载并执行任务脚本。</li>
</ul>
<p>模板中的其他属性均为非必要属性，用于描述执行规则。关于执行规则，taskloop
中主要定义如下几种规则。</p>
<ul>
<li><strong>指定时间规则（Specific Rule）</strong>
<ul>
<li>指定时间规则用于指定特定的时间值，对应的语法是
<code>at</code>。</li>
<li>支持指定时间规则的属性有
<code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>，其中
<code>week</code>、<code>month</code>、<code>day</code>
属性需要使用预定义的符号，其余属性可以直接使用数值。
<ul>
<li>对于
<code>week</code>，需要使用星期符号，如：<code>:Sun</code>、<code>:Mon</code>
等。</li>
<li>对于
<code>month</code>，需要使用月份符号，如：<code>:Jan</code>、<code>:Feb</code>
等。</li>
<li>对于
<code>day</code>，需要使用表示月份中第几天的符号，如：<code>:day1</code>，<code>:day2</code>
等。</li>
</ul></li>
<li>示例
<ul>
<li><code>t.week = at :Mon, :Sub, :Tue</code></li>
<li><code>t.month = at :Feb, :Aug</code></li>
<li><code>t.day = at :day2, :day8, :day30, day:31</code></li>
<li><code>t.year = at 2023, 2024</code></li>
<li><code>t.hour = at 10, 11</code></li>
<li><code>t.minute = at 59</code></li>
</ul></li>
</ul></li>
<li><strong>时间范围规则（Scope Rule）</strong>
<ul>
<li>时间范围规则包含三种子规则，对应的语法分别是：<code>before</code>、<code>between</code>、<code>after</code>。
<ul>
<li><code>before</code> 语法表示在小于等于某个值时执行。</li>
<li><code>between</code>
语法表示在大于等于某个值，且小于等于另一个值时执行。</li>
<li><code>after</code> 语法表示在大于等于某个值时执行。</li>
</ul></li>
<li>支持时间范围规则的属性有
<code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li>
<li>示例
<ul>
<li><code>t.year = before 2026</code></li>
<li><code>t.week = between :Mon, :Fri</code></li>
<li><code>t.hour = after 12</code></li>
</ul></li>
</ul></li>
<li><strong>时间间隔规则（Interval Rule）</strong>
<ul>
<li>时间间隔规则用于指定两次任务之间的时间间隔，对应的语法是
<code>interval</code>。</li>
<li>支持时间间隔规则的属性有
<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li>
<li>示例
<ul>
<li><code>t.minute = interval 5</code></li>
<li><code>t.day = interval 1</code></li>
</ul></li>
</ul></li>
<li><strong>循环次数规则（Loop Rule）</strong>
<ul>
<li>循环次数规则用于指定任务循环的次数，对应的语法是
<code>loop</code>。</li>
<li>支持循环次数规则的属性只有 <code>loop</code>。</li>
<li>示例
<ul>
<li><code>t.loop = loop 10</code></li>
</ul></li>
</ul></li>
<li><strong>时间列表规则（Time List Rule）</strong>
<ul>
<li>时间列表规则用于指定任务执行的时间列表，对应的语法是
<code>time</code>。其与 <code>hour</code>、<code>minute</code>
属性冲突，不能同时使用。</li>
<li>支持时间列表规则的属性只有 <code>time</code>。</li>
<li>示例
<ul>
<li><code>t.time = time "10:00:00", "7:00:00"</code></li>
</ul></li>
</ul></li>
<li><strong>日期列表规则（Date List Rule）</strong>
<ul>
<li>日期列表规则用于指定执行任务的日期列表，对应的语法是
<code>date</code>。其与
<code>year</code>、<code>month</code>、<code>day</code>
属性冲突，不能同时使用。</li>
<li>支持日期列表规则的属性只有 <code>date</code>。</li>
<li>示例
<ul>
<li><code>t.date = date "2023-10-1, "2023-5-1</code></li>
</ul></li>
</ul></li>
<li><strong>执行边界规则（Boundary Rule）</strong>
<ul>
<li>执行边界规则包含两种子规则，对应的语法分别是 <code>from</code> 和
<code>to</code>。
<ul>
<li><code>from</code> 语法表示任务从某一个时刻开始执行，支持的属性只有
<code>start_point</code>。</li>
<li><code>to</code> 语法表示任务在某一时刻之后不在执行，支持的属性只有
<code>end_point</code>。</li>
</ul></li>
<li>示例
<ul>
<li><code>t.start_point = "2023-10-1 10:00:00"</code></li>
<li><code>t.end_point = "2023-10-30 23:59:00</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="工作流程">工作流程</h2>
<p>taskloop 的工作流程可以分为三个步骤：</p>
<ul>
<li><strong>启动/关闭</strong></li>
<li><strong>初始化</strong></li>
<li><strong>发布/撤销</strong></li>
</ul>
<p>启动/关闭步骤是一个全局开关，对应分别有两个命令，如上所述。关于启动，一般只在最开始使用
taskloop
的时候使用启动命令。如果希望停止所有已注册任务的执行，则可以执行关闭命令。</p>
<p>taskloop
建议用户能够使用一个目录统一管理所有的定时任务，当希望为这些定时任务创建定时规则时，可以在目录下执行初始化命令，从而生成一个
Taskfile
文件。之后，即可自定义定时规则。如果用户本地维护了多个目录管理定时任务，则需要在不同的目录下分别执行一次初始化命令，从而完成任务规则自定义。</p>
<p>发布/撤销步骤相对而言会比较频繁，当初始化并自定义 Taskfile
之后，我们就可以执行发布命令，使得 Taskfile 真正在 taskloop
中生效。当然，有时候我们会在发布后发现一些错误，我们可以修改后重新发布，或者为了避免产生副作用，可以执行撤销命令。注意，发布/撤销命令必须在
Taskfile 的同级目录下执行。</p>
<h1 id="总结">总结</h1>
<p>本文简单介绍了一下我最近业余时间写的一个定时任务管理工具——taskloop。同时，解释了为什么做这个工具的原因（即解决
crontab 的痛点）。</p>
<p>关于软件
logo，我花了两晚设计了这样一个形象。两个圈组成一个莫比乌斯环，象征着循环。任务执行抽象为海豚跳圈，海豚在两个圈中循环穿越则象征着
taskloop 在永不停止地运行任务。</p>
<p>忘了说，其实写这篇文章的另一个重要目的是为了推广一下我的作品，也希望有兴趣的朋友能够给一些意见，甚至可以一起参与软件的开发和完善。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/baochuquan/taskloop">taskloop</a></li>
</ol>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>taskloop</tag>
        <tag>cron</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>控制反转、依赖注入、服务定位</title>
    <url>/2021/06/07/ioc-di-sl/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ioc-00.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>最近在阅读两款依赖注入的开源框架源码——Swinject 和
Resolver，为了便于后续的源码解读，这里先写一篇文章来梳理一下相关的概念，主要涉及控制反转、依赖注入、服务定位等概念。</p>
<h1 id="控制反转">控制反转</h1>
<p><strong>控制反转</strong>（Inversion of Control，简称
<strong>IoC</strong>）是软件开发中的一种设计思想，可以降低代码间的耦合度。</p>
<p>这样的解释还是很抽象，那到底什么是控制反转呢？下面，我们以一个例子来进行说明。</p>
<p>如下所示，我们定义了一个 <code>Company</code> 类，其依赖并创建了
<code>Engineer</code> 对象。我们把这种情况称为 “控制正转”，即
<strong><code>Company</code>
在内部控制了对象的初始化、属性赋值等操作</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">work</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span>: <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">work</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;code&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seller</span>: <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">work</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sell&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Engineer</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如，我们希望 <code>Company</code> 由 <code>Seller</code>
进行工作，那该如何进行修改？按照上面的设计逻辑，我们会对
<code>Company</code> 作出如下修改。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Seller</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于设计上的缺陷，当需求发生变更时，我们不得不对原来的类进行修改，这导致我们违反了
<strong>开闭原则</strong>——对扩展开放、对修改关闭。如下所示，为上述设计的类图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ioc-01.png?x-oss-process=image/resize,w_800" /></p>
<p>控制反转的基本思想是：<strong>把 <code>Company</code> 对
<code>employee</code>
的控制权从内部转交至外部，由外部来控制对象的初始化、属性赋值等操作</strong>。其期望的类图如下所示，目标是移除
<code>Company</code> 对 <code>EmployeeImpl</code>
实现类的依赖。这样的话，当我们修改 <code>EmployeeImpl</code>
实现类的类型，也无需修改 <code>Company</code>
类的内部代码，进而符合开闭原则。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ioc-02.png?x-oss-process=image/resize,w_800" /></p>
<p>通过一个例子，我们大致理解了 <strong>控制反转</strong>
的概念。在实际开发中，常见的实现控制反转的方式有两种：</p>
<ul>
<li><strong>依赖注入</strong>（Dependency Injection，简称
<strong>DI</strong>）</li>
<li><strong>服务定位</strong>（Service Locator）</li>
</ul>
<p>下面，我们分别对依赖注入和服务定位进行介绍。</p>
<h1 id="依赖注入">依赖注入</h1>
<p>依赖注入的基本思想是：<strong>通过一个注入器（Injector），由它来控制
<code>Employee</code> 的实现类的创建，并通过各种途径注入到
<code>Company</code> 中</strong>。依赖注入的类图如下所示。</p>
<blockquote>
<p><strong>注：在某些文章或框架中，注入器也被命名为容器（Containter或
IoC Container）</strong>。</p>
</blockquote>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ioc-03.png?x-oss-process=image/resize,w_800" /></p>
<p>依赖注入的注入方式有以下几种：</p>
<ul>
<li><strong>构造器注入（Constructor Injection）</strong></li>
<li><strong>属性注入（Property Injection）</strong></li>
<li><strong>方法注入（Method Injection）</strong></li>
<li><strong>接口注入（Interface Injection）</strong></li>
<li><strong>注解注入（Annotation Injection）</strong></li>
</ul>
<p>下面，我们依次进行介绍。</p>
<h2 id="构造器注入">构造器注入</h2>
<p>构造器注入是指通过初始化方法进行注入，如下所示。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> employee: <span class="type">Employee</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">employee</span>: <span class="type">Employee</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.employee <span class="operator">=</span> employee</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Injector</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Engineer</span>()</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> company: <span class="type">Companny</span> <span class="operator">=</span> <span class="type">Company</span>(employee: employee)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        company.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="属性注入">属性注入</h2>
<p>属性注入也称为 setter
方法注入，即通过设置属性的方式直接进行依赖注入，如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> employee: <span class="type">Employee</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee<span class="operator">?</span>.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Injector</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Engineer</span>()</span><br><span class="line">    <span class="keyword">let</span> company: <span class="type">Company</span> <span class="operator">=</span> <span class="type">Company</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        company.employee <span class="operator">=</span> employee</span><br><span class="line">        company.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法注入">方法注入</h2>
<p>方法注入则是通过方法参数传入依赖，如下所示。属性注入其实就是一种特殊的方法注入。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>(<span class="params">employee</span>: <span class="type">Employee</span>) &#123;</span><br><span class="line">        employee.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Injector</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Engineer</span>()</span><br><span class="line">    <span class="keyword">let</span> company: <span class="type">Company</span> <span class="operator">=</span> <span class="type">Company</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        company.operation(employee: employee)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口注入">接口注入</h2>
<p>接口注入本质上和前面几种依赖注入差不多，区别在于它需要为每种依赖声明一个对应的接口，由使用方实现接口并注入依赖，如下所示。相比前几种依赖注入，接口注入略微繁琐。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">InjectEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inject</span>(<span class="params">employee</span>: <span class="type">Employee</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> employee: <span class="type">Employee</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee<span class="operator">?</span>.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Company</span>: <span class="title class_">InjectEmployee</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inject</span>(<span class="params">dependency</span>: <span class="type">Employee</span>) &#123;</span><br><span class="line">        employee <span class="operator">=</span> dependency</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Injector</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Engineer</span>()</span><br><span class="line">    <span class="keyword">let</span> company: <span class="type">Company</span> <span class="operator">=</span> <span class="type">Company</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        company.inject(employee: employee)</span><br><span class="line">        company.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="注解注入">注解注入</h2>
<p>注解注入则是通过在需要注入依赖的地方添加特定的注解，通过注解背后的实现，自动注入对应的依赖，如下所示。相对而言，注解注入是一种使用更加简单的依赖注入方式。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Injected</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> dependency: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">Engineer</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Employee</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> dependency &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="meta">@Injected</span> <span class="keyword">var</span> employee: <span class="type">Employee</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee.work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tester</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> company: <span class="type">Company</span> <span class="operator">=</span> <span class="type">Company</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        company.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="服务定位">服务定位</h1>
<p><strong>服务定位，服务等同于被依赖的组件，定位即查找</strong>。服务定位的基本思想：<strong>一个服务定位器（Service
Locator）持有所有服务，当 <code>Company</code> 需要
<code>Employee</code>
的实现类时，即可返回一个特定类型的实现类</strong>。服务定位的类图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ioc-04.png?x-oss-process=image/resize,w_800" /></p>
<p>从类图中可以看出，服务定位与依赖注入的区别在于，服务定位只是将控制权从注入器转移到了服务定位器中。在依赖注入中，<code>Company</code>
是被动注入依赖，<code>Injector</code> 依赖
<code>Company</code>；在服务定位中，<code>Company</code>
则是主动请求服务，<code>Company</code> 依赖 <code>Injector</code>。</p>
<p>从服务定位器的内部实现，可以将服务定位分为两类：</p>
<ul>
<li>静态服务定位</li>
<li>动态服务定位</li>
</ul>
<p>下面，依次进行介绍。</p>
<h2 id="静态服务定位">静态服务定位</h2>
<p>对于静态服务定位，Service Locator
为每一种服务都提供了一个对应的方法，用于返回对应类型的服务，如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">use</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppForIOS</span>: <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">use</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;iOS&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> employee: <span class="type">Employee</span> <span class="operator">=</span> <span class="type">ServiceLocator</span>().getEmployee()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> product: <span class="type">Product</span> <span class="operator">=</span> <span class="type">ServiceLocator</span>().getProduct()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee.work()</span><br><span class="line">        product.use()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceLocator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getEmployee</span>() -&gt; <span class="type">Employee</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Engineer</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getProduct</span>() -&gt; <span class="type">Product</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AppForIOS</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tester</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> company: <span class="type">Company</span> <span class="operator">=</span> <span class="type">Company</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        company.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当每次增加新的服务时，Service Locator
内部需要新增方法以支持新的服务类型。这种方式的缺点很明显，因此现有的服务定位框架基本都是采用动态服务定位的方式设计实现的。</p>
<h2 id="动态服务定位">动态服务定位</h2>
<p>动态服务定位会在内部维护一个哈希表，哈希表能够存储各种类型的服务，并提供泛型方法以支持返回不同类型的服务。当新增服务时，也无需对
Service Locator 进行修改。如下所示，是一个简易的 Service Locator。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> employee: <span class="type">Employee</span>? <span class="operator">=</span> <span class="type">ServiceLocator</span>.shared.resolve(type: <span class="type">Employee</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> product: <span class="type">Product</span>? <span class="operator">=</span> <span class="type">ServiceLocator</span>.shared.resolve(type: <span class="type">Product</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">operation</span>() &#123;</span><br><span class="line">        employee<span class="operator">?</span>.work()</span><br><span class="line">        product<span class="operator">?</span>.use()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceLocator</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">ServiceLocator</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> map: [<span class="type">Int</span>: <span class="keyword">Any</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">register</span>&lt;<span class="type">Service</span>&gt;(<span class="params">type</span>: <span class="type">Service</span>.<span class="keyword">Type</span>, <span class="params">service</span>: <span class="type">Service</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> key <span class="operator">=</span> <span class="type">ObjectIdentifier</span>(type.<span class="keyword">self</span>).hashValue</span><br><span class="line">        map[key] <span class="operator">=</span> service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">type</span>: <span class="type">Service</span>.<span class="keyword">Type</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> key <span class="operator">=</span> <span class="type">ObjectIdentifier</span>(type.<span class="keyword">self</span>).hashValue</span><br><span class="line">        <span class="keyword">return</span> map[key] <span class="keyword">as?</span> <span class="type">Service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tester</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">test</span>() &#123;</span><br><span class="line">        <span class="type">ServiceLocator</span>.shared.register(type: <span class="type">Employee</span>.<span class="keyword">self</span>, service: <span class="type">Engineer</span>())</span><br><span class="line">        <span class="type">ServiceLocator</span>.shared.register(type: <span class="type">Product</span>.<span class="keyword">self</span>, service: <span class="type">AppForIOS</span>())</span><br><span class="line">        <span class="keyword">let</span> company <span class="operator">=</span> <span class="type">Company</span>()</span><br><span class="line">        company.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="依赖注入-vs-服务定位">依赖注入 vs 服务定位</h1>
<p>依赖注入和服务定位两者都实现了控制反转的目的。两者主要的区别在于提供服务（依赖）的方式不同。对于服务定位，使用方会显式地向
Service Locator 发起请求，而依赖注入并没有显式请求，而是被动注入。</p>
<p>对于服务定位，每个服务的使用方都需要依赖 Service Locator。由于
Service Locator
能够隐藏服务的相关信息，我们并不知道具体的依赖是什么，这可能会对于调试带来一些困难。</p>
<p>对于依赖注入，由于我们知道各个显式注入的位置，比如构造器，因此能够沿着调用栈，找到依赖创建的地方，进一步知道依赖的具体信息。</p>
<h1 id="总结">总结</h1>
<p>本文对控制反转、依赖注入、服务定位等几个概念，结合代码进行了介绍。依赖注入根据注入的途径又可以分为多种类型，包括：构造器注入、方法注入、属性注入、接口注入、注解注入等。服务定位根据内部实现方式，可以分为静态服务定位和动态服务定位两种实现方式。依赖注入和服务定位虽然有些差异，但是两者的目标是一致的，就是为了实现控制反转。</p>
<p>整体上而言，控制反转虽然能够对代码进行解耦，但是凡事都有两面性。它会让代码逻辑变得更加复杂，调试也会更加困难。从这方面看来，关于是否采用控制反转，需要具体场景具体分析，权衡利弊之后再作出选择。</p>
<p>现在业界的 IoC、ID 框架基本上都是在支持了
<strong>动态服务定位</strong>、<strong>注解注入</strong>
这两种功能的基础上，进行一些扩展，比如扩展一下服务定位的策略：是否每次查找都实例化服务？提供工厂方法进行延迟实例？是否缓存服务？...这些框架的服务定位设计思想基本上也是大同小异，基本都会在内部维护一个哈希表来缓存服务实例。</p>
<p>后续，有时间我们再来看看一些开源的 IoC 框架的设计。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://martinfowler.com/articles/injection.html">Inversion
of Control Containers and the Dependency Injection pattern</a></li>
<li><a
href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Introduction.md">Resolver:
Introduction</a></li>
<li><a
href="https://www.infoq.cn/article/bwzsmmbseetxp3cyy6mm">一文说透依赖注入</a></li>
<li><a
href="https://quickbirdstudios.com/blog/swift-dependency-injection-service-locators/">Dependency
Injection Strategies in Swift</a></li>
<li><a
href="https://juejin.cn/post/6844903838076370951">Swift中依赖注入的解耦策略</a></li>
<li><a
href="https://www.cnblogs.com/gaochundong/archive/2013/04/12/service_locator_pattern.html">Service
Locator 模式</a></li>
<li><a href="https://www.jianshu.com/p/2af9c063fd85">iOS
组件通信方案</a></li>
<li><a
href="https://medium.com/bigeye/dependency-injection-101-what-and-why-7bd11d53c528">Dependency
Injection 101--What and Why</a></li>
</ol>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>控制反转</tag>
        <tag>依赖注入</tag>
        <tag>服务定位</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS AVPlayer 视频缓存的设计与实现</title>
    <url>/2019/12/03/ios-avplayer-support-cache/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>最近一直在研究 iOS
平台的视频缓存设计方案。目标是实现视频边播边下载。后续再次播放时，则读取本地缓存数据，从而节省用户流量，提升用户体验。</p>
<span id="more"></span>
<p>基于 <code>AVPlayer</code> 的视频缓存方案 BCQMediaCache。 <a
href="https://github.com/baochuquan/BCQMediaCache?x-oss-process=image/resize,w_800">【源码传送门】</a></p>
<h1 id="基本原理">基本原理</h1>
<p>下图所示为 iOS AVPlayer 视频缓存的原理示意图。左边为原始的 AVPlayer
在播放时视频时资源的请求过程。右边为实现视频缓存的方案，其中的关键是为
<code>AVAssetResourceLoader</code> 设置代理，并实现
<code>AVAssetResourceLoaderDelegate</code>
协议所声明的两个方法。通过在这两个方法中捕获所有的
<code>AVAssetResourceLoadingRequest</code>
请求，并为所有的原始请求创建对应的自定义网络请求。使用自定义网络请求向远端多媒体服务器请求资源，当数据返回时，将数据返回给原始请求，并在本地进行数据缓存。
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/bcqmediacache-principle.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="技术细节">技术细节</h1>
<h2
id="avassetresourceloaderdelegate"><code>AVAssetResourceLoaderDelegate</code></h2>
<p>首先，我们需要为 <code>AVAssetResourceLoader</code> 设置代理。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlAsset <span class="operator">=</span> <span class="type">AVURLAsset</span>(url: xxx, options: <span class="literal">nil</span>)</span><br><span class="line">urlAsset.resourceLoader.setDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>.main)</span><br></pre></td></tr></table></figure> &gt; 注意：实现 <code>AVAssetResourceLoaderDelegate</code>
协议时，URL 必须是自定义的 URLScheme。我们需要把原始 URL 的
<code>http://</code> 或 <code>https://</code> 替换成
<code>xxx://</code>，协议方法才会生效。</p>
<p>然后，我们需要实现 <code>AVAssetResourceLoaderDelegate</code>
所声明的相关方法。对于视频缓存功能，我们仅需要实现以下两个方法即可。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">resourceLoader</span>(<span class="keyword">_</span> <span class="params">resourceLoader</span>: <span class="type">AVAssetResourceLoader</span>, </span><br><span class="line">                    <span class="params">shouldWaitForLoadingOfRequestedResource</span> <span class="params">loadingRequest</span>: <span class="type">AVAssetResourceLoadingRequest</span>) -&gt; <span class="type">Bool</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">resourceLoader</span>(<span class="keyword">_</span> <span class="params">resourceLoader</span>: <span class="type">AVAssetResourceLoader</span>, </span><br><span class="line">                    <span class="params">didCancel</span> <span class="params">loadingRequest</span>: <span class="type">AVAssetResourceLoadingRequest</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>resourceLoader(_:shouldWaitForLoadingOfRequestedResource:)</code>
方法表示代理类是否可以处理该请求。我们通过在这个方法中捕获每个原始请求，并创建对应的自定义网络请求。</p>
<p><code>resourceLoader(_:didCancel:)</code> 方法表示
<code>AVAssetResourceLoader</code>
主动放弃了某个原始请求。对此，我们需要将原始请求删除，并取消对应的自定义网络请求。</p>
<h2 id="自定义网络请求的创建">自定义网络请求的创建</h2>
<p>在上述
<code>resourceLoader(_:shouldWaitForLoadingOfRequestedResource:)</code>
代理方法中，我们能够捕获到一个原始请求，即一个
<code>AVAssetResourceLoadingRequest</code> 对象。如下所示，为
<code>AVAssetResourceLoadingRequest</code>
中的一些重要的属性和方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">AVAssetResourceLoadingRequest</span> : <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> request: <span class="type">URLRequest</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> contentInformationRequest: <span class="type">AVAssetResourceLoadingContentInformationRequest</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> dataRequest: <span class="type">AVAssetResourceLoadingDataRequest</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">finishLoading</span>()</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">finishLoading</span>(<span class="params">with</span> <span class="params">error</span>: <span class="type">Error</span>?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>request</code> 代表原始请求，由于 <code>AVPlayer</code>
会触发分片下载的策略，<code>request</code> 请求会从
<code>dataRequest</code>
中获取请求的分片范围。因此，根据请求地址和请求分片，我们就可以创建自定义的网络请求。请求分片需要在
HTTP Header 中进行设置。</p>
<h2 id="自定义网络请求的响应">自定义网络请求的响应</h2>
<p>下图所示为视频播放时的一次网络请求的时序图。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/timeline-of-avassetloadingrequest.png?x-oss-process=image/resize,w_800" /></p>
<p>我们根据 <code>dataRequest</code>
中的分片信息，创建并发起自定义网络请求。当远端的服务器响应该请求后，客户端会经历一下三个步骤，并调用相应的代理方法。</p>
<ul>
<li><strong>处理响应</strong></li>
<li><strong>处理数据</strong>（多次）</li>
<li><strong>请求结束</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, </span><br><span class="line">                <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>, </span><br><span class="line">                <span class="params">didReceive</span> <span class="params">response</span>: <span class="type">URLResponse</span>, </span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">URLSession</span>.<span class="type">ResponseDisposition</span>) -&gt; <span class="type">Void</span>)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, </span><br><span class="line">                <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>, </span><br><span class="line">                <span class="params">didReceive</span> <span class="params">data</span>: <span class="type">Data</span>)                </span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, </span><br><span class="line">                <span class="params">task</span>: <span class="type">URLSessionTask</span>, </span><br><span class="line">                <span class="params">didCompleteWithError</span> <span class="params">error</span>: <span class="type">Error</span>?)</span><br></pre></td></tr></table></figure>
<h3 id="处理响应">处理响应</h3>
<p>请求响应时，我们从响应头部中获取资源相关信息，如：</p>
<ul>
<li><code>ContentType</code> 表示文件类型</li>
<li><code>Content-Range</code> 包含文件长度信息</li>
<li><code>Accept-Ranges</code> 包含是否支持分片请求</li>
</ul>
<p>我们需要把视频的信息填充到 <code>AVAssetResourceLoadingRequest</code>
的 <code>contentInformationRequest</code> 中，从而通知
<code>AVAssetResourceLoader</code>
要下载视频的视频格式、视频长度等。</p>
<h3 id="处理数据">处理数据</h3>
<p>当请求的分片范围较大时，客户端分多次顺序调用数据处理代理方法。我们可以在此时对接收到的数据进行缓存。当然，还要将数据返回给
<code>dataRequest</code>，可以通过调用 <code>respond(with:)</code>
方法将数据返回给 <code>dataRequest</code>。</p>
<h3 id="请求结束">请求结束</h3>
<p>当数据传输完毕后，我们需要手动调用 <code>finishLoading()</code>
方法通知 <code>AVAssetResourceLoader</code>
数据下载完毕。如果请求失败，我们也需要手动调用
<code>finishLoading(with:)</code> 方法告诉
<code>AVAssetResourceLoader</code> 数据下载失败。</p>
<h2 id="重试机制">重试机制</h2>
<p>当一个网络请求未完成时，我们拖动视频的进度条，<code>AVAssetResourceLoader</code>
会自动取消前一次的网络请求，从而发起一个新的网络请求。</p>
<p>在上述 <code>resourceLoader(_:didCancel:)</code>
代理方法中，我们可以取消某一次下载请求。</p>
<h2 id="分片下载">分片下载</h2>
<p>一般情况下，视频播放支持进度拖拽的功能，即 <code>seek</code>
功能。因此，网络请求的分片与本地的分片数据可能存在如下关系：</p>
<ul>
<li><strong>本地缺失分片数据</strong></li>
<li><strong>本地包含完整分片数据</strong></li>
<li><strong>本地包含部分分片数据</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/seek-of-avassetloadingrequest.png?x-oss-process=image/resize,w_800" /></p>
<p>通过定义一个类来表示这两种分片信息。我们对请求的分片进行检查和拆分，并按顺序进行处理。如果本地已缓存，则直接返回本地分片数据；如果本地未缓存，则创建自定义网络请求，请求分片数据。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BCQResourceFragmentType</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> local                              <span class="comment">// 已缓存本地</span></span><br><span class="line">    <span class="keyword">case</span> remote                             <span class="comment">// 未缓存本地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BCQResourceFragment</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">BCQResourceFragmentType</span>       <span class="comment">// 数据分片类型</span></span><br><span class="line">    <span class="keyword">let</span> range: <span class="type">SVRange</span>                      <span class="comment">// 数据分片范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="设计实现">设计实现</h1>
<p>如图所示为 BCQMediaCache 的类图。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/BCQMediaCache.png?x-oss-process=image/resize,w_800" /></p>
<p>BCQMediaCache 使用四个类将其核心功能分为四层：</p>
<ul>
<li><strong><code>BCQResourceLoaderManager</code></strong></li>
<li><strong><code>BCQResourceLoader</code></strong></li>
<li><strong><code>BCQResourceFragmentDownloader</code></strong></li>
<li><strong><code>BCQResourceFragmentRequest</code></strong></li>
</ul>
<p><strong><code>BCQResourceLoaderManager</code></strong> 作为
<code>AVAssetResourceLoader</code> 的代理，实现了
<code>AVAssetResourceLoaderDelegate</code>
协议的两个方法。通过这两个方法实现对原始请求
<code>AVAssetResourceLoadingRequest</code>
的管理，包括：保存、取消。<code>BCQResourceLoaderManager</code>
还可以管理多个 URL，针对不同的 URL，它将创建对应的
<code>BCQResourceLoader</code>。具体的资源下载任务则由
<code>BCQResourceLoader</code> 及以下分层来完成。</p>
<p><strong><code>BCQResourceLoader</code></strong> 管理单个 URL
的资源下载。对于单个
URL，同一时刻可能存在多个网络请求，为此，<code>BCQResourceLoader</code>
维护一个网络请求的列表。</p>
<p><strong><code>BCQResourceFragmentDownloader</code></strong>
内部包含两个属性：<code>originRequest</code> 和
<code>customRequest</code>，分别表示原始网络请求和自定义网络请求。<code>BCQResourceFragmentDownloader</code>
将两者进行了绑定，负责处理两者之间的交互，如：</p>
<ul>
<li>根据本地保存的分片信息，对 <code>originRequest</code>
的请求分片进行详细拆分，得到 <code>BCQResourceFragment</code> 数组</li>
<li>使用 <code>BCQResourceFragment</code> 数组创建并启动
<code>customRequest</code></li>
<li>根据自定义请求的响应信息配置 <code>originRequest</code> 的
<code>contentInformationRequest</code></li>
<li>将自定义请求的返回数据返回给 <code>originRequest</code> 的
<code>dataRequest</code></li>
<li>通过自定义请求的结束调用通知 <code>originRequest</code> 的
<code>dataRequest</code></li>
</ul>
<p><strong><code>BCQResourceFragmentRequest</code></strong>
是数据请求的真正执行者。它根据分片的 <code>BCQResourceFragment</code>
数组，按顺序进行更细粒度的数据请求（远端请求或本地读取）。当从远端获取到数据时，首先向上层转发，其次异步写入本地。每个
<code>BCQResourceFragmentRequest</code>
单独占用一个线程，可并发执行。</p>
<p><strong><code>BCQResourceInfo</code></strong>
会在初始化时从本地读取元数据
<code>BCQResourceMeta</code>，元数据记录了本地已缓存数据的分片信息。</p>
<p><strong><code>BCQResourceUtils</code></strong>
则包含一些工具方法，如：创建缓存目录、日志打印方法等。</p>
<h1 id="注意问题">注意问题</h1>
<h2 id="自定义scheme">自定义Scheme</h2>
<p>实现 <code>AVAssetResourceLoaderDelegate</code> 协议时，URL
必须是自定义的 URLScheme。我们需要把原始 URL 的 <code>http://</code> 或
<code>https://</code> 替换成 <code>xxx://</code>，协议方法才会生效。</p>
<h2 id="服务器信任证书">服务器信任证书</h2>
<p>在请求资源时，我们可能会遇到 Challenge
验证。此时，我们需要在如下代理方法中进行 Challenge 验证。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>, </span><br><span class="line">                <span class="params">didReceive</span> <span class="params">challenge</span>: <span class="type">URLAuthenticationChallenge</span>, </span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">URLSession</span>.<span class="type">AuthChallengeDisposition</span>, <span class="type">URLCredential</span>?) -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="swift-httpurlresponse-content-range-天坑">Swift HTTPURLResponse
Content-Range 天坑</h2>
<p>使用 Swift 实现视频缓存方法，调试过程中遇到了一个 Swift
URLHTTPResponse 天坑：关于 HTTP Header 中的 Content-Range 字段。</p>
<p>正常情况下或者连接 Charles 并且 Disable SSL Proxying
情况下，<code>Content-Range</code> 为小写，即
<code>content-type</code>；连接 Charles 并且 Enable SSL Proxying
情况下，<code>Content-Range</code> 为大写，即
<code>Content-Range</code>。</p>
<h1 id="总结">总结</h1>
<p>在方案设计阶段，调研了多个开源库，包括：ShortMediaCache、VIMediaCache。详细阅读了
<code>VIMediaCache</code>
源码，绘制其设计类图，分析其设计优点和缺点。汲取 VIMediaCache
的设计优点，最后重新设计了一套方案。</p>
<p>在开发调试过程中，遇到了一些坑，花了不少时间解决。具体的实现涉及到不少细节，开发过程中也花费了不少时间。</p>
<p>总体而言，得到了很好的锻炼，值得~</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://github.com/vitoziv/VIMediaCache">VIMediaCache</a></li>
<li><a
href="https://github.com/dangercheng/ShortMediaCache">ShortMediaCache</a></li>
<li><a
href="https://mp.weixin.qq.com/s/v1sw_Sb8oKeZ8sWyjBUXGA">可能是目前最好的
AVPlayer 音视频缓存方案</a></li>
<li><a
href="http://msching.github.io/blog/2016/05/24/audio-in-ios-9/">iOS音频播放
(九)：边播边缓存</a></li>
<li><a
href="https://segmentfault.com/a/1190000016228456">iOS短视频播放缓存之道</a></li>
<li><a
href="http://xferris.cn/avplayer_cache/">AVPlayer初体验之边下边播与视频缓存</a></li>
<li><a
href="https://www.cnblogs.com/code-life/p/7806824.html">通过Authentication
Challenge来信任自签名Https证书</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AVPlayer</tag>
        <tag>AVAssetResourceLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 证书幕后原理</title>
    <url>/2020/03/22/ios-certificate-principle/</url>
    <content><![CDATA[<p>在日常的 iOS
开发中，无论是新手还是老鸟，总是会遇到各种与证书、签名有关的问题。当不了解其中的具体原理时，我们总是会被这些问题整得焦头烂额。对于我也是如此，为了彻底理清其中的原理，我花了一些时间进行了研究并整理出这篇文章以供后续进行参考。</p>
<span id="more"></span>
<h1 id="基本概念">基本概念</h1>
<p>iOS 开发中各种证书的核心就是 <strong>非对称加密技术</strong>（即
<strong>公钥/私钥加密技术</strong>）。关于非对称加密的原理，本文不作介绍。</p>
<p>为了深入了解证书幕后的原理，我们需要了解两个关键的概念：</p>
<ul>
<li><strong>数字签名</strong></li>
<li><strong>数字证书</strong></li>
</ul>
<h2 id="数字签名">数字签名</h2>
<p><strong>数字签名（Digital Signature）</strong>
是一种相当于现实世界中的盖章、签字的功能在数字信息领域中的实现。数字签名可以识别篡改和伪装。</p>
<p>在数字签名技术中，有两种行为：</p>
<ul>
<li><strong>签名生成</strong></li>
<li><strong>签名验证</strong></li>
</ul>
<h3 id="签名生成">签名生成</h3>
<p>签名生成由通信中的发起方进行，其过程如下所示。首先对通信内容进行哈希，然后使用发送方的私钥进行加密，最终得到签名。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/signature-creation.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="签名验证">签名验证</h3>
<p>签名验证由通信中的接收方进行，其过程如下所示。一般而言，发送方会把
<strong>消息</strong>、<strong>签名</strong>
一起发送给接收方。接收方首先使用发送方的公钥对签名进行解密，计算得出一个摘要。然后使用消息进行哈希，计算得出另一个摘要。最后，判断两个摘要是否相等，如果相等则说明接收到的消息没有被第三方进行篡改。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/signature-validation.png?x-oss-process=image/resize,w_800" /></p>
<p>那么接收方是如何获取到发送方的公钥的呢？接收方又是如何确定该公钥就是属于发送方的呢？这就是数字证书要做到事。</p>
<h2 id="数字证书">数字证书</h2>
<p><strong>数字证书（Digital Certificate）</strong>
是一种相当于现实世界中身份证的功能在数字信息领域中的实现。数字证书包含了个人或机构的
<strong>身份信息</strong> 及其 <strong>公钥</strong>，因此也称为
<strong>公钥证书（Public-Key Certificate，PKC）</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/my-certificate-example.png?x-oss-process=image/resize,w_800" /></p>
<p>类似于身份证是由权威的公安局颁发，公钥证书也是由权威的
<strong>认证机构（Certificate Authority，CA）</strong>
颁发。认证机构向接收方提供发送方的证书，证书中包含了发送方的身份信息和公钥。为了防止证书在颁发过程中被篡改，认证机构会将身份信息和公钥作为消息，用
<strong>CA 私钥</strong> 进行签名，进而将
<strong>身份信息</strong>、<strong>公钥</strong>、<strong>签名</strong>
一起放入证书，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/certificate.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="根证书">根证书</h2>
<p>接收方得到发送方证书时，通过 CA 公钥对证书进行签名验证。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/certificate-validation.png?x-oss-process=image/resize,w_800" /></p>
<p>不过，需要注意的是，很多情况下，CA
公钥则又是由一个更加权威的机构颁发。</p>
<p>类似于地方公安局的证书是由市级公安局颁发，市级公安局的证书又是由省级公安局颁发。证书是具有信任链（Chain
of Trust）的，<strong>根证书（Root Certificate）</strong>
是信任源，即信任链的起源。</p>
<p>根证书的颁发者被称为 <strong>Root Certificate Authority（Root
CA）</strong>。某一认证领域内的根证书是 Root CA
自行颁发给自己的证书（Self-signed Certificate），安装证书意味着对这个 CA
认证中心的信任。</p>
<p>根据证书在信任链中所处的位置，可以将证书分为三种：</p>
<ul>
<li><strong>根证书（Root Certificate）</strong></li>
<li><strong>中间证书（Intermediate Certificate）</strong></li>
<li><strong>叶子证书（Leaf Certificate）</strong></li>
</ul>
<p>这里就有一个根本性的问题：<strong>如何保证根证书是可信的？</strong></p>
<p>事实上，根证书都是随软件一起安装的，如：操作系统安装时会内置一份可信的根证书列表。</p>
<h1 id="ios-证书">iOS 证书</h1>
<p>在介绍了数字签名（包括：签名生成、签名验证）和数字证书（根证书）的基本概念之后，我们现在来介绍
iOS 开发中的相关证书。</p>
<p>首先，我们来看一下 MacOS 系统中关于 iOS
开发证书的信任链示例（通过“钥匙串”查看）：</p>
<ul>
<li><strong>Apple Root Certificate Authority</strong>：根证书
<ul>
<li><strong>Apple Worldwide Developer Relations Certification
Authority</strong>：中间证书
<ul>
<li><strong>iPhone Developer: 楚权 包(XXXXXXX)</strong>：叶子证书</li>
<li><strong>iPhone Distribution: Apple Tech</strong>：叶子证书</li>
<li><strong>Apple Development: baocq@apple.com</strong>：叶子证书</li>
</ul></li>
</ul></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/keychain-trust-of-chain.jpeg?x-oss-process=image/resize,w_1000" /></p>
<p>根证书 <code>Apple Root Certificate Authority</code> 是在 MacOS
操作系统安装时内置的，是 Apple Root CA 自行颁发的。</p>
<p>中间证书
<code>Apple World Developer Relations Certificate Authority</code>
（实际文件为 <code>AppleWWDRCA.cer</code>）是在Xcode 安装时内置的，是
Apple Root CA 颁发的。虽然 <code>AppleWWDRCA.cer</code>
是中间证书，但是对于 iOS 开发分类来说，它就是
<strong>开发根证书</strong>。</p>
<p>我们开发所使用的证书都是叶子证书，是 Apple Worldwide Developer
Relations Certification Authority 颁发的。</p>
<p>那么，我们开发所示用的证书是如何生成的呢？下面我们来介绍一下如何申请开发证书。</p>
<h2 id="申请原理">申请原理</h2>
<p>下图所示，是证书申请的基本原理，可分为以下几个步骤：</p>
<ul>
<li>开发者在本地生成密钥对，并提供开发者的身份信息。</li>
<li>将密钥对中的公钥、身份信息发送给 CA。</li>
<li>CA 使用 CA 私钥对开发者的公钥、身份信息进行签名。</li>
<li>CA 将开发者的公钥、身份信息、签名组装成证书以供下载。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/certificate-creation.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="申请方法">申请方法</h2>
<p>上述介绍 iOS 开发证书的申请原理。在 iOS
开发中，一般由两种申请方法：</p>
<ul>
<li><strong>CertificateSigningRequest</strong></li>
<li><strong>Xcode 自动申请</strong></li>
</ul>
<p>下面我们依次进行介绍。</p>
<h3 id="certificatesigningrequest">CertificateSigningRequest</h3>
<p>首先，通过 “钥匙串” 菜单栏选择 【从证书颁发机构请求证书...】。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-creation02.png?x-oss-process=image/resize,w_800" /></p>
<p>其次，填写用户的身份信息（电子邮箱），并勾选【存储到磁盘】。点击【继续】后将会保存一个
<code>CSR</code>
文件（<code>CertificateSigningRequest.certSigningRequest</code>）至本地。</p>
<p>注意，这个过程期间会生成一对非对称密钥对，<code>CertificateSigningRequest.certSigningRequest</code>
本质上包含了 <strong>开发者信息</strong>和
<strong>公钥</strong>。<strong>私钥</strong> 则始终保存在开发者的 Mac
中。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-creation03.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，在开发者网站（扮演了 AppleWDRCA 的角色）上传 <code>CSR</code>
文件，由 CA
进行签名并生成开发者证书。开发者证书始终保留在开发者网站上，开发者可以删除（Revoke）已注册的证书。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-creation04.png?x-oss-process=image/resize,w_800" /></p>
<p>最后，从开发者网站上下载开发者证书至 Mac，双击后即可安装。</p>
<h3 id="xcode-自动申请">Xcode 自动申请</h3>
<p>通过，Xcode 菜单【Preference...】-&gt;【Account】-&gt;【Apple
IDs】-&gt;【＋】，登录开发者账号。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/certificate-creation05.png?x-oss-process=image/resize,w_800" /></p>
<p>登录成功后，“钥匙串”会自动导入一份证书（包含一份密钥对）。开发者网站也会注册一份证书。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/certificate-creation07.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/certificate-creation06.png?x-oss-process=image/resize,w_800" /></p>
<p>Xcode 自动申请是一种一键式的申请方式，推荐开发者使用。</p>
<h2 id="使用">使用</h2>
<p>iOS 证书包含开发者的信息以及开发者的公钥。Xcode 导入证书后，对 App
打包时 Xcode 会根据证书从 Keychain 中找到与之匹配的私钥，并使用私钥对
App 进行签名。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/certificate-usage.png?x-oss-process=image/resize,w_800" /></p>
<p>当 App 安装到真机时，真机使用开发者公钥（App 中包含开发者公钥）对 App
进行签名验证，从而确保来源可信。App
安装时具体的验证过程我们后文再说。</p>
<h2 id="分类">分类</h2>
<p>iOS 证书可以分为两种：</p>
<ul>
<li><strong>Development</strong>：开发证书，用来开发和调试
App。一般证书名是
<code>iPhone Developer: xxx</code>。如果是多人协作的开发者账号，任意成员都可以申请自己的
Development 证书。</li>
<li><strong>Distribution</strong>：发布证书，用来发布 App。一般证书名是
<code>iPhone Distribution: xxx</code>。只有管理员以上身份的开发者账号才可以申请，因此可以控制提交权限的范围。</li>
</ul>
<p>下文主要针对 iOS App 开发调试过程中的开发证书进行介绍。</p>
<h1 id="授权文件entitlements">授权文件（Entitlements）</h1>
<p><strong>沙盒（Sandbox）</strong> 技术是 iOS
安全体系中非常重要的一项技术，其目的是 <strong>限制 App
的行为</strong>，如：可读写的路径、允许访问的硬件、允许使用的服务等等。因此，如果代码出现漏洞，也不会影响沙盒外的系统。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/sandbox.png?x-oss-process=image/resize,w_800" /></p>
<p>沙盒使用 <strong>授权文件（Entitlements）</strong> 声明 App
的权限。如果 App
中使用到了某项沙盒限制的功能，但是没有声明对应的权限，运行到相关代码时会直接
Crash。</p>
<p>新建的工程是没有 Entitlements 文件的，如果在
【Capabilities】中开启所需权限后，Xcode 会自动生成 Entitlements
文件，并将对应的权限声明添加到该文件中。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/entitlements02.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/entitlements01.png?x-oss-process=image/resize,w_800" /></p>
<p>Entitlements 文件是一个 <code>xml</code> 格式的 <code>plist</code>
文件，在项目中一般以 <code>.entitlements</code> 为后缀，其内容如下：
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>aps-environment<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>production<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.associated-domains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>applinks:xxxx.companyname.com<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.application-groups<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>group.com.companyname<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>事实上，Entitlements
文件的内容并不是全部的授权声明。因为缺省状态下，App 默认会包含与 TeamID
及 App ID 相关的权限声明，如下： <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>keychain-access-groups<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>xxxxxxxxxx.*<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>application-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>xxxxxxxxxx.test.CodeSign<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.team-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>xxxxxxxxxx<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure> 其中
<code>get-task-allow</code>
代表是否允许被调试，它在开发阶段是必需的一项权限，而在进行Archive打包用于上架时会被去掉。</p>
<p><strong>注意：代码签名时，会将 Entitlements
文件（如有）与上述缺省内容进行合并，得到最终的授权文件，并嵌入二进制代码中，作为被签名内容的一部分，由代码签名保证其不可篡改性。</strong></p>
<h1 id="app-id">App ID</h1>
<p><strong>App ID</strong> 即 Product ID，用于标识一个或一组 App。</p>
<p>App ID 字符串通常以 <strong>反域名（reverse-domain-name）</strong>
格式的 Company Identifier（Company
ID）作为前缀（Prefix/Seed），一般不超过 255 个 ASCII 字符。</p>
<p>App ID 全名会被追加 Application Identifier Prefix（一般为
TeamID）。App ID 可以分为两种：</p>
<ul>
<li><strong>Explicit App ID</strong>：唯一的 App
ID，用于标识一个应用程序。如：<code>com.apple.garageband</code> 用于标识
Bundle Identifier 为 <code>com.apple.garageband</code> 的 App。</li>
<li><strong>Wildcard App ID</strong>：含有通配符的 App
ID，用于标识一组应用程序。如：<code>com.apple.*</code> 用于标识 Bundle
Identifier 以 <code>com.apple.</code>
开头（苹果公司）的所有应用程序。</li>
</ul>
<p>开发者可在 Developer Member Center
网站上注册（Register）或删除（Delete）已注册的 App IDs。</p>
<p>在 Xcode 中，配置项
<code>Xcode Target -&gt; Info -&gt; Bunlde Identifier</code> 必须与 App
ID 是一致的（Explicit）或匹配的（Wildcard）。</p>
<p><strong>注意：注册 App ID
时，允许开发者在【Capabilities】中勾选所需的权限。这与上述的授权文件
Entitlements 相匹配。</strong></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/appid01.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="设备">设备</h1>
<p><strong>设备（Device）</strong> 即用于开发调试的 iOS 设备。每台 Apple
设备使用 <strong>UDID（Unique Device Identifier）</strong>
来唯一标识，即设备 ID。</p>
<p>Apple Member Center 网站个人账号下的 <strong>Device</strong>
中包含注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多注册
100 个设备。</p>
<p>开发者可在网站上注册或启用/禁用（Enable/Disable）已注册的
Device。</p>
<p>本文的 Device 是指连接到 macOS/Xcode 被授权用于开发测试的 iOS
设备（iPhone/iPad）。</p>
<h1 id="供应配置文件provisioning-profile">供应配置文件（Provisioning
Profile）</h1>
<h2 id="创建">创建</h2>
<p><strong>供应配置文件（Provisioning Profile，简称 pp）</strong>
包含了上述所有内容：</p>
<ul>
<li><strong>App ID</strong>（App ID
在注册时可声明所需沙盒权限，所以包含了 Entitlements）</li>
<li><strong>证书</strong></li>
<li><strong>设备 ID</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/provisioning-profile.png?x-oss-process=image/resize,w_800" /></p>
<p>一个 Provisioning Profile 对应一个 Explicit ID 或 Wildcard
ID。在网站上手动创建一个 Provisioning Profile
时，需依次指定上述三项内容：</p>
<ul>
<li>App ID：单选（沙盒权限，可多选）</li>
<li>证书：Certificates，可多选，对应多个开发者</li>
<li>设备：Devices，可多选，对应更多个开发设备</li>
</ul>
<p>开发者可以下载 Provisioning Profile 文件，即一个
<code>.mobileprovision</code> 文件。开发者也可以删除（Delete）已注册的
Provisioning Profile。</p>
<p>Provisioning Profile 会配置到
<code>Xcode -&gt; Target -&gt; Signing &amp; Capabilities -&gt; Provisioning Profile</code>
中。</p>
<p>Provisioning Profile 默认保存在本地的
<code>~/Library/MobileDevice/Provisioning Profiles</code> 目录下。</p>
<h2 id="构成">构成</h2>
<p><code>.mobileprovision</code> 包含以下这些字段及内容：</p>
<ul>
<li><code>Name</code>：即 <code>mobileprovision</code> 文件。</li>
<li><code>UUID</code>：即 <code>mobileprivision</code>
文件的真实文件名，是一个唯一标识。</li>
<li><code>TeamName</code>：即 Apple ID 账号名。</li>
<li><code>TeamIdentifier</code>：即 Team Identity。</li>
<li><code>AppIDName</code>：即 explicit/wildcard Apple ID
name（ApplicationIdentifierPrefix）。</li>
<li><code>ApplicationIdentifierPrefix</code>：即完整 App ID
的前缀。</li>
<li><code>ProvisionedDevices</code>：该 <code>.mobileprovision</code>
授权的所有开发设备的 UUID。</li>
<li><code>DeveloperCertificates</code>：该 <code>.mobileprovision</code>
允许对应用程序进行签名的所用证书，不同证书对应不同的开发者。如果使用不在这个列表中的证书进行签名，会出现
<code>code signing failed</code> 相关报错。</li>
<li><code>Entitlements</code>：包含了一组键值对。<code>&lt;key&gt;</code>、<code>&lt;dict&gt;</code>。
<ul>
<li><code>keychain-access-groups</code>：<code>$(AppIdentifierPrefix)</code></li>
<li><code>application-identifier</code>：带前缀的全名。如：<code>$(AppIdentifierPrefix)com.apple.garageband</code></li>
<li><code>com.apple.security.application-groups</code>：App Group
ID。</li>
<li><code>com.apple.developer.team-identifier</code>：同 Team
Identifier。</li>
</ul></li>
</ul>
<h2 id="签名-打包">签名 &amp; 打包</h2>
<p>首先，Xcode 会检查 Signing（entitlement、certificate）配置是否与
Provisioning Profile 相匹配，否则编译会报错。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/signing01.png?x-oss-process=image/resize,w_800" /></p>
<p>其次，Xcode 会检查 Signing &amp; Capabilities 配置的证书是否在本机
Keychain Access 中存在对应的 Public/Private Key
Pair，否则编译会报错。</p>
<p>然后，Xcode 证书在本机 Keychain Access 匹配的 Key Pair
的私钥对应用程序 <strong>内容（Executable Code，resources such as images
and nib files are not signed）</strong>
进行签名（CodeSign）。<strong>注意：Entitlements
文件也会被嵌入到内容中进行签名。</strong></p>
<p>最终，签名、Provisioning Profile、应用程序都会被打包到
<code>.ipa</code> 中</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/provisioning-profile-signing.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="ipa-文件"><code>.ipa</code> 文件</h3>
<p>我们可以用 <code>file</code> 命令来查看 <code>.ipa</code>
文件，从输出结果可以看出它是一个压缩文件。对 <code>.ipa</code>
文件解压后会得到一个 <code>Payload</code> 文件，里面包含了
<code>.app</code> 目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file Solar_200319-1858_r372ce72fe.ipa</span></span><br><span class="line">Solar_200319-1858_r372ce72fe.ipa: Zip archive data, at least v1.0 to extract</span><br></pre></td></tr></table></figure>
<h4 id="app-文件"><code>.app</code> 文件</h4>
<p>以 <code>Solar.app</code> 为例，<code>.app</code>
目录下主要有以下这些类型的文件：</p>
<ul>
<li><strong>可执行文件</strong>：以项目名称命名的可执行文件。如：<code>Solar</code>。</li>
<li><strong><code>xxx.bundle</code></strong>：资源文件，对应不同的 SDK
和 Pod。</li>
<li><strong><code>xxx.lproj</code></strong>：多语言本地化资源文件。每种语言单独定义其资源，包含：图片、文本、Storyboard、Xib
等。</li>
<li><strong><code>Frameworks</code></strong>：包含了 app
使用的第三方静态库、Swift 动态库。</li>
<li><strong><code>Info.plist</code></strong>：app
的相关配置，包括：Bundle Identifier、可执行文件名等。</li>
<li><strong><code>embedded.mobileprovision</code></strong>：供应配置文件（Provisioning
Profile）。</li>
<li><strong><code>_CodeSignature/CodeResources</code></strong>：一个
<code>plist</code>
文件，保存签名时每个文件的哈希值（摘要），这些哈希值并不需要都进行加密，因为非对称加密的性能是比较差的，全部都加密只会拖慢签名和校验的速度。</li>
</ul>
<h2 id="验证-运行">验证 &amp; 运行</h2>
<p>在真机上运行测试包和正式包时，系统对两者的验证有所不同。简而言之，测试包在设备上进行了完整的签名验证；正式包则把验证过程交给了
App Store，App Store
验证通过后重新进行一次签名，设备下载正式包后进行的验证过程则简化很多。</p>
<p>下面我们首先介绍一下测试包的验证过程。</p>
<h3 id="测试包">测试包</h3>
<p>当在设备上安装运行时，会对 App 进行验证。</p>
<p>首先，设备系统会对 App 中的 bundle ID、entitlements、certificate 与
Provisioning Profile 中的 App ID、entitlements、certificates
进行匹配验证，否则无法启动 App。</p>
<p>其次，设备系统使用本地内置的 CA 公钥对 Provisioning Profile 中匹配的
certificate 进行签名验证，从而确认匹配到的证书的合法性。</p>
<p>然后，设备系统使用 Provisioning Profile 中的匹配的，且经过 CA
验证过的 certificate（即打包应用程序的开发者的证书）中取出公钥，对 App
进行签名验证，否则无法启动 App。</p>
<p>最后，设备系统会将设备的 Device ID 与 Provisioning Profile 中的
Devices 的 Device ID 进行匹配，否则无法启动 App。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/provisioning-profile-validation.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="正式包">正式包</h3>
<p>假如你有一台越狱的设备，查看任意一个从 App Store 上下载的
App，你会发现里面没有 <code>embedded.mobileprovision</code> 文件，因为
App Store 已经完成了对 App
的验证（<strong>类似于上述测试包的验证过程</strong>）。当 App
通过验证后，Apple Store 会对 App
进行重新签名，如下图所示。重新签名的内容将不再包含 Provisioning
Profile，最终的 ipa 文件也不包含它。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/app-store-resigning.png?x-oss-process=image/resize,w_800" /></p>
<p>当设备从 App Store 下载 App 时，会直接使用设备上的 CA 公钥对 ipa
进行签名验证，如下图所示。与上述测试包的签名验证相比，正式包的签名验证简化了很多，因为有一部分验证工作已经由
App Store 完成了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/app-store-validation.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>有上述可知，非对称加密贯穿于 iOS
开发之中。当我们在开发中遇到签名、证书相关的问题时，我们只要结合证书幕后的原理，很容易就能找到解决办法。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《图解密码技术》</li>
<li><a href="https://blog.csdn.net/phunxm/article/details/42685597">iOS
Provisioning Profile(Certificate)与Code Signing详解</a></li>
<li><a href="https://www.jianshu.com/p/178104408615">iOS
掉签的概念和原理</a></li>
<li><a href="https://www.jianshu.com/p/e33412176310">iOS 浅谈 APP
ipa包的结构</a></li>
<li><a href="https://www.jianshu.com/p/c33db8e95e6d">ipa
目录结构及构建过程</a></li>
<li><a href="https://juejin.im/entry/5bb831b4f265da0aa52921ca">Library
vs Framework in iOS</a></li>
<li><a
href="https://juejin.im/post/5b90ea53e51d450ea131ef81">iOS语言国际化/本地化-实践总结</a></li>
<li><a href="https://www.jianshu.com/p/5d9955bf4c55">iOS
应用重签名</a></li>
<li><a
href="http://xelz.info/blog/2019/01/11/ios-code-signature-1/">细说iOS代码签名(一)</a></li>
<li><a
href="http://xelz.info/blog/2019/01/11/ios-code-signature-2/">细说iOS代码签名(二)</a></li>
<li><a
href="http://xelz.info/blog/2019/01/11/ios-code-signature-3/">细说iOS代码签名(三)</a></li>
<li><a
href="http://xelz.info/blog/2019/01/11/ios-code-signature-4/">细说iOS代码签名(四)</a></li>
<li><a
href="https://confluence.zhenguanyu.com/pages/viewpage.action?pageId=30677779">搜题
Configurations 的说明</a></li>
<li><a href="https://www.zhihu.com/question/20308474">iOS
开发者中的公司账号与个人账号之间有什么区别？</a></li>
<li><a
href="https://wenghengcong.com/posts/3c332106/">逆向（七）重签名</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS 开发证书</tag>
        <tag>Provisioning Profile</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 图像渲染原理</title>
    <url>/2018/09/25/ios-graphics-render-principle/</url>
    <content><![CDATA[<p>通过 <a
href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a>
一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS
开发过程中图形渲染原理。</p>
<span id="more"></span>
<h1 id="图形渲染技术栈">图形渲染技术栈</h1>
<p>下图所示为 iOS App 的图形渲染技术栈，App 使用
<code>Core Graphics</code>、<code>Core Animation</code>、<code>Core Image</code>
等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系。这些框架都需要通过
OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-rendering-framework-relationship.png" /></p>
<h2 id="ios-渲染框架">iOS 渲染框架</h2>
<h3 id="uikit"><code>UIKit</code></h3>
<p><code>UIKit</code> 是 iOS 开发者最常用的框架，可以通过设置
<code>UIKit</code> 组件的布局以及相关属性来绘制界面。</p>
<p>事实上， <code>UIKit</code>
自身并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（<code>UIView</code>
继承自 <code>UIResponder</code>），事件响应的传递大体是经过逐层的
<strong>视图树</strong> 遍历实现的。</p>
<h3 id="core-animation"><code>Core Animation</code></h3>
<p><code>Core Animation</code> 源自于 <code>Layer Kit</code>，动画只是
<code>Core Animation</code> 特性的冰山一角。</p>
<p><code>Core Animation</code> 是一个复合引擎，其职责是
<strong>尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即
CALayer），这些图层会被存储在一个叫做图层树的体系之中</strong>。从本质上而言，<code>CALayer</code>
是用户所能在屏幕上看见的一切的基础。</p>
<h3 id="core-graphics"><code>Core Graphics</code></h3>
<p><code>Core Graphics</code> 基于 Quartz
高级绘图引擎，主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及
PDF 文档创建，显示和分析。</p>
<p>当开发者需要在 <strong>运行时创建图像</strong> 时，可以使用
<code>Core Graphics</code> 去绘制。与之相对的是
<strong>运行前创建图像</strong>，例如用 Photoshop
提前做好图片素材直接导入应用。相比之下，我们更需要
<code>Core Graphics</code>
去在运行时实时计算、绘制一系列图像帧来实现动画。</p>
<h3 id="core-image"><code>Core Image</code></h3>
<p><code>Core Image</code> 与 <code>Core Graphics</code>
恰恰相反，<code>Core Graphics</code> 用于在
<strong>运行时创建图像</strong>，而 <code>Core Image</code> 是用来处理
<strong>运行前创建的图像</strong> 的。<code>Core Image</code>
框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。</p>
<p>大部分情况下，<code>Core Image</code> 会在 GPU 中完成工作，但如果 GPU
忙，会使用 CPU 进行处理。</p>
<h3 id="opengl-es"><code>OpenGL ES</code></h3>
<p><code>OpenGL ES</code>（OpenGL for Embedded Systems，简称 GLES），是
OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL
是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。</p>
<h3 id="metal"><code>Metal</code></h3>
<p><code>Metal</code> 类似于
<code>OpenGL ES</code>，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过
<code>Metal</code>，但其实所有开发者都在间接地使用
<code>Metal</code>。<code>Core Animation</code>、<code>Core Image</code>、<code>SceneKit</code>、<code>SpriteKit</code>
等等渲染框架都是构建于 <code>Metal</code> 之上的。</p>
<p>当在真机上调试 OpenGL 程序时，控制台会打印出启用 <code>Metal</code>
的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL
命令无缝桥接到 <code>Metal</code> 上，由 <code>Metal</code>
担任真正于硬件交互的工作。</p>
<h1 id="uiview-与-calayer-的关系">UIView 与 CALayer 的关系</h1>
<p>在前面的 <code>Core Animation</code> 简介中提到 <code>CALayer</code>
事实上是用户所能在屏幕上看见的一切的基础。为什么 <code>UIKit</code>
中的视图能够呈现可视化内容？就是因为 <code>UIKit</code> 中的每一个 UI
视图控件其实内部都有一个关联的 <code>CALayer</code>，即
<code>backing layer</code>。</p>
<p>由于这种一一对应的关系，视图层级拥有 <strong>视图树</strong>
的树形结构，对应 <code>CALayer</code> 层级也拥有 <strong>图层树</strong>
的树形结构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-viewtree-layertree.png?x-oss-process=image/resize,w_500" /></p>
<p>其中，视图的职责是 <strong>创建并管理</strong>
图层，以确保当子视图在层级关系中 <strong>添加或被移除</strong>
时，<strong>其关联的图层在图层树中也有相同的操作</strong>，即保证视图树和图层树在结构上的一致性。</p>
<blockquote>
<p>那么为什么 iOS 要基于 UIView 和 CALayer
提供两个平行的层级关系呢？</p>
</blockquote>
<p>其原因在于要做
<strong>职责分离</strong>，这样也能避免很多重复代码。在 iOS 和 Mac OS X
两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么
iOS 有 <code>UIKit</code> 和 <code>UIView</code>，对应 Mac OS X 有
<code>AppKit</code> 和 <code>NSView</code>
的原因。它们在功能上很相似，但是在实现上有着显著的区别。</p>
<blockquote>
<p>实际上，这里并不是两个层级关系，而是四个。每一个都扮演着不同的角色。除了
<strong>视图树</strong> 和 <strong>图层树</strong>，还有
<strong>呈现树</strong> 和 <strong>渲染树</strong>。</p>
</blockquote>
<h2 id="calayer"><code>CALayer</code></h2>
<p>那么为什么 <code>CALayer</code> 可以呈现可视化内容呢？因为
<code>CALayer</code> 基本等同于一个 <strong>纹理</strong>。纹理是 GPU
进行图像渲染的重要依据。</p>
<p>在 <a
href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a>
中提到纹理本质上就是一张图片，因此 <code>CALayer</code> 也包含一个
<code>contents</code> 属性指向一块缓存区，称为
<code>backing store</code>，可以存放位图（Bitmap）。iOS
中将该缓存区保存的图片称为 <strong>寄宿图</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-contents.png?x-oss-process=image/resize,w_500" /></p>
<p>图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成纹理），也支持直接使用纹理（图片）进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是
<strong>手动绘制</strong>；另一种是 <strong>使用图片</strong>。</p>
<p>对此，iOS 中也有两种相应的实现方式：</p>
<ul>
<li>使用图片：<strong>contents image</strong></li>
<li>手动绘制：<strong>custom drawing</strong></li>
</ul>
<h3 id="contents-image">Contents Image</h3>
<p>Contents Image 是指通过 <code>CALayer</code> 的 <code>contents</code>
属性来配置图片。然而，<code>contents</code> 属性的类型为
<code>id</code>。在这种情况下，可以给 <code>contents</code>
属性赋予任何值，app 仍可以编译通过。但是在实践中，如果
<code>content</code> 的值不是 <code>CGImage</code>
，得到的图层将是空白的。</p>
<p>既然如此，为什么要将 <code>contents</code> 的属性类型定义为
<code>id</code> 而非 <code>CGImage</code>。这是因为在 Mac OS
系统中，该属性对 <code>CGImage</code> 和 <code>NSImage</code>
类型的值都起作用，而在 iOS 系统中，该属性只对 <code>CGImage</code>
起作用。</p>
<p>本质上，<code>contents</code> 属性指向的一块缓存区域，称为
<code>backing store</code>，可以存放 bitmap 数据。</p>
<h3 id="custom-drawing">Custom Drawing</h3>
<p>Custom Drawing 是指使用 <code>Core Graphics</code>
直接绘制寄宿图。实际开发中，一般通过继承 <code>UIView</code> 并实现
<code>-drawRect:</code> 方法来自定义绘制。</p>
<p>虽然 <code>-drawRect:</code> 是一个 <code>UIView</code>
方法，但事实上都是底层的 <code>CALayer</code>
完成了重绘工作并保存了产生的图片。下图所示为 <code>-drawRect:</code>
绘制定义寄宿图的基本原理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-bitmap-custom-drawing.png?x-oss-process=image/resize,w_500" /></p>
<ul>
<li><code>UIView</code> 有一个关联图层，即 <code>CALayer</code>。</li>
<li><code>CALayer</code> 有一个可选的 <code>delegate</code> 属性，实现了
<code>CALayerDelegate</code> 协议。<code>UIView</code> 作为
<code>CALayer</code> 的代理实现了 <code>CALayerDelegae</code>
协议。</li>
<li>当需要重绘时，即调用 <code>-drawRect:</code>，<code>CALayer</code>
请求其代理给予一个寄宿图来显示。</li>
<li><code>CALayer</code> 首先会尝试调用 <code>-displayLayer:</code>
方法，此时代理可以直接设置 <code>contents</code> 属性。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)layer;</span><br></pre></td></tr></table></figure></li>
<li>如果代理没有实现 <code>-displayLayer:</code>
方法，<code>CALayer</code> 则会尝试调用
<code>-drawLayer:inContext:</code>
方法。在调用该方法前，<code>CALayer</code> 会创建一个空的寄宿图（尺寸由
<code>bounds</code> 和 <code>contentScale</code> 决定）和一个
<code>Core Graphics</code> 的绘制上下文，为绘制寄宿图做准备，作为
<code>ctx</code> 参数传入。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</span><br></pre></td></tr></table></figure></li>
<li>最后，由 <code>Core Graphics</code> 绘制生成的寄宿图会存入
<code>backing store</code>。</li>
</ul>
<h1 id="core-animation-流水线">Core Animation 流水线</h1>
<p>通过前面的介绍，我们知道了 <code>CALayer</code>
的本质，那么它是如何调用 GPU
并显示可视化内容的呢？下面我们就需要介绍一下 Core Animation
流水线的工作原理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-steps.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，app 本身并不负责渲染，渲染则是由一个独立的进程负责，即
<code>Render Server</code> 进程。</p>
<p>App 通过 IPC 将渲染任务及相关数据提交给
<code>Render Server</code>。<code>Render Server</code>
处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。</p>
<p>Core Animation 流水线的详细过程如下：</p>
<ul>
<li>首先，由 app 处理事件（Handle
Events），如：用户的点击操作，在此过程中 app 可能需要更新
<strong>视图树</strong>，相应地，<strong>图层树</strong>
也会被更新。</li>
<li>其次，app 通过 CPU
完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app
对图层进行打包，并在下一次 RunLoop 时将其发送至
<code>Render Server</code>，即完成了一次 <code>Commit Transaction</code>
操作。</li>
<li><code>Render Server</code> 主要执行 Open GL、Core Graphics
相关程序，并调用 GPU</li>
<li>GPU 则在物理层上完成了对图像的渲染。</li>
<li>最终，GPU 通过 Frame
Buffer、视频控制器等相关部件，将图像显示在屏幕上。</li>
</ul>
<p>对上述步骤进行串联，它们执行所消耗的时间远远超过 16.67
ms，因此为了满足对屏幕的 60 FPS
刷新率的支持，需要将这些步骤进行分解，通过流水线的方式进行并行执行，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-workflow.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="commit-transaction">Commit Transaction</h2>
<p>在 Core Animation 流水线中，app 调用 <code>Render Server</code>
前的最后一步 Commit Transaction 其实可以细分为 4 个步骤：</p>
<ul>
<li><code>Layout</code></li>
<li><code>Display</code></li>
<li><code>Prepare</code></li>
<li><code>Commit</code></li>
</ul>
<h3 id="layout">Layout</h3>
<p><code>Layout</code>
阶段主要进行视图构建，包括：<code>LayoutSubviews</code>
方法的重载，<code>addSubview:</code> 方法填充子视图等。</p>
<h3 id="display">Display</h3>
<p><code>Display</code>
阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的
<code>drawRect:</code> 方法可以自定义 <code>UIView</code>
的显示，其原理是在 <code>drawRect:</code> 方法内部绘制寄宿图，该过程使用
CPU 和内存。</p>
<h3 id="prepare">Prepare</h3>
<p><code>Prepare</code>
阶段属于附加步骤，一般处理图像的解码和转换等操作。</p>
<h3 id="commit">Commit</h3>
<p><code>Commit</code> 阶段主要将图层进行打包，并将它们发送至
<code>Render Server</code>。该过程会递归执行，因为图层和视图都是以树形结构存在。</p>
<h1 id="动画渲染原理">动画渲染原理</h1>
<p>iOS 动画的渲染也是基于上述 Core Animation
流水线完成的。这里我们重点关注 app 与 <code>Render Server</code>
的执行流程。</p>
<p>日常开发中，如果不是特别复杂的动画，一般使用 <code>UIView</code>
Animation 实现，iOS 将其处理过程分为如下三部阶段：</p>
<ul>
<li>Step 1：调用 <code>animationWithDuration:animations:</code>
方法</li>
<li>Step 2：在 Animation Block 中进行
<code>Layout</code>，<code>Display</code>，<code>Prepare</code>，<code>Commit</code>
等步骤。</li>
<li>Step 3：<code>Render Server</code> 根据 Animation
逐帧进行渲染。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-animation-three-stage-process.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/">Getting
Pixels onto the Screen</a>，<a
href="https://segmentfault.com/a/1190000000390012">中文版（iOS
开发：绘制像素到屏幕）</a></li>
<li><a href="https://lision.me/ios-rendering-process/">深入理解 iOS
Rendering Process</a></li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/">iOS Core
Animation: Advanced Techniques中文译本</a></li>
<li><a
href="https://www.jianshu.com/p/c49833c04362">关于drawRect</a></li>
<li>iOS 绘图与动画原理剖析</li>
<li>WWDC 2014 Session 419: Advanced Graphics and Animations for iOS
Apps</li>
</ol>
<h1 id="扩展阅读">扩展阅读</h1>
<ol type="1">
<li><a
href="https://www.jianshu.com/p/ca51c9d3575b">离屏渲染优化详解：实例示范+性能测试</a></li>
<li><a
href="https://github.com/seedante/iOS-Note/wiki/Mastering-Offscreen-Render">Mastering
Offscreen Render</a></li>
<li><a
href="https://download.developer.apple.com/wwdc_2012/wwdc_2012_session_pdfs/session_506__optimizing_2d_graphics_and_animation_performance.pdf">Optimizing
2D Graphics and Animation Performance</a></li>
<li><a
href="http://docs.huihoo.com/apple/wwdc/2012/session_240__polishing_your_interface_rotations.pdf">Polishing
Your Interface Rotation Animations</a></li>
<li><a
href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/421_core_animation_essentials.pdf">Core
Animation Essentials</a></li>
<li><a
href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/121_understanding_uikit_rendering.pdf">Understanding
UIKit Rendering</a></li>
<li><a
href="http://www.lukeparham.com/blog/2016/5/25/ios-rendering-the-ui">iOS:
Rendering the UI</a></li>
<li><a
href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect">iOS
事件处理机制与图像渲染过程</a></li>
<li><a href="https://www.jianshu.com/p/d05d19f70bac">iOS
动画篇：核心动画</a></li>
<li><a href="https://developer.samsung.com/game/gpu-framebuffer">GPU
Framebuffer Memory: Understanding Tiling</a></li>
<li><a
href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS
保持界面流畅的技巧</a></li>
<li><a href="https://www.jianshu.com/p/456c961164d9">OpenGL ES
框架详细解析（八） —— OpenGL ES 设计指南</a></li>
<li><a href="https://www.jianshu.com/p/748f9abafff8">iOS
开发-视图渲染与性能优化</a></li>
<li><a
href="https://segmentfault.com/a/1190000004164291#articleHeader5">iOS
视图、动画渲染机制探究</a></li>
<li><a
href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect">iOS
事件处理机制与图像渲染过程</a></li>
<li><a
href="https://www.zybuluo.com/qidiandasheng/note/494700">iOS界面渲染流程</a></li>
<li><a
href="http://blog.handy.wang/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/">界面渲染的整体流程</a></li>
<li><a
href="https://www.cnblogs.com/feng9exe/p/6723398.html">iOS图像处理之Core
Graphics和OpenGL ES初见</a></li>
<li>WWDC 2012 Session 506: Optimizing 2D Graphics and Animations
Performances</li>
<li>WWDC 2011 Session 421: Core Animation Essentials</li>
<li>WWDC 2011 Session 129: Practical Drawing for iOS Developers</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Core Animation Pipeline</tag>
        <tag>Render Server</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 网络(2)——AFNetworking</title>
    <url>/2019/08/06/ios-network-afnetworking/</url>
    <content><![CDATA[<p>在 <a
href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/">《iOS
网络——NSURLSession》</a>中，我们介绍了 <code>NSURLSession</code>
的架构及工作原理。本文，我们通过阅读 <a
href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>
源代码（版本号：<code>2.6.3</code>），来介绍其设计架构。</p>
<span id="more"></span>
<h1 id="afnetwoking-概述">AFNetwoking 概述</h1>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/afnetworking-logo.png?x-oss-process=image/resize,w_800" /></p>
<p>AFNetworking 是一套适用于 iOS、macOS、watchOS、tvOS
的网络库。AFNetworking 2.0 之后的版本构建在基于
<code>NSURLSession</code> 的 Foundation URL 加载系统之上。AFNetworking
扩展了 Cocoa
内置的强大的高级网络抽象，采用模块化设计，功能丰富，是最广泛使用的开源项目之一。</p>
<h1 id="afnetworking-架构">AFNetworking 架构</h1>
<p>AFNetworking 框架主要包含两部分：</p>
<ul>
<li>AFNetworking 核心功能</li>
<li>UIKit+AFNetworking 分类功能</li>
</ul>
<p>这里我们主要介绍 AFNetworking
的核心功能，其整体的架构如下图所示。AFNetworking 主要包含了 6 个类：</p>
<ul>
<li><strong><code>AFURLSessionManager</code></strong>：AFNetworking
的核心类。</li>
<li><strong><code>AFHTTPSessionManager</code></strong>：<code>AFURLSessionManager</code>
的子类，主要用于 HTTP 请求。</li>
<li><strong><code>AFURLRequestSerialization</code></strong>：请求序列化器，用于将参数编码为查询字符串、HTTP
正文，并根据需要设置合适的 HTTP 头部字段。</li>
<li><strong><code>AFURLResponseSerialization</code></strong>：响应序列化器，用于将数据解码为对象，还可以对传入的响应和数据进行验证。</li>
<li><strong><code>AFSecurityPolicy</code></strong>：通过安全连接评估服务器对固定的
X.509 证书和公钥的信任。</li>
<li><strong><code>AFNetworkReachabilityManager</code></strong>：监视网络可达性。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/afnetwoking-overview.png?x-oss-process=image/resize,w_800" /></p>
<p>下面我们来介绍一下 AFNetworking
的核心——<code>AFURLSessionManager</code>。</p>
<h2 id="afurlsessionmanager">AFURLSessionManager</h2>
<p>下图所示为 <code>AFURLSessionManager</code>
的内部结构。下面，我们将以该结构图为指导，介绍
<code>AFURLSessionManager</code> 的工作原理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/afnetwoking-afurlsessionmanager.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="持有属性">持有属性</h3>
<p>我们首先浏览一下 <code>AFURLSessionManager</code> 所持有的属性。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 外部公开的属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span></span></span><br><span class="line"><span class="comment">/// 管理的 Session</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="comment">/// 代理回调执行的队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"><span class="comment">/// 使用 dataTaskWithRequest:success:failure: 创建，使用 GET 或 POST 执行的 data task 的响应。默认值是 AFJSONResponseSerializer</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"><span class="comment">/// Session 使用的安全策略，用于评估服务器对安全连接的信任程度。AFURLSessionManager 使用默认策略 defaultPolicy</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"><span class="comment">/// 网络可达性管理器。AFURLSessionManager 默认使用 sharedManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的所有类型的任务，如：data，upload，download 等</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的 data 任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的 upload 任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的 download 任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class="line"><span class="comment">/// completionBlock 执行所在的队列。如果是 NULL，则在主线程执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> completionQueue;</span><br><span class="line"><span class="comment">/// completionBlock 执行所在的 group。如果是 NULL，则在一个私有的 group 中执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) dispatch_group_t completionGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// 内部私有的属性</span><br><span class="line">@interface AFURLSessionManager ()</span><br><span class="line">@property (readwrite, nonatomic, strong) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSOperationQueue *operationQueue;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line">@property (readonly, nonatomic, copy) NSString *taskDescriptionForSessionTasks;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSLock *lock;</span><br><span class="line"></span><br><span class="line">/// ---------------------</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession AF_API_UNAVAILABLE(macos);</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line">#if AF_CAN_INCLUDE_SESSION_TASK_METRICS</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionTaskDidFinishCollectingMetricsBlock taskDidFinishCollectingMetrics;</span><br><span class="line">#endif</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line">@property (readwrite, nonatomic, copy) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<p>首先，<code>AFURLSessionManager</code> 对象持有一个
<code>NSURLSessionConfiguration</code>
对象（会话配置对象）。使用会话配置对象即可初始化并持有一个
<code>NSURLSession</code>
对象（会话对象）。会话对象的初始化过程如下代码所示： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_session) &#123;</span><br><span class="line">            _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意，初始化会话对象后，<strong>会话对象将
<code>AFURLSessionManager</code>
设置成自己的代理</strong>。因此，<code>AFURLSessionManager</code>
需要实现相关协议所声明的那些方法。这些协议有：</p>
<ul>
<li><code>NSURLSessionDelegate</code></li>
<li><code>NSURLSessionTaskDelegate</code></li>
<li><code>NSURLSessionDataDelegate</code></li>
<li><code>NSURLSessionDownloadDelegate</code></li>
</ul>
<p>为了能够让开发者实现自定义处理会话级事件和任务级事件，<code>AFURLSessionManager</code>
提供了大量设置回调的方法，基本可以覆盖到协议所声明的每一个方法。这些回调被
<code>AFURLSessionManager</code>
在内部持有，只有在对应的协议方法被调用时，回调方法才会被执行。</p>
<h3 id="进度管理">进度管理</h3>
<p><code>AFURLSessionManager</code>
作为会话对象的代理，基本可以处理所有任务对象。但是，对于上传任务、下载任务进行进度管理，使用
<code>AFURLSessionManager</code>
来管理是较为繁琐的，也是不合理的。主要有以下几点原因：</p>
<ul>
<li>在上传任务和下载任务的整个生命周期中都需要持有一个进度对象
<code>NSProgress</code>。</li>
<li>在下载任务的整个生命周期中还需要持有一个接收数据对象，用于持续接收数据。</li>
<li><code>AFURLSessionManager</code>
主要用于管理会话，根据职责单一原则，它不应该管理任务对象的具体细节。</li>
</ul>
<p>因此，AFNetworking 提供了
<code>AFURLSessionManagerTaskDelegate</code>
这样一个类来管理特定任务的进度、数据。</p>
<p><code>AFURLSessionManager</code> 内部维护了一个可变字典属性
<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>，以任务对象的标识符
<code>taskIdentifier</code> 作为键，以
<code>AFURLSessionManagerTaskDelegate</code>
对象作为值。在初始化任务对象时，就绑定一个
<code>AFURLSessionManagerTaskDelegate</code>
对象，以处理进度、下载数据。具体代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据特定 request 创建一个 NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建任务对象</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为任务对象设置代理对象、上传进度回调、下载进度回调、完成回调</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个 AFURLSessionManagerTaskDelegate 对象，用以处理进度、下载数据</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来标识任务对象所属的 SessionManager</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 NSURLSessionTask &lt;-&gt; AFURLSessionManagerTaskDelegate 的映射关系</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AFURLSessionManagerTaskDelegate</code>
主要实现了以下这些协议方法。在这些方法内实现进度管理、下载管理。<code>AFURLSessionManager</code>
虽然也实现了这些协议，但是最终还是会调用
<code>AFURLSessionManagerTaskDelegate</code> 中的实现。</p>
<ul>
<li><code>NSURLSessionTaskDelegate</code>
<ul>
<li><code>URLSession:task:didCompleteWithError:</code></li>
<li><code>URLSession:task:didFinishCollectingMetrics:</code></li>
</ul></li>
<li><code>NSURLSessionDataDelegate</code>
<ul>
<li><code>URLSession:dataTask:didReceiveData:</code></li>
<li><code>URLSession:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code></li>
</ul></li>
</ul>
<h3 id="通知转发">通知转发</h3>
<p><code>NSURLSession</code>
定义了一系列通知，为了提供更完美的封装，<code>AFURLSessionManager</code>
捕获了这些通知，将它们转换成自己所定义的通知后，再进行转发。</p>
<p>这里，就用到了任务对象的 <code>taskDescription</code>
属性。<code>taskDescription</code> 属性描述了该任务对象所属的 Session
Manager。因为应用程序中可能会初始化多个
<code>AFURLSessionManager</code>。Session Manager
只有在捕获到它所管理的任务对象发出的通知后才会进行封装和转发。如：</p>
<ul>
<li><code>AFNetworkingTaskDidResumeNotification</code></li>
<li><code>AFNetworkingTaskDidSuspendNotification</code></li>
</ul>
<h2 id="afhttpsessionmanager">AFHTTPSessionManager</h2>
<p>接下来，我们再来介绍一下 <code>AFURLSessionManager</code>
的子类——<code>AFHTTPSessionManager</code>。</p>
<p>首先，我们来看一下 <code>AFHTTPSessionManager</code> 所特有的属性。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPSessionManager</span> : <span class="title">AFURLSessionManager</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> *baseURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>由于，<code>AFHTTPSessionManager</code> 主要用于 HTTP 请求，所以它为
HTTP 请求提供了一个请求序列化器和一个响应序列化器，并分别设置默认值为
HTTP 和 JSON。</p>
<p>除此之外，<code>AFHTTPSessionManager</code> 还封装了
<code>AFURLSessionManager</code>
的一些复杂的任务对象初始化方法，并提供了一些非常简单的便利方法，用以提供各种
HTTP 请求。如下所示： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                            parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                               headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                              progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgress</span><br><span class="line">                               success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                               failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)HEAD:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line">                                </span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">              constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                               progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgress</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line">                                </span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)PUT:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                            parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                               headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                               success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                               failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)PATCH:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                              parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                 headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                 success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                 failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)DELETE:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                               parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                  headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                  success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                  failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure></p>
<h1 id="结论">结论</h1>
<p>总而言之，AFNetworking 实际上只是对 NSURLSession 高度地封装,
提供一些简单易用的 API 方便我们在 iOS
开发中发出网络请求并在其上更快地构建网络层组件并提供合理的接口。</p>
<p>后面，有机会我们继续深入了解一下 AFNetworking
的其他辅助类以及分类功能。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a></li>
<li><a href="https://draveness.me/afnetworking1">AFNetworking
概述（一）</a></li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 网络(1)——NSURLSession</title>
    <url>/2019/07/21/ios-network-nsurlsession/</url>
    <content><![CDATA[<p>最近公司针对刚入职的应届毕业生开展了一个的“新牛计划”，目的是让他们能够在一个月的时间内从零基础成长为
iOS 开发新手。</p>
<span id="more"></span>
<p>在这个过程中，我们需要承担讲师的角色。因此，我们对 iOS
开发的知识体系进行了划分，而我则负责讲解其中的 GCD
和网络相关部分。为此，我也算是学习了一下 iOS
开发所涉及到的一些网络知识，也学习了一些开源框架，包括：AFNetworking、YTKNetwork、CocoaAsyncSocket。这里，我首先对
NSURLSession
做一些相关总结。后续，将陆续贴出相关开源框架的学习心得。</p>
<h1 id="nsurlsession-概述">NSURLSession 概述</h1>
<p>WWDC 2013，苹果对基于 <code>NSURLConnection</code> 的 Foundation URL
加载系统进行了重构，推出了新一代基于 <code>NSURLSession</code> 的
Foundation URL 加载系统，并将其首先应用在了 iOS 7 和 Mac OS X 10.9
Mavericks 系统之中。</p>
<h1 id="nsurlsession-架构">NSURLSession 架构</h1>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsession-overview.png?x-oss-process=image/resize,w_800" /></p>
<p><code>NSURLSession</code> 这个名字，实际上是指代 Foundation 框架的
URL 加载系统中一些列相关的类和协议。上图所示为 <code>NSURLSession</code>
的系统架构图，主要由三个类构成：</p>
<ul>
<li><strong><code>NSURLSession</code></strong>
<ul>
<li>负责请求/响应的关键对象，使用 <code>NSURLSessionConfiguration</code>
配置对象进行创建。</li>
<li>在请求/响应的执行过程中调用 <code>NSURLSessionTaskDelegate</code>
所定义的各种代理方法。</li>
</ul></li>
<li><strong><code>NSURLSessionConfiguration</code></strong>
<ul>
<li>用于对 <code>NSURLSession</code> 对象进行初始化，可以配置
<strong>可用网络</strong>、<strong>Cookie</strong>、<strong>安全性</strong>、<strong>缓存策略</strong>、<strong>自定义协议</strong>、<strong>启动事件</strong>
等选项，以及用于移动设备优化的相关选项。</li>
<li>几乎可以配置任何选项。</li>
</ul></li>
<li><strong><code>NSURLSessionTask</code></strong>
<ul>
<li>一个抽象类，其子类可以创建不同类型的任务（Task），如：下载、上传、获取数据（如：JSON
或 XML）。</li>
<li>在特定 URL Session 中执行。</li>
</ul></li>
</ul>
<p>结合上述系统结构图，我们可以将 <code>NSURLSession</code>
中的类分为以下 6 种（如下图所示）：</p>
<ul>
<li><strong>URL 加载</strong>（URL Loading）</li>
<li><strong>配置管理</strong>（Configuration Management）</li>
<li><strong>缓存管理</strong>（Cache Policy）</li>
<li><strong>Cookie 存储</strong>（Cookie Storage）</li>
<li><strong>认证和证书</strong>（Authentication and Credentials）</li>
<li><strong>协议支持</strong>（Protocol Support）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/url-loading-system-classes.png?x-oss-process=image/resize,w_800" /></p>
<p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据
<strong>缓存策略（Cache Policy）</strong> 以及
<strong>可用性（availability）</strong>
的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应，以便将来的请求可以使用。</p>
<p>在一个请求被发送到服务器过程中，服务器可能会发出
<strong>鉴权查询（Authorization Challenge）</strong>，这可以由共享的
Cookie 或 <strong>证书存储（Credential Storage）</strong>
来自动响应，或者由被委托对象来响应。此外，发送中的请求也可以被注册的
<code>NSURLProtocol</code> 对象所拦截，以便在必要时改变其加载行为。</p>
<p>下面我们依次来详细介绍 URL 加载系统中的 3 个主要类：
<code>NSURLSessionTask</code>、<code>NSURLSession</code>、<code>NSURLSessonConfiguration</code>。在
<code>NSURLSessionConfiguration</code> 中，我们将对缓存策略、Cookie
存储、自定义协议等内容稍作介绍。</p>
<h2 id="nsurlsessiontask">NSURLSessionTask</h2>
<p><code>NSURLSessionTask</code> 是一个抽象类，其包含如下 3
个实体子类。这 3 个子类封装了 3
个最基本的网络任务：<strong>获取数据</strong>（如：JSON 或
XML）、<strong>上传文件</strong>、<strong>下载文件</strong>。</p>
<ul>
<li><code>NSURLSessionDataTask</code></li>
<li><code>NSURLSessionUploadTask</code></li>
<li><code>NSURLSessionDownloadTask</code></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-class.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为这些类之间的继承关系。对于
<code>NSURLSessionDataTask</code>，服务器会有响应数据；而对于上传请求，服务器也会有响应数据，所以
<code>NSURLSessionUploadTask</code> 继承自
<code>NSURLSessionDataTask</code>。<code>NSURLSessionDownloadTask</code>
完成时，会带回已下载文件的一个临时的文件路径。</p>
<p>关于 <code>NSURLSessionTask</code>
的数据返回方式，主要有两种方式：</p>
<ul>
<li><strong><code>completionHandler</code> 回调</strong></li>
<li><strong><code>NSURLSessionDelegate</code> 代理</strong></li>
</ul>
<p>通过 <code>completionHandler</code>
回调将会创建一个隐式的代理（delegate），从而替代该 Task 原来的代理 ——
Session。</p>
<p>对于需要 override 原有 Session Task
的代理的默认行为的情况，我们需要使用不带 <code>completionHandler</code>
版本。</p>
<p>需要注意的是，<code>NSURLSessionTask</code>
及其子类都有着各自的代理协议，它们之间也存在着如下图所示的继承关系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-delegate.png?x-oss-process=image/resize,w_800" /></p>
<ul>
<li><code>NSURLSessionDelegate</code>：定义了网络请求最基础的代理方法。作为所有代理的基类。</li>
<li><code>NSURLSessionTaskDelegate</code>：定义了网络请求任务相关的代理方法。</li>
<li><code>NSURLSessionDownloadDelegate</code>：定义了下载任务相关的代理方法，如：下载进度等</li>
<li><code>NSURLSessionDataDelegate</code>：定义了普通数据任务和上传任务相关的代理方法。</li>
</ul>
<p>下面简要介绍一下这三个子类。</p>
<h3 id="nsurlsessiondatatask">NSURLSessionDataTask</h3>
<p><code>NSURLSessionDataTask</code> 主要用于
<strong>读取服务端的简单数据</strong>，如：JSON、XML 数据。</p>
<p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSURL 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure></p>
<p><strong>CompletionHandler</strong> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p>
<h3 id="nsurlsessionuploadtask">NSURLSessionUploadTask</h3>
<p><code>NSURLSessionUploadTask</code> 主要用于
<strong>向服务器发送文件类型的数据</strong>。</p>
<p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建，上传时指定文件源</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建，上传时指定数据源   </span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure></p>
<p><strong>CompletionHandler</strong> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p>
<h3 id="nsurlsessiondownloadtask">NSURLSessionDownloadTask</h3>
<p><code>NSURLSessionDownloadTask</code> 主要用于
<strong>文件下载</strong>，它针对大文件的网络请求做了更多的处理，如：下载进度、断点续传等。</p>
<p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 NSURL 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url;    </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用之前已经下载的数据来创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData;</span><br></pre></td></tr></table></figure></p>
<p><strong>CompletionHandler</strong> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p>
<h2 id="nsurlsession">NSURLSession</h2>
<p><code>NSURLSession</code> 是负责请求/响应的关键对象，使用
<code>NSURLSessionConfiguration</code> 配置对象进行创建。</p>
<p><code>NSURLSession</code> 本身并不会进行请求，而是通过创建 Task
的形式来进行网络请求。同一个 <code>NSURLSession</code> 可以创建多个
Task，并且这些 Task 之间的 Cache 和 Cookie 是共享的。</p>
<p><code>NSURLSession</code>
在管理请求/响应的过程中会调用相关的代理方法。这些代理方法主要分两类：</p>
<ul>
<li><strong>Session
的委托对象实现的代理方法（<code>NSURLSessionDelegate</code>
定义的方法）</strong>
<ul>
<li>主要用于处理连接层问题，如：服务器信任、客户端证书认证、NTLM 和
Kerberos 协议等问题</li>
</ul></li>
<li><strong>Task
的委托对象实现的代理方法（<code>NSURLSessionTaskDelegate</code>
及其子协议定义的方法）</strong>
<ul>
<li>主要用于处理以网络请求为基础的问题，如：Basic，Digest，<strong>代理身份验证（Proxy
Authentication）</strong> 等。</li>
</ul></li>
</ul>
<h2 id="nsurlsessionconfiguration">NSURLSessionConfiguration</h2>
<p><code>NSURLSessionConfiguration</code> 对象用于对
<code>NSURLSession</code> 进行初始化。</p>
<p><code>NSURLSessionConfiguration</code> 对以前
<code>NSMutableURLRequest</code>
所提供的网络请求层的设置选项进行了扩充，提供给开发者相当大的灵活性和控制权。从指定可用网络，到
cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，可以发现使用
<code>NSURLSessionConfiguration</code>
可以找到几乎任何想要进行配置的选项。</p>
<p><code>NSURLSession</code> 在初始化时会把配置它的
<code>NSURLSessionConfiguration</code>
对象进行一次深拷贝，并保存到自己的 <code>configuration</code>
属性中，而且这个属性是只读的。也就是说，<code>configuration</code>
只在初始化时被读取一次，之后都是不会变化的。</p>
<h3 id="初始化">初始化</h3>
<p><code>NSURLSessionConfiguration</code> 有三个类工厂方法：</p>
<ul>
<li><strong><code>+ defaultSessionConfiguration</code></strong>
<ul>
<li>返回一个标准的配置，具有共享 <code>NSHTTPCookieStorage</code>、共享
<code>NSURLCache</code>、共享 <code>NSURLCredentialStorage</code>。</li>
</ul></li>
<li><strong><code>+ ephemeralSessionConfiguration</code></strong>
<ul>
<li>返回一个预设的配置，该配置中不会对缓存、Cookie和证书进行持久性存储。这对于实现类似秘密浏览这种功能来说是很理想的。</li>
</ul></li>
<li><strong><code>+ backgroundSessionConfiguration:(NSString *)identifier</code></strong>
<ul>
<li>创建一个后台 Session。后台 Session 不同于普通 Session，后台 Session
可以在应用程序挂起、退出或崩溃的情况下进行上传/下载任务。初始化时指定的标识符，可用于向任何可能在进程外恢复后台传输的
<strong>守护进程（daemon）</strong> 提供上下文。</li>
</ul></li>
</ul>
<h3 id="属性配置">属性配置</h3>
<p><code>NSURLSessionConfiguration</code>
拥有数十个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。</p>
<h4 id="常规配置">常规配置</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *HTTPAdditionalHeaders</span><br></pre></td></tr></table></figure>
<p><code>HTTPAdditionalHeaders</code> 为基于 configuration 的 Session
生成的所有 Task 中的 <code>NSRULRequest</code>
对象添加额外的请求头部字段。默认为空。</p>
<p><code>NSURLSession</code> 默认为 <code>NSURLRequest</code>
对象添加了如下请求头部字段：</p>
<ul>
<li><code>Authorization</code></li>
<li><code>Connection</code></li>
<li><code>Host</code></li>
<li><code>Proxy-Authenticate</code></li>
<li><code>Proxy-Authorization</code></li>
<li><code>WWW-Authenticate</code></li>
</ul>
<p>如果在 <code>HTTPAdditionalHeaders</code> 自定义的头部字段与
<code>NSURLRequest</code> 对象重复了，则优先使用
<code>NSURLRequest</code> 对象中的请求头部字段。</p>
<p>利用 <code>HTTPAddtionalHeaders</code>
可以添加如下这些请求头部字段：</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>User-Agent</code></li>
<li>...</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType</span><br></pre></td></tr></table></figure>
<p>指定网络传输类型。可以让操作系统快速响应，提高传输质量，延长电池寿命等。大多数应用程序都不需要设置。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> allowsCellularAccess</span><br></pre></td></tr></table></figure>
<p>是否使用蜂窝网络。默认是 <code>YES</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForRequest</span><br></pre></td></tr></table></figure>
<p>指定请求的超时间隔。默认为 60s。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForResource</span><br></pre></td></tr></table></figure>
<p>指定资源的超时间隔。默认是7天。</p>
<h4 id="cookie-策略">Cookie 策略</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSHTTPCookieStorage</span> *HTTPCookieStorage;</span><br></pre></td></tr></table></figure>
<p>存储了 Session 所使用的 Cookie。默认情况下会使用
<code>NSHTTPCookieStorage</code> 的
<code>+ sharedHTTPCookieStorage</code> 单例。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> HTTPShouldSetCookies;</span><br></pre></td></tr></table></figure>
<p>指定了请求是否应该使用 Session 存储的 Cookie，即
<code>HTTPCookieStorage</code> 属性的值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSHTTPCookieAcceptPolicy</span> HTTPCookieAcceptPolicy;</span><br></pre></td></tr></table></figure>
<p>决定了什么情况下 Session 应该接受从服务器发出的 Cookie。</p>
<h4 id="安全策略">安全策略</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSURLCredentialStorage</span> *URLCredentialStorage;</span><br></pre></td></tr></table></figure>
<p>存储了 Session 所使用的证书。默认情况下会使用
<code>NSURLCredentialStorage</code> 的
<code>+ sharedCredentialStorage</code> 单例。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMaximumSupportedProtocol;</span><br><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMinimumSupportedProtocol;</span><br></pre></td></tr></table></figure>
<p>两者确定 Session 是否支持 SSL 协议。</p>
<h4 id="缓存策略">缓存策略</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSURLCache</span> *URLCache;</span><br></pre></td></tr></table></figure>
<p>Session 使用的缓存。默认情况下会使用 <code>NSURLCache</code> 的
<code>+ sharedURLCache</code> 单例。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestCachePolicy</span> requestCachePolicy;</span><br></pre></td></tr></table></figure>
<p>指定了一个请求的缓存响应应该在什么时候返回。</p>
<h4 id="后台传输">后台传输</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *identifier</span><br></pre></td></tr></table></figure>
<p>仅当使用 <code>backgroundSessionConfigurationWithIdentifier:</code>
方法创建配置对象时，才会设置此属性的值。<code>identifier</code> 唯一标识
<strong>后台会话</strong> 对象。</p>
<p>如果应用程序在后台任务进行传输时终止，可以使用
<code>identifier</code> 在应用程序重新启动时，重新创建
<code>configuration</code> 和 <code>session</code> 对象与
之前传输进行关联。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> sessionSendsLaunchEvents;</span><br></pre></td></tr></table></figure>
<p>设置传输结束时是否应该在后台恢复或启动应用程序。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">getter</span>=isDiscretionary) <span class="type">BOOL</span> discretionary;</span><br></pre></td></tr></table></figure>
<p>设置后台 Task 是否可以由系统进行调度，从而获得最佳性能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldUseExtendedBackgroundIdleMode;</span><br></pre></td></tr></table></figure>
<p>设置应用程序切换至后台时是否保持打开 TCP 连接。</p>
<h4 id="自定义协议">自定义协议</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;Class&gt; *protocolClasses;</span><br></pre></td></tr></table></figure>
<p>用来配置特定某个 Session 所使用的自定义协议（该协议是
<code>NSURLProtocol</code> 的子类）的数组。</p>
<h4 id="多路径-tcp">多路径 TCP</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLSessionMultipathServiceType</span> multipathServiceType;</span><br></pre></td></tr></table></figure>
<p>指定通过 Wi-Fi 和 蜂窝网络传输数据的多路径 TCP 的连接策略。</p>
<h4 id="http-策略与代理">HTTP 策略与代理</h4>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> HTTPMaximumConnectionsPerHost;</span><br></pre></td></tr></table></figure>
<p>用于限制连接到特定主机的数量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> HTTPShouldUsePipelining;</span><br></pre></td></tr></table></figure>
<p>用于开启 HTTP 流水线（HTTP
pipelining），可以显着减少请求的加载时间，但是由于没有被服务器广泛支持，默认是
<code>NO</code> 的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *connectionProxyDictionary;</span><br></pre></td></tr></table></figure>
<p>指定了 Session 连接中的代理服务器</p>
<h1 id="nsurlsession-使用">NSURLSession 使用</h1>
<p><code>NSURLSession</code> 的使用有如下几个步骤：</p>
<ol type="1">
<li>创建会话：基于 <code>NSURLSessionConfiguration</code> 对象创建
<code>NSURLSession</code> 对象</li>
<li>创建任务：基于 <code>NSURLSession</code> 对象创建
<code>NSURLSessionTask</code> 对象</li>
<li>执行任务：执行 <code>NSURLSessionTask</code> 对象</li>
</ol>
<h2 id="创建会话">创建会话</h2>
<p>会话的创建方式有三种： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 直接创建，使用默认的 NSURLSessionConfiguration 配置</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置后创建，先初始化一个 NSURLSessionConfiguration 对象</span></span><br><span class="line">[<span class="built_in">NSURLSession</span> sessionWithConfiguration:defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置加代理获得</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]</span><br><span class="line">                                                      delegate:<span class="keyword">self</span></span><br><span class="line">                                                 delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br></pre></td></tr></table></figure></p>
<h2 id="创建任务">创建任务</h2>
<p>任务的创建在上文介绍 <strong><code>NSURLSessionTask</code></strong>
时已经提到。这里不做赘述。</p>
<h2 id="执行任务">执行任务</h2>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure>
<h2 id="使用示例">使用示例</h2>
<h3 id="get-请求">GET 请求</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建会话</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建任务</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://www.xxx.com/login?username=myName&amp;pwd=myPsd&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">// 打印解析后的json数据</span></span><br><span class="line">    <span class="comment">// NSLog(@&quot;%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行任务</span></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure>
<h3 id="post-请求">POST 请求</h3>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建会话</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建任务</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://www.xxx.com/login&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建请求对象里面包含请求体</span></span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">request.HTTPMethod = <span class="string">@&quot;POST&quot;</span>;</span><br><span class="line">request.HTTPBody = [<span class="string">@&quot;username=myName&amp;pwd=myPsd&quot;</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">// 打印解析后的json数据</span></span><br><span class="line">    <span class="comment">// NSLog(@&quot;%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行任务</span></span><br><span class="line"> [task resume];</span><br></pre></td></tr></table></figure>
<h1 id="结论">结论</h1>
<p>iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对
<code>NSURLConnection</code>
进行深思熟虑后的一个自然而然的进化。尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是
<code>NSURLSession</code>
仍然是实现更高级别网络功能的一个强大的基础框架。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc">URL
Loading System</a></li>
<li><a href="https://juejin.im/post/5a69f8366fb9a01cb42c90bc">URL
Loading System 概览</a></li>
<li><a href="https://juejin.im/entry/58aacabcac502e006973ce03">iOS
NSURLSession 详解</a></li>
<li><a
href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started">URLSession
Tutorial: Getting Started</a></li>
<li><a
href="https://developer.apple.com/documentation/foundation/nsmutableurlrequest?language=objc">NSMutableURLRequest</a></li>
<li><a href="https://objccn.io/issue-5-4/">从 NSURLConnection 到
NSURLSession</a></li>
<li><a
href="https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/">From
NSURLConnection to NSURLSession</a></li>
</ol>
<div data-align="center">
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsession-overview.png?x-oss-process=image/resize,w_600" />
</div>
<div data-align="center">
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/url-loading-system-classes.png?x-oss-process=image/resize,w_600" />
</div>
<div data-align="center">
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-class.png?x-oss-process=image/resize,w_600" />
</div>
<div data-align="center">
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-delegate.png?x-oss-process=image/resize,w_600" />
</div>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLSession</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 网络(3)——YTKNetwork</title>
    <url>/2019/08/20/ios-network-ytknetwork/</url>
    <content><![CDATA[<blockquote>
<p>注意：在阅读本文之前建议先阅读<a
href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/">《iOS
网络——NSURLSession》</a>和<a
href="http://chuquan.me/2019/08/06/ios-network-afnetworking/">《iOS
网络——AFNetworking》</a>。</p>
</blockquote>
<span id="more"></span>
<p>在<a
href="http://chuquan.me/2019/08/06/ios-network-afnetworking/">《iOS
网络——AFNetworking》</a>一文中我们介绍了基于 <code>NSURLSession</code>
进行封装的 AFNetworking 的核心功能原理。本文，我们进一步介绍基于
AFNetworking 进行封装的 YTKNetwork 开源框架。本文，我们通过阅读
YTKNetwork 源代码（版本号：<code>2.0.4</code>）。</p>
<h1 id="ytknetwork-概述">YTKNetwork 概述</h1>
<p>YTKNetwork 是猿题库技术团队开源的一个网络请求框架，内部封装了
AFNetworking。YTKNetwork 实现了一套高层级的
API，提供更高层次的网络访问抽象。目前，猿题库公司的所有产品的 iOS
客户端都使用了
YTKNetwork，包括：猿题库、小猿搜题、猿辅导、小猿口算、斑马系列等。</p>
<h1 id="ytknetwork-架构">YTKNetwork 架构</h1>
<p>YTKNetwork 开源框架主要包含 3 个部分：</p>
<ul>
<li>YTKNetwork 核心功能</li>
<li>YTKNetwork 链式请求</li>
<li>YTKNetwork 批量请求</li>
</ul>
<p>其中，链式请求和批量请求都是基于 YTKNetwork
的核心功能实现的。下面我们分别进行介绍。</p>
<h2 id="ytknetwork-核心功能">YTKNetwork 核心功能</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-overview.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示为 YTKNetwork 核心功能的类的引用关系示意图。YTKNetwork
核心功能的基本思想是：</p>
<ul>
<li><strong>把每一个网络请求封装成一个对象，每个请求对象继承自
<code>YTKBaseRequest</code> 类</strong>。</li>
<li><strong>使用 <code>YTKNetworkAgent</code> 单例对象持有一个
<code>AFHTTPSessionManager</code> 对象来管理所有请求对象</strong>。</li>
</ul>
<p>YTKNetwork 核心功能主要涉及到 3 个类：</p>
<ul>
<li><code>YTKBaseRequest</code></li>
<li><code>YTKNetworkConfig</code></li>
<li><code>YTKNetworkAgent</code></li>
</ul>
<p>下面我们分别进行介绍。</p>
<h3 id="ytkbaserequest">YTKBaseRequest</h3>
<p><code>YTKBaseRequest</code>
类用于表示一个请求对象，它提供了一系列属性来充分表示一个网络请求。我们可以看一下它所定义的属性：
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBaseRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/// 请求相关属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLSessionTask</span> *requestTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *currentRequest;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *originalRequest;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSHTTPURLResponse</span> *response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 响应相关属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> responseStatusCode;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *responseHeaders;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *responseData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *responseString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> responseObject;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> responseJSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 异常</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 状态</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="type">BOOL</span> cancelled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="type">BOOL</span> executing;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 标识符，默认是 0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> tag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 附加信息，默认是 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;YTKRequestDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 成功/失败回调</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock successCompletionBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock failureCompletionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于在 POST 请求时构建 HTTP 主体。默认是 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFConstructingBlock constructingBodyBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于下载任务时指定本地下载路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *resumableDownloadPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于跟踪下载进度的回调</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFURLSessionTaskProgressBlock resumableDownloadProgressBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YTKRequestPriority requestPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// YTKRequestAccessory 是一个协议，声明了三个方法，允许开发者分别在请求执行的三个阶段(start、willStop、didStop)调用。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>事实上，<code>YTKBaseRequest</code> 类就是围绕
<code>NSURLSessionTask</code> 类进行封装的， <code>requestTask</code>
是它最重要的属性。<code>YTKBaseRequest</code> 的其他多个属性都源自于
<code>requestTask</code> 的属性。如：</p>
<ul>
<li><code>currentRequest</code>：即
<code>requestTask.currentRequest</code></li>
<li><code>originalRequest</code>：即
<code>requestTask.originalRequest</code></li>
<li><code>response</code>：即 <code>requestTask.response</code></li>
<li><code>responseHeaders</code>：即
<code>requestTask.allHeaderFields</code></li>
<li><code>responseStatusCode</code>：即
<code>requestTask.statusCode</code></li>
</ul>
<p><code>YTKBaseRequest</code>
提供了高层级的网络抽象，体现在提供了一些高层级的配置方法，并允许用户通过覆写这些方法来进行自定义配置。一些常用的配置方法包括如下：
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Base URL，因为一个应用程序中的网络请求的 BaseURL 几乎都是相同的。</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)baseUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求的 URL 路径</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 网络请求的超时间隔。默认 60 秒</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)requestTimeoutInterval &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HTTP 请求方法。默认是 GET</span></span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestMethodGET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求序列化器类型。默认是 HTTP</span></span><br><span class="line">- (YTKRequestSerializerType)requestSerializerType &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestSerializerTypeHTTP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 响应序列化器类型。默认是 JSON</span></span><br><span class="line">- (YTKResponseSerializerType)responseSerializerType &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKResponseSerializerTypeJSON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求参数对象，会根据配置的请求序列化器进行编码。</span></span><br><span class="line">- (<span class="type">id</span>)requestArgument &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否允许蜂窝网络。默认 YES</span></span><br><span class="line">- (<span class="type">BOOL</span>)allowsCellularAccess &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否使用 CDN。默认 NO</span></span><br><span class="line">- (<span class="type">BOOL</span>)useCDN &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CDN URL。根据 useCDN 决定是否使用。</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cdnUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>关于 <code>YTKBaseRequest</code>
对象的执行，它也提供了几个简单的方法以供开发者使用，如下所示。通过
<code>start</code> 方法，我们可以发现 <code>YTKBaseRequest</code>
被加入到了 <code>YTKNetworkAgent</code> 单例中。可见
<code>YTKNetworkAgent</code> 管理了多个 <code>YTKBaseRequest</code>
对象。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// YTKBaseRequest 开始执行</span></span><br><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="comment">// 执行 YTKRequestAccessory 协议定义的 requestWillStart: 方法。</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">    <span class="comment">// 将请求对象加入 YTKNetworkAgent 单例</span></span><br><span class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// YTKBaseRequest 停止执行</span></span><br><span class="line">- (<span class="type">void</span>)stop &#123;</span><br><span class="line">    <span class="comment">// 执行 YTKRequestAccessory 协议定义的 requestWillStop: 方法。</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 执行 YTKRequestAccessory 协议定义的 requestDidStop: 方法。</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 一个便利方法。执行 YTKBaseRequest。</span></span><br><span class="line">- (<span class="type">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    [<span class="keyword">self</span> start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ytknetworkconfig">YTKNetworkConfig</h3>
<p><code>YTKNetworkConfig</code> 是用于 <code>YTKNetworkAgent</code>
初始化的配置对象，是一个 <strong>单例</strong>。</p>
<p><code>YTKNetworkConfig</code> 主要包含以下属性： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKNetworkConfig</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求的 Base URL。默认是 &quot;&quot;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *baseUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  CDN URL. 默认是 &quot;&quot;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *cdnUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// URL 过滤器。YTKUrlFilterProtocol 声明的 filterUrl:withRequest: 方法会返回最终被使用的 URL</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKUrlFilterProtocol&gt;&gt; *urlFilters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缓存路径过滤器。YTKCacheDirPathFilterProtocol 声明的 filterCacheDirPath:withRequest: 方法会返回最终被使用的缓存路径。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *cacheDirPathFilters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 安全策略。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否打印调试日志信息。默认是 NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> debugLogEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 会话配置对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionConfiguration</span>* sessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><code>YTKNetworkConfig</code> 持有了一个
<code>NSURLSessionConfiguration</code> 类型的属性
<code>sessionConfiguration</code>，用于 <code>YTKNetworkAgent</code>
中初始化 <code>AFHTTPSessionManager</code>（本质上是用于初始化
<code>NSURLSession</code>）。</p>
<h3 id="ytknetworkagent">YTKNetworkAgent</h3>
<p><code>YTKNetworkAgent</code>
的内部结构如下图所示。下面我们将以该图为指导进行介绍。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-ytknetworkagent.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="初始化">初始化</h4>
<p><code>YTKNetworkAgent</code> 初始化过程会使用
<code>YTKNetworkConfig</code>
单例对象（配置对象）。使用配置对象的会话配置对象
<code>sessionConfiguration</code> 初始化会话管理器
<code>AFHTTPSessionManager</code>。</p>
<p><code>YTKNetwork</code> 框架默认只能使用 <code>YTKNetworkAgent</code>
单例对象。</p>
<h4 id="添加并执行请求">添加并执行请求</h4>
<p><code>YTKNetworkAgent</code> 提供了 <code>addRequest:</code>
方法来添加并执行请求对象。我们可以来看一下其内部实现。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化请求对象的关键属性 requestTask，即任务对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</span><br><span class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</span><br><span class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="type">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="comment">// 完成回调</span></span><br><span class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方式</span></span><br><span class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求序列化异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@&quot;requestTask should not be nil&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求优先级</span></span><br><span class="line">    <span class="comment">// !!Available on iOS 8 +</span></span><br><span class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</span><br><span class="line">                <span class="comment">/*!!fall through*/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YTKLog(<span class="string">@&quot;Add request: %@&quot;</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">// 将 请求对象 加入记录表</span></span><br><span class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</span><br><span class="line">    <span class="comment">// 执行请求，即执行任务对象</span></span><br><span class="line">    [request.requestTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>addRequest:</code> 方法内部会做一下几个步骤的工作：</p>
<ol type="1">
<li>初始化请求对象的关键属性 <code>requestTask</code>，即任务对象。</li>
<li>设置请求优先级</li>
<li>以任务对象的 <code>taskIdentifier</code>
为键，请求对象为值，建立映射关系，存入
<strong>记录表</strong>（即上图中的
<code>_requestRecord</code>，后文还会提到）。</li>
<li>执行请求，本质上是执行任务对象。</li>
</ol>
<p>我们重点看一下第 1 步。这一步默认调用了
<code>sessionTaskForRequest:error:</code>
方法进行初始化。该方法内部实现如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 获取请求方法</span></span><br><span class="line">    YTKRequestMethod method = [request requestMethod];</span><br><span class="line">    <span class="comment">// 获取请求URL</span></span><br><span class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    <span class="type">id</span> param = request.requestArgument;</span><br><span class="line">    <span class="comment">// 获取 HTTP 主体</span></span><br><span class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</span><br><span class="line">    <span class="comment">// 获取请求序列化器</span></span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据请求方法以及下载路径值，初始化相应的任务对象</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</span><br><span class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;POST&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;HEAD&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;PUT&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;DELETE&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;PATCH&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>sessionTaskForRequest:error:</code> 方法会根据请求对象的
<code>requestMethod</code> 初始化相应的任务对象。以 <code>POST</code>
请求为例，这里最终会调用
<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:constructingBodyWithBlock:error:</code>
方法。其内部实现如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个 URLRequest 对象</span></span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 URLRequest 对象，初始化任务对象，并返回该任务对象</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [_manager dataTaskWithRequest:request</span><br><span class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                <span class="comment">// 设置完成回调</span></span><br><span class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</span><br><span class="line">                           &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:constructingBodyWithBlock:error:</code>
方法根据入参初始化一个 URLRequest
对象，并使用该对象初始化一个任务对象，并返回该任务对象。</p>
<h4 id="完成回调">完成回调</h4>
<p>上述
<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:constructingBodyWithBlock:error:</code>
方法中，初始化任务对象时会设置完成回调。</p>
<p>我们来看看完成回调做了什么工作。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="type">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    Lock();</span><br><span class="line">    <span class="comment">// 根据任务对象的 taskIdentifier 从记录表中获取请求对象。</span></span><br><span class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</span><br><span class="line">    Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YTKLog(<span class="string">@&quot;Finished Request: %@&quot;</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *requestError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">BOOL</span> succeed = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的响应序列化器，序列化响应数据</span></span><br><span class="line">    request.responseObject = responseObject;</span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        request.responseData = responseObject;</span><br><span class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (request.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Default serializer. Do nothing.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                request.responseJSONObject = request.responseObject;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查请求是否成功，并获取请求异常</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = error;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = serializationError;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</span><br><span class="line">        requestError = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用请求成功处理 或 调用请求失败处理</span></span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从记录表中删除请求对象</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个回调中，主要做了一下几个工作：</p>
<ol type="1">
<li>根据任务对象的 <code>taskIdentifier</code> 从记录表
<code>_requestRecord</code> 中获取请求对象。</li>
<li>对于获取到的请求对象，根据不同的响应序列化器，序列化响应数据。</li>
<li>检查请求是否成功，并获取请求异常。</li>
<li>调用请求成功处理 或 调用请求失败处理</li>
<li>从记录表中删除请求对象。</li>
</ol>
<p>其中第 4 步，无论是成功回调还是失败回调，都会依次调用代理对象实现的
<code>requestFinished:</code> 或
<code>requestFailed</code>，以及请求对象的
<code>successCompletionBlock</code> 或
<code>failureCompletionBlock</code>。</p>
<h4 id="下载任务与缓存">下载任务与缓存</h4>
<p>关于下载任务，我们先来看一下上述
<code>sessionTaskForRequest:error:</code> 方法中，当请求对象的请求类型是
<code>YTKRequestMethodGET</code> 且设置了请求对象的
<code>resumableDownloadPath</code> 属性时，会调用
<code>downloadTaskWithDownloadPath:requestSerializer:URLString:parameters:progress:error:</code>
方法。该方法的具体实现如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithDownloadPath:(<span class="built_in">NSString</span> *)downloadPath</span><br><span class="line">                                         requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                                parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 使用请求参数、请求URL、请求类型，初始化 URLRequest 对象</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *urlRequest = [requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:URLString parameters:parameters error:error];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *downloadTargetPath;</span><br><span class="line">    <span class="comment">// 检查 resumableDownloadPath 指定的下载存储路径是否是目录</span></span><br><span class="line">    <span class="type">BOOL</span> isDirectory;</span><br><span class="line">    <span class="keyword">if</span>(![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadPath isDirectory:&amp;isDirectory]) &#123;</span><br><span class="line">        isDirectory = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理下载存储路径，确保不是目录，而是文件</span></span><br><span class="line">    <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *fileName = [urlRequest.URL lastPathComponent];</span><br><span class="line">        downloadTargetPath = [<span class="built_in">NSString</span> pathWithComponents:@[downloadPath, fileName]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downloadTargetPath = downloadPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理该路径原有的文件</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadTargetPath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:downloadTargetPath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查未完成下载暂存路径是否有数据 并 读取此路径暂存的数据</span></span><br><span class="line">    <span class="type">BOOL</span> resumeDataFileExists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath].path];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath]];</span><br><span class="line">    <span class="type">BOOL</span> resumeDataIsValid = [YTKNetworkUtils validateResumeData:data];</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> canBeResumed = resumeDataFileExists &amp;&amp; resumeDataIsValid;</span><br><span class="line">    <span class="type">BOOL</span> resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (canBeResumed) &#123;</span><br><span class="line">        <span class="comment">// 对于可恢复的下载请求，使用已下载的数据初始化一个下载任务，继续发起下载请求。</span></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            downloadTask = [_manager downloadTaskWithResumeData:data progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">            &#125; completionHandler:</span><br><span class="line">                            ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                                [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                            &#125;];</span><br><span class="line">            resumeSucceeded = <span class="literal">YES</span>;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            YTKLog(<span class="string">@&quot;Resume download failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">            resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!resumeSucceeded) &#123;</span><br><span class="line">        <span class="comment">// 如果尝试继续下载失败，则创建一个下载任务，重新开始发起下载请求。</span></span><br><span class="line">        downloadTask = [_manager downloadTaskWithRequest:urlRequest progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">            <span class="comment">// 指定下载的存储路径</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">        &#125; completionHandler:</span><br><span class="line">                        ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                            [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
下载任务的创建过程中，有三个关键步骤：</p>
<ol type="1">
<li>确保下载存储路径是文件路径，而非目录路径。</li>
<li>读取 <strong>未完成下载暂存路径</strong>
的数据，并判断是否可继续下载。</li>
<li>如果可以继续下载，则创建请求继续下载；否则，创建请求重新下载。</li>
</ol>
<p>从上面代码中，我们可以知道下载存储路径有两种可能：</p>
<ol type="1">
<li><code>resumableDownloadPath</code></li>
<li><code>resumableDownloadPath</code> + <code>filename</code></li>
</ol>
<p>那么未完成下载暂存路径是什么呢？我们来看代码： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)incompleteDownloadTempCacheFolder &#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> new];</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cacheFolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheFolder) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *cacheDir = <span class="built_in">NSTemporaryDirectory</span>();</span><br><span class="line">        cacheFolder = [cacheDir stringByAppendingPathComponent:kYTKNetworkIncompleteDownloadFolderName];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span>(![fileManager createDirectoryAtPath:cacheFolder withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:&amp;error]) &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Failed to create cache directory at %@&quot;</span>, cacheFolder);</span><br><span class="line">        cacheFolder = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheFolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)incompleteDownloadTempPathForDownloadPath:(<span class="built_in">NSString</span> *)downloadPath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *tempPath = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *md5URLString = [YTKNetworkUtils md5StringFromString:downloadPath];</span><br><span class="line">    tempPath = [[<span class="keyword">self</span> incompleteDownloadTempCacheFolder] stringByAppendingPathComponent:md5URLString];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:tempPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从上述代码，可以看出未完成下载暂存路径其实就是：</p>
<ul>
<li><code>NSTemporaryDirectory()</code> + 下载存储路径目录的 md5 值</li>
</ul>
<p>注意，<code>NSTemporaryDirectory()</code> 目录就是 UNIX 中的
<code>/tmp</code> 目录，该目录下的文件会在系统重启后被清空。</p>
<h2 id="ytknetwork-链式请求">YTKNetwork 链式请求</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-chain-overview.png?x-oss-process=image/resize,w_800" /></p>
<p>链式请求主要是通过 YTKNetwork 提供的两个类，并结合 YTKNetwork
核心功能实现的。这两类分别是：</p>
<ul>
<li><code>YTKChainRequest</code></li>
<li><code>YTKChainRequestAgent</code></li>
</ul>
<p>下面，我们分别介绍一下 <code>YTKChainRequest</code> 和
<code>YTKChainRequestAgent</code>。</p>
<h3 id="ytkchainrequest">YTKChainRequest</h3>
<p><code>YTKChainRequest</code> 继承自
<code>NSObject</code>，主要包含一下这些属性。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 公开属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKChainRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代理对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;YTKChainRequestDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// YTKRequestAccessory 是一个协议，声明了三个方法，允许开发者分别在请求执行的三个阶段(start、willStop、didStop)调用。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// ------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 私有属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKChainRequest</span>()&lt;<span class="title">YTKRequestDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 链式请求队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>&lt;YTKBaseRequest *&gt; *requestArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 链式请求回调队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>&lt;YTKChainCallback&gt; *requestCallbackArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> nextRequestIndex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YTKChainCallback emptyCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><code>YTKChainRequest</code> 提供了 4 个方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 获取链式请求队列</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;YTKBaseRequest *&gt; *)requestArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加实现了 YTKRequestAccessory 协议的对象</span></span><br><span class="line">- (<span class="type">void</span>)addAccessory:(<span class="type">id</span>&lt;YTKRequestAccessory&gt;)accessory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开始执行链式请求</span></span><br><span class="line">- (<span class="type">void</span>)start;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 停止执行链式请求</span></span><br><span class="line">- (<span class="type">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 向链式请求队列中添加请求</span></span><br><span class="line">- (<span class="type">void</span>)addRequest:(YTKBaseRequest *)request callback:(<span class="keyword">nullable</span> YTKChainCallback)callback;</span><br></pre></td></tr></table></figure></p>
<p>我们通过源代码来看一下其中比较关键的 <code>start</code> 方法。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="comment">// 判断链式请求是否已经启动</span></span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Chain request has already started.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式请求队列非空，则开始执行请求</span></span><br><span class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">        [<span class="keyword">self</span> startNextRequest];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Chain request array is empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>start</code>
方法内部首先判断链式请求是否已经启动，这是通过请求索引
<code>_nextRequestIndex</code>
来判断的。如果链式请求未启动，则开始执行链式请求，这里调用了一个关键的方法
<code>startNextRequest</code>。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)startNextRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</span><br><span class="line">        _nextRequestIndex++;</span><br><span class="line">        request.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">        [request start];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 每调用一次
<code>startNextRequest</code>，会移动请求索引、设置请求代理并执行。</p>
<p>链式请求中的每一个请求 <code>YTKBaseRequest</code> 的代理都是链式请求
<code>YTKChainRequest</code>。<code>YTKChainRequest</code> 实现了
<code>YTKRequestDelegate</code>
协议。每一个请求执行完成后，开始执行下一个请求。如果有一个请求失败，即整个链式请求失败。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</span><br><span class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</span><br><span class="line">    callback(<span class="keyword">self</span>, request);</span><br><span class="line">    <span class="comment">// 执行下一个请求</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</span><br><span class="line">            <span class="comment">// 所有请求执行完毕，调用代理方法 chainRequestFinished:</span></span><br><span class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</span><br><span class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</span><br><span class="line">        <span class="comment">// 有一个请求失败，即调用 chainRequestFailed:</span></span><br><span class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ytkchainrequestagent">YTKChainRequestAgent</h3>
<p><code>YTKChainRequestAgent</code>
的作用非常简单，就是作为一个单例，持有多个链式请求。<code>YTKChainRequestAgent</code>
提供的方法如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (YTKChainRequestAgent *)sharedAgent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加链式请求</span></span><br><span class="line">- (<span class="type">void</span>)addChainRequest:(YTKChainRequest *)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 移除链式请求</span></span><br><span class="line">- (<span class="type">void</span>)removeChainRequest:(YTKChainRequest *)request;</span><br></pre></td></tr></table></figure></p>
<h2 id="ytknetwork-批量请求">YTKNetwork 批量请求</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-batch-overview.png?x-oss-process=image/resize,w_800" /></p>
<p><code>YTKNetwork</code>
批量请求的实现原理其实与链式请求的实现原理是一样的，也提供了两个类：</p>
<ul>
<li><code>YTKBatchRequest</code></li>
<li><code>YTKBatchRequestAgent</code></li>
</ul>
<p>不同之处在于，<code>YTKBatchRequest</code> 中的单个请求并不是
<code>YTKBaseRequest</code> 请求，而是它的子类
<code>YTKRequest</code>。</p>
<p>我们来看看 <code>YTKRequest</code> 在父类 <code>YTKBaseRequest</code>
的基础上做了些什么。</p>
<h3 id="ytkrequest">YTKRequest</h3>
<p>首先，我们来看一下 <code>YTKRequest</code> 所提供的外部属性和方法。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKRequest</span> : <span class="title">YTKBaseRequest</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否忽略缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> ignoreCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求响应数据是否来自本地缓存</span></span><br><span class="line">- (<span class="type">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error;</span><br><span class="line"><span class="comment">/// 请求不使用缓存数据</span></span><br><span class="line">- (<span class="type">void</span>)startWithoutCache;</span><br><span class="line"><span class="comment">/// 将响应数据保存至缓存</span></span><br><span class="line">- (<span class="type">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Subclass Override</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缓存时间</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds;</span><br><span class="line"><span class="comment">/// 缓存版本</span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)cacheVersion;</span><br><span class="line"><span class="comment">/// 缓存敏感数据，用于验证缓存是否失效</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)cacheSensitiveData;</span><br><span class="line"><span class="comment">/// 是否异步写入缓存</span></span><br><span class="line">- (<span class="type">BOOL</span>)writeCacheAsynchronously;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure> 很明显，<code>YTKRequest</code>
在父类的基础上支持了本地缓存功能。</p>
<h4 id="缓存目录">缓存目录</h4>
<p>我们来重点看一下 <code>YTKRequest</code>
中相关的缓存目录。首先来看以下几个方法： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@&quot;LazyRequestCache&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter cache base path</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    <span class="type">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</span><br><span class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;</span>,</span><br><span class="line">                             (<span class="type">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    <span class="keyword">return</span> cacheFileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.metadata&quot;</span>, [<span class="keyword">self</span> cacheFileName]];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
默认情况下，<code>cacheBasePath</code>
方法返回的基本路径是：<code>/Library/LazyRequestCache</code>。</p>
<p><code>cacheFileName</code>
方法则根据请求的基本信息生成缓存的文件名：<code>Method:xxx Host:xxx Url:xxx Argument:xxx</code>，并使用
md5 进行编码。</p>
<p><code>cacheFilePath</code>
则是请求数据的完整存储路径：<code>/Library/LazyRequestCache/</code> +
md5(<code>Method:xxx Host:xxx Url:xxx Argument:xxx</code>)。</p>
<p><code>cacheMetadataFilePath</code>
则存储了缓存元数据，其路径是：<code>cacheFilePath</code> +
<code>.medata</code>。</p>
<p>缓存元数据使用 <code>YTKCacheMetaData</code> 对象表示，其定义如下：
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> <span class="type">long</span> version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><code>YTKCacheMetaData</code>
主要用户验证缓存是否有效。验证方法如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// Date</span></span><br><span class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Version</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</span><br><span class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sensitive data</span></span><br><span class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</span><br><span class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></span><br><span class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// App version</span></span><br><span class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>YTKNetwork 设计原理非常简单，仅仅是对 AFNetworking
做了一个简单的封装，提供了面向对象的使用方法，使用起来也是非常简单。不过也存在缺点，就是每一个请求都需要定义一个类。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>YTKNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 性能监控(2)——卡顿</title>
    <url>/2019/06/17/ios-performance-monitor-caton/</url>
    <content><![CDATA[<p>前文 <a
href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">iOS
性能监控(1)——CPU、Memory、FPS</a> 探讨了 iOS 中进行线上监控
CPU、Memory、FPS 等指标的原理以及具体实现方法。本文则继续探讨如何在 iOS
中进行线上监控卡顿的原理及实现。</p>
<span id="more"></span>
<h1 id="卡顿">卡顿</h1>
<h2 id="相关系统原理">相关系统原理</h2>
<p>那么为什么会出现卡顿呢？为了解释这个问题首先需要了解一下屏幕图像的显示原理。首先从
CRT 显示器原理说起，如下图所示。CRT
的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal
synchronization），简称
<strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical
synchronization），简称
<strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是
VSync
信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" /></p>
<p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU
计算好显示内容（如：视图的创建、布局计算、图片解码、文本绘制）提交至
GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync
信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_500" /></p>
<p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU
通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。事实上，iPhone
使用的就是双缓冲机制。在这种情况下，GPU
会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU
会直接把视频控制器的指针指向第二个缓冲器。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png?x-oss-process=image/resize,w_800" /></p>
<p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU
将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" /></p>
<p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是
V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync
信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。当
CPU 和 GPU 计算量比较大时，一旦它们的完成时间错过了下一次 C-Sync
的到来（通常是
1000/6=16.67ms），这样就会出现显示屏还是之前帧的内容，这就是界面卡顿的原因。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios_frame_drop.png?x-oss-process=image/resize,w_500" /></p>
<h2 id="fps-卡顿监控方案">FPS 卡顿监控方案</h2>
<p>FPS 卡顿监控方案的原理是 <strong>通过一段连续的 FPS
计算丢帧率来衡量当前页面绘制的质量</strong>。</p>
<p>具体实现方式可以通过 <a
href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">iOS
性能监控(1)——CPU、Memory、FPS</a> 一文中的 FPS 监控方法进行 FPS
数据采集，然后处理数据。这里不做多余的介绍。</p>
<h2 id="主线程卡顿监控方案">主线程卡顿监控方案</h2>
<p>主线程卡顿监控方案的原理是 <strong>通过子线程监控主线程的
RunLoop，判断两个状态区域之间的耗时是否达到一定阈值</strong>。因为主线程绝大部分计算或绘制任务都是以
RunLoop 为单位发生。单次 RunLoop 如果时长超过 16ms，就会导致 UI
体验的卡顿。</p>
<p>美团的移动端性能监控方案 Hertz 采用的就是这种方式。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-performance-monitor-caton01.png?x-oss-process=image/resize,w_500" /></p>
<p>首先我们需要了解一下 RunLoop 的原理。</p>
<h3 id="runloop-定义">RunLoop 定义</h3>
<p>RunLoop 是 iOS
事件响应与任务处理最核心的机制。当有持续的异步任务需求时，我们会创建一个独立的生命周期可控的线程。<strong>RunLoop
就是控制线程生命周期并接收事件进行处理的机制</strong>。</p>
<h3 id="runloop-机制">RunLoop 机制</h3>
<p><strong>主线程（有 RunLoop
的线程）几乎所有函数都从以下六个函数之一的函数调起：</strong></p>
<ol type="1">
<li><code>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</code>
<ul>
<li>CFRunloop is calling out to an abserver callback function</li>
<li>用于向外部报告 RunLoop 当前状态的改变，框架中很多机制都由
RunLoopObserver 触发，如：CAAnimation</li>
</ul></li>
<li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</code>
<ul>
<li>CFRunloop is calling out to a block</li>
<li>消息通知、非延迟的 perform、dispatch 调用、block 回调、KVO</li>
</ul></li>
<li><code>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</code>
<ul>
<li>CFRunloop is servicing the main dispatch queue</li>
<li>执行主队列上的任务</li>
</ul></li>
<li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</code>
<ul>
<li>CFRunloop is calling out to a timer callback function</li>
<li>基于定时器的延迟的 perfrom，dispatch 调用</li>
</ul></li>
<li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</code>
<ul>
<li>CFRunloop is calling out to a source 0 perform function</li>
<li>处理 App
内部事件、App自己负责管理（触发），如：<code>UIEvent</code>、<code>CFSocket</code>。普通函数调用，系统调用</li>
</ul></li>
<li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</code>
<ul>
<li>CFRunloop is calling out to a source 1 perform function</li>
<li>由 RunLoop 和内核管理，Mach port
驱动，如：<code>CFMachPort</code>、<code>CFMessagePort</code></li>
</ul></li>
</ol>
<h3 id="runloop-运行时">RunLoop 运行时</h3>
<p>如下所示为 <code>CFRunLoop</code> 源码中的核心方法
<code>CFRunLoopRun</code> 简化后的主要逻辑。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int32_t __CFRunLoopRun() &#123;</span><br><span class="line">    // 1. 通知 Observers：即将进入 RunLoop</span><br><span class="line">    __CFRunLoopDoObservers(KCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        // 2. 通知Observers：即将要处理 timer</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</span><br><span class="line">        // 3. 通知Observers：即将要处理 source</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        // 处理非延迟的主线程调用</span><br><span class="line">        __CFRunLoopDoBlocks();</span><br><span class="line">        // 处理 UIEvent 事件</span><br><span class="line">        __CFRunLoopDoSource0();</span><br><span class="line">    </span><br><span class="line">        // GCD dispatch main queue</span><br><span class="line">        CheckIfExistMessagesInMainDispatchQueue();</span><br><span class="line">    </span><br><span class="line">        // 4. 通知 Observers：即将进入休眠等待</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        // 等待内核mach_msg事件</span><br><span class="line">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</span><br><span class="line">        </span><br><span class="line">        // mach_msg_trap</span><br><span class="line">        // 休眠中 Zzz...</span><br><span class="line">        // Received mach_msg, wake up</span><br><span class="line">        </span><br><span class="line">        // 5. 通知 Observers：从休眠等待中醒来</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        if (wakeUpPort == timerPort) &#123;</span><br><span class="line">            // 处理因timer的唤醒</span><br><span class="line">            __CFRunLoopDoTimers();</span><br><span class="line">        &#125; else if (wakeUpPort == mainDispatchQueuePort) &#123;</span><br><span class="line">            // 处理异步方法唤醒，如：dispatch_async</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // UI 刷新，动画显示</span><br><span class="line">            __CFRunLoopDoSource1();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 再次确保是否有同步的方法需要调用</span><br><span class="line">        __CFRunLoopDoBlocks()</span><br><span class="line">    &#125; while(!stop &amp;&amp; !timeout);</span><br><span class="line">    </span><br><span class="line">    // 6. 通知 Observers：即将退出runloop</span><br><span class="line">    __CFRunLoopDoObservers(CFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> RunLoop
在运行时一直在向外部报告当前状态的更新，其状态定义如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry ,           // 进入 loop</span><br><span class="line">    kCFRunLoopBeforeTimers ,    // 触发 Timer 回调</span><br><span class="line">    kCFRunLoopBeforeSources ,   // 触发 Source0 回调</span><br><span class="line">    kCFRunLoopBeforeWaiting ,   // 等待 mach_port 消息</span><br><span class="line">    kCFRunLoopAfterWaiting ,    // 接收 mach_port 消息</span><br><span class="line">    kCFRunLoopExit ,            // 退出 loop</span><br><span class="line">    kCFRunLoopAllActivities     // loop 所有状态改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 RunLoop 运行逻辑中，不难发现 NSRunLoop
调用方法主要在于两个状态区间：</p>
<ul>
<li><code>kCFRunLoopBeforeSources</code> 和
<code>kCFRunLoopBeforeWaiting</code> 之间</li>
<li><code>kCFRunLoopAfterWaiting</code> 之后</li>
</ul>
<p><strong>如果这两个时间内耗时太久而无法进入下一步，可以线程受阻。如果这个线程时主线程，表现出来就是出现了卡顿。</strong></p>
<h3 id="代码实现">代码实现</h3>
<p>我们可以通过 <code>CFRunLoopObserverRef</code> 实时获取
<code>NSRunLoop</code> 的状态。具体使用方法如下：</p>
<p>首先创建一个 <code>CFRunLoopObserverContext</code> 观察者
<code>observer</code>。然后将观察者 <code>observer</code> 添加到主线程
RunLoop 的 <code>kCFRunLoopCommonModes</code> 模式下进行观察。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)registerObserver &#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，创建一个持续的子线程专门用来监控主线程的 RunLoop
状态。为了让计算更精确，需要让子线程更及时的获知主线程 RunLoop
状态变化，<code>dispatch_semaphore_t</code>
是一个不错的选择。另外，卡顿需要覆盖多次连续短时间卡顿和单次长时间卡顿两种情景，所以判定条件也需要做适当优化。优化后的代码实现如下所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)registerObserver &#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    // 创建信号</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES) &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">            if (st != 0) &#123;</span><br><span class="line">                if (activity == kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    if (++timeoutCount &lt; 5)</span><br><span class="line">                        continue;</span><br><span class="line">                    </span><br><span class="line">                    NSLog(@&quot;好像有点儿卡哦&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    </span><br><span class="line">    // 记录状态值</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">    </span><br><span class="line">    // 发送信号</span><br><span class="line">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检测到卡顿时应该立刻获取卡顿的方法堆栈信息，并推送至服务端共开发者分析，从而解决卡顿问题。</p>
<p>获取堆栈信息的一种方法是：<strong>直接调用系统函数</strong>。这种方法的优点是
<strong>性能消耗小</strong>。缺点是
<strong>它只能够获取简单的信息，无法配合 dSYM
来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限</strong>。</p>
<p>直接调用系统函数的主要思路是：用 <code>signal</code>
进行错误信息获取。具体代码如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int s_fatal_signals[] = &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);</span><br><span class="line"></span><br><span class="line">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class="line">    NSArray *exceptionArray = [exception callStackSymbols];     // 得到当前调用栈信息</span><br><span class="line">    NSString *exceptionReason = [exception reason];             // 非常重要，就是崩溃的原因</span><br><span class="line">    NSString *exceptionName = [exception name];                 // 异常类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SignalHandler(int code) &#123;</span><br><span class="line">    NSLog(@&quot;signal handler = %d&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitCrashReport() &#123;</span><br><span class="line">    // 系统错误信号捕获</span><br><span class="line">    for (int i = 0; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //oc 未捕获异常的捕获</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取堆栈信息的另一种方法是：<strong>直接使用 PLCrashReporter
第三方开源库</strong>。这种方法的优点是
<strong>能够定位到问题代码的具体位置，而且性能消耗也不大</strong>。具体代码如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD     </span><br><span class="line">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">PLCrashReporter *reporter = [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line"></span><br><span class="line">// 获取数据</span><br><span class="line">NSData *lagData = [reporter generateLiveReport];</span><br><span class="line"></span><br><span class="line">// 转换成 PLCrashReport 对象</span><br><span class="line">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line"></span><br><span class="line">// 进行字符串格式化处理</span><br><span class="line">NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"></span><br><span class="line">// 将字符串上传服务器</span><br><span class="line">NSLog(@&quot;lag happen, detail below: \n %@&quot;,lagReportString);</span><br></pre></td></tr></table></figure></p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">计算机那些事(8)——图形图像渲染原理</a></li>
<li><a href="http://chuquan.me/2018/10/06/understand-ios-runloop/">Run
Loop 原理详解</a></li>
<li><a
href="https://wereadteam.github.io/2016/05/03/WeRead-Performance/">微信读书
iOS 性能优化总结</a></li>
<li><a href="http://www.tanhao.me/code/151113.html/">iOS
实时卡顿监控</a></li>
<li><a
href="https://opensource.apple.com/source/CF/CF-1152.14/CFRunLoop.c.auto.html">CFRunLoop.c</a></li>
<li><a
href="https://juejin.im/post/5a94e9185188257a780dde61">RunLoop刨根问底</a></li>
<li><a href="https://www.cnblogs.com/zy1987/p/4582466.html">RunLoop
原理和核心机制</a></li>
<li><a
href="http://mrpeak.cn/blog/ui-detect/">iOS应用UI线程卡顿监控</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>卡顿</tag>
        <tag>性能监控</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 性能监控(1)——CPU、Memory、FPS</title>
    <url>/2019/06/10/ios-performance-monitor-cpu-mem-fps/</url>
    <content><![CDATA[<p>前段时间，在公司的 App
中集成了一个性能监视器，效果如下所示。在这个过程中，扒了一些性能监测开源框架的源码，并学习了其中的原理。本文就对此做一些简要的总结。</p>
<span id="more"></span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-performance-monitor.gif?x-oss-process=image/resize,w_400" /></p>
<h1 id="概述">概述</h1>
<p>通常情况下，App 的性能问题并不会导致 App
不可用，但是会潜在地影响用户体验。比如：CPU
占用率过高会导致电量消耗过快，手机发热等问题。为了能够主动、高效地发现性能问题，避免
App 质量进入无人监控的状态，我们需要对 App 的性能进行监控。目前，对 App
的性能监控，主要分为 <strong>线下</strong> 和 <strong>线上</strong>
两种监控维度。</p>
<h1 id="线下性能监控">线下性能监控</h1>
<p>关于线下性能监控，Xcode 内置提供了一个性能分析工具 Instruments。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/xcode-instruments-overview.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>Instruments 集成了非常多的性能检测工具，如：Leaks
可以用来监控内存泄露问题；Energy Log 可以用来监控耗电量。下图所示为
Instruments 中包含的各种性能检测工具。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/xcode-instruments-tools.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>通常，我们会在提审前使用 Instruments 对 App 进行线下的性能分析。</p>
<h1 id="线上性能监控">线上性能监控</h1>
<p>线上监控一般需要遵循两个原则：</p>
<ol type="1">
<li>监控代码与业务代码解耦</li>
<li>采用性能消耗最小的性能监控方案</li>
</ol>
<p>线上性能监控，主要集中在对 CPU 使用率、内存、FPS
帧率等方面的监控。下面分别介绍其各自的监控方法及原理。</p>
<h2 id="cpu">CPU</h2>
<p>CPU 占用率的采集原理其实很简单：<strong>App
作为进程运行时会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU
使用率的总和，就是当前 App 对 CPU 的占用率</strong>。</p>
<h3 id="相关系统原理">相关系统原理</h3>
<p>iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，XNU（X
is not UNIX） 是 Darwin 的内核，一个混合内核，由 Mach 微内核和 BSD
组成。Mach
内核是轻量级的平台，只能完成操作系统最基本的职责，如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，如文件操作和设备访问，都是由
BSD 层实现。</p>
<p>事实上，Mach 并不能识别 UNIX
中的所有进程，而是采用一种稍微不同的方式，使用了比进程更轻量级的概念：<strong>任务（Task）</strong>。经典的
UNIX
采用了自上而下的方式：最基本的对象是进程，然后进一步划分为一个或多个线程；Mach
则采用了自底向上的方式：最基本的单元是线程，一个或多个线程包含在一个任务中。</p>
<p><strong>线程</strong></p>
<ul>
<li>线程定义了 Mach
中最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据，其从设计上提供了调度所需要的大量信息。</li>
</ul>
<p><strong>任务</strong></p>
<ul>
<li>任务是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此，资源的共享实际上相当于允许对对应端口进行访问。</li>
</ul>
<p>严格来说，Mach 的任务并不是hi操作系统中所谓的进程，因为 Mach
作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。在
BSD 模型中，这两个概念有一对一的简单映射，每个 BSD 进程（即 OS X
进程）都在底层关联了一个 Mach
任务对象。实现这种映射的方法是指定一个透明的指针
<code>bsd_info</code>，Mach 对 <code>bsd_info</code> 完全无知。Mach
将内核也用任务表示（全局范围称为
<code>kernel_task</code>），尽管该任务没有对应的 PID，但可以想象 PID 为
0。</p>
<p>下图所示为权威著作《OS X Internal: A System Approach》中提供的 Mach
OS X 中进程子系统组成的概念图。与 Mac OS X 类似，iOS 的线程技术也是基于
Mach 线程技术实现的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/mach-task-thread-system.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="代码实现">代码实现</h3>
<p>上述提到线程表示的是底层的机器寄存器状态以及各种给调度统计数据。再来看
Mach 层中的 <code>thread_basic_info</code>
结构体的定义，其成员信息也证实了这一点。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct thread_basic_info &#123;</span><br><span class="line">        time_value_t    user_time;      // 用户运行时长</span><br><span class="line">        time_value_t    system_time;    // 系统运行时长</span><br><span class="line">        integer_t       cpu_usage;      // CPU 使用率</span><br><span class="line">        policy_t        policy;         // 调度策略</span><br><span class="line">        integer_t       run_state;      // 运行状态</span><br><span class="line">        integer_t       flags;          // 各种标记</span><br><span class="line">        integer_t       suspend_count;  // 暂停线程的计数</span><br><span class="line">        integer_t       sleep_time;     // 休眠时间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
每个线程都有这个结构体，所以我们只需要定时去遍历每个线程，累加每个线程的
<code>cpu_usage</code> 字段的值，就可以得到当前 App 所在进程的 CPU
使用率。</p>
<p>如下所示为 <strong>CPU 占用率</strong> 的代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取 CPU 使用率</span><br><span class="line">+ (CGFloat)cpuUsageForApp &#123;</span><br><span class="line">    kern_return_t           kr;</span><br><span class="line">    thread_array_t          thread_list;</span><br><span class="line">    mach_msg_type_number_t  thread_count;</span><br><span class="line">    thread_info_data_t      thinfo;</span><br><span class="line">    mach_msg_type_number_t  thread_info_count;</span><br><span class="line">    thread_basic_info_t     basic_info_th;</span><br><span class="line"></span><br><span class="line">    // 根据当前 task 获取所有线程</span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    if (kr != KERN_SUCCESS)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    float total_cpu_usage = 0;</span><br><span class="line">    // 遍历所有线程</span><br><span class="line">    for (int i = 0; i &lt; thread_count; i++) &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        // 获取每一个线程信息</span><br><span class="line">        kr = thread_info(thread_list[i], THREAD_BASIC_INFO, (thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">        if (kr != KERN_SUCCESS)</span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">        basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line">        if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            // cpu_usage : Scaled cpu usage percentage. The scale factor is TH_USAGE_SCALE.</span><br><span class="line">            // 宏定义 TH_USAGE_SCALE 返回 CPU 处理总频率：</span><br><span class="line">            total_cpu_usage += basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注意方法最后要调用 vm_deallocate，防止出现内存泄漏</span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">    return total_cpu_usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中使用 <code>task_threads</code> API 调用获取指定的 task
的线程列表。<code>task_threads</code> 将 <code>target_task</code>
任务中的所有线程保存在 <code>act_list</code> 数组中，数组包含
<code>act_listCnt</code> 个条目。上述源码中，在调用
<code>task_threads</code> API 时，<code>target_task</code> 参数传入的是
<code>mach_task_self()</code>，表示获取当前的 Mach task。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kern_return_t task_threads</span><br><span class="line">(</span><br><span class="line">	task_t target_task,</span><br><span class="line">	thread_act_array_t *act_list,</span><br><span class="line">	mach_msg_type_number_t *act_listCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>在获取到线程列表后，代码中使用 <code>thread_info</code> API
调用获取指定线程的线程信息。<code>thread_info</code> 查询
<code>flavor</code> 指定的线程信息，将信息返回到长度为
<code>thread_info_outCnt</code> 字节的 <code>thread_info_out</code>
缓存区中。上述源码，在调用 <code>thread_info</code> API
时，<code>flavor</code> 参数传入的是
<code>THREAD_BASIC_INFO</code>，使用这个类型会返回线程的基本信息，即
<code>thread_basic_info_t</code> 结构体。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kern_return_t thread_info</span><br><span class="line">(</span><br><span class="line">	thread_act_t target_act,</span><br><span class="line">	thread_flavor_t flavor,</span><br><span class="line">	thread_info_t thread_info_out,</span><br><span class="line">	mach_msg_type_number_t *thread_info_outCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上述源码的最后，使用 <code>vm_deallocate</code> API
以防止出现内存泄露。</p>
<p>使用该方法采集到的 CPU 数据与腾讯的 GT、Instruments
数据接近。事实上，GT 也是采用这种方法采集 CPU 数据。</p>
<h2 id="memory">Memory</h2>
<p>通过上述 CPU
占用率监控原理，我们可以联想：内存使用情况是否也可以通过类似的方式获取到呢？答案是肯定的。</p>
<h3 id="相关系统原理-1">相关系统原理</h3>
<p>内存是有限且系统共享的资源，一个程序占用越多，系统和其他程序所能用的就越少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也会占用一定的内存资源。减少内存占用也能同时减少其对
CPU 时间维度上的消耗，从而使不仅使 App
以及整个系统也都能表现的更好。</p>
<p>MacOS 和 iOS
都采用了虚拟内存技术来突破物理内存的大小限制，每个进程都有一段由多个大小相同的页（Page）所构成的逻辑地址空间。处理器和内存管理单元（MMU，Memory
Management Unit）维护着由逻辑地址到物理地址的
<strong>页面映射表</strong>（简称
<strong>页表</strong>），当程序访问逻辑内存地址时，由 MMU
根据页表将逻辑地址转换为真实的物理地址。在早期的苹果设备中，每个页的大小为
4KB；基于 A7 和 A8 处理器的系统为 64 位程序提供了 16KB 的虚拟内存分页和
4KB 的物理内存分页；在 A9 之后，虚拟内存和物理内存的分页大小都达到了
16KB。</p>
<p>虚拟内存分页（Virtual Page，VP）有两种类型：</p>
<ol type="1">
<li>Clean：指能够被系统清理出内存且在需要时能重新加载的数据，包括：
<ul>
<li>内存映射文件</li>
<li>Frameworks 中的 __DATA_CONST 部分</li>
<li>应用的二进制可执行文件</li>
</ul></li>
<li>Dirty：指不能被系统回收的内存占用，包括：
<ul>
<li>所有堆上的对象</li>
<li>图片解码缓冲数据</li>
<li>Framework 中的 __DATA 和 __DATA_DIRTY 部分</li>
</ul></li>
</ol>
<p>由于内存容量和读写寿命的限制，iOS 上没有 Disk Swap 机制，取而代之使用
<strong>Compressed Memory</strong> 技术。 Disk Swap 是指在 macOS
以及一些其他桌面操作系统中，当内存可用资源紧张时，系统将内存中的内容写入磁盘中的backing
store（Swapping out），并且在需要访问时从磁盘中再读入 RAM（Swapping
in）。与大多数 UNIX 系统不同的是，macOS 没有预先分配磁盘中的一部分作为
backing store，而是利用引导分区所有可用的磁盘空间。</p>
<p>苹果最初只是公开了从 OS X Mavericks 开始使用 Compressed Memory
技术，但 iOS 系统也从 iOS 7 开始悄悄地使用。</p>
<p>Compressed Memory
技术在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，其特点可以归结为：</p>
<ul>
<li>减少了不活跃内存占用</li>
<li>改善电源效率，通过压缩减少磁盘 IO 带来的损耗</li>
<li>压缩/解压非常快，能够尽可能减少 CPU 的时间开销</li>
<li>支持多核操作</li>
</ul>
<p>本质上，Compressed Memory 也是 Dirty Memory。因此，<strong>memory
footprint = dirty size + compressed
size</strong>，这也是我们需要并且能够尝试去减少的内存占用。</p>
<h3 id="代码实现-1">代码实现</h3>
<p>在 <code>/usr/include/mach/task_info.h</code> 中，我们可以看到
<code>mach_task_basic_info</code> 和 <code>task_basic_info</code>
结构体的定义，分别如下所示。事实上，苹果公司已经不建议再使用
<code>task_basic_info</code> 结构体了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */</span><br><span class="line">struct mach_task_basic_info &#123;</span><br><span class="line">        mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">        mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">        mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */</span><br><span class="line">        time_value_t    user_time;          /* total user run time for</span><br><span class="line">                                               terminated threads */</span><br><span class="line">        time_value_t    system_time;        /* total system run time for</span><br><span class="line">                                               terminated threads */</span><br><span class="line">        policy_t        policy;             /* default policy for new threads */</span><br><span class="line">        integer_t       suspend_count;      /* suspend count for task */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* localized structure - cannot be safely passed between tasks of differing sizes */</span><br><span class="line">/* Don&#x27;t use this, use MACH_TASK_BASIC_INFO instead */</span><br><span class="line">struct task_basic_info &#123;</span><br><span class="line">        integer_t       suspend_count;  /* suspend count for task */</span><br><span class="line">        vm_size_t       virtual_size;   /* virtual memory size (bytes) */</span><br><span class="line">        vm_size_t       resident_size;  /* resident memory size (bytes) */</span><br><span class="line">        time_value_t    user_time;      /* total user run time for</span><br><span class="line">                                           terminated threads */</span><br><span class="line">        time_value_t    system_time;    /* total system run time for</span><br><span class="line">                                           terminated threads */</span><br><span class="line">	policy_t	policy;		/* default policy for new threads */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>mach_task_basic_info</code> 结构体存储了 Mach task
的内存使用信息，其中 <code>resident_size</code> 是 App
使用的驻留内存大小，<code>virtual_size</code> 是 App
使用的虚拟内存大小。</p>
<p>如下所示为内存使用情况的代码实现： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前 app 内存使用量</span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    struct mach_task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line">	</span><br><span class="line">	kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t) &amp;info, &amp;count);</span><br><span class="line">	if (kr == KERN_SUCCESS) &#123;</span><br><span class="line">		return info.resident_size;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而，我用 <strong>通过此方法获取到的内存信息与 Instruments 中的
Activity Monitor 采集到的内存信息进行比较，发现前者要多出将近
100MB</strong>。经过调研发现，苹果使用了上述的 Compressed
Memory，我猜测：<code>resident_size</code> 可能是将 Compressed Memory
解压后所统计到的一个数值。<strong>真实的物理内存的值应该是
<code>task_vm_info</code> 结构体中的 <code>pyhs_footprint</code>
成员的值</strong>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define TASK_VM_INFO            22</span><br><span class="line">#define TASK_VM_INFO_PURGEABLE  23</span><br><span class="line">struct task_vm_info &#123;</span><br><span class="line">	mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">	integer_t       region_count;       /* number of memory regions */</span><br><span class="line">	integer_t       page_size;</span><br><span class="line">	mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">	mach_vm_size_t  resident_size_peak; /* peak resident size (bytes) */</span><br><span class="line"></span><br><span class="line">	mach_vm_size_t  device;</span><br><span class="line">	mach_vm_size_t  device_peak;</span><br><span class="line">	mach_vm_size_t  internal;</span><br><span class="line">	mach_vm_size_t  internal_peak;</span><br><span class="line">	mach_vm_size_t  external;</span><br><span class="line">	mach_vm_size_t  external_peak;</span><br><span class="line">	mach_vm_size_t  reusable;</span><br><span class="line">	mach_vm_size_t  reusable_peak;</span><br><span class="line">	mach_vm_size_t  purgeable_volatile_pmap;</span><br><span class="line">	mach_vm_size_t  purgeable_volatile_resident;</span><br><span class="line">	mach_vm_size_t  purgeable_volatile_virtual;</span><br><span class="line">	mach_vm_size_t  compressed;</span><br><span class="line">	mach_vm_size_t  compressed_peak;</span><br><span class="line">	mach_vm_size_t  compressed_lifetime;</span><br><span class="line"></span><br><span class="line">	/* added for rev1 */</span><br><span class="line">	mach_vm_size_t  phys_footprint;</span><br><span class="line"></span><br><span class="line">	/* added for rev2 */</span><br><span class="line">	mach_vm_address_t       min_address;</span><br><span class="line">	mach_vm_address_t       max_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因此，正确的内存使用情况的代码实现应该如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前 app 内存使用量</span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    task_vm_info_data_t vmInfo;</span><br><span class="line">    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">    kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);</span><br><span class="line">    if (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">        int64_t memoryUsageInByte = (int64_t) vmInfo.phys_footprint;</span><br><span class="line">        return memoryUsageInByte / 1024 / 1024;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="fps">FPS</h2>
<p>FPS（Frames Per
Second）是指画面每秒传输的帧数。每秒帧数越多，所显示的动画就越流畅，一般只要保持
FPS 在 50-60，App 就会有流畅的体验，反之会感觉到卡顿。</p>
<h3 id="相关系统原理-2">相关系统原理</h3>
<p><code>CADisplayLink</code>
是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。</p>
<p>一旦 <code>CADisplayLink</code> 以特定的模式注册到
<code>runloop</code> 之后，每当屏幕需要刷新时，<code>runloop</code>
就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的
<code>selector</code>，此时 <code>target</code> 可以读取到
<code>CADisplayLink</code>
的每次调用的时间戳，用来准备下一帧显示需要的数据。如：一个视频应用使用时间戳来计算下一帧要显示的视频数据。</p>
<h3 id="代码实现-2">代码实现</h3>
<p>现阶段，常用的 FPS 监控几乎都是基于 <code>CADisplayLink</code>
实现的。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// swift</span><br><span class="line">final class FPSMonitor: NSObject &#123;</span><br><span class="line">    private var timer: Timer?</span><br><span class="line">    private var link: CADisplayLink?</span><br><span class="line">    private var count: UInt = 0</span><br><span class="line">    private var lastTime: TimeInterval = 0</span><br><span class="line"></span><br><span class="line">    func enableMonitor() &#123;</span><br><span class="line">        if link == nil &#123;</span><br><span class="line">            link = CADisplayLink(target: self, selector: #selector(fpsInfoCalculate(_:)))</span><br><span class="line">            link?.add(to: RunLoop.main, forMode: .common)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            link?.isPaused = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func disableMonitor() &#123;</span><br><span class="line">        if let link = link &#123;</span><br><span class="line">            link.isPaused = true</span><br><span class="line">            link.invalidate()</span><br><span class="line">            self.link = nil</span><br><span class="line">            lastTime = 0</span><br><span class="line">            count = 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc</span><br><span class="line">    func fpsInfoCalculate(_ link: CADisplayLink) &#123;</span><br><span class="line">        if lastTime == 0 &#123;</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        count += 1</span><br><span class="line">        let delta = link.timestamp - lastTime</span><br><span class="line">        if delta &gt;= 1 &#123;</span><br><span class="line">            // 间隔超过 1 秒</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            let fps = Double(count) / delta</span><br><span class="line">            count = 0</span><br><span class="line"></span><br><span class="line">            let intFps = Int(fps + 0.5)</span><br><span class="line">            print(&quot;帧率：\(intFps)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>CADisplayLink</code> 实现的 FPS
在生产场景中只有指导意义，不能代表真实的 FPS。因为基于
<code>CADisplayLink</code> 实现的 FPS 无法完全检测出当前 <strong>Core
Animation</strong> 的性能情况，只能检测出当前 <strong>RunLoop</strong>
的帧率。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/aozhimin/iOS-Monitor-Platform">iOS
性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a></li>
<li><a href="">深入解析Mac OS X 与 iOS 操作系统</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/416/">WWDC
2018 Session 416 iOS Memory Deep Dive</a></li>
<li><a href="https://techblog.toutiao.com/2018/06/19/untitled-40/">[
WWDC2018 ] - 深入解析iOS内存 iOS Memory Deep Dive</a></li>
<li><a
href="https://github.com/WebKit/webkit/blob/52bc6f0a96a062cb0eb76e9a81497183dc87c268/Source/WTF/wtf/cocoa/MemoryFootprintCocoa.cpp">WebKit
MemoryFootprintCocoa</a></li>
<li><a
href="http://newosxbook.com/articles/MemoryPressure.html">Handling low
memory conditions in iOS and Mavericks</a></li>
<li><a
href="https://developer.apple.com/library/archive/technotes/tn2434/_index.html">Minimizing
your app's Memory Footprint</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html">About
the Virtual Memory System</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/49829766">iOS
内存管理研究</a></li>
<li><a href="https://juejin.im/entry/5bbda00ef265da0ac446c970">iOS
Memory Deep Dive</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34348398">深入理解
CADisplayLink 和 NSTimer</a></li>
<li><a
href="https://www.jianshu.com/p/c35a81c3b9eb">CADisplayLink</a></li>
<li><a
href="https://opensource.apple.com/source/CF/CF-1152.14/CFRunLoop.c.auto.html">CFRunLoop.c</a></li>
<li><a
href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">计算机那些事(8)——图形图像渲染原理</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>性能监控</tag>
        <tag>iOS</tag>
        <tag>CPU</tag>
        <tag>Memory</tag>
        <tag>FPS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向工程——基础篇</title>
    <url>/2018/02/06/ios-reverse-engineering-basis/</url>
    <content><![CDATA[<h1 id="ios文件系统">iOS文件系统</h1>
<p>iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有一套标准的文件系统——<a
href="https://wylmer.gitbooks.io/filesystem-hierarchy-standard/content/">Filesystem
Hierarchy Standard（FHS）</a>，其常用目录结构如下所示：</p>
<span id="more"></span>
<ul>
<li><code>/</code>：根目录</li>
<li><code>/bin</code>：binary，存放用户级基础功能的二进制文件，如<code>ls</code>、<code>ps</code>等</li>
<li><code>/boot</code>：存放能使系统成功启动的所有文件。<strong>iOS中此目录为空</strong></li>
<li><code>/dev</code>：device，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备。块设备以块为单位传输数据，如硬盘；字符设备以字符为单位传输数据，如调制解调器</li>
<li><code>/sbin</code>：system
binaries，存放提供系统级基础功的二进制文件，如<code>netstat</code>、<code>reboot</code>等</li>
<li><code>/etc</code>：法语Et Cetera（and so
on的意思），存放系统脚本及配置文件，如<code>passwd</code>、<code>hosts</code>。iOS中，<code>/etc</code>是一个符号链接，实际指向<code>/private/etc</code></li>
<li><code>/lib</code>：存放系统库文件、内核模块及设备驱动等。<strong>iOS中此目录为空</strong></li>
<li><code>/mnt</code>：mount，存放临时的文件系统挂载点。<strong>iOS中此目录为空</strong></li>
<li><code>/private</code>：存放两个目录，分别是<code>/private/etc</code>和<code>/private/var</code></li>
<li><code>/tmp</code>：临时目录。iOS中，<code>/tmp</code>是一个符号链接，实际指向<code>/private/var/tmp</code></li>
<li><code>/usr</code>：包含大多数用户和程序。
<ul>
<li><code>/usr/bin</code>：包含那些<code>/bin</code>和<code>/sbin</code>中未出现的基础功能，如<code>nm</code>、<code>killall</code>等</li>
<li><code>/usr/include</code>：包含所有的标准C头文件</li>
<li><code>/usr/lib</code>：存放库文件</li>
</ul></li>
<li><code>/var</code>：variable，存放一些经常更改的文件，如日志、用户数据、临时文件等。
<ul>
<li><code>/var/mobile</code>：存放了mobile用户的文件。<strong>逆向工程重点关注目录</strong></li>
<li><code>/var/root</code>：存放了root用户的文件</li>
</ul></li>
</ul>
<h2 id="ios独有目录">iOS独有目录</h2>
<p>下图所示分别是OSX和iOS的根目录结构，与FHS还是有一定的区别。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs001.png" /></p>
<p>对于iOS，其独有的目录如下思维导图所示：</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs002.png?x-oss-process=image/resize,w_500" /></p>
<ul>
<li><code>/Applications</code>：存放所有的<strong>系统App</strong>和<strong>来自于Cydia的App</strong>，不包括StoreApp</li>
<li><code>/Developer</code>：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录
<ul>
<li><code>/Developer/Applications</code></li>
<li><code>/Developer/Library</code></li>
<li><code>/Developer/Tools</code></li>
<li><code>/Developer/usr</code></li>
</ul></li>
<li><code>/Library</code>：存放一些提供系统支持的数据
<ul>
<li><code>/Library/MobileSubstrate/DynamicLibraries</code>：<strong>存放Cydia安装程序的<code>.plist</code>和<code>.dylib</code>文件</strong></li>
</ul></li>
<li><code>/System/Library</code>：iOS文件系统中最重要的目录之一，存放大量系统组件
<ul>
<li><code>/System/Library/Frameworks</code>：<strong>存放iOS中各种日常使用的framework</strong></li>
<li><code>/System/Library/PrivateFrameworks</code>：<strong>存放iOS中未公开的私有framework</strong></li>
<li><code>/System/Library/CoreServices/SpringBoard.app</code>：iOS桌面管理器</li>
</ul></li>
<li><code>/User</code>：用户目录（<code>mobile</code>用户的<code>home</code>目录），实际指向<code>/var/mobile</code>，存放大量用户数据
<ul>
<li><code>/var/mobile/Media/DCIM</code>：存放照片</li>
<li><code>/var/mobile/Media/Recording</code>：存放录音文件</li>
<li><code>/var/mobile/Library/SMS</code>：存放短信数据库</li>
<li><code>/var/mobile/Library/Mail</code>：存放邮件数据</li>
<li><code>/var/mobile/Containers</code>：<strong>存放StoreApp</strong>。
<ul>
<li><code>/var/mobile/Containers/Bundle</code>：<strong>存放所有StoreApp的可执行文件和相关资源</strong></li>
<li><code>/var/mobile/Containers/Data</code>：<strong>存放所有StoreApp的数据，沙盒目录的真实目录</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="ios应用storeapp沙盒">iOS应用（StoreApp）沙盒</h2>
<p>出于安全考虑，iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问）。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs004.png?x-oss-process=image/resize,w_500" /></p>
<p>上图所示为沙盒结构，沙盒在逻辑上包含两个部分：<code>Bundle Container</code>和<code>Data Container</code>，两者在iOS文件系统中的位置是平行的，分别是<code>/var/mobile/Containers/Bundle</code>和<code>/var/mobile/Containers/Data</code>。实际开发中，通过<code>NSHomeDirectory()</code>方法获取到沙盒根目录对应的是<code>Data Container</code>的路径。</p>
<h3 id="bundle-container">Bundle Container</h3>
<p>bundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。</p>
<p>在正向开发时，我们上传至App Store的ipa（iPhone
Application）包，解压后会有一个<code>Payload</code>目录，其内部又包含一个<code>.app</code>目录，这个目录就是一个App的目录结构，也是一个bundle。</p>
<p><code>Bundle Container</code>位于<code>/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/</code>主要用于存放静态资源，主要包含以下目录和文件：</p>
<ul>
<li><p><strong><code>MyApp.app</code></strong><br />
存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、<code>.plist</code>文件。这个目录不会被iTunes同步。</p></li>
<li><p><strong><code>iTunesArtWork</code></strong></p></li>
<li><p><strong><code>iTunesMetadata.plist</code></strong></p></li>
</ul>
<h3 id="data-container">Data Container</h3>
<p><code>Data Container</code>位于<code>/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/</code>，主要用于存放App运行时产生的动态数据，其主要包含以下目录和文件：</p>
<ul>
<li><strong><code>Documents</code></strong><br />
存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录</li>
<li><strong><code>Library</code></strong>
<ul>
<li><strong><code>Library/Caches</code></strong><br />
存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。</li>
<li><strong><code>Library/Preferences</code></strong><br />
存放偏好设置。使用<code>NSUserDefaults</code>写的设置数据都会保存在该目录下的一个<code>plist</code>文件中。iTunes或iCloud同步设备时备份该目录。</li>
</ul></li>
<li><strong><code>tmp</code></strong><br />
存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。</li>
</ul>
<p>在正向开发时，沙盒目录路径均有相应的获取方式，具体如下所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 沙盒目录</span><br><span class="line">NSLog(@&quot;%@&quot;,NSHomeDirectory());</span><br><span class="line"></span><br><span class="line">// MyApp.app</span><br><span class="line">NSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]);</span><br><span class="line"></span><br><span class="line">// Documents</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *docPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,docPath);</span><br><span class="line"></span><br><span class="line">// Library</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,libPath);</span><br><span class="line"></span><br><span class="line">// tmp</span><br><span class="line">NSLog(@&quot;%@&quot;,NSTemporaryDirectory());</span><br></pre></td></tr></table></figure></p>
<p>在逆向工程中，可以通过以下方式获取相关的目录： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取App的Bundle路径</span><br><span class="line">iphone: root# ps -e | grep appname</span><br><span class="line"></span><br><span class="line">// 获取App的Data路径</span><br><span class="line">iphone: root# cycript -p appname</span><br><span class="line">cy# directory = NSHomeDirectory()</span><br></pre></td></tr></table></figure></p>
<h1 id="ios二进制文件类型">iOS二进制文件类型</h1>
<p>iOS逆向的目标主要包含三类二进制文件：<code>Application</code>、<code>Dynamic Library</code>、<code>Daemon</code>。</p>
<h2 id="application">Application</h2>
<p>Application，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要：</p>
<ul>
<li><p><code>Info.plist</code><br />
Info.plist记录了App的基本信息，如：<strong><code>bundle identifier</code></strong>、<strong>可执行文件名</strong>、<strong>图标文件名</strong>等。</p></li>
<li><p>可执行文件<br />
查看Info.plist，即可定位可执行文件</p></li>
<li><p>lproj目录<br />
lproj目录下存放的是各种本地化的字符串。</p></li>
</ul>
<h3 id="系统app-vs.-storeapp">系统App VS. StoreApp</h3>
<p><code>/Applications/</code>目录下存放<strong>系统App</strong>（包括CydiaApp）；<code>/var/mobile/Containers/</code>目录下存放<strong>StoreApp</strong>。其区别在于：</p>
<ul>
<li><p>目录结构<br />
两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在<code>/var/mobile/Containers/Data/</code>下，以mobile权限运行的系统App的数据目录在<code>/var/mobile/</code>下，以root权限运行的系统App的数据目录在<code>/var/root/</code>下。</p></li>
<li><p>安装格式和权限<br />
Cydia
App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。</p></li>
</ul>
<h2 id="dynamic-library">Dynamic Library</h2>
<p>Dynamic
Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。</p>
<p>在iOS中，lib分为static和dynamic两种，其中static
lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。</p>
<p><strong>dylib是逆向工程的重要目标类型</strong>，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。</p>
<p>越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。</p>
<h2 id="daemon">Daemon</h2>
<p>iOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查<code>/System/Library/LaunchDaemons</code>和<code>/Library/LaunchDaemons</code>下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的<code>Info.plist</code>文件作用类似，即记录Daemon的基本信息。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《iOS应用逆向工程（第2版）》</li>
<li><a
href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html">File
System Programming Guide</a></li>
<li><a
href="http://www.cnblogs.com/wujy/archive/2016/02/13/5188302.html">iOS底层基础知识-文件目录结构</a></li>
<li><a href="https://www.jianshu.com/p/9cc4f0975d1d">iOS
APP沙盒目录</a></li>
<li><a href="https://bbs.feng.com/read-htm-tid-249.html">Mac OS X
术语表</a></li>
<li><a
href="http://www.cocoachina.com/mac/20150122/10988.html">了解iOS上的可执行文件和Mach-O格式</a></li>
<li><a
href="http://oncenote.com/2015/06/01/How-App-Launch/">由App的启动说起</a></li>
<li><a href="https://objccn.io/issue-6-3/">Mach-O 可执行文件</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向工程</tag>
        <tag>沙盒原理</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C Runtime 消息传递与转发</title>
    <url>/2018/10/20/ios-runtime-message-sending-and-forwarding/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C
通过一个用 C 语言和汇编实现的 runtime，在 C
语言的基础上实现了面向对象的功能。在 runtime
中，对象用结构体表示，方法用函数表示。</p>
<span id="more"></span>
<p>C 语言是一门静态语言，其在编译时决定调用哪个函数。而 Objective-C
则是一门动态语言，其在编译时不能决定最终执行时调用哪个函数（Objective-C
中函数调用称为消息传递）。Objective-C 的这种动态绑定机制正是通过 runtime
这样一个中间层实现的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-runtime-hierachry.png?x-oss-process=image/resize,w_300" /></p>
<p>为了分析 runtime 是如何进行动态绑定，我们首先需要了解一下 Objective-C
中类与对象等基本结构在 C 语言层面是如何实现的。</p>
<h1 id="数据结构">数据结构</h1>
<h2 id="objective-c-类">Objective-C 类</h2>
<p>Objective-C 类是由 <code>Class</code> 类型表示的，它本质上是一个指向
<code>objc_class</code> 结构体的指针。如下所示为
<code>objc/runtime.h</code> 中关于类的定义： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line"></span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure></p>
<h2 id="objective-c-对象">Objective-C 对象</h2>
<p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向
<code>objc_object</code> 结构体的指针。如下所示为
<code>objc/objc.h</code> 中关于对象的定义： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>objc_object</code> 结构体中只有一个成员，即指向其类的
<code>isa</code> 指针。<strong>当向一个 Objective-C
对象发送消息时，runtime 会根据实例对象的 <code>isa</code>
指针找到其所属的类。Runtime
会在类的方法列表以及父类的方法列表中去寻找与消息对应的
<code>selector</code> 指向的方法，找到后即运行该方法。</strong></p>
<h2 id="objective-c-元类meta-class">Objective-C 元类（meta class）</h2>
<p><code>meta-class</code> 是一个<strong>类对象的类</strong>。在
Objective-C
中，所有的类本身也是一个对象。事实上，在很多原型编程语言也采用这种“万物皆对象”的设计思想，如：Io。</p>
<p>通过向该对象发送消息，即可实现对类方法的调用。前提是类的
<code>isa</code> 指针必须指向一个包含这些类方法的
<code>objc_class</code> 结构体。<code>meta-class</code>
中存储着一个类的所有类方法。所以，类对象的 <code>isa</code>
指针指向的就是 <code>meta-class</code>。</p>
<ul>
<li><strong>当向一个对象发送消息时，runtime
会在这个对象所属的类的方法列表中查找方法。</strong></li>
<li><strong>当向一个类发送消息时，runtime 会在这个类的 meta-class
的方法列表中查找。</strong></li>
</ul>
<p>思考一下，<code>meta-class</code>
也是一个类，也可以向它发送一个消息，那么它的 <code>isa</code>
又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C
的设计者让所有的 <code>meta-class</code> 的 <code>isa</code> 指向基类的
<code>meta-class</code>，以此作为它们的所属类。</p>
<p>下图所示，为 Objective-C 对象在内存中的引用关系图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-time-message-send.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="objective-c-方法">Objective-C 方法</h2>
<p>方法实际上是一个指向 <code>objc_method</code>
结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于方法的定义：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 结构体中包含成员 <code>SEL</code> 和
<code>IMP</code>，两者将方法的名字与实现进行了绑定。通过
<code>SEL</code>，可以找到对应的
<code>IMP</code>，从而调用方法的具体实现。</p>
<h3 id="sel">SEL</h3>
<p><code>SEL</code> 又称选择器，是一个指向 <code>objc_selector</code>
结构体的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>方法的 <code>selector</code>
用于表示运行时方法的名字。<strong>Objective-C
在编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（
<code>Int</code> 类型的地址），即 <code>SEL</code>。</strong></p>
<p>由于一个类的方法列表中不能存在两个相同的 <code>SEL</code>，所以
Objective-C 不支持重载。但是不同类之间可以存在相同的
<code>SEL</code>，因为不同类的实例对象执行相同的 <code>selector</code>
时，会在各自的方法列表中去根据 <code>selector</code> 去寻找自己对应的
<code>IMP</code>。</p>
<p>通过下面三种方法可以获取 <code>SEL</code>：</p>
<ul>
<li><code>sel_registerName</code> 函数</li>
<li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li>
<li><code>NSSeletorFromString()</code> 方法</li>
</ul>
<h3 id="imp">IMP</h3>
<p><code>IMP</code> 本质上就是一个函数指针，指向方法实现的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL,...);</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<ul>
<li><code>id</code>：指向 <code>self</code>
的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）</li>
<li><code>SEL</code>：方法选择器</li>
<li><code>...</code>：方法的参数列表</li>
</ul>
<p><code>SEL</code> 与 <code>IMP</code> 的关系类似于哈希表中
<code>key</code> 与 <code>value</code>
的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p>
<h1 id="消息传递方法调用">消息传递（方法调用）</h1>
<p>在 Objective-C
中，<strong>消息直到运行时才绑定到方法实现上</strong>。编译器会将消息表达式
<code>[receiver message]</code> 转化为一个消息函数的调用，即
<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为主要参数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)                    // 不带参数</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)    // 带参数</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code> 通过以下几个步骤实现了动态绑定机制。</p>
<ul>
<li>首先，获取 <code>selector</code>
指向的方法实现。由于相同的方法可能在不同的类中有着不同的实现，因此根据
<code>receiver</code> 所属的类进行判断。</li>
<li>其次，传递 <code>receiver</code>
对象、方法指定的参数来调用方法实现。</li>
<li>最后，返回方法实现的返回值。</li>
</ul>
<p>消息传递的关键在于前文讨论过的 <code>objc_class</code>
结构体，其有两个关键的字段：</p>
<ul>
<li><code>isa</code>：指向父类的指针</li>
<li><code>methodLists</code>:
类的方法分发表（<code>dispatch table</code>）</li>
</ul>
<p>当创建一个新对象时，先为其分配内存，并初始化其成员变量。其中
<code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承链。</p>
<p>下图所示为消息传递过程的示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-messaging-framework.png?x-oss-process=image/resize,w_800" /></p>
<ul>
<li>当消息传递给一个对象时，首先从运行时系统缓存 <code>objc_cache</code>
中进行查找。如果找到，则执行。否则，继续执行下面步骤。</li>
<li><code>objc_msgSend</code> 通过对象的 <code>isa</code>
指针获取到类的结构体，然后在方法分发表 <code>methodLists</code>
中查找方法的 <code>selector</code>。如果未找到，将沿着类的
<code>isa</code> 找到其父类，并在父类的分发表 <code>methodLists</code>
中继续查找。</li>
<li>以此类推，一直沿着类的继承链追溯至 <code>NSObject</code>
类。一旦找到
<code>selector</code>，传入相应的参数来执行方法的具体实现，并将该方法加入缓存
<code>objc_cache</code> 。如果最后仍然没有找到
<code>selector</code>，则会进入<strong>消息转发</strong>流程（下文将进行介绍）。</li>
</ul>
<h1 id="消息转发">消息转发</h1>
<p>当一个对象能接收一个消息时，会走正常的消息传递流程。当一个对象无法接收某一消息时，会发生什么呢？默认情况下，如果以
<code>[object message]</code> 的形式调用方法，如果 <code>object</code>
无法响应 <code>message</code> 消息时，编译器会报错。如果是以
<code>performSeletor:</code> 的形式调用方法，则需要等到运行时才能确定
<code>object</code> 是否能接收 <code>message</code>
消息。如果不能，则程序崩溃。</p>
<p>对于后者，当不确定一个对象是否能接收某个消息时，可以调用
<code>respondsToSelector:</code> 来进行判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，当一个对象无法接收某一消息时，就会启动所谓“消息转发（message
forwarding）”机制。通过消息转发机制，我们可以告诉对象如何处理未知的消息。</p>
<p>消息转发机制大致可分为三个步骤：</p>
<ul>
<li>动态方法解析（Dynamic Method Resolution）</li>
<li>备用接收者</li>
<li>完整消息转发</li>
</ul>
<p>下图所示为消息转发过程的示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/ios-message-forwarding.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="动态消息解析">动态消息解析</h2>
<p>对象在接收到未知的消息时，首先会调用所属类的类方法
<code>+resolveClassMethod:</code> 或实例方法
<code>+resolveInstanceMethod:</code>。</p>
<p>在这两个方法中，我们可以为未知消息新增一个“处理方法”，通过运行时
<code>class_addMethod</code> 函数动态添加到类中。比如：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // 方法实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="备用接收者">备用接收者</h2>
<p>如果在上一步无法处理消息，则 runtime 会继续调用
<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p>
<p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是
<code>self</code>）
的对象，则这个对象会称为消息的新接收者，消息会被分发到这个对象。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([selString isEqualToString:@&quot;walk&quot;]) &#123;</span><br><span class="line">        return self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h2 id="完整消息转发">完整消息转发</h2>
<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。
这一步调用 <code>methodSignatureForSelector</code>
进行方法签名，这可以将函数的参数类型和返回值封装。如果返回
<code>nil</code>，则说明消息无法处理并报错
<code>unrecognized selector sent to instance</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;  </span><br><span class="line">    return [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回 <code>methodSignature</code>，则进入
<code>forwardInvocation</code>。对象会创建一个表示消息的
<code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在
<code>anInvocation</code> 中，包括
<code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错
<code>unrecognized selector sent to instance</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以利用备用接受者和完整消息转发实现对接受消息对象的转移，可以实现“多重继承”的效果。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Objective-C
Runtime Programming Guide</a></li>
<li><a
href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html">Objective-C
Runtime · 笔试面试知识整理</a></li>
<li><a
href="https://www.jianshu.com/p/adf0d566c887">iOS运行时(Runtime)详解+Demo</a></li>
<li><a
href="https://www.jianshu.com/p/f493bc6a949e">iOS内功篇：runtime</a></li>
</ol>
]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>基于树的iOS页面路径转换设计</title>
    <url>/2018/04/01/ios-tree-based-path-conversion-design/</url>
    <content><![CDATA[<h2 id="需求场景">需求场景</h2>
<p>采集用户在购买VIP或购买商品时的操作路径，如："首页" -&gt;
"搜题历史页" -&gt; "题目详情页1" -&gt; "名师大招"。</p>
<span id="more"></span>
<h3 id="设计原则">设计原则</h3>
<ol type="1">
<li>易用性</li>
<li>可靠性</li>
</ol>
<h3 id="方案分析">方案分析</h3>
<p>考虑到上述两个设计原则，路径转换在每个页面中的使用都不应该受限于其相对于其他页面的位置或关系。简而言之，即具备独立性和通用性。以view
controller为例，路径转换在特定的生命周期阶段使用，就是符合设计原则的。</p>
<p>以下有两种方案：基于栈的设计、基于多叉树的设计。下面依次进行分析。</p>
<h4 id="栈">1. 栈</h4>
<p>下图所示为两个View
Controller切换时，各个VC的生命周期的切换顺序，其中A为父VC，B为子VC。为了遵循上述设计原则，我们希望能够在特定生命周期进行push/pop操作。合法的push/pop组合应该遵循如下的调用顺序：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A push -&gt; B push -&gt; B pop -&gt; A pop</span><br></pre></td></tr></table></figure></p>
<p>然而，我们在下图中找不到一个合法的push/pop组合，除了【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种情况。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vcs-lifecycle.png?x-oss-process=image/resize,w_570" /></p>
<p>那么，在【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】是不是真能应对所有场景呢？</p>
<p>试想如下图所示这样一种场景，当一个VC包含多个VC对象时，其中一个VC再调用子VC。这时候，我们期望得到的路径应该是：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p>
<p>然而在很多情况下，A会在<code>init</code>/<code>viewDidLoad</code>阶段初始化多有VC对象。这时候如果使用的是【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种组合，在E中得到的路径会是：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-multisubvcs-structure.png?x-oss-process=image/resize,w_250" /></p>
<p>综合上述，使用栈结构很难实现一种易用、可靠的设计方案。</p>
<h4 id="树">2. 树</h4>
<p>我们使用多叉树实现了一个易用、可靠的路径转换方案。如下左图所示，为一个app经常会面临的vc结构。我们使用多叉树来描述ap的vc结构。在任何时候，页面总是能够返回到根页面（tab页），所以树节点不会形成环，即可以使用树结构来进行描述，如右图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/tree-based-path-conversion-design.png" /></p>
<p>其中，树节点包括四个属性： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface VGOKeyfromBaseNode : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak, nullable) __kindof VGOKeyfromBaseNode *parentNode;  // 父节点</span><br><span class="line">@property (nonatomic, strong) NSString *value;      // 节点信息</span><br><span class="line">@property (nonatomic, strong) NSMutableArray&lt;__kindof VGOKeyfromBaseNode *&gt; *subNodes;   // 子节点</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>为了能够维护多棵树，使用 <code>VGOKeyfromTreeManager</code>
进行管理，其包含两个属性： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof VGOKeyfromBaseNode *&gt; *keyfromTrees;     // 存储各个树的根节点</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof VGOKeyfromBaseNode *&gt; *currentNodes;     // 存储各个树的当前节点</span><br></pre></td></tr></table></figure></p>
<p>以 <code>keyfromNode</code> 的类型名称作为
key，分别保存了树的根节点以及当前节点。</p>
<p>使用的方法是：</p>
<ol type="1">
<li>在<code>viewDidLoad</code>阶段，创建节点并加入树中。</li>
<li>在<code>viewWillAppear/viewDidAppear</code>阶段或者在进入新页面之前，将该节点设置为当前节点。</li>
<li>在<code>dealloc</code>阶段，将本节点的父节点设置为当前节点，并将该节点从树中删除。</li>
</ol>
<p>树管理器的公有接口如下所示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建根节点</span><br><span class="line">- (void)createKeyfromTreeWithRootNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line"></span><br><span class="line">// 设置节点为当前节点</span><br><span class="line">- (void)updateCurrentNodeWithNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line"></span><br><span class="line">// 向树中添加子节点</span><br><span class="line">- (void)addNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line">// 从树中删除子节点</span><br><span class="line">- (void)removeNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line"></span><br><span class="line">// 获取从根节点到指定节点的列表</span><br><span class="line">- (NSArray&lt;__kindof VGOKeyfromBaseNode *&gt; *)nodePathToLastNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line">// 获取从根节点到指定节点的列表，并进行过滤</span><br><span class="line">- (NSArray&lt;__kindof VGOKeyfromBaseNode *&gt; *)nodePathToLastNode:(__kindof VGOKeyfromBaseNode *)node exceptValue:(nullable NSString *)value;</span><br><span class="line"></span><br><span class="line">// 获取从根节点到指定节点的路径</span><br><span class="line">- (NSString *)keyfromPathToLastNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line">// 获取从根节点到指定节点的路径，并自定义联结符号、过滤内容</span><br><span class="line">- (NSString *)keyfromPathToLastNode:(__kindof VGOKeyfromBaseNode *)node exceptValue:(nullable NSString *)value joinWith:(NSString *)join;</span><br></pre></td></tr></table></figure></p>
<p>节点的公有接口如下所示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将本节点设置为根节点</span><br><span class="line">- (void)setAsRootNode;</span><br><span class="line">// 将本节点设置为当前节点</span><br><span class="line">- (void)setAsCurrentNode;</span><br><span class="line"></span><br><span class="line">// 将本节点添加至树中</span><br><span class="line">- (void)addToKeyfromTree;</span><br><span class="line">// 将本节点从树种删除</span><br><span class="line">- (void)removeFromKeyfromTree;</span><br><span class="line"></span><br><span class="line">// 清空本节点的所有子节点</span><br><span class="line">- (void)clearSubNodes;</span><br><span class="line"></span><br><span class="line">// 获取本节点类型的根节点</span><br><span class="line">+ (__kindof VGOKeyfromBaseNode *)rootNode;</span><br><span class="line">// 获取本节点类型的当前节点</span><br><span class="line">+ (__kindof VGOKeyfromBaseNode *)currentNode;</span><br><span class="line">// 获取本节点类型的 keyfrom 路径</span><br><span class="line">+ (NSString *)keyfromPath;</span><br></pre></td></tr></table></figure></p>
<p>实践证明，这种设计方案还能够非常简单地应用到一下这些场景之中。</p>
<ol type="1">
<li>view Controller、View混合路径；</li>
<li>统跳；</li>
<li>view Controller多处复用、节点信息不同；</li>
<li>忽略路径中特定节点</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>路径转化</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS View Controller概览</title>
    <url>/2017/08/27/ios-viewcontroller-introduce/</url>
    <content><![CDATA[<h2 id="引言">### 引言</h2>
<p>在斯坦福CS193p课程中，白胡子老教授首先介绍了iOS开发中的<a
href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>软件设计模式，这是因为iOS应用即采用此种设计模式。如下图所示，MVC模式将软件分为三个部分：</p>
<span id="more"></span>
<ul>
<li>Model：数据存储层<br />
</li>
<li>View：视图展示层<br />
</li>
<li>Controller：逻辑控制层</li>
</ul>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-mvc.png" /></p>
<p>MVC模式隔离了视图层和数据层，两者必须以控制层作为中介实现交互和通信。实际的iOS应用一般都是MVC模式的嵌套组合实现，如下图所示。其中，控制层是由UIViewController类及其子类（如：UITableViewController、UINavigationController、UITabBarController）的实例实现的。UIViewController自带一个根视图层（即view属性），以便添加和操作用户自定义的视图层。当然，我们也可以在UIViewController中定义数据层。这是因为UIViewController需要这样的接口来连通并控制M和V。但是，好的设计会尽量将数据层和视图层从UIViewController中解耦分离出来。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-mvcs.png" /></p>
<h2 id="视图控制器">### 视图控制器</h2>
<h4 id="分类">分类</h4>
<p>前面说到，实际的app采用MVC嵌套组合的设计模式，以此为据，app中至少包含一个视图控制器。这些视图控制器管理着app中所有的事务，包括：视图管理、事件处理、视图控制器之间的调度等等。</p>
<p>既然视图控制器具有可以嵌套和组合，那么肯定有部分视图控制器可以充当视图控制器的容器。事实上，视图控制器的确可以分为以下两种：</p>
<ul>
<li>内容视图控制器（Content View
Controller）：用于管理app内容的视图控制器，也是最常用的视图控制器。<br />
</li>
<li>容器视图控制器（Container View
Controller）：作为其他视图控制器的容器，并以某种方式呈现这些视图控制器及其内容。</li>
</ul>
<h5 id="内容视图控制器">内容视图控制器</h5>
<p>内容视图控制器是最常用的元素，常见的有三种（后两者是前者的子类）：</p>
<ul>
<li>UIViewController</li>
<li>UITableViewController</li>
<li>UICollectionViewController</li>
</ul>
<p>常用的在大多数情况下，app上的一个页面就是由一个视图控制器所展现的。内容视图控制器的主要任务包含：</p>
<ul>
<li>更新视图内容，通常是响应底层数据的变化<br />
</li>
<li>响应用户与视图的交互<br />
</li>
<li>缩放视图、管理布局</li>
</ul>
<h5 id="容器视图控制器">容器视图控制器</h5>
<p>容器视图控制器使用属性viewcontrollers来存储对视图控制器的引用，并且不对容器中视图控制器的数量作限制。最常见容器视图控制器的有两种（两者均是UIViewController的子类）：</p>
<ul>
<li>UINavigationController<br />
</li>
<li>UITabBarController</li>
</ul>
<p>关于viewcontrollers属性，UINavigationController采用的是stack结构，UITabBarController采用的是array结构。不同的数据结构，对视图控制器的调度形式也不同。</p>
<p>下图所示为UINavigationController的应用示例，UINavigationController采用stack的方式调度页面（即视图控制器）。</p>
<p>三个视图控制器视图的顶部是UINavigationController的导航栏，当切换到某个内容视图控制器时，导航栏的样式可以由该视图控制器进行配置。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-uinavigationcontroller04.png" /></p>
<p>下图所示为UITabBarController的应用示例，其对页面的调度和操作array一样灵活，视图的底部有四个标签，对应着4个独立的视图控制器，可任意切换。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-uitabbarcontroller03.png" /></p>
<h4 id="视图管理">视图管理</h4>
<p>视图管理器，顾名思义，其有一个重要的作用就是：管理视图的层次结构。每个视图控制器都有一个根视图，其中包含了视图控制器的所有内容，可通过view属性获取。通过该属性，我们可以添加更多视图。<br />
内容视图管理器自身管理其所有的视图；容器视图管理器则采用分治的方式，通过子视图控制器来进行视图管理。
下图所示，代表性地展示了内容视图控制器及其视图之间的关系。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-relation-of-viewcontroller-and-views.png" /></p>
<h4 id="数据管理">数据管理</h4>
<p>在MVC设计模式中，视图控制器作为承担着数据和视图通信的中介角色。通过UIViewController的内置及自定义的属性和方法，可以完成控制器需要承担的任务。如下图所示，为视图控制器与数据、视图的关系示意图。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-relation-of-mvc.png" /></p>
<p>在实际开发中，我们始终应该清晰地分离视图控制器和数据对象。视图控制器应该扮演逻辑控制的角色，而应该减少数据管理的角色。</p>
<p>为了处理数据管理，很多设计使用了MVVM的设计模式，这种设计添加了一个View
Model层来对来自Model层的原始数据进行处理，从而提供给Controller，使其可以直接使用。</p>
<h3 id="生命周期">生命周期</h3>
<p>如下图所示为视图控制器的生命周期，其中与视图view相关的步骤较多。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-viewcontroller-lifecycle01.png" /></p>
<ul>
<li>init:
<ul>
<li>init阶段，通常只初始化比较关键的数据，而不会在该阶段对view进行初始化。</li>
</ul></li>
<li>loadView:
<ul>
<li>loadView阶段，通常只初始化view</li>
</ul></li>
<li>viewDidLoad
<ul>
<li>此时view不在为nil，适合创建一些附加的view及控件。</li>
</ul></li>
<li>viewWillAppear
<ul>
<li>该阶段阶段view即将被添加到app的window对象之上。一般在view被添加到superview之前，切换动画之前调用。</li>
</ul></li>
<li>viewDidAppear
<ul>
<li>一般用户显示后，可以进行动画操作。</li>
</ul></li>
</ul>
<p>如果在视图控制器中添加自定义的视图，则生命周期中还会多出两个步骤：</p>
<ul>
<li>viewWillLayoutSubviews</li>
<li>viewDidLayoutSubviews</li>
</ul>
<p>如下图所示，我分别在loadView和viewDidLoad阶段添加了一个视图，而viewWillLayoutSubviews和viewDidLayoutSubviews均出现在viewWillAppear之后。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)loadView &#123;</span><br><span class="line">    [super loadView];</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));</span><br><span class="line">    </span><br><span class="line">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(100, 400, 100, 50)];</span><br><span class="line">    button.backgroundColor = [UIColor blueColor];</span><br><span class="line">    [button addTarget:self action:@selector(buttonPressed) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));</span><br><span class="line">    </span><br><span class="line">    self.testView = [[TestView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)];</span><br><span class="line">    self.testView.backgroundColor = [UIColor grayColor];</span><br><span class="line">    [self.view addSubview:self.testView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-viewcontroller-lifecycle03.png" /></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIViewController</tag>
      </tags>
  </entry>
  <entry>
    <title>IP 协议相关技术</title>
    <url>/2019/03/09/ip-protocols/</url>
    <content><![CDATA[<p>IP（Internet
Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP
是无法实现通信的，还必须具有解析主机名、MAC
地址以及数据包在发送过程中异常情况处理等功能。</p>
<span id="more"></span>
<p>下文将详细介绍 IP 的各种辅助技术，主要包括：</p>
<ul>
<li>DNS</li>
<li>ARP</li>
<li>DHCP</li>
<li>NAT</li>
<li>Mobile IP</li>
</ul>
<h1 id="dns">DNS</h1>
<p>通常来说，我们在访问某个网站时不会直接使用 IP 地址，而是使用类似于
<code>www.chuquan.me</code>
这样的域名进行访问。为什么使用域名就能访问目标地址？因为有 DNS（Domain
Name System）的支持，其可以将域名转换为具体的 IP 地址。</p>
<h2 id="dns-的产生">DNS 的产生</h2>
<p>在互联网的起源 ARPANET
中，起初由互联网信息中心（SRI-NIC）整体管理一份 hosts 文件，记录 ARPANET
网中所有计算机的 IP 地址。由于主机的 IP
地址可以变更，所以其他计算机也需要定期下载最新的 hosts
文件才能正常使用网络。</p>
<p>随着网络规模的扩大，这种集中管理方式的可行性及可靠性均逐渐下降。于是，诞生了一个可以有效管理主机名和
IP 地址之间对应关系的系统，即 DNS 系统。在 DNS
系统中，主机的管理机构维护了一个用来表示组织内部主机名和 IP
地址映射关系的数据库。当用户在应用（如浏览器）中输入主机名（域名）时，DNS
会自动检索数据库，并返回对应的 IP 地址。</p>
<h2 id="域名的构成">域名的构成</h2>
<p>域名是为了标识主机名和组织机构名的一个具有分层结构的字符串。如：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pku.edu.cn</span><br></pre></td></tr></table></figure> 其中，<code>pku</code> 表示北京大学（Peking
University）固有的域名；<code>edu</code>
表示教育相关结构；<code>cn</code> 表示中国。</p>
<p>域名的分层如下图所示，各级分层构成一个树形结构，顶点 root
是树的根节点，根节点的下一层称为第 1 层域名，又称
<strong>顶级域名</strong>，如：<code>cn</code>、<code>jp</code>
等国别顶级域名，<code>com</code>、<code>org</code>
等特定领域域名。顶级域名的下一层称为第 2
层域名，如：<code>ac</code>、<code>co</code>
等表示不同组织结构的属性域名，<code>beijing</code>
等表示地域的通用域名。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-hierachy.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="域名服务器">域名服务器</h2>
<p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。其所管理的分层称为
<code>ZONE</code>。如图所示，每层都有一个域名服务器。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system.png" /></p>
<p>DNS 分层结构的根节点设置的 DNS 称为
<strong>根域名服务器</strong>。根域名服务器中注册了
<strong>顶级域名服务器</strong> 的 IP 地址。顶级域名服务器中则注册了第 2
层域名服务器的 IP
地址，以此类推，构成一个分层系统。如果域名服务器宕机，则针对该域的 DNS
查询就会失败。因此为了提高容灾能力，一般会设置至少两个以上的域名服务器。一旦第一个域名服务器无法查询，就会自动转到第二个甚至第三个域名服务器上进行。</p>
<h2 id="解析器">解析器</h2>
<p>进行 DNS 查询的主机和软件称为 <strong>DNS
解析器</strong>。用户所使用的工作站或个人电脑都属于解析器。<strong>一个解析器至少要注册一个以上域名服务器的
IP 地址</strong>。通常，至少包括组织内部的域名服务器的 IP 地址。</p>
<h2 id="dns-工作原理">DNS 工作原理</h2>
<p>那么 DNS 的工作原理是什么呢？假设 <code>yuanfudao.com</code>
域中的主机 A 访问网站 <code>pku.edu.cn</code>，该过程的 DNS
查询流程如图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system-query.png?x-oss-process=image/resize,w_800" /></p>
<p>解析器为了获取 IP
地址，向域名服务器进行查询。接收到查询请求的域名服务器首先在自己的数据库进行查找。如果有该域名对应的
IP
地址就返回。如果没有，则域名服务器再向上一层域名服务器进行查询，依次类推，直到根域名服务器。然后根节点遍历，直到找到指定的域名服务器，并由该域名服务器返回对应的
IP 地址。</p>
<p>解析器和域名服务器通过将查询结果进行缓存来提高查询性能。</p>
<h1 id="arp">ARP</h1>
<p>通过 DNS 确定了目标域名的 IP 地址之后，就可以向该目标地址发送 IP
数据报。然而，在底层数据链路层，进行实际通信时有必要了解每个 IP
地址对应的 MAC 地址。</p>
<p>ARP（Address Resolution Protocol）是一种解决地址问题的协议。ARP
以目标 IP 地址为线索，确定下一个应该接收数据分包的网络设备的 MAC
地址。如果目标主机不在同一个链路上，可以通过 ARP 查找下一跳路由器的 MAC
地址。</p>
<blockquote>
<p>ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以使用 ICMPv6 替代 ARP
发送邻居探索消息。</p>
</blockquote>
<h2 id="arp-工作原理">ARP 工作原理</h2>
<p>ARP 是如果确定 MAC 地址的呢？事实上，ARP 主要通过 <strong>ARP
请求</strong> 与 <strong>ARP 响应</strong> 两种类型的包来确定 MAC
地址的。</p>
<p>如图所示，主机 A 向同一链路上的主机 B 发送 IP 包，主机 A 的 IP 地址为
<code>172.20.1.1</code>，主机 B 的 IP 地址为
<code>172.20.1.2</code>，它们互不知道对方的 MAC 地址。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/arp-protocol.png?x-oss-process=image/resize,w_800" /></p>
<p>主机 A 为了确定主机 B 的 MAC 地址，先通过广播发送一个 ARP
请求包，请求包中包含了主机 B 的IP 地址
<code>172.20.1.2</code>。由于广播的包可以被同一个链路上的所有主机或路由器接收，因此
ARP 包的请求包也会被同一链路上所有的主机和路由器进行解析。如果 ARP
请求包中的目标 IP 地址与自己的 IP 地址一致，则该节点就将自己的 MAC
地址存入 ARP 响应包并返回给主机 A。</p>
<p>如果每发送一个 IP 数据报都要进行一次 ARP 请求以此确定 MAC
地址，那么将会产生大量不必要的网络流量。为此，通常会将 IP 与 MAC
地址的映射关系缓存在一个 <strong>ARP 缓存表</strong> 中。除了 ARP
请求发送端可以缓存发送端 MAC 地址，接收端也可以从 ARP
请求包获取发送端主机的 IP 地址及其 MAC 地址并将其进行缓存。</p>
<p>不过，MAC
地址的缓存是有一定的期限的。超出期限之后，缓存的内容将被清除。</p>
<h2 id="rarp">RARP</h2>
<p>RARP（Reverse Address Resolution Protocol）是一种根据 MAC 地址定位 IP
地址的协议。例如：将打印机服务器等小型嵌入式设备接入到网络时就会用到。</p>
<p>通常，我们使用个人电脑设置 IP 地址时，可以通过 DHCP 自动分配获取 IP
地址。但是对于嵌入式设备，会遇到没有任何输入接口或无法通过 DHCP 动态获取
IP 地址的情况。在这种情况下，一般使用 RARP。为此，需要架设一台 RARP
服务器，然后再接入该设备到网络，启动设备时，设备会发送一条类似于“我的
MAC 地址是 xxx，我的 IP 地址是什么”的请求信息。RARP
服务器接收到请求消息之后，返回类似于“MAC 地址为 xxx 的设备，IP 地址为
xxx”的信息。设备根据该应答信息设置自己的 IP 地址。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rarp-protocol.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="代理-arp">代理 ARP</h2>
<p>通常 ARP 包会被路由器隔离，但是采用代理 ARP（Proxy
ARP）的路由器可以将 ARP
请求转发给邻近的网段。因此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p>
<p>在目前的 TCP/IP
网络中，一般情况下用路由器链接多个网络时，会在各个网段上定义各自的子网，从而进行路由控制。然而，对于那些不支持设定子网掩码的老设备，不适用代理
ARP，有时就无法更好地使用网络。</p>
<h1 id="dhcp">DHCP</h1>
<p>每一台主机在接入网络时都需要设置 IP
地址，尤其是对于移动设备，每移动到一个新的地方，都需要重新设置 IP
地址。</p>
<p>DHCP（Dynamic Host Configuration Protocol）就是一种可以实现自动设置
IP 地址、统一管理 IP 地址分配的协议。通过
DHCP，计算机只要连接到网络就可以进行 TCP/IP 通信。</p>
<h2 id="dhcp-工作原理">DHCP 工作原理</h2>
<p>使用 DHCP 之前，需要先架设一台 DHCP 服务器。然后将 DHCP 所要分配的 IP
地址、子网掩码、路由控制信息、DNS 服务器地址等设置到服务器上。</p>
<p>从 DHCP 获取 IP 地址的过程主要分为两个步骤：</p>
<ul>
<li><strong>DHCP 请求</strong>：客户端广播发送 DHCP 发现包，请求设置 IP
地址和子网掩码。DHCP 服务器收到请求后返回 DHCP
提供包，通知可以使用的网络设置。</li>
<li><strong>DHCP 确认</strong>：客户端再次广播发送 DHCP
请求包，通知想要使用前一次 DHCP 提供包中的网络设置，以确保在 DHCP
服务器上重复设置也可以正常工作。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-protocol.png?x-oss-process=image/resize,w_800" /></p>
<p>当 DHCP 服务器遇到故障时，将导致无法自动分配 IP
地址，从而导致网段内所有主机之间无法进行 TCP/IP
通信。为了提高网络的可靠性，通常会架设两台以上的 DHCP 服务器。由于每个
DHCP 服务器内部都记录着 IP 地址的分配信息，因此可能会导致不同 DHCP
服务器分配的 IP 地址产生冲突。</p>
<p>为了检查所要分配的 IP 地址以及已分配的 IP 地址是否可用，DHCP 服务器或
DHCP 客户端必须具有以下功能：</p>
<ul>
<li><strong>DHCP 服务器</strong>：在分配 IP 地址前发送 ICMP
回送请求包，确认没有返回应答。</li>
<li><strong>DHCP 客户端</strong>：针对从 DHCP 获取到的 IP 地址发送 ARP
请求包，确认没有返回应答。</li>
</ul>
<h2 id="dhcp-中继代理">DHCP 中继代理</h2>
<p>家庭网络大多只有一个以太网（无线
LAN）的网段，与其连接的主机台数也不会很多。因此，只需要一台 DHCP
服务器就能应对 IP 地址分配的需求，而大多数情况下都由
<strong>宽带路由器</strong> 充当 DHCP 的角色。</p>
<p>相比之下，一个企业或学校的网络环境中，一般会有多个以太网（无线
LAN）的网段。在这种情况下，如果针对每个网段都设置 DHCP
服务器，则将是一个浩大的工程。即使路由器可以分担 DHCP
的功能，如果网络中有 100 个路由器，就要为 100 个路由器设置它们各自可分配
IP 地址的范围，并对这些范围进行后续的更新维护，这是极其难以管理的。</p>
<p>因此，在这类网络环境中，往往需要 DHCP 统一管理，具体方法可以使用 DHCP
中继代理实现。</p>
<p>这种方法需要在每个网段设置一个 DHCP 中继代理。它可以设置 DHCP
服务器的 IP 地址，从而可以在 DHCP 服务器上为每个网段注册 IP
地址的分配范围。</p>
<p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，DHCP
中继代理收到广播的请求包后，以单播的方式发给 DHCP
服务器。服务器收到包后再向 DHCP 中继代理返回应答，并由 DHCP
中继代理将此包转发给 DHCP 客户端。由此，DHCP
服务器即使不在同一个链路上也可以实现统一分配和管理的 IP 地址。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-agent-protocol.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="nat">NAT</h1>
<p>NAT（Network Address
Translator）是用于在本地网络中使用私有地址，在连接互联网时使用全局 IP
地址的技术。NAT 主要是为了应对 IPv4 日渐枯竭而开发的技术。</p>
<h2 id="nat-工作原理">NAT 工作原理</h2>
<p>如下图所示，以 <code>10.0.0.10</code> 的主机与
<code>163.221.120.9</code>
的主机进行通信为例。局域网中的主机发起请求时，NAT 路由器会将发送源地址从
<code>10.0.0.10</code> 转换为全局的 IP 地址 <code>202.244.174.37</code>
后再发送数据。反之，当数据从地址 <code>163.221.120.9</code>
发送过来时，目标地址 <code>202.244.174.37</code> 先被转换成私有 IP 地址
<code>10.0.0.10</code> 后再被转发。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nat-protocol.png?x-oss-process=image/resize,w_800" /></p>
<p>NAT 路由器内部有一个自动生成的用来转换地址的表。当
<code>10.0.0.10</code> 向 <code>163.221.120.9</code>
发送第一个数据包时生成这张表，并按照表中的映射关系进行处理。</p>
<h2 id="napt">NAPT</h2>
<p>NAPT（Network Address Port Translator）是 NAT 的升级版，不仅可以转换
IP 地址，还可以转换 TCP、UDP 端口号，可以实现用一个全局 IP
地址与多个主机的通信。</p>
<p>如下图所示，主机 <code>163.221.120.9</code> 的端口号是
<code>80</code>，LAN 中有两个客户端 <code>10.0.0.10</code> 和
<code>10.0.0.11</code> 同时进行通信，并且两个客户端的本地端口都是
<code>1025</code>。此时，仅仅将 IP 地址为路由器的全局地址
<code>202.244.174.37</code> 将无法区分两个客户端。因此，只要将
<code>10.0.0.11</code> 的端口号转换为 <code>1026</code>
就可以进行区分。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/napt-protocol.png?x-oss-process=image/resize,w_800" /></p>
<p>类似于 NAT，NAPT 路由器也会生成自动一个转换表。如：在 TCP
的情况下，建立 TCP 连接首次握手时的 SYN 包发出后就会生成转换表。断开 TCP
连接时的 FIN 包发出后就会被删除。</p>
<h1 id="mobile-ip">Mobile IP</h1>
<p>在与移动设备进行通信时，所连接的子网一旦发生变化，则无法通过 TCP
继续通信。因为 TCP 是面向连接的协议，自始至终都需要发送端和接收端主机的
IP 地址保持不变。类似的，UDP 也无法继续通信。</p>
<p>Mobile IP
技术就是为了解决所连接的子网发生变化时继续保持通信的需求。</p>
<h2 id="mobile-ip-工作原理">Mobile IP 工作原理</h2>
<p><strong>基本概念</strong></p>
<ul>
<li><strong>移动节点</strong>（MN，Mobile
Node）：从一个网络切换到另一个网络的设备，如：手机从一个网络切换到另一个网络。</li>
<li><strong>对等节点</strong>（CN，Correspondent
Node）：与移动节点通信的设备。</li>
<li><strong>归属地址</strong>（Permanent Address）：一个固定的 IP
地址，如同一个人的户籍，即使移动了也不会改变。</li>
<li><strong>转交地址</strong>（CoA：Care-of-Address）：设备移动当前所处网络予以分配的
IP 地址。</li>
<li><strong>归属代理</strong>（HA：Home
Agent）：暂时认为是移动设备当前所处网络的路由器。</li>
<li><strong>外地代理</strong>（FA：Foreign
Agent）：暂时认为是移动设备归属网络的路由器。</li>
</ul>
<p>如下图所示，为 Mobile IP 的工作原理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/mobile-ip-protocol.png?x-oss-process=image/resize,w_800" /></p>
<p>当移动节点接入切换至另一个网络时，首先请求外地代理为它服务，并向归属代理注册转交地址。</p>
<p>当对等节点向移动节点的归属地址发送分组数据时，归属代理能够截获该分组，并将该分组转发给移动节点最新注册的转交地址。外地代理收到分组数据后，转发给转交地址对应的设备，即移动节点。移动节点可以直接响应对等节点。</p>
<p>注意，归属代理和外地代理之间的通信是通过 IP
隧道实现的。因为归属代理会将对等节点的原始分组数据进行封装，再由外地代理进行拆封。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>DHCP</tag>
        <tag>DNS</tag>
        <tag>ARP</tag>
        <tag>Mobile IP</tag>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>IT面试整理(1)——网络</title>
    <url>/2017/03/02/it-interviews001/</url>
    <content><![CDATA[<h2 id="网络体系结构">网络体系结构</h2>
<ul>
<li><strong>OSI五层模型</strong>
<ul>
<li><em>应用层</em></li>
<li><em>传输层</em></li>
<li><em>网络层</em></li>
<li><em>数据链路层</em></li>
<li><em>物理层</em></li>
</ul></li>
</ul>
<span id="more"></span>
<ul>
<li><strong>OSI七层模型</strong>
<ul>
<li><em>应用层</em>: 文件传输，电子邮件，文件服务，虚拟终端
<ul>
<li>（协议族: FTP,HTTP,SMTP,DNS,Telnet,SNMP）</li>
</ul></li>
<li><em>表示层</em>:
数据格式化，代码转换，数据加密。对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</li>
<li><em>会话层</em>:
解除或建立与别的节点的联系。管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</li>
<li><em>传输层</em>:
提供端到端的接口。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层处理端到端的差错控制和流量控制问题。
<ul>
<li>（协议族: TCP, UDP）</li>
</ul></li>
<li><em>网络层</em>:
为数据包选择路由。还可以实现拥塞控制、网际互连等功能
<ul>
<li>（协议族: IP, ICMP, RIP, OSPF, BGP, IGMP）</li>
</ul></li>
<li><em>数据链路层</em>:
传输有地址的帧以及错误检测功能。在不可靠的物理介质上提供可靠的传输，该层的作用包括：物理地址寻址、数据的成帧、流量控制、
数据的检错、重发等
<ul>
<li>（协议族: SLIP, CSLIP, PPP, ARP, RARP, MTU）</li>
</ul></li>
<li><em>物理层</em>:
以二进制数据形式在物理媒介上传输数据。激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性
<ul>
<li>（协议族: ISO2110, IEEE802, IEEE802.2）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="地址解析协议">地址解析协议</h2>
<ul>
<li><strong>原理</strong>:
适用于局域网，主机在发送帧前将目标IP地址转换成目标MAC地址的过程</li>
<li><strong>工作过程</strong>
<ul>
<li><strong>(1)</strong>
当主机A向本局域网上主机B发送IP数据报时，先在自己的ARP缓冲表中查看有无主机B的IP地址；</li>
<li><strong>(2)</strong>
如果有，查出对应的硬件地址，并将此硬件地址写入MAC帧，然后通过以太网将数据包发送到目的主机中<br />
</li>
<li><strong>(3)</strong>
如果查不到主机B的IP地址的表项，高速缓存表可能是空的。主机A就自动运行ARP协议
<ul>
<li>ARP进程在本局域网上广播一个ARP请求分组。ARP请求分组的主要内容表明：我的IP地址是192.168.0.2，我的硬件地址是00-C0-15-AD-18，我想知道IP地址为192.168.0.4的主机的硬件地址</li>
<li>本局域网上的所有主机上运行的AR进程都接收此ARP请求分组</li>
<li>主机B在ARP请求分组中见到自己的IP地址，就向主机A发送ARP响应分组，并写入自己的硬件地址</li>
<li>主机A收到主机B的ARP响应分组后，在其ARP高速缓存中写入主机B的IP地址硬件地址的映射</li>
</ul></li>
</ul></li>
</ul>
<h2 id="路由选择协议">路由选择协议</h2>
<ul>
<li><strong>RIP协议</strong>
<ul>
<li>底层是Bellmanford算法，其选择路由的度量标准是跳数，最大跳数是15跳，如果大于15跳，则丢弃数据包</li>
</ul></li>
<li><strong>OSPF协议</strong>
<ul>
<li>底层是Dijskra算法，是链状状态路由选择协议，其选择路由的度量标准是带宽、延迟</li>
</ul></li>
</ul>
<h2 id="nat协议dhcp议dns协议">NAT协议、DHCP议、DNS协议</h2>
<ul>
<li><strong>NAT协议</strong>
<ul>
<li>网络地址转换协议:
一种将私有地址转换成合法IP地址的转换技术，完美解决了IP地址不足的问题，还能有效避免来自网络外部的攻击</li>
</ul></li>
<li><strong>DHCP协议</strong>
<ul>
<li>动态主机配置协议: 一种局域网的网络协议，使用UDP协议工作，主要用途:
<ul>
<li><ol type="1">
<li>给内部网络或者网络供应商自动分配IP地址</li>
</ol></li>
<li><ol start="2" type="1">
<li>给用户或者内部网络管理员作为对所有计算机作中央管理的手段</li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>DNS协议</strong>
<ul>
<li>将域名和IP地址相互映射的一个分布式数据库</li>
</ul></li>
</ul>
<h2 id="实现可靠传输的协议">实现可靠传输的协议</h2>
<ul>
<li><strong>(1) 停止等待协议</strong>
<ul>
<li>每发完一帧就停止发送，直到收到接收确认信号再发送下一帧，如果没有收到接收确认信号，则通过设定的定时器
超时后重传上一帧，通过序号判断之前的帧是否被接收</li>
</ul></li>
<li><strong>(2) 连续ARQ协议</strong>
<ul>
<li>发送窗口大于1，接收窗口等于1。如果发送窗口已经发送到了序号为5的帧，但是接收端收到序号为3的帧出错，那么3以后的帧都需重传。为了避免后面的帧重传，可以使用缓存</li>
</ul></li>
<li><strong>(3) 选择重传协议</strong></li>
</ul>
<h2 id="tcp拥塞控制">TCP拥塞控制</h2>
<p><a
href="http://blog.csdn.net/sicofield/article/details/9708383">【参考】</a>
- <strong>定义</strong>:
防止过多的数据注入网络中，可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是指点对点通信量的控制
- <strong>方法</strong>: - <strong>(1) 慢开始与拥塞避免</strong> -
慢开始： 先探测网络的拥塞程度，从小到大逐渐增加拥塞窗口的大小 -
拥塞避免:
让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1 -
<strong>(2) 快重传与快恢复</strong> - <strong>(3)
随机早起检测RED</strong></p>
<h2 id="网络设备及其相关层">网络设备及其相关层</h2>
<ul>
<li><strong>网关</strong>: 网络层以上的设备</li>
<li><strong>网络层</strong>: 路由器</li>
<li><strong>数据链路层</strong>: 网桥、交换机</li>
<li><strong>物理层</strong>: 中继器、集线器</li>
</ul>
<h2 id="https">HTTPS</h2>
<p><a href="https://segmentfault.com/a/1190000004467714">【参考】</a> -
在HTTP和TCP协议之间建立一层TLS/SSL协议</p>
<h2 id="http头">HTTP头</h2>
<p><a href="https://segmentfault.com/a/1190000004093321">【参考】</a> -
报文格式 - 报文首部 - 空行 - 报文主体 - 请求报文首部 - 请求行（GET
/index.html/ HTTP/1.1） - 请求首部字段 - 请求信息性首部字段 - From:
请求来自何方，格式是客户端用户的有效电子邮件地址 - Host:
服务器的主机名和端口号 - Referer: 这次请求的URL是从哪里获得的 -
User-Agent: 客户端的浏览器或代理信息 - Accept首部字段 - Accept:
客户端通过该首部字段告诉服务器自己可以接收哪些媒体类型，如text/html。此外，还有可以权重系数（q值）来表示媒体类型的优先级。
- Accept-Charset: 客户端可以接收哪些字符集，也可以有q值 -
Accept-Encoding: 客户端支持的内容编码及内容编码的优先级顺序。 -
Accept-Language: 客户端能够处理的自然语言集（中文、英文等） - TE:
客户端能够处理的传输编码，还可以指定伴随trailer字段的分块传输编码方式 -
条件请求首部字段 - Expect:
客户端通过该首部字段告知服务器它们需求某种行为，现在该首部与响应码100
Continue紧密相关。如果服务器无法理解该首部的值，就应该返回417
Expectation Failed - If-Match:
服务器会比对该字段的值和资源的ETag值，仅当两者一致时，才会执行请求，否则，返回412
Precondition Failed。该字段值为*时，会忽略ETag值 - If-Modified-Since:
该字段值应该是一个日期，如果服务器上资源的更新时间较该字段值新则处理该请求，否则，返回304
Not Modified - If-None-Match:
与If-Match相反，该字段的值与请求资源的ETag不一致时，处理该请求 -
If-Range:
该字段的值（ETag或时间）与资源的ETag或时间一致时，作为范围请求处理（参加首部字段Range）。否则，返回全体资源
- If-Unmodified-Since:
与If-Modified-Since相反，服务器上资源的更新时间早于该字段值时处理请求，否则，返回412
Precondition Failed - Range: 范围请求，只获取部分资源。如Range:
bytes=5001-10000，表示获取从第5001字节至10000字节的资源。成功处理范围请求时返回206
Partial Content响应，无法处理范围请求时返回200 OK响应及全部资源 -
安全请求首部字段 - Authorization:
向服务器回应自己的身份验证信息。客户端收到来自服务器的401 Authentication
Required响应后，要在其请求中包含这个首部 - Cookie:
HTTP/1.1中没有定义，用于客户端识别和跟踪的扩展首部<br />
- 代理请求首部字段 - Max-Forwards:
只能和TRACE方法一起使用，指定经过代理或其他中间节点的最大数目。每个收到带此首部的TRACE请求的应用程序，在请求转发之前都要将这个值减1；如果应用程序收到请求时，该首部值为0，则立即回应一条200
OK响应 - Proxy-Authorization:
与Authorization类似，用于客户端与代理服务器之间的身份验证 - 通用首部字段
- 实体首部字段 - 其他</p>
<ul>
<li>响应报文首部
<ul>
<li>状态行（HTTP/1.1 200 OK）</li>
<li>响应首部字段
<ul>
<li>响应信息性首部字段
<ul>
<li>Age:
响应已经产生了多长时间。HTTP/1.1规定缓存服务器在创建响应时必须包含Age首</li>
<li>Location: 客户端应重定向到指定URI，基本配合响应出现</li>
<li>Retry-After: 告诉客户端多久之后再次发送请求。主要配合503 Service
Unavailable使用，或与3**响应一起使用</li>
<li>Server: HTTP服务器的应用程序信息</li>
<li>Warning:</li>
</ul></li>
<li>协商首部字段
<ul>
<li>Accept-Ranges:
服务器是否能处理范围请求，bytes表示能，none表示不能</li>
<li>Vary:</li>
</ul></li>
<li>安全响应首部字段
<ul>
<li>Proxy-Authorizate:
与WWW-Authenticate类似，用于代理与客户端之间的认证，407 Proxy
Authentication Required响应必须包含该首部</li>
<li>Set-Cookie: 非HTTP/1.1标准首部</li>
<li>WWW-Authenticate: 告诉客户端访问所请求资源的认证方案，401
Unauthorized响应中肯定有该首</li>
</ul></li>
</ul></li>
<li>通用首部字段
<ul>
<li>通用信息性首部字段
<ul>
<li>Connection: 两个作用
<ol type="1">
<li>控制不再转发给代理的首部字段</li>
<li>管理持久连接</li>
</ol></li>
<li>Date: 创建HTTP报文的时间和日期</li>
<li>Trailer: 说明在报文主体后记录了哪些首部字段</li>
<li>Transfer-Encoding: 传输报文主体时采用的编码方式</li>
<li>Upgrade: 用于检测HTTP协议及其他协议是否可使用更高的版本进行通信</li>
<li>Via: 追踪客户端与服务器之前的请求和响应报文的传输路径</li>
</ul></li>
<li>通用缓存首部字段
<ul>
<li>Cache-Control: 管理缓存信息，是HTTP/1.1引入的一个复杂首部</li>
<li>Pragma: HTTP/1.1以前的遗留字段Pargma: no-cache与Cache-Control:
no-cache功能一致，只用在客户端发送请求时</li>
</ul></li>
</ul></li>
<li>实体首部字段
<ul>
<li>实体信息性首部字段
<ul>
<li>Allow: 通知客户端可以对特定资源使用那些HTTP方法。405 Method Not
Allowed响应中必须包含该首部</li>
</ul></li>
<li>内容首部字段
<ul>
<li>Content-Encoding:
告诉客户端实体的主体部分选用的内容编码方式。具体方式参见Accept-Encoding</li>
<li>Content-Language:
告诉客户端实体主体使用的自然语言（中文、英文等）</li>
<li>Content-Length:
表明实体主体部分的大小（单位：字节）。对实体主体进行内容编码传输时，不能再使用该首部字段</li>
<li>Content-Location: 报文主体部分相对应的URI</li>
<li>Content-MD5:
一串由MD5算法生成的值。对于检查在传输过程中数据是否被无意的修改非常有用，但不能用于安全目的，因为报文如果被有意的修改，该字段的值也可以计算后作相应修改</li>
<li>Content-Range:
针对范围请求，提供了请求实体在原始实体内的位置（范围），还给出了整个实体的长度</li>
<li>Content-Type: 响应报文中对象的媒体类型</li>
</ul></li>
<li>实体缓存首部字段
<ul>
<li>ETag: 实体标记，就是一种标识资源的方式</li>
<li>Expires:
资源失效日期，当Cache-Control有指定max-age指令时，会优先处理max-age</li>
<li>Last-Modified: 资源最终修改时间</li>
</ul></li>
</ul></li>
<li>其他</li>
</ul></li>
</ul>
<h2 id="http请求方法">HTTP请求方法</h2>
<ul>
<li><strong>GET</strong>: 最常见，向服务器请求某个资源<br />
</li>
<li><strong>POST</strong>:
起初用于向服务器输入数据。实际上，通常用于HTML表单数据的提交<br />
</li>
<li><strong>HEAD</strong>:
与GET的行为类似，但服务器返回的响应中只包含首部，不会返回主体部分<br />
</li>
<li><strong>PUT</strong>: 向服务器写入文档<br />
</li>
<li><strong>DELETE</strong>: 删除指定资源<br />
</li>
<li><strong>TRACE</strong>:
服务器回送收到的请求信息给客户端，主要用于诊断<br />
</li>
<li><strong>ONNECT</strong><br />
</li>
<li><strong>OPTIONS</strong>:
查询服务器支持的方法（通用或针对指定资源）</li>
</ul>
<h2 id="http状态码">HTTP状态码</h2>
<ul>
<li><strong>100 Continue</strong>:
继续，一般在发送post请求时，已发送了http
header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
<li><strong>200 OK</strong>: 正常返回信息</li>
<li><strong>201 Created</strong>: 请求成功并且服务器创建了新的资源</li>
<li><strong>202 Accepted</strong>: 服务器已接受请求，但尚未处理</li>
<li><strong>301 Moved Permanently</strong>:
请求的网页已永久移动到新位置。</li>
<li><strong>302 Found</strong>: 临时性重定向。</li>
<li><strong>303 See Other</strong>: 临时性重定向，且总是使用 GET
请求新的 URI。</li>
<li><strong>304 Not Modified</strong>:
自从上次请求后，请求的网页未修改过。</li>
<li><strong>400 Bad Request</strong>:
服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li><strong>401 Unauthorized</strong>: 请求未授权。</li>
<li><strong>403 Forbidden</strong>: 禁止访问。</li>
<li><strong>404 Not Found</strong>: 找不到如何与 URI 相匹配的资源。</li>
<li><strong>500 Internal Server Error</strong>:
最常见的服务器端错误。</li>
<li><strong>503 Service Unavailable</strong>:
服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
<h2 id="域名劫持">域名劫持</h2>
<ul>
<li><strong>原理</strong>:
通过攻击域名解析服务器或者伪造域名解析服务器的方法，把目标网站域名解析到错误的地址。</li>
</ul>
<h2 id="content-type">Content-Type</h2>
<ul>
<li><strong>含义</strong>:
用于指定请求和响应的HTTP内容类型。如果未指定，默认为text/html</li>
<li><strong>格式</strong>: [type]/[subtype];parameter
<ul>
<li>type
<ul>
<li>text:
用于标准化地表示文本信息，文本消息可以是多种字符集或多种格式的</li>
<li>multipart:
用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据</li>
<li>application: 用于传输应用程序数据或二进制数据</li>
<li>message: 用于包装一个email消息</li>
<li>image: 用于传输静态图片数据</li>
<li>audio: 用于传输音频数据</li>
<li>video: 用于传输动态影像数据，可以是与音频编辑在一起的视频格式的数据
q</li>
<li>subtype</li>
<li>patameter</li>
</ul></li>
</ul></li>
<li><strong>常见值</strong>
<ul>
<li>text/html</li>
<li>text/plain</li>
<li>text/css</li>
<li>text/javascript</li>
<li>application/x-www-form-urlencoded:
常用的表单发包方式，POST发包方式</li>
<li>multipart/form-data: 发送文件的POST包</li>
<li>application/json</li>
<li>application/xml</li>
</ul></li>
</ul>
<h2 id="etag">Etag</h2>
<h2 id="cache-control">cache-control</h2>
<ul>
<li><strong>private</strong>:
默认值。内容只缓存到私有缓存中（仅客户端可以换成，代理服务器不可缓存）</li>
<li><strong>public</strong>:
所用内容都可以被缓存（客户端和代理服务器都可缓存）
cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载</li>
<li><strong>no-store</strong>:
所有内容都不会被缓存到缓存或Internet临时文件中</li>
<li><strong>max-age</strong>: 缓存的内容将在xxx秒后失效</li>
<li><strong>must-revalidate/proxy-revalidation</strong>:
如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证</li>
</ul>
<h2 id="三次握手四次挥手">三次握手、四次挥手</h2>
<p><img
src="https://segmentfault.com//image?src=http://7xj8xg.com1.z0.glb.clouddn.com/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif&amp;objectId=1190000004138638&amp;token=d1b8c871d955e926a423b86be60a384b" /></p>
<ul>
<li><strong>三次握手</strong>
<ol type="1">
<li>Client端发送连接请求报文<br />
</li>
<li>Server端接收连接请求，并回复ACK报文，并为此次连接分配资源<br />
</li>
<li>Client端接收ACK报文，向Server端发送ACK报文，并分配资源</li>
</ol></li>
</ul>
<div data-align="center">
<img
src="http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif" />
</div>
<ul>
<li><strong>四次挥手</strong>
<ol type="1">
<li>Client端发送中断请求，即FIN报文<br />
</li>
<li>Server端收到FIN报文，发送ACK报文，并继续发送数据<br />
</li>
<li>Client端收到ACK报文，进入FIN_WAIT状态<br />
</li>
<li>Server端数据发送完毕，发送FIN报文<br />
</li>
<li>Client端收到FIN报文，发送ACK报文，等待2MSL</li>
</ol></li>
</ul>
<h2 id="ip地址">IP地址</h2>
<ul>
<li><strong>特殊的IP地址</strong>
<ul>
<li><em>网络地址</em>
<ul>
<li>IP地址由网络号和主机号组成，网络地址的主机号为全0，网络地址代表整个网络</li>
</ul></li>
<li><em>广播地址（直接广播地址）</em>
<ul>
<li>IP地址主机号全为1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息</li>
<li>既可本地广播，也可跨网段广播</li>
</ul></li>
<li><em>组播地址</em>
<ul>
<li>D类即主播地址</li>
</ul></li>
<li><em>255.255.255.255（受限广播地址）</em>
<ul>
<li>受限广播地址，只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组</li>
</ul></li>
<li><em>0.0.0.0</em>
<ul>
<li>表示整个网络。它的作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去。</li>
</ul></li>
<li><em>回环地址</em>
<ul>
<li>表示本机地址</li>
</ul></li>
<li><em>A、B、C类私有地址</em>
<ul>
<li>A类私有地址: 10.0.0.0/8, 范围: 10.0.0.0~10.255.255.255</li>
<li>B类私有地址: 172.16.0.0/12, 范围: 172.16.0.0~172.31.255.255</li>
<li>C类私有地址: 182.168.0.0/16, 范围: 192.168.0.0~192.168.255.255</li>
</ul></li>
</ul></li>
<li><strong>IP地址分类</strong>
<ul>
<li><em>A类地址</em>: 0开头，8位网络号</li>
<li><em>B类地址</em>: 10开头，16位网络号</li>
<li><em>C类地址</em>: 110开头，24位网络号</li>
<li><em>D类地址</em>: 1110开头，用于多播</li>
<li><em>E类地址</em>: 1111开头</li>
</ul></li>
</ul>
<h2 id="子网">子网</h2>
<ul>
<li><strong>原理</strong>: 从二级IP地址到三级IP地址
<ul>
<li>二级IP地址: <网络号><主机号>，默认子网掩码为网络号的长度</li>
<li>三级IP地址:
<网络号><子网号><主机号>，默认子网掩码为网络号+子网号的长度</li>
</ul></li>
</ul>
<h2 id="超网">超网</h2>
<ul>
<li><strong>原理</strong>: 变长子网掩码，无分类编址CIDR</li>
<li><strong>IP地址</strong>: <网络前缀><主机号></li>
<li><strong>特点</strong>:</li>
</ul>
<h2 id="tcpudp">TCP、UDP</h2>
<a href="https://segmentfault.com/a/1190000004138638">【参考】</a><br />

</div align=center>
<img
src="https://segmentfault.com/image?src=http://7xj8xg.com1.z0.glb.clouddn.com/TCP%EF%BC%8CUDP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.gif&amp;objectId=1190000004138638&amp;token=90d2ba2f129588bcae0a08299e765232" />
</div>
<ul>
<li><strong>报文格式</strong>
<ul>
<li>共有字段:
<ul>
<li>源端口和目的端口号</li>
<li>数据长度</li>
<li>校验和</li>
<li>数据域</li>
</ul></li>
<li>TCP特有字段
<ul>
<li>序列号和确认号</li>
<li>接收窗口</li>
<li>TCP首部</li>
<li>标识字段</li>
</ul></li>
</ul></li>
<li><strong>区别</strong>
<ul>
<li><em>TCP</em>
<ul>
<li>面向连接的协议，提供可靠的数据传输</li>
<li>当数据接收方收到数据发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在收到确认消息之后才会继续发送其他信息；</li>
<li>报文最大长度允许超过512字节</li>
</ul></li>
<li><em>UDP</em>
<ul>
<li>用户数据报协议，一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</li>
<li>报文最大长度为512字节</li>
</ul></li>
</ul></li>
</ul>
<h2 id="tcp对应的协议和udp对应的协议">TCP对应的协议和UDP对应的协议</h2>
<ul>
<li><strong>TCP</strong>
<ul>
<li>FTP: 定义了文件传输协议，使用21端口</li>
<li>Telnet:
一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DO
S模式下的通信服务，使用23端口</li>
<li>SMTP: 定义了简单邮件传送协议，使用25端口</li>
<li>POP3: 和SMTP对应，POP3用于接收邮件，使用110端口</li>
<li>HTTP: 从web服务器传输超文本到本地浏览器的传送协议</li>
</ul></li>
<li><strong>UDP</strong>
<ul>
<li>DNS: 用于域名解析服务，将域名地址转换为IP地址，使用53端口</li>
<li>SNMP: 简单网络管理协议，用来管理网络设备，使用161端口</li>
<li>TFTP: 简单文件传输协议，使用69端口</li>
</ul></li>
</ul>
<h2 id="socket">Socket</h2>
<ul>
<li><strong>套接字</strong>
<ul>
<li>是支持TCP/IP协议的网络通信的基本操作单元，是网络通信过程中端点的抽象表示，包含进行</li>
<li>套接字 =
连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口</li>
</ul></li>
</ul>
<h2 id="http2.0">HTTP2.0</h2>
<ul>
<li><strong>特性</strong>
<ul>
<li>入服务器端推:
允许服务器端在客户端需要数据之前就主动地将数据发送到客户端缓存<br />
</li>
<li>提供更多加密技术<br />
</li>
<li>使用多路技术，允许多个消息在一个连接上同时交叉</li>
<li>增加了头压缩，即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IT面试整理(2)——HTML</title>
    <url>/2017/03/07/it-interviews002/</url>
    <content><![CDATA[<h2 id="doctype"><strong>Doctype</strong></h2>
<ul>
<li><strong>作用</strong>
<ol type="1">
<li>对文档进行有效性验证： 告诉用户代理和校验器该文档的DTD<br />
</li>
<li>决定浏览器的呈现模式：通知浏览器读取文档时采用何种解析算法。浏览器有三种方式解析HTML文档(标准模式、怪异模式、部分怪异模式)<br />
</li>
</ol></li>
<li><strong>种类</strong>
<ol type="1">
<li>HTML 4.01: Strict, Transitional, Framset</li>
<li>XHTML 1.0: Strict, Transitional, Framset</li>
</ol></li>
</ul>
<span id="more"></span>
<h2 id="标准模式怪异模式"><strong>标准模式、怪异模式</strong></h2>
<ul>
<li><strong>标准模式</strong>：页面按照HTML与CSS的定义渲染</li>
<li><strong>怪异模式</strong>：浏览器为了了兼容很早之前针对旧版本浏览器设计、并未严格遵循W3C标准的网页而产生的一种页面渲染模式</li>
</ul>
<h2 id="语义化"><strong>语义化</strong></h2>
<ol type="1">
<li>去掉或丢失样式时能够让页面呈现出清晰的结构<br />
</li>
<li>有利于SEO：爬虫依赖于标签来确定上下文和各个关键字的权重<br />
</li>
<li>方便其他设备解析以意义的方式来渲染网页<br />
</li>
<li>可读性更好，方便团队开发</li>
</ol>
<h2 id="xhtml"><strong>XHTML</strong></h2>
<ol type="1">
<li>所有的标记都必须要有一个相应的结束标记<br />
</li>
<li>所有标签的元素和属性的名字都必须使用小写<br />
</li>
<li>所有的XML标记都必须合理嵌套<br />
</li>
<li>所有的属性必须用引号""括起来<br />
</li>
<li>把所有&lt;和&amp;特殊符号用编码表示<br />
</li>
<li>给所有属性赋一个值<br />
</li>
<li>不要在注释内容中使“--”<br />
</li>
<li>图片必须有说明文字</li>
</ol>
<h2 id="data-属性"><strong>data-属性</strong></h2>
<p>自定义属性，可通过对象的dataset属性获取，或通过getAttribute方法获取：<br />
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-author</span>=<span class="string">&quot;baochuquan&quot;</span> <span class="attr">data-time</span>=<span class="string">&quot;2016-06-20&quot;</span> <span class="attr">data-comment</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">dataset</span>.<span class="property">commentNum</span>;<span class="comment">//10</span></span><br></pre></td></tr></table></figure></p>
<h2 id="input的type属性参考"><strong>input的type属性</strong><a
href="http://www.w3school.com.cn/html5/att_input_type.asp">【参考】</a></h2>
<ul>
<li>button</li>
<li>checkbox</li>
<li>color</li>
<li>date</li>
<li>datetime</li>
<li>datetime-local</li>
<li>month</li>
<li>week</li>
<li>time</li>
<li>email</li>
<li>file</li>
<li>hidden</li>
<li>image</li>
<li>number</li>
<li>password</li>
<li>radio</li>
<li>range</li>
<li>reset</li>
<li>search</li>
<li>submit</li>
<li>tel</li>
<li>text</li>
<li>url</li>
</ul>
<h2 id="iframe的优缺点"><strong>iframe的优缺点</strong></h2>
<ul>
<li><strong>优点</strong><br />
</li>
</ul>
<ol type="1">
<li>解决加载缓慢的第三方内容(如图标和广告等)的加载问题<br />
</li>
<li>Security sandbox<br />
</li>
<li>并行加载脚本<br />
</li>
</ol>
<ul>
<li><strong>缺点</strong><br />
</li>
</ul>
<ol type="1">
<li>iframe会阻塞主页面的onload事件<br />
</li>
<li>即使内容为空，加载也需要时间<br />
</li>
<li>没有语义</li>
</ol>
<h2 id="html表单元素参考"><strong>HTML表单元素</strong><a
href="http://www.w3school.com.cn/html/html_form_elements.asp">【参考】</a></h2>
<ul>
<li>input</li>
<li>select</li>
<li>option</li>
<li>textarea</li>
<li>button</li>
</ul>
<h2 id="html5表单元素参考"><strong>HTMl5表单元素</strong><a
href="http://www.w3school.com.cn/html5/html_5_form_elements.asp">【参考】</a></h2>
<ul>
<li><code>datalist</code>:
datalist元素规定输入域的选项列表，列表是通过datalist内的option元素创建的</li>
<li><code>keygen</code>:
keygen元素的作用是提供一种验证用户的可靠方法</li>
<li><code>output</code>:
output元素用于不同类型的输出，如计算或脚本输出</li>
</ul>
<h2 id="head标签及其内容参考"><strong>head标签及其内容</strong><a
href="http://blog.csdn.net/puppylpg/article/details/47953181">【参考】</a></h2>
<ul>
<li><strong>作用</strong>:
描述了文档的各种属性和信息，包括文档的标题、在web中的位置以及和其它文档的关系等</li>
<li><strong>内容</strong>
<ul>
<li>title: 定义文档的标题，是head部分中唯一必需的元素</li>
<li>base: 为页面上的所有链接规定默认地址或默认目标
<ul>
<li>必选: href</li>
<li>可选: target</li>
</ul></li>
<li>meta:
可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词
<ul>
<li>必选: content</li>
<li>可选
<ul>
<li>http-equiv(Content-Type, expires, Refresh, set-cookie)</li>
<li>name: author, description, keywords, generator, revised, others</li>
</ul></li>
</ul></li>
<li>link: 链接一个外部样式表
<ul>
<li>rel, href, type, charset</li>
</ul></li>
<li>script: 直接包含脚本，或者通过src属性指向外部脚本文件</li>
<li>style: 为HTML文档定义样式信息</li>
</ul></li>
</ul>
<h2
id="块级元素行内元素空元素"><strong>块级元素、行内元素、空元素</strong></h2>
<ul>
<li>块级元素
<ul>
<li>div、dl、dt、dd、ul、li、ol、p、h1-6、table、fieldset、form</li>
</ul></li>
<li>行内元素
<ul>
<li>a、em、strong、i、img、b、label、select、textarea、sub、sup、q</li>
</ul></li>
<li>空元素
<ul>
<li>br、hr</li>
</ul></li>
</ul>
<h2 id="自闭合元素"><strong>自闭合元素</strong></h2>
<ul>
<li>自闭合标签不加斜杠，如: br, link</li>
</ul>
<h2 id="html5新特性"><strong>HTML5新特性</strong></h2>
<ul>
<li>新的文档类型：&lt;!DOCTYPR html&gt;</li>
<li>脚本和链接不需要type：</li>
<li>语义标签：header、footer</li>
<li>hgroup</li>
<li>标记元素：mark</li>
<li>图形元素：figure</li>
<li>必要属性：require</li>
<li>音频视频：video, audio</li>
<li>正则表达式：pattern属性</li>
<li>canvas API：栅格图形API</li>
<li>SVG：矢量图形API</li>
<li>Geolocation API</li>
<li>Communication API</li>
<li>WebSockets API</li>
<li>Form API</li>
<li>Web Works API</li>
<li>Web Storage API</li>
</ul>
<h2
id="置换元素不可置换元素"><strong>置换元素、不可置换元素</strong></h2>
<ul>
<li>置换元素
<ul>
<li>定义：浏览器根据元素的标签和属性，来决定元素的具体显示内容</li>
<li>如：imt, input, textarea, select, object</li>
</ul></li>
<li>不可替换元素
<ul>
<li>定义：其内容直接呈现给用户</li>
</ul></li>
</ul>
<h2 id="meta标签参考"><strong>meta标签</strong><a
href="http://www.jb51.net/web/158860.html">【参考】</a></h2>
<ul>
<li><strong>作用</strong>
<ul>
<li>通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie；</li>
<li>可以用于鉴别作者，设定页面格式，标注内容提要和关键字；</li>
<li>可以设置页面使其可以根据自己定义的时间间隔刷新自己</li>
<li>设置RASC内容等级</li>
</ul></li>
<li><strong>分类</strong>
<ol type="1">
<li>http-equiv: HTTP标题信息
<ul>
<li>Content-Type、Content-Language
<ul>
<li>说明: 设定页面使用的字符集，用以说明主页只做所使用的文字及语言</li>
<li>用法
<ul>
<li><meta http-equiv="Content-Type" Content="text/html; Charset=gb2312"></li>
<li><meta http-equiv="Content-Language" Content="zh-CN"></li>
</ul></li>
</ul></li>
<li>Refresh
<ul>
<li>说明:
让网页多长时间刷新自己，或在多长时间后让网页自动链接到其他网页</li>
<li>用法
<ul>
<li><meta http-equiv="Refresh" Content="30"></li>
<li>&lt;meta http-equiv="Refresh"
Content="5;Url="http://www.baidu.com"&gt;</li>
</ul></li>
</ul></li>
<li>Expires
<ul>
<li>说明:
指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调整
<ul>
<li><meta http-equiv="Expires" Content="0"></li>
<li><meta http-equiv="Expires" Content="Wed, 26 Feb 1997 08:21:57 GMT"></li>
</ul></li>
</ul></li>
<li>Pragma(cache模式)
<ul>
<li>说明: 禁止浏览器从本地机的缓存中调阅页面内容</li>
</ul></li>
<li>Set-Cookie(cookie设定)</li>
</ul></li>
<li>name: 页面描述信息</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>IT面试整理(3)——CSS</title>
    <url>/2017/03/17/it-interviews003/</url>
    <content><![CDATA[<h2 id="盒子模型参考"><strong>盒子模型</strong><a
href="http://www.cnblogs.com/cchyao/archive/2010/07/12/1775846.html">【参考】</a></h2>
<ul>
<li>组成: content、padding、border、margin</li>
<li>标准盒模型
<ul>
<li>width/height = content</li>
</ul></li>
<li>IE盒模型
<ul>
<li>width/height = content + padding + border</li>
</ul></li>
</ul>
<span id="more"></span>
<h2
id="行级元素块级元素的区别"><strong>行级元素、块级元素的区别</strong></h2>
<ul>
<li>块级元素: margin、padding可设置</li>
<li>行级元素: margin、padding水平方向可设置；竖直方向不可设置</li>
</ul>
<h2 id="浮动及其原理"><strong>浮动及其原理</strong></h2>
<ul>
<li>脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留</li>
<li>缺点
<ol type="1">
<li>父元素的高度无法被撑开，影响与父元素同级的元素<br />
</li>
<li>与浮动元素同级的非浮动元素（内联元素）会跟随其后<br />
</li>
<li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>
</ol></li>
<li>清除方法
<ol type="1">
<li>clear:both清除浮动</li>
<li>父级div定义overflow:auto overflow有三个值: hidden, auto, visible;
hidden, auto可用来清除浮动, auto对SEO更友好</li>
<li>:after方法</li>
</ol></li>
</ul>
<h2 id="css-hack"><strong>CSS hack</strong></h2>
<ul>
<li>定义: 针对不同浏览器/版本而写CSS的过程叫做CSS hack</li>
<li>三种方法
<ol type="1">
<li>IE条件注释法:
即在正常代码之外添加判断IE浏览器或对应版本的条件注释，符合条件的浏览器或版本号才会执行里面的代码。
<ul>
<li><!-- [if IE]>要执行的代码<![endif]--></li>
<li><!-- [if lt LE 8]>要执行的代码<![endif]--></li>
<li><!-- [if ! IE 8]>要执行的代码<![endif]--></li>
</ul></li>
<li>CSS属性前缀法: 即给CSS的属性添加前缀。比如:
*可以被IE6/IE7识别，_只能被IE6识别，"\9"可以被IE6-IE10识别，IE6不能识别!important，Firefox不能识别*,_,\9
<ul>
<li>#example{ color: #111; color: #222\9; *color: #333; _color: #444;
}</li>
</ul></li>
<li>选择器前缀法: 即给选择器加上前缀
<ul>
<li>*div{ color: red; }</li>
<li>*+div{ color: red; }</li>
</ul></li>
</ol></li>
</ul>
<h2 id="background-属性"><strong>background-属性</strong></h2>
<ul>
<li>background-color: 规定要使用的背景颜色
<ul>
<li>color-name</li>
<li>hex-number</li>
<li>rgb-number</li>
<li>transparent</li>
<li>inherit</li>
</ul></li>
<li>background-position: 规定背景图像的位置
<ul>
<li>top/left/bottom/right/center</li>
<li>x% y%</li>
<li>xpos ypos</li>
</ul></li>
<li>background-size: 规定背景图片尺寸
<ul>
<li>length</li>
<li>percentage</li>
<li>cover</li>
<li>contain</li>
</ul></li>
<li>background-repeat: 规定如何重复背景图像
<ul>
<li>repeat</li>
<li>repeat-x</li>
<li>repeat-y</li>
<li>no-repeat</li>
<li>inherit</li>
</ul></li>
<li>background-origin: 规定背景的定位区域
<ul>
<li>padding-box</li>
<li>border-box</li>
<li>content-box</li>
</ul></li>
<li>background-clip: 规定背景的绘制区域
<ul>
<li>border-box</li>
<li>padding-box</li>
<li>content-box</li>
</ul></li>
<li>background-attachment:
规定背景图像是否固定或者随着页面的其余部分滚动
<ul>
<li>scroll</li>
<li>fixed</li>
<li>inherit</li>
</ul></li>
<li>background-image: 规定要使用的背景图像
<ul>
<li>url('URL')</li>
<li>none</li>
<li>inherit</li>
</ul></li>
</ul>
<h2
id="displaynone和visibility-hidden的区别"><strong>display:none和visibility:
hidden的区别</strong></h2>
<ul>
<li>display: none 隐藏对应的元素，在文档布局中不分配空间；<br />
</li>
<li>visibility: hidden
隐藏对应的元素，但是在文档布局中仍然保留员阿里的空间</li>
</ul>
<h2 id="linkimport"><strong>link、<span class="citation"
data-cites="import">@import</span></strong></h2>
<ul>
<li>link属于HTML标签；而@import是CSS提供的</li>
<li>页面被加载时，link会被同时加载，而@import引用的CSS会等到页面被加载完再加载</li>
<li>link方式的样式的权重高于@import的权重</li>
</ul>
<h2 id="position-absolute和float的区别"><strong>position:
absolute和float的区别</strong></h2>
<ul>
<li>共同点:
对内联元素<code>float</code>和<code>absolute</code>属性，可以让元素脱离文档流，并且可以设置其宽高<br />
</li>
<li>不同点:
<code>float</code>仍会占据位置，<code>position</code>会覆盖文档流中的其他元素</li>
</ul>
<h2
id="relativeabsolutefixedstatic"><strong>relative、absolute、fixed、static</strong></h2>
<p>absolute:
生成绝对定位的元素，相对于最近一级的定位不是<code>static</code>的父元素来进行定位<br />
fixed: 生成绝对定位的元素，相对于浏览器窗口进行定位 relative:
生成相对定位的元素，相对于其在普通流中的位置进行定位 static:
默认值。没有定位，元素出现在正常的流中</p>
<h2 id="box-sizing"><strong>box-sizing</strong></h2>
<p>content-box: 让元素维持W3C的标准盒模型 border-box:
让元素位置IE传统盒模型</p>
<h2 id="css选择器"><strong>CSS选择器</strong></h2>
<ol type="1">
<li>id选择器(#myId)<br />
</li>
<li>类选择器(.myclassname)<br />
</li>
<li>标签选择器(div, h1, p)<br />
</li>
<li>相邻选择器(h1 + p)<br />
</li>
<li>子选择器(ul &gt; li)<br />
</li>
<li>后代选择器(li a)<br />
</li>
<li>通配符选择器(*)<br />
</li>
<li>属性选择器(a[rel="external"])<br />
</li>
<li>伪类选择器(a: hover, li:nth-child)</li>
</ol>
<h2 id="css选择器参考"><strong>CSS选择器</strong><a
href="http://www.w3school.com.cn/cssref/css_selectors.asp">【参考】</a></h2>
<h2 id="css伪类伪元素"><strong>CSS伪类、伪元素</strong></h2>
<ul>
<li><strong>伪类</strong>
<ul>
<li>定义:
基于当前元素所处的状态，或者说元素所具有的特性，而不是元素的id、class、属性等静态的标志。</li>
<li>:link</li>
<li>:visited</li>
<li>:hover</li>
<li>:active</li>
<li>:focus</li>
<li>:first-child</li>
<li>:lang</li>
</ul></li>
<li><strong>伪元素</strong>
<ul>
<li>定义:
目的是获取诸如元素内容第一个字、第一行，获取某些内容前面或后面这种普通的选择器无法完成的工作。<br />
</li>
<li>:first-letter</li>
<li>:first-line</li>
<li>:before</li>
<li>:after</li>
</ul></li>
</ul>
<h2
id="css可被继承不可被继承的样式"><strong>CSS可被继承、不可被继承的样式</strong></h2>
<p><strong>可继承</strong>: font-size, font-family, color,
text-indent<br />
<strong>不可继承</strong>: border, padding, margin, width, height</p>
<h2 id="css优先级"><strong>CSS优先级</strong></h2>
<p>!important &gt; 内联 &gt; id &gt; class &gt; tag &gt; 默认样式</p>
<h2 id="class属性覆盖"><strong>class属性覆盖</strong></h2>
<p>当存在多个类名时，类名的位置不会对属性的渲染产生影响。只有在style中定义的位置才会有影响，同一条属性，后面的定义会覆盖前面的定义</p>
<h2 id="css选择器权重"><strong>CSS选择器权重</strong></h2>
<ul>
<li>通用选择器: 0-0-0</li>
<li>标签选择器，伪元素: 0-0-1</li>
<li>类选择器，属性选择器，伪类: 0-1-0</li>
<li>ID选择器: 1-0-0</li>
</ul>
<h2 id="em-rem-px参考"><strong>em, rem, px</strong><a
href="http://www.cnblogs.com/leejersey/p/3662612.html">【参考】</a></h2>
<ul>
<li>px: 像素。相对长度单位。像素px是相对显示器屏幕分辨率而言的</li>
<li>em:
相对长度单位。相对于当前对象内文本的字体尺寸。如果当前对内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</li>
<li>rem:
相对长度单位。相对于HTML根元素。既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应</li>
</ul>
<h2 id="css3新特性"><strong>CSS3新特性</strong></h2>
<ul>
<li>边框：border-radius、box-shadow、border-image</li>
<li>背景：background-size、background-origin</li>
<li>文本：text-shadow、word-wrap</li>
<li>字体：<span class="citation"
data-cites="font-face">@font-face</span></li>
<li>2D转换：transform、translate()、rotate()、scale()、skew()、matrix()</li>
<li>3D转换：rotateX()、rotateY()</li>
<li>过度：transition</li>
<li>动画：<span class="citation"
data-cites="keyframes">@keyframes</span>、animation ##
<strong>水平垂直居中</strong><a
href="https://segmentfault.com/a/1190000006245264">【参考】</a></li>
</ul>
<ol type="1">
<li>绝对定位 + 负margin
<ul>
<li>优点: 兼容性好</li>
<li>缺点: 需要知道宽高，不够灵活</li>
</ul></li>
<li>绝对定位 + Transform
<ul>
<li>优点: 不需要知道宽高，灵活</li>
<li>缺点: 兼容性不好，在移动设备上建议使用</li>
</ul></li>
<li>绝对定位 + 自动margin
<ul>
<li>优点: 灵活性兼容性好</li>
<li>缺点:
适用于本身有尺寸的元素，如图片，对于段落等必须显示设置其宽高</li>
</ul></li>
<li>CSS3 flexbox
<ul>
<li>优点: 不需要知道宽高</li>
<li>缺点: 兼容性不好，在移动设备上建议使用</li>
</ul></li>
<li>table display
<ul>
<li>优点: 兼容性好<br />
</li>
<li>缺点: 增加了无用的html结构</li>
</ul></li>
</ol>
<h2 id="两列布局"><strong>两列布局</strong></h2>
<ol type="1">
<li>左浮动 + 右margin</li>
<li>左绝对定位 + 右margin</li>
<li>flex实现两列布局: 设置为flex布局后，子元素的float、clear、
vertical-align属性将失效</li>
<li>calc实现两列布局:
使用百分比、em、px、rem单位值计算出其宽度或者高度。通过对右div设置width:
calc(100%-100px)来实现自适应布局<br />
</li>
<li>float + margin负值
<ul>
<li>给右边的div外面套上一个父div，然后让父div的宽度设为100%。对父div的宽度设为100%</li>
</ul></li>
</ol>
<h2 id="水平居中参考"><strong>水平居中</strong><a
href="https://segmentfault.com/a/1190000005353303">【参考】</a></h2>
<ul>
<li>行内元素
<ul>
<li>对父元素设置文本居中，如: text-align: center</li>
<li>适用于inline, inline-block, inline-table, inline-flex</li>
</ul></li>
<li>块级元素
<ul>
<li>margin: 0 auto</li>
</ul></li>
<li>浮动元素</li>
</ul>
<h2 id="boxformatting-context参考"><strong>Box、Formatting
Context</strong><a
href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">【参考】</a></h2>
<ul>
<li>Box:
CSS布局的基本单位，一个页面由多个Box组成。元素的类型和display属性，决定了Box的类型。不同类型的Box，会参与不同的Formatting
Context（一个决定如何渲染文档的容器），即Box内的元素会以不同的方式渲染。
<ol type="1">
<li>block-level box: display属性为block、list-item、table的元素</li>
<li>inline-level box:
display属性为inline、inline-block、inline-table的元素</li>
<li>run-in box: CSS3存在</li>
</ol></li>
<li>Formatting context:
页面中的一块渲染区域，并且有一套渲染规则，其决定了其子元素将如何定位，以及和其他元素的
关系和相互作用
<ol type="1">
<li>BFC: Block Formatting Context</li>
<li>IFC: Inline Formatting Context</li>
<li>GFC: CSS3</li>
<li>FFC: CSS3</li>
</ol></li>
</ul>
<h2 id="bfc参考"><strong>BFC</strong><a
href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">【参考】</a></h2>
<ul>
<li>定义: 块级格式化上下文。一个独立的渲染区域，只有block-level
box参与，规定了内部的 block-level box如何布局。</li>
<li>BFC布局规则
<ol type="1">
<li>内部的box会在垂直方向一个个进行放置</li>
<li>box垂直方向的距离由margin决定。属于同一个BFC的两个相邻box的margin会发生重叠</li>
<li>每个元素的margin box的左边，与包含块border
box的左边相接触。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol></li>
<li>生成BFC的元素
<ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为
inline-block，table-cell，table-caption，flex，inline-flex</li>
<li>overflow不为visible</li>
</ul></li>
</ul>
<h2 id="边界塌陷-边界重叠"><strong>边界塌陷 &amp; 边界重叠</strong></h2>
<p><strong>定义</strong>: CSS中存在一个margin collapse，
即边界塌陷或边界重叠。对于上下两个并列的div，上面的div的margin-bottom和下面的div的margin-top会塌陷，取两者margin的最大值</p>
<h2 id="css-sprite"><strong>CSS sprite</strong></h2>
<p>把网页中的一些背景图片整合到一张图片中，再利用CSS的<code>background-repeat</code>,<code>background-image</code>,<code>background-position</code>的组合进行定位</p>
<h2 id="css-媒体查询参考"><strong>CSS 媒体查询</strong><a
href="http://www.runoob.com/cssref/css3-pr-mediaquery.html">【参考】</a></h2>
<ul>
<li>作用: <span class="citation"
data-cites="media可以针对不同的屏幕尺寸设置不同的样式">@media可以针对不同的屏幕尺寸设置不同的样式</span>，特别是设置响应式的页面</li>
<li>语法
<ul>
<li><span class="citation" data-cites="media">@media</span> mediatype
and|not|only (mediafeature){ CSS-Code; }
<ul>
<li>如: <span class="citation" data-cites="media">@media</span> screen
and (max-width: 300px) { ... }, <span class="citation"
data-cites="media">@media</span></li>
</ul></li>
<li>mediatype
<ul>
<li>all: 用于所有设备</li>
<li>print: 用于打印机和打印预览</li>
<li>screen: 用于电脑屏幕，平板电脑，智能手机等</li>
<li>speech: 应用于屏幕阅读器等发声设备</li>
</ul></li>
<li>mediafeature
<ul>
<li>aspect-ratio: 定义输出设备中的页面可见区域宽度和高度的比率</li>
<li>color: 定义输出设备每一组彩色原件的个数</li>
<li>color-index</li>
<li>device-aspect-ratio</li>
<li>device-height</li>
<li>device-width</li>
<li>grid</li>
<li>height</li>
<li>max-aspect-ratio</li>
<li>max-color</li>
<li>max-device-s</li>
<li>...</li>
</ul></li>
</ul></li>
</ul>
<h2 id="font-face参考"><strong><span class="citation"
data-cites="font-face">@font-face</span></strong><a
href="http://www.runoob.com/cssref/css3-pr-font-face-rule.html">【参考】</a></h2>
<ul>
<li>语法: <span class="citation"
data-cites="font-face">@font-face</span> { font-properties }</li>
<li>font-properties
<ul>
<li>font-family: 定义字体的名称(必须)</li>
<li>src: 定义字体的下载地址(必须)</li>
<li>font-stretch: 定义字体该如何被拉长</li>
<li>font-style: 定义字体该是怎样的样式</li>
<li>font-weight: 定义字体的粗细</li>
<li>unicode-range: 定义字体支持Unicode字符的范围</li>
</ul></li>
</ul>
<h2
id="css3画一个旋转的34的圆环"><strong>CSS3画一个旋转的3/4的圆环</strong></h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">20px</span> solid black;</span><br><span class="line">    <span class="attribute">border-left-color</span>: transparent;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: mycircle <span class="number">1s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> mycircle &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>); &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">360deg</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>IT面试整理(4)——Javascript</title>
    <url>/2017/04/27/it-interviews004/</url>
    <content><![CDATA[<h1 id="网页屏幕宽度高度的获取">网页、屏幕宽度、高度的获取</h1>
<ul>
<li>屏幕分辨率的宽度: window.screen.width</li>
<li>屏幕分辨率的高度: window.screen.height</li>
<li>屏幕可用工作区宽度: window.screen.availWidth</li>
<li>屏幕可用工作区高度: window.screen.availHeight</li>
<li>网页被卷起的高度: document.body.scrollTop</li>
<li>网页被卷起的左边: document.body.scrollLeft</li>
<li>网页正文的全文宽: document.body.scrollWidth</li>
<li>网页正文的全文高: document.body.scrollHeight</li>
<li>网页可见区域宽度: document.body.offsetWidth,
document.body.clientWidth;</li>
<li>网页可见区域高度: document.body.offsetHeight,
document.body.clientHeight;</li>
</ul>
<span id="more"></span>
<h1 id="元素宽度高度的获取参考">元素宽度、高度的获取<a
href="http://www.cnblogs.com/jscode/archive/2012/09/03/2669299.html">【参考】</a></h1>
<ul>
<li>clientWidth: 标准盒模型的宽度(包含border)</li>
<li>offsetWidth: 对象的宽度(width+padding+border)</li>
<li>style.width: 行内式才能获取，包含px, %<br />
</li>
<li>offsetLeft: 距离上层左边的距离</li>
<li>style.left: 可设置 <img
src="http://pic002.cnblogs.com/images/2012/389001/2012090315221723.gif" /></li>
</ul>
<h1 id="propertyattribute的区别">property、attribute的区别</h1>
<ul>
<li>相同之处
<ul>
<li>标准的DOM properties与attributes是同步。</li>
<li>公认的（非自定义）特性被以属性的形式添加到DOM对象中，如: id, align,
style</li>
</ul></li>
<li>不同之处
<ul>
<li>对于有些标准的特性的操作，getAttribute()与点号(.)获取的值存在差异，如href、src、value、style、onclick等</li>
</ul></li>
<li>property(属性): property的值不会出现在html中，只保存在js中</li>
<li>attribute(特性): 只能是字符串，大小写不敏感，出现在innerHTML中</li>
</ul>
<h1 id="typeof">typeof</h1>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>undefined</li>
<li>function</li>
<li>object</li>
</ul>
<h1 id="javascriptnodejs的区别">Javascript、Nodejs的区别</h1>
<ul>
<li>Javascript
<ul>
<li>ECMAScript: 语言基础，如：语法、数据类型结构、内置对象</li>
<li>DOM: 操作页面元素的方法</li>
<li>BOM: 操作浏览器的方法</li>
</ul></li>
<li>Nodejs
<ul>
<li>ECMAScript: 语言基础，如：语法、数据类型结构、内置对象</li>
<li>os: 操作系统</li>
<li>file: 文件系统</li>
<li>net: 网络系统</li>
<li>database: 数据库</li>
</ul></li>
</ul>
<h1
id="escapeencodeuriencodeuricomponent">escape、encodeURI、encodeURIComponent</h1>
<ul>
<li>escape: 将字符的unicode编码转换成为16进制序列，不编码字符有69个
<ul>
<li>如: *，+，-，.，/，@，_，0-9，a-z，A-Z</li>
</ul></li>
<li>encodeURI: 将字符的unicode编码转换成为UTF-8，不编码的字符有82个
<ul>
<li>如:
!，#，$，&amp;，'，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z</li>
</ul></li>
<li>encodeURIComponent:
将字符的unicode编码转换成为UTF-8，不编码的字符有71个
<ul>
<li>如: !， '，(，)，*，-，.，_，~，0-9，a-z，A-Z</li>
</ul></li>
</ul>
<h1 id="stopropagtion-stopimmediatepropagation">stopropagtion(),
stopImmediatePropagation()</h1>
<ul>
<li>stopPropagation(): 阻止事件在DOM中继续传播</li>
<li>stopImmediatePropagation(): 阻止同一个事件的其他监听函数被调用</li>
</ul>
<h1 id="domcontentloaded事件-readstatechange事件">DOMContentLoaded事件,
readstatechange事件</h1>
<ul>
<li>DOMContentLoaded事件:
比load事件早，文档下载并解析完成(DOM生成)，所有外部资源可能还没下载结束</li>
<li>readystatechange事件:
发生在Document对象和XMLHttpRequest对象，当其readyState属性发生变化时触发</li>
</ul>
<h1 id="javascript前缀命名规范">Javascript前缀命名规范</h1>
<ul>
<li>s: 表示字符串。如：sName，sHtml；</li>
<li>n: 表示数字。例如：nPage，nTotal；</li>
<li>b: 表示逻辑。例如：bChecked，bHasLogin；</li>
<li>a: 表示数组。例如：aList，aGroup；</li>
<li>r: 表示正则表达式。例如：rDomain，rEmail；</li>
<li>f: 表示函数。例如：fGetHtml，fInit；</li>
<li>o: 表示以上未涉及到的其他对象，例如：oButton，oDate；</li>
<li>g: 表示全局变量，例如：gUserName，gLoginTime；</li>
</ul>
<h1 id="闭包">闭包</h1>
<ul>
<li>原理:
当某个函数调用时会创建一个执行环境以及作用域链，然后根据arguments和其他命名参数初始化形成活动对象。当外部函数调用结束后，其执行环境与作用域链被销毁，但是其活动对象保存在了闭包之中，最后在闭包函数调用结束后才销毁。</li>
<li>实现:
在函数中定义函数，并且内部函数引用了外部函数的变量，最后内部函数被返回</li>
<li>特性
<ol type="1">
<li>函数嵌套函数</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol></li>
</ul>
<h1 id="javascript垃圾回收原理">Javascript垃圾回收原理</h1>
<ol type="1">
<li>如果一个对象不再被引用，那么对象会被GC回收</li>
<li>如果两个对象相互引用，且不被第三者引用，那么这两个对象会被回收</li>
</ol>
<h1 id="callapply">call、apply</h1>
<ul>
<li>其作用是可以改变其this的指向，其调用方式有所不同。<br />
</li>
<li>call传递参数；apply传递数组</li>
</ul>
<h1 id="javascript数据类型">Javascript数据类型</h1>
<ul>
<li>基本数据类型
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
</ul></li>
<li>引用数据类型
<ul>
<li>object</li>
<li>array</li>
</ul></li>
<li>特殊数据类型
<ul>
<li>null</li>
<li>undefined</li>
</ul></li>
</ul>
<h1 id="原型原型链">原型、原型链</h1>
<p>原型: 一个普通的对象，自带隐式的proto属性，原型也有自己的原型 原型链:
有一些用来继承和共享属性的对象组成的（有限的）对象链</p>
<h1 id="nullundefined">null、undefined</h1>
<p>null: 一个表示“无”的对象，转为数值时为0； undefined:
一个表示“无”的原始值，转为数值时为NaN</p>
<h1 id="es6新特性参考">ES6新特性<a
href="http://www.cnblogs.com/Wayou/p/es6_new_features.html">【参考】</a></h1>
<ul>
<li>箭头操作符：=&gt;</li>
<li>类的支持：class</li>
<li>增强的对象字面量：</li>
<li>可以再对象字面量里定义原型</li>
<li>可以直接调用父类方法</li>
<li>定义方法可以不用function关键字</li>
<li>字符串模板：·your name is ${num}·</li>
<li>解构：自动解析数组或对象中的值</li>
<li>默认参数、不定参数、拓展参数</li>
<li>let、const关键字</li>
<li>for of：值遍历</li>
<li>模块：module</li>
<li>Map、Set、WeakMap、WeakSet</li>
<li>Proxies</li>
<li>Symbols</li>
<li>Math、Number、String、Object的新API</li>
<li>Promises</li>
</ul>
<h1 id="promise">Promise</h1>
<p>Promise的四种状态 (1) pending: 初始状态，非fulfilled或rejected (2)
fulfilled: 成功的操作 (3) rejected: 失败的操作 (4) settled:
Promise已经被fulfilled或rejected，且不是pending</p>
<h1 id="严格模式">严格模式</h1>
<ul>
<li>目的
<ol type="1">
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ol></li>
<li>缺点
<ol type="1">
<li>与未采用严格模式的文件一起压缩，反而会浪费字节</li>
</ol></li>
</ul>
<h1 id="dom操作">DOM操作</h1>
<ul>
<li>创建 createDocumentFragment() createElement() createTextNode()</li>
<li>添加、移除、替换、插入 appendChild() removeChild() replaeChild()
insertBefor()</li>
<li>查找 getElementsByTagName() getElementsByName()
getElementById()</li>
</ul>
<h1
id="document.writeinnerhtml的区别">document.write、innerHTML的区别</h1>
<p>document.write: 只能重绘整个页面 innerHTML: 可以重绘部分页面</p>
<h1 id="javascript对象创建的几种方式">Javascript对象创建的几种方式</h1>
<ol type="1">
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>混合构造模式和原型模式</li>
<li>动态原型模式</li>
<li>寄生构造函数模式</li>
<li>稳妥构造函数模式</li>
</ol>
<h1 id="javascript继承的6中方法">Javascript继承的6中方法</h1>
<ol type="1">
<li>原型链继承<br />
</li>
<li>借用构造函数继承<br />
</li>
<li>组合继承（原型+借用构造）<br />
</li>
<li>原型式继承<br />
</li>
<li>寄生式继承<br />
</li>
<li>寄生组合式继承</li>
</ol>
<h1 id="如何获取ua">如何获取UA</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">whatBrowser</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">Browser</span>.<span class="property">Name</span>.<span class="property">value</span> = navigator.<span class="property">appName</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">Browser</span>.<span class="property">Version</span>.<span class="property">value</span> = navigator.<span class="property">appVersion</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">Browser</span>.<span class="property">Code</span>.<span class="property">value</span> = navigator.<span class="property">appCodeName</span>;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">Browser</span>.<span class="property">Agent</span>.<span class="property">value</span> = navigator.<span class="property">userAgent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1
id="slicesubstrsubstring的区别">slice()、substr()、substring()的区别</h1>
<ul>
<li>slice(start, [end])：参数可为负</li>
<li>substr(start, length)</li>
<li>substring(start, [end]): 参数不可为负</li>
</ul>
<h1 id="array方法">Array方法</h1>
<ul>
<li>转换方法
<ul>
<li>valueOf()</li>
<li>toString()</li>
<li>toLocaleString()</li>
<li>join()</li>
</ul></li>
<li>堆栈方法
<ul>
<li>push()</li>
<li>pop()</li>
</ul></li>
<li>队列方法
<ul>
<li>push()</li>
<li>shift()</li>
<li>unshift(item1, item2, ...)</li>
</ul></li>
<li>排序方法
<ul>
<li>reverse()</li>
<li>sort()</li>
</ul></li>
<li>操作方法
<ul>
<li>concat(arr1, arr2, ...)</li>
<li>slice()</li>
<li>splice()</li>
</ul></li>
<li>位置方法
<ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul></li>
<li>迭代方法
<ul>
<li>every()</li>
<li>filter()</li>
<li>forEach()</li>
<li>map()</li>
<li>some()</li>
</ul></li>
<li>合并方法
<ul>
<li>reduce()</li>
<li>reduceRight()</li>
</ul></li>
</ul>
<h1 id="string方法">String方法</h1>
<ul>
<li>字符方法
<ul>
<li>charAt(index): 返回指定位置的字符</li>
<li>charCodeAt(): 返回指定位置的字符的unicode编码</li>
</ul></li>
<li>操作方法
<ul>
<li>concat()</li>
<li>slice()</li>
<li>substring()</li>
<li>substr()</li>
</ul></li>
<li>位置方法
<ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul></li>
<li>trim方法
<ul>
<li>trim()</li>
<li>trimLeft()</li>
<li>trimRight()</li>
</ul></li>
<li>大小写转换方法
<ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul></li>
<li>模式匹配方法
<ul>
<li>match(string/reg)：
<ul>
<li>string: 返回匹配结果的数组</li>
<li>reg(g): 返回所有的匹配子串</li>
<li>reg:
返回一个数组：元素0存放的是匹配文本；其余元素存放与正则表达式的子表达式匹配的文本；input属性表示匹配文本的起始字符的位置；input属性表示输入字符串</li>
</ul></li>
<li>search()</li>
<li>replace()</li>
<li>split()</li>
</ul></li>
<li>其他方法
<ul>
<li>localeCompare()</li>
<li>fromCharCode()</li>
</ul></li>
</ul>
<h1 id="正则表达式">正则表达式</h1>
<ul>
<li>定义方法
<ul>
<li>直接定义: var r = /pattern/flags;</li>
<li>构造函数: var r = new RegExp('pattern', 'flags');</li>
</ul></li>
<li>元字符: ( ) [ ] { }  ^ $ | ? * + .</li>
<li>特殊元字符
<ul>
<li>.: 查找单个字符</li>
<li>: 查找字母数字下划线</li>
<li>: 查找非字母数字下划线</li>
<li> 查找数字</li>
<li>: 查找非数字字符</li>
<li>: 查找空白字符</li>
<li>: 查找非空白字符</li>
<li> 匹配单词边界</li>
<li>: 匹配非单词边界</li>
<li>\0: 查找NULL字符</li>
<li>: 查找换行符</li>
<li> 查找换页符</li>
<li> 查找回车符</li>
<li> 查找垂直制表符</li>
<li>: 查找以8进制xxx规定的字符</li>
<li>: 查找以16进制dd规定的字符</li>
<li>: 查找以16进制xxxx规定的unicode字符</li>
<li></li>
<li></li>
<li>{m,n}: 最少匹配前面表达式m次，最多n次</li>
<li>{m,}: 最少匹配前面表达式m次</li>
<li>{m}: 正好匹配前面表达式m次</li>
<li>?: 匹配前面表达式0或1次</li>
<li>+: 最少匹配前面表达式1次</li>
<li>*: 最少匹配前面表达式0次</li>
<li>|: 匹配前面表达式或后面表达式</li>
<li>(...): 组合项目</li>
<li>^: 匹配字符串的开头</li>
<li>$: 匹配字符串的结尾</li>
</ul></li>
</ul>
<h1 id="正则表达式方法">正则表达式方法</h1>
<ul>
<li>test(): 返回一个布尔值，表示传入的
字符串是否匹配（从lastIndex属性指示的地方开始）</li>
<li>exec(): 返回一个包含了匹配结果的数组（额外具有两个属性:
input表示本次搜索的目标字符串；index表示匹配结果在目标字符串内的位置）</li>
</ul>
<h1 id="常见的正则表达式">常见的正则表达式</h1>
<ul>
<li>匹配中文: [u4e00-u9fa5]</li>
<li>匹配URL
<ul>
<li>/http(s)?://([-]+.)+[-]+(/[-./?%&amp;=]*)?/</li>
</ul></li>
<li>匹配Email: /<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>+(.[-]+)*@[-]+(.[-]+)+$/</li>
</ul>
<h1 id="js函数调用的方法参考">JS函数调用的方法<a
href="http://www.cnblogs.com/leejersey/p/3663278.html">【参考】</a></h1>
<ol type="1">
<li>方法调用模式</li>
<li>函数调用模式</li>
<li>构造器调用模式</li>
<li>apply调用模式</li>
</ol>
<h1 id="随机打乱数组顺序">随机打乱数组顺序</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">randomArr</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现duplicate">实现duplicate</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">duplicate</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buf;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        buf = [];</span><br><span class="line">        <span class="keyword">var</span> i = obj.<span class="title function_">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">            buf[i] = <span class="title function_">duplicate</span>(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>)&#123;</span><br><span class="line">        buf = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            buf[k] = <span class="title function_">duplicate</span>(obj[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现数组去重">实现数组去重</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">distinct</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">elem, index</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(elem, index+<span class="number">1</span>) === -<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1
id="获取元素到页面顶部和左边的距离">获取元素到页面顶部和左边的距离</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDistance</span>(<span class="params">el</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x = el.<span class="property">offsetLeft</span>;</span><br><span class="line">    <span class="keyword">var</span> y = el.<span class="property">ofsetTop</span>;</span><br><span class="line">    <span class="keyword">while</span>(el = el.<span class="property">offsetParent</span>)&#123;</span><br><span class="line">        x += el.<span class="property">offsetLeft</span>;</span><br><span class="line">        y += el.<span class="property">offsetTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">        <span class="string">&#x27;y&#x27;</span>: y</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现bind方法">实现bind方法</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">context</span>)&#123;</span><br><span class="line">    self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        self.<span class="title function_">apply</span>(context, <span class="variable language_">arguments</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>-<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO 原理详解</title>
    <url>/2018/12/12/kvo-principle/</url>
    <content><![CDATA[<p>KVO（Key-Value Observing）是 iOS
开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析
KVO 的底层原理。<a
href="https://github.com/baochuquan/BAOStudy">源码地址</a></p>
<span id="more"></span>
<h1 id="示例源码">示例源码</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self setupSubviews];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = 1;</span><br><span class="line">    p1.age = 2;</span><br><span class="line">    p2.age = 2;</span><br><span class="line"></span><br><span class="line">    // self 监听 p1 的 age 属性</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line">    p1.age = 10;</span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupSubviews &#123;</span><br><span class="line">    [self setupHeaderView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupHeaderView &#123;</span><br><span class="line">    self.headerView.title = @&quot;KVO&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;监听到 %@ 的 %@ 改变了 %@&quot;, object, keyPath,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例对 <code>p1</code> 进行了 KVO 监听，当 <code>p1</code>
发生改变，即调用 <code>observeValueForKeyPath</code>
方法，从而打印以下信息。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">监听到 &lt;BAOPerson: 0x600003750200&gt; 的 age 改变了 &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 10;</span><br><span class="line">    old = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="kvo-实现原理">KVO 实现原理</h1>
<p>通过上述代码可以发现，一旦 <code>age</code>
属性的值发生改变，就会通知到监听者。我们知道赋值操作都是调用
<code>set</code> 方法，我们可以重写 <code>BAOPerson</code> 类中
<code>age</code> 的 <code>set</code> 方法，观察 KVO 是否是在
<code>set</code> 方法内部做了一些操作来通知监听者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age &#123;</span><br><span class="line">    NSLog(@&quot;override setAge&quot;);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现即使重写了 <code>set</code> 方法，<code>p1</code> 除了调用
<code>set</code> 方法之外还会执行监听者的
<code>observeValueForKeyPath</code> 方法。</p>
<p>根据上述实验推测：KVO 在运行时对 <code>p1</code> 对象进行了改动，使
<code>p1</code> 对象在调用 <code>setAge</code>
方法时做了一些额外的操作。所以问题出在对象身上，两个对象可能本质上并不一样。下面我们来探索一下
KVO 内部是如何实现的。</p>
<h1 id="kvo-实现分析">KVO 实现分析</h1>
<p>首先分别在添加 KVO 前后打上断点，以观察添加 KVO 前后 <code>p1</code>
对象有何不同。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-before-after-add-observe.png?x-oss-process=image/resize,w_800" /></p>
<p>通过打印对象的 <code>isa</code> 指针，我们发现，<code>p1</code>
对象的 <code>isa</code> 指针由之前的指向类对象 <code>BAOPerson</code>
变成了指向类对象
<code>NSKVONotifying_BAOPerson</code>。相应地，<code>p2</code>
对象没有改变。因此我们可以推测，<code>p1</code> 对象的 <code>isa</code>
发生改变后，其执行的 <code>setAge</code> 也发生了改变。</p>
<p>我们知道，<code>p2</code> 在调用 <code>setAge</code>
方法时，首先会通过 <code>p2</code> 对象的 <code>isa</code> 指针找到
<code>BAOPerson</code> 类对象，然后在类对象中找到 <code>setAge</code>
方法，最终找到方法对应的实现。如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo001.png?x-oss-process=image/resize,w_800" /></p>
<p>但是，<code>p1</code> 对象的 <code>isa</code> 在添加 KVO
之后已经指向了 <code>NSKVONotifying_BAOPerson</code>
类对象，<code>NSKVONotifying_BAOPerson</code> 则是
<code>BAOPerson</code> 的子类。<code>NSKVONotifying_BAOPerson</code> 是
runtime 在运行时生成的。因此，<code>p1</code> 对象在调用
<code>setAge</code> 方法时必然会根据 <code>p1</code> 的 <code>isa</code>
找到 <code>NSKVONotifying_BAOPerson</code>，并在
<code>NSKVONotifying_BAOPerson</code> 中找到 <code>setAge</code>
方法及其实现。</p>
<p>经查阅资料了解到，<code>NSKVONotifying_BAOPerson</code> 中的
<code>setAge</code> 方法中其实调用了 Foundation 框架中 C 语言函数
<code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code>
内部的操作大致是：首先调用 <code>willChangeValueForKey</code>
方法，然后调用父类的 <code>setAge</code> 方法对成员变量赋值，最后调用
<code>didChangeValueForKey</code>
方法。<code>didChangeValueForKey</code>
方法中会调用监听者的监听方法，最终调用监听者的
<code>observeValueForKeyPath</code> 方法。</p>
<h1 id="kvo-原理验证">KVO 原理验证</h1>
<p>前面我们已经通过断点打印 <code>isa</code>
指针的方式验证了：<code>p1</code> 对象在添加 KVO 后，其 <code>isa</code>
指针会指向一个通过 runtime 创建的 <code>BAOPerson</code> 的子类
<code>NSKVONotifying_BAOPerson</code>。</p>
<p>下面我们可以通过打印方法实现的地址来看一下 <code>p1</code> 和
<code>p2</code> 的 <code>setAge</code> 方法实现的地址在添加 KVO
前后有什么变化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过methodForSelector找到方法实现的地址</span><br><span class="line">NSLog(@&quot;添加 KVO 之前 - p1 = %p, p2 = %p&quot;, [p1 methodForSelector: @selector(setAge:)], [p2 methodForSelector: @selector(setAge:)]);</span><br><span class="line">    </span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;添加 KVO 之后 - p1 = %p, p2 = %p&quot;, [p1 methodForSelector: @selector(setAge:)], [p2 methodForSelector: @selector(setAge:)]);</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-name-before-after.png?x-oss-process=image/resize,w_800" /></p>
<p>执行上述代码，可以发现：在添加 KVO 之前，<code>p1</code> 和
<code>p2</code> 的 <code>setAge</code> 方法实现的地址是相同的；在添加
KVO 之后， <code>p1</code> 的 <code>setAge</code>
方法实现的地址发生了改变。通过打印方法实现可以证明，<code>p1</code> 的
<code>setAge</code> 方法的实现由 <code>BAOPerson</code> 类方法中的
<code>setAge</code> 方法转换成了 Foundation 框架中的 C 函数
<code>_NSSetIntValueAndNotify</code>。</p>
<p>事实上，Foundation 框架中很多例如
<code>_NSSetBoolValueAndNotify</code>、<code>_NSSetCharValueAndNotify</code>、<code>_NSSetFloatValueAndNotify</code>、<code>_NSSetLongValueAndNotify</code>
等函数。</p>
<p>为了查看 Foundation 框架中的相关函数，我们找到 Foundation
文件，通过命令行查询： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure> <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-value-and-notify-methods.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="中间类内部结构">中间类内部结构</h1>
<p><code>NSKVONotifying_BAOPerson</code> 作为 <code>BAOPerson</code>
的子类，其 <code>superclass</code> 指针指向 <code>BAOPerson</code>
类，其内部对 <code>setAge</code> 方法做了单独的实现，那么
<code>NSKVONotifying_BAOPerson</code> 同 <code>BAOPerson</code>
类的差别可能就在于其内存储的对象方法及实现不同。我们通过 runtime
分别打印 <code>BAOPerson</code> 类对象和
<code>NSKVONotifying_BAOPerson</code> 类对象内存储的对象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = 1;</span><br><span class="line">    p1.age = 2;</span><br><span class="line">    p2.age = 2;</span><br><span class="line">    </span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">    [self printMethods: object_getClass(p2)];</span><br><span class="line">    [self printMethods: object_getClass(p1)];</span><br><span class="line">    </span><br><span class="line">    p1.age = 10;</span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printMethods:(Class)cls &#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        NSString *methodName  = NSStringFromSelector(method_getName(method));</span><br><span class="line"></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:@&quot; &quot;];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;, methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的打印结果如下：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-in-middle-class.png?x-oss-process=image/resize,w_800" /></p>
<p>可以发现，<code>NSKVONotifying_BAOPerson</code> 中有 4
个对象方法，分别是: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setAge:</span><br><span class="line">class</span><br><span class="line">dealloc</span><br><span class="line">_isKVOA</span><br></pre></td></tr></table></figure></p>
<p><code>NSKVONotifying_BAOPerson</code> 重写 <code>class</code>
方法是为了隐藏 <code>NSKVONotifying_BAOPerson</code>
不被外界看到。我们在 <code>p1</code> 添加 KVO 之后，分别打印
<code>p1</code> 和 <code>p2</code> 对象的
<code>class</code>，可以发现它们都返回 <code>BAOPerson</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@, %@&quot;, [p1 class], [p2 class]);</span><br><span class="line">// 打印结果 BAOPerson, BAOPerson</span><br></pre></td></tr></table></figure>
<p>综上，我们可以画出 <code>NSKVONotifying_BAOPerson</code>
的内部结构及方法调用顺序。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo002.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="验证">验证</h1>
<p><code>didChangeValueForKey:</code> 内部调用
<code>observeValueForKeyPath:ofObject:change:context:</code> 方法 在
<code>BAOPerson</code> 类中重写 <code>willChangeValueForKey:</code> 和
<code>didChangeValueForKey:</code> 方法，模拟它们的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;override setAge&quot;);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey: - begin&quot;);</span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey: - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey: - begin&quot;);</span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey: - end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过运行上述代码，可以确定是在 <code>didChangeValueForKey:</code>
方法内部调用了监听者的
<code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-did-change-value-for-key.png?x-oss-process=image/resize,w_800" /></p>
<p>根据上述原理，可以通过调用 <code>willChangeValueForKey:</code> 和
<code>didChangeValueForKey:</code> 来手动触发 KVO。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://juejin.im/post/5adab70cf265da0b736d37a8">iOS底层原理总结 -
探寻KVO本质</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(5)——链接、静态链接、动态链接</title>
    <url>/2018/06/03/linking-static-linking-dynamic-linking/</url>
    <content><![CDATA[<p>通过<a
href="http://chuquan.me/2018/05/21/elf-introduce/">前面</a>对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？一切都要从链接说起。</p>
<span id="more"></span>
<h1 id="链接概述">链接概述</h1>
<p>模块化设计是软件开发中最常用的设计思想。<strong>链接（Linking）</strong>
本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。比如：</p>
<blockquote>
<p>我们在模块<code>main.c</code>中使用另一个模块<code>func.c</code>中的<code>foo()</code>函数。我们在<code>main.c</code>模块中每一处调用<code>foo</code>时都必须确切知道<code>foo</code>函数的地址。但由于每个模块都是单独编译的。编译器在编译<code>main.c</code>的时候并不知道<code>foo</code>函数的地址。所以编译器会暂时把这些调用<code>foo</code>的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。这就是静态链接最基本的过程和作用。</p>
</blockquote>
<p>如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object
File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和
<strong>库（Library）</strong> 一起链接形成最终的可执行文件。</p>
<p>其中，最常见的库就是<strong>运行时库（Runtime
Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/linking-process.png" /></p>
<p>链接过程主要包含了三个步骤：</p>
<ol type="1">
<li><strong>地址与空间分配（Address and Storage
Allocation）</strong></li>
<li><strong>符号解析（Symbol Resolution）</strong></li>
<li><strong>重定位（Relocation）</strong></li>
</ol>
<p>下面，我们以两个源代码文件<code>a.c</code>和<code>b.c</code>为例展开分析。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a.c</span><br><span class="line">extern int shared;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 100;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// b.c</span><br><span class="line">int shared = 1;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>b.c</code>中定义了两个全局符号：变量<code>shared</code>、函数<code>swap</code>；<code>a.c</code>中定义了一个全局符号：<code>main</code>。<code>a.c</code>引用了<code>b.c</code>中的<code>swap</code>和<code>shared</code>。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件<code>ab</code>。</p>
<p>使用<code>gcc -c</code>命令我们可以分别编译得到<code>a.o</code>和<code>b.o</code>两个目标文件。</p>
<h2 id="地址与空间分配">地址与空间分配</h2>
<p>在介绍ELF文件结构关于段与节的区别时，我们就提到过可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。</p>
<h3 id="按序叠加">按序叠加</h3>
<p>一个最简单的方案就是将输入的文件按序叠加，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-simple-merge.png" /></p>
<p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p>
<h3 id="合并相似节">合并相似节</h3>
<p>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的
<strong><code>.text</code>节</strong>合并到输出文件的
<strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-similar-merge.png" /></p>
<p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p>
<ol type="1">
<li>在输出的可执行文件中的空间</li>
<li>在装载后的虚拟地址中的空间</li>
</ol>
<p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p>
<p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫
<strong>两步链接（Two-pass Linking）</strong>
的方法。即整个链接过程分为两步：</p>
<ul>
<li><strong>第一步 地址与空间分配</strong><br />
扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</li>
<li><strong>第二步 符号解析与重定位</strong><br />
使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/two-step-linking.png" /></p>
<p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了<a
href="http://chuquan.me/2018/05/21/elf-introduce/">ELF文件结构</a>一文中没有介绍的
<strong>程序头表（Program Header Table）</strong>
结构。如下右图可执行文件结构所示，主要生成两个段：代码段（
<code>text</code>段）、数据段（ <code>data</code>段 ）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png" /></p>
<p>我们使用ld或gcc将<code>a.o</code>和<code>b.o</code>链接起来，然后使用objdump工具来查看链接前后的地址分配情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -h a.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -h b.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004b  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -h ab</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  ...</span><br><span class="line">  13 .text         00000202  0000000000400450  0000000000400450  00000450  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  ...</span><br><span class="line">  24 .data         00000014  0000000000601028  0000000000601028  00001028  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  25 .bss          00000004  000000000060103c  000000000060103c  0000103c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>可以发现，链接前目标文件中所有节的 <strong>VMA（Virtual Memory
Address）</strong>
都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个节被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>0x0000000000400450</code>。</p>
<p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>0x0000000000400450</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux
x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>0x0000000000400450</code>。</p>
<h2 id="符号解析">符号解析</h2>
<p>在<strong>两步链接</strong>中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。</p>
<p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p>
<p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p>
<p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p>
<h3 id="多重定义的全局符号解析">多重定义的全局符号解析</h3>
<p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p>
<p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p>
<p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong></p>
<p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li><strong>规则1：不允许有多个同名的强符号。</strong></li>
<li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li>
<li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li>
</ul>
<p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p>
<ul>
<li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li>
<li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li>
<li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li>
</ul>
<p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫
<strong>COMMON块（Common Block ）</strong>
的机制来处理。其过程如下：</p>
<p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p>
<h2 id="重定位">重定位</h2>
<p>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
<p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的
<strong>重定位表（Relocation Table）</strong>
专门用来保存这些与重定位相关的信息。</p>
<p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p>
<p>我们可以使用objdump工具来查看目标文件中的重定位表： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000023 R_X86_64_32       share</span><br><span class="line">0000000000000030 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line">0000000000000049 R_X86_64_PC32     __stack_chk_fail-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation
Entry）</strong>。利用数据结构成员包含的信息，即可完成重定位。</p>
<h1 id="静态链接">静态链接</h1>
<p>事实上，静态链接的过程就是上文所描述的过程。在Linux中，静态链接器（static
linker）<code>ld</code>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。</p>
<h1 id="动态链接">动态链接</h1>
<p>静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等。在静态链接中，C语言静态库是很典型的浪费空间的例子。关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序。</p>
<p>解决空间浪费和更新困难最简单的方法便是将程序的模块相互分割开来，形成独立文件。简而言之，就是不对那些组成程序的目标文件进行链接，而是等到程序要运行时才进行链接。</p>
<h2 id="动态链接的基本实现">动态链接的基本实现</h2>
<p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p>
<p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为
<strong>动态共享对象（DSO，Dynamic Shared
Objects）</strong>，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为
<strong>动态链接库（Dynamic Linking
Library）</strong>，一般以<code>.dll</code>为后缀。</p>
<p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在
<code>/lib</code>目录下，文件名为
<code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p>
<h2
id="动态链接程序运行时地址空间分布">动态链接程序运行时地址空间分布</h2>
<p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p>
<p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p>
<ul>
<li><strong>静态共享库（Static Shared
Library）</strong>（地址固定）</li>
<li><strong>动态共享库（Dynamic Shared
Libary）</strong>（地址不固定）</li>
</ul>
<h3 id="静态共享库">静态共享库</h3>
<p>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在<strong>某个特定的地址</strong>划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为<strong>静态</strong>。</p>
<p>但是静态共享库的目标地址会导致地址冲突、升级等问题。</p>
<h3 id="动态共享库">动态共享库</h3>
<p>采用动态共享库的方式，也称为<strong>装载时重定位（Load Time
Relocation）</strong>。其基本思路是：<strong>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。</strong></p>
<p>但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。</p>
<p>虽然，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为<strong>地址无关代码</strong>的技术被提出以克服这个问题。</p>
<h4 id="地址无关代码">地址无关代码</h4>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p>
</blockquote>
<p><strong>地址无关代码（PIC，Position-independent Code）</strong>
技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型：</p>
<ul>
<li><strong>类型1：模块内部的函数调用。</strong></li>
<li><strong>类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。</strong></li>
<li><strong>类型3：模块外部的函数调用。</strong></li>
<li><strong>类型4：模块外部的数据访问，如其他模块中定义的全局变量。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int a;</span><br><span class="line">extern int b;</span><br><span class="line">extern void ext();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    a = 1;      // 类型2：模块内部数据访问</span><br><span class="line">    b = 2;      // 类型4：模块外部数据访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    bar();      // 类型1：模块内部函数调用</span><br><span class="line">    ext();      // 类型4：模块外部函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类型1-模块内部函数调用">类型1 模块内部函数调用</h5>
<p>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</p>
<h5 id="类型2-模块内部数据访问">类型2 模块内部数据访问</h5>
<p>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p>
<h5 id="类型3-模块间数据访问">类型3 模块间数据访问</h5>
<p>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个<strong>指向这些变量的指针数组</strong>，也称为<strong>全局偏移表（Global
Offset
Table，GOT）</strong>，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/inter-module-data-access.png" /></p>
<p>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以<strong>在模块装载时被修改</strong>，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h5 id="类型4-模块间函数调用">类型4 模块间函数调用</h5>
<p>对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。</p>
<h1 id="总结">总结</h1>
<p>通过上文的描述，我们基本理清了链接的过程以及静态链接和动态链接的区别。事实上，链接的具体实现细节是非常复杂，本文只是对其进行了概述，更多细节以及优化实现还是需要我们自己进一步去探索。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>Executable and Linkable Format (ELF)</li>
<li>《Linux 二进制分析》</li>
<li>《程序员的自我修养——链接、装载与库》</li>
<li>《深入理解计算机系统》</li>
<li><a
href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable
and Linkable Format</a></li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>静态链接</tag>
        <tag>动态链接</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基本命令</title>
    <url>/2020/12/19/linux-basic-commands/</url>
    <content><![CDATA[<p>本文收录了一些常用的 Linux 基本命令。</p>
<span id="more"></span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/linux-basic-commands.png?x-oss-process=image/resize,w_800" /></p>
]]></content>
      <categories>
        <category>收录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(1)——硬盘</title>
    <url>/2019/04/05/linux-disk-introduce/</url>
    <content><![CDATA[<h1 id="硬盘接口">硬盘接口</h1>
<p>常见的硬盘接口有：<strong>IDE</strong>
、<strong>SATA</strong>、<strong>SAS</strong>、<strong>USB</strong>、<strong>SCSI</strong>，其中
SATA 是目前的主流接口，IDE 则几乎不再使用。</p>
<span id="more"></span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/disk-interfaces.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="设备文件">设备文件</h1>
<p>计算机的各种硬件设备在 Linux
中都有对应的设备文件，甚至不同的接口也对应着不同的设备文件，从而使用不同的驱动程序来操作硬件设备。对于硬盘，实体设备的文件名一般是
<code>/dev/sd[a-]</code>；虚拟设备（虚拟机中的硬盘）的文件名一般是
<code>/dev/vd[a-]</code>。</p>
<p>有时，系统中会有
<code>/dev/sda</code>、<code>/dev/sdb</code>...等设备文件，它们之间又是什么关系呢？实际上，<code>/dev/sd[a-]</code>
是 SATA/USB/SAS 等硬盘接口对应的设备文件，这类接口都使用 SCSI
模块作为驱动程序。<code>a</code>、<code>b</code>、<code>c</code>...则是按系统检测到的顺序来排列的，与实际插槽顺序无关。</p>
<p>我们知道硬盘是可以被分区成多个分区（partition），如在 Windows
中可以将一块硬盘分区成 <code>C:</code>、<code>D:</code>、<code>E:</code>
盘。那么，不同的分区是否也有对应的设备文件呢？</p>
<h1 id="硬盘结构">硬盘结构</h1>
<p>提到分区，我们需要先了解一下硬盘的结构。不同寻址方式的硬盘，其结构也不同。硬盘的寻址方式主要有两种：</p>
<ul>
<li><strong>CHS
寻址方式</strong>：由柱面数（Cylinders）、磁头数（Headers）、扇区数（Sectors）组成
3D 参数，简称 CHS 寻址方式，硬盘容量相对较小。如传统的机械硬盘（Hard
Disk Drive，HDD）。</li>
<li><strong>LBA
寻址方式</strong>：线性寻址，以逻辑区块为单位进行寻址，全称为 Logic
Block Address（即扇区的逻辑块地址），硬盘容量相对较大。如固态硬盘（Solid
State Disk，SSD）</li>
</ul>
<h2 id="chs-寻址方式">CHS 寻址方式</h2>
<p>如下图所为 CHS
寻址方式的硬盘结构，硬盘主要由盘片、机械手臂、磁头、主轴马达组成。盘片是数据存储的媒介，圆形，通过机械手臂读写数据，盘片需要转动才能够让机械手臂读写。因此，可以将盘片同心圆分割成一个个的小区块，这些区块组成一个圆形，可以让机械手臂的磁头进行读写。这个小区块就是硬盘的最小物理存储单位，即
<strong>扇区（sector）</strong>。位于同一个同心圆上的扇区组成的圆环，即
<strong>磁道（track）</strong>。硬盘中可能包含多个盘片，在所有盘片上的同一个磁道组成了所谓的
<strong>柱面（cylinder）</strong>，柱面是文件系统的最小单位，也是分区的最小单位。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-structure.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="lba-寻址方式">LBA 寻址方式</h2>
<p>LBA
寻址方式的硬盘使用集成电路代替物理旋转磁盘，主要由主控与闪存芯片组成。数据的读写速度远远高于
CHS 寻址方式的硬盘。</p>
<h1 id="硬盘分区">硬盘分区</h1>
<p>了解了硬盘结构，再来看硬盘分区。</p>
<p>关于硬盘分区，首先思考一个问题：为什么要分区？其实主要有两个原因：</p>
<ol type="1">
<li>数据的安全性。由于每个分区的数据是独立的，使得数据更加安全。</li>
<li>访存的高效性。对于 CHS
寻址方式的硬盘，由于分区将数据集中在某个柱面的区段，如第一个分区位于柱面号
1~100。当需要对该分区进行访存时，硬盘只会在 1~100
柱面范围内进行操作，从而提升了数据的访存性能。</li>
</ol>
<p>既然硬盘能被分区，那么其分区信息是如何保存的呢？答案就是分区表。但是对于不同寻址方式的硬盘，其分区表的格式也不同，主要有两种：</p>
<ul>
<li><strong>MBR 分区表</strong>：多用于 CHS 寻址方式的硬盘</li>
<li><strong>GUID 分区表</strong>：多用于 LBA 寻址方式的硬盘</li>
</ul>
<p>分区表有存储在哪里呢？和绝大多数文件将自身的基本描述信息放在文件的开头类似，分区表作为硬盘的基本信息，同样保存在硬盘最前面的存储区域。</p>
<p>下面分别介绍 MBR 分区表和 GUID 分区表。</p>
<h2 id="mbr-分区表"><strong>MBR 分区表</strong></h2>
<p>MBR 分区表保存在硬盘的
<strong>第一个扇区</strong>，由于第一个扇区主要记录了两个重要信息，也称为
<strong>主引导记录区（Master Boot
Record，MBR）</strong>。这两个信息分别是：</p>
<ul>
<li><strong>MBR 分区表</strong>：记录整个硬盘的分区信息，容量为 64
Bytes。</li>
<li><strong>引导程序（Boot Loader）</strong>：容量为 446 Bytes。</li>
</ul>
<h3 id="mbr-分区表-1">MBR 分区表</h3>
<p>分区表占据了 MBR 64 Bytes 的空间，最多只能记录 4
组分区信息，每组分区信息记录了该分区的
<strong>起始与结束的柱面号</strong>，这 4 组分区信息称为
<strong>主要分区（primary partition）</strong> 或
<strong>延伸分区（extended partition）</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-partition-table.png?x-oss-process=image/resize,w_800" /></p>
<p>假设上述硬盘的设备文件名为 <code>/dev/sda</code>，则这四个分区在
Linux
中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与分区在硬盘中的位置有关。</p>
<ul>
<li>P1：<code>/dev/sda1</code></li>
<li>P2：<code>/dev/sda2</code></li>
<li>P3：<code>/dev/sda3</code></li>
<li>P4：<code>/dev/sda4</code></li>
</ul>
<p>由于分区表只有 64 Bytes，最多只能记录 4
组分区信息，那么是否意味着一个硬盘最多只能分割成 4
个分区呢？当然不是！<strong>虽然第一个扇区的分区表只能记录 4
组分区信息，但是利用其中的延伸分区信息进一步索引到一个新的分区表，从而记录更多分区信息</strong>。如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-partition-table-extend.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，硬盘第一个扇区中的四个分区记录仅仅使用了两个，P1 为
<strong>主要分区</strong>，P2 为
<strong>延伸分区</strong>。延伸分区的目的是使用额外的扇区来记录分区信息。通过延伸分区所指向的那个区块继续记录分区信息。上图延伸分区索引的分区表继续分出了
5 个分区，这 5 个有延伸分区分出来的分区，称为 <strong>逻辑分区（logical
partition）</strong>。</p>
<p>同理，上图中的分区在 Linux 中的设备文件名如下所示。其中的
<code>/dev/sda3</code> 和 <code>/dev/sda4</code>
则保留给主要分区和延伸分区了，所以逻辑分区的设备文件名从 5 开始。</p>
<ul>
<li>P1：<code>/dev/sda1</code></li>
<li>P2：<code>/dev/sda2</code></li>
<li>L1：<code>/dev/sda5</code></li>
<li>L2：<code>/dev/sda6</code></li>
<li>L3：<code>/dev/sda7</code></li>
<li>L4：<code>/dev/sda8</code></li>
<li>L5：<code>/dev/sda9</code></li>
</ul>
<blockquote>
<p>MBR 主要分区、延伸分区、逻辑分区的特性 - 主要分区与延伸分区最多可以有
4 个（硬盘的限制） - 延伸分区最多只有一个（操作系统的限制） -
逻辑分区是由延伸分区持续分割出来的分区 -
主要分区和逻辑分区可以被格式化；延伸分区不能被格式化 -
逻辑分区的数量上限由操作系统决定</p>
</blockquote>
<h3 id="引导程序boot-loader">引导程序（Boot Loader）</h3>
<p>Boot loader 是操作系统安装在 MBR 中的一套软件，但 MRB 仅仅提供 446
Bytes 的空间给 boot loader，所以 boot loader
是极其精简的。其主要完成以下任务：</p>
<ol type="1">
<li>提供菜单：用户可以选择不同的开机项目</li>
<li>载入核心文件：直接指向可开机的程序区段来启动操作系统</li>
<li>转交其他 loader：将开机管理功能转交给其他 loader
负责，主要用于多系统引导。</li>
</ol>
<p>对于第 3 项，表示计算机系统中可能具有两个以上的 boot
loader。事实上，boot loader 不仅可以安装在 MBR
中，还可以安装在每个分区的 <strong>开机扇区（boot sector）</strong>
中。</p>
<p>假设 MBR 中安装的是可以识别 Windows/Linux 的 boot
loader，那么整个流程如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-boot-loader.png?x-oss-process=image/resize,w_800" /></p>
<p>由上图可知，MBR 的 boot loader 提供两个菜单选项：选项
1（M1）可以直接载入 Windows
的核心文件进行开机；选项二（M2）可以将开机管理任务交给第二个分区的开机扇区（boot
sector）。如果用户选择选项 2，第二分区的开机扇区中的 boot loader
将会载入 Linux 的核心文件进行开机。</p>
<blockquote>
<p>关于多系统安装 Linux 安装时，可以将 boot loader 安装在 MBR
或其他分区的开机扇区，Linux 的 boot loader 可以手动设置菜单（即上图的
M1、M2），因此可在 Linux 的 boot loader 中加入 Windows 开机的选项
Windows 安装时，其安装程序会主动覆盖 MBR
以及自己所在分区的开机扇区，并且没有选择的机会，也没有让用户自己选择的菜单的功能
结论：安装多系统时应该先安装 Windows 系统</p>
</blockquote>
<h2 id="guid-分区表">GUID 分区表</h2>
<p>MBR 主要有以下限制：</p>
<ul>
<li>操作系统无法寻址容量超过 2.2TB 的磁盘</li>
<li>MBR 只有一个区块，若被破坏后，很难对数据进行恢复</li>
<li>MBR 的引导程序所能使用空间只有 446 Byte，无法容纳更多的代码</li>
</ul>
<p>GUID 则解决了 MBR 的这些问题。</p>
<p>下图所示为 GUID 的结构示意图。与 MBR 使用扇区作为寻址单位不同，GUID
使用 <strong>逻辑区块（Logical Block）</strong> 作为寻址单位，即采用
LBA（Logical Block Address）寻址方式。MRB 仅使用第一个扇区 512 Bytes
的空间记录分区信息，GUID 则使用 34 个 LBA 区块（每个区块容量默认为 512
Bytes）记录分区信息。MBR 仅有一个扇区保存分区信息，GUID 除了使用硬盘前
34 个 LBA，还是用最后 33 个 LBA 作为备份。</p>
<p>这里有个疑问：为何前面使用 34 个 LBA，后面使用 33 个 LBA。因为第一个
LBA（LBA0）是用来兼容 MBR 的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-guid-partition-table.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="lba0mbr-兼容区块">LBA0（MBR 兼容区块）</h3>
<p>LBA0 为了兼容 MBR，该区块也分为两个部分，分别用于存储 MBR
分区表和引导程序。因为LBA0 是针对 MBR
兼容模式，因此其分区表中仅仅存放一个特殊标志的分区表信息，用来标识此硬盘为
LBA 寻址方式。</p>
<h3 id="lba1guid-分区表表头">LBA1（GUID 分区表表头）</h3>
<p>LBA1 记录了分区表本身的位置和大小，同时记录了备份分区表的位置（即最后
33 个 LBA）。此外还存放了分区表的校验码（CRC32），表示硬盘的完整性。</p>
<h3 id="lba233分区表表项">LBA2~33（分区表表项）</h3>
<p>从 LBA2 开始，每个 LBA 都可以记录 4
组分区信息。默认情况下，总共可以有 4 * 32 = 128 组分区信息。因为每个 LBA
有 512 Bytes，所以每组分区信息可使用 128 Bytes 的空间。这 128 Bytes
的分区信息中，分别提供了 64 Bits 用于记录分区对应的
<strong>起始/结束</strong> 区块号。因此，GUID 能够支持的硬盘的最大容量为
<code>2^64 * 512Byte = 233 TB</code></p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://blog.csdn.net/petershina/article/details/8330171">硬盘寻址方式</a></li>
<li><a
href="https://blog.csdn.net/Lyon_yong/article/details/79178794">SSD固态硬盘的结构和基本工作原理概述</a></li>
<li>《鸟哥的 Linux 私房菜——基础学习篇》</li>
<li>《Linux 系统架构和应用技巧》</li>
<li>《Linux 系统架构与目录解析》</li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Logos基础语法</title>
    <url>/2018/02/22/logos-syntax/</url>
    <content><![CDATA[<h1 id="hook"><code>%hook</code></h1>
<blockquote>
<p>该指令指定需要hook的class，必须以<code>%end</code>结尾</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down &#123;</span><br><span class="line">    NSLog(@&quot;Home Button Pressed&quot;);</span><br><span class="line">    %orig;     // call the original _menuButtonDown:</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h1 id="log"><code>%log</code></h1>
<blockquote>
<p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog，可以以<code>%log([(&lt;type&gt;)&lt;expr&gt;, ...])</code>的格式追加其他打印信息。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down &#123;</span><br><span class="line">    %log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;);</span><br><span class="line">    %orig;      // call the original _menuButtonDown:</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h1 id="orig"><code>%orig</code></h1>
<blockquote>
<p>该指令在<code>%hook</code>内部使用，执行被hook的函数的原始代码。此外，还可以利用<code>%orig</code>更改原始函数的参数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%hook SBLockScreenDateViewController</span><br><span class="line">- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2 &#123;</span><br><span class="line">    %orig(@&quot;iOS 8 App Reverse Engineering&quot;, arg2);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h1 id="group"><code>%group</code></h1>
<blockquote>
<p>该指令用户将<code>%hook</code>分组，便于代码管理及按条件初始化分组，必须以<code>%end</code>结尾。一个<code>%group</code>可以包含多个<code>%hook</code>，所有不属于某个自定义group的<code>%hook</code>都会被隐式归类到<code>%group_ungrouped</code>中。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%group iOS7Hook </span><br><span class="line">%hook iOS7Class </span><br><span class="line">- (id)iOS7Method &#123;</span><br><span class="line">    id result = %orig;</span><br><span class="line">    NSLog(@&quot;This class &amp; method only exist in iOS 7.&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS7Hook </span><br><span class="line"></span><br><span class="line">%group iOS8Hook </span><br><span class="line">%hook iOS8Class </span><br><span class="line">- (id)iOS8Method &#123;</span><br><span class="line">    id result = %orig;</span><br><span class="line">    NSLog(@&quot;This class &amp; method only exist in iOS 8.&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS8Hook </span><br><span class="line"></span><br><span class="line">%hook SpringBoard </span><br><span class="line">-(void)powerDown &#123;</span><br><span class="line">    %orig; </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h1 id="init"><code>%init</code></h1>
<blockquote>
<p>该指令用于初始化某个<code>%group</code>，必须在<code>%hook</code>或<code>%ctor</code>内调用；如果带参数，则初始化指定的group；如果不带参数，则初始化_ungroupded。<strong>只有调用了<code>%init</code>，对应的<code>%group</code>才能起作用</strong>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 </span><br><span class="line">#endif</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)applicationDidFinishLaunching:(id)application &#123;</span><br><span class="line">    %orig;</span><br><span class="line">    %init; // Equals to %init(_ungrouped) </span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp;</span><br><span class="line">        kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS7Hook);</span><br><span class="line">        </span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS8Hook); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h1 id="ctor"><code>%ctor</code></h1>
<blockquote>
<p>tweak的constructor，完成初始化工作；如果不显示定义，Theos会自动生成一个<code>%ctor</code>，并在其中调用<code>%init(_ungrouped)</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%hook SpringBoard </span><br><span class="line">- (void)reboot &#123;</span><br><span class="line">    NSLog(@&quot;If rebooting doesn&#x27;t work then I&#x27;m screwed.&quot;);</span><br><span class="line">    %orig; </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<p>上述实例可以成功生效，是因为Theos隐式定义了如下内容： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%ctor </span><br><span class="line">&#123;</span><br><span class="line">    %init(_ungrouped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>%ctor</code>一般可以用来初始化<code>%group</code>，以及进行<code>MSHookFunction</code>等操作。<code>%ctor</code>不需要以<code>%end</code>结尾。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 </span><br><span class="line">#endif</span><br><span class="line">%ctor</span><br><span class="line">&#123;</span><br><span class="line">    %init;</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; </span><br><span class="line">        kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS7Hook);</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS8Hook); </span><br><span class="line">    </span><br><span class="line">    MSHookFunction((void *)&amp;AudioServicesPlaySystemSound, </span><br><span class="line">                   (void *)&amp;replaced_AudioServicesPlaySystemSound, </span><br><span class="line">                   (void **)&amp;original_AudioServicesPlaySystemSound); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="new"><code>%new</code></h1>
<blockquote>
<p>在<code>%hook</code>内部使用，给一个现有class添加一个新函数，功能与<code>class_addMethod</code>相同。<strong>注意，Objective-C的Category语法也可以给现有的class添加新函数。但区别在于category是静态的，<code>class_addMethod</code>是动态的</strong>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">%new</span><br><span class="line">- (void)namespaceNewMethod &#123;</span><br><span class="line">    NSLog(@&quot;We&#x27;ve added a new method to SpringBoard.&quot;); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>
<h1 id="c"><code>%c</code></h1>
<p>该指令的作用等同于<code>objc_getClass</code>或<code>NSClassFromString</code>，即动态获取一个类的定义，在<code>%hook</code>或<code>%ctor</code>内使用。</p>
<p>(完)</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《iOS应用逆向工程（第2版）》</li>
<li><a href="http://iphonedevwiki.net/index.php/Logos">Logos</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Logos语法</tag>
        <tag>Theos</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O 格式</title>
    <url>/2020/09/14/mach-o-format/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>Mach-O 的全称是 Mach Object File
Format，它可以用来表示可执行文件、目标代码或共享库、动态库等。Mach
内核的操作系统，如：macOS，iPadOS，iOS 采用的都是
Mach-O。本文我们来学习一下 Mach-O 的内部结构，通过学习
Mach-O，可以了解应用程序是如何加载到系统中的，如何执行的。</p>
<span id="more"></span>
<h1 id="基本结构">基本结构</h1>
<p>Mach-O 文件的内部组成可以分为三个部分：</p>
<ul>
<li><strong>Header</strong>
<ul>
<li>每一个 Mach-O 文件的起始部分，用于将文件标识为 Mach-O 文件。Header
还包含关于文件的其他信息，如：文件类型、CPU 架构类型等。</li>
</ul></li>
<li><strong>Load Commands</strong>：
<ul>
<li>Load Commands 包含了一系列不同的 <strong>加载命令（Load
Commands）</strong>，可用于指导如何设置并加载二进制数据。在 Mach-O
的文件布局中，Load Commands 紧跟在 Header 之后。Load Commands
有诸多功能，比如：
<ul>
<li>指定文件在虚拟内存中的初始布局</li>
<li>指定动态链接时的符号表位置</li>
<li>指定程序主线程的初始执行状态</li>
<li>指定共享库的名称，共享库包含程序所导入符号的定义。</li>
</ul></li>
</ul></li>
<li><strong>Data</strong>
<ul>
<li>Data 包含了多个 segment，每个 segment 包含 0 个或多个 section。每个
segment 中的 section 具有相同的类型，如：代码或数据。每个 segment
定义了一个虚拟内存区域，动态链接器能够将其映射到进程的地址空间。segment
和 section 的数量和布局则是由 load commands 和文件类型指定的。</li>
<li>对于用户级完全链接的 Mach-O 文件，其最后一个 segment 是
<strong>LINKEDIT</strong> segment。该 segment
包含了符号链接的信息表，如：符号表、字符串表等，动态链接器基于这些信息将可执行程序或
Mach-O bundle 与其依赖的库进行链接接。</li>
</ul></li>
</ul>
<p>下图所示为 Mach-O 文件的基本结构：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/mach-o-overview.png?x-oss-process=image/resize,w_800" /></p>
<p>下面我们来对 Mach-O 文件 Header 和 Load Commands 进行着重分析。Load
Command 中涉及到的一些其他数据结构，如 section 则存储在 Data 之中。</p>
<h1 id="header">Header</h1>
<p>Header 的数据结构如下所示（在
<code>/usr/include/mach-o/loader.h</code> 中定义）： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	magic;		    <span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="type">cpu_type_t</span>	cputype;	    <span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="type">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filetype;	    <span class="comment">/* type of file */</span></span><br><span class="line">	<span class="type">uint32_t</span>	ncmds;		    <span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	sizeofcmds;	    <span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		    <span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>magic</code>
<ul>
<li>指定文件的类型为 Mach-O。如果文件希望其布局与 CPU 字节序相同，则使用
<code>MH_MAGIC</code>；如果文件希望其布局与 CPU 字节序相反，则使用
<code>MH_CIGAM</code>。</li>
</ul></li>
<li><code>cputype</code>
<ul>
<li>指定文件运行的目标架构，可能包含两种类型：
<ul>
<li><code>CPU_TYPE_POWERPC</code>：基于 PowerPC CPU 的 Mac 计算机。</li>
<li><code>CPU_TYPE_I386</code>：基于 Intel CPU 的 Mac 计算机。</li>
</ul></li>
</ul></li>
<li><code>cpusubtype</code>
<ul>
<li>指定 CPU 确切型号。如果希望能够 PowerPC 或 Intel
的所有处理器上执行，可以设置为 <code>CPU_SUBTYPE_POWERPC_ALL</code> 或
<code>CPU_SUBTYPE_I386_ALL</code>。</li>
</ul></li>
<li><code>filetype</code>
<ul>
<li>指定文件的类型。其包含以下这些值：
<ul>
<li><code>MH_OBJECT</code>：表示
<strong>中间目标文件</strong>。这是一种非常紧凑的格式，它将所有的
section 放在了一个 segment
中。<strong>编译器和汇编器通常会为每一个源代码文件生成一个中间目标文件，文件一般以
<code>.o</code> 作为后缀</strong>。</li>
<li><code>MH_EXECUTE</code>：表示
<strong>标准的可执行程序</strong>。</li>
<li><code>MH_BUNDLE</code>：表示 <strong>插件</strong> 或
<strong>bundle</strong>。非独立的二进制文件，<strong>由可执行文件显式进行加载</strong>。<strong>文件一般以
<code>.bundle</code> 作为后缀</strong>。</li>
<li><code>MH_DYLIB</code>：表示
<strong>动态共享库</strong>。其包含一些额外的表来支持多个模块。<strong>文件一般以
<code>.dylib</code> 作为后缀</strong>，framework
的主共享库除外，其没有文件后缀名。</li>
<li><code>MH_CORE</code>：表示
<strong>核心转储文件</strong>。操作系统会在程序崩溃时创建该文件。核心转储文件存储了程序崩溃时的完整地址空间。我们可以通过在核心转储文件上运行
<code>gdb</code> 来判断崩溃的原因。</li>
<li><code>MH_DYLINKER</code>：表示
<strong>动态链接器</strong>。<code>dyld</code> 的文件类型就是
<code>MH_DYLINKER</code>。</li>
<li><code>MH_DSYM</code>：表示
<strong>存储了二进制符号信息的文件</strong>。</li>
</ul></li>
</ul></li>
<li><code>ncmds</code>
<ul>
<li>指定 load commands 的数量。</li>
</ul></li>
<li><code>sizeofcmds</code>
<ul>
<li>指定 load commands 所占据的字节数。</li>
</ul></li>
<li><code>flags</code>
<ul>
<li>指定 Mach-O
文件的某些可选功能的状态，下面是一些我们可以操作该字段的掩码：
<ul>
<li><code>MH_NOUNDEFS</code>：表示目标文件在构建时不包含未定义的引用。</li>
<li><code>MH_INCRLNK</code>：表示目标文件是相对于一个基本文件的增量链接输出，无法再次链接。</li>
<li><code>MH_DYLDLINK</code>：表示目标文件是动态链接器的输入，无法再次静态链接。</li>
<li><code>MH_TWOLEVEL</code>：表示镜像采用二级命名空间绑定。</li>
<li><code>MH_BINDATLOAD</code>：表示当文件加载完毕之后，动态链接器应该对未定义引用进行绑定。</li>
<li><code>MH_PREBOUND</code>：表示文件的未定义引用是预先绑定的。</li>
<li><code>MH_PREBINDABLE</code>：表示文件没有预绑定，但是可以重新对其进行预绑定。<strong>仅在
<code>MH_PREBOUND</code> 未设置时使用</strong>。</li>
<li><code>MH_NOFIXPREBINDING</code>：表示动态链接器不会将关于此可执行文件的信息通知预绑定代理。</li>
<li><code>MH_ALLMODSBOUND</code>：表示将此二进制文件绑定到它所依赖的库的所有二级命名空间
module。<strong>仅在 <code>MH_PREBINDABLE</code> 和
<code>MH_TWOLEVEL</code> 设置时使用</strong>。</li>
<li><code>MH_CANONICAL</code>：表示文件已取消预绑定。</li>
<li><code>MH_SPLIT_SEGS</code>：表示文件的只读段和读写段是分离的。</li>
<li><code>MH_FORCE_FLAT</code>：表示可执行文件强制所有镜像使用扁平的命名空间绑定。</li>
<li><code>MH_SUBSECTIONS_VIA_SYMBOLS</code>：表示目标文件的 sections
可以分为独立的块。如果其他代码未使用这些块，则会被清理掉。</li>
<li><code>MH_NOMULTIDEFS</code>：表示确保子镜像没有针对同一符号的多种定义。因此可以使用两级命名空间提示。</li>
</ul></li>
</ul></li>
</ul>
<p><strong>注意</strong>：对于所有的文件类型（<code>MH_OBJECT</code>
除外），对于给定的 CPU 架构，segments 必须页对齐：PowerPC 和 x86
处理器的页面大小均为 4KB。这使得内核能够直接为 segment
分配虚拟内存页面。</p>
<h1 id="load-commands">Load Commands</h1>
<p>Load commands 位于 Header
之后，它们用于指定文件的逻辑结构、文件在虚拟内存中的布局。所有类型的
<strong>加载命令</strong>
都具有相同的两个字段，用于指定命令类型以及命令数据的大小，如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></span><br><span class="line">	<span class="type">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>cmd</code>
<ul>
<li>指定加载命令的类型。下面列出了有效的加载命令的类型。
<ul>
<li><code>LC_UUID</code>：表示 <code>uuid_command</code>
加载命令。用于指定一个镜像或其对应的 dSYM 文件的 128 位 UUID。</li>
<li><code>LC_SEGMENT</code>：表示 <code>segment_command</code>
加载命令。将指定的 segment
映射到加载此文件的进程的地址空间中。此外，还定义了 segment 所包含的所有
sections。</li>
<li><code>LC_SYMTAB</code>：表示 <code>symtab_command</code>
加载命令。用于指定此文件的符号表。<strong>动态链接或静态链接此文件时都会调用符号表信息，调试器也使用符号表将符号映射到生成符号的原始代码文件</strong>。</li>
<li><code>LC_DYSYMTAB</code>：表示 <code>dysymtab_command</code>
加载命令。用于指定
<strong>动态链接器使用的额外符号表信息</strong>。</li>
<li><code>LC_THREAD</code>、<code>LC_UNIXTHREAD</code>：表示
<code>thread_command</code>
加载命令。对于可执行文件，<code>LC_UNIXTHREAD</code>
定义了进程主线程的初始化状态；<code>LC_THREAD</code> 与
<code>LC_UNIXTHREAD</code> 类似，但是不会导致内核分配栈区。</li>
<li><code>LC_LOAD_DYLIB</code>：表示 <code>dylib_command</code>
加载命令。用于定义此文件会链接的动态链接库的名称。</li>
<li><code>LC_ID_DYLIB</code>：表示 <code>dylib_command</code>
加载命令。用于定义动态链接器的名称。</li>
<li><code>LC_PREBOUND_DYLIB</code>：表示
<code>prebound_dylib_command</code>
加载命令。对于此文件预先链接到的共享库，通过此加载命令指定共享库中使用的
module。</li>
<li><code>LC_LOAD_DYLINKER</code>：表示 <code>dylinker_command</code>
加载命令。用于指定
<strong>内核加载此文件所使用的动态链接器</strong>。</li>
<li><code>LC_ID_DYLINKER</code>：表示 <code>dylinker_command</code>
加载命令。用于指定此文件是动态链接器。</li>
<li><code>LC_ROUTINES</code>：表示 <code>routines_command</code>
加载命令。包含共享库初始化进程的地址。</li>
<li><code>LC_TWOLEVEL_HINTS</code>：表示
<code>twolevel_hints_command</code>
加载命令。包含两级命名空间查找表。</li>
<li><code>LC_SUB_FRAMEWORK</code>：表示
<code>sub_framework_command</code> 加载命令。将此文件标识为 umbrella
framework 的子 framework 的实现。umbrella framework
的名称存储在字符串参数中。</li>
<li><code>LC_SUB_UMBRELLA</code>：表示 <code>sub_umbrella_command</code>
加载命令。将一个文件标记为此 umbrella framework 的子 umbrella。</li>
<li><code>LC_SUB_LIBRARY</code>：表示 <code>sub_library_command</code>
加载命令。用于定义 <code>LC_SUB_LIBRARY</code> 加载命令的属性，标识为此
framework 的子 library，并将该 framework 标记为一个 umbrella
framework。</li>
<li><code>LC_SUB_CLIENT</code>：表示 <code>sub_client_command</code>
加载命令。当包含 <code>LC_SUB_CLIENT</code> 加载命令，且包含另一个
framework 或 bundle 的名称时，子 framework 就可以允许被它们所链接。</li>
</ul></li>
</ul></li>
<li><code>cmdsize</code>
<ul>
<li>指定数据结构的大小，以字节为单位。不同类型的加载命令，除了包含上述两个基本字段之外，还包含其他的数据字段。</li>
</ul></li>
</ul>
<p>表：</p>
<p>下面依次来介绍各种不同类型的加载命令。</p>
<h2 id="uuid_command">uuid_command</h2>
<p><code>uuid_command</code> 加载命令用于指定镜像或其对应的 dSYM 文件的
128 位通用唯一标识符（UUID）。<code>uuid_command</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_UUID */</span></span><br><span class="line">    <span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* sizeof(struct uuid_command) */</span></span><br><span class="line">    <span class="type">uint8_t</span>	uuid[<span class="number">16</span>];	<span class="comment">/* the 128-bit uuid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>uuid</code>
<ul>
<li>128 位的 UUID。</li>
</ul></li>
</ul>
<h2 id="segment_command">segment_command</h2>
<p><code>segment_command</code> 命令用于指定一个 segment
的字节范围，该范围中的数据通过加载器映射到程序的地址空间。<code>segment_command</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="type">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>segname</code>
<ul>
<li>用于描述 segment 名称的 C 字符串。<strong>苹果定义 segment
名称以两个下划线为前缀，并由大写字母组成，如：<code>__TEXT</code>、<code>__DATA</code></strong>。</li>
</ul></li>
<li><code>vmaddr</code>
<ul>
<li>指定 segment 在虚拟内存中的起始地址。</li>
</ul></li>
<li><code>vmsize</code>
<ul>
<li>指定 segment 在虚拟内存中占据的字节数。</li>
</ul></li>
<li><code>fileoff</code>
<ul>
<li>指定要映射到 <code>vmaddr</code> 位置的数据在此文件中的偏移。</li>
</ul></li>
<li><code>filesize</code>
<ul>
<li>指定 segment 在磁盘上占据的字节数。对于运行时比构建时需要更多内存的
segment，<code>vmsize</code> 可以大于
<code>filesize</code>。比如，链接器为 <code>MH_EXECUTABLE</code>
文件生成的 <code>__PAGESIZE</code> segment，其 <code>vmsize</code> 是
<code>0x1000</code>，而 <code>filesize</code> 却是 <code>0</code>。因为
<code>__PAGEZERO</code>
不包含数据，因此在运行前没有必要占据任何空间。类似的，静态链接器通常在
<code>__DATA</code> segment 的末尾分配未初始化的数据。</li>
</ul></li>
<li><code>maxprot</code>
<ul>
<li>指定 segment 的最大允许的虚拟内存保护级别。</li>
</ul></li>
<li><code>initprot</code>
<ul>
<li>指定 segment 的初始化虚拟内存保护级别。</li>
</ul></li>
<li><code>nsects</code>
<ul>
<li>指定紧跟在此加载命令之后的 section 数量。</li>
</ul></li>
<li><code>flags</code>
<ul>
<li>定义一组影响 segment 加载的标志位，如下：
<ul>
<li><code>SG_HIGHVM</code>：segment
的文件内容占虚拟内存空间的高位部分，低位部分填充零。</li>
<li><code>SG_NORELOC</code>：segment
没有任何重定位的内容，也没有要重定位的内容。</li>
</ul></li>
</ul></li>
</ul>
<p>Segment 定义了 Mach-O
中的一段字节，并定义了当这段字节映射到到虚拟内存时的地址和内存保护级别。比如，segment
始终关于虚拟内存页面对齐的。一个 segment 包含 0 个或多个
section。相比加载前，运行时的 segment
可能需要更多的内存。比如：由链接器为 PowerPC
生成的可执行文件中，<code>__PAGEZERO</code> segment 虚拟内存大小为 1
页，但在磁盘上的大小却为 0。由于 <code>__PAGEZERO</code>
不包含任何数据，因此不需要占用可执行文件中的任何空间。</p>
<p>为了紧凑起见，中间目标文件仅包含一个 segment。该 segment
没有名称，它包含所有的 section。</p>
<p>以下是 OS X 可执行文件中可能会包含的 segment：</p>
<ul>
<li><code>__PAGEZERO</code>：静态链接器创建 <code>__PAGEZERO</code>
segment 作为可执行文件的第一个 segment。该 segment 的虚拟内存地址为
0，并且未分配保护权限，这些权限的组合会导致对 NULL
的访问立即崩溃。<code>__PAGEZERO</code> segment
的大小为当前体系结构的一个完整 VM 页面的大小。<code>__PAGEZERO</code>
segment 中没有数据，所以它在文件中不占空间。</li>
<li><code>__TEXT</code>：<code>__TEXT</code> segment
包含可执行代码和其他只读数据。为了允许内核将其直接从可执行文件映射到可共享的内存，静态链接器将此
segment 的虚拟内存权限设置为禁止写入。当该 segment
映射到内存中时，可以在对其内存感兴趣的进程之间进行共享。（这主要用于
framework，bundle 以及共享库，但是可以在 OS X
中运行同一可执行文件的多个副本，在这种情况下也是如此。）只读属性还表示页面组成
<code>__TEXT</code> segment
的文件永远都不需要写回到磁盘。当内核需要释放物理内存时，它可以简单地丢弃一个或多个
<code>__TEXT</code> 页面，并在下次需要它们时从磁盘中重新读取。</li>
<li><code>__DATA</code>：<code>_DATA</code> segment
包含可写数据。静态链接器设置此 segment
的虚拟内存权限为允许读写。因为是可写的，所以在逻辑上会为与该库连接的每个进程复制框架或共享库的
<code>__DATA</code> segment。当组成 <code>__DATA</code> segment
的内存页是可读写时，内核将其标记为
<strong>写时复制</strong>（Copy-on-write）。因此，当一个进程写入这些页面时，该进程将会得到属于自己的页面私有副本。</li>
<li><code>__OBJC</code>：<code>__OBJC</code> segment 包含由 Objective-C
语言运行时支持的库所使用的数据。</li>
<li><code>__IMPORT</code>：<code>IMPORT</code> segment
包含符号插桩以及指向可执行文件中未定义符号的非惰性指针。只有 IA-32
体系结构的可执行文件会生成此 segment。</li>
<li><code>__LINKEDIT</code>：<code>__LINKEDIT</code> segment
包含动态链接器所需要的原始数据，如：符号、字符串、重定位表项。</li>
</ul>
<h3 id="section">section</h3>
<p>紧跟在 <code>segment_command</code> 数据结构之后的是一个 section
数据结构的数组，section 的数量由 <code>segment_command</code> 的
<code>nsects</code> 字段确定。多个 section 组成一个 segment。</p>
<p><code>section</code> 的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section</span> &#123;</span>                <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="type">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="type">uint32_t</span>	addr;		    <span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="type">uint32_t</span>	size;		    <span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="type">uint32_t</span>	offset;		    <span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="type">uint32_t</span>	align;		    <span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="type">uint32_t</span>	reloff;	    	<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nreloc;		    <span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;	    	<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="type">uint32_t</span>	reserved1;  	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="type">uint32_t</span>	reserved2;	    <span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>sectname</code>
<ul>
<li>指定 section 的名称。<strong>苹果定义 section
的名称以两个下划线开头，并由小写字母组成，如：<code>__text</code>、<code>__data</code></strong>。</li>
</ul></li>
<li><code>segname</code>
<ul>
<li>指定最终应包含此 section 的 segment
的名称。为了紧凑起见，中间目标文件（<code>MH_OBJECT</code>
类型的文件）仅包含一个 segment，所有的 section
都放在其中。静态链接器在构建最终产物（非 <code>MH_OBJECT</code>
类型的文件）时，会将每个 section 放在指定的 segment 中。</li>
</ul></li>
<li><code>addr</code>
<ul>
<li>指定 section 在虚拟内存中的起始地址。</li>
</ul></li>
<li><code>size</code>
<ul>
<li>指定 section 在虚拟内存中占据的字节数。</li>
</ul></li>
<li><code>offset</code>
<ul>
<li>指定 section 在此文件中的偏移。</li>
</ul></li>
<li><code>align</code>
<ul>
<li>指定 section 的对齐方式。</li>
</ul></li>
<li><code>reloff</code>
<ul>
<li>指定 section 的第一个重定位项在文件中的偏移。</li>
</ul></li>
<li><code>nreloc</code>
<ul>
<li>指定 section 的重定位项的数量。</li>
</ul></li>
<li><code>flags</code>
<ul>
<li>该字段可分为两个部分：低 8 位指定 section 的类型、高 24 位包含指定
section
的其他属性的一组标志。这些类型和标志主要被静态链接器和文件分析工具（如：<code>otool</code>）用来确定如何修改或显示
section。section 的类型有以下这些：
<ul>
<li><code>S_REGULAR</code>：表示 section
没有特殊类型。<strong>标准工具创建的 <code>__TEXT,__text</code> 就是此类
section</strong>。</li>
<li><code>S_ZEROFILL</code>：<strong>按需填充零</strong>，当首次读取或写入该
section 时，其中的每个页面都会自动填充零。</li>
<li><code>S_CSTRING_LITERALS</code>：表示 section 只包含常量 C
字符传。<strong>标准工具创建的 <code>__TEXT,__cstring</code> 就是此类
section</strong>。</li>
<li><code>S_4BYTE_LITERALS</code>：表示 section 只包含 4
字节长的常量值。<strong>标准工具创建的 <code>__TEXT,__literal4</code>
就是此类 section</strong>。</li>
<li><code>S_8BYTE_LITERALS</code>：表示 section 只包含 8
字节长的常量值。<strong>标准工具创建的 <code>__TEXT,__literal8</code>
就是此类 section</strong>。</li>
<li><code>S_NON_LAZY_SYMBOL_POINTERS</code>：表示 section
只包含符号的非惰性指针。<strong>标准工具创建的
<code>__DATA,__nl_symbol_ptrs</code> 就是此类 section</strong>。</li>
<li><code>S_LAZY_SYMBOL_POINTERS</code>：表示 section
只包含符号的惰性指针。<strong>标准工具创建的
<code>__DATA,__la_symbol_ptrs</code> 就是此类 section</strong>。</li>
<li><code>S_SYMBOL_STUBS</code>：表示 section
只包含符号插桩（stub）。<strong>标准工具创建的
<code>__TEXT,__symbol_stub</code> 和
<code>__TEXT,__picsymbol_stub</code> 就是此类 section</strong>。</li>
<li><code>S_MOD_INIT_FUNC_POINTERS</code>：表示 section
只包含指向模块构建方法的指针。<strong>标准工具创建的
<code>__DATA,__mod_init_func</code> 就是此类 section</strong>。</li>
<li><code>S_MOD_TERM_FUNC_POINTERS</code>：表示 section
只包含指向模块析构方法的指针。<strong>标准工具创建的
<code>__DATA,__mod_term_func</code> 就是此类 section</strong>。</li>
<li><code>S_COALESCED</code>：表示 section
只包含由静态链接器或动态链接器合并的符号。多个文件包含同一符号的合并定义，而不会引起
<code>multiple-defined-symbol</code> 报错。</li>
<li><code>S_GB_ZEROFILL</code>：表示 section 是一个按需填充零的
section。section 可以大于 4 GB。该 section 只能放在仅包含零填充 section
的 segment 中。如果将零填充 section 放在包含非零填充 section 的 segment
中，那么可能会导致这些 section
无法没读取。最终导致静态链接器无法生成输出文件。</li>
</ul></li>
<li>section 的属性有以下这些：
<ul>
<li><code>S_ATTR_PURE_INSTRUCTIONS</code>：表示 section
只包含可执行机器码。<strong>标准工具会为
<code>__TEXT,__text</code>、<code>__TEXT,__symbol_stub</code>、<code>__TEXT,__picsymbol_stub</code>
等 section 设置该属性</strong>。</li>
<li><code>S_ATTR_SOME_INSTRUCTIONS</code>：表示 section
包含一部分可执行机器码。</li>
<li><code>S_ATTR_NO_TOC</code>：表示 section 包含合并符号。</li>
<li><code>S_ATTR_EXT_RELOC</code>：表示 section
包含必须要被重定位的引用。这些引用引用其他文件中的数据（未定义符号）。为了支持外部重定位，包含此
section 的 segment 的最大虚拟内存保护级别必须允许读取和写入。</li>
<li><code>S_ATTR_LOC_RELOC</code>：表示 section
包含的引用必须被重定位。它们引用的是此文件中的数据。</li>
<li><code>S_ATTR_STRIP_STATIC_SYMS</code>：如果镜像的
<code>mach_header</code> 中的 <code>MH_DYLDLINK</code>
标志位被设置了，那么 section 中的静态符号就可以被删除。</li>
<li><code>S_ATTR_NO_DEAD_STRIP</code>：表示 section
的内容如果没有被引用，不能被删除。</li>
<li><code>S_ATTR_LIVE_SUPPORT</code>：如果 section
引用的代码存在，但是无法检测到该引用，那么不能被删除。</li>
</ul></li>
</ul></li>
</ul>
<p>Mach-O 文件中的每个 section
都具有类型和一组属性标志位。在中间目标文件中，静态链接器通过 section
的类型和属性决定如何将这些 section
拷贝到最终产物中。目标文件分析工具（如：<code>otool</code>）使用 section
的类型和属性来确定如何读取和显示 section。动态链接器也会用到某些 section
类型和属性。</p>
<p>以下是一些重要的符号类型和属性的静态链接变体：</p>
<ul>
<li><strong>regular section</strong>：在一个 regular section
中，一个外部符号只能有一个定义存在于中间目标文件。如果静态链接器找到两个外部符号的定义，则会报错。</li>
<li><strong>coalesced section</strong>：在最终的产物中，静态链接器对于
coalesced section
中的每一个符号只保留一个定义。为了支持复杂的语言特性（如 C++ 的虚表和
RTTI），编译器可以在每个中间目标文件中为一个特定的符号创建一个定义。之后，静态链接器和动态链接器会将重复的定义减少为单个定义。</li>
<li><strong>带弱定义的 coalesced
section</strong>：弱符号定义只可能出现在 coalesced section
中。当静态链接器找到符号的重复定义时，它会丢弃任何具有弱定义属性的合并符号定义。如果没有非弱定义，则是会用第一个弱定义。此功能旨在支持
C++ 模板。它允许显式模板实例覆盖隐式模板实例。C++ 编译器将显式定义放在
regular section 中，并将隐式定义放在 coalesced section
中，并标记为弱定义。用弱定义构建的的中间目标文件（以及静态归档库）只能与
OX X v10.2
及更高版本中的静态链接器一起使用。如果最终产物（应用程序和共享库）应该在
OS X 的早期版本中使用，则不应包含较弱的定义。</li>
</ul>
<p>以下是 <code>__TEXT</code> segment 中的几种 section：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Segment and Section</th>
<th style="text-align: left;">content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>__TEXT,__text</code></td>
<td
style="text-align: left;">可执行的机器码。编译器通常在此部分中放置可执行代码，而不放置任何形式的表或数据。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__TEXT,__cstring</code></td>
<td style="text-align: left;">常量 C 字符串。C
字符串是一系列非空字节，以空字节 <code>\0</code>
结尾。静态链接器会在构建最终产物时合并 C 字符串常量，并删除重复项。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__TEXT,__picsymbol_stub</code></td>
<td style="text-align: left;">与位置无关的间接符号插桩。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__TEXT,__symbol_stub</code></td>
<td style="text-align: left;">间接符号插桩。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__TEXT,__const</code></td>
<td style="text-align: left;">初始化的常量。编译器将所有声明为 const
的不可重定位数据放在此 section 中。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__TEXT,__literal4</code></td>
<td style="text-align: left;">4 字节文本值。编译器在此 section
中放置单精度浮点常量。在构建最终产物时，静态链接器会合并这些值，并删除重复项。在某些架构中，编译器使用即时加载指令比添加到此
section 中更加高效。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__TEXT,__literal8</code></td>
<td style="text-align: left;">8 字节文本值。同上</td>
</tr>
</tbody>
</table>
<p>以下是 <code>__DATA</code> segment 中的几种 section：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Segment and Section</th>
<th style="text-align: left;">content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>__DATA,__data</code></td>
<td style="text-align: left;">初始化的可变变量，例如可写的 C
字符串和数据数组。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__DATA,__la_symbol_ptr</code></td>
<td
style="text-align: left;">惰性符号指针，它们是对从其他文件导入的函数的间接引用。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__DATA,__nl_symbol_ptr</code></td>
<td
style="text-align: left;">非惰性符号指针，它们是对从其他文件导入的数据项的间接引用。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__DATA,__dyld</code></td>
<td style="text-align: left;">动态链接器使用的占位 section。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__DATA,__const</code></td>
<td style="text-align: left;">初始化的可重定位常量变量。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__DATA,__mod_init_func</code></td>
<td style="text-align: left;">模块构造函数。C++
编译器将静态构造函数放在此处。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__DATA,__mod_term_func</code></td>
<td style="text-align: left;">模块析构函数。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__DATA,__bss</code></td>
<td style="text-align: left;">未初始化的静态变量的数据，例如
<code>static int i;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__DATA,__common</code></td>
<td
style="text-align: left;">位于全局范围内（函数声明之外）的未初始化的导入符号定义，例如，<code>int i;</code></td>
</tr>
</tbody>
</table>
<p>以下是 <code>__IMPORT</code> segment 中的几种 section： |Segment and
Section | content | |:---|:---|
|<code>__IMPORT,__jump_table</code>|动态库中的函数调用插桩。|
|<code>__IMPORT,__pointers</code>|非惰性符号指针，它们是对从其他文件中导入的函数的直接引用。|</p>
<h2 id="twolevel_hints_command">twolevel_hints_command</h2>
<p><code>twolevel_hints_command</code> 的数据结构定义如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twolevel_hints_command</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> cmd;	    <span class="comment">/* LC_TWOLEVEL_HINTS */</span></span><br><span class="line">    <span class="type">uint32_t</span> cmdsize;	<span class="comment">/* sizeof(struct twolevel_hints_command) */</span></span><br><span class="line">    <span class="type">uint32_t</span> offset;	<span class="comment">/* offset to the hint table */</span></span><br><span class="line">    <span class="type">uint32_t</span> nhints;	<span class="comment">/* number of hints in the hint table */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>offset</code>
<ul>
<li>指定 <code>twolevel_hint</code> 数组在文件中的偏移。</li>
</ul></li>
<li><code>nhints</code>
<ul>
<li>指定 <code>twolevel_hint</code> 的数量。</li>
</ul></li>
</ul>
<p>静态链接器在编译一个两级命名空间镜像时，会将
<code>LC_TWOLEVEL_HINTS</code>
加载命令、两级命名空间提示表写入输出文件中。</p>
<p>默认，<code>ld</code> 不会在 <code>MH_BUNDLE</code> 中写入
<code>LC_TWOLEVEL_HINTS</code> 加载命令和两级命名空间提示表。</p>
<h3 id="twolevel_hint">twolevel_hint</h3>
<p><code>twolevel_hint</code>
用于表示两级命名空间提示表中的一个项。<code>twolevel_hint</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twolevel_hint</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> </span><br><span class="line">	isub_image:<span class="number">8</span>,	<span class="comment">/* index into the sub images */</span></span><br><span class="line">	itoc:<span class="number">24</span>;	    <span class="comment">/* index into the table of contents */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>isub_image</code>
<ul>
<li>表示符号已定义的子镜像（subimage）。用来索引组成综合镜像（umbrella
image）的子镜像。如果该字段为
0，则表示符号位于综合镜像中。如果镜像不是一个 umbrella framework 或
library，那么该字段也是 0。</li>
</ul></li>
<li><code>itoc</code>
<ul>
<li><code>isub_image</code> 所指定镜像的符号索引。</li>
</ul></li>
</ul>
<p>两级命名空间提示表为动态链接器提供了建议的位置，从而在当前镜像所链接的库中搜索符号。</p>
<p>两级命名空间镜像中每一个未定义的符号在二级命名空间提示表中有着对应的索引项。</p>
<p><strong>静态链接器在构建两级命名空间镜像时将
<code>LC_TWOLEVEL_HINTS</code>
加载命令和两级命名空间提示表写入到输出文件中。</strong></p>
<p><strong>默认情况下，链接器不会在 <code>MH_BUNDLE</code> 文件中写入
<code>LC_TWOLEVEL_HINTS</code>
加载命令和两级命名空间提示表。</strong></p>
<h3 id="lc_str">lc_str</h3>
<p><code>lc_str</code> 用于定义一个可变长度的字符串。<code>lc_str</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	offset;	<span class="comment">/* offset to the string */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LP64__</span></span><br><span class="line">	<span class="type">char</span>		*ptr;	<span class="comment">/* pointer to the string */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>offset</code>
<ul>
<li>表示从包含此字符串的加载命令的开始到字符串数据开始的偏移。</li>
</ul></li>
<li><code>ptr</code>
<ul>
<li>表示指向字节数组的指针。在运行时，该指针包含字符串数据的虚拟内存地址。在
Mach-O 文件中没有使用 <code>ptr</code> 字段。</li>
</ul></li>
</ul>
<p>加载命令使用 <code>lc_str</code>
数据结构存储可变长度的数据，如库名。除非另有说明，否则数据由 C
字符串组成。</p>
<p>指针指向的数据存储在加载命令之后，并且将数据大小存储在加载命令之中。该字符串应该以
null 终止。我们还可以通过从加载命令数据结构的 <code>cmdsize</code>
字段减去加载命令数据结构大小来确定字符串的大小。</p>
<h2 id="dylib_command">dylib_command</h2>
<p><code>dylib_command</code> 的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* includes pathname string */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dylib</span>	<span class="title">dylib</span>;</span>	<span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>dylib</code>
<ul>
<li>用于描述共享库的属性。</li>
</ul></li>
</ul>
<p><strong>对于文件所链接的每一个共享库，静态链接器都会创建一个
<code>LC_LOAD_DYLIB</code> 加载命令，并且将其 <code>dylib</code>
字段设置为目标库的 <code>LC_ID_DYLD</code> 加载命令的 <code>dylib</code>
字段值。所有 <code>LC_LOAD_DYLIB</code>
加载命令组成一个列表，该列表根据文件中的位置进行排序，最早的
<code>LC_LOAD_DYLIB</code>
命令在列表的最前面。对于两级命名空间文件，符号表中未定义的符号项通过索引此列表来引用其父级共享库。该索引称之为
<code>library ordinal</code>，它存储在 <code>nlist</code> 数据结构的
<code>n_desc</code> 字段中。</strong></p>
<p><strong>在运行时，动态链接器使用 <code>LC_LOAD_DYLIB</code>
加载命令的 <code>dyld</code>
字段中的名称来查找共享库</strong>。如果找到了库，则动态链接器会将
<code>LC_LOAD_DYLIB</code>
加载命令的版本信息与库的版本信息进行比较。为了使动态链接器能够成功链接共享库，共享库的兼容版本必须小于等于
<code>LC_LOAD_DYLIB</code> 加载命令中的兼容版本。</p>
<p>动态链接器使用时间戳来确定它是否可以使用预绑定信息。当前版本由
<code>NSVersionOfRunTimeLibrary</code>
函数返回，从而允许你确定程序正在使用的库的版本。</p>
<h3 id="dylib">dylib</h3>
<p>动态链接器使用 <code>dylib</code> 来匹配要链接的共享库。仅在
<code>dylib_command</code> 加载命令中被用到。</p>
<p><code>dylib</code> 的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>  <span class="title">name</span>;</span>			<span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="type">uint32_t</span> timestamp;			<span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="type">uint32_t</span> current_version;		<span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="type">uint32_t</span> compatibility_version;	<span class="comment">/* library&#x27;s compatibility vers number*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>name</code>
<ul>
<li><code>lc_str</code> 类型的数据结构。用于指定共享库的名称。</li>
</ul></li>
<li><code>timestamp</code>
<ul>
<li>表示共享库构建的时间戳。</li>
</ul></li>
<li><code>current_version</code>
<ul>
<li>表示共享库的当前版本。</li>
</ul></li>
<li><code>compatibility_version</code>
<ul>
<li>表示共享库的兼容版本。</li>
</ul></li>
</ul>
<h2 id="dylinker_command">dylinker_command</h2>
<p><code>dylinker_command</code> 的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylinker_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_ID_DYLINKER, LC_LOAD_DYLINKER or LC_DYLD_ENVIRONMENT */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* includes pathname string */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>    <span class="title">name</span>;</span>	<span class="comment">/* dynamic linker&#x27;s path name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>name</code>
<ul>
<li><code>lc_str</code> 类型的数据结构。用于指定动态链接器的名称。</li>
</ul></li>
</ul>
<p><strong>动态链接的每个可执行文件都包含一个
<code>LC_LOAD_DYLINKER</code>
加载命令，该命令指定内核必须加载指定名称的动态链接器。动态链接器本身使用
<code>LC_ID_DYLINKER</code> 加载命令指定其名称</strong>。</p>
<h2 id="prebound_dylib_command">prebound_dylib_command</h2>
<p>对于可执行文件链接到的每一个预绑定的库，静态链接器都会添加一个
<code>LC_PREBOUND_DYLIB</code> 命令。</p>
<p><code>prebound_dylib_command</code> 的数据结构定义如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prebound_dylib_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		        <span class="comment">/* LC_PREBOUND_DYLIB */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	        <span class="comment">/* includes strings */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>	<span class="title">name</span>;</span>		    <span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nmodules;	        <span class="comment">/* number of modules in library */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>	<span class="title">linked_modules</span>;</span>	<span class="comment">/* bit vector of linked modules */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>name</code>
<ul>
<li><code>lc_str</code>
类型的数据结构。用于指定预绑定共享库的名称。</li>
</ul></li>
<li><code>nmodules</code>
<ul>
<li>指定预绑定共享库所包含模块的数量。</li>
</ul></li>
<li><code>linked_modules</code>
<ul>
<li><code>lc_str</code>
类型的数据结构。它是一个可变长度的位集，每个位表示相应的模块是否已经链接到当前文件中，1
表示是，0 表示否。第一个模块是第一个字节的低位。</li>
</ul></li>
</ul>
<h2 id="thread_command">thread_command</h2>
<p><code>thread_command</code> 的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_THREAD or  LC_UNIXTHREAD */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* total size of this command */</span></span><br><span class="line">	<span class="comment">/* uint32_t flavor		   flavor of thread state */</span></span><br><span class="line">	<span class="comment">/* uint32_t count		   count of uint32_t&#x27;s in thread state */</span></span><br><span class="line">	<span class="comment">/* struct XXX_thread_state state   thread state for this flavor */</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="routines_command">routines_command</h2>
<p><code>routines_command</code>
描述共享库构建函数的位置，动态链接器会在调用任何程序之前调用该函数。<code>routines_command</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">routines_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		    <span class="comment">/* LC_ROUTINES */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	    <span class="comment">/* total size of this command */</span></span><br><span class="line">	<span class="type">uint32_t</span>	init_address;	<span class="comment">/* address of initialization routine */</span></span><br><span class="line">	<span class="type">uint32_t</span>	init_module;	<span class="comment">/* index into the module table that */</span></span><br><span class="line">				                <span class="comment">/*  the init routine is defined in */</span></span><br><span class="line">	<span class="type">uint32_t</span>	reserved1;</span><br><span class="line">	<span class="type">uint32_t</span>	reserved2;</span><br><span class="line">	<span class="type">uint32_t</span>	reserved3;</span><br><span class="line">	<span class="type">uint32_t</span>	reserved4;</span><br><span class="line">	<span class="type">uint32_t</span>	reserved5;</span><br><span class="line">	<span class="type">uint32_t</span>	reserved6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>init_address</code>
<ul>
<li>表示构建函数在虚拟内存中的地址。</li>
</ul></li>
<li><code>init_module</code>
<ul>
<li>表示包含构建函数的模块在模块表中的索引。</li>
</ul></li>
</ul>
<p>当使用 <code>-init</code>
选项指定一个共享库构建函数时，静态链接器会添加一个
<code>LC_ROUTINES</code> 命令。</p>
<h2 id="sub_framework_command">sub_framework_command</h2>
<p><code>sub_framework_command</code> 加载命令用于指定 subframework
所属的 umbrella framework。<code>sub_framework_command</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_framework_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		    <span class="comment">/* LC_SUB_FRAMEWORK */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	    <span class="comment">/* includes umbrella string */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> 	<span class="title">umbrella</span>;</span>	<span class="comment">/* the umbrella framework name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>umbrella</code>
<ul>
<li>表示此文件所属的 umbrella framework 的名称。</li>
</ul></li>
</ul>
<h2 id="sub_umbrella_command">sub_umbrella_command</h2>
<p><code>sub_umbrella_command</code> 加载命令用于指定 framework 的一个
subumbrella。与 subframework 不同，任何客户端都可以链接到一个
subumbrella。</p>
<p><code>sub_umbrella_command</code> 的数据结构定义如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_umbrella_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		        <span class="comment">/* LC_SUB_UMBRELLA */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	        <span class="comment">/* includes sub_umbrella string */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> 	<span class="title">sub_umbrella</span>;</span>	<span class="comment">/* the sub_umbrella framework name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>sub_umbrella</code>
<ul>
<li><code>lc_str</code> 类型的数据结构。用于指定 subumbrella
的名称。</li>
</ul></li>
</ul>
<h2 id="sub_library_command">sub_library_command</h2>
<p>指定此 framework 的一个 sublibrary，并将此 framework 标记为 umbrella
framework。与 subframework 不同，任何客户端都可以链接到一个
sublibrary。</p>
<p><code>sub_library_command</code> 的数据结构定义如下：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_library_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		        <span class="comment">/* LC_SUB_LIBRARY */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	        <span class="comment">/* includes sub_library string */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> 	<span class="title">sub_library</span>;</span>	<span class="comment">/* the sub_library name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>sub_library</code>
<ul>
<li><code>lc_str</code> 类型的数据结构。用于指定此文件所属的 sublibrary
的名称。</li>
</ul></li>
</ul>
<h2 id="sub_client_command">sub_client_command</h2>
<p><code>sub_client_command</code> 加载命令用于指定允许链接到此
subframework 的文件的名称。否则，需要该文件链接到该文件所在的 umbrella
framework。</p>
<p><code>sub_client_command</code> 的数据结构如下所示：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_client_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_SUB_CLIENT */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* includes client string */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> 	<span class="title">client</span>;</span>		<span class="comment">/* the client name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>client</code>
<ul>
<li><code>lc_str</code> 类型的数据结构。用于指定允许链接到此 library
的客户端的名称。</li>
</ul></li>
</ul>
<p>如果在调用 <code>ld</code> 时带上
<code>-allowable_client &lt;name&gt;</code> 选项，其中
<code>&lt;name&gt;</code> 可以是一个 framework 的安装名称，也可以是一个
bundle 的客户端名称，那么 <code>ld</code> 工具会在产物中生成一个
<code>sub_client_command</code> 加载命令。</p>
<h2 id="symtab_command">symtab_command</h2>
<p><code>symtab_command</code>
加载命令用于描述符号表的数据结构以及位置和大小信息。<code>symtab_command</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		<span class="comment">/* LC_SYMTAB */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	<span class="comment">/* sizeof(struct symtab_command) */</span></span><br><span class="line">	<span class="type">uint32_t</span>	symoff;		<span class="comment">/* symbol table offset */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsyms;		<span class="comment">/* number of symbol table entries */</span></span><br><span class="line">	<span class="type">uint32_t</span>	stroff;		<span class="comment">/* string table offset */</span></span><br><span class="line">	<span class="type">uint32_t</span>	strsize;	<span class="comment">/* string table size in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>symoff</code>
<ul>
<li>指定符号表表项在文件中的起始位置。<strong>符号表是一组
<code>nlist</code> 数据结构组成的一个表</strong>。</li>
</ul></li>
<li><code>nsyms</code>
<ul>
<li>指定符号表中的表项数量。</li>
</ul></li>
<li><code>stroff</code>
<ul>
<li>指定字符串表在文件中的起始位置。</li>
</ul></li>
<li><code>strsize</code>
<ul>
<li>指定字符串表的大小。单位为字节。</li>
</ul></li>
</ul>
<h3 id="nlist">nlist</h3>
<p><code>nlist</code> 是表示符号表中的表项的数据结构。<code>nlist</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LP64__</span></span><br><span class="line">		<span class="type">char</span> *n_name;	<span class="comment">/* for use when in-core */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="type">uint32_t</span> n_strx;	<span class="comment">/* index into the string table */</span></span><br><span class="line">	&#125; n_un;</span><br><span class="line">	<span class="type">uint8_t</span> n_type;		<span class="comment">/* type flag, see below */</span></span><br><span class="line">	<span class="type">uint8_t</span> n_sect;		<span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">	<span class="type">int16_t</span> n_desc;		<span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">	<span class="type">uint32_t</span> n_value;	<span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>u_un</code>
<ul>
<li>保存了指向字符串表的索引，<code>n_str</code>。如果希望指定一个空字符串（""），可以将字段设置为
0。联合体中的 <code>n_name</code> 字段并不会用在 Mach-O 文件中。</li>
</ul></li>
<li><code>n_type</code>
<ul>
<li>一个字节值，包含使用四个位掩码访问的数据。
<ul>
<li><code>N_STAB</code>（0xE0）：如果设置了这 3
位，则表示该符号是符号调试表（stab）表项。在这种情况下，整个
<code>n_type</code> 字段都被解释为 stab 值。</li>
<li><code>N_PEXT</code>（0x10）：如果设置了此位，则表示该符号被标记为具有有限的全局作用域。静态链接器处理该文件时会将每个设置了
<code>N_PEXT</code> 位的符号清除 <code>N_EXT</code> 位（<code>ld</code>
的 <code>-keep_private_externs</code> 选项关闭了此行为）。对于 OS X
GCC，我们可以使用 <code>__private_extern__</code>
方法属性来设置此位。</li>
<li><code>N_TYPE</code>（0x0E）：这些位定义了符号的类型。</li>
<li><code>N_EXT</code>（0x01）：如果设置了这 3
位，则表示该符号是一个外部符号，该符号可以在此文件外部定义，也可以在此文件中定义并可以被外部文件引用。</li>
</ul></li>
<li>上述提到的 <code>N_TYPE</code> 字段包含以下这些值：
<ul>
<li><code>N_UNDF</code>（0x0）：表示符号未定义。未定义符号是指在此模块中引用但是在其他模块中定义的符号。此时，<code>n_sect</code>
字段为 <code>NO_SECT</code>。</li>
<li><code>N_ABS</code>（0x2）：表示符号是绝对的。链接器不会修改绝对符号的值。此时，<code>n_sect</code>
字段为 <code>NO_SECT</code>。</li>
<li><code>N_SECT</code>（0xE）：表示符号定义在 <code>n_sect</code>
所指定的 section 中。</li>
<li><code>N_PBUD</code>（0xC）：表示符号未定义，并且镜像为该符号使用了一个预绑定的值。此时，<code>n_sect</code>
字段为 <code>NO_SECT</code>。</li>
<li><code>N_INDR</code>（0xA）：表示符号的定义与另一个符号相同。<code>n_value</code>
字段是一个指向字符串表的索引，用于指定另一个符号的名称。链接该符号时，此符号与另一个符号具有相同定义的类型和值。</li>
</ul></li>
</ul></li>
<li><code>n_sect</code>
<ul>
<li>表示 section 的编号，在对应 section
中可以找到该符号；如果该字段的值为
<code>NO_SECT</code>，则表示在该镜像中找不到该符号。section 在 segment
中是按顺序排列的，从 1 开始连续编号。</li>
</ul></li>
<li><code>n_desc</code>
<ul>
<li>一个 16 位的值，为非稳定符号提供关于该符号性质的附加信息。可以使用
<code>REFERENCE_TYPE</code>（0xF）掩码来访问其值。值的定义有以下这些：
<ul>
<li><code>REFERENCE_FLAG_UNDEFINED_NON_LAZY</code>（0x0）：表示该符号引用了外部非惰性（数据）符号。</li>
<li><code>REFERENCE_FLAG_UNDEFINED_LAZY</code>（0x1）：表示该符号引用了外部惰性符号。比如一个函数调用。</li>
<li><code>REFERENCE_FLAG_DEFINED</code>（0x2）：表示符号定义在本模块内。</li>
<li><code>REFERENCE_FLAG_PRIVATE_DEFINED</code>（0x3）：表示符号定义在本模块内，并且只对本共享库内的模块可见。</li>
<li><code>REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY</code>（0x4）：表示符号定义在了此文件中的其他模块内，是一个非惰性（数据）符号，并且只对本共享库内的模块可见。</li>
<li><code>REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY</code>（0x5）：表示符号定义在了此文件中的其他模块内，是一个惰性（函数）符号，并且只对本共享库内的模块可见。</li>
</ul></li>
<li>掩码以外的位的值的定义有以下这些：
<ul>
<li><code>REFERENCED_DYNAMICALLY</code>（0x10）：对于被动态加载器 API
（如：<code>dlsym</code>、<code>NSLookupSymbolInImage</code>）引用的已定义符号，或者该位必须被设置。<code>strip</code>
工具使用该位来避免删除必须存在的符号：如果符号设置了该位，则
<code>strip</code> 不会删除它。</li>
<li><code>N_DESC_DISCARDED</code>（0x20）：在一个完全链接的镜像中，动态链接器会在运行时用到该位。因此，不要在完全链接的图像中设置此位。</li>
<li><code>N_NO_DEAD_STRIP</code>（0x20）：当在一个可重定位目标文件（文件类型为
<code>MH_OBJECT</code>）中对一个已定义符号进行设置时，表示静态链接器用于不会对符号进行
dead-strip 处理。</li>
<li><code>N_WEAK_REF</code>（0x40）：表示此未定义符号是一个弱引用。如果动态链接器找不到该符号的定义，那么将会符号地址位置为
0。静态链接器在给定合适的弱链接标志的情况下会设置此符号。</li>
<li><code>N_WEAK_DEF</code>（0x80）：表示此符号是一个弱定义。如果静态链接器或动态链接器为该符号找到了另一个（非弱）定义，那么弱定义会被忽略。只有在已合并的
section 中的符号可以被标记为弱定义。</li>
</ul></li>
<li>如果文件是一个两级命名空间镜像（即，如果设置了
<code>mach_header</code> 的 <code>MH_TWOLEVEL</code> 标志位），那么
<code>n_desc</code> 的高 8 位则指向未定义符号的定义所位于的
library。使用 <code>GET_LIBRARY_ORDINAL 宏</code> 来读取此值，使用
<code>SET_LIBRARY_ORIDINAL</code> 宏来设置此值。0 表示指定当前镜像。1 到
253 则是根据此文件中的 <code>LC_LOAD_COMMAND</code> 加载命令的顺序指定
library 的编号。254
用于会被动态查找的未定义的符号。对于能够从可执行程序中加载符号的插件，会将其链接至
255，从而指定可执行镜像。对于扁平命名空间镜像，高 8 位必须为 0。</li>
</ul></li>
<li><code>n_value</code>
<ul>
<li>即符号的值。符号表表项的类型（<code>n_type</code>
字段指定）不同，那么值的形式也不同。对于 <code>N_SECT</code>
符号类型，<code>n_value</code> 是符号的地址。</li>
</ul></li>
</ul>
<p>公共符号必须是 <code>N_UNDF</code> 类型，并且必须设置
<code>N_EXT</code> 位。公共符号的 <code>n_value</code>
是符号的数据的大小（以字节为单位）。在 C
语言中，公共符号是在此文件中声明但未初始化的变量。公共符号只能出现在
<code>MH_OBJECT</code> 类型的 Mach-O 文件中。</p>
<h2 id="dysymtab_command">dysymtab_command</h2>
<p><code>dysymtab_command</code>
加载命令描述了用于动态链接的符号表的各部分的大小和位置。<code>dysymtab_command</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> cmd;	        <span class="comment">/* LC_DYSYMTAB */</span></span><br><span class="line">    <span class="type">uint32_t</span> cmdsize;	    <span class="comment">/* sizeof(struct dysymtab_command) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ilocalsym; 	<span class="comment">/* index to local symbols */</span></span><br><span class="line">    <span class="type">uint32_t</span> nlocalsym;	    <span class="comment">/* number of local symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> iextdefsym;    <span class="comment">/* index to externally defined symbols */</span></span><br><span class="line">    <span class="type">uint32_t</span> nextdefsym;    <span class="comment">/* number of externally defined symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> iundefsym;	    <span class="comment">/* index to undefined symbols */</span></span><br><span class="line">    <span class="type">uint32_t</span> nundefsym;	    <span class="comment">/* number of undefined symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> tocoff;	    <span class="comment">/* file offset to table of contents */</span></span><br><span class="line">    <span class="type">uint32_t</span> ntoc;	        <span class="comment">/* number of entries in table of contents */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> modtaboff;	    <span class="comment">/* file offset to module table */</span></span><br><span class="line">    <span class="type">uint32_t</span> nmodtab;	    <span class="comment">/* number of module table entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> extrefsymoff;	<span class="comment">/* offset to referenced symbol table */</span></span><br><span class="line">    <span class="type">uint32_t</span> nextrefsyms;	<span class="comment">/* number of referenced symbol table entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> indirectsymoff;<span class="comment">/* file offset to the indirect symbol table */</span></span><br><span class="line">    <span class="type">uint32_t</span> nindirectsyms; <span class="comment">/* number of indirect symbol table entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> extreloff;	    <span class="comment">/* offset to external relocation entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> nextrel;	    <span class="comment">/* number of external relocation entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> locreloff;	    <span class="comment">/* offset to local relocation entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> nlocrel;	    <span class="comment">/* number of local relocation entries */</span></span><br><span class="line">&#125;;	</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>ilocalsym</code>
<ul>
<li>指定本地符号组中第一个符号的索引。</li>
</ul></li>
<li><code>nlocalsym</code>
<ul>
<li>指定本地符号组中所有符号的数量。</li>
</ul></li>
<li><code>iextdefsym</code>
<ul>
<li>指定已定义的外部符号组中第一个符号的索引。</li>
</ul></li>
<li><code>nextdefsym</code>
<ul>
<li>指定已定义的外部符号组中所有符号的数量。</li>
</ul></li>
<li><code>iundefsym</code>
<ul>
<li>指定未定义的外部符号组中第一个符号的索引。</li>
</ul></li>
<li><code>nundefsym</code>
<ul>
<li>指定未定义的外部符号组中所有符号的数量。</li>
</ul></li>
<li><code>tocoff</code>
<ul>
<li>指定内容数据表在文件中的偏移。</li>
</ul></li>
<li><code>ntoc</code>
<ul>
<li>指定内容数据表的表项数量</li>
</ul></li>
<li><code>modtaboff</code>
<ul>
<li>指定模块表数据在文件中的偏移。</li>
</ul></li>
<li><code>nmodtab</code>
<ul>
<li>指定模块表的表项数量。</li>
</ul></li>
<li><code>extrefsymoff</code>
<ul>
<li>指定外部引用表数据在文件中的偏移。</li>
</ul></li>
<li><code>nextrefsyms</code>
<ul>
<li>指定外部引用表数据的表项数量。</li>
</ul></li>
<li><code>indirectsymoff</code>
<ul>
<li>指定间接符号表数据在文件中的偏移。</li>
</ul></li>
<li><code>nindirectsyms</code>
<ul>
<li>指定间接符号表的表项数量。</li>
</ul></li>
<li><code>extreloff</code>
<ul>
<li>指定外部重定位表数据在文件中的偏移。</li>
</ul></li>
<li><code>nextrel</code>
<ul>
<li>指定外部重定位表的表项数量。</li>
</ul></li>
<li><code>locrelloff</code>
<ul>
<li>指定本地重定位表数据在文件中的偏移。</li>
</ul></li>
<li><code>nlocrel</code>
<ul>
<li>指定本地重定位表的表项数量。</li>
</ul></li>
</ul>
<p><code>LC_DYSYMTAB</code>
加载命令包含符号表的一组索引和一组文件偏移量，这些文件偏移量定义了其他几个表的位置。文件中未使用的表的字段应设置为
0。</p>
<h3 id="dylib_table_of_contents">dylib_table_of_contents</h3>
<p><code>dylib_table_of_contents</code>
用于描述一个动态共享库内容表的表项。<code>dylib_table_of_contents</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_table_of_contents</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> symbol_index;	<span class="comment">/* the defined external symbol (index into the symbol table) */</span></span><br><span class="line">    <span class="type">uint32_t</span> module_index;	<span class="comment">/* index into the module table this symbol is defined in */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>symbol_index</code>
<ul>
<li>一个符号表表项的索引，该表项引用了这个已定义的外部符号。</li>
</ul></li>
<li><code>module_index</code>
<ul>
<li>一个模块表表项的索引，表示这个已定义的外部符号所在的模块。</li>
</ul></li>
</ul>
<h3 id="dylib_module">dylib_module</h3>
<p><code>dylib_module</code>
用于描述一个动态共享库的模块表表项。<code>dylib_module</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_module</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> module_name;	<span class="comment">/* the module name (index into string table) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> iextdefsym;	<span class="comment">/* index into externally defined symbols */</span></span><br><span class="line">    <span class="type">uint32_t</span> nextdefsym;	<span class="comment">/* number of externally defined symbols */</span></span><br><span class="line">    <span class="type">uint32_t</span> irefsym;		<span class="comment">/* index into reference symbol table */</span></span><br><span class="line">    <span class="type">uint32_t</span> nrefsym;		<span class="comment">/* number of reference symbol table entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> ilocalsym;		<span class="comment">/* index into symbols for local symbols */</span></span><br><span class="line">    <span class="type">uint32_t</span> nlocalsym;		<span class="comment">/* number of local symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> iextrel;		<span class="comment">/* index into external relocation entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> nextrel;		<span class="comment">/* number of external relocation entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> iinit_iterm;	<span class="comment">/* low 16 bits are the index into the init section, high 16 bits are the index into the term section */</span></span><br><span class="line">    <span class="type">uint32_t</span> ninit_nterm;	<span class="comment">/* low 16 bits are the number of init section entries, high 16 bits are the number of term section entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span>			    <span class="comment">/* for this module address of the start of */</span></span><br><span class="line">	objc_module_info_addr;  <span class="comment">/*  the (__OBJC,__module_info) section */</span></span><br><span class="line">    <span class="type">uint32_t</span>			    <span class="comment">/* for this module size of */</span></span><br><span class="line">	objc_module_info_size;	<span class="comment">/*  the (__OBJC,__module_info) section */</span></span><br><span class="line">&#125;;	</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>module_name</code>
<ul>
<li>一个字符串表的表项索引，该表项描述了这个模块的名称。</li>
</ul></li>
<li><code>iextdefsym</code>
<ul>
<li>表示该模块的第一个已定义外部符号在符号表中的索引。</li>
</ul></li>
<li><code>nextdefsym</code>
<ul>
<li>表示该模块的所有已定义外部符号的数量。</li>
</ul></li>
<li><code>irefsym</code>
<ul>
<li>表示该模块在外部引用表中的第一个表项的索引。</li>
</ul></li>
<li><code>nrefsym</code>
<ul>
<li>表示该模块在外部引用表中的占有表项的数量。</li>
</ul></li>
<li><code>ilocalsym</code>
<ul>
<li>表示该模块的第一个本地符号在符号表中的索引。</li>
</ul></li>
<li><code>nlocalsym</code>
<ul>
<li>表示该模块的所有本地符号的数量。</li>
</ul></li>
<li><code>iexterel</code>
<ul>
<li>表示该模块在外部重定位表中的第一个表项的索引。</li>
</ul></li>
<li><code>nextrel</code>
<ul>
<li>表示该模块在外部重定位表中占有表项的数量。</li>
</ul></li>
<li><code>iinit_iterm</code>
<ul>
<li>指定了模块构造 section 的索引（低 16 位）；指定了模块析构 section
的索引（高 16 位）。</li>
</ul></li>
<li><code>ninit_nterm</code>
<ul>
<li>指定了模块构造 section 中的指针数量（低 16 位）；指定了模块析构
section 中的指针数量（高 16 位）。</li>
</ul></li>
<li><code>objc_module_info_addr</code>
<ul>
<li>表该模块数据部分的起始静态链接地址，位于 <code>__module_info</code>
section <code>__OBJC</code> segment。</li>
</ul></li>
<li><code>objc_module_info_size</code>
<ul>
<li>表示 <code>__OBJC</code> segment 的 <code>__module_info</code>
section 使用该模块的数据的字节数。</li>
</ul></li>
</ul>
<h3 id="dylib_reference">dylib_reference</h3>
<p><code>dylib_reference</code>
为共享库中的模块提供的外部引用表项定义属性。<code>dylib_reference</code>
的数据结构定义如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_reference</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> isym:<span class="number">24</span>,	<span class="comment">/* index into the symbol table */</span></span><br><span class="line">    		  flags:<span class="number">8</span>;	<span class="comment">/* flags to indicate the type of reference */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>字段说明</strong></p>
<ul>
<li><code>isym</code>
<ul>
<li>表示被引用符号在符号表中的索引。</li>
</ul></li>
<li><code>flags</code>
<ul>
<li>用于表示引用的类型。</li>
</ul></li>
</ul>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://studfile.net/preview/2082911/">Mach-O_File_Format.pdf</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——Matrix-Code-Rain</title>
    <url>/2016/08/26/matrix-code-rain/</url>
    <content><![CDATA[<p>最近自己的博客刚刚建起来，想好好经营一下。内容比较少，另外希望能产出一些高质量的文章，所以不想将CSDN博客上的文章迁移过来。那么就得自己发点干货了。废话不多说，转入正题。</p>
<span id="more"></span>
<p>数个月前在github上阅读过一个小项目的源码——<a
href="https://github.com/neilcarpenter/Matrix-code-rain">Matrix-code-rain</a>。其效果是黑客帝国中代码在屏幕上从上至下滑落。<a
href="http://neilcarpenter.com/demos/canvas/matrix/">DEMO</a>见此链接。如下截图所示即代码雨效果图:
<img
src="http://images.chuquan.me/blog-images/matrix-code-rain.png?x-oss-process=image/resize,w_800"
alt="代码雨" /></p>
<p>首先观察效果图，大致分为三个部分:
左上角的<code>帧频监测模块</code>、左下角的<code>快照工具栏</code>、<code>代码雨</code>主体。</p>
<p>项目的index.html文件中的body部分包含了两个主要的元素:</p>
<ul>
<li>id="info"的div元素<br />
</li>
<li>id="canvas"的画布</li>
</ul>
<p>前者提供了<code>快照</code>功能，以旋转方式显示/隐藏的特效（该效果是以CSS3实现的）；后者实现了<code>帧频检测</code>功能以及主效果<code>代码雨</code>。</p>
<p>下面先把JS主干代码贴出，并做简要解读。</p>
<h1 id="主干代码">主干代码</h1>
<p>这里仅标出代码主干，具体细节请查看源码。代码的主干很简单，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stats = <span class="keyword">new</span> <span class="title class_">Stats</span>();</span><br><span class="line">stats.<span class="property">domElement</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">stats.<span class="property">domElement</span>.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&#x27;0px&#x27;</span>;</span><br><span class="line">stats.<span class="property">domElement</span>.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;0px&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>( stats.<span class="property">domElement</span> );</span><br><span class="line"><span class="keyword">var</span> M = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eventListenerz</span>(<span class="params"></span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	M.<span class="title function_">init</span>();</span><br><span class="line">	<span class="title function_">eventListenerz</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先简单分析一下主干代码，然后再分析具体细节:<br />
开头五行代码，引用了一个外部JS文件(stats.min.js)定义的一个构造函数<code>Stats()</code>，然后初始化一个对象，这个对象的功能就是<code>帧频检测</code>，最后把它放到左上角。<br />
接着初始化一个对象M，这个对象内部定义了很多属性和方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> M = &#123;</span><br><span class="line">	<span class="comment">// 属性</span></span><br><span class="line">	<span class="comment">// 关于每一栏canvas的属性设置</span></span><br><span class="line">	<span class="attr">setting</span>: &#123;</span><br><span class="line">		<span class="attr">COL_WIDTH</span>: <span class="number">15</span>,	<span class="comment">// 每一栏的宽度</span></span><br><span class="line">		<span class="attr">COL_HEIGHT</span>: <span class="number">25</span>, <span class="comment">// 每一栏的高度</span></span><br><span class="line">		<span class="attr">VELOCITY_PARAMS</span>: &#123;</span><br><span class="line">			<span class="attr">min</span>: <span class="number">4</span>, <span class="comment">// 代码雨的最小速度</span></span><br><span class="line">			<span class="attr">max</span>: <span class="number">8</span>	<span class="comment">// 代码雨的最大速度</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">CODE_LENGTH_PARAMS</span>: &#123;</span><br><span class="line">			<span class="attr">min</span>: <span class="number">20</span>,<span class="comment">// 代码雨的最小长度</span></span><br><span class="line">			<span class="attr">max</span>: <span class="number">40</span>	<span class="comment">// 代码雨的最大长度</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">animation</span>: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">c</span>: <span class="literal">null</span>,</span><br><span class="line">	<span class="attr">ctx</span>: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">lineC</span>: <span class="literal">null</span>,</span><br><span class="line">	<span class="attr">ctx2</span>: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">video</span>: <span class="literal">null</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">WIDTH</span>: <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">	<span class="attr">HEIGHT</span>: <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="attr">COLUMNS</span>: <span class="literal">null</span>,	<span class="comment">// canvas列数</span></span><br><span class="line">	<span class="attr">canvii</span>: [],</span><br><span class="line">	<span class="attr">font</span>: <span class="string">&#x27;30px matrix-code&#x27;</span>,</span><br><span class="line">	<span class="attr">letters</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, ...],</span><br><span class="line">	</span><br><span class="line">	<span class="attr">codes</span>: [],</span><br><span class="line">	</span><br><span class="line">	<span class="attr">createCodeLoop</span>: <span class="literal">null</span>,</span><br><span class="line">	<span class="attr">codesCounter</span>: <span class="number">0</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 方法  </span></span><br><span class="line">	<span class="title function_">init</span>(),  </span><br><span class="line">	<span class="title function_">loop</span>(),  </span><br><span class="line">	<span class="title function_">draw</span>(),  </span><br><span class="line">	<span class="title function_">createCode</span>(),  </span><br><span class="line">	<span class="title function_">createCanvii</span>(),  </span><br><span class="line">	<span class="title function_">createLines</span>(),  </span><br><span class="line">	<span class="title function_">assignColumn</span>(),  </span><br><span class="line">	<span class="title function_">randomFromInterval</span>(),</span><br><span class="line">	<span class="title function_">snapshot</span>()  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后定义一个添加事件监听的函数<code>eventListenerz</code>。</p>
<p>当页面加载后执行如下代码:<br />
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = &#123;</span><br><span class="line">	M.<span class="title function_">init</span>();	<span class="comment">// 初始化M</span></span><br><span class="line">	<span class="title function_">eventListenerz</span>();	<span class="comment">//添加事件监听</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <code>M.init()</code>做了以下这些事:</p>
<ol type="1">
<li>将canvas元素赋值给M.c；</li>
<li>获取画布上的绘图环境，并赋值给M.ctx（后面称之为<code>画布</code>）；</li>
<li>获取页面的高度、宽度并设置画布的高度和宽度，让画布充满整个页面；</li>
<li>设置画布背景色为黑色；</li>
<li>设置画布的字体为<code>30px matrix-code</code>；</li>
<li>创造屏幕质感，画一条条的横线。这里动态创建了一个canvas元素，并设置画布的宽高与页面一致，通过调用<code>M.createLines()</code>方法来绘制满屏的横线，其实为了效果更好每条横线下面紧挨一条颜色更淡的横线，达到色差缓冲的效果；<br />
</li>
<li>根据网页的宽度、预设的canvas宽度，计算网页横向能放多少个canvas；</li>
<li>针对每一栏canvas初始化一个codes数组，数组的0索引的值是一个对象:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">&#x27;open&#x27;</span>: <span class="literal">true</span>, </span><br><span class="line">	<span class="string">&#x27;position&#x27;</span>: &#123;<span class="string">&#x27;x&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0</span>&#125;,</span><br><span class="line">	<span class="string">&#x27;strength&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="9" type="1">
<li>调用<code>M.loop()</code>方法，该方法内部调用了<code>requestAnimationFrame</code>，并把其任务ID赋值给<code>M.animation</code>。然后是loop方法的主体，调用<code>M.draw()</code>——想必就是绘制代码雨的效果。此外，同时更新<code>帧频检测器</code>的数据状态，达到循环动画的效果。</li>
<li>调用<code>M.createCode()</code>方法，该方法什么作用？请继续往下阅读。</li>
</ol>
<p>这时候，代码的大体流程已经知道了，我们只要了解<code>M.draw()</code>是如何绘制代码雨，以及<code>M.createCode()</code>是如何初始化的即可。</p>
<h1 id="代码雨">代码雨</h1>
<p>先来看我绘制的一张图，改图简要的介绍了代码雨的组成，在看具体分析之前大家可以先自己想想其实现方式。</p>
<figure>
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/matrix-code-rain.png?x-oss-process=image/resize,w_800"
alt="代码雨原理图" />
<figcaption aria-hidden="true">代码雨原理图</figcaption>
</figure>
<p>要了解代码雨原理，首先了解<code>M.draw()</code>是如何工作的。</p>
<h2 id="m.draw">M.draw()</h2>
<p><code>M.draw()</code>做了以下工作:</p>
<ol type="1">
<li>清理画布，避免之前绘制的图像遗留在画布上产生重影；</li>
<li>设置如何将新图像绘制到已有图像之上，默认为<code>source-over</code>；</li>
<li>对每一canvas进行处理。<br />
1).
当其codes[0]包含canvas属性时，获取其速度值、canvas的高度，x、y坐标，canvas元素，canvas画布。然后根据其位置将这个canvas添加到主canvas上。<br />
a.
当y坐标小于网页高度时（即canvas的y坐标还在网页范围内），更新y坐标(y减去速度值)；
b. 否则，将y坐标设为0，这就达到了同一列不停的循环的效果。</li>
</ol>
<p>看到第3步，对比<strong>代码主干</strong>一节中第8步，我们发现：<code>M.draw()</code>阶段时每一栏的canvas的codes数组根本没有canvas属性。这种情况下，第3步中的处理条件根本无法达到。所以肯定缺少初始化的一步，这肯定包含在<code>M.createCode()</code>中，其实看方法名也能看出来。</p>
<h2 id="m.createcode">M.createCode()</h2>
<p><code>M.createCode()</code>做了以下工作:</p>
<ol type="1">
<li>判断<code>M.codesCounter</code>是否大于canvas列数。如果是，清除M.createCodeLoop的定时任务，并返回。否则，继续往下执行。推断一下：毕竟网页横向被分解成了很多个canvas，有多少个canvas，<code>M.createCode()</code>就会被调用多少次吧。<br />
</li>
<li>给局部变量randomInterval赋值为<code>M.randomFromInterval(0,100)</code>的执行结果。直接跳到这段代码看看，哦，生成一个0到100之间的随机数。<br />
</li>
<li>给局部变量colum赋值为<code>M.assignColumn()</code>的执行结果。直接跳到这段代码看看：随机获取一个canvas的索引，如果该canvas的codes[0]的open属性为true，则置为false，并返回canvas的索引；否则直接返回false。仔细想想，这段代码把open置为false后，并没有还原成true。<br />
</li>
<li>根据column索引值，对对应一列的canvas进行处理。
<ol type="1">
<li>随机获取一个代码雨长度值，并赋值给codeLength；</li>
<li>随机获取一个代码雨速度值，并赋值给codeVelocity；</li>
<li>获取代码雨字符表的长度，并赋值给lettersLength；</li>
<li>设置该canvas的codes[0].position属性，起始的x坐标与列索引有关，y坐标都为0；</li>
<li>设置该canvas的codes[0].velocity属性，为随机获取的速度值；</li>
<li>设置该canvas的codes[0].strength属性，为其速度/速度上限值，这个到底什么作用呢？先放着继续往下看；</li>
<li>根据代码雨长度值，获取相应数量的字符，这是通过在字符表中随机获取的，并将字符依次赋值给该canvas的codes[1],
codes[2]...</li>
<li>调用<code>M.createCanvii(column)</code>。这里把canvas的列索引值传递进去了，想必就是进行绘制操作了。</li>
<li><code>M.codesCount</code>++，这一步验证了第1步的猜想。</li>
</ol></li>
<li>根据局部变量randomInterval来设置另一列canvas的初始化。</li>
</ol>
<h2 id="m.createcanvii">M.createCanvii()</h2>
<p>上面一节第8步对<code>M.createCanvii(col)</code>的作用进行了猜想，下面我们来看看是不是符合我们的猜想。
<code>M.createCanvii(col)</code>做了以下工作:</p>
<ol type="1">
<li>获取该列canvas要显示的字符数，赋值给codeLen；</li>
<li>获取该列canvas的高度，通过字符数*每个字符的高度即可得到；</li>
<li>获取该列canvas的速度，通过codes[0].velocity即可得到；</li>
<li>获取该列canvas的strength，此时我们还是不知道这是个什么参数；</li>
<li>创建一个canvas元素，并获取其画布环境，并设置其宽度和高度；</li>
<li>根据codeLen，绘制所有字符，这里并不是单纯的绘制。前5个和最后4个不太一样，哪里不一样呢？之前不明白其含义的strength出现了，原来是为了让两端的颜色变淡一些。</li>
<li>绘制完毕后，将该列canvas的codes[0].canvas的值赋为这里绘创建的canvas元素。哦，这时候，<strong>M.draw()</strong>一节的第3步的条件就成立了，就可以把这个创建的canvas添加到网页的主canvas了。</li>
</ol>
<p>现在一切就明了了，接下来有兴趣的话可以看看<code>快照工具栏</code>的效果实现。</p>
<h1 id="快照工具栏">快照工具栏</h1>
<p>先来看看CSS3提供的几个动画方法和特性:</p>
<p><strong>transform</strong>: <em>none | transform-functions</em><br />
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">matrix</span>():		<span class="comment">/*定义转换*/</span>  </span><br><span class="line"><span class="title function_">translate</span>():	<span class="comment">/*原点坐标偏移*/</span></span><br><span class="line"><span class="title function_">scale</span>():		<span class="comment">/*缩放*/</span>  </span><br><span class="line"><span class="title function_">rotate</span>():		<span class="comment">/*沿轴旋转*/</span>   </span><br><span class="line"><span class="title function_">skew</span>():		<span class="comment">/*沿轴倾斜*/</span>   </span><br><span class="line"><span class="title function_">perspective</span>():	<span class="comment">/*定义透视*/</span>  </span><br></pre></td></tr></table></figure></p>
<p><strong>transition</strong>: <em>property duration timing-function
delay</em><br />
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: none|all|property;  </span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="built_in">time</span>(s/ms);  </span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear|ease|ease-in|ease-out|ease-in-out|<span class="built_in">cubic-bezier</span>(n,n,n)   </span><br></pre></td></tr></table></figure>
transform属性的是transform-function，上述只列出了6类方法，每一类方法对应还有针对2D,
3D的方法。</p>
<p>很明显，快照工具栏的旋转显示/隐藏方式是以<code>tramsform</code>分别对<code>显示时定义一个状态</code>，<code>隐藏时定义一个状态</code>，然后通过CSS3的<code>transition</code>属性来进行状态切换设置。</p>
<p>果然代码中也是以这种方式实现的:</p>
<h2 id="显示状态">显示状态</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: bottom center;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line"><span class="attribute">transition</span>: transform <span class="number">1s</span> ease-in-out;</span><br></pre></td></tr></table></figure>
<h2 id="隐藏状态">隐藏状态</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br></pre></td></tr></table></figure>
<h2 id="状态转移方式">状态转移方式</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: transform <span class="number">1s</span> ease-in-out;  </span><br></pre></td></tr></table></figure>
<p>两个状态、转移方式都定义好了，那么就可以通过事件了切换这两者的状态了。用toggle的方法来添加/删除类来达到状态切换的效果。果然，JS代码中有一个函数<code>eventListenerz()</code>就包含了状态切换的处理。<br />
此外，快照工具栏还有一个主要功能:
快照。还是在上面那个函数里面，包含了这两行代码:<br />
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> snapshotBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;snapshot&#x27;</span>);</span><br><span class="line">snapshotBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, M.<span class="property">snapshot</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
第一行代码获取了<code>快照</code>按钮的buttn元素；第二行代码则是对该按钮添加了一个click事件监听以及相应的回调函数。<br />
<code>M.snapshot</code>是其内部定义的一个方法。其源码如下:<br />
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">snapshot</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	M.<span class="title function_">createLines</span>(M.<span class="property">ctx</span>);</span><br><span class="line">	<span class="variable language_">window</span>.<span class="title function_">open</span>(M.<span class="property">c</span>.<span class="title function_">toDataURL</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
M.c为页面的主canvas，对其调用<code>toDataURL()</code>方法，该方法将canvas进行转化成一个特定格式的图片（默认PNG），并返回一个data
URI。最后新开一个窗口显示该图片。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Matrix-Code-Rain</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC、MVP、MVVM的演化</title>
    <url>/2018/04/11/mvc-mvp-mvvm/</url>
    <content><![CDATA[<p>在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。</p>
<span id="more"></span>
<h1 id="mvc">MVC</h1>
<h2 id="基本mvc模式">基本MVC模式</h2>
<p>如下图所示为基本的MVC（Model-View-Controller）模式结构图，可分为三部分：模型（Model）、视图（View）、控制器（Controller）。其在MVC模式中所扮演的角色分别为：</p>
<ol type="1">
<li>Model：模型管理应用程序的数据，响应有关其状态信息（通常来自View）的请求，并响应指令以更改状态（通常来自Controller）。</li>
<li>View：视图管理数据的展示。</li>
<li>Controller：控制器解释用户的输入，并通知模型、视图进行状态更新。</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/basic-MVC.png" /></p>
<p>其中，View和Controller依赖于Model，而Model并不依赖于View和Controller。这种设计模式的优点在于允许Model不受View的影响，从而能够进行独立的构建和测试。</p>
<p>此外，根据Model的具体实现还可以进一步分为：<strong>主动型Model</strong>、<strong>被动型Model</strong>。</p>
<h3 id="被动型model-mvc模式">被动型Model MVC模式</h3>
<p>当只有一个Controller操控着Model时可以采用<strong>被动型Model</strong>。Controller定义Model，并在Model发生改变时通知View，后者再进行更新。在这种场景下，Model完全独立于View和Controller。实际上，被动型Model
MVC模式就是基本的MVC模式。</p>
<h3 id="主动型model-mvc模式">主动型Model MVC模式</h3>
<p>当Model的状态未受Controller干扰的情况下发生变化时，使用<strong>主动型Model</strong>。当其他来源正在更改数据并且必须立刻反应到View中时，可能会发生这种情况。</p>
<p>为了实现主动型Model，通常使用Observer模式来提供了一种机制来提醒其他对象的状态变化，避免引入依赖关系。各个View实现Observer接口并向Model注册。当Model发生变化时，Model会遍历所有注册的观察者并通知他们相关的变化。这种方法通常被称为“发布
-
订阅”。Model从不需要关于任何View的任何信息。事实上，在Controller需要被告知Model变化的情况下（例如，启用或禁用菜单选项），所有Controller必须通过实现Observer接口并订阅Model的变化。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/active-model-MVC.png" /></p>
<h2 id="传统版mvc">传统版MVC</h2>
<p>上述主动型Model
MVC模式通过加入Observer模式进行了改良。事实上，随着业务需求的变化，MVC模式通过不断加入一些更基本的设计模式采演化成现在经典的MVC模式。这些基本模式协同工作，定义了MVC应用程序特有的功能分离和通信路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/traditional-MVC.png" /></p>
<p>上图所示为传统MVC设计模式，其通过Composition、Strategy、Observer等基本设计模式协同工作以实现。用户操作在复合结构的某个层次上操作View，生成一个事件。Controller接收事件，并进行解释。这个过程使用Strategy模式实现，可以是通过消息请求一个Model对象来更新其状态或请求一个View对象来更新其行为或外观。Model对象则在其状态改变时通知所有已注册为观察者的对象。如果观察者是对象，则可以相应更新其外观。</p>
<h2 id="苹果版mvc">苹果版MVC</h2>
<p>苹果认为传统的MVC模式中，View通过Observer模式直接观察Model对象以获取相关的通知，而这样的设计会导致View和Model对象不能被广泛复用，因为View与其观察的Model之间存在耦合关系。因此，苹果版MVC与传统MVC基本一致，只是隔离了View和Model。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/apple-MVC.png" /></p>
<p>在iOS中，UIViewController和UIView是一一对应的。随着业务的深入，MVC最终一点点变成了<strong>Massive-View-Controller</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVC.png" /></p>
<h1 id="mvp">MVP</h1>
<p>MVP（Modell-View-Presenter）模式就是为了解决MVC中Controller越来越臃肿的问题，进一步明确代码分工。MVP与苹果版MVC非常相似，但是它们的从属关系有所不同（实线表示持有）。如下图所示，MVP模式中View持有Presenter，Presenter持有Model，View不能直接访问Model；而MVC模式中Controller持有View和Model。</p>
<p>通过修改从属关系，可以真正意义上实现将UI逻辑和数据逻辑隔离，而隔离之后就可以方便地对数据逻辑部分进行单元测试。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVP.png" /></p>
<p>在iOS中，MVP的实现一般如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVP.png" /></p>
<h1 id="mvvm">MVVM</h1>
<p>MVVM（Model View
View-Model）就是为了解决MVP中Presenter过于臃肿的问题。MVVM的思想是将Controller中UI控制逻辑与业务逻辑进行分离，并抽离出一个View-Model来完成UI控制的逻辑。而Controller只需要负责业务逻辑即可。如下图便是MVVM的结构图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVVM.png" /></p>
<p>通常，View-Model可以调用Model定义的方法，从Model中获取数据以用于View，并对数据进行预处理，使View可以直接使用。View又可以向View-Model发出用户的操作命令，从而更改Model。MVVM实现了一种双向绑定机制。</p>
<p>在iOS中，MVVM的实现一般如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVVM.png" /></p>
<p>MVVM的优点在于：降低了View和Model之间的耦合；分离了业务逻辑和视图逻辑。缺点在于：View和Model双向绑定导致bug难以定位，两者中的任何一方出现问题，另一方也会出现问题；增加了胶水代码。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://msdn.microsoft.com/en-us/library/ff649643.aspx">Model-View-Controller</a></li>
<li><a
href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html">Concepts
in Objective-C Programming</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx">The
MVVM Pattern</a></li>
<li><a href="https://www.jianshu.com/p/caaa173071f3">iOS
关于MVC和MVVM设计模式的那些事</a></li>
<li><a
href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC,
MVP和MVVM</a></li>
<li><a
href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm">被误解的MVC和被神化的MVVM</a></li>
<li><a
href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html">iOS使用RAC实现MVVM的正经姿势</a></li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>我的独立产品集</title>
    <url>/2024/01/18/my-indie-hacker-products/</url>
    <content><![CDATA[<p>本文罗列了一些我业余时间开发的独立产品，如果我写的博客对你有些许帮助，那我也诚邀你下载体验一下我开发的独立产品。当然，如果能够针对产品提出一些建议或给个好评，那真的不胜感激！这也会是我继续完善产品的动力！</p>
<span id="more"></span>
<h1 id="macos-应用">MacOS 应用</h1>
<h2 id="莫负休息">莫负休息</h2>
<p>莫负休息（Morph Rest）是一款 MacOS
休息提醒应用程序。通过定时休息，可以预防视力疲劳、腰间盘突出、颈椎疼痛等职业病，当然也可以辅助提醒喝水，避免尿酸过高，引发肾结石、痛风等疾病。</p>
<p>莫负休息的主要特性：</p>
<ul>
<li>最低支持 MacOS 10.15 系统</li>
<li>支持浅色模式、深色模式</li>
<li>支持简体中文、繁体中文、英语、日语、韩语等多种语言</li>
<li>支持用户自定义工作、休息间隔</li>
<li>提供多种主题用于在休息期间展示</li>
</ul>
<p>下载地址——<a
href="https://apps.apple.com/cn/app/%E8%8E%AB%E8%B4%9F%E4%BC%91%E6%81%AF-%E4%BC%91%E6%81%AF%E6%8F%90%E9%86%92/id6474056217?mt=12">传送门</a></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-rest/0.9.0-common-market.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="莫负时钟">莫负时钟</h2>
<p>莫负时钟（Morph Clock）是一款 MacOS
屏幕保护程序。它采用了一种你从未见过的动态时钟效果，让你的 Mac
成为办公室中最靓的仔~</p>
<p>莫负时钟的主要特性：</p>
<ul>
<li>最低支持 MacOS 10.14 系统。</li>
<li>动态渐变背景色，无时无刻都在变换颜色。</li>
</ul>
<p>下载地址——<a
href="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-clock/MorphClock.saver.zip">传送门</a></p>
<div data-align="center">
<video src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-clock/MorphClock.mov" type="video/mp4" controls="controls" width="60%" height="60%">
</video>
</div>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Indie Hacker</tag>
      </tags>
  </entry>
  <entry>
    <title>【我的绘画作品】</title>
    <url>/2016/08/29/my-paintings/</url>
    <content><![CDATA[<p>小时候，我的梦想是成为一个画家。在幼儿园之前，曾经有机会接触绘画教育，很遗憾却因为一些小意外而错失了。不过，这并不能阻止我热爱绘画。<br />
我的画作其实并不多，现在一年能画一幅已然是奢侈。用一篇持续更新的博文来展示我的画作其实也足够了。</p>
<span id="more"></span>
<h1 id="section">2016</h1>
<h2 id="月">2月</h2>
<p>和bluestory风格类似，不过符合我的口味。 <img
src="http://images.chuquan.me/blog-images/bluestory01.jpeg?x-oss-process=image/resize,w_600"
alt="bluestory01" /></p>
<figure>
<img
src="http://images.chuquan.me/blog-images/bluestory02.jpeg?x-oss-process=image/resize,w_800"
alt="bluestory01" />
<figcaption aria-hidden="true">bluestory01</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/bluestory03.jpeg?x-oss-process=image/resize,w_800"
alt="bluestory01" />
<figcaption aria-hidden="true">bluestory01</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/bluestory04.jpeg?x-oss-process=image/resize,w_800"
alt="bluestory01" />
<figcaption aria-hidden="true">bluestory01</figcaption>
</figure>
<h1 id="section-1">2015</h1>
<h2 id="月-1">2月</h2>
<p>非常喜欢DJ Okawarri的flowerdance专辑以及专辑封面。 <img
src="http://images.chuquan.me/blog-images/flowerdance01.png?x-oss-process=image/resize,w_600"
alt="flowerdance01" /></p>
<figure>
<img
src="http://images.chuquan.me/blog-images/flowerdance02.png?x-oss-process=image/resize,w_600"
alt="flowerdance01" />
<figcaption aria-hidden="true">flowerdance01</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/flowerdance03.jpeg?x-oss-process=image/resize,w_800"
alt="flowerdance01" />
<figcaption aria-hidden="true">flowerdance01</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/flowerdance04.jpeg?x-oss-process=image/resize,w_800"
alt="flowerdance01" />
<figcaption aria-hidden="true">flowerdance01</figcaption>
</figure>
<h1 id="section-2">2014</h1>
<h2 id="月-2">2月</h2>
<p>百无聊赖。 <img
src="http://images.chuquan.me/blog-images/slam01.png?x-oss-process=image/resize,w_600"
alt="slam01" /></p>
<figure>
<img
src="http://images.chuquan.me/blog-images/slam02.png?x-oss-process=image/resize,w_600"
alt="slam02" />
<figcaption aria-hidden="true">slam02</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/slam03.png?x-oss-process=image/resize,w_600"
alt="slam03" />
<figcaption aria-hidden="true">slam03</figcaption>
</figure>
<h2 id="月-3">1月</h2>
<p>想画画，但不知道画什么，突然想到好友喜欢海贼王，那就来个路飞吧。 <img
src="http://images.chuquan.me/blog-images/lufei01.png?x-oss-process=image/resize,w_600"
alt="lufei01" /></p>
<figure>
<img
src="http://images.chuquan.me/blog-images/lufei03.png?x-oss-process=image/resize,w_600"
alt="lufei03" />
<figcaption aria-hidden="true">lufei03</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/lufei02.png?x-oss-process=image/resize,w_800"
alt="lufei02" />
<figcaption aria-hidden="true">lufei02</figcaption>
</figure>
<h1 id="section-3">2013</h1>
<p>一天时间重新回味了一遍《变形金刚》三部曲，心血来潮的作品。 <img
src="http://images.chuquan.me/blog-images/transformer01.png?x-oss-process=image/resize,w_600"
alt="transformer01" /></p>
<figure>
<img
src="http://images.chuquan.me/blog-images/transformer02.png?x-oss-process=image/resize,w_600"
alt="transformer01" />
<figcaption aria-hidden="true">transformer01</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/transformer03.png?x-oss-process=image/resize,w_600"
alt="transformer01" />
<figcaption aria-hidden="true">transformer01</figcaption>
</figure>
<figure>
<img
src="http://images.chuquan.me/blog-images/transformer04.png?x-oss-process=image/resize,w_600"
alt="transformer01" />
<figcaption aria-hidden="true">transformer01</figcaption>
</figure>
<p><strong>（未完待续）</strong></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>绘画</tag>
        <tag>手绘</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎关注我的 Twitter 账号！</title>
    <url>/2024/05/16/my-twitter-account/</url>
    <content><![CDATA[<p>最近在思考一个问题：如何打造个人品牌？思来想去，我觉得要做到以下几点：</p>
<ul>
<li>确定目标受众</li>
<li>培养专业能力</li>
<li>维持社交媒体</li>
<li>建立人脉关系</li>
</ul>
<span id="more"></span>
<p>一直以来，我并没有主动意识到要去打造个人品牌，也白白浪费了写博客的这几年。另一方面，我使用的社交媒体较少，仅限于微信、微博。而其中的朋友和粉丝基本上都是同事、同学、亲戚、朋友。在这样的熟人关系中经常发表一些日常的想法和看法，显然不太合适。从产品的角度解释就是目标人群定位不准确，所以很少更新社交媒体。</p>
<p>后续，我准备长期维持一个 Twitter
账号，发表一些日常的想法和看法。欢迎各位朋友关注 <a
href="https://twitter.com/Baochuquan">Bao
Chuquan</a>，你们的支持是我创作的动力！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Twitter</tag>
      </tags>
  </entry>
  <entry>
    <title>Myers 差分算法</title>
    <url>/2023/09/13/myers-difference-algorithm/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>差分算法（Difference
Algorithm）是一种数值计算方法，其主要用于解决两个数据集之间的差异问题，通过计算两个数据集之间的差异，取代对整个数据集的处理。</p>
<p>差分算法的应用非常广泛，主要有以下这些应用领域：</p>
<ul>
<li><strong>数据压缩</strong>：差分算法可以用来检测和删除冗余数据，从而实现数据的压缩。比如，对于一段音频数据，如果相邻的数据点之间的值几乎没有变化，那么就可以用差分值来代替原始数据，从而大大减小数据的大小。</li>
<li><strong>版本控制</strong>：差分算法可以用来比较不同版本的源代码，以便开发者能够知道哪些部分被修改了。比如：git、svn
等版本控制工具。</li>
<li><strong>UI
框架</strong>：差分算法可以用来比较两个状态的界面树，并找到最少的更新操作，从而高性能刷新界面。比如：SwiftUI、IGList、React、Flutter
等 UI 框架。</li>
</ul>
<p>本文，我们将深入探讨广泛应用在各种版本控制工具中的差分算法——Myers
差分算法。</p>
<h1 id="最长公共子序列">最长公共子序列</h1>
<p>在介绍 Myers 算法之前，我们先来了解一下著名的
<strong>最长公共子序列（Longest Common Subsequence，LCS）</strong>
问题。我们引用一下 LeetCode 中的问题描述，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给定两个字符串 text1 和 text2，返回这两个字符串的最长「公共子序列」的长度。如果不存在「公共子序列」，则返回 0 。</span><br><span class="line"> </span><br><span class="line">一个字符串的「子序列」是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span><br><span class="line"></span><br><span class="line">例如，<span class="string">&quot;ace&quot;</span> 是 <span class="string">&quot;abcde&quot;</span> 的子序列，但 <span class="string">&quot;aec&quot;</span> 不是 <span class="string">&quot;abcde&quot;</span> 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">&gt; 输入：text1 = <span class="string">&quot;CBABAC&quot;</span>, text2 = <span class="string">&quot;ABCABBA&quot;</span> </span><br><span class="line">&gt; 输出：4  </span><br><span class="line">&gt; 解释：最长公共子序列是 <span class="string">&quot;BABA&quot;</span> 或 <span class="string">&quot;CABA&quot;</span> 或 <span class="string">&quot;CBBA&quot;</span> ，它的长度为 4 。</span><br></pre></td></tr></table></figure>
<p>对于 LCS 问题，经典思路是使用动态规划来解决。动态规划的核心思想是
<strong>将一个大问题拆分成多个子问题，分别求解各个子问题，基于各个子问题的解推断出大问题的解</strong>。与分治、递归相比，动态规划会记录各个子问题的解，避免重复运算，以空间换时间，从而实现对时间复杂度的优化。下面，我们来介绍一下
LCS 的动态规划解法。</p>
<p>假设字符串 <span class="math inline">\(text1\)</span> 和
<code>text2</code> 的长度分别为 <code>m</code> 和
<code>n</code>，对此创建一个 <code>m+1</code> 行 <code>n+1</code>
列的二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示
<code>text1[0:i]</code> 和 <code>text2[0:j]</code>
的最长公共子序列的长度。</p>
<blockquote>
<p>上述表示中，<code>text1[0:i]</code> 表示 <code>text1</code> 的长度为
<code>i</code> 的前缀，<code>text2[0:j]</code> 表示 <code>text2</code>
的长度为 <code>j</code> 的前缀。</p>
</blockquote>
<p>考虑动态规划的边界情况：</p>
<ul>
<li>当 <code>i = 0</code> 时，<code>text1[0:i]</code>
为空，空字符串和任何字符串的最长公共子序列的长度都是
<code>0</code>，因此对任意 <code>0 ≤ j ≤ n</code>，有
<code>dp[0][j] = 0</code>；</li>
<li>当 <code>j = 0</code> 时，<code>text2[0:j]</code>
为空，同理可得，对任意 <code>0 ≤ i ≤ m</code>，有
<code>dp[i][0] = 0</code>。</li>
</ul>
<p>因此动态规划的边界情况是：当 <code>i = 0</code> 或 <code>j = 0</code>
时，<code>dp[i][j] = 0</code>。</p>
<p>当 <code>i &gt; 0</code> 且 <code>j &gt; 0</code> 时，考虑
<code>dp[i][j]</code> 的计算：</p>
<ul>
<li>当 <code>text1[i-1] = text2[j-1]</code>
时，将这两个相同的字符称为公共字符，考虑 <code>text1[0:i-1]</code> 和
<code>text2[0:j-1]</code> 的最长公共子序列，再增加一个公共字符即可得到
<code>text1[0:i]</code> 和 <code>text2[0:j]</code>
的最长公共子序列，因此 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li>
<li>当 <code>text1[i-1] != text2[j-1]</code> 时，考虑一下两种情况：
<ul>
<li>情况一：<code>text1[0:i-1]</code> 和 <code>text2[0:j]</code>
的最长公共子序列</li>
<li>情况二：<code>text1[0:i]</code> 和 <code>text2[0:j-1]</code>
的最长公共子序列</li>
<li>对此，计算 <code>text1[0:i]</code> 和 <code>text2[0:j]</code>
的最长公共子序列，应取两项中长度较大的一项，因此
<code>dp[i][j] = max(dp[i-1]][j], dp[i][j-1])</code>。</li>
</ul></li>
</ul>
<p>最终得到如下所示的状态转移方程：</p>
<p><span class="math display">\[
dp[i][j] =
\begin{cases}
dp[i-1][j-1] + 1, &amp; \text{text1[i-1] = text2[j-1]}  \\
max(dp[i-1][j], dp[i][j-1]), &amp; \text{text1[i-1]$\neq$text2[j-1]}
\end{cases}
\]</span></p>
<p>根据状态转移方程，我们可以得到如下代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图所示为二维数组 <code>dp[i][j]</code>
的存储内容，大问题的解由子问题的解推导而出，数组整体从左到右，从上到下推导构建。我们在图中使用黄色标识了
<code>text1[i-1] == text2[j-1]</code>
的情况。此时将从左上角相邻的位置取值并加
1；否则，取左边或上边的相邻值中的最大值。整个二维数组中保存的最大值就是
LCS 问题的解。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-02.png?x-oss-process=image/resize,w_800" /></p>
<p>至此我们计算得到了最长公共子序列的长度，然而在实际情况中，我们倾向于得到最长公共子序列本身。此时，可以借助我们构建的二维数组进行回溯。</p>
<p>回溯的方法是：从二维数组的右下角向左上角遍历，当
<code>i = m+1</code>，<code>j = n+1</code> 时可能会遇到三种情况：</p>
<ul>
<li>如果 <code>text1[i] = text2[j]</code>，那么向左上角遍历。</li>
<li>如果 <code>text1[i] != text2[j]</code>，判断 <code>dp[i][j]</code>
和 <code>dp[i-1][j]</code> 的值。
<ul>
<li>如果 <code>dp[i][j] = dp[i-1][j]</code>，则向上遍历；</li>
<li>否则，向左遍历。</li>
</ul></li>
</ul>
<p>由此，我们可以得到如下的遍历路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-03.png?x-oss-process=image/resize,w_800" /></p>
<p>在回溯得到遍历路径之后，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列
<code>CABA</code>，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-05.png?x-oss-process=image/resize,w_800" /></p>
<p>当然，细心的同学可能会对上述的回溯方法产生疑问：为什么
<code>dp[i][j] = dp[i-1][j]</code>
时向上遍历，而非向左遍历？事实上，如果我们也可以修改回溯方法，得到如下的遍历路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-04.png?x-oss-process=image/resize,w_800" /></p>
<p>同样，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列
<code>BABA</code>，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-06.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="最小编辑距离">最小编辑距离</h1>
<p>事实上，在特定设定下，最长公共子序列问题可以等价为
<strong>最小编辑距离（Minimum Edit Distance，也称 Levenshtein）</strong>
问题。</p>
<p>具体设定为：在最小编辑距离问题中，如果编辑操作只有
<strong>删除</strong> 和 <strong>插入</strong>，没有
<strong>替换</strong> 操作，且每个操作的代价是 1，那么从字符串 A
转换成字符串 B 的最小编辑距离就可以转换成如下公式。</p>
<p><span class="math display">\[
med(A, B) = length(A) + length(B) - 2 * lcs(A, B)
\]</span></p>
<p>以上述 <code>text1 = CBABAC</code>，<code>text2 = ABCABBA</code>
为例，寻找最长公共子序列问题，我们可以视为将 <code>text2</code> 转换成
<code>text1</code> 的最小编辑距离问题。</p>
<p>此时，我们可以将向左遍历的起始位置染成红色，将向上遍历的起始位置染成绿色，如下所示是分别对
<code>CABA</code> 和 <code>BABA</code> 遍历路径的染色图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-07.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-08.png?x-oss-process=image/resize,w_800" /></p>
<p>这里，我们对已经染色的路径进行编辑规则的定义，如下：</p>
<ul>
<li>被染成红色的位置，表示在路径中删除原始字符串对应的字符</li>
<li>被染成绿色的位置，表示在路径中插入目标字符串对应的字符</li>
<li>被染成黄色的位置，表示不进行任何编辑编辑操作</li>
</ul>
<p>此时，我们就可以得到最小编辑距离的实际操作步骤，即
<strong>最短编辑脚本（Shortest Edit
Script，SES）</strong>，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-09.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-10.png?x-oss-process=image/resize,w_800" /></p>
<p>上面两图的右半部分是两个符合预期的最短编辑脚本。然而，在实际过程中，对某一个原始文本进行编辑得到另一个目标文本，可能会存在非常多的最短编辑脚本。此时我们该如何选择？<strong>根据实际经验，我们认为先删除旧内容，后插入新内容，具有更直观的体验</strong>。比如：Code
Review
的差异比较也都是按照先删除后插入的方式进行展示，如下所示。因此，上述第一种最短编辑脚本更加直观，符合预期。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-11.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="myers-差分算法">Myers 差分算法</h1>
<p>1986 年 Eugene W.Myers 发表了一篇论文《An O(ND) Difference Algorithm
and Its
Variations》，提出一种基于广度优先搜索和贪心策略的算法，优化了最短编辑路径问题。该算法在求解大规模字符串编辑距离问题时比传统的动态规划更加有效。</p>
<p>下面，我们以 <code>source = ABCABBA</code>
为原始字符串，<code>target = CBAABAC</code> 为目标字符串，基于 Myers
差分算法来查找最短编辑距离和最小编辑脚本。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-12.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="基本定义">基本定义</h2>
<p>与上述算法类似，Myers
差分算法的基本思想仍然是查找一条从左上角至右下角的路径。在路径遍历时，这里有几个基本定义：</p>
<ul>
<li><strong>遍历的方向</strong>：仅支持三个方向，分别是
<strong>向右</strong>、<strong>向下</strong>、<strong>右下</strong>。</li>
<li><strong>遍历的步长</strong>：对于向右和向下，步长为
1。一次只能移动一格；对于右下，一次可以移动任意长度，前提是移动过程中所有坐标的
x、y
值对应在原始字符串和目标字符串中的对应位置的字符必须相同。下图所示，黄色箭头表示可以允许移动的起始位置和终点位置。</li>
<li><strong>遍历的深度</strong>：对于向右和向下，每移动一步，深度加
1；对于右下，无论移动步长为多少，深度始终加 0。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-13.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="k-d-坐标系">K-D 坐标系</h2>
<p>除了对比原始字符串和目标字符串所建立的 X-Y 坐标系外，Myers
还建立了一个 K-D 坐标系，如下图所示。</p>
<p>K 来源于 X 与 Y 的关系式 <code>y = x - k</code>，即偏移量。根据 X 和
K 的值，我们可以计算得到 Y 的值。</p>
<p>D 表示遍历的深度。由于向右或向下移动一步，深度加
1；右下移动一步，深度加 0。因此，D 轴并不是完全垂直于 K
轴，而是类似于等高线，向多方向增长，相同 D
值所连成的线可能是折线，而不一定是直线。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-21.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="最佳位置">最佳位置</h2>
<p>Myers 差分算法是基于贪心策略实现的，对此它定义了一个
<strong>最佳位置</strong> 的概念，作为贪心的基准值。在 K-D
坐标系中，同一条 K 线上，X 值越大的位置（根据 K 的值可以计算得到 Y
值），则越靠近右下角的终点。</p>
<p>那么如何记录最佳位置？很显然，每一个 K
值需要单独记录各自的最佳位置，因此，需要有一个 Map 来进行存储，其中 Key
是 K 值，Value 则是 X 值。根据 K 和 X，我们可以计算出 Y 值。</p>
<h2 id="算法原理">算法原理</h2>
<p>在了解了算法的基本定义、K-D
坐标系以及最佳位置等概念之后，我们来看一下算法具体原理。</p>
<p>算法整体包含两层循环：</p>
<ul>
<li>外层循环：迭代遍历的深度。在最坏的情况下（删除全部原始字符，掺入全部目标字符），遍历的深度为两个字符的长度之和，因此深度的范围为
<code>[0, M+N)</code>。</li>
<li>内层循环：迭代必要的 K 值。对于每一条 K
线，从其上的最佳位置出发，移动深度加 1 后的位置只能在其相邻的两条 K
线上。因此，相同深度的最佳位置所在的 K 线，相邻之间的 K 值差为
2。对应地，内层循环的步长也为 2，并且每一轮遍历，深度加 1，K
的范围也会外扩 2。</li>
</ul>
<p>下面，我们来图解一下算法的运行过程，以下每张图表示一次完整的内层循环。</p>
<p>首先，为 <code>k(0)</code> 查找所有深度为 <code>d0</code>
的最佳位置，很显然，只有起点符合，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-22.png?x-oss-process=image/resize,w_800" /></p>
<p>其次，为 <code>k(-1)</code> 和 <code>k(1)</code> 查找所有深度为
<code>d1</code> 的最佳位置。由于 <code>d1</code> 是基于 <code>d0</code>
宽度优先搜索查找的，而 <code>d0</code>
只有一个，所以由此向两个方向搜索的 K 线只有 <code>k(-1)</code> 和
<code>k(1)</code>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-23.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，我们继续基于 <code>d1</code> 的各个最佳位置进行宽度优先搜索，为
<code>(k-2)</code>、<code>k(0)</code>、<code>k(2)</code> 查找
<code>d2</code> 的各个最佳位置。由于每一轮内层循环的 K 线数量都会外扩
1，因此，首尾的两条 K 线，只能基于内侧 K
线的上一轮循环最佳位置来查找本轮最佳位置；对于中间的 K 线，它两侧的 K
线都有上一轮的最佳位置，它可以从中选择更优的最佳位置（即 X
值更大的最佳位置）来查找本轮的最佳位置。如下图所示，<code>k(-2)</code>
的最佳位置 <code>d2</code> 只能基于 <code>k(-1)</code> 的最佳位置
<code>d1</code> 来查找得到；<code>k(2)</code> 的最佳位置 <code>d2</code>
只能基于 <code>k(1)</code> 的最佳位置 <code>d1</code>
来查找得到。对于中间的 K 线，这里只有
<code>k(0)</code>，它会在左右两边的 K 线中选择一个最佳位置，显然
<code>k(1)</code> 上的 <code>d1</code> 的 X
值更大，因此选择它作为搜索的起点。</p>
<p>从图中，我们还可以看到，当到达深度加 1
的位置后，算法还会进一步判断是否可以向右下移动，因为右下移动时，深度不会增加。此时，我们发现这几个位置都能沿着黄色的线移动，于是
<code>d2</code> 就到达了图中所示的位置。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-24.png?x-oss-process=image/resize,w_800" /></p>
<p>接着，为
<code>k(-3)</code>、<code>k(-1)</code>、<code>k(1)</code>、<code>k(3)</code>
查找 <code>d3</code> 的各个最佳位置。注意，这里我们看一下
<code>k(-1)</code> 的处理，此时它两侧 <code>k(-2)</code> 和
<code>k(0)</code> 的最佳位置的 X 值相同。此时，我们选择基于
<code>k(-2)</code> 右移，很明显，这样必然会比基于 <code>k(0)</code>
下移能找到 X 值更大的位置。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-25.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，为
<code>k(-4)</code>、<code>k(-2)</code>、<code>k(0)</code>、<code>k(2)</code>、<code>k(4)</code>
查找 <code>d4</code> 的各个最佳位置。注意，此时会存在部分 K
线的最佳位置不包含 X-Y 坐标系中真实存在的位置，比如 <code>k(-4)</code>
的最佳位置。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-26.png?x-oss-process=image/resize,w_800" /></p>
<p>最后，我们在为
<code>k(-5)</code>、<code>k(-3)</code>、<code>k(-1)</code>、<code>k(1)</code>、<code>k(3)</code>、<code>k(5)</code>
查找最佳位置时，发现其中一条 K
线的最佳位置已经到达终点，那么此时我们已经找到了最短编辑距离，那么可以结束遍历。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-27.png?x-oss-process=image/resize,w_800" /></p>
<p>在上述过程中，Myers 算法使用一个 Map 记录每条 K 线的最佳位置，其中
Key 为 K 值，Value 为最佳位置。当对同一条 K 线多次更新最佳位置时，Map
只会记录最新的最佳位置。为了便于复现完整的编辑路径，Myers 算法还使用一个
Map 用于记录每个深度的所有最佳位置，其中 Key 为深度值 D，Value 是一个子
Map，记录了该深度时各个 K 线的最佳位置。通过回溯这个包含全部最佳位置的
Map，我们可以重建遍历路径，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-28.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="算法实现">算法实现</h2>
<p>下面，我们使用代码来实现一下 Myers 算法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ruby </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myers</span>(<span class="params">stra, strb</span>)</span><br><span class="line">  <span class="comment"># 字符串 a 和 b 的长度，分别为 n 和 m</span></span><br><span class="line">  m = stra.length</span><br><span class="line">  n = strb.length</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于存储每条 K 线上最佳位置的 Map</span></span><br><span class="line">  v = &#123; <span class="number">1</span> =&gt; <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment"># 用于存储所有深度的所有最佳位置的 Map，用于回溯编辑路径</span></span><br><span class="line">  vs = &#123; <span class="number">0</span> =&gt; &#123; <span class="number">1</span> =&gt; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">  loop <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 外层循环，遍历深度</span></span><br><span class="line">    (<span class="number">0</span>..m + n).each <span class="keyword">do</span> |<span class="params">d</span>|</span><br><span class="line">      tmp = &#123;&#125;</span><br><span class="line">      <span class="comment"># 内层循环，宽度优先搜索，遍历 K 线</span></span><br><span class="line">      (-d..d).step(<span class="number">2</span>) <span class="keyword">do</span> |<span class="params">k</span>|</span><br><span class="line">        down = ((k == -d) |<span class="params"></span>| ((k != d) &amp;&amp; v[k + <span class="number">1</span>] &gt; v[k - <span class="number">1</span>]))</span><br><span class="line">        kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 获取移动的起点位置</span></span><br><span class="line">        xStart = v[kPrev]</span><br><span class="line">        yStart = xStart - kPrev</span><br><span class="line">        <span class="comment"># 获取移动一步的中间位置，向右或向下</span></span><br><span class="line">        xMid = down ? xStart : xStart + <span class="number">1</span></span><br><span class="line">        yMid = xMid - k</span><br><span class="line">        <span class="comment"># 获取移动的终点位置，后续可能会向右下移动。</span></span><br><span class="line">        xEnd = xMid</span><br><span class="line">        yEnd = yMid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向右下移动，深度始终不变</span></span><br><span class="line">        <span class="keyword">while</span>(xEnd &lt; m &amp;&amp; yEnd &lt; n &amp;&amp; stra[xEnd] == strb[yEnd]) <span class="keyword">do</span></span><br><span class="line">          xEnd += <span class="number">1</span></span><br><span class="line">          yEnd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录对应 K 线所能达到的最佳位置</span></span><br><span class="line">        v[k] = xEnd</span><br><span class="line"></span><br><span class="line">        tmp[k] = xEnd</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果两个字符串均到达末端，表示找到了终点，可以结束查找</span></span><br><span class="line">        <span class="keyword">if</span> xEnd == m &amp;&amp; yEnd == n</span><br><span class="line">          vs[d] = tmp</span><br><span class="line">          <span class="comment"># 生成最短编辑路径</span></span><br><span class="line">          snakes = solution(vs, m, n, d)</span><br><span class="line">          <span class="comment"># 打印最短编辑路径</span></span><br><span class="line">          printDiff(snakes, stra, strb)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 记录深度为 D 的所有 K 线的最佳位置</span></span><br><span class="line">      vs[d] = tmp</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">vs, m, n, d</span>)</span><br><span class="line">  snakes = []</span><br><span class="line">  <span class="comment"># 定义位置结构</span></span><br><span class="line">  p = &#123; <span class="symbol">x:</span> m, <span class="symbol">y:</span> n &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 回溯最短编辑路径</span></span><br><span class="line">  <span class="keyword">while</span> d &gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">    v = vs[d]</span><br><span class="line">    vPrev = vs[d-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    k = p[<span class="symbol">:x</span>] - p[<span class="symbol">:y</span>]</span><br><span class="line">    <span class="comment"># 判断之前位置到当前位置最开始移动的方式，向下或向右</span></span><br><span class="line">    down = ((k == -d) |<span class="params"></span>| ((k != d) &amp;&amp; (vPrev[k + <span class="number">1</span>] &gt; vPrev[k - <span class="number">1</span>])))</span><br><span class="line">    kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前位置</span></span><br><span class="line">    xEnd = v[k]</span><br><span class="line">    yEnd = xEnd - k</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 之前位置</span></span><br><span class="line">    xStart = vPrev[kPrev]</span><br><span class="line">    yStart = xStart - kPrev</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中间走斜线时的起始位置</span></span><br><span class="line">    xMid = down ? xStart : xStart + <span class="number">1</span></span><br><span class="line">    yMid = xMid - k</span><br><span class="line"></span><br><span class="line">    snakes.unshift([xStart, xMid, xEnd])</span><br><span class="line"></span><br><span class="line">    p[<span class="symbol">:x</span>] = xStart</span><br><span class="line">    p[<span class="symbol">:y</span>] = yStart</span><br><span class="line"></span><br><span class="line">    d -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> snakes</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printDiff</span>(<span class="params">snakes, stra, strb</span>)</span><br><span class="line">  diffresult = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  yOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  snakes.each_with_index <span class="keyword">do</span> |<span class="params">snake, index</span>|</span><br><span class="line">    s = snake[<span class="number">0</span>]</span><br><span class="line">    m = snake[<span class="number">1</span>]</span><br><span class="line">    e = snake[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是第一个差异，并且差异的开始点不是字符串头（即两字符串在开始部分有相同子字符串）</span></span><br><span class="line">    <span class="keyword">if</span> index === <span class="number">0</span> &amp;&amp; s != <span class="number">0</span></span><br><span class="line">      <span class="comment"># 打印所有相同字符，直到s</span></span><br><span class="line">      (<span class="number">0</span>..s-<span class="number">1</span>).each <span class="keyword">do</span> |<span class="params">j</span>|</span><br><span class="line">        diffresult += <span class="string">&quot;  <span class="subst">#&#123;stra[j]&#125;</span>\n&quot;</span></span><br><span class="line">        yOffset += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> m - s == <span class="number">1</span></span><br><span class="line">      <span class="comment"># 用红色打印删除的字符</span></span><br><span class="line">      diffresult += <span class="string">&quot;\033[0;31m- <span class="subst">#&#123;stra[s]&#125;</span>\033[0m\n&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 用绿色打印插入的字符</span></span><br><span class="line">      diffresult += <span class="string">&quot;\033[0;32m+ <span class="subst">#&#123;strb[yOffset]&#125;</span>\033[0m\n&quot;</span></span><br><span class="line">      yOffset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 打印相同的字符</span></span><br><span class="line">    (<span class="number">0</span>..e-m-<span class="number">1</span>).each <span class="keyword">do</span> |<span class="params">i</span>|</span><br><span class="line">      diffresult += <span class="string">&quot;  <span class="subst">#&#123;stra[m+i]&#125;</span>\n&quot;</span></span><br><span class="line">      yOffset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  puts diffresult</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;ABCABBA&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;CBABAC&#x27;</span></span><br><span class="line">myers(s1, s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>传统动态规划的时间复杂度为 <code>O(mn)</code>，空间复杂度为
<code>O(mn)</code>，其中 <code>m</code> 和 <code>n</code>
分别是两个字符串的长度；Myers 算法的时间复杂度为
<code>O((m+n)D)</code>，<code>D</code>
是最小编辑距离，当最短编辑距离相对较小时，Myers
算法的时间效率是优于传统动态规划的，Myers 算法的空间复杂度为
<code>O(m+n)</code>。因此，当面对大规模且较为相似的字符串比较任务时，Myers
算法相比动态规划更具优势。</p>
<p>后续，我们将阅读一些开源软件或框架，来学习一下 Myers
差分算法在其中的应用。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://www.nathaniel.ai/myers-diff/">Visualizing
Diffs</a></li>
<li><a
href="https://chenshinan.github.io/2019/05/02/git%E7%94%9F%E6%88%90diff%E5%8E%9F%E7%90%86%EF%BC%9AMyers%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/">git生成diff原理：Myers差分算法</a></li>
<li><a
href="https://mcll.top/2019/05/23/diff%E7%AE%97%E6%B3%95/">一种diff算法：Myers</a></li>
<li><a
href="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">The
Myers diff algorithm: part 1</a></li>
<li><a
href="https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/">The
Myers diff algorithm: part 2</a></li>
<li><a
href="https://blog.jcoglan.com/2017/02/17/the-myers-diff-algorithm-part-3/">The
Myers diff algorithm: part 3</a></li>
<li><a
href="https://blog.jcoglan.com/2017/03/22/myers-diff-in-linear-space-theory/">Myers
diff in linear space: theory</a></li>
<li><a
href="https://blog.jcoglan.com/2017/04/25/myers-diff-in-linear-space-implementation/">Myers
diff in linear space: implementation</a></li>
<li>An O(ND) Difference Algorithm and Its Variations. Eugene
W.Myers.</li>
<li><a href="https://zhuanlan.zhihu.com/p/35256233">Diff应用：从LCS
到UICollectionView</a></li>
<li><a
href="https://www.cnblogs.com/oto-G/p/16357245.html">Myers差分算法的理解、实现、可视化</a></li>
<li><a
href="https://juejin.cn/post/6887367495021330445#heading-8">Myers‘Diff之贪婪算法</a></li>
<li><a href="https://github.com/pkg/diff">pkg diff</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Myers</tag>
        <tag>最长公共子序列</tag>
        <tag>最短编辑距离</tag>
        <tag>最短编辑脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>初识人工神经网络（2）——代码实现</title>
    <url>/2024/07/31/neural-network-implement/</url>
    <content><![CDATA[<p>前一篇 <a href="https://chuquan.me/2024/07/21/neural-network-introduce">文章</a> 我们介绍了人工神经网络的基本原理，本文我们将使用 Python 来实现一个简易的神经网络，可用于识别手写数字，从而加深对于神经网络的理解。</p>
<span id="more"></span>
<p>本文实现的完整代码 <a href="https://github.com/baochuquan/implementing-neural-network">传送门</a>。</p>
<h1 id="神经网络实现"><a class="markdownIt-Anchor" href="#神经网络实现"></a> 神经网络实现</h1>
<p>根据我们的理解，神经网络应该至少包含三个部分：</p>
<ul>
<li><strong>初始化</strong>：初始化输入层节点、隐藏层节点、输出层节点的数量。</li>
<li><strong>训练</strong>：通过特定的训练样本，优化连接权重。</li>
<li><strong>查询</strong>：给定输入，计算输出。</li>
</ul>
<p>对此，我们定义一个 <code>NeuralNetwork</code> 类来表示神经网络，其内部包含三个函数分别对应初始化、训练、查询，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># neural network class definition </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span> :</span><br><span class="line">    <span class="comment"># initialise the neural network </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>() :</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># train the neural network </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>() :</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># query the neural network </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>() :</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们依次来实现神经网络的各个部分。</p>
<h2 id="初始化网络"><a class="markdownIt-Anchor" href="#初始化网络"></a> 初始化网络</h2>
<h3 id="网络结构"><a class="markdownIt-Anchor" href="#网络结构"></a> 网络结构</h3>
<p>首先，我们定义神经网络的基本结构，其包含三个层：输入层、隐藏层、输出层。此外，我们还需要定义学习率，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># initialise the neural network</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self , inputnodes, hiddennodes, outputnodes, learningrate </span>) :</span><br><span class="line">    <span class="comment"># set number of nodes in each input, hidden, output layer</span></span><br><span class="line">    self.inodes = inputnodes</span><br><span class="line">    self.hnodes = hiddennodes</span><br><span class="line">    self.onodes = outputnodes</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    self.lr = learningrate</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="连接权重"><a class="markdownIt-Anchor" href="#连接权重"></a> 连接权重</h3>
<p>其次，定义神经网络的核心参数——连接权重。这里涉及两部分连接权重，分别是：</p>
<ul>
<li>输入层与隐藏层之间的连接权重矩阵：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>h</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{input\_hidden}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span></span></span></span>，其大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>s</mi><mo>×</mo><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">hidden\_nodes \times input\_nodes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>。</li>
<li>隐藏层与输出层之间的连接权重矩阵：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mrow><mi>h</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{hidden\_output}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">n</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span></span></span></span>，其大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>s</mi><mo>×</mo><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">hidden\_nodes \times output\_nodes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span></span></span></span>。</li>
</ul>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-15.png?x-oss-process=image/resize,w_800" alt="" /></p>
<p>在 Python 中，我们使用经典的数学库 <code>numpy</code> 来实现矩阵的表示和运算，通过如下的方式我们可以定义一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo>×</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">rows \times columns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span></span></span></span> 的数组，数组元素是 0 ~ 1 的随机值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.random.rand(rows, columns)</span><br></pre></td></tr></table></figure>
<p>在前一篇文章中，我们介绍过权重的范围在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1.1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1. 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 之间。这里我们可以通过上述方式生成随机数之后再减去 0.5，从而使数组元素变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>0.5</mn><mo separator="true">,</mo><mn>0.5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-0.5, 0.5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">]</span></span></span></span> 之间的随机值，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.wih = (numpy.random.rand(self.hnodes, self.inodes) - <span class="number">0.5</span>)</span><br><span class="line">self.who = (numpy.random.rand(self.onodes, self.hnodes) - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>我们之前还提到过一种优化的权重初始化方案：<strong>在一个节点传入连接数量平方根倒数的范围内进行正态分布采样</strong>，即权重范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mi mathvariant="normal">/</mi><msqrt><mtext>传入连接数</mtext></msqrt><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><msqrt><mtext>传入连接数</mtext></msqrt><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1/\sqrt{传入连接数}, -1/\sqrt{传入连接数}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">数</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，相关代码实现如下所示。其中 <code>numpy.random.normal()</code> 函数用于实现正态分布采样，传入的三个参数分别是：正态分布值的中心、标准方差、数组大小。<code>pow(self.hnodes, -0.5)</code> 相当于节点数量的 -0.5 次方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.wih = numpy.random.normal( <span class="number">0.0</span> , <span class="built_in">pow</span>(self.hnodes, -<span class="number">0.5</span>) , (self.hnodes, self.inodes) )</span><br><span class="line">self.who = numpy.random.normal( <span class="number">0.0</span> , <span class="built_in">pow</span>(self.onodes, -<span class="number">0.5</span>) , (self.onodes, self.hnodes) )</span><br></pre></td></tr></table></figure>
<p>最后我们结合网络结构和连接权重，可以得到完整的初始化代码，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># initialise the neural network</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"> self , inputnodes, hiddennodes, outputnodes, learningrate </span>) :</span><br><span class="line">    <span class="comment"># set number of nodes in each input, hidden, output layer</span></span><br><span class="line">    self.inodes = inputnodes</span><br><span class="line">    self.hnodes = hiddennodes</span><br><span class="line">    self.onodes = outputnodes</span><br><span class="line">    </span><br><span class="line">    self.wih = numpy.random.normal ( <span class="number">0.0</span> , <span class="built_in">pow</span>(self.hnodes, -<span class="number">0.5</span>) , (self.hnodes, self.inodes) )</span><br><span class="line">    self.who = numpy.random.normal ( <span class="number">0.0</span> , <span class="built_in">pow</span>(self.onodes, -<span class="number">0.5</span>) , (self.onodes, self.hnodes) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># learning rate</span></span><br><span class="line">    self.lr = learningrate</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="查询网络"><a class="markdownIt-Anchor" href="#查询网络"></a> 查询网络</h2>
<p>查询网络本质上就是信号转换的过程。我们知道每一个神经元都会对输入信号进行两次处理，分别是求和函数和激活函数，对应的矩阵表达式如下所示。</p>
<p>\begin{aligned}<br />
X_{hidden} = &amp; W_{input_hidden} \cdot I<br />
\<br />
\<br />
O_{hidden} = &amp; sigmoid(X_{hidden})<br />
\end{aligned}</p>
<p>对于求和函数，我们可以通过 numpy 库中的矩阵点乘函数来实现，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hidden_inputs = numpy.dot(self.wih, inputs)</span><br></pre></td></tr></table></figure>
<p>对于激活函数，我们使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">sigmoid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span> 激活函数，它的表达式是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{1+e^{-x}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7026642857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。对此，SciPy Python 库中的 <code>expit()</code> 函数实现了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mi>m</mi><mi>o</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">sigmoid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span></span></span></span> 函数。我们可以在初始化方法中加入一下这段代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br></pre></td></tr></table></figure>
<p>然后，我们将上述求和函数结果输入至激活函数中，即可得到隐藏层的输出，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hidden_outputs = self.activation_function(hidden_inputs)</span><br></pre></td></tr></table></figure>
<p>输出层的信号转换本质上与隐藏层一样，因此我们可以添加两行类似的代码来对输出层进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">final_outputs = self.activation_function(final_inputs)</span><br></pre></td></tr></table></figure>
<p>最后我们得到完整的查询网络代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># query the neural network</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, inputs_list</span>) :</span><br><span class="line">    <span class="comment"># convert inputs list to 2d array</span></span><br><span class="line">    inputs = numpy.array(inputs_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculate signals into hidden layer</span></span><br><span class="line">    hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">    <span class="comment"># calculate the signals emerging from hidden layer</span></span><br><span class="line">    hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculate signals into final output layer</span></span><br><span class="line">    final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">    <span class="comment"># calculate the signals emerging from final output layer</span></span><br><span class="line">    final_outputs = self.activation_function(final_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> final_outputs</span><br></pre></td></tr></table></figure>
<h2 id="训练网络"><a class="markdownIt-Anchor" href="#训练网络"></a> 训练网络</h2>
<p>训练网络主要包含两部分：</p>
<ul>
<li>正向的信号转换</li>
<li>反向的权重更新</li>
</ul>
<h3 id="信号转换"><a class="markdownIt-Anchor" href="#信号转换"></a> 信号转换</h3>
<p>信号转换的过程与上述查询网络一致，因此我们可以直接照搬相关代码，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">    <span class="comment"># convert inputs list to 2d array</span></span><br><span class="line">    inputs = numpy.array(inputs_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">    targets = numpy.array(targets_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculate signals into hidden layer</span></span><br><span class="line">    hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">    <span class="comment"># calculate the signals emerging from hidden layer</span></span><br><span class="line">    hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculate signals into final output layer</span></span><br><span class="line">    final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">    <span class="comment"># calculate the signals emerging from final output layer</span></span><br><span class="line">    final_outputs = self.activation_function(final_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="权重更新"><a class="markdownIt-Anchor" href="#权重更新"></a> 权重更新</h3>
<p>对于一个三层神经网络，我们只需要更新两部分权重，分别是：</p>
<ul>
<li>隐藏层与输出层的权重更新</li>
<li>输入层与隐藏层的权重更新</li>
</ul>
<p>权重更新是基于误差实现的，因此我们首先要计算误差，对于输出层的误差，计算样本的预期目标输出值与实际计算输出值的差即可；对于隐藏层的误差，我们在上一篇文章中进行了公式推导，如下所示。</p>
<p>\begin{aligned}<br />
error_{hidden} = W^T_{hidden_output} \cdot error_{output}<br />
\end{aligned}</p>
<p>由此，我们可以得到如下所示的误差计算代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># error is the (target - actual)</span></span><br><span class="line">output_errors = targets - final_outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># hidden layer error is the output_errors, split by weights, recombined at hidden nodes</span></span><br><span class="line">hidden_errors = numpy.dot(self.who.T, output_errors)</span><br></pre></td></tr></table></figure>
<p>然后，我们根据上一篇文章中推导的权重更新公式来实现相关代码，其公式如下所示。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 是学习率。基于此，我们可以分别实现隐藏层与输出层的权重更新、输入层与隐藏层的权重更新。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-42.png?x-oss-process=image/resize,w_800" alt="" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update the weights for the links between the hidden and output layers</span></span><br><span class="line">self.who += self.lr * numpy.dot(( output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line"></span><br><span class="line"><span class="comment"># update the weights for the links between the input and hidden layers</span></span><br><span class="line">self.wih += self.lr * numpy.dot(( hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br></pre></td></tr></table></figure>
<p>最后，我们可以得到完整的训练网络的相关代码，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">    <span class="comment"># convert inputs list to 2d array</span></span><br><span class="line">    inputs = numpy.array(inputs_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">    targets = numpy.array(targets_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculate signals into hidden layer</span></span><br><span class="line">    hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">    <span class="comment"># calculate the signals emerging from hidden layer</span></span><br><span class="line">    hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># calculate signals into final output layer</span></span><br><span class="line">    final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">    <span class="comment"># calculate the signals emerging from final output layer</span></span><br><span class="line">    final_outputs = self.activation_function(final_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># output layer error is the (target - actual) </span></span><br><span class="line">    output_errors = targets - final_outputs</span><br><span class="line">    <span class="comment"># hidden layer error is the output_errors, split by weights, recombined at hidden nodes</span></span><br><span class="line">    hidden_errors = numpy.dot(self.who.T, output_errors)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the weights for the links between the hidden and output layers</span></span><br><span class="line">    self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># update the weights for the links between the input and hidden layers</span></span><br><span class="line">    self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h1 id="神经网络测试"><a class="markdownIt-Anchor" href="#神经网络测试"></a> 神经网络测试</h1>
<p>神经网络适合用于解决不具有固定模式或计算步骤的问题，比如：图像识别、语音识别等。这里我们尝试让神经网络解决一个类似的问题——手写数字识别。下图所示是一个手写数字的示例，我们可能会对于这个数字是 4 还是 9 产生分歧。此时，神经网络就可以作为判断的辅助工具，我们的目的也是如此。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-imp-01.png?x-oss-process=image/resize,w_800" alt="" /></p>
<h2 id="训练数据"><a class="markdownIt-Anchor" href="#训练数据"></a> 训练数据</h2>
<p>经典的手写数字数据库 <a href="https://yann.lecun.com/exdb/mnist/">MNIST</a> 为我们提供了训练和测试的样本数据，由于 MNIST 数据库的格式不易使用，我们使用别人构建的相对简单的 CSV 文件：</p>
<ul>
<li>训练集 <a href="http://www.pjreddie.com/media/files/mnist_train.csv">http://www.pjreddie.com/media/files/mnist_train.csv</a></li>
<li>测试集 <a href="http://www.pjreddie.com/media/files/mnist_test.csv">http://www.pjreddie.com/media/files/mnist_test.csv</a></li>
</ul>
<p><code>mnist_train.csv</code> 和 <code>mnist_test.csv</code> 中的每一行代表一个样本数据，每个样本数据由 785 个数字组成，由逗号进行分隔。其中第 1 个数字是样本的预期目标值；其余 784 个数字素是样本的输入数据，本质上是一个打平的 28 x 28 的二维矩阵，每个数字表示一个颜色值，范围在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>255</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 255]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mclose">]</span></span></span></span> 之间。如下所示，是一个样本数据的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,18,18,18,126,136,175,26,166,255,247,127,0,0,0,0,0,0,0,0,0,0,0,0,30,36,94,154,170,253,253,253,253,253,225,172,253,242,195,64,0,0,0,0,0,0,0,0,0,0,0,49,238,253,253,253,253,253,253,253,253,251,93,82,82,56,39,0,0,0,0,0,0,0,0,0,0,0,0,18,219,253,253,253,253,253,198,182,247,241,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,156,107,253,253,205,11,0,43,154,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,1,154,253,90,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,139,253,190,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,190,253,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35,241,225,160,108,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,81,240,253,253,119,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45,186,253,253,150,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,93,252,253,187,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,253,249,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,130,183,253,253,207,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,148,229,253,253,253,250,182,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,114,221,253,253,253,253,201,78,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,66,213,253,253,253,253,198,81,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,171,219,253,253,253,253,195,80,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,55,172,226,253,253,253,253,244,133,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,136,253,253,253,212,135,132,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br></pre></td></tr></table></figure>
<p>将此样本数据转换成图像，可以得到如下所示的手写数字图像，通过肉眼判断手写数字与预期目标值 5 是相符合的。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-imp-02.png?x-oss-process=image/resize,w_800" alt="" /></p>
<h2 id="构建网络"><a class="markdownIt-Anchor" href="#构建网络"></a> 构建网络</h2>
<p>对于输入层节点，由于样本的输入数据是 28 x 28 = 784，因此在初始化网络时，传入的 <code>input_nodes</code> 也应该是 784。</p>
<p>对于输出层节点，由于神经网络是对图像进行分类，在此情况下，分类的结果应该是 [0, 9] 共 10 个数字中的任意一个，因此在初始化网络时，传入的 <code>output_nodes</code> 也应该是 10。</p>
<p>对于隐藏层节点，这也是一个可自由调节的参数。由于隐藏层是为了提取输入数据的特征和模式，理论上可以比输入更简洁，因此我们可以考虑使用一个比输入节点数更小的数来表示，比如：100。同样，学习率也是一个可自由调节的参数，这里我们暂停为 0.3。</p>
<p>如下所示，是网络构建的相关代码实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># number of input, hidden and output nodes</span></span><br><span class="line">input_nodes = <span class="number">784</span></span><br><span class="line">hidden_nodes = <span class="number">100</span></span><br><span class="line">output_nodes = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># learning rate is 0.3</span></span><br><span class="line">learning_rate = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create instance of neural network</span></span><br><span class="line">n = neuralNetwork(input_nodes,hidden_nodes,output_nodes, learning_rate)</span><br></pre></td></tr></table></figure>
<h2 id="样本数据预处理"><a class="markdownIt-Anchor" href="#样本数据预处理"></a> 样本数据预处理</h2>
<p>在上一篇文章中我们提到输入值的范围应该是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，而当前的样本输入值的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>255</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 255]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>。因此我们需要进行样本数据处理，可以考虑将其缩小至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0.01</mn><mo separator="true">,</mo><mn>1.0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0.01, 1.0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 的范围之中，相关的处理代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br></pre></td></tr></table></figure>
<p>除了样本输出值，我们还需要处理样本目标值。当前输出层具有 10 个节点，输出值最大的节点的索引就是手写数字的识别结果，如下所示。对此，理想情况是定义一个数组，只有一个元素为 1，其余元素为 0。然而激活函数无法输出 0 和 1，此时如果将目标值设为 0 或 1，将会导致神经网络反馈过大的权重。因此我们要对这些目标值进行微调，使用 0.01 和 0.99 来代替 0 和 1，实现代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#output nodes is 10 (example)</span></span><br><span class="line">onodes = <span class="number">10</span></span><br><span class="line">targets = numpy.zeros(onodes) + <span class="number">0.01</span></span><br><span class="line">targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])] = <span class="number">0.99</span></span><br></pre></td></tr></table></figure>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-imp-03.png?x-oss-process=image/resize,w_800" alt="" /></p>
<p>如下所示是输入数据预处理的相关代码实现。我们首先打开样本数据的 <code>csv</code> 文件，然后循环依次遍历每一个样本数据，拆分成目标值和输入值，最后对它们进行预处理，从而匹配神经网络的值的约束。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load the mnist training data CSV file into a list </span></span><br><span class="line">training_data_file = <span class="built_in">open</span>(<span class="string">&quot;./mnist_train.csv&quot;</span>, <span class="string">&#x27;r&#x27;</span>) </span><br><span class="line">training_data_list = training_data_file.readlines() </span><br><span class="line">training_data_file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># go through all records in the training data set</span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> training_data_list:</span><br><span class="line">    <span class="comment"># split the record by the &#x27;,&#x27; commas</span></span><br><span class="line">    all_values = record.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment"># scale and shift the inputs</span></span><br><span class="line">    inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span> </span><br><span class="line">    <span class="comment"># create the target output values (all 0.01, except the desired label which is 0.99)</span></span><br><span class="line">    targets = numpy.zeros(output_nodes) + <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># all_values[0] is the target label for this record</span></span><br><span class="line">    targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])] = <span class="number">0.99</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># train the neural network</span></span><br><span class="line">    n.train(inputs, targets)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="训练与测试"><a class="markdownIt-Anchor" href="#训练与测试"></a> 训练与测试</h2>
<p>我们使用 <code>mnist_train.csv</code> 完成了训练之后，可以使用 <code>mnist_test.csv</code> 来进行测试。我们只要再读取测试数据，输入至已训练的神经网络中查询结果，并比对输出值与目标值。为了有一个衡量标准，我们对每次样本测试进行打分，查询结果正确 +1，最后计算正确率，相关代码实现如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load the mnist test data CSV file into a list</span></span><br><span class="line">test_data_file = <span class="built_in">open</span>(<span class="string">&quot;./mnist_test.csv&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">test_data_list = test_data_file.readlines()</span><br><span class="line">test_data_file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># test the neural network</span></span><br><span class="line"><span class="comment"># scorecard for how well the network performs, initially empty </span></span><br><span class="line">scorecard = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># go through all the records in the test data set</span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> test_data_list:</span><br><span class="line">    <span class="comment"># split the record by the &#x27;,&#x27; commas</span></span><br><span class="line">    all_values = record.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment"># correct answer is first value</span></span><br><span class="line">    correct_label = <span class="built_in">int</span>(all_values[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># scale and shift the inputs</span></span><br><span class="line">    inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">     <span class="comment"># query the network</span></span><br><span class="line">    outputs = n.query(inputs)</span><br><span class="line">    <span class="comment"># the index of the highest value corresponds to the label </span></span><br><span class="line">    label = numpy.argmax(outputs)</span><br><span class="line">    <span class="comment"># append correct or incorrect to list</span></span><br><span class="line">    <span class="keyword">if</span> (label == correct_label):</span><br><span class="line">        <span class="comment"># network&#x27;s answer matches correct answer, add 1 to scorecard</span></span><br><span class="line">        scorecard.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:<span class="comment"># network&#x27;s answer doesn&#x27;t match correct answer, add 0 to scorecard</span></span><br><span class="line">        scorecard.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate the performance score, the fraction of correct answers</span></span><br><span class="line">scorecard_array = numpy.asarray(scorecard)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;performance = &quot;</span>, scorecard_array.<span class="built_in">sum</span>() / scorecard_array.size)</span><br></pre></td></tr></table></figure>
<h1 id="神经网络优化"><a class="markdownIt-Anchor" href="#神经网络优化"></a> 神经网络优化</h1>
<p>至此，我们实现了一个手写数字识别的神经网络，并完成了评测。虽然评测得分还不错，正确率超过 95%，但是它还可以进一步优化。下面我们简单介绍几种优化思路。</p>
<h2 id="调整学习率"><a class="markdownIt-Anchor" href="#调整学习率"></a> 调整学习率</h2>
<p>调整学习率是最直观的一种优化思路。学习率过小会导致学习反馈不足，学习率过大会导致学习反馈震荡。下图所示是我们所实现神经网络的性能评分与与学习率的关系曲线。整体而言，我们应该不断调整，选择一个适中的学习率。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-imp-04.png?x-oss-process=image/resize,w_800" alt="" /></p>
<h2 id="重复训练"><a class="markdownIt-Anchor" href="#重复训练"></a> 重复训练</h2>
<p>重复训练也是一种经典的优化思路。我们将样本训练一次称为一个 <strong>世代</strong>（Epoch）。我们可以在样本训练的代码的外层再嵌套一层遍历，尝试进行多个世代的训练，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train the neural network</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># epochs is the number of times the training data set is used for training</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> training_data_list:</span><br><span class="line">        <span class="comment"># split the record by the &#x27;, commas</span></span><br><span class="line">        all_values = record.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="comment"># scale and shift the inputs</span></span><br><span class="line">        inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">        <span class="comment"># create the target output values (all 0.01, except the desired label which is 0.99)</span></span><br><span class="line">        targets = numpy.zeros(output_nodes) + <span class="number">0.01</span></span><br><span class="line">        <span class="comment"># all_values[0] is the target label for this record</span></span><br><span class="line">        targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])] = <span class="number">0.99</span></span><br><span class="line">        n.train(inputs, targets)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>与学习率类似，过少的训练会导致学习反馈不足，过多的训练会导致网络过渡拟合训练数据。下图所示是性能评分与世代数的关系曲线，我们同样也需要进行不断调整世代数，寻找一个最佳值。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-imp-05.png?x-oss-process=image/resize,w_800" alt="" /></p>
<h2 id="调整网络结构"><a class="markdownIt-Anchor" href="#调整网络结构"></a> 调整网络结构</h2>
<p>调整网络结构也是一种优化思路。我们可以考虑调整隐藏层的节点数量。如果节点数太少的话，会导致节点无法承载过多的特征，从而表现不佳。下图所示是性能评测与隐藏层节点数之间的关系曲线，很显然节点越多，性能表现越好。当然这也是有代价的，节点数越多，神经网络的计算量就越大。</p>
<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-imp-06.png?x-oss-process=image/resize,w_800" alt="" /></p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文基于神经网络的基本原理，使用 Python 依次实现了神经网络的初始化、训练、查询等部分。然后，我们使用 MNIST 的样本数据和测试数据依次来对神经网络进行训练和测试。最后，我们提了三种神经网络性能优化的思路，包括：学习率、训练量、网络结构等。</p>
<p>后续有时间，我们将再来深入学习一下机器学习的其他相关技术。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>epoch</tag>
        <tag>MNIST</tag>
        <tag>手写数字识别</tag>
      </tags>
  </entry>
  <entry>
    <title>初识人工神经网络（1）——基本原理</title>
    <url>/2024/07/21/neural-network-introduce/</url>
    <content><![CDATA[<p>最近看了《Python
神经网络编程》一书之后，对于神经网络的基本原理有了一个初步的理解，于是产出此篇文章作为系统性的梳理和总结。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>计算机设计的初衷是为了解决大量的数学运算，因此适用于解决具有固定模式或计算步骤的问题。对于不具备固定模式或计算步骤的问题，比如图像识别、语音识别等，传统的计算机程序很难有效地予以解决。</p>
<p>人工智能的重要研究方向之一就是通过计算机来解决这类相对困难的问题。机器学习便是人工智能领域中的一个重要分支，而人工神经网络则是机器学习中一种被广泛使用的算法。</p>
<h1 id="分类器">分类器</h1>
<p>为了能够理解神经网络的核心思想，我们先来介绍一个分类器的例子。</p>
<p>假如花园中有两种虫子：毛虫细而长，瓢虫宽而短。我们希望设计一个分类器，当给定一个虫子的长度和宽度，分类器能够自动进行分类。</p>
<h2 id="设计分析">设计分析</h2>
<p>我们考虑对虫子的长度和宽度进行分析，绘制一个二维坐标系，可以发现两种虫子是存在一定的聚类特征的，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-01.png?x-oss-process=image/resize,w_800" /></p>
<p>因此，分类器的设计目标就是通过数据训练进行学习，从而找到一条分界线，将两种类型的虫子进行有效分类。如下所示，在训练阶段，分界线会不断地进行修正，最终到达一个相对正确的位置。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-02.png?x-oss-process=image/resize,w_800" /></p>
<p>分类器最终结构如下所示，它有一个输入和一个输出，通过分类器实现内部分类逻辑，最终输出分类结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="样本训练">样本训练</h2>
<p>那么分类器该如何通过数据训练来调整分界线的斜率呢？首先，我们需要定义一个用于表示分界线的函数（或称测试函数），如下所示。</p>
<span class="math display">\[\begin{aligned}
y = Ax
\end{aligned}\]</span>
<p>然后，我们随机初始化 <span class="math inline">\(A\)</span>
的值，假设初始化值为 <code>0.25</code>，那么将得到如下所示的直线 <span
class="math inline">\(y = 0.25x\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-03.png?x-oss-process=image/resize,w_800" /></p>
<p>接下来，我们开始输入训练样本，如下所示。当输入两个虫子的样本数据后，我们发现分界线并没有正确对虫子进行有效分类。此时，我们需要对斜率进行调整，这也是训练的核心目标。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-04.png?x-oss-process=image/resize,w_800" /></p>
<p>我们观察第一个训练样本数据：宽度 3.0，长度 1.0，瓢虫。我们将 <span
class="math inline">\(x = 3.0\)</span> 代入函数 <span
class="math inline">\(y = Ax\)</span>，得到 <span
class="math inline">\(y = 0.25 * 3.0 =
0.75\)</span>。然而，样本数据告诉我们 <span class="math inline">\(y =
1.0\)</span>，此时我们看到了误差的存在。值得注意的是，分界线是为了对实现分类，我们需要让
<span class="math inline">\(x\)</span> 代入函数后得到的 <span
class="math inline">\(y\)</span> 值大于 <span
class="math inline">\(1.0\)</span>。为了避免调整过大，我们将 <span
class="math inline">\(y\)</span> 的目标值设置为 <span
class="math inline">\(1.1\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-05.png?x-oss-process=image/resize,w_800" /></p>
<p>由此，我们计算输出值和目标值之间的误差，基于此计算出调整的斜率差值。下图显示了初始分界线和一次训练后的分界线。</p>
<span class="math display">\[\begin{aligned}
实际值: &amp; y = Ax = 0.25 * 3.0 = 0.75
\\
目标值: &amp; t = (A + \Delta A)x = 1.1
\\
误差值: &amp; E = t - y = (\Delta A)x = 1.1 - 0.75 = 0.35
\\
斜率差值: &amp; \Delta A = E / x = 0.35 / 3.0 = 0.1167
\\
斜率修正值: &amp; (A + \Delta A) = 0.25 + 0.1167 = 0.3667
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-06.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，我们再观察第二个训练样本数据：宽度 1.0，长度
3.0，毛虫。采用类似的方法，我们可以计算出调整后的斜率为 <span
class="math inline">\(2.9\)</span>。下图显示了初始分界线和两次训练后的分界线。</p>
<span class="math display">\[\begin{aligned}
实际值: &amp; y = Ax = 0.3667 * 1.0 = 0.3667
\\
目标值: &amp; t = (A + \Delta A)x = 2.9
\\
误差值: &amp; E = t - y = (\Delta A)x = 2.9 - 0.3667 = 2.5333
\\
斜率差值: &amp; \Delta A = E / x = 2.5333 / 1.0 = 2.5333
\\
斜率修正值: &amp; (A + \Delta A) = 0.3667 + 2.5333 = 2.9
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-07.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="适度改进">适度改进</h2>
<p>如果我们仔细观测两次训练，会发现最终改进的直线与最后一次训练样本非常匹配。这种方式实际上抛弃了所有先前训练样本的学习结果，只对最后一次训练样本进行了学习。</p>
<p>那么如何解决这个问题呢？一个重要的思路就是
<strong>适度改进（Moderate）</strong>。</p>
<p>我们可以在改进公式中增加一个调节系数 <span
class="math inline">\(L\)</span> ，也称为 <strong>学习率（Learning
Rate）</strong>，如下所示。</p>
<span class="math display">\[\begin{aligned}
\Delta A = L (E / x)
\end{aligned}\]</span>
<p>基于新的调整公式，设定学习率 <span class="math inline">\(L =
0.5\)</span>，我们再来计算一下斜率的改进过程。</p>
<span class="math display">\[\begin{aligned}
第一次训练: &amp;
\\
实际值: &amp; y = Ax = 0.25 * 3.0 = 0.75
\\
目标值: &amp; t = (A + \Delta A)x = 1.1
\\
误差值: &amp; E = t - y = (\Delta A)x = 1.1 - 0.75 = 0.35
\\
斜率差值: &amp; \Delta A = L (E / x) = 0.5 * 0.35 / 3.0 = 0.0583
\\
斜率修正值: &amp; (A + \Delta A) = 0.25 + 0.0583 = 0.3083
\\
\\
第二次训练: &amp;
\\
实际值: &amp; y = Ax = 0.3083 * 1.0 = 0.3083
\\
目标值: &amp; t = (A + \Delta A)x = 2.9
\\
误差值: &amp; E = t - y = (\Delta A)x = 2.9 - 0.3083 = 2.5917
\\
斜率差值: &amp; \Delta A = L (E / x) = 0.5 * 2.5917 / 1.0 = 1.2958
\\
斜率修正值: &amp; (A + \Delta A) = 0.3083 + 1.2958 = 1.6042
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-08.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="分类器组合">分类器组合</h2>
<p>上述，我们介绍了单一分类器通过训练样本进行学习调整相关参数，最终可用于解决特定问题。</p>
<p>然而，现实中很多问题并不是一个分类器能够解决的，比如：如何在网格节点中输出逻辑异或（XOR）的值？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-09.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，我们无论如何都无法通过一条分界线来正确进行分类。于是，我们开始考虑采用多个分类器进行组合，共同完成对复杂问题的求解，这就是神经网络的基本思想。</p>
<h1 id="神经网络">神经网络</h1>
<p>人工神经网络（Artificial Neural
Network，ANN，简称神经网络），其设计思想借鉴了动物大脑的生物神经网络，构建了一套类似神经元互连的分层组织结构。</p>
<h2 id="神经元">神经元</h2>
<p>无论是人工神经网路，还是生物神经网络，神经元都是其中的基本组成单元，两种神经元的结构也基本差不多。</p>
<h3 id="生物神经元">生物神经元</h3>
<p>如下图所示，生物神经元主要包含三部分：</p>
<ul>
<li>树突：用于接收外部电信号</li>
<li>轴突：用于传导电信号</li>
<li>突触：用于将电信号传递至其他神经元或细胞</li>
</ul>
<p>此外，神经元还会通过阈值（threshold）抑制输入，直到电信号超出阈值，才会触发输入。因为神经元不希望传递各种微小的噪音信号，而只传递有意识的明显信号。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-13.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="人工神经元">人工神经元</h3>
<p>如下图所示，人工神经元主要包含三个部分：</p>
<ul>
<li>输入：类似于树突，可以包含一个或多个输入端，用于接收外部信号</li>
<li>输出：类似于轴突和突触，用于传递和输出信号</li>
<li>节点：类似于细胞核，用于处理信号。本质上是两个函数，分别是：
<ul>
<li>求和函数：对所有输入进行求和</li>
<li>激活函数：或称阈值函数，用于过滤噪音信号，类似于生物神经元中抑制噪音电信号。</li>
</ul></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-12.png?x-oss-process=image/resize,w_800" /></p>
<p>对于激活函数，一个简单的阶跃函数即可实现类似的效果。但是为了更接近自然的效果，这里采用一种平滑且经典的
Sigmoid 函数（简称 S
函数）作为激活函数，其函数表达式如下所示。除此之外，神经网络中常用的激活函数还有很多，比如：双曲正切函数（Hyperbolic
Tangent）、ReLU函数（Rectified Linear Unit）、Leaky
ReLU函数、ELU函数（Exponential Linear Unit）、SELU（Scaled Exponential
Linear Unit）、Softmax 等等，有兴趣的朋友可以自行了解。</p>
<span class="math display">\[\begin{aligned}
y = \frac{1}{1+e^{-x}}
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-16.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="基本结构">基本结构</h2>
<p>通过构建多层神经元，每一层中的神经元都与在其前后层中的所有神经元相互连接，即可得到一个分层的人工神经网络。</p>
<p>根据分层所在的位置，我们将分层分为三种类型：输入层、隐藏层、输出层。任意一个神经网络的输入层和输出层各自只有一个，隐藏层可以有多个。下图所示是一个三层结构的神经网络，可以看到每个节点都与前一层或后一层的其他每个节点相互连接。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-14.png?x-oss-process=image/resize,w_800" /></p>
<p>基于训练样本，神经网络会进行学习，那么它有没有可以调整的参数呢？类似上文介绍的分类器，我们可以调整斜率参数。在神经网络中，则是
<strong>通过调整节点之间的连接强度作为训练样本的学习反馈</strong>。</p>
<p>下图所示展示了节点之间各个连接的连接强度，使用
<strong>权重</strong>（Weight）表示，比如：<span
class="math inline">\(w_{1,2}\)</span> 表示当前层节点 1 与后一层节点 2
之间的连接强度。通常权重值的范围位于 <span class="math inline">\([0,
1]\)</span> 之间，当权重值为 0 时，则表示连接断开。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-15.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="信号转换">信号转换</h1>
<p>了解了神经网络的基本结构之后，我们来介绍一下输入信号是如何在神经网络中经过一层一层的神经元，最终转换成输出信号的。在这个过程中，我们会结合矩阵运算来进行表达。</p>
<p>下图所示是一个具有 3 个分层，每个分层 3
个节点的神经网络，为了保持图示清晰，我们没有标注所有权重。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-17.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们来依次看一下输入层、隐藏层、输出层对于信号的转换和处理。</p>
<h2 id="输入层">输入层</h2>
<p>在人工神经网络中，输入层的节点通常不会进行求和函数和激活函数的处理。输入层的节点主要负责接收原始的输入信号，并将其直接透传给下一层的隐藏层或输出层。</p>
<p>对于输入层，我们可以使用矩阵 <span
class="math inline">\(I_{input}\)</span> 来表示输入信号，使用矩阵 <span
class="math inline">\(O_{input}\)</span>
表示输出信号。由此得到如下所示表示：</p>
<span class="math display">\[\begin{aligned}

O_{input} = I_{input} =
\left(
\begin{matrix}
0.9
\\
0.1
\\
0.8
\end{matrix}
\right)

\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-18.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="隐藏层">隐藏层</h2>
<p>对于隐藏层，我们可以使用矩阵 <span
class="math inline">\(W_{input\_hidden}\)</span>来表示输入层与隐藏层之间的连接权重，如下所示：</p>
<span class="math display">\[\begin{aligned}

W_{input\_hidden} =
\left(
\begin{matrix}
0.9 &amp; 0.3 &amp; 0.4
\\
0.2 &amp; 0.8 &amp; 0.2
\\
0.1 &amp; 0.5 &amp; 0.6
\end{matrix}
\right)

\end{aligned}\]</span>
<p>隐藏层神经元节点接收输入信号后，会依次使用求和函数、激活函数进行处理，然后进行输出。关于求和函数，我们可以使用矩阵点乘来表示，这里使用
<span class="math inline">\(X_{hidden}\)</span>
来表示隐藏层求和函数的计算结果。</p>
<span class="math display">\[\begin{aligned}
X_{hidden} = &amp; W_{input\_hidden} \cdot O_{input}
\\
= &amp;
\left(
\begin{matrix}
0.9 &amp; 0.3 &amp; 0.4
\\
0.2 &amp; 0.8 &amp; 0.2
\\
0.1 &amp; 0.5 &amp; 0.6
\end{matrix}
\right)
\cdot
\left(
\begin{matrix}
0.9
\\
0.1
\\
0.8
\end{matrix}
\right)
\\
= &amp;
\left(
\begin{matrix}
1.16
\\
0.42
\\
0.62
\end{matrix}
\right)
\end{aligned}\]</span>
<p>关于激活函数，我们使用 <span class="math inline">\(sigmoid\)</span>
来表示，隐藏层的最终输出仍然可以矩阵来表示，这里使用 <span
class="math inline">\(O_{hidden}\)</span> 表示隐藏层的最终输出。</p>
<span class="math display">\[\begin{aligned}
O_{hidden} = &amp; sigmoid \left( X_{hidden} \right)
\\
= &amp;
sigmoid
\left(
\begin{matrix}
1.16
\\
0.42
\\
0.62
\end{matrix}
\right)
\\
= &amp;
\left(
\begin{matrix}
0.761
\\
0.603
\\
0.650
\end{matrix}
\right)
\end{aligned}\]</span>
<p>由此我们得到隐藏层的输出信号，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-19.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="输出层">输出层</h2>
<p>输出层对于信号的转换和处理，本质上和隐藏层没有任何区别，计算的方法和流程是一样的。</p>
<p>我们使用 <span class="math inline">\(W_{hidden\_output}\)</span>
表示隐藏层与输出层之间的连接权重，结合隐藏层的输出 <span
class="math inline">\(O_{hidden}\)</span>，通过矩阵点乘来运用求和函数，得到
<span class="math inline">\(X_{output}\)</span>，如下所示。</p>
<span class="math display">\[\begin{aligned}
X_{output} = &amp; W_{hidden\_output} \cdot O_{hidden}
\\
= &amp;
\left(
\begin{matrix}
0.3 &amp; 0.7 &amp; 0.5
\\
0.6 &amp; 0.5 &amp; 0.2
\\
0.8 &amp; 0.1 &amp; 0.9
\end{matrix}
\right)
\cdot
\left(
\begin{matrix}
0.761
\\
0.603
\\
0.650
\end{matrix}
\right)
\\
= &amp;
\left(
\begin{matrix}
0.975
\\
0.888
\\
1.254
\end{matrix}
\right)
\end{aligned}\]</span>
<p>最后再应用激活函数，得到输出层的结果 <span
class="math inline">\(O_{output}\)</span> ，如下所示。</p>
<span class="math display">\[\begin{aligned}
O_{output} = &amp; sigmoid \left( X_{output} \right)
\\
= &amp;
sigmoid
\left(
\begin{matrix}
0.975
\\
0.888
\\
1.254
\end{matrix}
\right)
\\
= &amp;
\left(
\begin{matrix}
0.726
\\
0.708
\\
0.778
\end{matrix}
\right)
\end{aligned}\]</span>
<p>由此我们得到输出层的输出信号，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-20.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="训练反馈">训练反馈</h1>
<p>在实际应用神经网络之前，我们必须使用大量训练样本对其进行训练，训练的核心目的是
<strong>调整各节点之间链接权重的值</strong>，使其调整为合适的值，从而让神经网络能够输出相对准确的结果。</p>
<h2 id="值的约束">值的约束</h2>
<p>首先我们来看下神经网络中的值，其主要包含四种：目标值、输入值、输出值、权重值。这些值的范围与神经网络运行和训练密切相关，下面我们分别来了解一下。</p>
<h3 id="输出值-目标值">输出值 &amp; 目标值</h3>
<p>输出值的范围与激活函数有关。下图所示是 Sigmoid
激活函数的曲线图，其输出值的范围为 <span class="math inline">\((0,
1)\)</span>。训练样本的目标值的范围也应该与输出值的范围一样；否则，神经网络会驱使更大（或更小）的权重，导致学习能力过犹不足。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-22.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="输入值">输入值</h3>
<p>类似输出值，输入值范围也与激活函数有关。对于 sigmoid
函数，当输入值超出某个范围之后，输出值会变得非常平坦，换句话说就是梯度（斜率）差异很小，从而会导致学习能力降低。</p>
<p>很显然，梯度变化适中的区域更适合用于神经网络的训练，如下图所示，输入值的范围在
<span class="math inline">\([-1, 1]\)</span>
之内的激活函数梯度变化适中。不过，我们要注意输入值为 0
的情况，此时结合任意权重值后，信号都会变成 0，权重更新表达式也会变成
0，从而导致学习能力丧失（后续权重更新中会详细进行介绍）。因此我们要避免输入值等于
0，一般建议将输入值的范围设置为 <span class="math inline">\((0,
1]\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-21.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="权重值">权重值</h3>
<p>根据前面的介绍，我们知道权重值会影响求和函数的结果，并最终作为激活函数的输入。因此，初始权重值同样也会影响神经网络的学习能力，过大（或过小）的初始值会造成过大（或过小）的信号传递给激活函数，导致神经网络饱和，从而降低神经网络学习更好权重的能力。</p>
<p>如下所示，是我们认为 sigmoid
激活函数的梯度适中的区域。对此，我们也可以简单地将权重的初始值范围设置为
<span class="math inline">\([-1, 1]\)</span>，并随机均匀进行取值。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-23.png?x-oss-process=image/resize,w_800" /></p>
<p>当然，我们还有更好的权重值初始化方案。对此，我们回顾一下求和函数的输入和输出。一个神经元节点的求和函数输出等于与之相连的前一层所有节点的输出的加权求和。因此我们应该根据输出值的范围逆向推导各个连接的权重值，很显然，这与每个节点的连接的节点数量有关。对此，数学家提出了一种基于经验法则的权重初始化方案，即
<strong>在一个节点传入连接数量平方根倒数的大致范围内随机采样，作为权重初始值</strong>。比如，每个节点具有
100 条输入连接，那么权重的范围应该在 <span
class="math inline">\([-1/\sqrt{100}, 1/\sqrt{100}]\)</span> 之间，即
<span class="math inline">\([-0.1, 0.1]\)</span> 之间。</p>
<p>从直觉上讲，这种方案是有意义的。一个节点的输入连接越多，就会有越多的信号叠加在一起。因此，如果连接更多，那么减小权重的范围是有道理的。</p>
<p>当然，这种优化方案还定义了权重初始值应该遵循正态分布，下图总结了这种基于正态分布的权重初始化方案。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-24.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="误差分割">误差分割</h2>
<p>神经网络是基于训练样本的目标值与实际运行的输出值之间的误差来进行反馈学习，从而调整各个连接的权重。然而，每个节点可能有多个输入连接，每个连接有各自的权重值。为了合理分配误差值，神经网络会根据连接的权重来进行分割误差。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-25.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="误差传播">误差传播</h2>
<p>了解了误差分割后，我们再来看看神经网络是如何传播误差的。</p>
<h3 id="输出层-1">输出层</h3>
<p>我们先来看输出层的误差传播。下图展示了一个具有 2 个输入节点和 2
个输出节点的神经网络。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-26.png?x-oss-process=image/resize,w_800" /></p>
<p>对于输出层节点 1，我们定义其实际输出值为 <span
class="math inline">\(o_1\)</span>，目标输出值为 <span
class="math inline">\(t_1\)</span>，那么由此可计算得出误差值 <span
class="math inline">\(e_1 = (t_1 -
o_1)\)</span>。然后我们可以按照连接权重来分割误差，很显然，<span
class="math inline">\(e_1\)</span> 和 <span
class="math inline">\(e_2\)</span> 的误差传播组成如下所示。</p>
<span class="math display">\[\begin{aligned}
e_1 = e_1 \frac{w_{1,1}}{w_{1,1} + w_{2,1}} + e_1 \frac{w_{2,1}}{w_{1,1}
+ w_{2,1}}
\\
\\
e_2 = e_2 \frac{w_{1,2}}{w_{1,2} + w_{2,2}} + e_2 \frac{w_{2,2}}{w_{1,2}
+ w_{2,2}}
\end{aligned}\]</span>
<h3 id="隐藏层-1">隐藏层</h3>
<p>我们再来看隐藏层的误差传播。下图展示了一个包含输入层、隐藏层、输出层的
3 层神经网络。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-27.png?x-oss-process=image/resize,w_800" /></p>
<p>对于隐藏层的各个节点，它们并没有所谓的目标值，因此无法直接计算其误差。对此，我们可以通过将输出层的误差进行反向传播，层层传递。</p>
<p>首先，我们根据输出层的误差传播可以计算等到输出层前置连接 <span
class="math inline">\(w_{1,1}\)</span>、<span
class="math inline">\(w_{1,2}\)</span>、<span
class="math inline">\(w_{2,1}\)</span>、<span
class="math inline">\(w_{2,2}\)</span>
各自的误差分量，然后即可计算得到隐藏层节点的误差值 <span
class="math inline">\(e_1\)</span>、<span
class="math inline">\(e_2\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-29.png?x-oss-process=image/resize,w_800" /></p>
<p>由此方法继续计算，可以进一步得出隐层层前置连接各自的误差分量，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-28.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="矩阵运算">矩阵运算</h3>
<p>对于各个层的误差值的计算，我们同样可以使用矩阵来表示。我们使用 <span
class="math inline">\(error_{output}\)</span> 来表示输出层误差，使用
<span class="math inline">\(error_{hidden}\)</span>
来表示隐藏层误差，其表示如下。</p>
<span class="math display">\[\begin{aligned}
error_{output} = &amp;
\left(
\begin{matrix}
e_1
\\
e_2
\end{matrix}
\right)
\\
\\
error_{hidden} = &amp;
\left(
\begin{matrix}
\frac{w_{1,1}}{w_{1,1} + w_{2,1}} &amp; \frac{w_{1,2}}{w_{1,2} +
w_{2,2}}
\\
\frac{w_{2,1}}{w_{2,1} + w_{1,1}} &amp; \frac{w_{2,2}}{w_{2,2} +
w_{1,2}}
\end{matrix}
\right)
\cdot
\left(
\begin{matrix}
e_1
\\
e_2
\end{matrix}
\right)
\end{aligned}\]</span>
<p><span class="math inline">\(error_{hidden}\)</span>
的矩阵定义比较复杂，有没有办法进行简化呢？我们观察到，最终要的是输出误差与链接权重
<span class="math inline">\(w_{i,j}\)</span>
的乘法。更大的权重意味着更多的输出误差给隐藏层。这里的分母只是一种归一化因此，如果我们忽略这个因子，那么我们仅仅时区了误差的大小，但是能够换来更加简单的矩阵表示，如下所示。</p>
<span class="math display">\[\begin{aligned}
error_{hidden} = &amp;
\left(
\begin{matrix}
w_{1,1} &amp; w_{1,2}
\\
w_{2,1} &amp; w_{2,2}
\end{matrix}
\right)
\cdot
\left(
\begin{matrix}
e_1
\\
e_2
\end{matrix}
\right)
\end{aligned}\]</span>
<p>对比之前的权重矩阵 <span
class="math inline">\(W_{hidden\_output}\)</span>，可以发现这里的矩阵其实就是
<span class="math inline">\(W_{hidden\_output}\)</span>
的转置矩阵，因此我们可以将表示式进一步转换成如下所示。</p>
<span class="math display">\[\begin{aligned}
error_{hidden} = W^T_{hidden\_output} \cdot error_{output}
\end{aligned}\]</span>
<h2 id="权重更新">权重更新</h2>
<p>了解了误差分割与传播后，我们再来看看神经网络是如何通过误差来对权重进行更新，从而达到学习的目的。</p>
<p>事实上，我们很容易就可以基于神经网络的正向信号转换过程，推导出反向权重更新过程。由于正向过程中，神经元对信号依次进行求和函数、激活函数的处理，并且层与层之间是相互依赖的。对于一个
3 x 3
的神经网络，输出层的某个节点的计算公式将非常复杂，如下所示。一旦神经玩网络的节点数量、层级数量增加，计算公式会更加复杂，基于此进行逆向的权重更新，将会变得极其复杂！</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-30.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="梯度下降法">梯度下降法</h3>
<p>为此，研究人员提出了一种 <strong>梯度下降</strong>（Gradient
Descent） 的方法来绕过这个问题，解决这个问题。</p>
<p>我们来举一个例子说明一下说明是梯度下降法。想象一下，一个非常复杂、有山峰山谷的群山峻岭。在黑夜中，伸手不见五指。此时，你在某个山坡上，需要到坡底，手里只有一把手电筒，你该怎么做呢？你只能通过手电筒看到脚下的土地是上坡还是下坡，于是你就小步地往这个方向走。通过这种方式，不需要完整的底图，也不需要事先指定路线，缓慢地前进，慢慢地下山。这种方法，在数学上被称为梯度下降。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-31.png?x-oss-process=image/resize,w_800" /></p>
<p>那么梯度下降法与神经网络有什么关系呢？其实，我们可以寻找一个误差函数
<span class="math inline">\(y = f(x)\)</span>，<span
class="math inline">\(y\)</span> 表示误差值，<span
class="math inline">\(x\)</span>
表示连接的权重值。对于神经网络的样本训练而言，本质上就是找到最小误差值所对应的权重值，从而更新权重，达到学习的目的。</p>
<p>为了正确理解梯度下降的思想，我们来使用一个简单的例子来演示一下。假设，误差函数为
<span class="math inline">\(y = (x-1)^2 + 1\)</span>。我们希望找到 <span
class="math inline">\(x\)</span>，从而最小化误差 <span
class="math inline">\(y\)</span>。那么我们可以通过判断斜率（也称梯度）的方式来寻找，当斜率为负时，<span
class="math inline">\(x\)</span> 可以尝试适当增大；当斜率为正时，<span
class="math inline">\(x\)</span>
可以尝试适当减小，通过这种方式逐步逼近，从而找到最小值，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-32.png?x-oss-process=image/resize,w_800" /></p>
<p>为了提高训练学习的效率，我们可以动态调节步长。当梯度较大时，可以使用较大的步长，提高学习效率；当梯度较小时，可以使用较小的步长，避免调整过度。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-33.png?x-oss-process=image/resize,w_800" /></p>
<p>实际情况下，神经网络中的误差函数并不一定那么简单，它可能会有多个局部最小值。为了避免终止于错误的函数最小值，我们可以使用不同的起点（权重初值值）来进行多次训练。如下图所示，我们使用梯度下降法进行了三次尝试，其中有一次终止于错误的最小值。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-34.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="误差函数">误差函数</h3>
<p>神经网络具有非常多的节点和连接，那么我们该如何使用误差函数来描述这么多的连接权重并实现权重更新呢？这里我们针对每一个层都会使用一个误差函数来批量描述连接权重与误差的关系。</p>
<h4 id="误差表示">误差表示</h4>
<p>由于每一个层都包含多个节点，我们需要对每个节点的误差进行聚合。此时需要考虑多个误差值的情况下如何表示总体误差，对此下面列出了针对
3 个输出节点的神经网络的几种误差表示方法。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-35.png?x-oss-process=image/resize,w_800" /></p>
<p>方案一：误差 = 目标值 -
实际值。这种方案描述误差的方法非常直观，但是在处理多节点的误差聚合时，会出现总和为
0 的情况，这会导致神经网络无法得到很好的训练。</p>
<p>方案二：误差 = |目标值 -
实际值|。这种方案解决了多节点的误差聚合可能为 0
的问题。但是它的斜率（或称梯度），在最小值附近会出现跳变，从而导致梯度下降法无法很好地发挥作用。下图所示对应的函数及其导数。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-36.png?x-oss-process=image/resize,w_800" /></p>
<p>方案三：误差 = (目标值 -
实际值)^2。这种方案即解决了多节点的误差聚合可能为 0
的问题，也解决了斜率跳变的问题。因此，我们采用这种方案作为误差的计算方式。</p>
<h4 id="斜率推导">斜率推导</h4>
<p>要使用梯度下降法，我们必须要计算出误差函数相对权重的斜率，这里涉及到微积分的知识。这里如果你对微积分不太熟悉也没关系，我们只要知道最后推导出来的公式即可。</p>
<p>下图所示分别展示了包含一个权重和两个权重的误差函数及其斜率的示意图。当误差函数中每增加一个权重变量时，函数就会增加一个维度。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-37.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们先来看隐藏层和输出层之间的连接权重。我们使用 <span
class="math inline">\(w_{i,k}\)</span>
表示隐藏层和输出层之间的连接权重，使用 <span
class="math inline">\(n\)</span> 表示输层节点的数量，然后对误差函数
<span class="math inline">\(E\)</span> 进行展开，得到如下表示。</p>
<span class="math display">\[\begin{aligned}
\frac{\partial E}{\partial w_{j,k}} = \frac{\partial \sum_n(t_n -
o_n)^2}{\partial w_{j,k}}
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-38.png?x-oss-process=image/resize,w_800" /></p>
<p>注意，在节点 <span class="math inline">\(n\)</span> 的输出 <span
class="math inline">\(o_n\)</span>
只取决于链接到这个节点的连接。对于单个输出节点 <span
class="math inline">\(k\)</span>，其只依赖于与它连接的节点及其权重。因此，我们可以进一步简化表达式，如下所示。</p>
<span class="math display">\[\begin{aligned}
\frac{\partial E}{\partial w_{j,k}} = \frac{\partial (t_k -
o_k)^2}{\partial w_{j,k}}
\end{aligned}\]</span>
<p>为了继续推导，我们利用链式法则对斜率表达式进行拆分，进而推导，如下所示。</p>
<span class="math display">\[\begin{aligned}
\frac{\partial E}{\partial w_{j,k}} = &amp;
\frac{\partial E}{\partial o_k} \cdot  \frac{\partial o_k}{\partial
w_{j,k}} \\
= &amp;
-2(t_k - o_k) \cdot \frac{\partial o_k}{\partial w_{j,k}} \\
\end{aligned}\]</span>
<p>输出层的输出 <span class="math inline">\(o_k\)</span>
依赖隐藏层的输出 <span
class="math inline">\(o_j\)</span>，然后经过输出层节点应用求和函数、激活函数，从而转换成
<span class="math inline">\(o_k\)</span>。因此，我们可以继续推导。</p>
<span class="math display">\[\begin{aligned}
\frac{\partial E}{\partial w_{j,k}} = &amp;
\frac{\partial E}{\partial o_k} \cdot  \frac{\partial o_k}{\partial
w_{j,k}} \\
= &amp;
-2(t_k - o_k) \cdot \frac{\partial o_k}{\partial w_{j,k}} \\
= &amp;
-2(t_k - o_k) \cdot \frac{\partial sigmoid(\sum_j w_{j,k} \cdot
o_j)}{\partial w_{j, k}} \\
\end{aligned}\]</span>
<p>接下来涉及到微分 sigmoid
函数，这里我们直接使用数学家们已经推导出来的结果进行应用，如下所示。</p>
<span class="math display">\[\begin{aligned}
\frac{\partial sigmoid(x)}{\partial x} = sigmoid(x) (1 - sigmoid(x))
\end{aligned}\]</span>
<p>将该结果代入上述斜率推导中，得到：</p>
<span class="math display">\[\begin{aligned}
\frac{\partial E}{\partial w_{j,k}} = &amp;
-2(t_k - o_k) \cdot sigmoid(\sum_j w_{j,k} \cdot o_j) (1- sigmoid(\sum_j
w_{j,k} \cdot o_j)) \cdot \frac{\partial \sum_j w_{j,k} \cdot
o_j}{\partial w_{j, k}} \\
= &amp;
-2(t_k - o_k) \cdot sigmoid(\sum_j w_{j,k} \cdot o_j) (1- sigmoid(\sum_j
w_{j,k} \cdot o_j)) \cdot o_j
\end{aligned}\]</span>
<p>由于在梯度下降法中，我们只关注斜率的方向，所以可以进一步去掉系数
<code>2</code>，从而得到如下斜率表达式。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-39.png?x-oss-process=image/resize,w_800" /></p>
<p>由于权重改变方向与梯度方向相反，结合学习率 <span
class="math inline">\(\alpha\)</span>，我们可以得到权重更新前后的关系式，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-40.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="矩阵表示">矩阵表示</h4>
<p>为了推导矩阵表示，我们尝试使用矩阵乘法的形式进行计算，可以得到如下所示的表示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-41.png?x-oss-process=image/resize,w_800" /></p>
<p>我们可以发现矩阵表达式中的最后一部分，其实就是前一层 <span
class="math inline">\(o_j\)</span>
的输出的转置。最后，我们可以得到权重更新矩阵的矩阵表达式，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-42.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了人工神经网络工作的基本原理，从而能够对它产生一个初步认知，有利于后续的进阶学习。</p>
<p>首先，我们以一个分类器结构介绍了机器学习的基本思想。在此基础上进行扩展，组合多个分类器，这也是人工神经网络的基本思想。</p>
<p>然后，我们介绍了神经网络正向的信号转换过程，其中涉及连接权重、求和函数、激活函数等。此外，我们还介绍了神经网络的训练的相关概念，包括：误差分割、误差传播、权重更新等。关于权重更新，我们重点介绍了误差函数及斜率的推导。</p>
<p>后续有时间我们将进一步介绍如何使用 Python
打造一个简单的人工神经网络。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《Python神经网络编程》</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>激活函数</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 关联对象与 Method Swizzling</title>
    <url>/2018/11/23/oc-associate-object-and-method-swizzling/</url>
    <content><![CDATA[<h1 id="关联对象">关联对象</h1>
<p>关联对象，顾名思义，即通过唯一键（<code>key</code>）连接（关联）至某个类的实例上的对象。</p>
<p>那么什么时候会用到关联对象呢？</p>
<span id="more"></span>
<p>比如，我们需要对内置类 <code>NSArray</code>
添加一个属性（不使用继承）。如何解决？分类似乎只能添加方法。当我们了解关联对象后，就可以轻松实现。</p>
<h2 id="关联对象基础">关联对象基础</h2>
<h3 id="设置关联对象">设置关联对象</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>object</code>: 与谁关联，通常是 <code>self</code></li>
<li><code>key</code>: 唯一键，在获取值时通过该键获取，通常是使用
<code>static const void *</code> 来声明</li>
<li><code>value</code>: 关联所设置的值</li>
<li><code>policy</code>: 内存管理策略</li>
</ul>
<h4 id="内存管理策略">内存管理策略</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,             // 表示弱引用关联，通常是基本数据类型</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,   // 表示强引用关联对象，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,     // 表示关联对象copy，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,         // 表示强引用关联对象，不是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403            // 表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当对象释放时，会根据设置关联对象时采用的策略来决定是否释放关联对象。当策略为
<code>RETAIN/COPY</code> 时，释放关联对象。当策略为 <code>ASSIGN</code>
时，不释放关联对象。</p>
<h3 id="获取关联对象">获取关联对象</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>object</code>: 与谁关联，通常是传
<code>self</code>，在设置关联时所指定的与哪个对象关联的那个对象</li>
<li><code>key</code>: 唯一键，在设置关联值所指定的键</li>
</ul>
<h3 id="取消关联对象">取消关联对象</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>
<p>取消对象的所有关联对象。如果要取消指定的关联对象，可使用
<code>setAssociatedObject</code> 设置为 <code>nil</code> 来实现。</p>
<h3 id="关联对象应用">关联对象应用</h3>
<p>给 <code>UIViewController</code> 添加一个是否需要登录的属性。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL needToLogin;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const char *ViewControllerNeedToLoginKey = &quot;ViewControllerNeedToLoginKey&quot;;</span><br><span class="line"></span><br><span class="line">- (void)setNeedToLogin:(BOOL)needToLogin &#123;</span><br><span class="line">    objc_setAssociatedObject(self, ViewControllerNeedToLoginKey, @(needToLogin), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)needToLogin &#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, ViewControllerNeedToLoginKey) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="method-swizzling">Method Swizzling</h1>
<p>Method Swizzling，顾名思义，就是将两个方法的实现交换。</p>
<p>那么什么时候会用到 Method Swizzling 呢？</p>
<p>比如，在开发中，我们可能会遇到系统提供的 API
不能满足实际需求。我们希望能够修改它以达到期望的效果。</p>
<h2 id="method-swizzling-原理">Method Swizzling 原理</h2>
<p>Method Swizzling 的实现充分利用了 <a
href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C
runtime 动态绑定机制</a>。</p>
<p>在 Objective-C
中调用方法，其实是向一个对象发送消息，而查找消息的唯一依据是方法名
<code>selector</code>。每个类都有一个方法列表
<code>objc_method_list</code>，存放着其所有的方法
<code>objc_method</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个方法 <code>objc_method</code>
保存了方法名（<code>SEL</code>）和方法实现（<code>IMP</code>）的映射关系。Method
Swizzling 其实就是重置了 <code>SEL</code> 和 <code>IMP</code>
的映射关系。如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-method-swizzling.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="method-swizzling-基础">Method Swizzling 基础</h2>
<h3 id="获取方法">获取方法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>cls</code>: 目标类</li>
<li><code>name</code>: 方法名</li>
</ul>
<h3 id="获取方法实现">获取方法实现</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMP _Nonnull class_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name) </span><br></pre></td></tr></table></figure>
<h3 id="添加方法">添加方法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>cls</code>: 目标类</li>
<li><code>name</code>: 要添加方法的方法名</li>
<li><code>imp</code>: 要添加方法的方法实现</li>
<li><code>types</code>: 方法实现的编码类型</li>
</ul>
<h3 id="替换方法">替换方法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMP _Nullable class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types) </span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>cls</code>: 目标类</li>
<li><code>name</code>: 目标方法的方法名</li>
<li><code>imp</code>: 方法的新方法实现</li>
<li><code>types</code>: 方法实现的编码类型</li>
</ul>
<h3 id="交换方法实现">交换方法实现</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) </span><br></pre></td></tr></table></figure>
<h3 id="获取方法的编码类型">获取方法的编码类型</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char * _Nullable method_getTypeEncoding(Method _Nonnull m) </span><br></pre></td></tr></table></figure>
<h2 id="method-swizzling-应用">Method Swizzling 应用</h2>
<p>通过分类允许 <code>NSObject</code> 对任意两个方法进行 Method
Swizzling。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@implementation NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSEL);</span><br><span class="line">    if (originalMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(self, targetSEL);</span><br><span class="line">    if (targetMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_addMethod(self, originalSEL, class_getMethodImplementation(self, originalSEL), method_getTypeEncoding(originalMethod));</span><br><span class="line">    class_addMethod(self, targetSEL, class_getMethodImplementation(self, targetSEL), method_getTypeEncoding(targetMethod));</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod(self, originalSEL), class_getInstanceMethod(self, targetSEL));</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Class metaClass = object_getClass((id)self);</span><br><span class="line">    return [metaClass swizzleMethod:originalSEL withMethod:targetSEL error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://www.jianshu.com/p/3efc3e94b14c">iOS
runtime实战应用：Method Swizzling</a></li>
<li><a href="https://www.jianshu.com/p/c68cc81ef763">iOS
runtime实战应用：关联对象</a></li>
<li><a href="https://www.jianshu.com/p/3efc3e94b14c">iOS
runtime实战应用：Method Swizzling</a></li>
<li><a
href="https://www.jianshu.com/p/adf0d566c887">iOS运行时(Runtime)详解+Demo</a></li>
</ol>
]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>关联对象</tag>
        <tag>Method Swizzling</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——ohmyzsh</title>
    <url>/2020/11/01/oh-my-zsh/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oh-my-zsh-logo.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>最近在做一个 shell
项目——NOX，在开发过程中遇到了一些设计方面的问题。为了能够得到一些灵感，我将注意力放到了
github 上 star 数量最高的 shell 项目——ohmyzsh。本文将记录我阅读 ohmyzsh
源码后，对于其设计的一些理解。</p>
<h1 id="概述">概述</h1>
<p>Ohmyzsh（下文简称 OMZ）
是一个由开发者社区驱动的开源框架，用于管理我们的 zsh 配置。OMZ
提供了大量的插件，能够有效提升我们的命令行工作效率。此外，OMZ
提供了大量的主题，通过主题配置我们可以将终端打造得极具极客范！</p>
<h1 id="目录结构">目录结构</h1>
<p>我们首先来看一下 OMZ 的目录结构，如下图所示。根据
<code>.gitignore</code> 中的定义，我们可以大概能够猜测到：</p>
<ul>
<li><code>cache</code> 目录用于存放 OMZ
运行时产生的缓存文件。<code>cache</code> 目录不加入 git 管理。</li>
<li><code>custom</code>
目录用于存放用户自定义的一些插件或主题，该目录下默认有两个子目录
<code>plugins</code> 和 <code>themes</code>
分别用户存放插件和主题。比如：我们可以将
<code>https://github.com/zsh-users/zsh-completions</code> 克隆到
<code>custom/plugins</code>
目录下，作为自定义的插件集合。<code>custom</code> 目录不加入 git
管理。</li>
<li><code>lib</code> 目录下的一系列文件定义了诸多 shell
工具方法。下文我们将具体进行介绍。</li>
<li><code>log</code> 目录应该用户存放 OMZ
运行时产生的日志缓存文件。<code>log</code> 目录不加入 git 管理。</li>
<li><code>plugins</code> 目录存放了 OMZ
项目所管理的插件。该目录下的子目录数量庞大，其中每一个子目录对应一个工具，如：<code>xcode</code>
目录对应 Xcode，该目录下存放的文件可分为两类：一是以 <code>_</code>
为前缀的自动补全文件；二是以 <code>.plugin.zsh</code>
为后缀的插件文件。我们可以通过设置 <code>.zshrc</code> 中的
<code>plugins</code> 数组变量来选择加载的插件。</li>
<li><code>templates</code> 目录存放了一个 zsh 配置文件的模板。</li>
<li><code>themes</code> 目录存放了大量主题，文件命名方式遵循
<code>主题名称</code> + <code>.zsh-theme</code> 的规则。我们可以通过设置
<code>.zshrc</code> 中的 <code>ZSH_THEME</code> 变量来选择主题。</li>
<li><code>tools</code> 目录包含了一系列 OMZ
系统相关的重要脚本，如：安装、卸载、检查更新、执行更新等。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/omz-directory.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="安装方式">安装方式</h1>
<p>从 <code>tools/install.sh</code> 脚本中，我们能够看出 OMZ
的安装过程可以分为以下五个步骤：</p>
<ul>
<li>设置变量</li>
<li>环境检查</li>
<li>设置 OMZ</li>
<li>设置 zshrc</li>
<li>设置 shell</li>
</ul>
<h2 id="设置变量">设置变量</h2>
<p>第一步 <strong>设置变量</strong>
中设置的变量包含两类：基础设置相关的变量、执行选项相关的变量。</p>
<p>基础设置相关的变量包括以下这些：</p>
<ul>
<li><code>ZSH</code>：表示 OMZ 仓库的路径，默认是
<code>$HOME/.oh-my-zsh</code>。</li>
<li><code>REPO</code>：表示仓库名称，默认是
<code>ohmyzsh/ohmyzsh</code>。</li>
<li><code>REMOTE</code>：表示 OMZ 仓库的远程地址，默认是
<code>https://github.com/$&#123;REPO&#125;.git</code>。</li>
<li><code>BRANCH</code>：表示安装 OMZ 时所对应的仓库分支，默认是
<code>master</code>。</li>
</ul>
<p>执行选项相关的变量包括以下这些：</p>
<ul>
<li><code>CHSH</code>：表示安装 OMZ 时是否会切换默认的 shell，默认是
<code>yes</code>。</li>
<li><code>RUNZSH</code>：表示是否会在安装后运行 zsh，默认是
<code>yes</code>。</li>
<li><code>KEEP_ZSHRC</code>：表示是否会替换已有的
<code>.zshrc</code>，默认是 <code>no</code>。</li>
</ul>
<p>在执行 <code>install.sh</code>
脚本时，我们可以通过传入特定选项来设置执行选项相关的变量。如：</p>
<ul>
<li><code>--skip-chsh</code> 选项：将 <code>CHSH</code> 设置为
<code>no</code>。</li>
<li><code>--unattended</code> 选项：将 <code>CHSH</code> 和
<code>RUNZSH</code> 均设置为 <code>no</code>。</li>
<li><code>--keep-zshrc</code> 选项：将 <code>KEEP_ZSHRC</code> 设置为
<code>yes</code>。</li>
</ul>
<h2 id="环境检查">环境检查</h2>
<p>第二步 <strong>环境检查</strong> 中主要判断了两种情况：</p>
<ul>
<li>zsh 未安装的情况下，退出 OMZ 的安装</li>
<li>OMZ 已安装的情况下，退出 OMZ 的安装</li>
</ul>
<h2 id="设置-omz">设置 OMZ</h2>
<p>第三步 <strong>设置 OMZ</strong> 的任务主要是根据第一步中所设置的变量
<code>REPO</code>、<code>REMOTE</code>、<code>ZSH</code>，通过
<code>git</code> 将远程仓库克隆到本地。</p>
<h2 id="设置-zshrc">设置 zshrc</h2>
<p>第四步 <strong>设置 zshrc</strong>，顾名思义，就是设置
<code>~/.zshrc</code> 文件。这里会用到第一步中所设置的变量
<code>ZSH</code> 和 <code>KEEP_ZSHRC</code>。</p>
<p>当 <code>KEEP_ZSHRC</code> 为 <code>yes</code> 时，则跳过本步骤。</p>
<p>当 <code>KEEP_ZSHRC</code> 为 <code>no</code> 时，会先将原有的
<code>~/.zshrc</code> 备份为
<code>~/.zshrc.pre-oh-my-zsh</code>，用于卸载时进行恢复。然后将
<code>templates</code> 目录下的 <code>zshrc.zsh-template</code> 拷贝为
<code>~/.zshrc</code>，同时将 <code>ZSH</code> 变量的设置导入至
<code>~/.zshrc</code> 中。</p>
<p><code>~/.zshrc</code>
设置完之后，其内部默认开启的配置并不多，如下所示。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Path to your oh-my-zsh installation.</span><br><span class="line">export ZSH=$HOME/.oh-my-zsh</span><br><span class="line"></span><br><span class="line">ZSH_THEME=&quot;robbyrussell&quot;</span><br><span class="line"></span><br><span class="line">plugins=(git)</span><br><span class="line"></span><br><span class="line">source $ZSH/oh-my-zsh.sh</span><br></pre></td></tr></table></figure>
每次启动 zsh 时都会执行 <code>~/.zshrc</code> 中定义的命令。OMZ 默认在
<code>~/.zshrc</code> 中设置了
<code>ZSH</code>、<code>ZSH_THEME</code>、<code>plugins</code>
三个变量，此外还定义了每次启动 zsh 时执行 <code>oh-my-zsh.sh</code>
脚本，对 OMZ 进行初始化。</p>
<h2 id="设置-shell">设置 shell</h2>
<p>第五步 <strong>设置 shell</strong>
的任务主要是根据第一步中所设置的变量 <code>CHSH</code>
来决定是否将默认的 shell 切换成 zsh。</p>
<h1 id="omz-初始化">OMZ 初始化</h1>
<p>在上一节 <strong>安装方式</strong> 的 <strong>设置 zshrc</strong>
小结中，我们提到每次启动 zsh 时都会执行 <code>oh-my-zsh.sh</code> 脚本对
OMZ 进行初始化。那么这个初始化过程具体包含哪些内容呢？如下所示为
<code>oh-my-zsh.sh</code> 的源代码。</p>
<p>OMZ 初始化的主要步骤包括：</p>
<ul>
<li>默认路径设置，如：<code>ZSH</code>、<code>ZSH_CACHE_DIR</code>、<code>fpath</code>、<code>ZSH_CUSTOM</code>、<code>ZSH_COMPDUMP</code>
等</li>
<li>检查更新</li>
<li>初始化补全系统，包括：预设 <code>fpath</code> 变量、创建
<code>.zcompdump</code> 文件等</li>
<li>加载 lib</li>
<li>加载插件</li>
<li>加载自定义配置</li>
<li>加载主题</li>
</ul>
<p>详细初始化过程可以阅读如下所示的源代码。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 如果 `ZSH` 变量没有设置，则将 `ZSH` 设置为当前 `oh-my-zsh.sh` 脚本所在的目录路径</span></span><br><span class="line">[[ -z <span class="string">&quot;<span class="variable">$ZSH</span>&quot;</span> ]] &amp;&amp; <span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$&#123;<span class="variable">$&#123;(%):-%x&#125;</span>:a:h&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 如果 `ZSH_CACHE_DIR` 变量没有设置，则将 `ZSH_CACHE_DIR` 设置为 `cache` 目录路径，用于存放缓存文件。</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$ZSH_CACHE_DIR</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  ZSH_CACHE_DIR=<span class="string">&quot;<span class="variable">$ZSH</span>/cache&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 检查更新</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DISABLE_AUTO_UPDATE</span>&quot;</span> != <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$ZSH</span>/tools/check_for_upgrade.sh</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 OMZ</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 为 `fpath` 变量增加两个索引路径，即使这两个路径在当前仓库中并不存在。`fpath` 类似于 `PATH`，zsh 启动时会加载 `fpath` 路径下的所有脚本文件。</span></span><br><span class="line">fpath=(<span class="variable">$ZSH</span>/functions <span class="variable">$ZSH</span>/completions <span class="variable">$fpath</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 根据 `fpath` 变量加载所有后面会用到的库函数</span></span><br><span class="line"><span class="built_in">autoload</span> -U compaudit compinit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 如果 `ZSH_CUSTOM` 变量没有设置，则将 `ZSH_CUSTOM` 设置为 `custom` 目录路径，用于存放自定义配置文件和插件。</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    ZSH_CUSTOM=<span class="string">&quot;<span class="variable">$ZSH</span>/custom&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">is_plugin</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> base_dir=<span class="variable">$1</span></span><br><span class="line">  <span class="built_in">local</span> name=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">builtin</span> <span class="built_in">test</span> -f <span class="variable">$base_dir</span>/plugins/<span class="variable">$name</span>/<span class="variable">$name</span>.plugin.zsh \</span><br><span class="line">    || <span class="built_in">builtin</span> <span class="built_in">test</span> -f <span class="variable">$base_dir</span>/plugins/<span class="variable">$name</span>/_<span class="variable">$name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 将 `~/.zshrc` 中 `plugins` 变量所指定的插件路径加入到 `fpath` 变量中。`ZSH_CUSTOM` 中的自定义插件的优先级比 OMZ 提供的插件的优先级更高。所有的插件会在执行 `compinit` 之前加载完成。</span></span><br><span class="line"><span class="keyword">for</span> plugin (<span class="variable">$plugins</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> is_plugin <span class="variable">$ZSH_CUSTOM</span> <span class="variable">$plugin</span>; <span class="keyword">then</span></span><br><span class="line">    fpath=(<span class="variable">$ZSH_CUSTOM</span>/plugins/<span class="variable">$plugin</span> <span class="variable">$fpath</span>)</span><br><span class="line">  <span class="keyword">elif</span> is_plugin <span class="variable">$ZSH</span> <span class="variable">$plugin</span>; <span class="keyword">then</span></span><br><span class="line">    fpath=(<span class="variable">$ZSH</span>/plugins/<span class="variable">$plugin</span> <span class="variable">$fpath</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[oh-my-zsh] plugin &#x27;<span class="variable">$plugin</span>&#x27; not found&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 设置 `SHORT_HOST` 变量</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$OSTYPE</span>&quot;</span> = darwin* ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># macOS&#x27;s $HOST changes with dhcp, etc. Use ComputerName if possible.</span></span><br><span class="line">  SHORT_HOST=$(scutil --get ComputerName 2&gt;/dev/null) || SHORT_HOST=<span class="variable">$&#123;HOST/.*/&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  SHORT_HOST=<span class="variable">$&#123;HOST/.*/&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 设置 `ZSH_COMPDUMP` 变量，`.zcompdump` 文件用于加速 `compinit` 的执行（在 zsh 中，`compinit` 用于初始化 shell 补全）</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  ZSH_COMPDUMP=<span class="string">&quot;<span class="variable">$&#123;ZDOTDIR:-<span class="variable">$&#123;HOME&#125;</span>&#125;</span>/.zcompdump-<span class="variable">$&#123;SHORT_HOST&#125;</span>-<span class="variable">$&#123;ZSH_VERSION&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. 构建 zcompdump OMZ metadata，本质上就是用 OMZ git 仓库当前的 commit 号进行区分 </span></span><br><span class="line">zcompdump_revision=<span class="string">&quot;#omz revision: <span class="subst">$(builtin cd -q <span class="string">&quot;<span class="variable">$ZSH</span>&quot;</span>; git rev-parse HEAD 2&gt;/dev/null)</span>&quot;</span></span><br><span class="line">zcompdump_fpath=<span class="string">&quot;#omz fpath: <span class="variable">$fpath</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. 如果 OMZ zcompdump metadata 发生变化，则删除 `.zcompdump` 文件</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">command</span> grep -q -Fx <span class="string">&quot;<span class="variable">$zcompdump_revision</span>&quot;</span> <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> 2&gt;/dev/null \</span><br><span class="line">   || ! <span class="built_in">command</span> grep -q -Fx <span class="string">&quot;<span class="variable">$zcompdump_fpath</span>&quot;</span> <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span> <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span></span><br><span class="line">  zcompdump_refresh=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 12. 执行 compinit，生成 `.zcompdump` 文件</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$ZSH_DISABLE_COMPFIX</span> != <span class="literal">true</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$ZSH</span>/lib/compfix.zsh</span><br><span class="line">  <span class="comment"># If completion insecurities exist, warn the user</span></span><br><span class="line">  handle_completion_insecurities</span><br><span class="line">  <span class="comment"># Load only from secure directories</span></span><br><span class="line">  compinit -i -C -d <span class="string">&quot;<span class="variable">$&#123;ZSH_COMPDUMP&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># If the user wants it, load from all found directories</span></span><br><span class="line">  compinit -u -C -d <span class="string">&quot;<span class="variable">$&#123;ZSH_COMPDUMP&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 13. 如果 `.zcompdump` 文件不存在，则创建，并写入 zcompdump metadata</span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$zcompdump_refresh</span> )); <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Use `tee` in case the $ZSH_COMPDUMP filename is invalid, to silence the error</span></span><br><span class="line">  <span class="comment"># See https://github.com/ohmyzsh/ohmyzsh/commit/dd1a7269#commitcomment-39003489</span></span><br><span class="line">  <span class="built_in">tee</span> -a <span class="string">&quot;<span class="variable">$ZSH_COMPDUMP</span>&quot;</span> &amp;&gt;/dev/null &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$zcompdump_revision</span></span><br><span class="line"><span class="string">$zcompdump_fpath</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> zcompdump_revision zcompdump_fpath zcompdump_refresh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 14. 加载 `lib` 目录下的所有以 `.zsh` 为后缀的配置文件</span></span><br><span class="line"><span class="keyword">for</span> config_file (<span class="variable">$ZSH</span>/lib/*.zsh); <span class="keyword">do</span></span><br><span class="line">  custom_config_file=<span class="string">&quot;<span class="variable">$&#123;ZSH_CUSTOM&#125;</span>/lib/<span class="variable">$&#123;config_file:t&#125;</span>&quot;</span></span><br><span class="line">  [ -f <span class="string">&quot;<span class="variable">$&#123;custom_config_file&#125;</span>&quot;</span> ] &amp;&amp; config_file=<span class="variable">$&#123;custom_config_file&#125;</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$config_file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 15. 加载 `~/.zshrc` 中 `plugins` 变量所定义的全部插件</span></span><br><span class="line"><span class="keyword">for</span> plugin (<span class="variable">$plugins</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="variable">$ZSH_CUSTOM</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh</span><br><span class="line">  <span class="keyword">elif</span> [ -f <span class="variable">$ZSH</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="variable">$ZSH</span>/plugins/<span class="variable">$plugin</span>/<span class="variable">$plugin</span>.plugin.zsh</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 16. 加载 `custom` 目录下的所有自定义配置文件</span></span><br><span class="line"><span class="keyword">for</span> config_file (<span class="variable">$ZSH_CUSTOM</span>/*.zsh(N)); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$config_file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">unset</span> config_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 17. 加载 `~/.zshrc` 中 `ZSH_THEME` 变量所定义的主题</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$ZSH_THEME</span>&quot;</span> = <span class="string">&quot;&quot;</span>  ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span></span><br><span class="line">  <span class="keyword">elif</span> [ -f <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/themes/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH_CUSTOM</span>/themes/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">source</span> <span class="string">&quot;<span class="variable">$ZSH</span>/themes/<span class="variable">$ZSH_THEME</span>.zsh-theme&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<h1 id="更新策略">更新策略</h1>
<p>由于安装 OMZ 时，OMZ 会在 <code>~/.zshrc</code> 中加入一行代码
<code>source $ZSH/oh-my-zsh.sh</code>，从而使得每次启动 zsh 会都会执行
<code>oh-my-zsh.sh</code> 中的代码。<code>oh-my-zsh.sh</code> 中通过
<code>DISABLE_AUTO_UPDATE</code> 变量来判断是否执行更新检查，然后由
<code>check_for_upgrade.sh</code> 来决定是否进行更新，如下所示：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$DISABLE_AUTO_UPDATE</span>&quot;</span> != <span class="string">&quot;true&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="variable">$ZSH</span>/tools/check_for_upgrade.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p><code>DISABLE_AUTO_UPDATE</code> 默认未进行初始化，所以每次启动 zsh
都会进行更新检查，用户可以通过在 <code>~/.zshrc</code> 去掉对
<code>DISABLE_AUTO_TITLE="true"</code> 的注释来关闭更新检查。</p>
<p>下面，我们依次来介绍 OMZ 中的更新检查和更新执行。</p>
<h2 id="更新检查">更新检查</h2>
<p>OMZ 更新检查的主要逻辑包括以下这些步骤：</p>
<ul>
<li>读取 <code>cache/.zsh-update</code> 中的 <code>LAST_EPOCH</code>
变量，如果文件不存在或 <code>LAST_EPOCH</code>
的值为空，则写入新值并退出。<code>LAST_EPOCH</code>
表示上一次更新的时间（单位：从 1970年1月1日至当前的天数）。</li>
<li>读取更新间隔值 <code>UPDATE_ZSH_DAYS</code>，默认值为 13。如果上次
<code>LAST_EPOCH</code> 的更新时间与当前相隔 13
天及以上，那么继续后面的步骤；否则，退出。</li>
<li>根据 <code>DISABLE_UPDATE_PROMPT</code>
的值决定是否请求用户同意更新。采用交互式的方式请求用户同意。如果同意更新，则执行更新，更新完成后更新
<code>cache/.zsh-update</code> 中上次更新的时间
<code>LAST_EPOCH</code>。</li>
</ul>
<h2 id="更新执行">更新执行</h2>
<p>具体的更新操作非常简单，就是通过 <code>git pull --rebase</code>
的方式获取最新的代码。</p>
<h1 id="插件">插件</h1>
<p>插件是 OMZ 所提供的最重要的功能之一。插件主要位于 OMZ 的
<code>plugins</code> 目录下，每一个插件都有一个维护者，因此 OMZ
是一个社区驱动的开源项目。</p>
<p>那么插件究竟干了些什么呢？我们以
<code>plugins/git/git.plugin.zsh</code> 为例，进行分析。</p>
<p>总体而言，插件提供了三方面的功能。</p>
<ul>
<li>函数</li>
<li>alias</li>
<li>自动补全</li>
</ul>
<p>对于函数，插件中提供了如下所示的一些函数，这些函数我们可以在 shell
中直接调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">current_branch</span></span>() &#123;</span><br><span class="line">  git_current_branch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">work_in_progress</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> $(git <span class="built_in">log</span> -n 1 2&gt;/dev/null | grep -q -c <span class="string">&quot;\-\-wip\-\-&quot;</span>); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;WIP!!&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对于 alias，插件中则定义大量缩写以供用户快速调用命令，如下所示：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> gc=<span class="string">&#x27;git commit -v&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gc!=<span class="string">&#x27;git commit -v --amend&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcn!=<span class="string">&#x27;git commit -v --no-edit --amend&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gca=<span class="string">&#x27;git commit -v -a&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gca!=<span class="string">&#x27;git commit -v -a --amend&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcan!=<span class="string">&#x27;git commit -v -a --no-edit --amend&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcans!=<span class="string">&#x27;git commit -v -a -s --no-edit --amend&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcam=<span class="string">&#x27;git commit -a -m&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcsm=<span class="string">&#x27;git commit -s -m&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gcb=<span class="string">&#x27;git checkout -b&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>与此同时，插件还为函数定义了自动补全函数，如下所示定义
<code>ggpnp</code> 函数的自动补全与 <code>git checkout</code> 相同。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">ggpnp</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> == 0 ]]; <span class="keyword">then</span></span><br><span class="line">    ggl &amp;&amp; ggp</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ggl <span class="string">&quot;<span class="variable">$&#123;*&#125;</span>&quot;</span> &amp;&amp; ggp <span class="string">&quot;<span class="variable">$&#123;*&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggpnp=git-checkout</span><br></pre></td></tr></table></figure></p>
<p>此外，OMZ 还会提供特定的自动补全文件，一般以 <code>_</code>
为前缀，后跟具体的命令名称，如：<code>_pod</code> 为 <code>pod</code>
提供了自动补全定义。</p>
<p>我们可以对 <code>~/.zshrc</code> 的 <code>plugins</code>
变量进行修改，选择我们想要加载的插件。</p>
<p>关于 zsh 自动补全的细节，本文不作具体介绍，可以参考 <a
href="http://chuquan.me/2020/10/02/zsh-completion-tutorial/">《Zsh
自动补全脚本入门》</a> 一文。</p>
<h1 id="主题">主题</h1>
<p>主题主要用于修改 zsh
提示符和某些程序的外观，还有一些其他的行为，如：终端的 tab
和窗口标题。</p>
<p>主题通过设置各种变量来控制 zsh
提示符的外观，包括：<code>PROMPT</code>、<code>RPRPROMT</code>、<code>LSCOLORS</code>、<code>LS_COLORS</code>
等变量；此外，主题还能够安装 hook 方法，从而提供更深层次的修改。</p>
<p>我们可以对 <code>~/.zshrc</code> 的 <code>ZSH_THEME</code>
变量进行修改，选择我们想要的主题。</p>
<p>关于主题的具体实现，后面有时间写一篇文章来进行介绍。</p>
<h1 id="总结">总结</h1>
<p>总体而言，从设计角度而言，OMZ
非常简单，它使用清晰的目录结构管理插件、主题。OMZ
的安装和更新也非常简单，没有复杂的机制。由于 OMZ
提供了巨量的插件和主题，能够极大地提升用户的工作效率，从而受到了用户的热烈追捧。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28968650">Zsh
开发指南（第十八篇 更多内置模块的用法）</a></li>
</ol>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>ohmyzsh</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI 模型与 TCP-IP 协议详解</title>
    <url>/2019/03/02/osi-tcp-ip-introduce/</url>
    <content><![CDATA[<h1 id="osi-参考模型">OSI 参考模型</h1>
<p>在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着异构机型之间通信的需求不断增加，通信技术的标准化也随之展开。于是，ISO（International
Organization for Standard）制定了一个国际标准 OSI（Open System
Interconnection），即广为人知的 OSI
参考模型，作为标准化通信技术的设计准则。</p>
<span id="more"></span>
<p>OSI 参考模型将通信协议中必要的功能分层了 7
层。每个分层接收下一层提供的特定服务，并负责为上一层提供特定的服务。这些功能上相对独立的分层可以构造一个扩展性和灵活性都较强的系统。</p>
<p>下表所示为 OSI 参考模型及其各个分层的职责。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi.png?x-oss-process=image/resize,w_800" /></p>
<ul>
<li><p><strong>应用层</strong>：主要负责为应用程序提供服务并规定应用程序中通信相关的细节。在该层实现的协议有：文件传输、电子邮件、远程登录等协议。</p></li>
<li><p><strong>表示层</strong>：主要负责数据格式的转换。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。</p></li>
<li><p><strong>会话层</strong>：主要负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p></li>
<li><p><strong>传输层</strong>：主要负责进行可靠传输。只在通信双方节点上进行处理，而无需在路由器上处理。</p></li>
<li><p><strong>网络层</strong>：主要负责寻址和路由选择，从而将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某个地址。</p></li>
<li><p><strong>数据链路层</strong>：主要负责物理层面上互连的、节点之间的通信传输。将
0、1 序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。如与 1
个以太网相连的 2 个节点之间的通信。</p></li>
<li><p><strong>物理层</strong>：主要负责 0、1 比特流（0、1
序列）与电压的高低、光的闪灭之间的互换。</p></li>
</ul>
<h1 id="osi-参考模型通信示例">OSI 参考模型通信示例</h1>
<p>下面举例说明 OSI 参考模型的功能。假设使用主机 A 的用户向使用主机 B
的用户发送一封邮件。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="应用层">应用层</h2>
<p>用户 A 在主机 A 上新建一封邮件，指定收件人为 B，并输入邮件内容为
“早上好”。用户确认发送时，开始进入应用层协议的处理。该协议在传送数据的前端附加一个首部信息。主机
B 在收到主机 A
发送至的数据后，分析其数据首部与数据正文，并将邮件存入本地。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email02.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="表示层">表示层</h2>
<p>表示层会将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复成“该计算机特有的数据格式”，然后在进行相应的处理。</p>
<p>此例中，“早上好”这段文字根据编码格式被转换成了“统一的网络数据格式”。由于文字的编码格式非常多，如：UTF-8、UTF-16、Unicode
等，如果未能按照特定格式编码，那么在接收端收到的邮件可能就是乱码。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="会话层">会话层</h2>
<p>假如用户 A 新建了 5 封邮件准备发送给用户 B。这 5
封邮件的发送顺序可以有多种：</p>
<ul>
<li>每发一封邮件时建立一次连接，随后断开连接</li>
<li>一旦建立连接后，将 5 封邮件连续发送给对方</li>
<li>同时建立 5 个连接，将 5 封邮件同时发送给对方</li>
</ul>
<p>会话层的主要责任就是决定采用何种连接方式。</p>
<p>类似应用层、表示层，会话层在其收到的数据前端附加首部之后再转发给下一层。这些首部中
<strong>记录着数据传送顺序的信息</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email04.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="传输层">传输层</h2>
<p>会话层只对何时建立连接、何时发送数据等问题进行管理，并不具备实际传输数据的功能。真正负责在网络上传输数据的是会话层以下的分层。</p>
<p>主机 A 确保与主机 B
之间的通信并准备发送数据。该过程称为“建立连接”。连接建立后即可使主机 A
发送的邮件到达主机 B。传输结束之后，有必要将连接断开。</p>
<p>上述两个主机之间创建逻辑上的通信连接是传输层的主要作用。此外，传输层为确保数据到达目标地址，会在通信两端的主机之间进行确认，如果数据没有到达，则负责进行重发。</p>
<p>示例中，如果主机 A 将“早上好”发送给主机
B，由于网络异常等原因导致只有部分数据到达目标地址。假设主机 B
只收到“早上”这部分数据，那么它会将没有收到“早上”之后那部分数据的事实告诉主机
A，主机 A 得知后会将“好”重新发送给主机 B，并再次确认对端是否收到。</p>
<p>因此，保证数据传输的可靠性是传输层的一个重要作用。为了确保可靠性，传输层也会对所要传输的数据附加首部以识别这一分层的数据。然而，实际上将数据传输给对端的处理是由网络层完成的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="网络层">网络层</h2>
<p>网络层的作用是在网络与网络互连的环境中，将数据从发送端主机发送到接收端主机。如图所示，两端主机之间虽然有众多数据链路，但是能够将数据从主机
A 发送到主机 B 也都是网络层的功劳。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email06.png?x-oss-process=image/resize,w_800" /></p>
<p>网络层的数据发送通过目标地址选择对应的计算机，因此目标地址是网络中唯一指定的序号，类似于电话号码。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email07.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="数据链路层物理层">数据链路层、物理层</h2>
<p>通信传输本质上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过介质互连的设备之间进行数据处理。</p>
<p>物理层则将数据的 0、1
转换为电压和脉冲光传输给物理的传输介质，而<strong>相互直连的设备之间使用地址实现传输</strong>。这种地址被称为
<strong>MAC</strong> 地址。<strong>采用 MAC
地址，目的是为了识别连接同一传输介质上的设备</strong>。物理层会将包含
MAC
地址的信息的首部附加到同网络层转发过来的数据上，并将其发送到网络中。</p>
<p>网络层与数据链路层都是基于目标地址将数据发送给接收端，其区别在于： -
<strong>网络层负责将整个数据发送给最终的目标地址</strong> -
<strong>数据链路层只负责发送一个分段内的数据</strong></p>
<p>详见上图。</p>
<h1 id="tcpip-协议分层模型">TCP/IP 协议分层模型</h1>
<h2 id="tcpip-的含义">TCP/IP 的含义</h2>
<p>从字面上看，有人可能会认为 TCP/IP 是指 TCP 与 IP
两种协议。虽然实际中的确有这两种协议，但是在很多情况下，它泛指
IP、ICMP、TCP、UDP、TELNET、FTP、HTTP 等协议群，所以有时也称 TCP/IP 为
<strong>网际协议族</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-protocols.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="数据包">数据包</h2>
<p><strong>包、帧、数据报、段、消息</strong>
等五个术语都用来表述数据的单位，其区别在于：</p>
<ul>
<li>包：全能性术语</li>
<li>帧：表示数据链路层中包的单位</li>
<li>数据报：表示 IP 和 UDP 等网络层以上分层中包的单位</li>
<li>段：表示 TCP 数据流中的信息</li>
<li>消息：表示应用层中数据的单位</li>
</ul>
<p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上层传来的数据。在数据包的首部，明确标明了协议应该如何读取数据。通过解析首部，能够了解该协议必要的信息以及要处理的内容。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-data-header.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="tcpip-与-osi-参考模型">TCP/IP 与 OSI 参考模型</h2>
<p>关于 TCP/IP 与 OSI 参考模型的关系，我们可以认为 TCP/IP 是对 OSI
参考模型的一种具体实现。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-ois-compare.png?x-oss-process=image/resize,w_800" /></p>
<ul>
<li><strong>硬件（物理层）</strong>
<ul>
<li>TCP/IP
的最底层是负责数据传输的硬件，如以太网或电话线路等物理层的设备。物理层所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等都会有所不同。</li>
</ul></li>
<li><strong>网络接口层（数据链路层）</strong>
<ul>
<li>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层，可认为是让
NIC（网卡）正常工作的驱动程序。</li>
</ul></li>
<li><strong>互联网层（网络层）</strong>
<ul>
<li>互联网层使用 IP 协议，对应 OSI 模型中的第 3 层网络层。IP 协议基于 IP
地址转发分组数据包。</li>
<li>TCP/IP
分层中的互联网层与传输层的功能通常由操作系统实现。尤其是路由器，它必须实现通过互联网曾转发分组数据包的功能。连接互联网的所有主机和路由器都必须实现
IP 的功能。</li>
</ul></li>
</ul>
<blockquote>
<p><strong>为什么要分组？</strong><br />
首先需要明确一个事实：一台计算机在收发数据时会独占其所在的整条通信线路。如果一条线路上连接了多台计算机，当计算机相互之间进行数据传输时，则需要等待线路中没有其他计算机占用时才能进行数据传输。如果某台计算机占用线路之后传输大量数据，则其他计算机始终保持等待状态。极端情况下根本无法进行通信。<br />
采用分组（交换）技术，数据会被分成更小的单元，所有的计算机就可以并发收发数据，从而提高了通信线路的利用率。</p>
</blockquote>
<blockquote>
<p><strong>IP</strong><br />
IP 是跨越网络传送数据包，使整个互联网都能收到数据的协议，这个过程中使用
IP 地址作为主机的标识。<br />
IP 还隐含着数据链路的功能。通过
IP，相互通信的主机之间无论经过怎样的底层数据链路都能够实现通信。<br />
IP
是分组交换的一种协议，但其并不具备重发机制。即使分组数据包未能达到对端主机也不会重发，属于非可靠传输协议。</p>
</blockquote>
<blockquote>
<p><strong>ICMP</strong><br />
IP
数据包在发送途中一旦出现异常导致无法到达对端目标地址时，需要向发送端发送一个异常通知。ICMP
就是为这一功能而定制的，常用于 <strong>诊断网络的健康状况</strong>。</p>
</blockquote>
<blockquote>
<p><strong>ARP</strong><br />
从分组数据包的 IP 地址中解析出物理地址（MAC 地址）的一种协议。</p>
</blockquote>
<ul>
<li><strong>传输层</strong>
<ul>
<li>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同时运行着多个程序。为了识</li>
<li>别哪些程序之间在进行通信，使用 <strong>端口号</strong>
进行区分。</li>
</ul></li>
</ul>
<blockquote>
<p><strong>TCP</strong><br />
TCP
是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP
能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP
还能够有效利用带宽，缓解网络拥堵。<br />
为了建立和断开连接，TCP 需要进行 3 次握手，4
次挥手，从而会导致网络流量的浪费。</p>
</blockquote>
<blockquote>
<p><strong>UDP</strong><br />
UDP 是一种面向无连接的传输层协议。UDP
不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。<br />
UDP 常用语分组数据较少或多播、广播通信以及视频通信等多媒体领域。</p>
</blockquote>
<ul>
<li><strong>应用层（会话层以上分层）</strong>
<ul>
<li>TCP/IP 协议分层模型将 OSI
参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。</li>
</ul></li>
</ul>
<h1 id="tcpip-协议分层模型通信示例">TCP/IP 协议分层模型通信示例</h1>
<p>这里继续以上述电子邮件收发的示例来介绍 TCP/IP
协议分层模型的通信过程。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-example.png?x-oss-process=image/resize,w_800" /></p>
<p>邮件收发过程可分为个主要步骤：</p>
<ul>
<li>发送数据包（发送端）</li>
<li>接收数据包（接收端）</li>
</ul>
<h2 id="发送数据包">发送数据包</h2>
<h3 id="应用程序处理">应用程序处理</h3>
<p>应用程序在发送邮件那一刻建立 TCP 连接，从而利用该 TCP
连接发送数据。该过程首先将应用层发来的数据发送至下一层的
TCP，再做实际的转发处理。</p>
<h3 id="tcp-模块处理">TCP 模块处理</h3>
<p>TCP 根据应用程序的指示，负责建立连接、发送数据、断开连接。TCP
会在应用层数据前端附加一个 TCP 首部，其中包括：<strong>源端口号</strong>
和
<strong>目标端口号</strong>（用以识别发送主机和接收主机上的应用）、<strong>序号</strong>（用以标识发送包中哪部分是数据）、<strong>校验和</strong>（用以判断数据是否被损坏）。</p>
<h3 id="ip-模块处理">IP 模块处理</h3>
<p>IP 将 TCP 传来的 TCP 首部和 TCP
数据合起来作为自己的数据，并在数据前端附加一个 IP 首部，其中包括：接收端
IP 地址和发送端 IP 地址。</p>
<p>IP 包生成后，根据路由控制表决定接收此 IP 包的路由器或主机。随后，IP
包将被发送给连接到这些路由器或主机网络接口的驱动程序，以实现真正发送数据。</p>
<p>如果尚且不知道接收端的 MAC 地址，可利用 ARP 查找。只要知道了对端的
MAC 地址，就可将 MAC 地址和 IP
地址交给以太网的驱动程序，实现数据传输。</p>
<h3 id="网络接口以太网驱动处理">网络接口（以太网驱动）处理</h3>
<p>以太网驱动会将 IP 传来的 IP
包的前端附加上以太网首部并进行发送处理。以太网首部包含：接收端 MAC
地址、发送端 MAC
地址、标志以太网类型的以太网数据的协议。由此产生的以太网数据包将被发送至物理层传输给接收端。</p>
<h2 id="接收数据包">接收数据包</h2>
<p>数据包的接收流程是发送流程的逆序过程。</p>
<h3 id="网络接口以太网驱动处理-1">网络接口（以太网驱动）处理</h3>
<p><strong>主机收到以太网包后，先从以太网包首部找到 MAC
地址判断是否为发给自己的包。如果不是则丢弃。</strong></p>
<p>如果确认是发给自己的包，则查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。示例中数据的协议类型是
IP，因此将数据传送给处理 IP 的子程序（如果是 ARP，则把数据传给处理 ARP
的子程序）。如果无法识别协议类型，则丢弃数据。</p>
<h3 id="ip-模块处理-1">IP 模块处理</h3>
<p>IP 模块收到 IP
包首部以数据部分后，也做类似处理。<strong>如果判断首部中的 IP
地址与自己的 IP
地址匹配，则接收数据并从中查找上一层的协议</strong>。如果上一层协议为
TCP，则传给 TCP 处理；如果上一层协议为 UDP，则传给 UDP
处理；<strong>对于路由器，接收端 IP 地址往往不是自己的 IP
地址，此时会根据路由控制表，查询应送达的主机或路由器以后再转发数据</strong>。</p>
<h3 id="tcp-模块处理-1">TCP 模块处理</h3>
<p>TCP
模块会先计算校验和以确认数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。</p>
<p>数据接收完毕后，接收端则发送一个“确认回执”给发送端。如果回执消息未能达到发送端，发送端会认为接收端没有接收到数据而一直重复发送。</p>
<p>数据被完整接收后，会传给由端口号识别的应用程序。</p>
<h3 id="应用程序处理-1">应用程序处理</h3>
<p>接收端应用程序通过解析数据可最终获取到邮件的具体内容。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI
模型-维基百科</a></li>
<li>《图解 TCP/IP》</li>
<li>《TCP/IP 详解》</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>OSI</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Paul Heckel 差分算法</title>
    <url>/2023/10/06/paul-heckel-difference-algorithm/</url>
    <content><![CDATA[<p>前一篇 <a
href="http://chuquan.me/2023/09/13/myers-difference-algorithm/">文章</a>
我们介绍了 Myers
差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit
等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——Paul
Heckel 差分算法。</p>
<span id="more"></span>
<h1 id="解决什么问题">解决什么问题？</h1>
<p>通过前一篇文章，我们知道 Myers 差分算法主要用于
<strong>解决特定设定下的最小编辑距离问题</strong>，即：当编辑操作只支持
<strong>插入</strong> 和 <strong>删除</strong> 时，计算一个文件从
<code>A</code> 状态转换成 <code>B</code>
状态所需的最少编辑次数（或编辑方式）。算法特别适用于对编辑次数敏感，但是对速度和内存不敏感的系统，比如版本控制系统。</p>
<p>对比而言，Paul Heckel 差分算法则主要用于
<strong>解决最小化差异问题</strong>，即：当一个文件从 <code>A</code>
状态转换成 <code>B</code>
状态时，两种状态之间的数据差异。算法会为每一项差异定义一个对应的类型（操作），比如：删除、插入、移动等，其侧重点在于最小化差异，而不是最小化编辑。Paul
Heckel 差分算法特别适合对计算速度敏感，但是对于
<strong>差异不敏感</strong> 的系统，比如实时数据分析系统，UI
框架数据差分。</p>
<h1 id="算法原理">算法原理</h1>
<h2 id="核心思想">核心思想</h2>
<p>Paul Heckel
算法使用三种类型来表示两个文件之间的差异结果，分别是：<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。基于此，算法的核心思路其实非常简单，分别是：</p>
<ul>
<li><strong>确定旧文件中待删除的行</strong></li>
<li><strong>确定新文件中待插入的行</strong></li>
<li><strong>确定旧文件至新文件中待移动的行，并记录行号关系（旧文件行号、新文件行号）</strong></li>
</ul>
<h2 id="数据结构">数据结构</h2>
<p>很显然，根据算法的核心思想，新旧两个文件中的所有行最终都将被分类为三种类型（如果行的内容和位置都没有变化，则分类为移动类型，只不过移动的行号保持不变而已）。</p>
<p>Paul Heckel 差分算法使用两个数组 <code>NA</code>（New Array）和
<code>OA</code>（Old
Array）分别记录新旧两个文件的每一行的信息。数组元素分为两种类型：<strong>指针</strong>
或
<strong>行号</strong>。通过这种方式，我们可以对新旧两个文件中的所有行进行分类：</p>
<ul>
<li>当旧文件中某一行在 <code>OA</code>
中对应的元素为指针时，表示这一行是待删除的。</li>
<li>当新文件中某一行在 <code>NA</code>
中对应的元素为指针时，表示这一行是待插入的。</li>
<li>当新文件（旧文件）中某一行在
<code>NA</code>（<code>OA</code>）中对应的元素为行号时，表示这一行是待移动的。行号记录了它在旧文件（新文件）的位置。两两配对。</li>
</ul>
<p>这里提到了数组元素可能是指针类型，那么它到底指向什么类型的数据呢？事实上，这是
Paul Heckel 算法预定义的一种数据类型，这里我们称之为 entry 类型。entry
的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">entry</span> &#123;</span><br><span class="line">    <span class="type">int</span> oc;         <span class="comment">// old count. 记录该行在旧文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> nc;         <span class="comment">// new count. 记录该行在新文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> olno;       <span class="comment">// old line number. 记录该行在旧文件中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，为了方便快速查找某一行所对应的
entry，这里还定义了一个哈希表，算法中称为 <strong>符号表（Symbol
Table）</strong>，其中 Key 为行内容，Value 为 entry。</p>
<p>如下所示，为算法所定义的相关数据结构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-01.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="算法实现">算法实现</h1>
<p>算法的实现主要分为三个部分，分别是：</p>
<ul>
<li>构建阶段</li>
<li>移动类型筛选</li>
<li>分析输出</li>
</ul>
<p>下面依次进行介绍。</p>
<h2 id="构建阶段">构建阶段</h2>
<p>在构建阶段，将遍历新文件和旧文件的每一行，同时构建数组、符号表表项（Key
为行内容，Value 为 Entry）。</p>
<ul>
<li>对于新文件，在构建 Entry 时，对 <code>nc</code> 字段加 1。</li>
<li>对于旧文件，在构建 Entry 时，对 <code>oc</code> 字段加 1，并设置
<code>olno</code> 为当前的行号。</li>
</ul>
<p>在构建数组（ <code>NA</code> 和 <code>OA</code>
）时，其元素均为指针类型，指向当前行对应在符号表中的 entry。</p>
<p>很显然，构建阶段需要进行两次遍历，其对应在论文中分别是 Pass 1 和 Pass
2。</p>
<h2 id="移动类型筛选">移动类型筛选</h2>
<p>在构建阶段完成后，数组 <code>NA</code> 和 <code>OA</code>
中的所有元素都是指针类型，指向符号表中的某个
entry。接下来，只要我们把属于 <strong>移动</strong>
类型的行筛选出来，也就是把数组中的某些元素修改为行号，即可完成对三种类型的分类。</p>
<p>在继续介绍之前，我们先说明一种常见的情况：<strong>一个文件中行内容可能是唯一项，也可能是重复项</strong>。比如，在下图所示的两个文件中，<code>THE</code>
在新旧两个文件中都重复出现了两次，<code>A</code>、<code>MASS</code>、<code>OF</code>
等内容在各自的文件中都是唯一项。对此，算法的处理方式也有所不同。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-03.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="唯一项筛选">唯一项筛选</h3>
<p>对于唯一项，很显然，如果符合移动类型的话，行所对应的 entry 中的
<code>oc</code> 和 <code>nc</code> 的值均为
1，表示它们在新旧文件中各自只出现了一次。</p>
<p>由于移动类型是对等的，所以我们只需要遍历 <code>NA</code>
数组就可以找到所有唯一项的移动类型。具体的做法是：</p>
<ul>
<li>遍历 <code>NA</code> 数组，根据元素（指针类型）找到对应的
entry。</li>
<li>判断 entry 的 <code>oc</code> 和 <code>nc</code> 字段是否均为 1。
<ul>
<li>如果符合条件，则将 <code>NA</code>
对应的位置的元素设置成行号类型，值为
<code>olno</code>（即该行对应在旧文件中的位置）；同时将 <code>OA</code>
的 <code>olno</code> 位置的元素设置成行号类型，值为
<code>i</code>（即当前遍历到的行号）。此时，两者实现了移动匹配（各自记录了彼此的位置）。</li>
<li>如果不符合条件，则将继续遍历 <code>NA</code>。</li>
</ul></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-04.png?x-oss-process=image/resize,w_800" /></p>
<p>在遍历完成后，数组 <code>NA</code> 和 <code>OA</code>
中均可能有一部分元素变成了行号类型，值为对方的某个行号。本轮遍历对应在论文中是
Pass 3。</p>
<h3 id="重复项筛选">重复项筛选</h3>
<p>对于重复项，算法采用了一种模糊处理的方式。这里主要遵循了下面这个设定：</p>
<blockquote>
<p>If a line has been found to be unaltered, and the lines immediately
adjacent to it in both files are identical, then these lines must be the
same line. This information can be used to find blocks of unchanged
lines.</p>
<p>译：如果某一行没有发生改变，并且在新旧两个文件中与它紧邻的行都是相同的，那么这些行必须是相同的行。这个信息可以用来找到未改变的行块。</p>
</blockquote>
<p>上述设定需要寻找某一行前后邻近的行，很显然，需要进行两次遍历，分别是正向遍历和反向遍历。同样，这里只需要遍历
<code>NA</code> 即可。</p>
<p>对于正向遍历，会进行以下处理：</p>
<ul>
<li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当
<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示
<code>NA[i]</code> 指向 <code>OA[j]</code>）
<ul>
<li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>
类型的行，那么继续判断 <code>NA[i+1]</code> 是否与 <code>OA[j+1]</code>
指向同一个 entry。
<ul>
<li>如果是，则将 <code>NA[i+1]</code> 的元素设置成行号类型，值为
<code>j+1</code>；将 <code>OA[j+1]</code> 的元素设置成行号类型，值为
<code>i+1</code>。</li>
</ul></li>
</ul></li>
<li>此外其他情况均继续遍历 <code>NA</code>。</li>
</ul>
<p>对于反向遍历，其处理与正向遍历类似，只不过方向相反：</p>
<ul>
<li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当
<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示
<code>NA[i]</code> 指向 <code>OA[j]</code>）
<ul>
<li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>
类型的行，那么继续判断 <code>NA[i-1]</code> 是否与 <code>OA[j-1]</code>
指向同一个 entry。
<ul>
<li>如果是，则将 <code>NA[i-1]</code> 的元素设置成行号类型，值为
<code>j-1</code>；将 <code>OA[j-1]</code> 的元素设置成行号类型，值为
<code>i-1</code>。</li>
</ul></li>
</ul></li>
<li>此外其他情况均继续遍历 <code>NA</code>。</li>
</ul>
<p>经过这一番操作后，算法会处理筛选出重复项，下图所示红色标识。这些重复项的
<strong>移动</strong> 类型，可以与某些唯一项连成
<strong>移动块</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-02.png?x-oss-process=image/resize,w_800" /></p>
<p>重复项的筛选，经历了两次遍历，分别对应论文中的 Pass 4 和 Pass 5。</p>
<h2 id="分析输出">分析输出</h2>
<p>经过上述一系列处理之后，数组 <code>NA</code> 和 <code>OA</code>
将所有行分成了三种类型，分别是
<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。根据这些信息，我们可以遍历
<code>NA</code> 和
<code>OA</code>，输出差异的分析结果。这一步，对应在论文中则是 Pass
6。</p>
<h1 id="算法缺陷">算法缺陷</h1>
<p>至此，仔细的同学可能会发现，在重复项筛选的过程中，算法会遗漏一部分属于
<strong>移动</strong> 类型的行，而将它们误判为 <strong>删除</strong> 或
<strong>插入</strong> 类型。</p>
<p>如下所示为算法误判的一个例子。我们将新文件中的第一个 <code>THE</code>
前后相邻的两个行改成两个唯一项 <code>UNIQUE1</code> 和
<code>UNIQUE2</code>。由于旧文件中不存在 <code>UNIQUE1</code> 和
<code>UNIQUE2</code>，所以它们是属于插入类型的项。此时，我们再看上述
Pass 4 和 Pass 5 的执行逻辑，可以看出新文件中的第一个 <code>THE</code>
并不会并筛选为移动类型，而是被错误地认为是插入类型。所以说，Paul Heckel
算法对于重复项的处理采用了一种模糊处理的方式。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-05.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，这也是 Paul Heckel
差分算法的特点，它牺牲了一部分差异精准度，换来了更快的分析速度。这也是为什么我们在「解决了什么问题」这一节中说
Paul Heckel 算法适合速度敏感、差异不敏感的系统。</p>
<h1 id="算法应用">算法应用</h1>
<p>基于 Paul Heckel 算法变种的差分算法应用其实非常多，在 iOS
开发中就有很多相关的框架，比如：IGListKit、DifferenceKit、RxDataSources、FlexibleDiff、DeepDiff
等。下面，我们来看看 IGListKit 是如何应用并优化 Paul Heckel
差分算法的。</p>
<h2 id="类型扩展">类型扩展</h2>
<p>由于绝大多数应用都对 Paul Heckel
算法进行了一定程度的优化，因此，我们必须要先了解它们到底优化了什么。</p>
<p>事实上，原始的 Paul Heckel 算法只对 <strong>位置</strong> 和
<strong>内容</strong> 两个维度进行差分检测（符号表的 Key
和数据判等都是基于 <strong>内容</strong>），从而产生 3
种分类，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">位置</th>
<th style="text-align: left;">内容</th>
<th style="text-align: left;">分类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move（起始位置不变）</td>
</tr>
<tr class="even">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="odd">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move</td>
</tr>
<tr class="even">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
</tbody>
</table>
<p>但是在实际应用中，为了支持更加复杂多变的场景，一般会额外支持
<strong>标识</strong> 或 <strong>ID</strong> 的维度。此时，算法将基于
<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong>
三个维度进行差分检测（符号表的 Key 基于
<strong>标识</strong>，数据判等基于 <strong>内容</strong>），对此将产生
4 种分类，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">标识（ID）</th>
<th style="text-align: left;">位置</th>
<th style="text-align: left;">内容</th>
<th style="text-align: left;">分类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move（起始位置不变）</td>
</tr>
<tr class="even">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">update</td>
</tr>
<tr class="odd">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move</td>
</tr>
<tr class="even">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">update &amp; move</td>
</tr>
<tr class="odd">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="even">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="odd">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="even">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
</tbody>
</table>
<h2 id="iglistdiff">IGListDiff</h2>
<h3 id="数据结构-1">数据结构</h3>
<p>在数据结构定义上，IGListDiff
与原始算法类似，也定义了一个符号表和两个数组，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-06.png?x-oss-process=image/resize,w_800" /></p>
<p>对于符号表，IGListDiff 使用数据的标识（ID）作为 Key，以
<code>IGListEntry</code> 作为 Value。<code>IGListEntry</code>
的定义如下所示，很显然，它与原始算法中的 <code>entry</code>
结构非常类似：</p>
<ul>
<li><code>oldCounter</code> 和 <code>newCounter</code> 对应的是
<code>oc</code> 和 <code>nc</code> 字段。</li>
<li><code>oldIndex</code> 对应
<code>olno</code>，但是它支持记录多个位置信息，支持处理重复项。<code>olno</code>
只能记录一个位置。</li>
<li><code>IGListEntry</code> 额外还有一个 <code>updated</code>
字段，用于标记扩展的 <strong>更新</strong>（update）类型。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Used to track data stats while diffing.</span></span><br><span class="line"><span class="keyword">struct</span> IGListEntry &#123;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the old array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> oldCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the new array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The indexes of the data in the old array</span></span><br><span class="line">    stack&lt;<span class="built_in">NSInteger</span>&gt; oldIndexes;</span><br><span class="line">    <span class="comment">/// Flag marking if the data has been updated between arrays by checking the isEqual: method</span></span><br><span class="line">    <span class="type">BOOL</span> updated = <span class="literal">NO</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于两个数组，IGListDiff
同样具备，区别在于元素的表示形式。在原始算法中，<code>NA</code> 和
<code>OA</code> 数组存储的元素可能是指针或行号，而 IGListDiff 则使用
<code>IGListRecord</code>
类型来记录两种信息，其定义如下所示。其中，<code>entry</code>
用于存储指针，<code>index</code> 用于存储行号。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Track both the entry and algorithm index. Default the index to NSNotFound</span></span><br><span class="line"><span class="keyword">struct</span> IGListRecord &#123;</span><br><span class="line">    IGListEntry *entry;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">NSInteger</span> index;</span><br><span class="line"></span><br><span class="line">    IGListRecord() &#123;</span><br><span class="line">        entry = <span class="literal">NULL</span>;</span><br><span class="line">        index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外，IGListDiff 定义一个 <code>IGListDiffable</code>
协议，所有希望调用 IGListDiff 差分算法的数据都必须支持该协议。如下所示为
<code>IGListDiffable</code> 的定义。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListDiffable)</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListDiffable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a key that uniquely identifies the object.</span></span><br><span class="line"><span class="comment"> @return A key that can be used to uniquely identify the object.</span></span><br><span class="line"><span class="comment"> @note Two objects may share the same identifier, but are not equal. A common pattern is to use the `NSObject` category for automatic conformance. However this means that objects will be identified on their pointer value so finding updates becomes impossible.</span></span><br><span class="line"><span class="comment"> @warning This value should never be mutated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;)diffIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns whether the receiver and a given object are equal.</span></span><br><span class="line"><span class="comment"> @param object The object to be compared to the receiver.</span></span><br><span class="line"><span class="comment"> @return `YES` if the receiver and object are equal, otherwise `NO`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToDiffableObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;IGListDiffable&gt;)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>算法会使用数据的 <code>diffIdentifier</code>
作为标识（ID），符号表也将以此为 Key 记录对应的 entry。另一个协议方法
<code>isEqualToDiffableObject:</code> 则用于进行内容判等。</p>
<p>关于输出，原始算法并没有做相关说明。对此，IGListDiff
自定义了两种输出结构，分别是 <code>IGListIndexSetResult</code> 和
<code>IGListIndexPathResult</code>，如下所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexPathResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexPathResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The index paths inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *inserts;</span><br><span class="line"><span class="comment">// The index paths deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *deletes;</span><br><span class="line"><span class="comment">// The index paths in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *updates;</span><br><span class="line"><span class="comment">// The moves from an index path in the old collection to an index path in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndexPath *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexSetResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexSetResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The indexes inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *inserts;</span><br><span class="line"><span class="comment">// The indexes deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *deletes;</span><br><span class="line"><span class="comment">// The indexes in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *updates;</span><br><span class="line"><span class="comment">// The moves from an index in the old collection to an index in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndex *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>两者均携带了所有差异数据的位置信息，包括：插入、删除、更新、移动。区别则在于
<code>IGListIndexPathResult</code> 用于表示位置信息的类型是
<code>NSIndexPath</code> 类型，适用于 iOS
中的列表数据，<code>IGListIndexSetResult</code> 用于表示位置信息的类型是
<code>NSInteger</code> 类型，更适合通用的数组数据。</p>
<h3 id="核心逻辑">核心逻辑</h3>
<p>IGListDiff 中 <code>IGListDiff.m</code> 文件的
<code>IGListDiffing</code>
方法实现了差分算法的核心逻辑，大概可分为三个步骤：</p>
<ul>
<li><strong>构建阶段</strong></li>
<li><strong>标记移动类型和更新类型</strong></li>
<li><strong>格式化输出</strong></li>
</ul>
<h4 id="构建阶段-1">构建阶段</h4>
<p>在构建阶段，IGListDiff
分别正向遍历新数据和反向遍历旧数据，从而构建数组元素
<code>NA</code>、<code>OA</code>、符号表，这一点与原始算法类似。这里反向遍历旧数据是因为这里使用栈来记录所有的
<code>olno</code>，以便后续正向地出栈旧数据的位置信息。具体代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;, IGListEntry, IGListHashID, IGListEqualID&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 1</span></span><br><span class="line"><span class="comment">// create an entry for every item in the new array</span></span><br><span class="line"><span class="comment">// increment its new count for each occurence</span></span><br><span class="line">vector&lt;IGListRecord&gt; newResultsArray(newCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(newArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.newCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add NSNotFound for each occurence of the item in the new array</span></span><br><span class="line">    entry.oldIndexes.push(<span class="built_in">NSNotFound</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    newResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 2</span></span><br><span class="line"><span class="comment">// update or create an entry for every item in the old array</span></span><br><span class="line"><span class="comment">// increment its old count for each occurence</span></span><br><span class="line"><span class="comment">// record the original index of the item in the old array</span></span><br><span class="line"><span class="comment">// MUST be done in descending order to respect the oldIndexes stack construction</span></span><br><span class="line">vector&lt;IGListRecord&gt; oldResultsArray(oldCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(oldArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.oldCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the original indices where the item occurred onto the index stack</span></span><br><span class="line">    entry.oldIndexes.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    oldResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标记移动类型和更新类型">标记移动类型和更新类型</h4>
<p>构建完成之后，开始对移动类型和更新类型进行标记，具体如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pass 3</span></span><br><span class="line"><span class="comment">// handle data that occurs in both arrays</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    IGListEntry *entry = newResultsArray[i].entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grab and pop the top original index. if the item was inserted this will be NSNotFound</span></span><br><span class="line">    <span class="built_in">NSCAssert</span>(!entry-&gt;oldIndexes.empty(), <span class="string">@&quot;Old indexes is empty while iterating new item %li. Should have NSNotFound&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> originalIndex = entry-&gt;oldIndexes.top();</span><br><span class="line">    entry-&gt;oldIndexes.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// originalIndex 存在表示「标识相同」。这里判断 originalIndex &lt; oldCount 应该是为了做越界保护。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex &lt; oldCount) &#123;</span><br><span class="line">        <span class="comment">// 对于「内容不同」的项，将其标记为更新类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; n = newArray[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; o = oldArray[originalIndex];</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffPointerPersonality:</span><br><span class="line">                <span class="comment">// 基于指针判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffEquality:</span><br><span class="line">                <span class="comment">// 基于指针 + 内容判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o &amp;&amp; ![n isEqualToDiffableObject:o]) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，并且内容不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0 表示新旧数据均存在</span></span><br><span class="line">    <span class="comment">// originalIndex != NSNotFound 的是为了让新旧数据两两匹配，因为 oldIndexes 随着遍历的迭代，始终在出栈。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex != <span class="built_in">NSNotFound</span></span><br><span class="line">        &amp;&amp; entry-&gt;newCounter &gt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; entry-&gt;oldCounter &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 对于「内容相同」的项，交换记录其在对方数组中的位置，表示移动类型</span></span><br><span class="line">        newResultsArray[i].index = originalIndex;</span><br><span class="line">        oldResultsArray[originalIndex].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出，每次迭代会从根据 <code>NA</code> 数组元素
<code>IGListRecord</code> 的 <code>entry</code> 字段索引到符号表中对应的
<code>IGListEntry</code>。然后从 <code>IGListEntry</code> 的
<code>oldIndexes</code> 字段出栈一个旧文件中存在的位置。</p>
<p>如果 <code>originalIndex</code> 存在，则表示 <code>NA</code> 和
<code>OA</code> 均存在，此时进一步判断内容，如果内容发生了变化则标记
<code>updated</code> 字段为
<code>YES</code>。判断内容变化的方式有两种，用户可以选择配置：</p>
<ul>
<li><strong>基于指针判断</strong>：如果指针不同，则表示数据发生了变化</li>
<li><strong>基于指针+内容判断</strong>：如果指针不同，并且内容不同，则表示数据发生了变化</li>
</ul>
<p>在遍历过程中，还会记录移动类型的位置信息。它的前提条件包含两部分：</p>
<ul>
<li><code>newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0</code>：表示新旧数据均存在</li>
<li><code>originalIndex != NSNotFound</code>：表示新旧数据可以进行移动类型的匹配，每一次匹配，<code>oldIndexes</code>
都会出栈一次，消耗一次对等的匹配。举个例子：
<ul>
<li>如果 <code>newCounter = 3</code>，<code>oldCounter = 2</code>
时，<code>NA</code>
中第三个数据会被归为插入类型，前两个数据会被归为移动类型。</li>
<li>如果 <code>newCounter = 2</code>，<code>oldCounter = 3</code>
时，<code>OA</code>
中的第三个数据会被归为删除类型，前两个数据会被归为移动类型。</li>
</ul></li>
</ul>
<h4 id="格式化输出">格式化输出</h4>
<p>首先，遍历 <code>OA</code>
数组，确定删除类型，具体代码如下所示。数组元素的 <code>index</code>
类型为 <code>NSNotFound</code> 类似于原始算法中 <code>OA</code>
元素的类型为指针。当符合这个条件时，表示数据类型为删除类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterate old array records checking for deletes</span></span><br><span class="line"><span class="comment">// incremement offset for each delete</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">    deleteOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = oldResultsArray[i];</span><br><span class="line">    <span class="comment">// if the record index in the new array doesn&#x27;t exist, its a delete</span></span><br><span class="line">    <span class="comment">// 对 OA 中的删除项进行分类</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，遍历 <code>NA</code>
数组，确定插入、更新、移动等类型，具体代码如下所示。数组元素的
<code>index</code> 类型为 <code>NSNotFound</code> 类似于原始算法中
<code>NA</code>
元素的类型为指针。当符合这个条件时，表示数据类型为插入类型。否则，均属于移动类型。</p>
<p>这里由于 IGListDiff 额外扩展了一个 <code>updated</code>
字段，所以有一部分元素为同时标记为更新类型。这一点其实很容易理解，当新旧数据中有一个数据标识相同，但是位置不同，且内容不同，我们可以认为它做了一次移动操作修改了位置，又做了一次更新操作修改了内容。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    insertOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = newResultsArray[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> oldIndex = record.index;</span><br><span class="line">    <span class="comment">// add to inserts if the opposing index is NSNotFound</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定插入类型</span></span><br><span class="line">        addIndexToCollection(returnIndexPaths, mInserts, toSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// note that an entry can be updated /and/ moved</span></span><br><span class="line">        <span class="keyword">if</span> (record.entry-&gt;updated) &#123;</span><br><span class="line">            <span class="comment">// 确定更新类型</span></span><br><span class="line">            addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate the offset and determine if there was a move</span></span><br><span class="line">        <span class="comment">// if the indexes match, ignore the index</span></span><br><span class="line">        <span class="comment">// 确定移动类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> insertOffset = insertOffsets[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> deleteOffset = deleteOffsets[oldIndex];</span><br><span class="line">        <span class="keyword">if</span> ((oldIndex - deleteOffset + insertOffset) != i) &#123;</span><br><span class="line">            <span class="type">id</span> move;</span><br><span class="line">            <span class="keyword">if</span> (returnIndexPaths) &#123;</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *from = [<span class="built_in">NSIndexPath</span> indexPathForItem:oldIndex inSection:fromSection];</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *to = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:toSection];</span><br><span class="line">                move = [[IGListMoveIndexPath alloc] initWithFrom:from to:to];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                move = [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i];</span><br><span class="line">            &#125;</span><br><span class="line">            [mMoves addObject:move];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, toSection, i, newArray[i], newMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化小结">优化小结</h3>
<p>整体而言，IGListDiff 在 Paul Heckel
差分算法的基础上扩展了差分类型，从原来的
<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong> 3
种类型扩展成
<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong>、<strong>更新</strong>
4 种类型。类型的扩展本质上是通过增加检测维度实现的，Paul Heckel
差分算法只支持 <strong>位置</strong>、<strong>内容</strong> 2
个维度进行检测，而 IGListDiff 则支持
<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong> 3
个维度进行检测。</p>
<p>此外，IGListDiff 实现了精准检测，而 Paul Heckel
算法实现的是模糊处理，会存在移动类型误判为插入或删除等情况。这种精准检测的能力，适用于对差异敏感的系统，使得算法的应用场景进一步扩大。</p>
<h1 id="总结">总结</h1>
<p>本文首先介绍了原始的 Paul Heckel 差分算法的实现原理。原始的 Paul
Heckel 差分算法基于位置、内容 2
个维度进行差分检测，支持检测插入、删除、移动等 3
种类型。但是，其实现的是一种模糊处理的差分检测，会存在将移动类型归为插入或删除的情况。</p>
<p>其次，我们介绍了 IGListKit 中的 IGListDiff 模块，其在 Paul Heckel
差分算法的基础上进行了优化，基于标识、位置、内容 3
个维度进行差分检测，支持检测插入、删除、移动、更新等 4
种类型。IGListDiff 实现了一种精确分析的差分算法，这更符合我们在 UI
框架中对于数据差异精准检测的需求。</p>
<p>通过上文的介绍，我们可以举一反三猜想地其他应用是如何实现数据差分检测的。对此，如果你感兴趣的话，可以研究一个其他的框架，来印证一下你的猜想，甚至可以考虑自己实现差分算法。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://dl.acm.org/doi/pdf/10.1145/359460.359467">A
Technique for Isolating Differences Between Files</a>. Paul Heckel.</li>
<li><a href="https://gist.github.com/ndarville/3166060">Isolating
Differences Between Files</a></li>
<li><a href="https://github.com/Instagram/IGListKit">IGListKit</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>差分算法</tag>
        <tag>Paul Heckel</tag>
        <tag>IGListKit</tag>
        <tag>IGListDiff</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods Podfile 解析原理</title>
    <url>/2021/12/24/podfile-analyze-principle/</url>
    <content><![CDATA[<p>作为 iOS 开发者，我们都知道 Podfile 是 CocoaPods 用于描述 Xcode
项目依赖的配置文件。当需要为项目添加依赖时，我们只需要在 Podfile
中声明一个 <code>pod</code> 即可，比如：</p>
<span id="more"></span>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;Alamofire&#x27;</span>, <span class="string">&#x27;~&gt; 5.4&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当我们执行了 <code>pod install</code>
之后，项目就集成并依赖了这个第三方 pod
库了。那么，这背后的原理到底是什么呢？</p>
<p>为了探索 Podfile 背后的原理，我们来看 <a
href="https://github.com/CocoaPods/Core">CocoaPods-Core</a>
的相关源码实现，这里我们主要关注 3 个源码文件：</p>
<ul>
<li><code>podfile/dsl.rb</code></li>
<li><code>podfile/target_definition.rb</code></li>
<li><code>podfile.rb</code></li>
</ul>
<h1 id="示例">示例</h1>
<p>下文我们以一个 Demo Project 的例子进行介绍，如下所示为 Demo Project
的 Podfile 文件定义。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;11.0&#x27;</span></span><br><span class="line"></span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">use_modular_headers!</span><br><span class="line">install! <span class="string">&#x27;cocoapods&#x27;</span>, <span class="symbol">:warn_for_unused_master_specs_repo</span> =&gt; <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">&#x27;Alamofire&#x27;</span>, <span class="string">&#x27;~&gt; 5.4&#x27;</span></span><br><span class="line">  pod <span class="string">&#x27;Dollar&#x27;</span></span><br><span class="line">  pod <span class="string">&#x27;SnapKit&#x27;</span>, <span class="string">&#x27;~&gt; 4.0&#x27;</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">&#x27;DemoTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">&#x27;DemoUITests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="podfile-初始化">Podfile 初始化</h1>
<p>在上述例子中，Podfile
文件声明了项目的依赖，诸如：<code>Alamofire</code>、<code>Dollar</code>、<code>SnapKit</code>
等。当我们执行 <code>pod install</code> 命令时，CocoaPods 会根据 Podfile
文件路径进行初始化，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">podfile</span></span><br><span class="line">  <span class="variable">@podfile</span> |<span class="params"></span>|= <span class="title class_">Podfile</span>.from_file(podfile_path) <span class="keyword">if</span> podfile_path</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Podfile</code> 类提供了类方法 <code>self.from_file</code>，根据
Podfile 文件路径进行初始化。<code>self.from_file</code>
方法的定义如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.from_file(path)</span><br><span class="line">  path = <span class="title class_">Pathname</span>.new(path)</span><br><span class="line">  <span class="comment"># 根据路径判断 Podfile 是否存在</span></span><br><span class="line">  <span class="keyword">unless</span> path.exist?</span><br><span class="line">    <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;No Podfile exists at path `<span class="subst">#&#123;path&#125;</span>`.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 根据路径的文件后缀名，选择对应的工厂方法进行初始化</span></span><br><span class="line">  <span class="keyword">case</span> path.extname</span><br><span class="line">  <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;.podfile&#x27;</span>, <span class="string">&#x27;.rb&#x27;</span></span><br><span class="line">    <span class="title class_">Podfile</span>.from_ruby(path)</span><br><span class="line">  <span class="keyword">when</span> <span class="string">&#x27;.yaml&#x27;</span></span><br><span class="line">    <span class="title class_">Podfile</span>.from_yaml(path)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;Unsupported Podfile format `<span class="subst">#&#123;path&#125;</span>`.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>self.from_file</code>
的实现中，首先会根据路径判断文件是否存在，如果不存在即抛出异常。然后，判断通过文件的后缀判断文件的类型，选择不同的工厂方法进行初始化。通过溯源代码定义，我们可以发现，CocoaPods
支持的 4 种命名方式的 Podfile，分别是：</p>
<ul>
<li><strong><code>CocoaPods.podfile.yaml</code></strong></li>
<li><strong><code>CocoaPods.podfile</code></strong></li>
<li><strong><code>Podfile</code></strong></li>
<li><strong><code>Podfile.rb</code></strong></li>
</ul>
<p>对于 <code>yaml</code> 类型的 Podfile 文件，使用
<code>self.from_yaml</code> 工厂方法进行初始化；对于其他类型的 Podfile
文件，使用 <code>self.from_ruby</code> 工厂方法进行初始化。</p>
<p>这里，我们重点看一下 <code>self.from_ruby</code>
的实现，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.from_ruby(path, contents = <span class="literal">nil</span>)</span><br><span class="line">  <span class="comment"># 读取 Podfile 中的内容</span></span><br><span class="line">  contents |<span class="params"></span>|= <span class="title class_">File</span>.open(path, <span class="string">&#x27;r:utf-8&#x27;</span>, &amp;<span class="symbol">:read</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 使用 UTF-8 进行编码</span></span><br><span class="line">  <span class="keyword">if</span> contents.respond_to?(<span class="symbol">:encoding</span>) &amp;&amp; contents.encoding.name != <span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line">    contents.encode!(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果存在非法字符，则报错。</span></span><br><span class="line">  <span class="keyword">if</span> contents.tr!(<span class="string">&#x27;“”‘’‛&#x27;</span>, <span class="string">%(&quot;&quot;&#x27;&#x27;&#x27;)</span>)</span><br><span class="line">  <span class="comment"># Changes have been made</span></span><br><span class="line">    <span class="title class_">Core</span>UI.warn <span class="string">&quot;Smart quotes were detected and ignored in your <span class="subst">#&#123;path.basename&#125;</span>. &quot;</span> \</span><br><span class="line">                <span class="string">&#x27;To avoid issues in the future, you should not use &#x27;</span> \</span><br><span class="line">                <span class="string">&#x27;TextEdit for editing it. If you are not using TextEdit, &#x27;</span> \</span><br><span class="line">                <span class="string">&#x27;you should turn off smart quotes in your editor of choice.&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 初始化 Podfile 对象，并传入尾随闭包</span></span><br><span class="line">  podfile = <span class="title class_">Podfile</span>.new(path) <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># rubocop:disable Lint/RescueException</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      <span class="comment"># rubocop:disable Security/Eval</span></span><br><span class="line">      <span class="comment"># 使用 eval 执行 Podfile 中定义的代码</span></span><br><span class="line">      eval(contents, <span class="literal">nil</span>, path.to_s)</span><br><span class="line">      <span class="comment"># rubocop:enable Security/Eval</span></span><br><span class="line">    <span class="keyword">rescue</span> <span class="title class_">Exception</span> =&gt; e</span><br><span class="line">      message = <span class="string">&quot;Invalid `<span class="subst">#&#123;path.basename&#125;</span>` file: <span class="subst">#&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">raise</span> <span class="title class_">DSLError</span>.new(message, path, e, contents)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># rubocop:enable Lint/RescueException</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 返回 Podfile 对象</span></span><br><span class="line">  podfile</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在工厂方法中，主要通过 3 个步骤来初始化 Podfile。</p>
<ul>
<li><strong>首先，读取 Podfile 文件的内容，并进行 UTF-8
编码。</strong></li>
<li><strong>然后，检测文件内容是否存在非法字符，如果存在则抛出异常。</strong></li>
<li><strong>最后，通过 <code>Podfile</code>
类构造方法进行初始化，并传入一个尾随闭包。</strong></li>
</ul>
<p>注意，最后一步的尾随闭包包含了一行关键代码：<code>eval(contents, nil, path.to_s)</code>
。正是这行代码，执行了我们在 Podfile
文件声明的所有内容，从而使它们正式生效。我们在 Podfile
文件进行声明，本质上是编写了对一系列 ruby 方法的调用。</p>
<h1 id="targetdefinition-树构建">TargetDefinition 树构建</h1>
<p>我们继续深入 <code>Podfile</code> 类的构造方法，其定义如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">defined_in_file = <span class="literal">nil</span>, internal_hash = &#123;&#125;, &amp;block</span>)</span><br><span class="line">  <span class="variable language_">self</span>.defined_in_file = defined_in_file</span><br><span class="line">  <span class="variable">@internal_hash</span> = internal_hash</span><br><span class="line">  <span class="keyword">if</span> block</span><br><span class="line">    <span class="comment"># ruby 类型的 Podfile 初始化逻辑</span></span><br><span class="line">    default_target_def = <span class="title class_">TargetDefinition</span>.new(<span class="string">&#x27;Pods&#x27;</span>, <span class="variable language_">self</span>)</span><br><span class="line">    default_target_def.abstract = <span class="literal">true</span></span><br><span class="line">    <span class="variable">@root_target_definitions</span> = [default_target_def]</span><br><span class="line">    <span class="variable">@current_target_definition</span> = default_target_def</span><br><span class="line">    <span class="comment"># 真正执行 Podfile 文件中所声明的代码</span></span><br><span class="line">    instance_eval(&amp;block)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># yaml 类型的 Podfile 初始化逻辑</span></span><br><span class="line">    <span class="variable">@root_target_definitions</span> = []</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>ruby</code> 类型的 Podfile 文件，<code>Podfile</code>
对象初始化时，会构建一个 <code>TargetDefinition</code>
树的根节点。然后，通过 <code>instance_eval</code> 方法真正执行 Podfile
中的代码。<strong>从而在已有的 <code>TargetDefinition</code>
根节点的基础上，进一步构建了整棵 <code>TargetDefinition</code>
树</strong>。</p>
<p>在 Demo Project 的例子中，<code>Podfile</code> 初始化后，构建的
<code>TargetDefinition</code> 树如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/targetdefinition-tree.png?x-oss-process=image/resize,w_800" /></p>
<p><code>TargetDefinition</code> 树的层级结构与 Podfile 文件中声明的
<code>target</code> 嵌套层级结构相关联，如下为 Podfile 文件中
<code>target</code> 的定义。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  target <span class="string">&#x27;DemoTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">&#x27;DemoUITests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    inherit! <span class="symbol">:search_paths</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们来看一下 <code>target</code> 方法的具体实现，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>(<span class="params">name, options = <span class="literal">nil</span></span>)</span><br><span class="line">  <span class="keyword">if</span> options</span><br><span class="line">    <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;Unsupported options `<span class="subst">#&#123;options&#125;</span>` for &quot;</span> \</span><br><span class="line">      <span class="string">&quot;target `<span class="subst">#&#123;name&#125;</span>`.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  parent = current_target_definition</span><br><span class="line">  <span class="comment"># 初始化一个 TargetDefinition，并建立父子关系</span></span><br><span class="line">  definition = <span class="title class_">TargetDefinition</span>.new(name, parent)</span><br><span class="line">  <span class="variable language_">self</span>.current_target_definition = definition</span><br><span class="line">  <span class="comment"># 执行闭包</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">ensure</span></span><br><span class="line">  <span class="comment"># 执行完毕，恢复 current_target_definition</span></span><br><span class="line">  <span class="variable language_">self</span>.current_target_definition = parent</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>target</code> 方法中，会创建一个
<code>TargetDefinition</code> 对象，并将当前的
<code>TargetDefinition</code>
作为父对象，从而建立父子关系，构建树结构。构建完毕，执行
<code>target</code>
方法的尾随闭包，进行进一步的设置。最后，恢复现场。</p>
<h2 id="targetdefinition">TargetDefinition</h2>
<p>那么 <code>TargetDefinition</code>
到底是什么？其实上图已经给了我们答案：<strong>一个
<code>TargetDefinition</code> 对应一个 Xcode Target</strong>。</p>
<p>在 <a
href="http://chuquan.me/2021/12/03/understand-concepts-in-xcode/">《理解
Xcode 中的各种概念》</a> 一文中，我们介绍了 Target
的作用，<strong>其包含构建特定 Product 所需的 build configuration、build
rule、build phase，并指定对应的构建产物 Product</strong>。默认，Target
继承 Project 定义的 build configuration，并且可以覆盖或自定义 build
settings。</p>
<p>如下所示，为 <code>TargetDefinition</code> 类的主要定义如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Podfile</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TargetDefinition</span></span><br><span class="line">      <span class="comment"># [TargetDefinition, Podfile]</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:parent</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># [Array&lt;TargetDefinition&gt;]</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:children</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">protected</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># [Hash]</span></span><br><span class="line">      <span class="built_in">attr_accessor</span> <span class="symbol">:internal_hash</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># Methods</span></span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>TargetDefinition</code> 类包含一个指向父节点的指针
<code>parent</code> 以及一组指向子节点的指针
<code>children</code>。最关键的是，<code>TargetDefinition</code>
通过一个内部的 <code>internal_hash</code> 存储了所有
<code>TargetDefinition</code> 的配置信息，包括：build
configurations，build phases、build rules
等等。<strong><code>TargetDefinition</code> 定义的其他方法几乎全部都是对
<code>internal_hash</code> 进行增删查改。</strong></p>
<h3 id="hash-keys">Hash Keys</h3>
<p><code>TargetDefinition</code> 内部通过定义一个 <code>HASH_KEYS</code>
的数组预定义了 <code>internal_hash</code>
将存储哪些键值对。<code>HASH_KEYS</code> 的定义如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HASH_KEYS</span> = <span class="string">%w(</span></span><br><span class="line"><span class="string">  name</span></span><br><span class="line"><span class="string">  platform</span></span><br><span class="line"><span class="string">  podspecs</span></span><br><span class="line"><span class="string">  exclusive               </span></span><br><span class="line"><span class="string">  inhibit_warnings</span></span><br><span class="line"><span class="string">  use_modular_headers</span></span><br><span class="line"><span class="string">  user_project_path</span></span><br><span class="line"><span class="string">  build_configurations</span></span><br><span class="line"><span class="string">  project_names</span></span><br><span class="line"><span class="string">  dependencies</span></span><br><span class="line"><span class="string">  script_phases</span></span><br><span class="line"><span class="string">  children</span></span><br><span class="line"><span class="string">  configuration_pod_whitelist</span></span><br><span class="line"><span class="string">  uses_frameworks</span></span><br><span class="line"><span class="string">  swift_version_requirements</span></span><br><span class="line"><span class="string">  inheritance</span></span><br><span class="line"><span class="string">  abstract</span></span><br><span class="line"><span class="string">  swift_version</span></span><br><span class="line"><span class="string">)</span>.freeze</span><br></pre></td></tr></table></figure>
<p>对比一下 Xcode Target
的结构类图，如下所示，我们大概能找到一些对应关系，尤其是
<code>PBXNativeTarget</code>，如：<code>dependencies</code>、<code>build_configurations</code>、<code>script_phases</code>
等。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-01.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="dsl-解析">DSL 解析</h1>
<p>在 <code>TargetDefinition</code> 树构造过程中，我们用到的
<code>target</code> 方法定义在 Podfile DSL 中。除此之外，Podfile DSL
中还定义了一系列方法。这些 DSL
的主要作用是：<strong>为开发者提供简洁的语法，从而支持自定义配置
Target、Project、Workspace，并且提供了一系列 hook
方法，允许开发者执行自定义脚本。</strong></p>
<p>Podfile DSL 本质上是一个 module，它会被 mixin 到 <code>Podfile</code>
类中，其内部实现与 <code>Podfile</code> 紧密关联。尤其是，Podfile DSL
使用了 <code>Podfile</code> 类中定义的
<code>current_target_definition</code> 和
<code>internal_hash</code>，用于存储 Podfile 所声明的配置信息。</p>
<p>Podfile DSL 根据功能可以分为如下几种类型：</p>
<ul>
<li>Root Options</li>
<li>Dependencies</li>
<li>Target Configuration</li>
<li>Workspace</li>
<li>Sources</li>
<li>Hooks</li>
</ul>
<p>下面，对这些 DSL 进行简要的介绍。</p>
<h2 id="root-options">Root Options</h2>
<p>Root Options 相关的 DSL 主要用于对 Podfile
进行整体配置，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明安装过程中会使用的安装方法和选项</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     internal_hash[&#x27;installation_method&#x27;] =&gt; &#123;&quot;name&quot; =&gt; xxx, &quot;options&quot; =&gt; xxx&#125;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">install!</span>(<span class="params">installation_method, options = &#123;&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用 Global Gemset 运行 CocoaPods，则会抛出异常。</span></span><br><span class="line"><span class="comment"># 如果传入 version 参数，则严格限制 bundler 的版本号。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ensure_bundler!</span>(<span class="params">version = <span class="literal">nil</span></span>)</span><br></pre></td></tr></table></figure>
<h2 id="dependencies">Dependencies</h2>
<p>Dependencies 相关的 DSL 主要用于为每个 Target
指定依赖。其主要通过调用 <code>TargetDefinition</code>
类所提供的方法将配置存入 <code>TargetDefinition</code> 类的
<code>internal_hash</code> 中。相关 DSL 如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个特定依赖</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.store_pod(name, *requirements)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pod</span>(<span class="params">name = <span class="literal">nil</span>, *requirements</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 podspec</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.store_podspec(options)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">podspec</span>(<span class="params">options = <span class="literal">nil</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个子 target，关联父 target，设置当前为子 target</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition = definition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>(<span class="params">name, options = <span class="literal">nil</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 build phase</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.store_script_phase(options)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">script_phase</span>(<span class="params">options</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前 target 设置成抽象 target</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.abstract = abstract</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abstract!</span>(<span class="params">abstract = <span class="literal">true</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个抽象 target</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abstract_target</span>(<span class="params">name</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置继承模式</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.inheritance = inheritance</span></span><br><span class="line"><span class="comment"># 三种模式</span></span><br><span class="line"><span class="comment">#    - :complete: 当前 target 继承父 target 的全部行为</span></span><br><span class="line"><span class="comment">#    - :none: 当前 target 不继承父 target 的任何行为</span></span><br><span class="line"><span class="comment">#    - :search_paths: 当前 target 只继承父 target 的 search paths</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inherit!</span>(<span class="params">inheritance</span>)</span><br></pre></td></tr></table></figure>
<h2 id="target-configurations">Target Configurations</h2>
<p>Target Configurations 相关的 DSL 主要用于控制 CocoaPods 生成 Project
文件。类似的，其主要也通过调用 <code>TargetDefinition</code>
类所提供的相关方法将配置存入 <code>TargetDefinition</code> 类的
<code>internal_hash</code> 中。相关 DSL 如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置当前 target 的目标平台</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.set_platform!(name, target)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">platform</span>(<span class="params">name, target = <span class="literal">nil</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 target 所在的 project。注意：Pods 库会被该 target 链接</span></span><br><span class="line"><span class="comment"># 同时可以为 target 指定 build configuration</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.user_project_path = path</span></span><br><span class="line"><span class="comment">#     current_target_definition.build_configurations = build_configurations</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">project</span>(<span class="params">path, build_configurations = &#123;&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前 target 是否忽略所有来自 CocoaPods 库的警告</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.inhibit_all_warnings = true</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inhibit_all_warnings!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所有的 CocoaPods 静态库使用 modular header</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.use_modular_headers_for_all_pods = true</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">use_modular_headers!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 Pods 使用 framework 而非静态库。注意：当使用 framework 时，我们需要指定 `:linkage` 的类型为 `:static` 或 `:dynamic`</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.use_frameworks!(option)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">use_frameworks!</span>(<span class="params">option = <span class="literal">true</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 target 支持的 swift 版本约束</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     current_target_definition.store_swift_version_requirements(*requirements)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">supports_swift_versions</span>(<span class="params">*requirements</span>)</span><br></pre></td></tr></table></figure>
<h2 id="workspace">Workspace</h2>
<p>Workspace 相关的 DSL 主要用于配置 Xcode Workspace，设置全局的
settings。其将配置存储在 <code>Podfile</code> 类的
<code>internal_hash</code> 中。相关 DSL 如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置包含所有 project 的 Xcode workspace </span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     internal_hash[&#x27;workspace&#x27;] =&gt; path</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">workspace</span>(<span class="params">path</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置根据所有已安装的 Pods 的头文件生成一个 BridgeSupport 元文件</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     internal_hash[&#x27;generate_bridge_support&#x27;] =&gt; true</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_bridge_support!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为 `OTHER_LD_FLAGS` 添加 `-fobjc-arc` 标志</span></span><br><span class="line"><span class="comment"># 存储方式：</span></span><br><span class="line"><span class="comment">#     internal_hash[&#x27;set_arc_compatibility_flag&#x27;] =&gt; true</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_arc_compatibility_flag!</span></span><br></pre></td></tr></table></figure>
<h2 id="sources">Sources</h2>
<p>Sources 相关的 DSL 主要用于设置源，Podfile 通过源列表查找对应的
Specification。相关的 DSL 如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 spec 的位置</span></span><br><span class="line"><span class="comment"># 存储方法：</span></span><br><span class="line"><span class="comment">#     internal_hash[&#x27;sources&#x27;] &lt;&lt; source</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">source</span>(<span class="params">source</span>)</span><br></pre></td></tr></table></figure>
<h2 id="hooks">Hooks</h2>
<p>Hooks 相关的 DSL 主要用于配置自定义脚本。Podfile 提供了一系列
hooks，这些 hooks 会在 install 过程中被执行。相关的 DSL 如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置安装过程中会用到的插件</span></span><br><span class="line"><span class="comment"># internal_hash[&#x27;plugins&#x27;] &lt;&lt; name</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plugin</span>(<span class="params">name, options = &#123;&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Pods 下载完成后，安装之前，执行 hook</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_install</span>(<span class="params">&amp;block</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 project 写入硬盘前，执行 hook</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_integrate</span>(<span class="params">&amp;block</span>)</span><br><span class="line"></span><br><span class="line">在 project 写入硬盘前，执行 hook 进行最后的修改</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_install</span>(<span class="params">&amp;block</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 project 写入硬盘后，执行 hook</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_integrate</span>(<span class="params">&amp;block</span>)</span><br></pre></td></tr></table></figure>
<h1 id="podfile-对象">Podfile 对象</h1>
<p>当 Podfile 文件中的代码执行完毕后，<code>Podfile</code>
对象也就构建完成了。<code>Podfile</code> 类的主要定义如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Podfile</span></span><br><span class="line">    <span class="keyword">include</span> <span class="title class_">Pod::Podfile::DSL</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">StandardError</span> &lt; <span class="symbol">:</span><span class="symbol">:StandardError</span>; <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># podfile 路径</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:defined_in_file</span></span><br><span class="line">    <span class="comment"># 所有的 TargetDefinition 的根节点, 正常只有一个，即 Pods.project target</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:root_target_definitions</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录 Pods.project 项目的配置信息</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:internal_hash</span></span><br><span class="line">    <span class="comment"># 当前 DSL 解析使用的 TargetDefinition</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:current_target_definition</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>类似于 <code>TargetDefinition</code>，<code>Podfile</code>
也提供了一个 <code>internal_hash</code>
用于存储一些全局的设置，它通过一个 <code>HASH_KEYS</code>
数组预定义了一系列键，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HASH_KEYS</span> = <span class="string">%w(</span></span><br><span class="line"><span class="string">  installation_method</span></span><br><span class="line"><span class="string">  workspace</span></span><br><span class="line"><span class="string">  sources</span></span><br><span class="line"><span class="string">  plugins</span></span><br><span class="line"><span class="string">  set_arc_compatibility_flag</span></span><br><span class="line"><span class="string">  generate_bridge_support</span></span><br><span class="line"><span class="string">  target_definitions</span></span><br><span class="line"><span class="string">)</span>.freeze</span><br></pre></td></tr></table></figure>
<p>在 DSL 解析一节中，我们知道了 DSL 将配置信息分别存储在了
<code>TargetDefinition</code> 类的 <code>internal_hash</code> 和
<code>Podfile</code> 类的 <code>internal_hash</code> 中。而
<code>Podfile</code> 类又持有了一个属性
<code>root_target_definition</code>，该属性引用了整个
<code>TargetDefinition</code> 树。因此，我们通过 <code>Podfile</code>
对象就可以得到所有相关内容。对此，<code>Podfile</code> 类提供了一个方法
<code>to_hash</code> 将所有的内容进行了合并，具体如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_hash</span></span><br><span class="line">  hash = &#123;&#125;</span><br><span class="line">  <span class="comment"># 获取 TargetDefinition 树的所有内容</span></span><br><span class="line">  hash[<span class="string">&#x27;target_definitions&#x27;</span>] = root_target_definitions.map(&amp;<span class="symbol">:to_hash</span>)</span><br><span class="line">  <span class="comment"># 将 TargetDefinition 树的所有内容与 internal_hash 进行合并</span></span><br><span class="line">  hash.merge!(internal_hash)</span><br><span class="line">  hash</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="依赖关系">依赖关系</h1>
<p>至此，我们差不多能明白 Podfile 的工作原理：Podfile 本质上是描述了一个
Pods Project 及其所包含的一系列 Xcode Target，其中每一个 Xcode Target
都指定一个 pod 库构建对应 Product。由于 Demo Project 和 Pods Project
处于同一个 Xcode Workspace 中，因此 Demo Project 可以直接引用 Pods
Project 构建的所有 Target，大体的依赖关系如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-00.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文以 Podfile 文件为入口，简单分析了 Podfile
文件的作用及其解析流程。在解析过程中，我们发现内部构建了一棵
TargetDefinition 树，树的层级结构正好与 Podfile 文件中的
<code>target</code> 嵌套结构相对应。每一个 <code>TargetDefinition</code>
节点存储了其所声明的 pod 依赖以及相关配置。Podfile
文件解析完成后会生成一个 <code>Podfile</code> 对象，该对象包含了 Podfile
文件声明的所有信息。</p>
<p>从本质上而言，Podfile 文件其实是描述了 Pods Project
的依赖以及配置。所有的第三方依赖都由 Pods Project
进行管理，主工程则是依赖 Pods Project
所构建的产物，从而有效地将主工程和第三方依赖进行了隔离。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/CocoaPods/Core">CocoaPods-Core</a></li>
</ol>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>Podifle</tag>
        <tag>TargetDefinition</tag>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods Podspec 解析原理</title>
    <url>/2022/01/03/podspec-analyze-principle/</url>
    <content><![CDATA[<p>在 CocoaPods 中，podspec 文件主要用于描述一个 pod
库的基本信息，包括：名称、版本、源、依赖等等。本文，我们来介绍一下
CocoaPods-Core 中另一个重要的部分——podspec。</p>
<span id="more"></span>
<h1 id="podspec-初始化">Podspec 初始化</h1>
<p>当执行 <code>pod install</code> 时，CocoaPods 会从本地的 pod repo
中查找与指定的 pod 命名和版本所对应的 podspec 文件。如果没有找到，那么
CocoaPods 会更新 pod repo，这背后有着一套复杂的管理机制，关于 podspec
管理机制下一篇文章我们将进行介绍。如果找到了，那么 CocoaPods 会对
podspec 文件进行初始化。</p>
<p><code>Source</code> 类提供了一个
<code>specification(name, version)</code> 方法支持加载指定命名和版本的
podspec，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># source.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">specification</span>(<span class="params">name, version</span>)</span><br><span class="line">  <span class="title class_">Specification</span>.from_file(specification_path(name, version))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>CocoaPods-Core</code> 使用
<code>Specification</code>/<code>Spec</code> 类表示
podspec，其提供了一个类方法 <code>self.from_file</code> 支持 podspec
初始化，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.from_file(path, subspec_name = <span class="literal">nil</span>)</span><br><span class="line">  path = <span class="title class_">Pathname</span>.new(path)</span><br><span class="line">  <span class="comment"># 如果指定的 podspec 文件不存在，则抛出异常</span></span><br><span class="line">  <span class="keyword">unless</span> path.exist?</span><br><span class="line">    <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;No podspec exists at path `<span class="subst">#&#123;path&#125;</span>`.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 读取 podspec 文件内容</span></span><br><span class="line">  string = <span class="title class_">File</span>.open(path, <span class="string">&#x27;r:utf-8&#x27;</span>, &amp;<span class="symbol">:read</span>)</span><br><span class="line">  <span class="comment"># Work around for Rubinius incomplete encoding in 1.9 mode</span></span><br><span class="line">  <span class="comment"># 对 podspec 文本进行 UTF-8 编码</span></span><br><span class="line">  <span class="keyword">if</span> string.respond_to?(<span class="symbol">:encoding</span>) &amp;&amp; string.encoding.name != <span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line">    string.encode!(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 初始化</span></span><br><span class="line">  from_string(string, path, subspec_name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>self.from_file</code> 会对文件路径进行校验，并读取 podspec
文件内容，进行 UTF-8 编码后，调用 <code>self.from_string</code>
方法进行初始化。<code>self.from_string</code> 方法实现如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.from_string(spec_contents, path, subspec_name = <span class="literal">nil</span>)</span><br><span class="line">  path = <span class="title class_">Pathname</span>.new(path).expand_path</span><br><span class="line">  spec = <span class="literal">nil</span></span><br><span class="line">  <span class="comment"># 根据 podspec 的文件类型，选择不同的方式进行初始化</span></span><br><span class="line">  <span class="keyword">case</span> path.extname</span><br><span class="line">  <span class="keyword">when</span> <span class="string">&#x27;.podspec&#x27;</span></span><br><span class="line">    <span class="title class_">Dir</span>.chdir(path.parent.directory? ? path.parent : <span class="title class_">Dir</span>.pwd) <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># 执行 podspec 文件所定义的 ruby 代码</span></span><br><span class="line">      spec = <span class="symbol">:</span><span class="symbol">:Pod</span>._eval_podspec(spec_contents, path)</span><br><span class="line">      <span class="keyword">unless</span> spec.is_a?(<span class="title class_">Specification</span>)</span><br><span class="line">        <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;Invalid podspec file at path `<span class="subst">#&#123;path&#125;</span>`.&quot;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">when</span> <span class="string">&#x27;.json&#x27;</span></span><br><span class="line">    spec = <span class="title class_">Specification</span>.from_json(spec_contents)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;Unsupported specification format `<span class="subst">#&#123;path.extname&#125;</span>` for spec at `<span class="subst">#&#123;path&#125;</span>`.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  spec.defined_in_file = path</span><br><span class="line">  spec.subspec_by_name(subspec_name, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从 <code>self.from_string</code> 方法的实现可以看出，podspec
支持两种文件类型，分别是：<code>.podspec</code> 和
<code>.json</code>。</p>
<p>对于 <code>.podspec</code> 文件类型，podspec 文件中定义的 ruby
代码，因此直接调用 <code>::Pod._eval_podspec</code> 方法执行 ruby
代码，从而完成初始化。</p>
<p>对于 <code>.json</code> 文件类型，<code>specification</code>
类通过混入（mixin）实现了 <code>from_json</code> 方法的
<code>JSONSupport</code> 模块，从而完成初始化。<code>from_json</code>
的内部实现如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification/json.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.from_json(json)</span><br><span class="line">  <span class="keyword">require</span> <span class="string">&#x27;json&#x27;</span></span><br><span class="line">  <span class="comment"># 将 json 转换为 hash</span></span><br><span class="line">  hash = <span class="variable constant_">JSON</span>.parse(json)</span><br><span class="line">  from_hash(hash)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.from_hash(hash, parent = <span class="literal">nil</span>, <span class="symbol">test_specification:</span> <span class="literal">false</span>, <span class="symbol">app_specification:</span> <span class="literal">false</span>)</span><br><span class="line">  attributes_hash = hash.dup</span><br><span class="line">  spec = <span class="title class_">Spec</span>.new(parent, <span class="literal">nil</span>, test_specification, <span class="symbol">:app_specification</span> =&gt; app_specification)</span><br><span class="line">  subspecs = attributes_hash.delete(<span class="string">&#x27;subspecs&#x27;</span>)</span><br><span class="line">  testspecs = attributes_hash.delete(<span class="string">&#x27;testspecs&#x27;</span>)</span><br><span class="line">  appspecs = attributes_hash.delete(<span class="string">&#x27;appspecs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">## backwards compatibility with 1.3.0</span></span><br><span class="line">  spec.test_specification = !attributes_hash[<span class="string">&#x27;test_type&#x27;</span>].<span class="literal">nil</span>?</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将 podspec hash 赋值给 Specificaiton 对象的 attributes_hash 属性</span></span><br><span class="line">  spec.attributes_hash = attributes_hash</span><br><span class="line">  <span class="comment"># 修改 Specification 对象的 subsepcs 属性</span></span><br><span class="line">  spec.subspecs.concat(subspecs_from_hash(spec, subspecs, <span class="literal">false</span>, <span class="literal">false</span>))</span><br><span class="line">  spec.subspecs.concat(subspecs_from_hash(spec, testspecs, <span class="literal">true</span>, <span class="literal">false</span>))</span><br><span class="line">  spec.subspecs.concat(subspecs_from_hash(spec, appspecs, <span class="literal">false</span>, <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">  spec</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>self.from_json</code> 将 json 格式的 podspec 转换成了
hash，然后以此为参数调用 <code>self.from_hash</code> 方法进行 podspec
初始化。</p>
<p><code>self.from_hash</code> 中初始化一个 <code>Specification</code>
对象，并对其相关属性进行设置。这里，最关键的就是 <strong>将 hash 赋值给
<code>Specification</code> 对象的 <code>attribuets_hash</code>
属性</strong>，从而使 <code>Specification</code> 对象拥有了 podspec
所描述的所有信息。</p>
<h1 id="specification-树构建">Specification 树构建</h1>
<p>在上一节中，<code>self.from_hash</code> 方法完成了对 podspec
的初始化，需要注意其内部还调用了 <code>self.subspecs_from_hash</code>
方法，该方法的实现如下所示： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification/json.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">self</span>.subspecs_from_hash(spec, subspecs, test_specification, app_specification)</span><br><span class="line">  <span class="keyword">return</span> [] <span class="keyword">if</span> subspecs.<span class="literal">nil</span>?</span><br><span class="line">  <span class="comment"># 每一个 subspec 对应初始化一个 Specification 对象，并构建一个 Specification 树</span></span><br><span class="line">  subspecs.map <span class="keyword">do</span> |<span class="params">s_hash</span>|</span><br><span class="line">    <span class="title class_">Specification</span>.from_hash(s_hash, spec,</span><br><span class="line">                            <span class="symbol">:test_specification</span> =&gt; test_specification,</span><br><span class="line">                            <span class="symbol">:app_specification</span> =&gt; app_specification)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>方法内部对 <code>Specification</code> 的每一个 subspec 初始化一个
<code>Specification</code> 对象，并绑定父子关系，从而构建一棵
<code>Specification</code> 树。以 AFNetworking 为例，根据其 podspec
构建的 <code>Specification</code> 树如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-specification-03.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="specification-核心">Specification 核心</h1>
<p>前面，我们介绍了通过 podspec 如何构建一棵 <code>Specification</code>
树，下面我们来看看 <code>Specification</code> 的核心结构，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Specification</span></span><br><span class="line">    <span class="comment"># subspec 的父节点</span></span><br><span class="line">    <span class="built_in">attr_reader</span> <span class="symbol">:parent</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># spec 的唯一 ID，name + version 的 hash</span></span><br><span class="line">    <span class="built_in">attr_reader</span> <span class="symbol">:hash_value</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># spec 的配置信息</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:attributes_hash</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># spec 包含的 subspec</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:subspecs</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>类似于 <code>Podfile</code>，<code>Specification</code> 同样使用
<code>attributes_hash</code> 记录配置信息。此外，对于
<code>subspec</code>，会有一个 <code>parent</code> 属性指向其所属的
<code>Specification</code> 父节点。</p>
<p>当看到了 <code>Specification</code>
类的核心实现后，我们可能会想到上一篇文章中所提到的
<code>TargetDefinition</code>
类。两者都构建了一个树结构，两者之间是否存在什么关系？</p>
<p><strong>在 Xcode 中，target
作为一个最小的可编译单元，它编译后的产物为链接库或 framework。在
CocoaPods 中，target 则由 <code>Specification</code>
进行描述，最终转换成 <code>TargetDefinition</code>，即 Xcode
Target。</strong></p>
<p><strong>在 Xcode 中，一个 target 可以依赖其他 target
进行构建。对应，在 CocoaPods 中，一个 spec 可以依赖其他
subspec，从而描述整个构建关系。</strong></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-specification-02.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>subspec
可以单独作为依赖被引入到项目中</strong>，其包含以下特点：</p>
<ul>
<li>在未指定 <code>default_subspec</code> 的情况下，spec 的全部 subspec
都将作为依赖被引入项目</li>
<li>subspec 会主动继承父节点 spec 所定义的
<code>attributes_hash</code></li>
<li>subspec 可以指定自己的源代码、资源文件、编译配置、依赖等</li>
<li>同一 spec 内部的 subspec 之间可以存在依赖关系</li>
<li>每个 subspec 在 <code>pod push</code> 时都需要 lint 通过</li>
</ul>
<h1 id="specification-dsl">Specification DSL</h1>
<p>与 Podfile 类似，Podspec 也定义了一系列 DSL，DSL
基本原理是：<strong>使用一个哈希表存储配置项，并提供一系列方法对应操作不同的配置项</strong>。具体过程包括以下几个步骤：</p>
<ul>
<li>使用 <code>attribute</code> 或 <code>root_attribute</code>
方法声明属性和配置</li>
<li>属性和配置直接存储至类属性 <code>Self.attributes</code></li>
<li>遍历 <code>Self.attributes</code>，为每个属性名称定义动态 setter
方法</li>
<li>属性和配置转发存储至实例属性 <code>attributes_hash</code></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-specification-01.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示，<code>Specification::DSL::AttributeSupport</code>
模块定义了上述流程中几个关键的属性和方法：<code>Self.attributes</code>、<code>root_attribute</code>、<code>attribute</code>、<code>store_attribute</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification/dsl/attribute_support.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Specification</span></span><br><span class="line">    <span class="keyword">module</span> <span class="variable constant_">DSL</span></span><br><span class="line">      <span class="comment"># 类属性</span></span><br><span class="line">      <span class="keyword">class</span> &lt;&lt; <span class="variable language_">self</span></span><br><span class="line">        <span class="built_in">attr_reader</span> <span class="symbol">:attributes</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">module</span> <span class="title class_">AttributeSupport</span></span><br><span class="line">        <span class="comment"># 根配置</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">root_attribute</span>(<span class="params">name, options = &#123;&#125;</span>)</span><br><span class="line">          options[<span class="symbol">:root_only</span>] = <span class="literal">true</span></span><br><span class="line">          options[<span class="symbol">:multi_platform</span>] = <span class="literal">false</span></span><br><span class="line">          store_attribute(name, options)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 普通配置</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">attribute</span>(<span class="params">name, options = &#123;&#125;</span>)</span><br><span class="line">          store_attribute(name, options)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 存储方法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">store_attribute</span>(<span class="params">name, options</span>)</span><br><span class="line">          attr = <span class="title class_">Attribute</span>.new(name, options)</span><br><span class="line">          <span class="variable">@attributes</span> |<span class="params"></span>|= &#123;&#125;</span><br><span class="line">          <span class="variable">@attributes</span>[name] = attr</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如下所示，<code>Specification</code>
类中定义了动态方法和存储转发逻辑。 <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specification.rb</span></span><br><span class="line"><span class="comment"># 将属性存储至 attributes_hash</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_attribute</span>(<span class="params">name, value, platform_name = <span class="literal">nil</span></span>)</span><br><span class="line">  name = name.to_s</span><br><span class="line">  value = <span class="title class_">Specification</span>.convert_keys_to_string(value) <span class="keyword">if</span> value.is_a?(<span class="title class_">Hash</span>)</span><br><span class="line">  value = value.strip_heredoc.strip <span class="keyword">if</span> value.respond_to?(<span class="symbol">:strip_heredoc</span>)</span><br><span class="line">  <span class="keyword">if</span> platform_name</span><br><span class="line">    platform_name = platform_name.to_s</span><br><span class="line">    attributes_hash[platform_name] |<span class="params"></span>|= &#123;&#125;</span><br><span class="line">    attributes_hash[platform_name][name] = value</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    attributes_hash[name] = value</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spec 类加载时遍历 attributes 动态生成 setter 方法</span></span><br><span class="line"><span class="variable constant_">DSL</span>.attributes.values.each <span class="keyword">do</span> |<span class="params">a</span>|</span><br><span class="line">  <span class="built_in">define_method</span>(a.writer_name) <span class="keyword">do</span> |<span class="params">value</span>|</span><br><span class="line">    store_attribute(a.name, value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> a.writer_singular_form</span><br><span class="line">    alias_method(a.writer_singular_form, a.writer_name)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>Podspec DSL 根据功能可以分为以下 6 大类，具体 DSL
定义可以参考官方文档——<a
href="https://guides.cocoapods.org/syntax/podspec.html">传送门</a>。</p>
<ul>
<li><strong>Root
Specification</strong>：基本配置，用于描述名称、版本号等</li>
<li><strong>Platform</strong>：指定平台约束</li>
<li><strong>Build
Settings</strong>：构建所需的依赖配置，如：<code>dependency</code>、<code>frameworks</code></li>
<li><strong>File
Patterns</strong>：文件管理，如：源码文件、资源文件、内嵌
frameworks、内嵌 libraries</li>
<li><strong>Subspecs</strong>：podspec 的子模块，一个子模块以一个 target
为单元进行构建</li>
<li><strong>Multi-Platform
Support</strong>：为不同的平台执行不同的资源文件</li>
</ul>
<h1 id="总结">总结</h1>
<p>整体而言，Podspec 的解析原理与 Podfile 差不多，都是定义一组 DSL，通过
DSL
方法将配置的属性保存在一个对象的哈希表中。与此同时，构建一个树从而建立相互之间的依赖关系，所有的配置信息都保存在一棵对象树中。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/CocoaPods/Core">CocoaPods-Core</a></li>
<li><a
href="https://looseyi.github.io/post/sourcecode-cocoapods/05-cocoapods-podspec/">PodSpec
文件分析</a></li>
</ol>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>podspec</tag>
        <tag>Specification</tag>
      </tags>
  </entry>
  <entry>
    <title>20个强大的Sublime Text插件</title>
    <url>/2017/05/12/powerful-sublimetext-pulgin/</url>
    <content><![CDATA[<p><a
href="http://inspiretrends.com/20-powerful-sublimetext-plugins/">原文链接</a><br />
SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。这些非常棒的特性包括：</p>
<ul>
<li>任意跳转（Goto Anything）<br />
</li>
<li>多重选择（multiple selections）</li>
<li>指令面板（command palette）<br />
</li>
<li>免打扰模式（distraction free mode）<br />
</li>
<li>分区编辑（split editing）<br />
</li>
<li>快速项目切换（instant project switch）<br />
</li>
<li>...</li>
</ul>
<span id="more"></span>
<p>此外，你还可以随意地自定义更多功能。更重要的是，Sublime支持Mac、Windows和Linux等多种系统平台。</p>
<p>SublimeText本身已经非常强大，但是更棒的是还有大量的插件支持它，给它带来更强大的功能，这就是本文要讨论的内容。不多废话，让我们看看20个强大的SublimeText插件。</p>
<h2 id="ftpsync"># 20 <a
href="https://github.com/NoxArt/SublimeText2-FTPSync">FTPsync</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin001.gif" />
</div>
<p>默认情况下SublimeText不具备FTP功能，如果你正在寻找能在你的SublimeText应用程序中使用的免费易用的FTP工具，你可以考虑FTPSync。这是一个非常简单的FTP同步工具，它可以控制上传目标的多重命名。</p>
<h2 id="sass-build"># 19 <a
href="https://github.com/jaumefontal/SASS-Build-SublimeText2">SASS
Build</a></h2>
<p>SASS Build
是一个编写CSS的预处理器。这个插件可以帮助你妥善构建包括压缩选项在内的SASS文件。一旦你安装了这个插件，你可以很容易地通过按Ctrl+
B（MAC系统是 Command +B）来启动它。</p>
<h2 id="package-control"># 18 <a
href="https://packagecontrol.io/installation">Package Control</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin002.gif" />
</div>
<p>简而言之，这个是你在完成安装SublimeText后必须安装的东西。因为有了这个特殊的“插件”，你可以很容易地安装、升级、删除，甚至非常方便地查看你已经安装在SublimeText中的包或插件的列表。它通过菜单和对应的行为使这些过程变得非常容易和有组织。</p>
<h2 id="emmet"># 17 <a href="https://emmet.io/">Emmet</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin003.gif" />
</div>
<p>Emmet（前身是大名鼎鼎的Zen
Coding）是一个可以让你更快更高效地编写HTML和CSS，节省你大量时间的插件。你只需按约定的缩写形式书写而不用写整个代码，然后按“扩展”键，这些缩写就会自动扩展为对应的代码内容。
比如，你只需要输入 ((h4&gt;a[rel=external])+p&gt;img[width=500
height=320])*12
，然后它会被扩展转换成12个列表项和紧随其后的图像。然后你就可以在此基础上再填写内容，就这么简单。</p>
<h2 id="sublimelinter"># 16 <a
href="https://github.com/titoBouzout/SideBarEnhancements/tree/st3">SublimeLinter</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin004.gif" />
</div>
<p>这个插件最近才为SublimeText3重建和发布。新版本带来了很多新的功能，而不是简单地把所有的Linter放在一个包中，开发者允许用户在升级时选择并安装自己经常使用的Linter。很明显，这可以节省磁盘空间。“更多的定制”，这对用户是很友好的。</p>
<h2 id="sublimeenhancements"># 15 <a
href="https://github.com/titoBouzout/SideBarEnhancements/tree/st3">SublimeEnhancements</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin005.gif" />
</div>
<p>这个插件可以给SublimeText的边栏菜单带来扩充的功能，包括：在当前工程文件夹中新建文件，移动文件或文件夹，产生文件或文件夹的副本，在新窗口或浏览器中打开，刷新等。这只是概括地说，安装后探索它更多的功能吧。</p>
<h2 id="packageresourceviewer"># 14 <a
href="https://github.com/skuroda/PackageResourceViewer">PackageResourceViewer</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin006.gif" />
</div>
<p>通过这个特殊的插件，会给你查看和编辑SublimeText附带的不同的包带来很多方便。你也可以提取任何给定的包。这一行动将其复制到用户文件夹，以便你可以安全地对其进行编辑。</p>
<h2 id="git"># 13 <a
href="https://github.com/kemayo/sublime-text-git">Git</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin007.gif" />
</div>
<p>虽然名字看上去并不友好，但作为开发者的你肯定一眼就能明白它是干什么的。这个插件会将Git整合进你的SublimeText，使的你可以在SublimeText中运行Git命令，包括添加，提交文件，查看日志，文件注解以及其它Git功能。</p>
<h2 id="terminal"># 12 <a
href="https://github.com/wbond/sublime_terminal">Terminal</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin008.gif" />
</div>
<p>这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。</p>
<h2 id="csscomb"># 11 <a href="http://csscomb.com/">CSSComb</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin009.gif" />
</div>
<p>这是用来给CSS属性进行排序的格式化插件。如果你想保持的代码干净整洁，并且希望按一定的顺序排列，那么这个插件是一种有效解决的方案。特别是当你和其他有自己代码编写风格的开发者一同协作的时候。</p>
<h2 id="caniuse"># 10 <a
href="http://timkl.xyz/sublime-text-caniuse/">CanIUse</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin010.gif" />
</div>
<p>如果你想检查浏览器是否支持你包括在你的代码中的CSS和HTML元素，那么这是你需要的插件。所有你需要做的就是选择有疑问的元素，插件将为你做其余的事情。</p>
<h2 id="alignment"># 9 <a
href="https://github.com/wbond/sublime_alignment">Alignment</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin011.gif" />
</div>
<p>这个插件让你能对齐你的代码，包括 PHP、CSS 和
Javascript。代码看起来更简洁和可读，便于编辑。您可以查看下面的图片来明白我说的意思。</p>
<h2 id="trimmer"># 8 <a
href="https://github.com/jonlabelle/Trimmer">Trimmer</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin012.gif" />
</div>
<p>你知道当你编写代码时，由于错误或别的某些原因，会产生一些不必要的空格。需要注意的是多余的空格有时也会造成错误。这个插件会自动删除这些不必要的空格。</p>
<h2 id="colorpicker"># 7 <a
href="http://weslly.github.io/ColorPicker/">ColorPicker</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin013.gif" />
</div>
<p>如果你经常要查看或设置颜色值，这个插件可以很方便地调用你本机的调色板应用。这是一个双向的功能，你既可以在调色板中选择一个颜色，然后按“确定”按钮把该值填写到
SublimeText
中活动文档的当前位置，也可以在活动文档中选择一个颜色的值，按此插件的快捷键就会在显示的调色板中定位到该值所对应的颜色。</p>
<h2 id="markdownediting"># 6 <a
href="https://github.com/SublimeText-Markdown/MarkdownEditing">MarkdownEditing</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin014.gif" />
</div>
<p>SublimeText不仅仅是能够查看和编辑 Markdown
文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。</p>
<h2 id="filediffs"># 5 <a
href="https://github.com/colinta/SublimeFileDiffs">FileDiffs</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin015.gif" />
</div>
<p>这个插件允许你看到SublimeText中两个不同文件的差异。你可以比较的对象可以是从剪贴板中复制的数据，或工程中的文件，当前打开的文件等。</p>
<h2 id="docblock"># 4 <a
href="https://github.com/spadgos/sublime-jsdocs">DocBlock</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin016.gif" />
</div>
<p>DocBlockr
可以使你很方便地对代码建立文档。它会解析函数，变量，和参数，根据它们自动生成文档范式，你的工作就是去填充对应的说明。</p>
<h2 id="定制主题"># 3 定制主题</h2>
拥有不同的主题可以触发创意和想法，你可能想使用这些插件来实现不同的主题，带来更好的和令人兴奋的前景。
## <a href="https://github.com/kkga/spacegray/">SpaceGray</a>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin017.gif" />
</div>
<h2 id="centurion"><a
href="https://github.com/allanhortle/Centurion">Centurion</a></h2>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sublime-plugin018.gif" />
</div>
<h2 id="snippets"># 2 Snippets</h2>
<p>Snippets，你一定已经听说了，可以帮你快速书写代码。但它不是像上面提到的插件那样使用缩写，它是重用代码块以节省您的时间。你甚至可以创建自己的代码段，这完全取决于你自己。</p>
<h2 id="语法支持"># 1 语法支持</h2>
<p>如果有一个SublimeText本身所带语言包不包含的语言，它就无法显示适当的语法高亮。这些语言包括LESS，Sass，SCSS，Styls和Jade（或其它）。如果您正在使用这些语言，你可能要安装它们的语法插件。
- <a href="https://github.com/danro/LESS-sublime">LESS</a> - <a
href="https://github.com/nathos/sass-textmate-bundle">Sass</a> - <a
href="https://github.com/MarioRicalde/SCSS.tmbundle">SCSS</a> - <a
href="https://github.com/billymoon/Stylus">Stylus</a> - <a
href="https://github.com/P233/Jade-Snippets-for-Sublime-Text-2">Jade</a></p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 核心实现原理</title>
    <url>/2022/10/16/promise-core-implement/</url>
    <content><![CDATA[<p>在传统的基于 <strong>闭包</strong> 的异步编程中，经常会出现
<strong>地狱嵌套</strong>
的问题，这使得高度异步的代码几乎无法阅读。Promise
则是解决这个问题的众多方案之一。</p>
<span id="more"></span>
<p>Promise
的核心思想是：<strong>实现一个容器，对内管理异步任务的执行状态，对外提供同步编程的代码结构，从而具备更好的可读性</strong>。本文，我们将通过分析
Promise 的设计思想，并实现 Promise 核心逻辑，从而深入理解 Promise
实现原理。</p>
<p>本文所实现的 Promise 代码已在 Github 开源——<a
href="https://github.com/baochuquan/implementing-promise">传送门</a>。</p>
<h1 id="future-vs.-promise">Future vs. Promise</h1>
<p>Future 和 Promise
是异步编程中经常提到的两个概念，两者的关系经常用一句话来概括——A Promise
to Future。</p>
<p>我们可以认为 Future 和 Promise 是一种异步编程技术的两个部分：</p>
<ul>
<li><strong>Future
是异步任务的返回值，表示一个未来值的占位符，是值的消费者。</strong></li>
<li><strong>Promise
是异步任务的执行过程，表示一个值的生产过程，是值的生产者。</strong></li>
</ul>
<p>以如下一段 Dart 代码为例，<code>getUserInfo</code> 方法体是一个
Promise，其定义了值的生产过程，<code>getUserInfo</code> 方法返回值是一个
Future，其定义了一个未来值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;UserInfo&gt; getUserInfo(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> response = <span class="keyword">await</span> <span class="keyword">get</span>(<span class="string">&#x27;https://chuquan.me/userinfo&#x27;</span>);</span><br><span class="line">        <span class="keyword">final</span> userInfo = UserInfo.fromJson(response.data <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;);</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125; <span class="keyword">on</span> DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        Toast.instance.showNetworkError(context, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future 和 Promise
来源于函数式编程语言，其目的是分离一个值和生产值的方法，从而简化异步编程。本质上，两者是一一对应的。</p>
<p>很多语言都有 Future 和 Promise 的实现，比如：Swift Task、C# Task、C++
std::future、Scala Future 对应的是 Future 的实现；C++
std::promise、JavaScript Promise、Scala Promise 对应的是 Promise
的实现。</p>
<h1 id="基本用法">基本用法</h1>
<p>Promise
支持以同步代码结构编写异步代码逻辑，其提供一系列便利方法以支持链式调用，如：<code>then</code>、<code>done</code>、<code>catch</code>、<code>finally</code>
等。注意，不同的编程语言或库实现中，方法命名有所不同。</p>
<p>如下所示，是一个以 JavaScript 编写的 Promise 的基本用法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="基本原理">基本原理</h1>
<p>本质上，Promise 是一个对象，其包含三种状态，分别是：</p>
<ul>
<li><strong><code>pending</code>：表示进行中状态</strong>。</li>
<li><strong><code>fulfilled</code>：表示已成功状态状态</strong>。此时，Promise
得到一个结果值 <code>value</code>。</li>
<li><strong><code>rejected</code>：表示已失败状态</strong>。此时，Promise
得到一个错误值 <code>error</code>，用于表示错误原因。</li>
</ul>
<p><code>pending</code> 是起始状态，<code>fulfilled</code> 和
<code>rejected</code> 是结束状态。一旦 Promise
的状态发生了变化，它将不会再改变。因此，Promise 是一种
<strong>单赋值</strong> 的结构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promise-03.png?x-oss-process=image/resize,w_800" /></p>
<p>Promise 内部的状态由 <strong>执行器（executor）</strong> 或
<strong>解析器（resolver）</strong> 来进行更新。Promise
创建时的状态默认为 <code>pending</code>，用户为 Promise
提供状态转移逻辑，比如：网络请求成功时将状态设置为
<code>fulfilled</code>，网络请求失败时将状态设置为
<code>rejected</code>。通常，执行器会提供两个方法 <code>resolve</code>
和 <code>reject</code> 分别用于设置 <code>fulfilled</code> 和
<code>rejected</code> 状态。</p>
<p>此外，Promise
还支持通过链式操作符实现回调任务的链式执行，其原理是在内部维护一个回调任务列表，当
Promise
到达结束状态时，自动执行内部的回调任务，从而整体实现异步任务的链式执行。</p>
<h1 id="核心实现">核心实现</h1>
<p>下面，我们来手动实现 Promise 的核心逻辑，编程语言为 Swift。</p>
<h2 id="状态">状态</h2>
<p>首先，定义 Promise 的三个状态，如下所示。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> pending</span><br><span class="line">    <span class="keyword">case</span> fulfilled</span><br><span class="line">    <span class="keyword">case</span> rejected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="执行器">执行器</h2>
<p>Promise
的核心目标是为了解决异步（或同步）任务的相关问题。首先，要解决两个问题：</p>
<ul>
<li><strong>如何表示异步任务？</strong></li>
<li><strong>如何更新任务状态？</strong></li>
</ul>
<p>对于第一个问题，很简单，我们可以提供一个闭包，让用户在闭包中自定义任务即可。</p>
<p>对于第二个问题，同样，我们可以提供两个状态更新方法，让用户在任务的特定阶段调用即可。</p>
<p>这里，我们定义的执行器如下所示。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Resolve</span>&lt;<span class="type">T</span>&gt; <span class="operator">=</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Reject</span> <span class="operator">=</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Executor</span> <span class="operator">=</span> (<span class="keyword">_</span> resolve: <span class="keyword">@escaping</span> <span class="type">Resolve</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">_</span> reject: <span class="keyword">@escaping</span> <span class="type">Reject</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上述定义的执行器是一个闭包，闭包的参数是两个状态更新方法，分别是
<code>resolve</code> 和
<code>reject</code>，可供用户在任务的特定阶段调用，以更新任务的状态。</p>
<p>由于 <code>resolve</code> 和 <code>reject</code> 方法分别用于设置
<code>fulfilled</code> 和 <code>rejected</code>
状态，两个状态分别对应两个值：<code>value</code> 和
<code>error</code>，从方法的入参可以看出两者的区别。因此，除了状态之外，还需定义两个字段，分别用于保存
<code>value</code> 和 <code>error</code>，具体定义如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> state: <span class="type">State</span> <span class="operator">=</span> .pending</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> value: <span class="type">T</span>?</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> error: <span class="type">Error</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式执行">链式执行</h2>
<p>Promise 的核心功能之一是 <strong>链式执行</strong>
异步任务。那么，如何实现链式执行异步任务呢？很简单，我们将后一个 Promise
的异步任务存储在前一个 Promise 的回调任务列表中，当前一个 Promise
达到结束状态（<code>fulfilled</code> 或
<code>rejected</code>）时，执行其内部保存的下一个（组）回调任务即可。</p>
<p>对此，我们可以在 Promise 内部保存两个数组，分别用户存储
<code>fulfilled</code> 状态和 <code>rejected</code>
状态时要执行的回调任务。除此之外，我们还需要对 <code>resolve</code> 和
<code>reject</code>
方法进行进一步加工，方法调用时，分别设置当前异步任务的返回值、状态，并执行回调任务。具体定义如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> onFulfilledCallbacks <span class="operator">=</span> [<span class="type">Resolve</span>&lt;<span class="type">T</span>&gt;]()</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> onRejectedCallbacks <span class="operator">=</span> [<span class="type">Reject</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">executor</span>: <span class="type">Executor</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：resolve 和 reject 必须强引用 self，避免在执行 resolve 和 reject 之前系统释放 self</span></span><br><span class="line">        <span class="keyword">let</span> resolve: <span class="type">Resolve</span>&lt;<span class="type">T</span>&gt; <span class="operator">=</span> &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">            <span class="keyword">self</span>.onFulfilledCallbacks.forEach &#123; onFullfilled <span class="keyword">in</span></span><br><span class="line">                onFullfilled(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.state <span class="operator">=</span> .fulfilled</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject: <span class="type">Reject</span> <span class="operator">=</span> &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.error <span class="operator">=</span> error</span><br><span class="line">            <span class="keyword">self</span>.onRejectedCallbacks.forEach &#123; onRejected <span class="keyword">in</span></span><br><span class="line">                onRejected(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.state <span class="operator">=</span> .rejected</span><br><span class="line">        &#125;</span><br><span class="line">        executor &#123; value <span class="keyword">in</span></span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125; <span class="keyword">_</span>: &#123; error <span class="keyword">in</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们分别使用 <code>onFulfilledCallbacks</code> 和
<code>onRejectedCallbacks</code> 保存回调任务。同时定义了
<code>resolve</code> 和 <code>reject</code>
两个方法，内部分别设置异步任务的返回值、状态，并执行回调任务。</p>
<p>Promise
初始化时，执行器会立即执行，从而触发异步任务的执行，同时将两个状态更新方法作为参数传入闭包，以供用户在任务的特定阶段调用。</p>
<h2 id="任务串联">任务串联</h2>
<p>Promise 通过 <code>then</code> 方法来串联任务，即让前一个 Promise
保存下一个 Promise 的任务。<code>then</code> 方法包含两个闭包
<code>onFulfilled</code> 和
<code>onRejected</code>，分别表示不同状态的回调任务，其在前一个 Promise
的状态为 <code>fulfilled</code> 和 <code>rejected</code>
时分别执行。</p>
<p>当 <code>then</code> 串联任务时，我们需要考虑前一个 Promise
的状态。这里，我们分三种情况进行考虑：</p>
<ul>
<li>当前一个 Promise 的状态为 <code>pending</code> 时，我们创建一个
Promise，其任务的核心是将 <code>onFulfilled</code> 和
<code>onRejected</code> 分别加入前一个 Promise 的回调任务队列中。</li>
<li>当前一个 Promise 的状态为 <code>fulfilled</code> 时，我们创建一个
Promise，其任务的核心是立即执行 <code>onFulfilled</code> 任务。</li>
<li>当前一个 Promise 的状态未 <code>rejected</code> 时，我们创建一个
Promise，其任务的核心是立即执行 <code>onRejected</code> 任务。</li>
</ul>
<p><code>then</code> 方法的具体实现如下所示。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="comment">// Functor</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">then</span>&lt;<span class="type">R</span>&gt;(<span class="params">onFulfilled</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">R</span>, <span class="params">onRejected</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .pending:</span><br><span class="line">            <span class="comment">// 将普通函数应用到包装类型，并返回包装类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] resolve, reject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 初始化时即执行</span></span><br><span class="line">                <span class="comment">// 在 curr promise 加入 onFulfilled/onRejected 任务，任务可修改 curr promise 的状态</span></span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onFulfilledCallbacks.append &#123; value <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">let</span> r <span class="operator">=</span> onFulfilled(value)</span><br><span class="line">                    resolve(r)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onRejectedCallbacks.append &#123; error <span class="keyword">in</span></span><br><span class="line">                    onRejected(error)</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .fulfilled:</span><br><span class="line">            <span class="keyword">let</span> value <span class="operator">=</span> value<span class="operator">!</span></span><br><span class="line">            <span class="comment">// 将普通函数应用到包装类型，并返回包装类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; resolve, <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> r <span class="operator">=</span> onFulfilled(value)</span><br><span class="line">                resolve(r)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .rejected:</span><br><span class="line">            <span class="keyword">let</span> error <span class="operator">=</span> error<span class="operator">!</span></span><br><span class="line">            <span class="comment">// 将普通函数应用到包装类型，并返回包装类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; <span class="keyword">_</span>, reject <span class="keyword">in</span></span><br><span class="line">                onRejected(error)</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>onFulfilled</code> 和 <code>onRejected</code>
闭包的入参和返回值，这是 <code>then</code>
能够实现异步任务的值传递的关键。</p>
<h2 id="monad">Monad</h2>
<p>上一节的 <code>then</code> 方法主要是 Functor 实现，为了进一步扩展
<code>then</code> 方法的，我们来实现 Monad <code>then</code>
方法，具体实现如下所示。</p>
<p>关于 Functor 和 Monad 的概念，可以阅读 <a
href="http://chuquan.me/2020/07/06/fp-functor-applicative-monad/">《函数式编程——Functor、Applicative、Monad》</a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="comment">// Monad</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">then</span>&lt;<span class="type">R</span>&gt;(<span class="params">onFulfilled</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">R</span>&gt;, <span class="params">onRejected</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .pending:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] resolve, reject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 初始化时即执行</span></span><br><span class="line">                <span class="comment">// 在 prev promise 的 callback 队列加入一个生成 midd promise 的任务。</span></span><br><span class="line">                <span class="comment">// 在 midd promise 的 callback 队列加入一个任务，修改 curr promise 状态。</span></span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onFulfilledCallbacks.append &#123; value <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">let</span> promise <span class="operator">=</span> onFulfilled(value)</span><br><span class="line">                    promise.then(onFulfilled: &#123; r <span class="keyword">in</span></span><br><span class="line">                        resolve(r)</span><br><span class="line">                    &#125;, onRejected: &#123; <span class="keyword">_</span> <span class="keyword">in</span> &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onRejectedCallbacks.append &#123; error <span class="keyword">in</span></span><br><span class="line">                    onRejected(error)</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .fulfilled:</span><br><span class="line">            <span class="keyword">return</span> onFulfilled(value<span class="operator">!</span>)</span><br><span class="line">        <span class="keyword">case</span> .rejected:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; <span class="keyword">_</span>, reject <span class="keyword">in</span></span><br><span class="line">                onRejected(error<span class="operator">!</span>)</span><br><span class="line">                reject(error<span class="operator">!</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="便利方法">便利方法</h2>
<p>通常 Promise
还具有一系列遍历方法，如：<code>fistly</code>、<code>catch</code>、<code>done</code>、<code>finally</code>
等。下面，我们依次实现。</p>
<p><code>firstly</code>
方法本质上是语法糖，表示异步任务组的第一步。我们实现一个全局方法，通过闭包实现任务的具体逻辑，如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">firstly</span>&lt;<span class="type">T</span>&gt;(<span class="params">closure</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>catch</code> 方法仅用于处理错误，其可通过 <code>then</code>
方法实现，关键是实现 <code>onRejected</code> 方法，如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">`catch`</span>(<span class="params">onError</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> then(onFulfilled: &#123; <span class="keyword">_</span> <span class="keyword">in</span> &#125;, onRejected: onError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>done</code> 方法仅用于处理返回值，其可通过 <code>then</code>
方法实现，关键是实现 <code>onFulfilled</code> 方法，如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">done</span>(<span class="params">onNext</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> then(onFulfilled: onNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>finally</code> 方法用于 Promise
链式调用的末尾，其并不接收之前任务的返回值和错误，支持用户在任务结束时执行状态无关的任务，具体实现如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">finally</span>(<span class="params">onCompleted</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        then(onFulfilled: &#123; <span class="keyword">_</span> <span class="keyword">in</span> onCompleted() &#125;, onRejected: &#123; <span class="keyword">_</span> <span class="keyword">in</span> onCompleted() &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="内存管理">内存管理</h1>
<p>类似 Rx，Promise 的内存管理十分巧妙，其核心原理是
<strong>通过闭包强引用对象</strong>。下面，我们来分别介绍一下 Functor
<code>then</code> 和 Monad <code>then</code> 的内存管理。</p>
<h2 id="functor-then">Functor <code>then</code></h2>
<p>如下所示，为 Functor <code>then</code> 方法产生的内存管理示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promise-01.png?x-oss-process=image/resize,w_800" /></p>
<p>在初始化 Promise 时，<code>resolve</code> 和 <code>reject</code>
方法必须强引用 Promise，否则等到异步任务执行完成时，Promise
早已释放，根本无法通过 Promise 执行回调任务。</p>
<p>当调用 Functor <code>then</code> 方法时，Promise
的两个回调任务列表将引用 <code>then</code> 方法所传入的两个闭包
<code>onFulfilled</code> 和 <code>onRejected</code>，同时引用
<code>then</code> 方法内部创建的 Promise 的 <code>resolve</code> 和
<code>reject</code> 方法。新创建的 Promise 又被自身的
<code>resolve</code> 和 <code>reject</code>
方法所引用，从而实现线性的内存引用关系。</p>
<h2 id="monad-then">Monad <code>then</code></h2>
<p>如下所示，为 Monad <code>then</code> 方法产生的内存管理示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promise-02.png?x-oss-process=image/resize,w_800" /></p>
<p>同样，当调用 Monad <code>then</code> 方法是，Promise
的两个回调任务数组将引用 <code>then</code> 方法所传入的两个闭包
<code>onFulfilled</code> 和 <code>onRejected</code>，同时引用
<code>then</code> 方法内部创建的 Promise 的 <code>reject</code>
方法。从而实现线性的内存引用关系。</p>
<p>区别于 Functor <code>then</code>，Monad <code>then</code> 方法的
<code>onFulfilled</code> 闭包会返回一个包装类型
<code>Promise&lt;R&gt;</code>。因此，当 Promise 状态为
<code>fulfilled</code> 或 <code>rejected</code> 时，<code>then</code>
会立即返回由该闭包生成的 Promise；当 Promise 状态为 <code>pending</code>
时，<code>then</code> 会将闭包生成的 Promise 作为中间层
Promise，由中间层 Promise 调用 Functor
<code>then</code>，从而产生一个间接的线性内存引用。</p>
<h1 id="功能测试">功能测试</h1>
<p>下面，我们来编写一个网络请求的例子来对我们实现的 Promise
进行测试。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetworkError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> decodeError</span><br><span class="line">    <span class="keyword">case</span> responseError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> avatarURL: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123; <span class="string">&quot;name: =&gt; <span class="subst">\(name)</span>; avatar =&gt; <span class="subst">\(avatarURL)</span>&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAPI</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">user</span>() -&gt; <span class="type">Promise</span>&lt;<span class="type">User</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">User</span>&gt; &#123; (resolve, reject) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// Mock HTTP Request</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;request user info&quot;</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> arc4random() <span class="operator">%</span> <span class="number">10</span> <span class="operator">!=</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> result &#123;</span><br><span class="line">                    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>(name: <span class="string">&quot;chuquan&quot;</span>, avatarURL: <span class="string">&quot;avatarurl&quot;</span>)</span><br><span class="line">                    resolve(user)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">NetworkError</span>.responseError)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">avatar</span>() -&gt; <span class="type">Promise</span>&lt;<span class="type">UIImage</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">UIImage</span>&gt; &#123; (resolve, reject) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// Mock HTTP Request</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;request avatar info&quot;</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> arc4random() <span class="operator">%</span> <span class="number">10</span> <span class="operator">!=</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> result &#123;</span><br><span class="line">                    <span class="keyword">let</span> avatar <span class="operator">=</span> <span class="type">UIImage</span>()</span><br><span class="line">                    resolve(avatar)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">NetworkError</span>.decodeError)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个 <code>TestAPI</code>
的类，其提供两个方法，分别请求用户信息和头像信息，返回值均为
Promise。其内部我们使用 GDC
延迟进行模拟，使用随机数设置网络请求的成功和失败情况。</p>
<p>接下来，我们来进行功能测试，依次请求用户信息和头像信息，如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> api <span class="operator">=</span> <span class="type">TestAPI</span>()</span><br><span class="line">firstly &#123;</span><br><span class="line">    api.user()</span><br><span class="line">&#125;.then &#123; user <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;user name =&gt; <span class="subst">\(user)</span>&quot;</span>)</span><br><span class="line">    api.avatar()</span><br><span class="line">&#125;.catch &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;request error&quot;</span>)</span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;request complete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当网络请求成功时，我们会得到如下内容： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">request user info</span><br><span class="line">user name =&gt; User(name: <span class="string">&quot;chuquan&quot;</span>, avatarURL: <span class="string">&quot;avatarurl&quot;</span>)</span><br><span class="line">request avatar info</span><br><span class="line">request complete</span><br></pre></td></tr></table></figure>
当网络请求失败时，我们则得到如下内容： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">request user info</span><br><span class="line">request error</span><br><span class="line">request complete</span><br></pre></td></tr></table></figure></p>
<p>从执行顺序和结果而言，是符合我们的预期的。当然，我们还可以编写更多测试用例来进行测试，本文将不再赘述。</p>
<h1 id="总结">总结</h1>
<p>本文，我们介绍了一种常见的异步编程技术
Promise，深入分析其设计原理，并最终手动实现一套简易的 Promise
框架。此外，我们还对 Promise
的内存管理进行了简要的分析，以深入了解内部的运行机制。</p>
<p>后续，有机会的话，我们来分析一款流行的 Promise 开源框架，以进一步验证
Promise 的设计。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures
and Promises</a></li>
<li><a href="http://dist-prog-book.com/chapter/2/futures.html">Futures
and Promises</a></li>
<li><a href="https://promisesaplus.com/">Promises/A+</a></li>
<li><a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li>
<li><a
href="https://juejin.cn/post/6945319439772434469">从一道让我失眠的
Promise 面试题开始，深入分析 Promise 实现细节</a></li>
<li><a
href="https://fuzhe1989.github.io/2018/01/30/future-promise/">Future与Promise</a></li>
<li><a href="http://khanlou.com/2015/09/what-the-heck-is-a-monad/">A
promise is a Monad</a></li>
<li><a
href="https://gist.github.com/peter-leonov/c86720d1517235a1f28cd453a9d39bb4">async/await
is just the do-notation of the Promise monad</a></li>
<li><a href="https://khanlou.com/2015/09/what-the-heck-is-a-monad/">What
The Heck Is A Monad</a></li>
<li><a
href="https://bluepnume.medium.com/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand
promises before you start using async/await</a></li>
</ol>
]]></content>
      <categories>
        <category>异步与并发</category>
      </categories>
      <tags>
        <tag>Functor</tag>
        <tag>Monad</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——PromiseKit</title>
    <url>/2022/10/29/promisekit/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>PromiseKit 是一款基于 Swift 的 Promise 异步编程框架，作者是大名鼎鼎的
Max Howell，Max Howell 同时也是 Homebrew 的作者，因在面试 Google
时写不出算法题反转二叉树而走红。</p>
<p>最近，我在研究 Promise 异步编程，一开始尝试从阅读 PromiseKit
源码上手，但是发现里面的一些设计理念难以理解。因此，转而去研究 Promise
核心原理，并产出了一篇文章——<a
href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise
核心实现原理》</a>。最后，再回过头来阅读 PromiseKit
源码，很多当初不理解的设计立马豁然开朗了。这里，希望通过本文记录自己对于
PromiseKit 设计思想的一些理解。</p>
<p>注：本文分析的 PromiseKit 版本是 <code>6.18.1</code>。</p>
<h1 id="thenable-catchmixin">Thenable &amp; CatchMixin</h1>
<p><code>Thenable</code> 是 PromiseKit
的核心协议之一，其声明了一个关键方法
<code>pipe(to:)</code>，并实现了一系列链式操作符（方法），具体如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Thenable</span>: <span class="title class_">AnyObject</span> &#123;</span><br><span class="line">    <span class="comment">/// The type of the wrapped value</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// `pipe` is immediately executed when this `Thenable` is resolved</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pipe</span>(<span class="params">to</span>: <span class="keyword">@escaping</span>(<span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The resolved result or nil if pending.</span></span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">Thenable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">then</span>&lt;<span class="type">U</span>: <span class="type">Thenable</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>.<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">U</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">compactMap</span>&lt;<span class="type">U</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">done</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">tap</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">asVoid</span>() -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循 <code>Thenable</code> 协议的有两个泛型类型，分别是：</p>
<ul>
<li><code>Promise&lt;T&gt;</code>：支持异步任务的成功和失败状态。</li>
<li><code>Guarantee&lt;T&gt;</code>：仅支持异步任务的成功状态，不接受失败状态。</li>
</ul>
<p>两者的主要区别在于 <code>Promise</code> 支持失败状态，而
<code>Guarantee</code> 不支持失败状态。因此，PromiseKit 定义了另一个协议
<code>CatchMixin</code>，该协议声明并实现了错误处理相关的方法，如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">CatchMixin</span>: <span class="title class_">Thenable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">CatchMixin</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">`catch`</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">policy</span>: <span class="type">CatchPolicy</span> <span class="operator">=</span> conf.catchPolicy, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">PMKFinalizer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>&lt;<span class="type">U</span>: <span class="type">Thenable</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">policy</span>: <span class="type">CatchPolicy</span> <span class="operator">=</span> conf.catchPolicy, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; <span class="keyword">where</span> <span class="type">U</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) -&gt; <span class="type">Guarantee</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Guarantee</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ensure</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ensureThen</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Guarantee</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Guarantee</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">policy</span>: <span class="type">CatchPolicy</span> <span class="operator">=</span> conf.catchPolicy, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CatchMixin</code> 协议继承自 <code>Thenable</code>
协议，从而限制 PromiseKit 只为遵循 <code>Thenable</code> 协议的类型支持
<code>catch</code> 和 <code>recover</code> 等能力。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="promise">Promise</h1>
<p>从 <a
href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise
核心实现原理》</a> 中，我们知道 Promise 内部主要包含几个部分：</p>
<ul>
<li><strong>执行状态</strong>：用于表示 Promise
的三种状态，<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。</li>
<li><strong>执行结果</strong>：对于成功状态，为任务的返回值；对于失败状态，为任务的错误码。</li>
<li><strong>回调任务列表</strong>：当 Promise
达到结束态时，将自动执行回调任务列表中的任务，并将当前执行结果作为参数传入回调任务。</li>
<li><strong>执行器</strong>：用于更新执行状态和执行结果，并执行回调任务列表中的任务。</li>
</ul>
<p>在 PromiseKit 的实现中，使用两个类型来表示 4 个部分：</p>
<ul>
<li><code>Box</code>：表示一个容器，包含了
<strong>执行状态</strong>、<strong>执行结果</strong>、<strong>回调任务列表</strong>。</li>
<li><code>Resolver</code>：<strong>执行器</strong>。</li>
</ul>
<p>在 <a
href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise
核心实现原理》</a> 中，我们设计实现的 <code>Promise</code>
强关联了回调任务列表和执行器，执行器同时反向强引用了 Promise。然而，在
PromiseKit 中，<code>Promise</code> 仅强关联了
<code>Box</code>，而弱依赖了
<code>Resolver</code>，<code>Resolver</code> 则强关联了
<code>Box</code>。当然，两种设计在内存管理中的作用是一样的。如下所示为
<code>Promise</code> 与 <code>Box</code>、<code>Resolver</code>
的引用关系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-03.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们来分别介绍一下 <code>Box</code> 和 <code>Resolver</code>
的设计。</p>
<h2 id="box">Box</h2>
<p>PromiseKit 通过两种具体的 <code>Box</code>
子类来表示不同状态下的容器，分别是：</p>
<ul>
<li><code>EmptyBox</code>：表示 <code>pending</code> 状态下的容器。</li>
<li><code>SealedBox</code>：表示 <code>resolved</code>
状态下的容器，具体可以是 <code>fulfilled</code> 或 <code>rejected</code>
状态。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-04.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="执行状态-执行结果-回调任务列表">执行状态 &amp; 执行结果 &amp;
回调任务列表</h3>
<p>Promise 通过 <code>Sealant</code>
枚举类型将三种执行状态（<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>）分成两种执行状态：</p>
<ul>
<li><strong>开始状态</strong>：<code>pending</code> 状态。</li>
<li><strong>结束状态</strong>：<code>resolved</code> 状态，具体可以是
<code>fulfilled</code> 或 <code>rejected</code>。</li>
</ul>
<p><code>Sealant</code> 的定义如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Sealant</span>&lt;<span class="title class_">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> pending(<span class="type">Handlers</span>&lt;<span class="type">R</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> resolved(<span class="type">R</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Handlers</span>&lt;<span class="title class_">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> bodies: [(<span class="type">R</span>) -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="keyword">@escaping</span>(<span class="type">R</span>) -&gt; <span class="type">Void</span>) &#123; bodies.append(item) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>pending</code> 状态的关联值存储了
<strong>回调任务列表</strong>
<code>Handlers</code>；<code>resolved</code>
状态的关联值存储了两种细分的状态 <code>Result</code>。</p>
<p><code>Result</code> 枚举类型则用于进一步表示 <code>fulfilled</code>
和 <code>rejected</code> 状态，具体定义如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> fulfilled(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> rejected(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过关联对象，分别存储两种 <strong>执行结果</strong>：返回值
<code>T</code> 和错误码 <code>Error</code>。</p>
<h3 id="emptybox-sealedbox">EmptyBox &amp; SealedBox</h3>
<p><code>Box</code> 抽象类定义了三个方法，分别是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inspect</span>() -&gt; <span class="type">Sealant</span>&lt;<span class="type">T</span>&gt; &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inspect</span>(<span class="keyword">_</span>: (<span class="type">Sealant</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>) &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">seal</span>(<span class="keyword">_</span>: <span class="type">T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inspect()</code> 方法用于检查内部状态，返回值为
<code>Sealant</code> 值。对于 <code>SealedBox</code>，其返回始终为
<code>resolved&lt;T&gt;</code>。</p>
<p><code>inspect(_ body: (Sealant&lt;T&gt;) -&gt; Void)</code>
方法将内部结果作为参数传递给闭包并执行。</p>
<p><code>seal(_: T)</code> 方法非常关键，当 <code>Box</code> 为
<code>pending</code> 状态时，<code>seal</code> 方法可以将内部状态更新为
<code>resolved</code>，同时执行 <strong>回调任务列表</strong>
中的所有任务。<code>Resolver</code> 就是通过 <code>seal</code>
方法来更新状态的。具体如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyBox</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Box</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">seal</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers: <span class="type">Handlers</span>&lt;<span class="type">T</span>&gt;!</span><br><span class="line">        barrier.sync(flags: .barrier) &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">case</span> .pending(<span class="keyword">let</span> _handlers) <span class="operator">=</span> <span class="keyword">self</span>.sealant <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="comment">// already fulfilled!</span></span><br><span class="line">            &#125;</span><br><span class="line">            handlers <span class="operator">=</span> _handlers</span><br><span class="line">            <span class="keyword">self</span>.sealant <span class="operator">=</span> .resolved(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> handlers <span class="operator">=</span> handlers &#123;</span><br><span class="line">            handlers.bodies.forEach&#123; <span class="variable">$0</span>(value) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resolver">Resolver</h2>
<p><code>Resolver</code>
的核心作用是更新执行状态和执行结果，并执行回调任务列表中的任务。由于
<code>Box</code>
封装了执行状态、执行结果、回调任务列表，并且提供了更新状态的方法
<code>seal</code>。因此，<code>Resolver</code>
只需提供针对不同状态的便利方法，内部调用 <code>Box</code> 的
<code>seal</code> 方法进行更新即可。具体如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Resolver</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> box: <span class="type">Box</span>&lt;<span class="type">Result</span>&lt;<span class="type">T</span>&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">box</span>: <span class="type">Box</span>&lt;<span class="type">Result</span>&lt;<span class="type">T</span>&gt;&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.box <span class="operator">=</span> box</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> .pending <span class="operator">=</span> box.inspect() &#123;</span><br><span class="line">            conf.logHandler(.pendingPromiseDeallocated)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">Resolver</span> &#123;</span><br><span class="line">    <span class="comment">/// Fulfills the promise with the provided value</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fulfill</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        box.seal(.fulfilled(value))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Rejects the promise with the provided error</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">reject</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">Error</span>) &#123;</span><br><span class="line">        box.seal(.rejected(error))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Resolves the promise with the provided result</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">resolve</span>(<span class="keyword">_</span> <span class="params">result</span>: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">        box.seal(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务串联">任务串联</h2>
<p>Promise 的核心能力之一是串联任务（异步或同步）。从
<code>Thenable</code>
的方法中，我们可以看到几乎所有的串联方法内部都是通过
<code>pipe(to:)</code> 方法实现任务串联的。下面，我们来看一下
<code>Promise</code> 中该方法的定义。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Thenable</span>, <span class="title class_">CatchMixin</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">pipe</span>(<span class="params">to</span>: <span class="keyword">@escaping</span>(<span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> box.inspect() &#123;</span><br><span class="line">        <span class="keyword">case</span> .pending:</span><br><span class="line">            box.inspect &#123;</span><br><span class="line">                <span class="keyword">switch</span> <span class="variable">$0</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> .pending(<span class="keyword">let</span> handlers):</span><br><span class="line">                    handlers.append(to)</span><br><span class="line">                <span class="keyword">case</span> .resolved(<span class="keyword">let</span> value):</span><br><span class="line">                    to(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .resolved(<span class="keyword">let</span> value):</span><br><span class="line">            to(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从实现中可以看到，<code>pipe(to:)</code> 方法会先判断
<code>Box</code> 的状态，如果是 <code>pending</code>
状态，则将闭包加入回调任务列表；如果是 <code>resolved</code>
状态，则立即执行闭包。</p>
<h2 id="内存管理">内存管理</h2>
<p>PromiseKit 所实现的 <code>Promise</code>
的内存管理是非常清晰。我们可以通过阅读各种链式操作符的内部实现来梳理其内存引用关系。如下所示，为链式操作符下产生的线性内存引用关系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-05.png?x-oss-process=image/resize,w_800" /></p>
<p>当对 <code>promise 0</code> 执行链式操作符时，链式操作符会创建一个
<code>promise 1</code>，并在内部创建一个匿名闭包对用户闭包进行封装。同时，匿名闭包将引用
<code>promise 1</code> ，以处理 <code>rejected</code> 状态。</p>
<p>当 <code>promise 0</code> 为 <code>fulfilled</code>
时，执行匿名闭包，进而执行用户闭包，从而创建一个临时的
<code>promise m</code>。此时，<code>promise m</code> 通过
<code>pipe(to:)</code> 方法将 <code>promise 1</code>
的状态更新方法（任务）<code>box.seal</code>
加入回调任务列表，最终形成上图所示的内存引用关系。</p>
<h1 id="guarantee">Guarantee</h1>
<p><code>Guarantee</code> 其实是裁剪版的
<code>Promise</code>，不支持错误处理，即 <strong>保证有返回值</strong>
的含义。</p>
<p><code>Guarantee</code> 遵循 <code>Thenable</code>
协议，并重新实现了一套链式操作符（方法），不同的是，返回值为
<code>Guarantee</code> 类型，从而避免交错使用 <code>Promise</code> 和
<code>Guarantee</code>。</p>
<h1 id="全局方法">全局方法</h1>
<p>为了便于使用，PromiseKit 还提供了几个常用的全局方法，包括：</p>
<ul>
<li><code>after</code>：延时任务，<code>Guarantee</code> 类型。</li>
<li><code>firstly</code>：语法糖，让代码更具可读性，立即执行闭包。</li>
<li><code>race</code>：当有一个 Promise 为 <code>fulfilled</code>
状态时，执行回调任务列表。</li>
<li><code>when</code>：当所有 Promise 均为 <code>fulfilled</code>
状态时，执行回调任务列表。</li>
</ul>
<h1 id="总结">总结</h1>
<p>整体而言，PromiseKit 以 <code>Thenable</code> 和
<code>CatchMixin</code> 协议为基础，实现了两种类型的 Promise，分别是
<code>Promise</code> 和 <code>Guarantee</code>。</p>
<p><code>Promise</code> 的工作流程主要涉及了 <code>Box</code> 和
<code>Resolver</code>，两者有各自的职责。<code>Box</code>
包含了执行结果、执行状态、回调任务列表，并提供了状态更新方法
<code>seal</code>。<code>Resolver</code>
作为执行器，提供给用户来更新状态。</p>
<p><code>Thenable</code> 提供的 <code>pipe(to:)</code>
方法是串联任务的关键，几乎所有的链式操作符均使用了
<code>pipe(to:)</code> 方法进行任务串联。</p>
<p>从编码角度而言，PromiseKit
在职责单一、方法命名方面的设计与实践，还是非常值得我们来学习的。</p>
<p>后续，我们将继续阅读一些不错的开源源码，学习其中的设计思想。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li>
<li><a
href="http://chuquan.me/2022/10/16/promise-core-implement/">Promise
核心实现原理</a></li>
</ol>
]]></content>
      <categories>
        <category>异步与并发</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Promise</tag>
        <tag>Guarantee</tag>
      </tags>
  </entry>
  <entry>
    <title>基于原型的继承模式</title>
    <url>/2023/04/22/prototype-based-inheritance/</url>
    <content><![CDATA[<p><strong>继承</strong>（Inheritance）是
<strong>面向对象编程</strong>（Object Oriented Programming,
OOP）的三大特性之一，其他两大特性是
<strong>封装</strong>（Encapsulation）和
<strong>多态</strong>（Polymorphism）。在编程语言中，继承的主流实现方式有两种，分别是：</p>
<span id="more"></span>
<ul>
<li><strong>基于类的继承</strong>（Class-based
Inheritance）：绝大多数面向对象编程语言都使用了基于类的继承，比如：C++、Java、Swift、Kotlin
等。</li>
<li><strong>基于原型的继承</strong>（Prototype-based
Inheritance）：少数面向对象编程语言使用基于原型的继承，一般都是解释型编程语言，即脚本语言，比如：JavaScript、Lua、Io、Self、NewtonScript
等。</li>
</ul>
<p>除此之外，有一些辅助继承的实现方式，比如：<strong>接口继承</strong>
和
<strong>类型混入</strong>，一般用于实现多类型复用，可以达到类似多继承的效果。</p>
<p>本文，我们来简单介绍一下其中基于原型的继承模式。</p>
<h1 id="基于类的继承-vs-基于原型的继承">基于类的继承 vs
基于原型的继承</h1>
<p>在基于类继承的语言中，对象是类的实例，类可以从另一个类继承。从本质上而言，类相当于模板，对象则通过这些模板来进行创建。</p>
<p>下图所示，为基于类的继承实现示意图。每个类都有一个类似
<code>superclass</code> 的指针指向其父类。每个对象都有一个类似
<code>isa</code> 的指针指向其所属的类。</p>
<p>此外，每个类都存储了一系列方法，可用于其实例进行查找和共享。关于方法存储方式，不同语言的实现有所不同。</p>
<ul>
<li>对于 C++
等语言，每个类会保存所有祖先类的方法地址。因此，在方法查找时，无需沿着继承链进行查找</li>
<li>对于 Ruby、Objective-C
等语言，每个类只会保存其所定义的方法地址，而不保存祖先类的方法地址。因此，在方法查找时，会沿着继承链进行查找，这种模式也被称为
<strong>消息传递</strong>（Message Passing）。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-03.png?x-oss-process=image/resize,w_800" /></p>
<p>在基于原型继承的语言中，没有类的概念，对象可以直接从另一对象继承。中间省略了通过模板创建对象的过程。</p>
<p>下图所示，为基于原型的继承实现示意图。每个对象都有一个类似
<code>prototype</code> 的指针指向其原型对象。</p>
<p>每个对象存储了一系列方法，基于原型链，对象之间可以实现方法共享，当然也可以共享属性。方法和属性的查找过程，类似于上述的消息传递，会沿着原型链进行查找。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-04.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="原型继承的优缺点">原型继承的优缺点</h1>
<p>前面，我们简单对比了两种继承模式的实现原理。下面，我们来讨论一下原型继承的优缺点。</p>
<p>对比而言，原型继承的优点主要有一下这些：</p>
<ul>
<li><strong>避免大量的初始化工作</strong>。通过克隆一个现有对象来创建一个新对象，并具有相同的内部状态。</li>
<li><strong>具有非常强大的动态性</strong>。通过修改原型链，可以将原型指针指向任意对象，使得当前对象可以继承其他对象的能力。</li>
<li><strong>有效降低程序的代码量</strong>。由于原型继承没有类的概念，因此在代码实现中无需进行类的定义。</li>
</ul>
<p>当然，凡事都具有两面性，以下罗列了一些原型继承的缺点：</p>
<ul>
<li><strong>性能开销相对较大</strong>。当我们访问属性或方法时，运行时会通过原型链进行查找，中间存在一个遍历的过程。</li>
<li><strong>原型共享的副作用</strong>。由于多个对象可以共享同一个原型对象，一旦某个对象修改原型对象的状态，将会对其他对象产生副作用。</li>
<li><strong>面向对象异类设计</strong>。绝大多数面向对象语言及教程都是基于类的实现而设计的，这对于习惯于基于类的
OOM 的开发者很容易产生困惑。</li>
</ul>
<h1 id="不同语言的原型继承实现">不同语言的原型继承实现</h1>
<p>下面，我们来看看不同编程语言中，基于原型的继承模式的实现细节。</p>
<h2 id="javascript">JavaScript</h2>
<p>JavaScript
原型实现存在着很多矛盾，它使用了一些复杂的语法，使其看上去类似于基于类的语言，这些语法掩盖了其内在的原型机制。JavaScript
不直接让对象继承其他对象，而是提供了一个中间层——<strong>构造函数</strong>，完成对象的创建和原型的串联，从而间接完成对象继承。由于构造函数的定义类似于类定义，但又不是真正意义的类，因此我们可以称之为
<strong>伪类</strong>（Pseudo Class）。</p>
<p>默认情况下，伪类包含一个 <code>prototype</code>
指针指向原型，对象包含一个 <code>constructor</code>
指针指向伪类（构造函数），两者之间的关系如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-01.png?x-oss-process=image/resize,w_800" /></p>
<p>为了实现新的对象继承其他对象，一般会先修改伪类中
<code>prototype</code>
的指针，然后再调用伪类进行对象构造和原型绑定。如下所示，为一段代码实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AType</span>.<span class="property">propertytype</span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 AType。即修改伪类 BType 的 prototype 指针，使其指向父对象。</span></span><br><span class="line"><span class="title class_">BType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">AType</span>();</span><br><span class="line"><span class="title class_">BType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">BType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>BType.prototype = new AType()</code> 修改了
<code>BType</code> 伪类的 <code>prototype</code> 指针，使其指向
<code>AType</code> 对象。当我们调用 <code>BType</code>
构造函数时，所构造的对象自动继承 <code>AType</code>
对象。如下所示，为基于原型的继承关系示意图，其中每个伪类的
<code>prototype</code>
指针都发生了变化，指向了其所继承的父对象。最终，生成的对象中会包含一个
<code>__proto__</code> 指针指向父对象。根据 <code>__proto__</code>
指针我们可以构建一个完整的原型链。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-02.png?x-oss-process=image/resize,w_800" /></p>
<p>当然，在原型继承模式中，原型链中的父对象可能会被多个子对象所共享，因此子对象之间的状态同步问题需要格外注意。一旦，某个子对象修改了父对象的状态，那么会同时影响其他子对象。关于如何解决这个问题，JavaScript
中有很多解决方法，具体细节可以阅读相关书籍和博客，这里不作详细赘述。</p>
<h2 id="lua">Lua</h2>
<p>Lua 中的 <strong>表（table）</strong>
是一种非常强大且常用的数据结构，它类似于其他编程语言中的字典或哈希表，可以以键值对的方式存储数据，包括方法定义。通常会使用
table
来解决模块（module）、包（package）、对象（object）等相关实现。</p>
<p>与此同时，Lua 还提供了 <strong>元表（metatable）</strong>
的概念，其本质上仍然是一个表结构。但是元表可以对表进行关联和扩展，允许我们改变表的行为。</p>
<p>元表中最常用的键是 <code>__index</code>
元方法。当我们通过键来访问表时，如果对应的键没有定义值，那么 Lua
会查找表的元表中的 <code>__index</code> 键。如果 <code>__index</code>
指向一个表，那么 Lua 会在这个表中查找对应的键。</p>
<p>如下所示，我们为表 <code>a</code> 设置一个元表，其中定义元表的。
<code>__index</code> 键为表 <code>b</code>。当查找表 <code>a</code>
时，对应的键没有定义，那么会去查找元表。判断元表是否定义了
<code>__index</code> 键，这里定义为另一个表 <code>b</code>。于是，会在表
<code>b</code> 中查找对应的键。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(a, &#123; <span class="built_in">__index</span> = b &#125;)</span><br></pre></td></tr></table></figure>
<p>Lua 中的继承模式正是基于元表和 <code>__index</code>
元方法而实现的。如下所示，分别是 Lua
中继承模式的实现示意图，以及对应的代码实现。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-06.png?x-oss-process=image/resize,w_800" /></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">RootType = &#123; rootproperty = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RootType:new</span> <span class="params">(o)</span></span> </span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">SuperType = RootType:new(&#123; superproperty = <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">SubType = SuperType:new(&#123; subproperty = <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>RootType</code> 是一个对象，其实现了一个 <code>new</code>
方法用于完成几项工作：</p>
<ul>
<li>构造对象，其本质上是一个表。</li>
<li>将 <code>RootType</code> 对象设置为新对象的元表。</li>
<li>将 <code>RootType</code> 对象的 <code>__index</code> 指向
<code>RootType</code> 对象自身。</li>
</ul>
<p>最终形成图中所示的对象继承关系。由于 Lua
中的继承实现没有类的概念，而只有对象的概念。因此也被归类成基于原型的继承模式。当
<code>SubType</code> 对象中没有找到对应的键时，会根据
<code>metatable</code> 指针找到对应的元表，并根据元表的
<code>__index</code> 指针找到进一步查找的表对象
<code>SuperType</code>。如果 <code>SuperType</code>
中仍然没有，那么继续根据 <code>metatable</code> 和 <code>__index</code>
指针进行查找。</p>
<h2 id="io">Io</h2>
<p>Io 的继承模式也是基于原型实现的，它的实现相对而言更加简单、直观。</p>
<p>在 Io
中，一切都是对象（包括闭包、命名空间等），所有行为都是消息（包括赋值操作）。这种消息传递机制其实与
Objective-C、Ruby 是一样的机制。在 Io
中，对象的组成非常关键，其主要包含两个部分：</p>
<ul>
<li><strong>槽</strong>（slots）：一系列键值对，可以存储方法或属性。</li>
<li><strong>原型</strong>（protos）：一个内部的对象数组，记录该对象所继承的原型。</li>
</ul>
<p>Io 使用克隆的方式创建对象，对应提供了一个 <code>clone</code>
方法。当对父对象进行克隆时，新对象的 <code>protos</code>
数组中会加入对父对象的引用，从而建立继承关系。如下所示，为 Io
中继承模式的实现示意图，以及对应的代码实现。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-07.png?x-oss-process=image/resize,w_800" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RootType := Object clone</span><br><span class="line">RootType rootproperty := 0</span><br><span class="line"></span><br><span class="line">SuperType := RootType clone</span><br><span class="line">SuperType superproperty := 0</span><br><span class="line"></span><br><span class="line">SubType := SuperType clone</span><br><span class="line">SubType subproperty := 0</span><br></pre></td></tr></table></figure>
<p>相比于 JavaScript 和 Lua 的链表式单继承模式，Io
是支持多继承的，其采用了多叉树的模式来实现的，其中最关键的就是
<code>protos</code> 数组。很显然，<code>protos</code>
数组可以存储多个原型对象。因此，可以实现多继承。如下所示，是 Io
中多继承模式的实现示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-08.png?x-oss-process=image/resize,w_800" /></p>
<p>因此，Io 中方法和属性的查找方式也有所不同，其基于 <code>protos</code>
数组，使用深度优先搜索的方式来进行查找。在这种模式下，如果一个对象继承的对象越多，那么方法和属性的查找效率也会越低。</p>
<h1 id="总结">总结</h1>
<p>本文，我们首先简单对比了基于类的继承模式与基于原型的继承模式，其核心区别在于是否基于类来进行构建继承关系。对于后者，没有类的概念，即使有，那也是一种语法糖，为了与基于类的语言靠拢降低开发者的学习成本和理解成本。</p>
<p>其次，我们简单介绍了基于原型继承的优缺点。当我们对编程语言进行技术选型时，也可以从这方面进行考虑和权衡，判断是否适用于特定的场景。</p>
<p>最后，我们介绍了三种编程语言中基于原型的继承实现，分别是：JavaScript、Lua、Io。三种语言各有其实现特点，但核心思想基本是一致的，即直接在对象之间建立引用关系，从而便于进行方法和属性的查找。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《深入设计模式》</li>
<li>《JavaScript 高级程序设计》</li>
<li>《JavaScript 语言精粹》</li>
<li>《七周七语言：理解多种编程范式》</li>
<li><a href="http://siffiejoe.github.io/lua-prototype/">prototype ——
Prototype Based OO Programming For Lua</a></li>
<li><a
href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Prototype-based_programming">Prototype-based
programming</a></li>
<li><a
href="https://developer-interview.com/p/oop-ood/how-prototype-based-oop-is-different-from-class-based-13">Difference
from class-based inheritance</a></li>
<li><a
href="https://developer-interview.com/p/oop-ood/what-are-advantages-and-disadvantages-of-prototypal-oop-12">What
are advantanges and disadvantages of prototypal OOP</a></li>
<li><a
href="https://developer-interview.com/p/oop-ood/what-is-prototype-based-oop-how-it-is-different-from-class-based-4">What
is prototype-based OOP?</a></li>
<li><a
href="https://exploringjs.com/impatient-js/ch_proto-chains-classes.html">Prototype
chains and classes</a></li>
<li><a href="https://github.com/nusov/lua-object">lua-object</a></li>
<li><a
href="https://juejin.cn/post/6975694337698955295">01.原型(prototype)和原型链(prototype
chain)</a></li>
<li><a
href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">对象原型</a></li>
<li><a
href="http://kenneth-kin-lum.blogspot.com/2012/10/javascripts-pseudo-classical.html">JavaScript's
Pseudo Classical Inheritance diagram</a></li>
<li><a href="https://www.lua.org/pil/contents.html">Programming in
Lua</a></li>
</ol>
]]></content>
      <categories>
        <category>编程范式</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>原型继承</tag>
        <tag>类继承</tag>
        <tag>原型链</tag>
        <tag>元表</tag>
      </tags>
  </entry>
  <entry>
    <title>【我的阅读轨迹】</title>
    <url>/2017/01/05/read-books/</url>
    <content><![CDATA[<blockquote>
<p>回看过去三个月，从10月中旬开始毕设换题，到现在2017年初，自己一直忙于毕设相关事宜，几乎没有挤出一些时间来提升自己。为了能够改变现在的生活状态，写下这篇博文以长期记录自己的阅读轨迹，希望能够以此鞭策自己不断地阅读、学习、思考、成长。</p>
</blockquote>
<span id="more"></span>
<h1 id="section">2017</h1>
<h2 id="黑客与画家">《黑客与画家》</h2>
<ul>
<li>时间: 1月3日至1月16日，一遍完</li>
<li>简评: 硅谷创业之父Paul
Graham的散文集，描述了作者对社会现象、人生、技术、创业等方面的一些自己独特的见解。虽然本书并没有围绕具体某个主题展开，但是作者不时地传达出“Think
Different”的思想，非常好的一本书。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/hacker-and-painter01.jpg" />
</div></li>
</ul>
<h2 id="webkit技术内幕">《Webkit技术内幕》</h2>
<ul>
<li>时间: 1月17日至今，未读完
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/webkit-tech01.jpg" />
</div></li>
</ul>
<h2 id="启示录-打造用户喜爱的产品">《启示录 打造用户喜爱的产品》</h2>
<ul>
<li>时间: 2月9日至2月19日，一遍完</li>
<li>简评:
本书分为三大部分：人员，流程，产品。人员部分主要介绍了围绕一款产生的设计、开发、发布、管理需要进行的人员配置，这方面非常适合类似相管理等职位的人来阅读；流程部分则介绍了产品诞生的过程中，以产品经理为中心，如何处理和协调整个过程；产品部分则是关于作者根据自己30年从业经验给产品经理的一些意见和建议。总体来说，本书对于产品经理是一本非常有价值的指导手册。希望有时间能够再次拜读此书，汲取其精华，写一点自己的得心体会。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/inspired01.jpg" />
</div></li>
</ul>
<h2 id="从0到1-开启商业与未来的秘密">《从0到1
开启商业与未来的秘密》</h2>
<ul>
<li>时间: 2月19日至5月1日</li>
<li>简评:
作者是Paypal的创始人之一，本文与《黑客与画家》类似，每一章都一个主题，但整本书始终围绕着如何创业、如何打造一个成功的企业来阐述作者的观点。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/from-zero-to-one.jpg" />
</div></li>
</ul>
<h2 id="objective-c编程">《Objective-C编程》</h2>
<ul>
<li>时间: 7月11日至7月13日</li>
<li>简评:
入职后转岗iOS开发，Mentor指引了一条学习路线，首先看《Object-C编程》这本书。此书非常适于iOS开发入门，主要介绍Object-C的语法及相关概念。题外话：不得不说人的潜能真的是难以置信，三天看完了一本380页的技术书，还撸了一遍示例代码。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/object-c-programming.jpg" />
</div></li>
</ul>
<h2 id="ios编程">《iOS编程》</h2>
<ul>
<li>时间: 7月22日至7月30</li>
<li>简评:
一本非常好的开发指南，初学如果不看斯坦福的视频，对于里面的介绍各种东西可能会比较陌生。本书覆盖的知识面比较广，但并不深入，总体来说是一本非常好的iOS入门书籍。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-programming.jpg" />
</div></li>
</ul>
<h2 id="ios开发进阶">《iOS开发进阶》</h2>
<ul>
<li>时间: 9月10日~9月12日</li>
<li>简评:
花了三天空余时间过了一遍这本书，主要介绍了作者根据自身多年iOS开发经验总结出的一些开发经验，包括对使用工具提高开发、应用发布的注意事项等等。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-advanced-develop-book.jpg" />
</div></li>
</ul>
<h2 id="ios-core-animationadvanced-techniques">《iOS Core
Animation：Advanced Techniques》</h2>
<ul>
<li>时间: 9月12日~10月24日</li>
<li>简评: 主要介绍Core Animation框架的关键原理以及相关应用，值得二刷。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-core-animation-book.jpg" />
</div></li>
</ul>
<h2 id="swift-3.0-官方教程中文版">《Swift 3.0 官方教程中文版》</h2>
<ul>
<li>时间: 10月24日~10月30日</li>
<li>简评: 官方教程，详细全面地介绍了swift
3.0的特性。语言类的官方教程阅读起来还是比较枯燥的，希望以后能够多多锻炼。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/swift-official-tutorial.png?x-oss-process=image/resize,w_390" />
</div></li>
</ul>
<h2 id="swift编程入门">《Swift编程入门》</h2>
<ul>
<li>时间：10月31日~11月12日</li>
<li>简评：此书是对Swift官方教程进行了简化，整理得出的一般语言教程，很不错，值得向初学者推荐。
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/swift-programming-tutorial.jpg?x-oss-process=image/resize,w_390" />
</div></li>
</ul>
<h1 id="section-1">2018</h1>
<h2 id="ios应用逆向工程">《iOS应用逆向工程》</h2>
<ul>
<li>时间：1月14日~2月22日</li>
<li>简评：作者根据自己多年的逆向经验总结的一套方法，包括：理论、工具、实例等。总体说来，iOS逆向的原理并不复杂，工程性比较强，如果要做iOS逆向工程，可以深入了解一下。</li>
<li>笔记：<a
href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/">iOS逆向工程——基础篇</a>、<a
href="http://chuquan.me/2018/02/22/logos-syntax/">Logos基础语法</a>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/book-ios-reverse-engineering.png" />
</div></li>
</ul>
<h2 id="mba教不了的创富课">《MBA教不了的创富课》</h2>
<ul>
<li>时间：2月23日~2月25日</li>
<li>简评：本书分为九个部分：念力、统御力、成长力、财务力、前瞻力、决断力、竞争力、洞察力、批判力。老雕从这个九个方面开始，以身边或编撰的创业故事为例，以创业者、企业管理者的角度来分析如何应对各种公司、企业运行过程中可能会遇到的一些问题。并以此进行总结。虽然，书中对于理论总结的部分很少，但是通过这些例子实实在在地传达了这些理念。值得推荐！
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/book-mba-chuangfuke.jpg" />
</div></li>
</ul>
<h2 id="机器学习实战">《机器学习实战》</h2>
<ul>
<li>时间：4月12日~至今</li>
<li>简评：
<div data-align="center">
<img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/book-machine-learning.jpg" />
</div></li>
</ul>
<p>（未完待续）</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——Resolver</title>
    <url>/2021/07/01/resolver/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/resolver-01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>Resolver 是一个采用 Swift
编写的轻量级依赖注入/服务定位框架。关于依赖注入和服务定位的概念，可以阅读
<a
href="http://chuquan.me/2021/06/07/ioc-di-sl/">《控制反转、依赖注入、服务定位》</a>
一文。本文源码解读的 <a
href="https://github.com/hmlongco/Resolver">Resolver</a> 版本是
1.5.0。</p>
<h1 id="基本原理">基本原理</h1>
<p>Resolver
是一个依赖注入/服务定位框架，但是它的核心逻辑主要还是服务定位的典型设计实现。服务定位的设计通常包括两个主要步骤：</p>
<ul>
<li><strong>服务注册（Service Register）</strong></li>
<li><strong>服务解析（Service Resolve）</strong></li>
</ul>
<p>服务注册通常是注册一个工厂方法，工厂方法能够根据相关参数可以实例化一个服务对象。由于允许注册多个服务，因此会有一个容器（Container）来存储这些工厂方法。通常情况下，会使用一个哈希表存储这些工厂方法，其中以服务的名称为键，以对应的工厂方法为值。这里我们暂且称这个哈希表为
<strong>注册项哈希表</strong>。</p>
<p>服务解析是指根据服务的名称在容器中查找对应的工厂方法，执行并返回一个服务对象的过程。通常情况下，会根据不同的需求采用不同的解析策略。比如：在某些场景下，每次都调用工厂方法初始化一个服务对象；在某些场景下，对于同一种服务只初始化一次，后续重复使用该服务对象。对于后一种情况，一般会使用另一个哈希表存储这些服务对象，其中以服务的名称为键，以对应的服务对象为值。这里我们暂且称这个哈希表为
<strong>缓存哈希表</strong>。</p>
<h1 id="整体架构">整体架构</h1>
<p>在了解了服务定位的设计原理之后，我们再来看看 Resolver
的设计实现。下图所示为 Resolver
的类图，其中设计的核心在于红色虚线框中的部分，这里主要涉及到 3
个类：<code>Resolver</code>、<code>ResolverRegistration</code>、<code>ResolverScope</code>。这
3 个类基本覆盖了 Resolver 的主体逻辑，下面我们依次进行介绍。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/resolver-04.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="resolverregistration"><code>ResolverRegistration</code></h1>
<p><code>ResolverRegistration</code> 从命名上看就知道是用来表示一个
<strong>注册项</strong>。如下所示，是 <code>ResolverRegistration</code>
的定义。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResolverRegistration</span>&lt;<span class="title class_">Service</span>&gt;: <span class="title class_">ResolverOptions</span>&lt;<span class="title class_">Service</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">key</span>: <span class="type">Int</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>?) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key <span class="operator">=</span> key</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> namedService <span class="operator">=</span> name &#123;</span><br><span class="line">            <span class="keyword">self</span>.cacheKey <span class="operator">=</span> <span class="type">String</span>(key) <span class="operator">+</span> <span class="string">&quot;:&quot;</span> <span class="operator">+</span> namedService.rawValue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.cacheKey <span class="operator">=</span> <span class="type">String</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(resolver: resolver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">resolve</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;abstract function&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照基本原理一节中的介绍，<code>ResolverRegistration</code>
按道理应该会定义工厂方法，但是这里我们只看到了关于 <code>key</code> 和
<code>cacacheKey</code> 的定义，这是什么情况？事实上，我们从
<code>resolve(resolver: Resolver, args: Any?) -&gt; Service?</code>
方法的定义可以确定 <code>ResolverRegistration</code>
是一个抽象类。因此，我们需要再来看看它的子类。</p>
<p><code>ResolverRegistration</code> 定义了三个子类，分别是：</p>
<ul>
<li><code>ResolverRegistrationOnly</code></li>
<li><code>ResolverRegistrationResolver</code></li>
<li><code>ResolverRegistrationArgumentsN</code></li>
</ul>
<p>这三个子类的定义分别如下所示，可以发现，子类中定义了工厂方法。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// ResolverRegistration stores a service definition and its factory closure.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverRegistrationOnly</span>&lt;<span class="title class_">Service</span>&gt;: <span class="title class_">ResolverRegistration</span>&lt;<span class="title class_">Service</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> factory: <span class="type">ResolverFactory</span>&lt;<span class="type">Service</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">key</span>: <span class="type">Int</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>?, <span class="params">factory</span>: <span class="keyword">@escaping</span> <span class="type">ResolverFactory</span>&lt;<span class="type">Service</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.factory <span class="operator">=</span> factory</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(resolver: resolver, key: key, name: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> service <span class="operator">=</span> factory() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        mutate(service, resolver: resolver, args: args)</span><br><span class="line">        <span class="keyword">return</span> service</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ResolverRegistrationResolver stores a service definition and its factory closure.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverRegistrationResolver</span>&lt;<span class="title class_">Service</span>&gt;: <span class="title class_">ResolverRegistration</span>&lt;<span class="title class_">Service</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> factory: <span class="type">ResolverFactoryResolver</span>&lt;<span class="type">Service</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">key</span>: <span class="type">Int</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>?, <span class="params">factory</span>: <span class="keyword">@escaping</span> <span class="type">ResolverFactoryResolver</span>&lt;<span class="type">Service</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.factory <span class="operator">=</span> factory</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(resolver: resolver, key: key, name: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> service <span class="operator">=</span> factory(resolver) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        mutate(service, resolver: resolver, args: args)</span><br><span class="line">        <span class="keyword">return</span> service</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ResolverRegistrationArguments stores a service definition and its factory closure.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverRegistrationArgumentsN</span>&lt;<span class="title class_">Service</span>&gt;: <span class="title class_">ResolverRegistration</span>&lt;<span class="title class_">Service</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> factory: <span class="type">ResolverFactoryArgumentsN</span>&lt;<span class="type">Service</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">key</span>: <span class="type">Int</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>?, <span class="params">factory</span>: <span class="keyword">@escaping</span> <span class="type">ResolverFactoryArgumentsN</span>&lt;<span class="type">Service</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.factory <span class="operator">=</span> factory</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(resolver: resolver, key: key, name: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> service <span class="operator">=</span> factory(resolver, <span class="type">Resolver</span>.<span class="type">Args</span>(args)) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        mutate(service, resolver: resolver, args: args)</span><br><span class="line">        <span class="keyword">return</span> service</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，我们还发现，这三个类的内部逻辑几乎一模一样，唯一的区别在于工厂方法的类型不一样，分别是：</p>
<ul>
<li><code>ResolverFactory&lt;Service&gt;</code></li>
<li><code>ResolverFactoryResolver&lt;Service&gt;</code></li>
<li><code>ResolverFactoryArgumentsN&lt;Service&gt;</code></li>
</ul>
<p>这三种工厂的定义分别如下，可以看出它们都是用于初始化服务的工厂方法，区别在于服务的初始化入参不同，有些需要参数，有些不需要，有些甚至连
<code>Resolver</code> 都不需要。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ResolverFactory</span>&lt;<span class="type">Service</span>&gt; <span class="operator">=</span> () -&gt; <span class="type">Service</span>?</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ResolverFactoryResolver</span>&lt;<span class="type">Service</span>&gt; <span class="operator">=</span> (<span class="keyword">_</span> resolver: <span class="type">Resolver</span>) -&gt; <span class="type">Service</span>?</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ResolverFactoryArgumentsN</span>&lt;<span class="type">Service</span>&gt; <span class="operator">=</span> (<span class="keyword">_</span> resolver: <span class="type">Resolver</span>, <span class="keyword">_</span> args: <span class="type">Resolver</span>.<span class="type">Args</span>) -&gt; <span class="type">Service</span>?</span><br></pre></td></tr></table></figure></p>
<p><strong>从这三个类对于 <code>resolve</code>
的实现来看可以发现，它们才是服务初始化的真正执行者</strong>。</p>
<p>看完 <code>ResolverRegistration</code> 的子类后，我们再来看它的父类
<code>ResolverOptions</code>，具体如下所示： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResolverOptions</span>&lt;<span class="title class_">Service</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Parameters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> scope: <span class="type">ResolverScope</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> mutator: <span class="type">ResolverFactoryMutator</span>&lt;<span class="type">Service</span>&gt;?</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> mutatorWithArgumentsN: <span class="type">ResolverFactoryMutatorArgumentsN</span>&lt;<span class="type">Service</span>&gt;?</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">weak</span> <span class="keyword">var</span> resolver: <span class="type">Resolver</span>?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Lifecycle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">resolver</span>: <span class="type">Resolver</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.resolver <span class="operator">=</span> resolver</span><br><span class="line">        <span class="keyword">self</span>.scope <span class="operator">=</span> <span class="type">Resolver</span>.defaultScope</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">implements</span>&lt;<span class="type">Protocol</span>&gt;(<span class="keyword">_</span> <span class="params">type</span>: <span class="type">Protocol</span>.<span class="keyword">Type</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>? <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">ResolverOptions</span>&lt;<span class="type">Service</span>&gt; &#123;</span><br><span class="line">        resolver<span class="operator">?</span>.register(type.<span class="keyword">self</span>, name: name) &#123; r, <span class="keyword">_</span> <span class="keyword">in</span> r.resolve(<span class="type">Service</span>.<span class="keyword">self</span>) <span class="keyword">as?</span> <span class="type">Protocol</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">resolveProperties</span>(<span class="keyword">_</span> <span class="params">block</span>: <span class="keyword">@escaping</span> <span class="type">ResolverFactoryMutator</span>&lt;<span class="type">Service</span>&gt;) -&gt; <span class="type">ResolverOptions</span>&lt;<span class="type">Service</span>&gt; &#123;</span><br><span class="line">        mutator <span class="operator">=</span> block</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">resolveProperties</span>(<span class="keyword">_</span> <span class="params">block</span>: <span class="keyword">@escaping</span> <span class="type">ResolverFactoryMutatorArgumentsN</span>&lt;<span class="type">Service</span>&gt;) -&gt; <span class="type">ResolverOptions</span>&lt;<span class="type">Service</span>&gt; &#123;</span><br><span class="line">        mutatorWithArgumentsN <span class="operator">=</span> block</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">scope</span>(<span class="keyword">_</span> <span class="params">scope</span>: <span class="type">ResolverScope</span>) -&gt; <span class="type">ResolverOptions</span>&lt;<span class="type">Service</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.scope <span class="operator">=</span> scope</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">func</span> <span class="title function_">mutate</span>(<span class="keyword">_</span> <span class="params">service</span>: <span class="type">Service</span>, <span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.mutator<span class="operator">?</span>(resolver, service)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> mutatorWithArgumentsN <span class="operator">=</span> mutatorWithArgumentsN &#123;</span><br><span class="line">            mutatorWithArgumentsN(resolver, service, <span class="type">Resolver</span>.<span class="type">Args</span>(args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 <code>ResolverOptions</code> 的属性上看，在结合
<code>ResolverRegistration</code>
及其子类的定义，我们可以知道一个注册项的定义大致包含如下这些内容：</p>
<ul>
<li><code>factory</code>:
工厂方法，用于初始化服务对象，可以有三种工厂方法。</li>
<li><code>key</code>：用于服务注册的注册项哈希表中的键。</li>
<li><code>cacheKey</code>：用于服务解析的缓存哈希表中的键。</li>
<li><code>resolver</code>：<code>Resolver</code>
类型，它是服务注册的核心实现，内部维护一个注册项哈希表，同时也是与用户打交道的类，可以认为是
Service Locator。</li>
<li><code>scope</code>：<code>ResolverScope</code>
类型，它是服务解析的核心实现，内部维护一个缓存哈希表。</li>
<li><code>mutator</code>:
<code>ResolverFactoryMutator&lt;Service&gt;?</code>
类型，允许用户对初始化后的服务对象进行额外的修改。</li>
<li><code>mutator</code>：<code>ResolverFactoryMutatorArgumentsN&lt;Service&gt;?</code>
类型，允许用户使用参数对初始化后的服务对象进行额外的修改。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/resolver-03.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="resolverscope"><code>ResolverScope</code></h1>
<p>在上一节中，我们提到了 <code>ResolverScope</code>
主要负责服务解析，此外内部维护了一个缓存哈希表。下面，我们来深入分析一下，如下所示为
<code>ResolverScope</code> 的定义。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResolverScope</span>: <span class="title class_">ResolverScopeType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Moved definitions to ResolverScope to allow for dot notation access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// All application scoped services exist for lifetime of the app. (e.g Singletons)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> application <span class="operator">=</span> <span class="type">ResolverScopeCache</span>()</span><br><span class="line">    <span class="comment">/// Cached services exist for lifetime of the app or until their cache is reset.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> cached <span class="operator">=</span> <span class="type">ResolverScopeCache</span>()</span><br><span class="line">    <span class="comment">/// Graph services are initialized once and only once during a given resolution cycle. This is the default scope.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> graph <span class="operator">=</span> <span class="type">ResolverScopeGraph</span>()</span><br><span class="line">    <span class="comment">/// Shared services persist while strong references to them exist. They&#x27;re then deallocated until the next resolve.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">ResolverScopeShare</span>()</span><br><span class="line">    <span class="comment">/// Unique services are created and initialized each and every time they&#x27;re resolved.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> unique <span class="operator">=</span> <span class="type">ResolverScopeUnique</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abstract base for class never called</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;abstract&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>resolve</code> 的实现来看，我们也能够确认
<code>ResolverScope</code>
是一个抽象类。除此之外，它还定义了几个静态变量。这几个静态变量的类型都是
<code>ResolverScope</code> 的子类，而且类型有所不同。</p>
<p>下面，我们来看看它的子类。</p>
<h2 id="resolverscopecache"><code>ResolverScopeCache</code></h2>
<p><code>ResolverScopeCache</code>
的定义如下，其内部维护了一个缓存哈希表
<code>cacahedServices</code>。另外，它定义了一套自己的服务解析策略，从
<code>resolve</code> 方法可以看出大致的策略如下：</p>
<ol type="1">
<li>根据注册项的 <code>cacheKey</code>
查找服务对象，如果查到，则直接返回对应的服务对象；否则，进入步骤 2</li>
<li>调用服务初始化的真正执行者 <code>ResolverRegistration</code> 的
<code>resolve</code> 方法进行初始化服务对象。</li>
<li>如果初始化完成，则加入缓存哈希表进行缓存。</li>
<li>最后，返回服务对象。</li>
</ol>
<p>此外，<code>ResolverScopeCache</code> 还提供一个 <code>reset</code>
方法，可以清空缓存哈希表。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Cached services exist for lifetime of the app or until their cache is reset.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResolverScopeCache</span>: <span class="title class_">ResolverScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="comment">// 根据注册项的 cachedKey 读取缓存</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> service <span class="operator">=</span> cachedServices[registration.cacheKey] <span class="keyword">as?</span> <span class="type">Service</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> service</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有缓存，则解析并实例化 sevice，并存入缓存</span></span><br><span class="line">        <span class="keyword">let</span> service <span class="operator">=</span> registration.resolve(resolver: resolver, args: args)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> service <span class="operator">=</span> service &#123;</span><br><span class="line">            cachedServices[registration.cacheKey] <span class="operator">=</span> service</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">        cachedServices.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> cachedServices <span class="operator">=</span> [<span class="type">String</span> : <span class="keyword">Any</span>](minimumCapacity: <span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resolverscopegraph"><code>ResolverScopeGraph</code></h2>
<p><code>ResolverScopeGraph</code>
的定义如下所示，它也持有一个缓存哈希表，其服务解析策略与
<code>ResolverScopeCache</code>
大同小异，区别在于：它在一次解析周期中对于相同的服务只解析一次，当一次解析周期完毕后，自动清空缓存哈希表。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Graph services are initialized once and only once during a given resolution cycle. This is the default scope.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverScopeGraph</span>: <span class="title class_">ResolverScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="comment">// 根据注册项的 cachedKey 读取缓存</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> service <span class="operator">=</span> graph[registration.cacheKey] <span class="keyword">as?</span> <span class="type">Service</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> service</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有缓存，则解析并实例化 sevice，并存入缓存</span></span><br><span class="line">        resolutionDepth <span class="operator">=</span> resolutionDepth <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> service <span class="operator">=</span> registration.resolve(resolver: resolver, args: args)</span><br><span class="line">        resolutionDepth <span class="operator">=</span> resolutionDepth <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> resolutionDepth <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            graph.removeAll()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> service <span class="operator">=</span> service, <span class="built_in">type</span>(of: service <span class="keyword">as</span> <span class="keyword">Any</span>) <span class="keyword">is</span> <span class="type">AnyClass</span> &#123;</span><br><span class="line">            graph[registration.cacheKey] <span class="operator">=</span> service</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> graph <span class="operator">=</span> [<span class="type">String</span> : <span class="keyword">Any</span><span class="operator">?</span>](minimumCapacity: <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> resolutionDepth: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resolverscopeshare"><code>ResolverScopeShare</code></h2>
<p><code>ResolverScopeShare</code>
的定义如下所示，其内部同样持有一个缓存哈希表，它的解析策略也是优先查找缓存哈希表，如果找不到，则初始化服务对象并存入缓存。不过它通过一个封装类型弱引用了服务对象，从而允许服务对象被共享。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Shared services persist while strong references to them exist. They&#x27;re then deallocated until the next resolve.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverScopeShare</span>: <span class="title class_">ResolverScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> service <span class="operator">=</span> cachedServices[registration.cacheKey]<span class="operator">?</span>.service <span class="keyword">as?</span> <span class="type">Service</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> service</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> service <span class="operator">=</span> registration.resolve(resolver: resolver, args: args)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> service <span class="operator">=</span> service, <span class="built_in">type</span>(of: service <span class="keyword">as</span> <span class="keyword">Any</span>) <span class="keyword">is</span> <span class="type">AnyClass</span> &#123;</span><br><span class="line">            cachedServices[registration.cacheKey] <span class="operator">=</span> <span class="type">BoxWeak</span>(service: service <span class="keyword">as</span> <span class="type">AnyObject</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">        cachedServices.removeAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">BoxWeak</span> &#123;</span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> service: <span class="type">AnyObject</span>?</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cachedServices <span class="operator">=</span> [<span class="type">String</span> : <span class="type">BoxWeak</span>](minimumCapacity: <span class="number">32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="resolverscopeunique"><code>ResolverScopeUnique</code></h2>
<p><code>ResolverScopeUnique</code>
的定义如下所示，它内部并没有缓存哈希表，因此每一次进行服务解析时，它都会重新初始化一个服务对象。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Unique services are created and initialized each and every time they&#x27;re resolved.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverScopeUnique</span>: <span class="title class_">ResolverScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> registration.resolve(resolver: resolver, args: args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="resolverscopecontainer"><code>ResolverScopeContainer</code></h2>
<p><code>ResolverScopeContainer</code>
的定义如下所示，它内部没有缓存哈希表，它的解析策略是让 Resolver 的
<code>ResolverScopeCache</code> 来代理执行服务解析。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Proxy to container&#x27;s scope. Cache type depends on type supplied to container (default .cache)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ResolverScopeContainer</span>: <span class="title class_">ResolverScope</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">resolver</span>: <span class="type">Resolver</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span>) -&gt; <span class="type">Service</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> resolver.cache.resolve(registration: registration, resolver: resolver, args: args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="resolver"><code>Resolver</code></h1>
<p><code>Resolver</code>
是服务注册的核心，也是与用户直接打交道的类，用户通过调用它提供的方法进行注册和解析。</p>
<p>下面，我们来看一下 <code>Resolver</code>
的实现，由于它的代码较多，这里进行了部分删减，具体如下所示。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Resolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MARK: - Defaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Default registry used by the static Registration functions.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> main: <span class="type">Resolver</span> <span class="operator">=</span> <span class="type">Resolver</span>()</span><br><span class="line">    <span class="comment">/// Default registry used by the static Resolution functions and by the Resolving protocol.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> root: <span class="type">Resolver</span> <span class="operator">=</span> main</span><br><span class="line">    <span class="comment">/// Default scope applied when registering new objects.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> defaultScope: <span class="type">ResolverScope</span> <span class="operator">=</span> .graph</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - Lifecycle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">parent</span>: <span class="type">Resolver</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.parent <span class="operator">=</span> parent</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">register</span>&lt;<span class="type">Service</span>&gt;(<span class="keyword">_</span> <span class="params">type</span>: <span class="type">Service</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">Service</span>.<span class="keyword">self</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">                                        <span class="params">factory</span>: <span class="keyword">@escaping</span> <span class="type">ResolverFactory</span>&lt;<span class="type">Service</span>&gt;) -&gt; <span class="type">ResolverOptions</span>&lt;<span class="type">Service</span>&gt; &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">let</span> key <span class="operator">=</span> <span class="type">ObjectIdentifier</span>(<span class="type">Service</span>.<span class="keyword">self</span>).hashValue</span><br><span class="line">        <span class="keyword">let</span> registration <span class="operator">=</span> <span class="type">ResolverRegistrationOnly</span>(resolver: <span class="keyword">self</span>, key: key, name: name, factory: factory)</span><br><span class="line">        add(registration: registration, with: key, name: name)</span><br><span class="line">        <span class="keyword">return</span> registration</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">resolve</span>&lt;<span class="type">Service</span>&gt;(<span class="keyword">_</span> <span class="params">type</span>: <span class="type">Service</span>.<span class="keyword">Type</span> <span class="operator">=</span> <span class="type">Service</span>.<span class="keyword">self</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">args</span>: <span class="keyword">Any</span><span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">Service</span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        registrationCheck()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> registration <span class="operator">=</span> lookup(type, name: name),</span><br><span class="line">            <span class="keyword">let</span> service <span class="operator">=</span> registration.scope.resolve(resolver: <span class="keyword">self</span>, registration: registration, args: args) &#123;</span><br><span class="line">            <span class="keyword">return</span> service</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;RESOLVER: &#x27;<span class="subst">\(Service.<span class="keyword">self</span>)</span>:<span class="subst">\(name<span class="operator">?</span>.rawValue <span class="operator">??</span> <span class="string">&quot;NONAME&quot;</span>)</span>&#x27; not resolved. To disambiguate optionals use resolver.optional().&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - Internal</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Internal function searches the current and parent registries for a ResolverRegistration&lt;Service&gt; that matches</span></span><br><span class="line">    <span class="comment">/// the supplied type and name.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">lookup</span>&lt;<span class="type">Service</span>&gt;(<span class="keyword">_</span> <span class="params">type</span>: <span class="type">Service</span>.<span class="keyword">Type</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>?) -&gt; <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;? &#123;</span><br><span class="line">        <span class="keyword">let</span> key <span class="operator">=</span> <span class="type">ObjectIdentifier</span>(<span class="type">Service</span>.<span class="keyword">self</span>).hashValue</span><br><span class="line">        <span class="keyword">let</span> containerName <span class="operator">=</span> name<span class="operator">?</span>.rawValue <span class="operator">??</span> <span class="type">NONAME</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> container <span class="operator">=</span> registrations[key], <span class="keyword">let</span> registration <span class="operator">=</span> container[containerName] &#123;</span><br><span class="line">            <span class="keyword">return</span> registration <span class="keyword">as?</span> <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> parent <span class="operator">=</span> parent, <span class="keyword">let</span> registration <span class="operator">=</span> parent.lookup(type, name: name) &#123;</span><br><span class="line">            <span class="keyword">return</span> registration</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Internal function adds a new registration to the proper container.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">func</span> <span class="title function_">add</span>&lt;<span class="type">Service</span>&gt;(<span class="params">registration</span>: <span class="type">ResolverRegistration</span>&lt;<span class="type">Service</span>&gt;, <span class="params">with</span> <span class="params">key</span>: <span class="type">Int</span>, <span class="params">name</span>: <span class="type">Resolver</span>.<span class="type">Name</span>?) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">var</span> container <span class="operator">=</span> registrations[key] &#123;</span><br><span class="line">            container[name<span class="operator">?</span>.rawValue <span class="operator">??</span> <span class="type">NONAME</span>] <span class="operator">=</span> registration</span><br><span class="line">            registrations[key] <span class="operator">=</span> container</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registrations[key] <span class="operator">=</span> [name<span class="operator">?</span>.rawValue <span class="operator">??</span> <span class="type">NONAME</span> : registration]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> <span class="type">NONAME</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> parent: <span class="type">Resolver</span>?</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock <span class="operator">=</span> <span class="type">Resolver</span>.lock</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> registrations <span class="operator">=</span> [<span class="type">Int</span> : [<span class="type">String</span> : <span class="keyword">Any</span>]]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码中可以看出，<code>Resolver</code> 内部维护了一个注册项哈希表
<code>registrations</code>。</p>
<p>当用户调用 <code>register</code>
方法进行服务注册时，首先会在内部初始化一个注册项（
<code>ResolverRegistration</code> 的子类）。然后，调用 <code>add</code>
方法将注册项存入注册项哈希表中。</p>
<p>当用户调用 <code>resolve</code> 方法进行服务解析时，首先会调用
<code>loopup</code>
方法查找注册项哈希表中对应的注册项，然后调用注册项对应的 scope
进行服务解析，本质上服务的初始化最终还是由注册项完成。</p>
<p>在 Resolver 中，默认使用的 <code>ResolverScope</code> 是
<code>ResolverScopeGraph</code>
类型，当然我们也可以在注册时，通过调用注册项的 <code>scope</code>
方法进行切换。</p>
<p>我们仔细阅读 <code>loopup</code> 方法和 <code>init</code>
方法，可以发现，<code>Resolver</code> 可以其实是可以构成一棵
<code>Resolver</code> 树，在查找注册项时，会递归地查找父级
<code>Resolver</code> 中的注册项哈希表。</p>
<h2 id="resolving-协议"><code>Resolving</code> 协议</h2>
<p><code>Resolver</code>
为服务注册和服务解析同时实现了两套方法——静态方法和实例方法。</p>
<p>当我们使用静态方法时，对应的 <code>Resolver</code> 对象是一个全局变量
<code>root</code> 或 <code>main</code>，两者其实是同一个
<code>Resolver</code> 对象。</p>
<p>当我们使用实例方法时，首先我们需要初始化一个 <code>Resolver</code>
对象。对此，框架提供了一个 <code>Resolving</code>
协议，并扩展了默认实现，如下所示。这样的话，遵循了
<code>Resolving</code> 协议的类会自动扩展了一个 <code>Resolver</code>
类型的属性，并且执行修改类型。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Resolving</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resolver: <span class="type">Resolver</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Resolving</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> resolver: <span class="type">Resolver</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Resolver</span>.root</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="注解注入">注解注入</h1>
<p><code>Resolver</code>
除了完整实现了一套服务定位架构之外，还支持了注解注入。它提供了五种类型的注解，底层使用
<code>propertyWrapper</code> 实现的，分别如下：</p>
<ul>
<li><code>Injected&lt;Service&gt;</code></li>
<li><code>OptionalInjected&lt;Service&gt;</code></li>
<li><code>LazyInjected&lt;Service&gt;</code></li>
<li><code>WeakLazyInjected&lt;Service&gt;</code></li>
<li><code>InjectedObject&lt;Service&gt;</code></li>
</ul>
<p>使用注解的前提是，服务必须提前进行注册，因为注解在初始化时会立即进行服务解析。不过，<code>LazyInjected&lt;Service&gt;</code>
和 <code>WeakLazyInjected&lt;Service&gt;</code>
并无此要求，对于它们，只需要在调用前进行服务注册即可。</p>
<h1 id="设计模式">设计模式</h1>
<p>Resolver 框架其实采用了 <strong>策略模式</strong>
进行设计实现的。</p>
<p>当服务注册时，<code>Resolver</code> 依赖的是抽象类
<code>ResolverRegistration</code>，框架提供了三种具体类型的
<code>ResolverRegistration</code>。当已有类型满足不了需求时，我们可以对
<code>Resolver</code> 的 <code>register</code> 方法进行重载，并自定义
<code>ResolverRegistration</code> 子类。</p>
<p>当服务注册时，<code>Resolver</code> 依赖的同样是抽象类
<code>ResolverScope</code>，框架提供两个五种具体类型的
<code>ResolverScope</code>
以提供不同的解析策略。当已有类型满足不了需求时，我们同样可以自定义
<code>ResolverScope</code> 子类实现定制的解析策略。</p>
<h1 id="总结">总结</h1>
<p>本文对 Resolver 源码进行了解读，分析其整体框架的设计。Resolver
的核心主要包含三个部分：<code>ResolverRegistration</code>、<code>ResolverScope</code>、<code>Resolver</code>，它们各有各的职责，遵循了职责单一的设计原则，并且实现了一个扩展性很强的策略模式。</p>
<p>我认为 Resolver
非常适合作为重构的一套辅助工具，希望后面能够在实际开发中使用一下，从而能够在实践中提高一下自己的架构设计能力。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/hmlongco/Resolver">Resolver</a></li>
<li><a
href="http://chuquan.me/2021/06/07/ioc-di-sl/">控制反转、依赖注入、服务定位</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/strategy">Design
Pattern</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>依赖注入</tag>
        <tag>服务定位</tag>
        <tag>Resolver</tag>
        <tag>服务注册</tag>
        <tag>服务解析</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V——针对SoC的一套开放标准</title>
    <url>/2016/12/01/riscv-brief-introduction/</url>
    <content><![CDATA[<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/riscv-logo.png" />
</div>
<span id="more"></span>
<p><strong>对于大多数计算设备来说Linux已经成为了标准的操作系统，伯克利的研究者希望RISC-V也能够像Linux一样成为所有计算设备的标准ISA</strong></p>
<p>片上系统（systems-on-a-chip,
SoCs)，集成了处理器和cache，如今已经被越来越广泛的运用到各个领域之中。因此有越来越多的公司加入到了芯片制造这个领域之中。鉴于业界已经通过开放标准和开源软件进行了革命——如TCP/IP和Linux。那么作为最重要的接口之一的指令系统（instruction
set architecture，ISA）为什么不对所有人开放呢？</p>
<p>尽管指令系统由于历史或商业原因变得专利化了，但是从技术角度来看，必须要有免费的、开放的ISA。</p>
<p><em>这并不是一个遗漏的错误</em>。一些拥有很成功ISA的公司，如ARM，IBM，Intel，MIPS都拥有针对他们自己的ISA的专利，而这使得我们这些没有license的学术机构和小公司根本无法使用这些ISA，除非付出巨额的费用。</p>
<p>而ARM的license甚至还不允许你设计自己的ARM核；而是只能使用其设计。目前世界上大约只有10家大公司才拥有修改其设计自己的ARM核的license。这就是商业，通过阻止别人进行设计改造从而扼杀了竞争和创新。</p>
<p><em>也不是因为公司做大部分的软件开发</em>。虽然围绕这些流行ISA的软件生态系统有着非常高价值，但这几乎都是外人构建了所有的软件。</p>
<p><em>并不只有公司具备设计合格的ISA的能力</em>。虽然设计ISA涉及到大量工作，但是今天有很多机构或公司有能力设计ISA。</p>
<p><em>最流行的ISA并不见得是完美的ISA</em>。ARM和80x86不被视为完美的ISA。</p>
<p><em>也不是只有设计ISA的公司才能验证它们</em>。很久以前，开放组织开发了可以确保与诸如浮点单元（IEEE
754），网络芯片和交换机（以太网）和I/O总线（PCIe）的硬件标准兼容的机制。如果没有这样的组织，开放的IT标准也不会那么受欢迎。</p>
<p><em>最后，专有ISA不能保证永远存活下去</em>。如果一个公司倒闭了，它的ISA也会随之消亡。Digital
Equipment公司的消亡导致Alpha和VAX
ISA也一起终结了。注意，ISA实际上是一个接口规范，而不是实现。</p>
<p>其实有应该三种类型的ISA实现：<br />
(1) 私有的闭源，如AppleiOS (2) 许可的开源，如Wind River VxWorks (3)
免费的开源，用户可以修改、共享，如Linux</p>
<p>拥有专利的ISA实际上允许前两种类型，但是我们还需要一种免费开放的ISA。</p>
<p>我们的结论是，业界将受益于可行的，免费开放的ISA，就像它从免费开放的软件栈中获益。例如，它将实现一个真正的，自由，开放的处理器设计市场，拥有专利的ISA阻止了这样一个市场的诞生。这样的市场会具有：
- <strong>更强大的创新能力</strong>:
通过源自更多设计师的自由市场竞争，包括开放ISA与专有的ISA的竞争。<br />
- <strong>共享的、开放的核心设计</strong>:
这意味着更短的上市时间，更低的成本（由于重复使用），更少的错误（因为有更多人的关注），比如这将使政府机构加入涉密后门更困难。<br />
- <strong>负担得起的处理器</strong>:
更多的设备能够负担得起处理器的费用，这将有助于扩大物联网，其目标成本可能只有1美元。</p>
<p>要想让开源社区拥抱如此的开源ISA，我们认为它需要一个可靠的商业记录。第一个问题是，哪种风格的ISA有成功的历史？</p>
<p>在30年来没有这样的成功的ISA。除了DSP市场的一部分，VLIW已经失败了：Multiflow也不行，Itanium破产了，尽管惠普和英特尔投资了数十亿美元。没有新的CISC
ISA可以成功数十年。幸存的CISC从复杂的ISA转换为更容易执行的ISA，这对于制定有价值的遗留代码基础是非常有意义的。</p>
<p>一套新的ISA不会有任何遗留代码，所以额外的硬件成本和翻译的开销成本很难证明：为什么不是只使用易于执行的ISA在第一位？
RISC风格load-store ISA可以追溯到至少50年到Seymour Cray的CDC
6600.虽然80x86赢得了PC战争，RISC主导后PC时代的平板电脑和智能手机;
在2013年超过100亿基于ARM的SoC出货，相比之下，80x86芯片只有3亿。</p>
<p>鉴于ISA可以存活数十年，我们预测未来的技术景观，看看哪些功能对于基于RISC的免费开放ISA可能是重要的。
三个平台可能占据主导地位：物联网，个人移动设备和仓库规模计算机（WSC）。
这个蓝图式的建议有四个关键要求：<br />
(1) <strong>基本、扩展ISA</strong>:
为了匹配SoC的需求，同时保持稳定的软件基础，自由的，开放的ISA应该具有： -
编译器和操作系统可以依赖的一小组核心指令<br />
- 标准且可扩展的ISA，可以为应用程序定制SoC<br />
- 可调用特定应用程序加速器的全新操作码的空间<br />
这符合当今SoC经常使用自定义应用程序特定加速器的做法。</p>
<ol start="2" type="1">
<li><strong>紧凑指令集编码</strong>:
考虑到IoT的成本敏感性和对小容量存储器的期望，较小代码是可取的。<br />
</li>
<li><strong>四精度（QP）以及单精度和双精度浮点</strong>:
在WSC中运行的一些应用程序处理这样的大数据集，这依靠软件库进行QP运算。<br />
</li>
<li><strong>128位寻址以及32位和64位</strong>:
物联网上的节点的有限内存大小意味着32位寻址在未来几十年将是非常重要的，而64位寻址是更高要求的标准。尽管WSC行业不需要128位的运算，但是在十年内，WSC可能需要超过64位（16艾字节）来寻址所有的固态，非易失性存储器。</li>
</ol>
<p>这些都是需要很多年才能确认是否正确的细节，所以似乎使用现有的ISA起步是更聪明的做法，而不是成立委员会，从头开始。
RISC
ISAs都很相似，所以其中很多都可能是很好的选择。好消息是，已经有三个开源RISC
ISA：SPARC，OpenRISC和RISC-V。</p>
只有RISC-V满足上述所有四个要求（见下表）。
RISC-V也是10到20岁的年轻人，所以我们可以从以前的RISC
ISA的错误中学习和修复——例如，SPARC和OpenRISC延迟分支——这就是为什么RISC-V是如此简单和干净。
此外，SPARC（V9）的64位地址版本是专有的，而OpenRISC可能失去了动力。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/RISC-ISA-compare.gif" />
</div>
<p>RISC-V有很大的发展势头，到目前为止，它有来自Berkeley的8个芯片实现，以及在印度，英国和美国的外部项目。
由于开源Chisel硬件设计系统，一个64位RISC-V核要比类似过程制造的32位ARM内核快，且功耗和速度均为后者的一半。</p>
<p>虽然很难摒弃我们的偏见，但我们认为RISC-V是自由，开放RISC
ISA的最好的、最安全的选择。为了扩大这个免费的，开放的ISA的社区，我们将提供研讨会和创建一个非营利基础，以验证实施和维护和发展RISC-V。</p>
<p>虽然RISC-V的第一个首要目标是物联网，但我们有着更为远大的目标：正如Linux已成为大多数计算设备的标准操作系统一样，我们设想RISC-V成为所有计算设备的标准ISA。</p>
目前已经有大量公司和机构加入并关注着RISC-V的发展。<br />

<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/google.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/microsoft_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ibmpos_blurgb.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/NVIDIA.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/amd_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/huawei.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/westerndigital.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oracle.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/uc_berkeley_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/microsemi.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/lowrisc.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/nxp.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/minima_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codasip.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/eth_zurich_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/grayresearch.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/esperanto_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/cortus_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/roalogic.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/lattice.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ultra_soc.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/mircon.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/sifive.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bluespec.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/baesystems.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/espressif.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ict-logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/rumble.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/IDT.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/syntacore.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/andes_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/antmicro.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/blockstream_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/iit_madras_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/technolution.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/Mellanox_logo.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/Rambus-Cryptography-Research.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/draper.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/intrinsix.png" />
</div>
<div data-align="center">
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/runtime.png" />
</div>
<p>（完）</p>
<p><strong>参考</strong> [1] <a
href="http://www.eetimes.com/author.asp?doc_id=1323406&amp;page_number=1">RISC-V:
An Open Standard for SoCs</a></p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Threejs 实现 3D 魔方</title>
    <url>/2024/06/01/rubiks-cube-01/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-12.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>最近这段时间学习了计算机图形学和
Threejs，为了巩固一下学习效果，同时也希望给<a
href="https://apps.apple.com/cn/app/%E8%8E%AB%E8%B4%9F%E4%BC%91%E6%81%AF-%E4%BC%91%E6%81%AF%E6%8F%90%E9%86%92/id6474056217?mt=12">「莫负休息」</a>新增主题，于是基于
Threejs 实现了一个魔方程序。当然，基于 Threejs
的魔方程序其实早就已经有了，我只不过是站在前人的成果上做了一次实践和总结而已。</p>
<p>源码传送门——<a
href="https://github.com/baochuquan/rubiks-cube">Rubiks Cube</a>，Demo
传送门——<a href="http://rubiks.chuquan.me">rubiks.chuquan.me</a>。</p>
<h1 id="魔方的定义">魔方的定义</h1>
<p>魔方（Rubik's Cube），是匈牙利建筑学教授和雕塑鲁比克·埃尔内，于 1974
年发明的机械益智玩具。</p>
<p>魔方是一个正立方体，一共 6 个面，对应 6
种颜色。魔方的官方配色是：白色、红色、橙色、黄色、绿色、蓝色，其中黄白相对，红橙相对，蓝绿相对，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-01.png?x-oss-process=image/resize,w_800" /></p>
<p>一个三阶魔方由 3 x 3 x 3 共 27 个方块组成，根据方块的位置，可以分为 3
种类型，分别是：</p>
<ul>
<li>中心块：中心块有 6
个，位于魔方每面的正中心，只有一种颜色。中心块彼此之间的相对位置不会变化。</li>
<li>棱块：棱块有 12
个，位于魔方每个魔方中心块的上下左右，有两种颜色。</li>
<li>角块：角块有 8 个，位于魔方每个魔方中心块的斜对角，有三种颜色。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="场景布置">场景布置</h1>
<p>对于任意 3D
场景，我们都需要先对场景中的基本元素进行设置，主要包括：相机、灯光、渲染器。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-03.png?x-oss-process=image/resize,w_800" /></p>
<p>首先初始化一个场景
<code>Scene</code>，后续所有相关元素都将添加至这个场景中，并设置位置坐标。</p>
<p>然后，我们初始化相机，Threejs
中有两种相机：正交相机、透视相机。透视相机成像的画面具有近大远小的效果，所以我们这里使用透视相机。当然，相机的位置确立之后，我们还需要确定它的观测方向，这里使用
<code>lookAt</code> 方法。此外，我们还可以设置相机的视场（Field of
View），它表示相机的可视角度值，决定了屏幕画面的可视范围。</p>
<p>对于灯光，这里我只设置了一个环境光，因此无需设置坐标。当然，Threejs
中有很多光源，比如：点光源、面光源、射线光源等。</p>
<p>相关的代码实现如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scene, camera, renderer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupScene</span>(<span class="params"></span>) &#123;</span><br><span class="line">  scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>();</span><br><span class="line">  scene.<span class="property">background</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupCamera</span>(<span class="params"></span>) &#123;</span><br><span class="line">  camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line">    <span class="number">45</span>,</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line">    <span class="number">0.1</span>, </span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">  camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">10</span>, <span class="number">12</span>, <span class="number">10</span>);</span><br><span class="line">  camera.<span class="title function_">lookAt</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">  camera.<span class="property">fov</span> = <span class="number">45</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupLights</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ambientLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">  scene.<span class="title function_">add</span>(ambientLight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们还需要定义一个渲染器。通过渲染器我们才能够将 3D
场景的渲染结果并绑定至 2D
平面，相关代码如下所示。在具体实现中，我们将渲染器的 DOM 元素绑定至
<code>body</code> 中，这样我们才能在 2D 网页中看到渲染效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123;</span><br><span class="line">    <span class="attr">antialias</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了方便查看空间效果，一般我们会创建一个轨道控制器。基于轨道控制器，我们可以通过鼠标旋转整个空间坐标系，从而可以在不同角度进行观测，相关代码如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupControls</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化控制器</span></span><br><span class="line">  controller = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, renderer.<span class="property">domElement</span>);</span><br><span class="line">  controller.<span class="property">enableDamping</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="魔方建模">魔方建模</h1>
<p>完成了场景布置之后，我们将在空间中对魔方进行建模。建模的过程非常简单，只需创建
3 x 3 x 3 共 27
个立方体即可，每个立方体的表面使用贴图作为材质。为了便于后续旋转魔方时获取同一平面中的
9 个立方体，我们在建模时会对每个立方体设置编号索引，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-04.png?x-oss-process=image/resize,w_800" /></p>
<p>魔方建模的实现代码如下所示。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建立方体，并加入场景</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupCubes</span>(<span class="params"></span>) &#123;</span><br><span class="line">  cubes = <span class="title function_">createCube</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> cube = cubes[i];</span><br><span class="line">    scene.<span class="title function_">add</span>(cube);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建立方体，设置空间左边，使用贴图作为材质</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCube</span>(<span class="params">x, y, z, num, len</span>) &#123;</span><br><span class="line">  <span class="comment">// 魔方左上角坐标</span></span><br><span class="line">  <span class="keyword">var</span> leftUpX = x - num / <span class="number">2</span> * len;</span><br><span class="line">  <span class="keyword">var</span> leftUpY = y + num / <span class="number">2</span> * len;</span><br><span class="line">  <span class="keyword">var</span> leftUpZ = z + num / <span class="number">2</span> * len;</span><br><span class="line">  <span class="comment">// 根据颜色生成材质</span></span><br><span class="line">  <span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>();</span><br><span class="line">  <span class="keyword">const</span> textures = [</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/blue.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/green.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/yellow.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/white.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/orange.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/red.png&quot;</span>),</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> materials = textures.<span class="title function_">map</span>(<span class="function"><span class="params">texture</span> =&gt;</span> <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">map</span>: texture &#125;));</span><br><span class="line">  <span class="comment">// 生成小方块</span></span><br><span class="line">  <span class="keyword">var</span> cubes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; num * num; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> box = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(len, len, len);</span><br><span class="line">      <span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(box, materials);</span><br><span class="line">      <span class="comment">// 依次计算各个小方块中心点坐标</span></span><br><span class="line">      mesh.<span class="property">position</span>.<span class="property">x</span> = (leftUpX + len / <span class="number">2</span>) + (j % num) * len;</span><br><span class="line">      mesh.<span class="property">position</span>.<span class="property">y</span> = (leftUpY - len / <span class="number">2</span>) - <span class="built_in">parseInt</span>(j / num) * len;</span><br><span class="line">      mesh.<span class="property">position</span>.<span class="property">z</span> = (leftUpZ - len / <span class="number">2</span>) - i * len;</span><br><span class="line">      mesh.<span class="property">tag</span> = i * <span class="number">9</span> + j;</span><br><span class="line">      cubes.<span class="title function_">push</span>(mesh);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cubes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，魔方建模实现完成，完整的代码可以参考 <a
href="https://github.com/baochuquan/rubiks-cube/blob/main/src/components/RubiksCube01.vue">RubiksCube01.vue</a>
文件。</p>
<h1 id="魔方控制">魔方控制</h1>
<p>魔方控制是基于鼠标实现的，核心思想分为以下几个步骤：</p>
<ul>
<li>首先，通过鼠标触点确定触点目标方块和触点平面法向量</li>
<li>其次，根据鼠标移动方向和触点平面法向量确定旋转方向</li>
<li>然后，通过旋转方向和触点目标方块获取整个旋转平面</li>
<li>最后，对整个旋转平面中的所有方块执行旋转动画</li>
</ul>
<h2 id="监听鼠标事件">监听鼠标事件</h2>
<p>鼠标事件是控制魔方的基础，因此我们需要实现鼠标事件的监听。相关实现如下所示，我们同时处理了鼠标控制和触摸控制两种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupEvents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, startMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, moveMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, stopMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, startMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, moveMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, stopMouse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="确定触点方块与平面法向量">确定触点方块与平面法向量</h2>
<p>对于确定目标触点方块和平面法向量，这里有两个问题：</p>
<ul>
<li>如何通过二维平面中的鼠标位置确定三维空间中的位置呢？</li>
<li>立方体的位置不固定，那么该如何确定触点平面的方向呢？</li>
</ul>
<p>对于第一个问题，解决方法是
<strong>射线</strong>（Raycaster），其基本原理是：通过相机位置和鼠标位置确定三维空间中的一根射线，延伸射线，找到三维空间中与射线相交的物体，根据自定义规则（比如：第一个）来找到目标物体。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-05.png?x-oss-process=image/resize,w_800" /></p>
<p>对于第二个问题，我们首先需要了解一下 Threejs 中的坐标系统： -
全局坐标系：也称世界坐标系，是整个 3D 场景的坐标系。 -
局部坐标系：也称物体坐标系。在 iOS/Android 中存在视图层级树，在 Threejs
中同样存在场景层级树，整个 3D
场景是根场景，空间中的物体可以作为子场景，子场景又可以继续添加场景。每个场景有自己的坐标系，当对一个场景进行仿射变换，那么它的子场景也会发生仿射变换，这就是物体坐标系的作用。</p>
<p>由于魔方旋转过程中，每个立方体自身的也在不停的旋转和移动，此时每个物体的局部坐标系也会发生变换，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-06.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，如果基于目标立方体获取其表面法向量，那么获取到的法向量是基于局部坐标系的，不具备全局意义。因此，我们必须要将基于
<strong>局部坐标系</strong> 的表面法向量转换成基于
<strong>全局坐标系</strong> 的表面法向量。</p>
<p>对此，有两种解决方法：</p>
<ul>
<li>对基于局部坐标系的法向量通过矩阵变换，转换成基于全局坐标系。</li>
<li>增加一个固定不变的透明物体，通过射线获取其表面法向量，以代表立方体的表面法向量。</li>
</ul>
<p>对于前者，我们需要记录立方体从原始位置到当前位置的所有变换操作，再对基于局部坐标系的法向量做逆变换。这种方案实现难度且计算量都很大。</p>
<p>对于后者，其实现难度显然更低。我们只需创建一个透明的立方体，其大小与魔方整体相同，如下图所示。当判断表面法向量时，通过该透明立方体获取即可，由此得到的是基于全局坐标系的法向量。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-07.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示为确定触点方块与平面法向量的核心代码逻辑。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupRubiks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 透明正方体</span></span><br><span class="line">  <span class="keyword">let</span> box = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">vertexColors</span>: <span class="variable constant_">THREE</span>.<span class="property">FaceColors</span>, <span class="attr">opacity</span>: <span class="number">0</span>, <span class="attr">transparent</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  rubiks = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(box, mesh);</span><br><span class="line">  rubiks.<span class="property">cubeType</span> = <span class="string">&#x27;coverCube&#x27;</span>;</span><br><span class="line">  scene.<span class="title function_">add</span>(rubiks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取操作焦点以及该焦点所在平面的法向量 </span></span><br><span class="line"><span class="comment"> * */</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getIntersectAndNormalize</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mouse = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>();</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">touches</span>) &#123;</span><br><span class="line">    <span class="comment">// 触摸事件</span></span><br><span class="line">    <span class="keyword">var</span> touch = event.<span class="property">touches</span>[<span class="number">0</span>];</span><br><span class="line">    mouse.<span class="property">x</span> = (touch.<span class="property">clientX</span> / <span class="variable language_">window</span>.<span class="property">innerWidth</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    mouse.<span class="property">y</span> = -(touch.<span class="property">clientY</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 鼠标事件</span></span><br><span class="line">    mouse.<span class="property">x</span> = (event.<span class="property">clientX</span> / <span class="variable language_">window</span>.<span class="property">innerWidth</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    mouse.<span class="property">y</span> = -(event.<span class="property">clientY</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raycaster = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Raycaster</span>();</span><br><span class="line">  raycaster.<span class="title function_">setFromCamera</span>(mouse, camera);</span><br><span class="line">  <span class="comment">// Raycaster方式定位选取元素，可能会选取多个，以第一个为准</span></span><br><span class="line">  <span class="keyword">var</span> intersects = raycaster.<span class="title function_">intersectObjects</span>(scene.<span class="property">children</span>);</span><br><span class="line">  <span class="keyword">var</span> intersect, normalize;</span><br><span class="line">  <span class="keyword">if</span> (intersects.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">cubeType</span> === <span class="string">&#x27;coverCube&#x27;</span>) &#123;</span><br><span class="line">        intersect = intersects[<span class="number">1</span>];</span><br><span class="line">        normalize = intersects[<span class="number">0</span>].<span class="property">face</span>.<span class="property">normal</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intersect = intersects[<span class="number">0</span>];</span><br><span class="line">        normalize = intersects[<span class="number">1</span>].<span class="property">face</span>.<span class="property">normal</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="comment">//nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">intersect</span>: intersect, <span class="attr">normalize</span>: normalize&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="确定旋转方向">确定旋转方向</h2>
<p>下面，我们基于触点目标方块、表面法向量，再结合鼠标移动方向，计算旋转方向。具体实现原理主要包括以下几个步骤：</p>
<ul>
<li>计算鼠标的平移向量</li>
<li>判断平移向量与全局坐标系 6 个方向之间的夹角，选择夹角最小的方向</li>
<li>结合表面法向量，确定旋转方向</li>
</ul>
<p>为什么要结合表面法向量来确定旋转方向？因为同一平移向量时，表面法向量不同，则魔方的旋转方向也不同。如下所示，当鼠标平移方向接近
<code>x</code> 轴方向，如果表面法向量与 <code>z</code>
轴方向相同，那么魔方将环绕 <code>y</code>
轴进行逆时针旋转；如果表面法向量与 <code>y</code>
轴方向相同，那么魔方将环绕 <code>z</code> 轴进行顺时针旋转。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-08.png?x-oss-process=image/resize,w_800" /></p>
<p>如下所示，为判断魔方旋转方向的代码逻辑。我们根据不同的拖拽方向分情况讨论，最终确定魔方的
6 种旋转方向。 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 魔方转动的六个方向</span></span><br><span class="line"><span class="keyword">const</span> xLine = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );     <span class="comment">// X轴正方向</span></span><br><span class="line"><span class="keyword">const</span> xLineAd = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );  <span class="comment">// X轴负方向</span></span><br><span class="line"><span class="keyword">const</span> yLine = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> );     <span class="comment">// Y轴正方向</span></span><br><span class="line"><span class="keyword">const</span> yLineAd = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span> );  <span class="comment">// Y轴负方向</span></span><br><span class="line"><span class="keyword">const</span> zLine = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );     <span class="comment">// Z轴正方向</span></span><br><span class="line"><span class="keyword">const</span> zLineAd = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span> );  <span class="comment">// Z轴负方向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得旋转方向</span></span><br><span class="line"><span class="comment"> * vector3: 鼠标滑动的方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDirection</span>(<span class="params">vector3</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> direction;</span><br><span class="line">  <span class="comment">// 判断差向量和 x、y、z 轴的夹角</span></span><br><span class="line">  <span class="keyword">var</span> xAngle = vector3.<span class="title function_">angleTo</span>(xLine);</span><br><span class="line">  <span class="keyword">var</span> xAngleAd = vector3.<span class="title function_">angleTo</span>(xLineAd);</span><br><span class="line">  <span class="keyword">var</span> yAngle = vector3.<span class="title function_">angleTo</span>(yLine);</span><br><span class="line">  <span class="keyword">var</span> yAngleAd = vector3.<span class="title function_">angleTo</span>(yLineAd);</span><br><span class="line">  <span class="keyword">var</span> zAngle = vector3.<span class="title function_">angleTo</span>(zLine);</span><br><span class="line">  <span class="keyword">var</span> zAngleAd = vector3.<span class="title function_">angleTo</span>(zLineAd);</span><br><span class="line">  <span class="keyword">var</span> minAngle = <span class="title class_">Math</span>.<span class="title function_">min</span>(...[xAngle, xAngleAd, yAngle, yAngleAd, zAngle, zAngleAd]);  <span class="comment">// 最小夹角</span></span><br><span class="line">  <span class="keyword">switch</span>(minAngle)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">xAngle</span>:</span><br><span class="line">      direction = <span class="number">10</span>;  <span class="comment">// 向x轴正方向旋转90度（还要区分是绕z轴还是绕y轴）</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">xAngleAd</span>:</span><br><span class="line">      direction = <span class="number">20</span>;  <span class="comment">// 向x轴反方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">yAngle</span>:</span><br><span class="line">      direction = <span class="number">30</span>;  <span class="comment">// 向y轴正方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">yAngleAd</span>:</span><br><span class="line">      direction = <span class="number">40</span>;  <span class="comment">// 向y轴反方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">zAngle</span>:</span><br><span class="line">      direction = <span class="number">50</span>;  <span class="comment">// 向z轴正方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">zAngleAd</span>:</span><br><span class="line">      direction = <span class="number">60</span>;  <span class="comment">// 向z轴反方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="确定旋转平面">确定旋转平面</h2>
<p>随后，我们可以根据触点目标方块的位置，结合旋转方向，找到与它同一旋转平面的立方体。比如，对于绕
<code>x</code> 轴旋转时，我们只需要找到所有与触点目标方块的
<code>x</code> 坐标相同的立方体即可。相关实现如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-11.png?x-oss-process=image/resize,w_800" /></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据立方体和旋转方向，找到同一平面上的所有立方体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPlaneCubes</span>(<span class="params">cube, direction</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">let</span> orientation = direction % <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> radians = (orientation % <span class="number">2</span> == <span class="number">1</span>) ? <span class="number">90</span> : -<span class="number">90</span>;</span><br><span class="line">  <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="comment">// 绕x轴</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = cubes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">position</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(curr.<span class="property">position</span>.<span class="property">x</span> - cube.<span class="property">position</span>.<span class="property">x</span>) &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">          results.<span class="title function_">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="comment">// 绕y轴</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = cubes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">position</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(curr.<span class="property">position</span>.<span class="property">y</span> - cube.<span class="property">position</span>.<span class="property">y</span>) &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">          results.<span class="title function_">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="comment">// 绕z轴</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = cubes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">position</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(curr.<span class="property">position</span>.<span class="property">z</span> - cube.<span class="property">position</span>.<span class="property">z</span>) &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">          results.<span class="title function_">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现旋转动画">实现旋转动画</h2>
<p>最后，我们需要实现旋转动画。对此，我们首先定义动画时长，根据当前时长与动画时长的比例，计算当前旋转角度的比例，并更新位置，从而实现旋转效果。关于旋转变换，我们在
<a
href="https://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2">《计算机图形学基础（2）——变换》</a>
一文中也介绍过。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-09.png?x-oss-process=image/resize,w_800" /></p>
<p>我们以 2D
平面中的物体旋转来推导旋转矩阵。上图所示，我们将左边的图片进行旋转得到右边的图片，那么我们必须求解如下所示的矩阵运算公式，其中
<span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>
为待求解的变量。</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39; \\
y&#39;
\end{matrix}
\right)
=
\left(
\begin{matrix}
A &amp; B \\
C &amp; D \\
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y
\end{matrix}
\right)
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-10.png?x-oss-process=image/resize,w_800" /></p>
<p>为了求解 <span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>
四个变量，我们将以 <span class="math inline">\((0, 1)\)</span> 和 <span
class="math inline">\((1, 0)\)</span> 两个点的旋转为例求解方程。</p>
<p>对于 <span class="math inline">\((0, 1)\)</span>
点的旋转，我们可以得到如下方程：</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
-sin \theta
\\
cos \theta
\end{matrix}
\right)
=
\left(
\begin{matrix}
A &amp; B \\
C &amp; D \\
\end{matrix}
\right)
\left(
\begin{matrix}
0 \\
1
\end{matrix}
\right)

\\
-sin \theta = A * 0 + B * 1 = B
\\
cos \theta = C * 0 + D * 1 = D
\end{aligned}\]</span>
<p>对于 <span class="math inline">\((1, 0)\)</span>
点的旋转，我们可以得到如下方程：</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
cos \theta
\\
sin \theta
\end{matrix}
\right)
=
\left(
\begin{matrix}
A &amp; B \\
C &amp; D \\
\end{matrix}
\right)
\left(
\begin{matrix}
1 \\
0
\end{matrix}
\right)

\\
cos \theta = A * 1 + B * 0 = A
\\
sin \theta = C * 1 + D * 0 = C
\end{aligned}\]</span>
<p>至此 <span class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>
四个变量均已求解，由此得到旋转矩阵如下：</p>
<span class="math display">\[\begin{aligned}
\left(
\begin{matrix}
x&#39;
\\
y&#39;
\end{matrix}
\right)
=
\left(
\begin{matrix}
cos\theta &amp; -sin\theta \\
sin\theta &amp; cos\theta \\
\end{matrix}
\right)
\left(
\begin{matrix}
1 \\
0
\end{matrix}
\right)
\end{aligned}\]</span>
<p>进而得到 <span class="math inline">\(x&#39;\)</span> 和 <span
class="math inline">\(y&#39;\)</span> 的计算公式如下：</p>
<span class="math display">\[\begin{aligned}
x&#39; = cos\theta x - sin\theta y
\\
y&#39; = sin\theta x + cos\theta y
\end{aligned}\]</span>
<p>由于魔方的旋转都是沿着一个轴进行旋转，所以我们可以将它看成三种情况的
2D 平面旋转，由此得到如下 3 个旋转方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rotateAroundWorldX</span>(<span class="params">cube, rad</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> y0 = cube.<span class="property">position</span>.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">var</span> z0 = cube.<span class="property">position</span>.<span class="property">z</span>;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Quaternion</span>(); </span><br><span class="line">    q.<span class="title function_">setFromAxisAngle</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ), rad);</span><br><span class="line">    cube.<span class="property">quaternion</span>.<span class="title function_">premultiply</span>(q);</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * y0 - <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * z0;</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">z</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * z0 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * y0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rotateAroundWorldY</span>(<span class="params">cube, rad</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x0 = cube.<span class="property">position</span>.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">var</span> z0 = cube.<span class="property">position</span>.<span class="property">z</span>;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Quaternion</span>(); </span><br><span class="line">    q.<span class="title function_">setFromAxisAngle</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> ), rad);</span><br><span class="line">    cube.<span class="property">quaternion</span>.<span class="title function_">premultiply</span>( q );</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * x0 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * z0;</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">z</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * z0 - <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * x0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rotateAroundWorldZ</span>(<span class="params">cube, rad</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x0 = cube.<span class="property">position</span>.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">var</span> y0 = cube.<span class="property">position</span>.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Quaternion</span>(); </span><br><span class="line">    q.<span class="title function_">setFromAxisAngle</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ), rad);</span><br><span class="line">    cube.<span class="property">quaternion</span>.<span class="title function_">premultiply</span>( q );</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * x0 - <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * y0;</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * y0 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * x0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由于这几个方法仅仅旋转物体、更新坐标，实际上我们需要在一段时间内连续进行调用，从而实现一个完整的旋转动画，具体的调用实现如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rotateAnimation</span>(<span class="params">cubes, direction, currentstamp, startstamp, laststamp</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(startstamp === <span class="number">0</span>)&#123;</span><br><span class="line">        startstamp = currentstamp;</span><br><span class="line">        laststamp = currentstamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currentstamp - startstamp &gt;= rotateDuration)&#123;</span><br><span class="line">      currentstamp = startstamp + rotateDuration;</span><br><span class="line">      isRotating = <span class="literal">false</span>;</span><br><span class="line">      startPoint = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> orientation = direction % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> radians = (orientation % <span class="number">2</span> == <span class="number">1</span>) ? -<span class="number">90</span> : <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="title function_">rotateAroundWorldX</span>(cubes[i], radians * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * (currentstamp - laststamp) / rotateDuration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="title function_">rotateAroundWorldY</span>(cubes[i], radians * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * (currentstamp - laststamp) / rotateDuration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="title function_">rotateAroundWorldZ</span>(cubes[i], radians * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * (currentstamp - laststamp) / rotateDuration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currentstamp - startstamp &lt; rotateDuration)&#123;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="function">(<span class="params">timestamp</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">rotateAnimation</span>(cubes, direction, timestamp, startstamp, currentstamp);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们实现了通过鼠标控制魔方的旋转，完整的代码可以参考 <a
href="https://github.com/baochuquan/rubiks-cube/blob/main/src/components/RubiksCube02.vue">RubiksCube02.vue</a>
文件。</p>
<h1 id="总结">总结</h1>
<p>本文我们基于 Threejs 实现了一个 3D
魔方，并支持了通过鼠标控制魔方旋转的功能。后续，我们将进一步介绍如何实现魔方的自动还原算法。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://mofang.1or9.com/mofangdingyi.shtml">魔方基本定义</a></li>
</ol>
]]></content>
      <categories>
        <category>Threejs</category>
      </categories>
      <tags>
        <tag>Threejs</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift 核心实现原理</title>
    <url>/2020/08/24/rxswift-core-implement/</url>
    <content><![CDATA[<p>一直以来，响应式编程都是业界讨论的热门话题之一。为了推广响应式编程，ReactiveX
社区几乎为每一种编程语言设计实现了一种对应的响应式编程框架。RxSwift
就是针对 Swift 所开发的响应式框架。</p>
<span id="more"></span>
<p>关于 RxSwift，网上有不少相关的学习资料，但绝大多数都是 RxSwift
的使用说明，鲜有文章介绍 RxSwift
背后的设计原理。通过阅读源码，查阅资料，正向设计，我逐步理解了 RxSwift
的设计思想。因此，趁热打铁，记录并总结一下我的理解。</p>
<p>下文我们首先介绍一下 RxSwift
中所涉及的基本概念。然后，从零开始设计并实现 RxSwift，从而逐步理解
RxSwift 的设计理念。</p>
<p><strong>本文所实现的 RxSwift 代码已在 Github 开源——<a
href="https://github.com/baochuquan/implementing-rx">传送门</a></strong>。参照源码阅读本文效果更佳。</p>
<h1 id="基础">基础</h1>
<p>RxSwift 主要蕴含了以下几种设计思想：</p>
<ul>
<li><strong>发布-订阅模式</strong></li>
<li><strong>流编程</strong></li>
<li><strong>函数式编程</strong></li>
</ul>
<p>下面，我们依次来进行介绍。</p>
<h2 id="发布-订阅模式">发布-订阅模式</h2>
<p><strong>发布-订阅模式</strong> 是 RxSwift
所呈现的一种最直观思想。发布-订阅模式可以分为两个角色：<strong>发布者</strong>、<strong>订阅者</strong>。</p>
<p>订阅者的主要职责是：</p>
<ul>
<li>订阅：监听并处理某个事件。其本质就是向发布者注册一个处理某个事件的闭包。</li>
<li>取消（订阅）</li>
</ul>
<p>发布者的主要职责是：</p>
<ul>
<li>发布：分发某个事件</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern.png?x-oss-process=image/resize,w_800" /></p>
<p>发布-订阅模式的基本原理是：</p>
<ul>
<li>订阅者调用发布者提供的订阅方法进行订阅，从而在发布者内部注册订阅者。</li>
<li>发布者内部会维护一个订阅者列表。</li>
<li>当发布者发布事件时，会遍历订阅者列表，执行其中的处理方法（将事件作为参数传递给闭包，并执行）。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-implementation.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="举例">举例</h3>
<p>在日常开发中，发布-订阅模式是一种广泛被应用的设计模式。比如：iOS 中的
NotificationCenter、Flutter
中的事件总线都是基于这种模式实现的。如下所示为 Flutter
中事件总线的一种实现方式，其中的代码逻辑基本遵循了上述所描述的发布-订阅模式的基本原理。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅者订阅内容签名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> EventCallback(arg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    EventBus._internal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存单例</span></span><br><span class="line">    <span class="keyword">static</span> EventBus _singleton = <span class="keyword">new</span> EventBus._internal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂构造函数</span></span><br><span class="line">    <span class="keyword">factory</span> EventBus()=&gt; _singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存事件订阅者队列，key:事件名(id)，value: 对应事件的订阅者队列</span></span><br><span class="line">    <span class="keyword">var</span> _emap = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">List</span>&lt;EventCallback&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加订阅者，即订阅</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">on</span>(eventName, EventCallback f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventName == <span class="keyword">null</span> || f == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        _emap[eventName] ??= <span class="keyword">new</span> <span class="built_in">List</span>&lt;EventCallback&gt;();</span><br><span class="line">        _emap[eventName].add(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除订阅者，即取消</span></span><br><span class="line">    <span class="keyword">void</span> off(eventName, [EventCallback f]) &#123;</span><br><span class="line">        <span class="keyword">var</span> list = _emap[eventName];</span><br><span class="line">        <span class="keyword">if</span> (eventName == <span class="keyword">null</span> || list == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            _emap[eventName] = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.remove(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件，事件触发后该事件所有订阅者会被调用，即发布</span></span><br><span class="line">    <span class="keyword">void</span> emit(eventName, [arg]) &#123;</span><br><span class="line">        <span class="keyword">var</span> list = _emap[eventName];</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">int</span> len = list.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 反向遍历，防止订阅者在回调中移除自身带来的下标错位 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = len; i &gt; <span class="number">-1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 执行注册的闭包</span></span><br><span class="line">            list[i](arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 top-level（全局）变量，页面引入该文件后可以直接使用 bus</span></span><br><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> EventBus();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考：为什么 iOS 中一个监听了某个通知的类必须要在
<code>dealloc</code> 时要执行 <code>removeObserver:</code> 方法？</p>
</blockquote>
<h2 id="流编程">流编程</h2>
<p><strong>流（stream）</strong> 是 RxSwift
另一个重要的设计思想。<code>Observable&lt;T&gt;</code> 是 Rx
框架的基础，也被称为
<strong>可观察序列</strong>。它的作用是可以异步地产生一系列数据，即一个
<code>Observable&lt;T&gt;</code> 对象会随着时间的推移不定期地发出
<code>event(element: T)</code>。数据就像水流一样持续不断地在流动，顾名思义，这也被称为
<strong>流编程</strong>。</p>
<p>关于流编程，《计算机程序的构造与解释》一书中认为
<strong>流编程是一种调用驱动的编程思想</strong>。流编程的基本思想是：<strong>一般情况下，只是部分地构造出流的结构，并将这样的部分结构传给使用流的程序。如果使用者需要访问这个流中未构造出的那个部分，那么这个流就会自动地继续构造下去，但是只做出满足当时需要的那一部分</strong>。</p>
<p>如下所示是 RxSwift 中常见使用形式，<code>observable</code>
是数据源，不断地发出数据，如果水流一样，最终流向 <code>subscribe</code>
中的闭包。期间会流经 <code>map</code>，<code>filter</code>
等操作符，经过转换或过滤。这就是流编程的思想。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observable: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Observable</span>.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.onNext(<span class="number">0</span>)</span><br><span class="line">    observer.onNext(<span class="number">1</span>)</span><br><span class="line">    observer.onNext(<span class="number">2</span>)</span><br><span class="line">    observer.onNext(<span class="number">3</span>)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable.map &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">2</span> &#125;.filter &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">3</span> &#125;.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流编程底层实现的本质则是
<strong>闭包的延迟执行和强制执行</strong>。具体来说是基于一种称为
<code>delay</code> 的特殊形式，对于 <code>delay &lt;exp&gt;</code>
的求值不会对 <code>&lt;exp&gt;</code> 求值，而是返回一个称为
<strong>延时对象</strong> 的对象。它可以看做是对未来的某个时间求值
<code>&lt;exp&gt;</code>
的允诺。在各类编程语言中，返回特定类型的闭包常被用于描述一个延迟对象。与
<code>delay</code> 配对的是 <code>force</code>
的过程。它以一个延时对象为参数，执行相应的求值工作，即迫使
<code>delay</code>
完成其所允诺的求值。在各类编程语言中，执行返回特定类型的闭包常被用于描述
<code>force</code> 的过程。</p>
<h2 id="函数式编程">函数式编程</h2>
<p>RxSwift
提供了大量无副作用的操作符，无副作用也是函数式编程的一种重要特性。RxSwift
能够实现操作符的链式调用，一个重要的前提是：<strong>提供操作符的类型和操作符的返回类型必须保持一致</strong>。这里就涉及到了函数式编程中的一些高阶概念：<strong>函子（Functor）</strong>、<strong>适用函子（Applicative）</strong>、<strong>单子（Monad）</strong>。详细内容可参见<a
href="http://chuquan.me/2020/07/06/fp-functor-applicative-monad/">《函数式编程——Functor、Applicative、Monad》</a>一文。</p>
<p>不过，RxSwift 操作符中运用最多的是
<strong>函子</strong>（Functor），什么是函子？简而言之，<strong>函子能够将普通函数应用到一个包装类型</strong>。如下图及代码所示，一个包装类型包含了一个原始值，当函子作用在其上后，使用普通函数对原始值进行转换，最终将结果值放入包装类型中返回。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/fp-apply.png?x-oss-process=image/resize,w_800" /></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="comment">// 满足 Functor 的条件：map 方法能够将 普通函数 应用到包装类</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">U</span>&gt;(<span class="keyword">_</span> <span class="params">f</span>: (<span class="type">T</span>) -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> x): <span class="keyword">return</span> .success(f(x))</span><br><span class="line">        <span class="keyword">case</span> .failure: <span class="keyword">return</span> .failure</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 RxSwift 中最常用的 <code>map</code>
操作符为例，如下所示。<code>map</code> 方法扩展自
<code>ObservableType</code>，其能够将普通函数
<code>(Element) -&gt; Result</code> 应用到 <code>ObservableType</code>
包装类型。这其实就是一种典型的 <strong>函子</strong> 应用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">Result</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>)</span><br><span class="line">        -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Map</span>(source: <span class="keyword">self</span>.asObservable(), transform: transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="核心实现">核心实现</h1>
<p>下面我们将以正向设计的方式，结合 RxSwift 中的设计思想，手动实现一个
RxSwift 的核心部分。</p>
<h2 id="基本功能rxdemo-01">基本功能(RxDemo-01)</h2>
<p>首先，我们来定义事件，RxSwift 中有三种类型的事件，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Event</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Event</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">Element</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Error</span>)</span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，我们来定义订阅者，在 <code>RxDemo-01</code> 中，我们先忽略
<strong>取消订阅</strong>
的功能，如下所示。订阅者必须遵循订阅者协议，需要实现
<strong>监听事件</strong> 的方法
<code>on(event: Event&lt;Element&gt;)</code>。订阅者内部维护一个处理事件的闭包
<code>_handler</code>。当监听事件方法触发时，会立即执行处理事件闭包。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Observer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ObserverType</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听事件</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">on</span>(<span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">ObserverType</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理事件的闭包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _handler: (<span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">handler</span>: <span class="keyword">@escaping</span> (<span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        _handler <span class="operator">=</span> handler</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 监听事件 的协议，内部处理事件</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">on</span>(<span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        _handler(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来定义发布者，如下所示。发布者必须遵循发布者协议，需要实现
<strong>订阅操作</strong> 的方法
<code>subscribe&lt;O: ObserverType&gt;(observer: O) where O.Element == Element</code>。发布者内部维护一个发布事件的闭包
<code>_eventGenerator</code>。当订阅发生时（订阅操作方法被执行时），会立即执行发布事件的闭包。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Observable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅操作</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 发布事件 的闭包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _eventGenerator: (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">eventGenerator</span>: <span class="keyword">@escaping</span> (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        _eventGenerator <span class="operator">=</span> eventGenerator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 订阅操作 的协议，内部发布事件</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="comment">// 生成事件</span></span><br><span class="line">        _eventGenerator(observer <span class="keyword">as!</span> <span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来试用一下 RxDemo-01 所实现的
RxSwift。很显然，这种模式与原始的 RxSwift 的使用方式基本吻合。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observable <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123; (observer) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 0&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 1&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 2&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 3&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">3</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send completed&quot;</span>)</span><br><span class="line">    observer.on(event: .completed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer <span class="operator">=</span> <span class="type">Observer</span>&lt;<span class="type">Int</span>&gt; &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable.subscribe(observer: observer)</span><br><span class="line"><span class="comment">// send 0</span></span><br><span class="line"><span class="comment">// recive 0</span></span><br><span class="line"><span class="comment">// send 1</span></span><br><span class="line"><span class="comment">// recive 1</span></span><br><span class="line"><span class="comment">// send 2</span></span><br><span class="line"><span class="comment">// recive 2</span></span><br><span class="line"><span class="comment">// send 3</span></span><br><span class="line"><span class="comment">// recive 3</span></span><br><span class="line"><span class="comment">// send completed</span></span><br><span class="line"><span class="comment">// recive completed</span></span><br></pre></td></tr></table></figure>
<p>下图所示为 RxDemo-01 实现的 RxSwift 的内部调用关系。通过闭包实现将
<code>observer</code> 传递给
<code>observable</code>，在发布事件时能够将事件传递给
<code>observer</code>，从而形成一条看似自左向右流动的数据流。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="取消订阅rxdemo-02">取消订阅(RxDemo-02)</h2>
<p>RxDemo-01 有一个明显的缺陷——无法取消订阅。我们来参考 RxSwift
的实现，它
<strong>并不是直接让订阅者支持取消订阅，而是通过一个第三方类型
<code>Disposable</code> 对订阅进行管理</strong>。<code>Disposable</code>
的核心作用是 <strong>提供一个状态位标识订阅是否已经取消</strong>。</p>
<p>关于由第三方类来管理订阅，而不是让订阅者自己管理的原因，我猜测有两个：一是出于职责单一的原则；二是为了支持函数式编程，抽取一个第三方类型作为返回值，从而在链式调用时保持类型一致。</p>
<p><code>Disposable</code> 协议要求所有的 <code>Disposable</code>
类型都实现 <code>dispose</code> 方法，表示取消订阅。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Disposable</span> &#123;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dispose</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义两个遵循 <code>Dispoable</code>
协议的类型：<code>AnonymousDisposable</code> 和
<code>CompositeDisposable</code>。</p>
<p><code>AnonymousDisposable</code> 作为一个匿名
<code>Disposable</code>，在本例中作为最底层的 <code>Disposable</code>
并没有什么作用，只是为了实现模式统一而已。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnonymousDisposable</span>: <span class="title class_">Disposable</span> &#123;</span><br><span class="line">    <span class="comment">// AnonymousDisposable 封装了 取消订阅 的闭包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _disposeHandler: () -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">disposeClosure</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        _disposeHandler <span class="operator">=</span> disposeClosure</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dispose</span>() &#123;</span><br><span class="line">        _disposeHandler()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CompositeDisposable</code> 作为一个可管理多个
<code>Disposable</code>
的容器，它内部维持一个标志位表示订阅是否被取消。<code>CompositeDisposable</code>
所实现的 <code>dispose</code> 方法真正改变了标志位，并对其所维护的所有
<code>Disposable</code> 执行各自的 <code>dispose</code>
方法，从而完成它们定义的在取消订阅时需要执行的附带操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompositeDisposable</span>: <span class="title class_">Disposable</span> &#123;</span><br><span class="line">    <span class="comment">// 可用于管理一组 Disposable 的 CompositeDisposable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已销毁（取消订阅）的标志位</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> isDisposed: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 管理一组 Disposable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> disposables: [<span class="type">Disposable</span>] <span class="operator">=</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">disposable</span>: <span class="type">Disposable</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> isDisposed &#123;</span><br><span class="line">            disposable.dispose()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        disposables.append(disposable)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dispose</span>() &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>isDisposed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 销毁所有 disposable，并设置标志位</span></span><br><span class="line">        disposables.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">        isDisposed <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，这里执行 <code>dispose</code>
操作只是修改了状态，并没有释放订阅资源。只有当
<code>CompositeDisposable</code> 对象被释放后才算真正释放资源。在原版
RxSwift 中，<code>DisposeBag</code> 差不多就是
<code>CompositeDisposable</code>。这样也是为什么我们要把订阅交给
<code>DisposeBag</code> 来进行管理，<code>DisposeBag</code>
作为某个对象的属性，会随着对象的释放，从而自动释放真正的订阅资源。</p>
<p>为了支持 <code>Disposable</code>，我们需要在 RxDemo-01
的基础上稍作修改即可，主要是修改发布者 <code>Observable</code> 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Observable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅操作</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 发布事件 的闭包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _eventGenerator: (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">eventGenerator</span>: <span class="keyword">@escaping</span> (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">        _eventGenerator <span class="operator">=</span> eventGenerator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 订阅操作 的协议，内部生成事件</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> composite <span class="operator">=</span> <span class="type">CompositeDisposable</span>()</span><br><span class="line">        <span class="comment">// 通过一个中间 Observer 对原始 Observer 进行封装，用于过滤事件的传递。</span></span><br><span class="line">        <span class="keyword">let</span> disposable <span class="operator">=</span> _eventGenerator(<span class="type">Observer</span> &#123; (event) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="operator">!</span>composite.isDisposed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="comment">// 事件传递给原始 observer</span></span><br><span class="line">            observer.on(event: event)</span><br><span class="line">            <span class="comment">// 通过 composite 管理 error、completed 时，自动取消订阅</span></span><br><span class="line">            <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> .error(<span class="keyword">_</span>), .completed:</span><br><span class="line">                composite.dispose()</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 将 _eventGenerator 返回的 AnonymousDisposable 加入至 CompositeDisposable 中进行管理</span></span><br><span class="line">        composite.add(disposable: disposable)</span><br><span class="line">        <span class="keyword">return</span> composite</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来试用一下 RxDemo-02 所实现的
RxSwift。很显然，这种模式与原始的 RxSwift
的使用方式进一步吻合。这里，我们实现了取消订阅的功能。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observable <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 0&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">0</span>))    <span class="comment">// observer.on(event: .next(0).map(&#123; $0 * 2 &#125;))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 1&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 2&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 3&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">3</span>))</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send completed&quot;</span>)</span><br><span class="line">        observer.on(event: .completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnonymousDisposable</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dispose&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer <span class="operator">=</span> <span class="type">Observer</span>&lt;<span class="type">Int</span>&gt; &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposable <span class="operator">=</span> observable.subscribe(observer: observer)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">2</span>) &#123;</span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send 0</span></span><br><span class="line"><span class="comment">// recive 0</span></span><br><span class="line"><span class="comment">// send 1</span></span><br><span class="line"><span class="comment">// recive 1</span></span><br><span class="line"><span class="comment">// send 2</span></span><br><span class="line"><span class="comment">// recive 2</span></span><br><span class="line"><span class="comment">// send 3</span></span><br><span class="line"><span class="comment">// recive 3</span></span><br><span class="line"><span class="comment">// dispose</span></span><br><span class="line"><span class="comment">// send completed</span></span><br></pre></td></tr></table></figure>
<p>RxDemo-02 的核心思想是在 RxDemo-01
的基础上对事件进行拦截和过滤，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-02.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的实现方式如下所示，通过 <code>CompositeDisposable</code> 管理
<code>AnonymousDisposable</code>（原始 <code>subscribe</code>
中的闭包执行后的返回类型）。同时，在执行发布事件时，使用一个中间
Observer 接收原始事件，中间 Observer 引用外部
<code>CompositeDisposable</code> 的状态决定是否将事件发送给原始
Observer。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-03.png?x-oss-process=image/resize,w_800" /></p>
<p>使用 <code>CompositeDisposable</code>
的本质就是添加了一个中间层来解决管理订阅的问题。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="结构优化rxdemo-03">结构优化(RxDemo-03)</h2>
<p>在 RxDemo-02 中，<code>AnonymousObserver</code> 引用了外部的
<code>CompositeDisposable</code>
中的订阅状态，从而决定事件的传递方向。这种代码逻辑由内而外实现，并不是很直观。</p>
<p>为了更加清晰地描述这个事件流动方向，RxDemo-03
通过增加一个中间层，将原始 observer、中间
observer、事件转发逻辑聚合在同一层级下，让代码具有更好的可读性。这里我们实现一个遵循
<code>Disposable</code> 协议的 <code>Sink</code> 类型。<code>Sink</code>
是 <strong>水槽</strong>
的意思，象征着这里我们通过它来控制事件的流动方向，暗示了这个类的作用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sink</span>&lt;<span class="title class_">O</span>: <span class="title class_">ObserverType</span>&gt;: <span class="title class_">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _disposed: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _forward: <span class="type">O</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _eventGenerator: (<span class="type">Observer</span>&lt;<span class="type">O</span>.<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _composite <span class="operator">=</span> <span class="type">CompositeDisposable</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">forward</span>: <span class="type">O</span>, <span class="params">eventGenerator</span>: <span class="keyword">@escaping</span> (<span class="type">Observer</span>&lt;<span class="type">O</span>.<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">        _forward <span class="operator">=</span> forward</span><br><span class="line">        _eventGenerator <span class="operator">=</span> eventGenerator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>() &#123;</span><br><span class="line">        <span class="comment">// 通过一个中间 Observer 接收原始事件</span></span><br><span class="line">        <span class="comment">// 根据 CompositionDisposable 的状态决定是否传递给原始 Observer</span></span><br><span class="line">        <span class="keyword">let</span> observer <span class="operator">=</span> <span class="type">Observer</span>&lt;<span class="type">O</span>.<span class="type">Element</span>&gt;(forward)</span><br><span class="line">        <span class="comment">// 执行事件生成器</span></span><br><span class="line">        <span class="comment">// 将返回值 Disposable 加入到 CompositeDisposable 中进行管理</span></span><br><span class="line">        _composite.add(disposable: _eventGenerator(observer))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">forward</span>(<span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">O</span>.<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>_disposed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 事件传递给原始 observer</span></span><br><span class="line">        _forward.on(event: event)</span><br><span class="line">        <span class="comment">// 通过 composite 管理 error、completed 时，自动取消订阅</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .completed, .error(<span class="keyword">_</span>):</span><br><span class="line">            dispose()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dispose</span>() &#123;</span><br><span class="line">        _disposed <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        _composite.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义了 <code>Sink</code> 之后，我们就可以简化
<code>Observable</code> 中 <code>subscribe</code> 方法的具体实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 发布事件 的闭包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _eventGenerator: (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">eventGenerator</span>: <span class="keyword">@escaping</span> (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">        _eventGenerator <span class="operator">=</span> eventGenerator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 订阅操作 的协议，内部生成事件</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sink <span class="operator">=</span> <span class="type">Sink</span>(forward: observer, eventGenerator: _eventGenerator)</span><br><span class="line">        sink.run()</span><br><span class="line">        <span class="keyword">return</span> sink</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SinkDisposable</code> 引用了原始的事件发生器，并定义一个中间
Observer 转入至原始事件发生器，从而让中间 observer
接收原始事件。除此之外，<code>SinkDisposable</code> 还引用了原始
observer，当中间 observer
处理原始事件时，会判断订阅是否已经取消，从而决定是否将原始事件转发给原始
observer。此时，RxDemo-03 实现的 RxSwift 的内部调用关系如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-04.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="操作符rxdemo-04">操作符(RxDemo-04)</h2>
<p>下面，我们来实现操作符，RxSwift
中包含了大量的操作符，它们基本上都是对函数式编程中
<strong>函子</strong>、<strong>单子</strong> 等进行了应用。我们以
<code>map</code> 为例进行介绍。</p>
<p>如下所示，<code>map</code> 方法能够将一个普通函数应用到包装类型
<code>ObservableType</code> 上。<code>map</code> 方法最终返回一个
<code>Observable&lt;Result&gt;</code> 类型（同样遵循
<code>ObservableType</code> 协议），因此能够完美支持链式操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">Result</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt; &#123; (observer) <span class="keyword">in</span>   <span class="comment">// observer 为原始 observer</span></span><br><span class="line">            <span class="comment">// 此闭包可看成是一个 eventGenerator</span></span><br><span class="line">            <span class="comment">// 向原始 observable 中传入一个中间 map observer，即由中间 map observer 替换原始 observer 监听原始事件</span></span><br><span class="line">            <span class="comment">// 中间 map observer 对原始事件进行转换后，转发给原始 observer</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.subscribe(observer: <span class="type">Observer</span> &#123; (event) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">switch</span> event &#123;</span><br><span class="line">                <span class="keyword">case</span> .next(<span class="keyword">let</span> element):</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> observer.on(event: .next(transform(element)))</span><br><span class="line">                    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                        observer.on(event: .error(error))</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                    observer.on(event: .error(error))</span><br><span class="line">                <span class="keyword">case</span> .completed:</span><br><span class="line">                    observer.on(event: .completed)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来试用一下 RxDemo-04 所实现的 RxSwift。这里，我们实现了
<code>map</code> 操作符的功能。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observable <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 0&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">0</span>))    <span class="comment">// observer.on(event: .next(0).map(&#123; $0 * 2 &#125;))</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 1&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 2&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 3&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">3</span>))</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send completed&quot;</span>)</span><br><span class="line">        observer.on(event: .completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnonymousDisposable</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dispose&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer <span class="operator">=</span> <span class="type">Observer</span>&lt;<span class="type">Int</span>&gt; &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposable <span class="operator">=</span> observable.map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125;.subscribe(observer: observer)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">2</span>) &#123;</span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send 0</span></span><br><span class="line"><span class="comment">// recive 0</span></span><br><span class="line"><span class="comment">// send 1</span></span><br><span class="line"><span class="comment">// recive 2</span></span><br><span class="line"><span class="comment">// send 2</span></span><br><span class="line"><span class="comment">// recive 4</span></span><br><span class="line"><span class="comment">// send 3</span></span><br><span class="line"><span class="comment">// recive 6</span></span><br><span class="line"><span class="comment">// dispose</span></span><br><span class="line"><span class="comment">// send completed</span></span><br></pre></td></tr></table></figure>
<p>RxDemo-04
中由于增加了操作符功能，其内部的调用关系也发生了变化。特别是，发布事件和过滤事件的逻辑，很显然，每增加一个操作符，就会增加一个
<code>SinkDisposable</code> 中间层，调用栈也会更深。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-05.png?x-oss-process=image/resize,w_800" /></p>
<p>如果我们仔细分析
RxDemo-04，其实我们可以发现内部隐藏了如下所示的调用关系链：observable
-&gt; MapObserver -&gt; MapObservable -&gt;
observer。实际执行时，调用关系如下所示：</p>
<ol type="1">
<li>observable 调用 MapObserver.on 方法，将原始事件传递给
MapObserver；</li>
<li>MapObserver 使用 map 方法将原始事件转换成 map 事件（即 map
后的数据），作为 MapObservable 发出的事件；</li>
<li>MapObservable 调用 observer.on 方法，将 map 事件传给 observer。</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-06.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="分类细化rxdemo-05">分类细化(RxDemo-05)</h2>
<p>在 RxDemo-04 中，为了增加 <code>map</code> 操作符，对
<code>ObservableType</code> 进行了扩展，其本质就是在原始的 Observable 和
Observer 之间插入了一个 MapObserver 和一个
MapObservable。本节，我们继续进行优化，对中间类也进行细分和定义。</p>
<p>在 RxDemo-04 中，<code>Sink</code> 的主要作用是
<strong>根据订阅是否取消决定是否拦截事件的传递</strong>。这里我们可能会想到：中间订阅者（如：MapObserver）本身是不是就应该具备
<code>Sink</code> 的这种功能呢？事实上，RxSwift 就是让 <code>Sink</code>
作为所有 Observer 的基类。</p>
<p>对于操作符，我们可以实现上述的模式；但是，对于不带操作符的情况，该如何处理呢？为了实现模式的统一，我们可以认为不带操作符的情况等同于带了
<strong>只返回原值的匿名操作符</strong>，即等同于
<code>map &#123; $0 &#125;</code>。针对此情况，我们也需要定义两个类
<code>AnonymousObserver</code> 和 <code>AnonymousObservable</code>。</p>
<p>下面，我们来进行优化改进。</p>
<p>首先，我们将原来的 <code>Observable&lt;Element&gt;</code>
改成抽象基类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">ObservableType</span> &#123;</span><br><span class="line"><span class="comment">//    // 定义 发布事件 的闭包，有子类来定义</span></span><br><span class="line"><span class="comment">//    private let _eventGenerator: (Observer&lt;Element&gt;) -&gt; Disposable</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    init(_ eventGenerator: @escaping (Observer&lt;Element&gt;) -&gt; Disposable) &#123;</span></span><br><span class="line"><span class="comment">//        _eventGenerator = eventGenerator</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 订阅操作 的协议，内部生成事件</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">rxAbstractMethod</span>(<span class="params">file</span>: <span class="type">StaticString</span> <span class="operator">=</span> <span class="keyword">#file</span>, <span class="params">line</span>: <span class="type">UInt</span> <span class="operator">=</span> <span class="keyword">#line</span>) -&gt; <span class="type">Swift</span>.<span class="type">Never</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;Abstract Method&quot;</span>, file: file, line: line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，我们再一定一个新的类 <code>Producer&lt;Element&gt;</code> 代替
<code>Observable&lt;Element&gt;</code>。<code>Producer&lt;Element&gt;</code>
继承自
<code>Observable&lt;Element&gt;</code>，作为发布者的基类，该类内部没有时间生成器
<code>eventGenerator</code> 的闭包，由子类选择性进行定义。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">Observable</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 实现 订阅操作 的协议，内部生成事件</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">subscribe</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> run(observer: observer)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们来对 <code>Sink</code> 进行修改。在 RxDemo-04
中，<code>Sink</code>
即提供了事件生成的功能和事件转发的功能。这里，我们让 <code>Sink</code>
的职责更加单一，仅仅是提供事件转发的功能。修改结果如下：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sink</span>&lt;<span class="title class_">O</span>: <span class="title class_">ObserverType</span>&gt;: <span class="title class_">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _disposed: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _forward: <span class="type">O</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _composite <span class="operator">=</span> <span class="type">CompositeDisposable</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">forward</span>: <span class="type">O</span>) &#123;</span><br><span class="line">        _forward <span class="operator">=</span> forward</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forward</span>(<span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">O</span>.<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>_disposed <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="comment">// 事件传递给原始 observer</span></span><br><span class="line">        _forward.on(event: event)</span><br><span class="line">        <span class="comment">// 通过 composite 管理 error、completed 时，自动取消订阅</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .completed, .error(<span class="keyword">_</span>):</span><br><span class="line">            dispose()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">dispose</span>() &#123;</span><br><span class="line">        _disposed <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dispose execute&quot;</span>)</span><br><span class="line">        _composite.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了便于泛型类型的转换，我们给 <code>ObservableType</code>
协议增加一个方法，并由 <code>Observable&lt;Element&gt;</code>
予以实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">asObservable</span>() -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">asObservable</span>() -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来分别实现 <code>Sink</code> 的子类
<code>AnonymousObserver</code> 和 <code>MapObserver</code> 以及
<code>Producer</code> 的子类 <code>AnonymousObservable</code> 和
<code>MapObservable</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnonymousObserver</span>&lt;<span class="title class_">O</span>: <span class="title class_">ObserverType</span>&gt;: <span class="title class_">Sink</span>&lt;<span class="title class_">O</span>&gt;, <span class="title class_">ObserverType</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">O</span>.<span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">forward</span>: <span class="type">O</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(forward: forward)    <span class="comment">// forward 为原始订阅者</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">on</span>(<span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// 对原始事件进行转发</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next(<span class="keyword">let</span> element):</span><br><span class="line">            <span class="keyword">self</span>.forward(event: .next(element))</span><br><span class="line">        <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">self</span>.forward(event: .error(error))</span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        <span class="keyword">case</span> .completed:</span><br><span class="line">            <span class="keyword">self</span>.forward(event: .completed)</span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">run</span>(<span class="params">parent</span>: <span class="type">AnonymousObservable</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="comment">// 执行事件生成器</span></span><br><span class="line">        parent._eventGenerator(<span class="type">Observer</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnonymousObservable</span>&lt;<span class="title class_">Element</span>&gt;: <span class="title class_">Producer</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有事件生成器闭包</span></span><br><span class="line">    <span class="keyword">let</span> _eventGenerator: (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">eventGenerator</span>: <span class="keyword">@escaping</span> (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._eventGenerator <span class="operator">=</span> eventGenerator</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">run</span>&lt;<span class="type">O</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Element</span> <span class="operator">==</span> <span class="type">O</span>.<span class="type">Element</span>, <span class="type">O</span> : <span class="type">ObserverType</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅发生时，生成一个中间订阅者 AnonymousObserver 来订阅原始事件，并将事件转发给原始订阅者</span></span><br><span class="line">        <span class="keyword">let</span> sink <span class="operator">=</span>  <span class="type">AnonymousObserver</span>(forward: observer)</span><br><span class="line">        sink.run(parent: <span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> sink</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapObserver</span>&lt;<span class="title class_">Source</span>, <span class="title class_">Result</span>, <span class="title class_">O</span>: <span class="title class_">ObserverType</span>&gt;: <span class="title class_">Sink</span>&lt;<span class="title class_">O</span>&gt;, <span class="title class_">ObserverType</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">Source</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Result</span> <span class="operator">=</span> <span class="type">O</span>.<span class="type">Element</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Transform</span> <span class="operator">=</span> (<span class="type">Source</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _transform: <span class="type">Transform</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">forward</span>: <span class="type">O</span>, <span class="params">transform</span>: <span class="keyword">@escaping</span> <span class="type">Transform</span>) &#123;  <span class="comment">// forward 为原始订阅者</span></span><br><span class="line">        <span class="keyword">self</span>._transform <span class="operator">=</span> transform</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(forward: forward)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">on</span>(<span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="comment">// 对原始事件进行 map 转换，对结果进行转发</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next(<span class="keyword">let</span> element):</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> mappedElement <span class="operator">=</span> <span class="keyword">try</span> _transform(element)</span><br><span class="line">                <span class="keyword">self</span>.forward(event: .next(mappedElement <span class="keyword">as!</span> <span class="type">O</span>.<span class="type">Element</span>))</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.forward(event: .error(error))</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">self</span>.forward(event: .error(error))</span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        <span class="keyword">case</span> .completed:</span><br><span class="line">            <span class="keyword">self</span>.forward(event: .completed)</span><br><span class="line">            <span class="keyword">self</span>.dispose()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MapObservable</span>&lt;<span class="title class_">Source</span>, <span class="title class_">Result</span>&gt;: <span class="title class_">Producer</span>&lt;<span class="title class_">Result</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Transform</span> <span class="operator">=</span> (<span class="type">Source</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _transform: <span class="type">Transform</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _source: <span class="type">Observable</span>&lt;<span class="type">Source</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">source</span>: <span class="type">Observable</span>&lt;<span class="type">Source</span>&gt;, <span class="params">transform</span>: <span class="keyword">@escaping</span> <span class="type">Transform</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._source <span class="operator">=</span> source</span><br><span class="line">        <span class="keyword">self</span>._transform <span class="operator">=</span> transform</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">run</span>&lt;<span class="type">O</span>: <span class="type">ObserverType</span>&gt;(<span class="params">observer</span>: <span class="type">O</span>) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Result</span> <span class="operator">==</span> <span class="type">O</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="comment">// 订阅发生时，生成一个中间订阅者 MapObserver 来订阅上游事件</span></span><br><span class="line">        <span class="keyword">let</span> sink <span class="operator">=</span> <span class="type">MapObserver</span>(forward: observer, transform: <span class="keyword">self</span>._transform)</span><br><span class="line">        <span class="keyword">self</span>._source.subscribe(observer: sink)</span><br><span class="line">        <span class="keyword">return</span> sink</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们再来看发布者、操作符，其实两者的本质都是一样，都是创建了一个发布者。对此，我们采用扩展的方式来提供相应的方法。如下所示：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">create</span>(<span class="keyword">_</span> <span class="params">eventGenerator</span>: <span class="keyword">@escaping</span> (<span class="type">Observer</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AnonymousObservable</span>(eventGenerator: eventGenerator)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ObservableType</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">Result</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span> (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MapObservable</span>(source: <span class="keyword">self</span>.asObservable(), transform: transform)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们再来验证一下实现结果，如下所示。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observable <span class="operator">=</span> <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span>  <span class="comment">// observer 为 MapObserver</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 0&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 1&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 2&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send 3&quot;</span>)</span><br><span class="line">    observer.on(event: .next(<span class="number">3</span>))</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;send completed&quot;</span>)</span><br><span class="line">        observer.on(event: .completed)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnonymousDisposable</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dispose&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer <span class="operator">=</span> <span class="type">Observer</span>&lt;<span class="type">Int</span>&gt; &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;recive completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> disposable <span class="operator">=</span> observable.map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">2</span> &#125;.map &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="number">1</span> &#125;.subscribe(observer: observer)</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">2</span>) &#123;</span><br><span class="line">    disposable.dispose()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send 0</span></span><br><span class="line"><span class="comment">// recive 1</span></span><br><span class="line"><span class="comment">// send 1</span></span><br><span class="line"><span class="comment">// recive 3</span></span><br><span class="line"><span class="comment">// send 2</span></span><br><span class="line"><span class="comment">// recive 5</span></span><br><span class="line"><span class="comment">// send 3</span></span><br><span class="line"><span class="comment">// recive 7</span></span><br><span class="line"><span class="comment">// dispose execute</span></span><br><span class="line"><span class="comment">// send completed</span></span><br></pre></td></tr></table></figure></p>
<p>从运行结果而言，RxDemo-05
基本实现了分类细化，并且达到了取消订阅的功能。此时，上述例子中实际的订阅关系如下所示。相比
RxDemo-04，多了 <code>AnonymousObserver</code> 和
<code>AnonymousObservable</code>，但是整体的内部订阅关系链更加清晰了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-07.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，我们再来对照一下 RxSwift 和 RxDemo-05
中类的定义，如下表所示。各个类的功能基本相同，整体结构也是大同小异，只是在类名上略有差异。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">RxDemo-05</th>
<th style="text-align: left;">Producer</th>
<th style="text-align: left;">Sink</th>
<th style="text-align: left;">AnonymousObserver</th>
<th style="text-align: left;">AnonymousObservable</th>
<th style="text-align: left;">MapObserver</th>
<th style="text-align: left;">MapObservable</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">RxSwift</td>
<td style="text-align: left;">Producer</td>
<td style="text-align: left;">Sink</td>
<td style="text-align: left;">AnonymousObservableSink</td>
<td style="text-align: left;">AnonymousObservable</td>
<td style="text-align: left;">Map</td>
<td style="text-align: left;">MapSink</td>
</tr>
</tbody>
</table>
<h2 id="订阅管理rxdemo-06">订阅管理(RxDemo-06)</h2>
<p>如果，我们仔细对比，可以发现 RxSwift 中 <code>Producer</code> 的
<code>subscribe</code> 方法内部与 RxDemo-05
还是不太一样，前者内部还引用了一个 <code>SinkDisposer</code>
类。其作用是什么呢？事实上，其主要作用是管理
<code>disposeHandler</code>。细心的同学可能会发现 RxDemo-05 中有个
BUG：取消订阅时没有执行 <code>print("dispose")</code> 闭包。</p>
<p>对此，我们也可以用类似的方式来解决，通过增加一个 <code>Diposer</code>
类来进行管理。具体代码见：RxDemo-06。</p>
<p>当订阅发生时（即执行 <code>subscribe</code>
方法时），内部会产生一个递归的控制流，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-08.png?x-oss-process=image/resize,w_800" /></p>
<p>通过递归返回的方式构建整个订阅管理关系链，如下图所示。<code>diposer0</code>
是 <code>subscribe</code> 方法最终返回的 <code>Disposable</code>
对象。当我们对 <code>disposer0</code> 执行 <code>dispose</code>
方法时，内部会递归地执行 <code>dispose</code>
方法，最终取消订阅链中所有的订阅。</p>
<p>注意：这里面会有循环引用，如 <code>MapObserver</code> 内部又引用了
<code>Disposer0</code>，RxDemo-06 以及 RxSwift 中的处理是给
<code>Disposer</code>
类内部添加一个状态，表示是否已经取消了订阅，从而避免循环引用导致的循环调用。这里的循环引用并不一定是坏事，它在下述的场景下起到了非常关键的作用。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rx-observer-pattern-stream-09.png?x-oss-process=image/resize,w_800" /></p>
<p>当事件中出现一个 <code>complete</code> 或 <code>error</code>
事件时，由于事件会依次传递至 <code>Observer</code>，最后一次传递时，即
<code>MapObserver</code> 进行传递时，会判断是否是 <code>complete</code>
或 <code>error</code> 事件，从而决定是否执行 <code>dispose</code>
方法。当 <code>MapObserver</code> 执行 <code>dipose</code>
方法时，会通过上述的循环引用，调用 <code>Disposer0</code> 执行
<code>dispose</code> 方法，从而实现整体取消订阅。</p>
<h1 id="总结">总结</h1>
<p>本文通过逐步实现 RxSwift
核心部分中的功能，一窥其背后的设计思路。从中我们也看到了其对函数式编程的应用，以及其所呈现出来的流编程模式的底层实现原理。</p>
<p>后续，我们将进一步探索原版 RxSwift 中其他的一些内容。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/ReactiveX/RxSwift">RxSwift repo</a></li>
<li><a href="http://reactivex.io/">ReactiveX</a></li>
<li><a
href="http://chuquan.me/2020/07/06/fp-functor-applicative-monad">函数式编程——Functor、Applicative、Monad</a></li>
<li>《计算机程序的构造与解释》</li>
<li><a
href="https://academy.realm.io/posts/try-swift-nyc-2017-krunoslav-zaher-modern-rxswift-architectures/">Modern
RxSwift Architectures</a></li>
<li><a
href="https://medium.com/@SergDort/learn-rx-by-implementing-observable-e5cb08c9c35">Learn
Rx by implementing Observable</a></li>
</ol>
]]></content>
      <categories>
        <category>Rx</category>
      </categories>
      <tags>
        <tag>RxSwift</tag>
        <tag>流编程</tag>
        <tag>函数式编程</tag>
        <tag>发布订阅</tag>
      </tags>
  </entry>
  <entry>
    <title>Sketch Cheat Sheet</title>
    <url>/2023/10/21/sketch-cheat-sheet/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/sketch-exercise01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>我的博客文章配图基本上都是使用 Sketch
绘制的，但是绘制方法仅限我的自我认知而已。由于没有系统性地学习过
Sketch，因此在遇到一些复杂场景时，绘制的效率非常低。于是最近业余时间在 B
站上学习了一套 Sketch 教程——<a
href="https://www.bilibili.com/video/BV1hd4y1z7pZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=247f8a5d677ea1cff0161b9afe62e41f">《Sketch
零基础速学教程（矢量绘图设计工具）》</a>。</p>
<p>这里记录一下教程中提到的快捷键技巧，便于后续参考。经过实测，这些技巧确实能够提升效率，文章封面图就是学完教程结合技巧绘制的图标。</p>
<h1 id="快捷键">快捷键</h1>
<h2 id="基础快捷键">基础快捷键</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">新建画板（New Artboard）</td>
<td style="text-align: left;">A</td>
</tr>
<tr class="even">
<td style="text-align: left;">插入矩形（Rectangle）</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="odd">
<td style="text-align: left;">插入原型（Oval）</td>
<td style="text-align: left;">O</td>
</tr>
<tr class="even">
<td style="text-align: left;">插入文本（Text）</td>
<td style="text-align: left;">T</td>
</tr>
<tr class="odd">
<td style="text-align: left;">钢笔工具（Vector Point）</td>
<td style="text-align: left;">V</td>
</tr>
<tr class="even">
<td style="text-align: left;">放大（Zoom</td>
<td style="text-align: left;">按住 Z，然后框选想放大的区域</td>
</tr>
<tr class="odd">
<td style="text-align: left;">查看间距（Guides）</td>
<td style="text-align: left;">Alt（选中一个图层，按住
Alt，鼠标移动移动到另一个图层，可查看选中图层到指向图层的间距）</td>
</tr>
<tr class="even">
<td style="text-align: left;">创建分组（Group）</td>
<td style="text-align: left;">⌘ G</td>
</tr>
<tr class="odd">
<td style="text-align: left;">取消分组（Ungroup）</td>
<td style="text-align: left;">⌘ ⇧ G</td>
</tr>
<tr class="even">
<td style="text-align: left;">复制上一步操作（Duplicate</td>
<td style="text-align: left;">⌘ D</td>
</tr>
<tr class="odd">
<td style="text-align: left;">编辑（Edit）</td>
<td style="text-align: left;">Enter</td>
</tr>
</tbody>
</table>
<h2 id="吸管工具">吸管工具</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">吸取颜色（Color Picker）</td>
<td style="text-align: left;">⌃ C</td>
</tr>
</tbody>
</table>
<h2 id="复制样式">复制样式</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">复制图层样式（Copy Style）</td>
<td style="text-align: left;">⌘ ⌥ C</td>
</tr>
<tr class="even">
<td style="text-align: left;">粘贴图层样式（Paste Style）</td>
<td style="text-align: left;">⌘ ⌥ V</td>
</tr>
</tbody>
</table>
<h2 id="视图模式">视图模式</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">演示模式（Presentation Mode）</td>
<td style="text-align: left;">⌘ .</td>
</tr>
<tr class="even">
<td style="text-align: left;">以画布为中心放大（Center Canvas）</td>
<td style="text-align: left;">⌘ 1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">以选择的图层为中心放大（Zoom
Selection）</td>
<td style="text-align: left;">⌘ 2</td>
</tr>
<tr class="even">
<td style="text-align: left;">视图放大</td>
<td style="text-align: left;">⌘ +</td>
</tr>
<tr class="odd">
<td style="text-align: left;">视图缩小</td>
<td style="text-align: left;">⌘ -</td>
</tr>
<tr class="even">
<td style="text-align: left;">恢复到画布实际大小</td>
<td style="text-align: left;">⌘ 0</td>
</tr>
</tbody>
</table>
<h2 id="图层">图层</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">在图层面板从上往下选择图层（Selecting
Layer Below）</td>
<td style="text-align: left;">tab</td>
</tr>
<tr class="even">
<td style="text-align: left;">在图层面板从下往上选择图层（Selecting
Layer Below）</td>
<td style="text-align: left;">⇧ tab</td>
</tr>
<tr class="odd">
<td style="text-align: left;">上移图层（Bring Forward）</td>
<td style="text-align: left;">⌘ ]</td>
</tr>
<tr class="even">
<td style="text-align: left;">下移图层（Bring Backward）</td>
<td style="text-align: left;">⌘ [</td>
</tr>
<tr class="odd">
<td style="text-align: left;">置顶图层（Bring to Front）</td>
<td style="text-align: left;">⌘ ⌥ ]</td>
</tr>
<tr class="even">
<td style="text-align: left;">置底图层（Bring to End）</td>
<td style="text-align: left;">⌘ ⌥ [</td>
</tr>
</tbody>
</table>
<h2 id="相关补充">相关补充</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">隐藏图层</td>
<td style="text-align: left;">⌘ ⇧ H</td>
</tr>
<tr class="even">
<td style="text-align: left;">锁定图层</td>
<td style="text-align: left;">⌘ ⇧ L</td>
</tr>
<tr class="odd">
<td style="text-align: left;">查找图层</td>
<td style="text-align: left;">⌘ F</td>
</tr>
<tr class="even">
<td style="text-align: left;">变换工具</td>
<td style="text-align: left;">⌘ ⇧ T</td>
</tr>
<tr class="odd">
<td style="text-align: left;">旋转工具</td>
<td style="text-align: left;">⌘ ⇧ R</td>
</tr>
<tr class="even">
<td style="text-align: left;">将字体转换成轮廓</td>
<td style="text-align: left;">⌘ ⌥ O</td>
</tr>
<tr class="odd">
<td style="text-align: left;">显示/取消填充</td>
<td style="text-align: left;">F</td>
</tr>
<tr class="even">
<td style="text-align: left;">显示/取消描边</td>
<td style="text-align: left;">B</td>
</tr>
<tr class="odd">
<td style="text-align: left;">将当前图层用作蒙版</td>
<td style="text-align: left;">⌘ ⌃ M</td>
</tr>
<tr class="even">
<td style="text-align: left;">改变形状尺寸</td>
<td style="text-align: left;">⌘ 键盘上/下/左/右</td>
</tr>
<tr class="odd">
<td style="text-align: left;">切换不同的 Sketch 文件</td>
<td style="text-align: left;">⌘ ~</td>
</tr>
</tbody>
</table>
<h2 id="设置">设置</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">打开设置</td>
<td style="text-align: left;">⌘ ,</td>
</tr>
</tbody>
</table>
<h1 id="屏幕分辨率尺寸">屏幕分辨率尺寸</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">设备</th>
<th style="text-align: left;">屏幕尺寸</th>
<th style="text-align: left;">屏幕分辨率（px）</th>
<th style="text-align: left;">逻辑分辨率（pt）</th>
<th style="text-align: left;">PPI</th>
<th style="text-align: left;">倍率</th>
<th style="text-align: left;">换算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">iPhone14</td>
<td style="text-align: left;">6.1寸</td>
<td style="text-align: left;">1170x2532</td>
<td style="text-align: left;">390x844</td>
<td style="text-align: left;">460</td>
<td style="text-align: left;"><span class="citation"
data-cites="3x">@3x</span></td>
<td style="text-align: left;">1pt=3px</td>
</tr>
<tr class="even">
<td style="text-align: left;">iPhone12 Pro Max</td>
<td style="text-align: left;">6.7寸</td>
<td style="text-align: left;">1284x2778</td>
<td style="text-align: left;">428x926</td>
<td style="text-align: left;">458</td>
<td style="text-align: left;"><span class="citation"
data-cites="3x">@3x</span></td>
<td style="text-align: left;">1pt=3px</td>
</tr>
<tr class="odd">
<td style="text-align: left;">iPhone12 Pro</td>
<td style="text-align: left;">6.1寸</td>
<td style="text-align: left;">1170x2532</td>
<td style="text-align: left;">390x844</td>
<td style="text-align: left;">460</td>
<td style="text-align: left;"><span class="citation"
data-cites="3x">@3x</span></td>
<td style="text-align: left;">1pt=3px</td>
</tr>
<tr class="even">
<td style="text-align: left;">iPhone11 Pro Max</td>
<td style="text-align: left;">6.5寸</td>
<td style="text-align: left;">1242x2688</td>
<td style="text-align: left;">414x896</td>
<td style="text-align: left;">458</td>
<td style="text-align: left;"><span class="citation"
data-cites="3x">@3x</span></td>
<td style="text-align: left;">1pt=3px</td>
</tr>
<tr class="odd">
<td style="text-align: left;">iPhone11 Pro</td>
<td style="text-align: left;">6.1寸</td>
<td style="text-align: left;">1125x2436</td>
<td style="text-align: left;">375x812</td>
<td style="text-align: left;">458</td>
<td style="text-align: left;"><span class="citation"
data-cites="3x">@3x</span></td>
<td style="text-align: left;">1pt=3px</td>
</tr>
<tr class="even">
<td style="text-align: left;">iPhone11</td>
<td style="text-align: left;">5.8寸</td>
<td style="text-align: left;">828x1792</td>
<td style="text-align: left;">414x896</td>
<td style="text-align: left;">326</td>
<td style="text-align: left;"><span class="citation"
data-cites="2x">@2x</span></td>
<td style="text-align: left;">1pt=2px</td>
</tr>
<tr class="odd">
<td style="text-align: left;">iPhone8 Plus</td>
<td style="text-align: left;">5.5寸</td>
<td style="text-align: left;">1242x2208</td>
<td style="text-align: left;">414x736</td>
<td style="text-align: left;">401</td>
<td style="text-align: left;"><span class="citation"
data-cites="3x">@3x</span></td>
<td style="text-align: left;">1pt=3px</td>
</tr>
<tr class="even">
<td style="text-align: left;">iPhone8</td>
<td style="text-align: left;">4.7寸</td>
<td style="text-align: left;">750x1334</td>
<td style="text-align: left;">375x667</td>
<td style="text-align: left;">326</td>
<td style="text-align: left;"><span class="citation"
data-cites="2x">@2x</span></td>
<td style="text-align: left;">1pt=2px</td>
</tr>
<tr class="odd">
<td style="text-align: left;">iPhoneSE</td>
<td style="text-align: left;">4.0寸</td>
<td style="text-align: left;">640x1136</td>
<td style="text-align: left;">320x568</td>
<td style="text-align: left;">326</td>
<td style="text-align: left;"><span class="citation"
data-cites="2x">@2x</span></td>
<td style="text-align: left;">1pt=2px</td>
</tr>
<tr class="even">
<td style="text-align: left;">iPhone3GS</td>
<td style="text-align: left;">3.5寸</td>
<td style="text-align: left;">320x480</td>
<td style="text-align: left;">320x480</td>
<td style="text-align: left;">163</td>
<td style="text-align: left;"><span class="citation"
data-cites="1x">@1x</span></td>
<td style="text-align: left;">1pt=1px</td>
</tr>
</tbody>
</table>
<p>UI 设计一般以 390x844 或 375x812 为尺寸进行绘制。</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>Sketch</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods Source 管理机制</title>
    <url>/2022/01/07/source-analyze-principle/</url>
    <content><![CDATA[<p>CocoaPods-Core 主要包括三部分功能，分别是：Podfile 解析、Podspec
解析、Source
管理，前两个功能我们在之前的文章中已经分别进行了介绍，本文我们再来介绍一下最后一个功能——CocoaPods
Source 管理机制。</p>
<span id="more"></span>
<h1 id="基本原理">基本原理</h1>
<p>Source，即 podspec 源。Source 管理机制，本质上就是对 podspec
进行管理。CocoaPods 采用 <strong>集中式</strong>
的源管理方案，其基本原理 <strong>使用一个源仓库管理所有 pod
所发布的不同版本的 podspec 文件，每一个 podspec 记录了 pod
库的资源地址以及其他相关信息</strong>。</p>
<p>CocoaPods 在集中式管理的基础上，实现了两套具体方案：master 和
trunk。其中，master 是 CocoaPods 1.8.0 之前版本所采用的默认方案；trunk
是 CocoaPods 1.8.0 以之后版本所采用的的默认方案。</p>
<p>默认，CocoaPods 会把源仓库拷贝或克隆到本地用户根目录下的
<code>~/.cocoapods/repos/</code>。在 <code>~/.cocoapods/repos/</code>
目录下，其实我们可能看到两套方案各自对应一个目录：<code>master</code>、<code>trunk</code>，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> ~/.cocoapods/repos</span></span><br><span class="line">Spec_Lock            master               trunk</span><br></pre></td></tr></table></figure>
<p>下面，我们对这两种方案分别进行介绍。</p>
<h2 id="master">Master</h2>
<p>对于 master 方案，其源仓库（下文简称 master
repo）的组织结构如下图所示。其具体方案是：</p>
<ul>
<li>根据 pod 的名称计算得到 MD5 值。如：md5("AFNetworking") =&gt;
a75d452377f3996bdc4b623a5df25820</li>
<li>获取 MD5 值的前 N 位，默认是 3 位。如：a75</li>
<li>对前 N
位值进行拆解，每一位对应一个目录，构成一个多级目录。如：<code>a/7/5</code></li>
<li>将 pod 及其各个版本的 podspec 文件存放在对应的目录下。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-source-01.png?x-oss-process=image/resize,w_800" /></p>
<p>那么问题来了，为什么要使用一个多级目录结构存储 podspec 呢？</p>
<p>其实，在 2016 年 master repo
仓库下的所有文件都在同级目录，对目录进行分级是为了解决 <a
href="https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935">Github
下载慢</a> 的问题。</p>
<p>那么问题又来了，为什么对目录进行分级能加速 github 下载呢？</p>
<p>本质上，这与 git 的底层原理有关。在 git
对象模型中，对于目录的每次更改都会生成一个新的树对象，许多 git
操作需要遍历这棵树，内部必须通过多步增量重新创建，每一步都必须找到并解压缩。当一个目录下存在非常多的子目录的情况下，一个变更操作会生成非常大的树对象。因此，采用多级目录结构可以降低
git 对象模型的大小，从而降低 git 仓库大小，提升下载速度。</p>
<h2 id="trunk">Trunk</h2>
<p>尽管 master repo 采用多级目录的方式优化了仓库的大小，但是架不住 pod
库以及版本迭代实在太多了。于是，CocoaPods 1.7.0 支持了 CDN。</p>
<p>CDN 的基本思路是：在网络各处放置节点服务器，构成一个虚拟网络，CDN
系统能够实时地根据网络流量和各节点的连接、负载状况、响应时间等综合信息，将用户请求转发到里用户最近的服务节点，从而在网络链路上进行加速。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/cdn-principle.gif?x-oss-process=image/resize,w_800" /></p>
<p>然而，CDN 并没有解决本质问题，master repo
这种全量下载的方式其实是有很大的优化空间的。于是，CocoaPods 1.8.0
支持了按需下载的方式，即 trunk 方案。</p>
<p>对于 trunk 方案，其源仓库（下文简称 trunk
repo）的组织结构如下图所示。其具体方案是：</p>
<ul>
<li>使用 <code>.txt</code> 文件记录一系列 pod 名称及其所有版本号。</li>
<li>同一 <code>.txt</code> 文件所记录的所有 pod 的名称的 MD5 值前 N
位相同，同时 <code>.txt</code> 文件以此 N 位 MD5
值作为文件名称的标识元素。如：<code>all_pods_version_a_7_5.txt</code>。</li>
<li>当请求某个 pod 的 podspec 文件时，根据 pod 名称计算得到
<code>.txt</code> 文件名称。如：AFNetworking -&gt;
<code>all_pods_version_a_7_5.txt</code>。</li>
<li>使用对应的 <code>.etag</code> 文件（如果没有则不使用）请求对应的
<code>.txt</code> 文件。<code>.etag</code>
文件用于表示文件是否更新。如果远端文件未更新，则使用本地已下载的
<code>.txt</code> 文件，如果远端文件已更新，则下载最新的
<code>.txt</code> 文件。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-source-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="整体架构">整体架构</h1>
<p>下图所示为 source
管理机制的整体架构类图，主要有以下几个核心部分组成：</p>
<ul>
<li><code>Manager</code>：source 的管理类，作为 source
管理机制的代理，外部操作由 Manager 类提供接口并进行转发。</li>
<li><code>Aggregate</code>：source 的聚合类，管理所有 source，承接
Manager 类接口转发，并转发至各个 source，对外隐藏了内部查找逻辑。</li>
<li><code>Source</code>：描述一个 podspec 源，master repo、trunk repo
各自对应一个 Source 实例。</li>
<li><code>Metadata</code>：描述一个源的元信息。</li>
<li><code>Specification</code>：描述一个 podspec 文件。</li>
<li><code>Dependency</code>：描述一个 pod 的一个依赖，如：podsepc
文件中定义的 <code>dependency</code>。</li>
<li><code>Set</code>：描述一个 pod
所对应的源信息，主要用于描述查询结果。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-source-04.png" /></p>
<h2 id="manager">Manager</h2>
<p>如下所示，为 <code>Source::Manager</code>
类核心部分的定义，<code>Manager</code> 使用 repos
目录作为初始化参数，默认是 <code>~/.cocoapods/repos</code>。
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># source/manager.rb</span></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Source</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Manager</span></span><br><span class="line">      <span class="comment"># 包含多个 repo 的目录</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:repos_dir</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">repos_dir</span>)</span><br><span class="line">        <span class="variable">@repos_dir</span> = <span class="title class_">Pathname</span>(repos_dir).expand_path</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># source repos 的聚合</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">aggregate</span></span><br><span class="line">        aggregate_with_repos(source_repos)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># source repos 的聚合</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">aggregate_with_repos</span>(<span class="params">repos</span>)</span><br><span class="line">        sources = repos.map &#123; |<span class="params">path</span>| source_from_path(path) &#125;</span><br><span class="line">        <span class="variable">@aggregates_by_repos</span> |<span class="params"></span>|= &#123;&#125;</span><br><span class="line">        <span class="variable">@aggregates_by_repos</span>[repos] |<span class="params"></span>|= <span class="title class_">Source::Aggregate</span>.new(sources)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 给定名称，返回对应的源</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">source_with_name</span>(<span class="params">name</span>)</span><br><span class="line">        source = sources([name]).first</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">unless</span> source.repo.exist?</span><br><span class="line">        source</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 给定路径，返回对应的源</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">source_from_path</span>(<span class="params">path</span>)</span><br><span class="line">        <span class="variable">@sources_by_path</span> |<span class="params"></span>|= <span class="title class_">Hash</span>.new <span class="keyword">do</span> |<span class="params">hash, key</span>|</span><br><span class="line">          hash[key] = <span class="keyword">case</span></span><br><span class="line">                      <span class="keyword">when</span> key.basename.to_s == <span class="title class_">Pod</span><span class="symbol">:</span><span class="symbol">:TrunkSource</span><span class="symbol">:</span><span class="symbol">:TRUNK_REPO_NAME</span></span><br><span class="line">                        <span class="title class_">TrunkSource</span>.new(key)</span><br><span class="line">                      <span class="keyword">when</span> (key + <span class="string">&#x27;.url&#x27;</span>).exist?</span><br><span class="line">                        <span class="title class_">CDNSource</span>.new(key)</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        <span class="title class_">Source</span>.new(key)</span><br><span class="line">                      <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="variable">@sources_by_path</span>[path]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 返回所有源的路径</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">source_repos</span></span><br><span class="line">        <span class="keyword">return</span> [] <span class="keyword">unless</span> repos_dir.exist?</span><br><span class="line">        repos_dir.children.select(&amp;<span class="symbol">:directory?</span>).sort_by &#123; |<span class="params">d</span>| d.basename.to_s.downcase &#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 给定一组名称，返回对应的一组源</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">sources</span>(<span class="params">names</span>)</span><br><span class="line">        dirs = names.map &#123; |<span class="params">name</span>| source_dir(name) &#125;</span><br><span class="line">        dirs.map &#123; |<span class="params">repo</span>| source_from_path(repo) &#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 返回所有的源</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">all</span></span><br><span class="line">        aggregate.sources</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>Manager</code> 负责初始化 <code>~/.cocoapods/repos</code>
目录下所有的 source，并将它们聚合至 <code>Aggregate</code>
中，具体步骤包括以下几个关键步骤：</p>
<ul>
<li>执行 <code>source_repos</code> 方法，获取所有 source 路径</li>
<li>执行 <code>source_from_path</code> 方法，根据 source 路径初始化
<code>Source</code> 对象。
<ul>
<li>如果路径节点目录的名称为 <code>trunk</code>，则实例化
<code>TrunkSource</code> 对象。</li>
<li>如果名为 <code>.url</code> 文件，则实例化 <code>CDNSource</code>
对象。</li>
<li>其他情况则实例化 <code>Source</code> 对象。</li>
</ul></li>
<li>聚合所有 source 对象，实例化 <code>Aggregate</code> 对象。</li>
</ul>
<h2 id="aggregate">Aggregate</h2>
<p><code>Manager</code> 实现了初始化 <code>Aggregate</code>
相关方法，除此之外，<code>Manager</code>
提供了一系列查询方法，这些方法最终会转发至 <code>Aggregate</code>。</p>
<p>如下所示，为 <code>Aggregate</code>
类核心部分的定义，其提供了一系列查询方法，实现 <code>Manager</code>
转发过来的查询方法，如：<code>search(dependency)</code> 方法。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Source</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Aggregate</span></span><br><span class="line">      <span class="comment"># Aggregate 聚合的所有 source</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:sources</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">sources</span>)</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">&quot;Cannot initialize an aggregate with a nil source: (<span class="subst">#&#123;sources&#125;</span>)&quot;</span> <span class="keyword">if</span> sources.<span class="keyword">include</span>?(<span class="literal">nil</span>)</span><br><span class="line">        <span class="variable">@sources</span> = sources</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 查找依赖</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">dependency</span>)</span><br><span class="line">        found_sources = sources.select &#123; |<span class="params">s</span>| s.search(dependency) &#125;</span><br><span class="line">        <span class="keyword">unless</span> found_sources.empty?</span><br><span class="line">          <span class="title class_">Specification::Set</span>.new(dependency.root_name, found_sources)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="source">Source</h2>
<p><code>Source</code> 用于描述一个 podspec 源，其负责管理其包含的所有
podspec 文件。其核心定义如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Source</span></span><br><span class="line">    <span class="comment"># source 所对应的元信息</span></span><br><span class="line">    <span class="built_in">attr_reader</span> <span class="symbol">:metadata</span></span><br><span class="line">    <span class="comment"># source 所对应的 repo 路径</span></span><br><span class="line">    <span class="built_in">attr_reader</span> <span class="symbol">:repo</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Source</code> 类还提供了一系列方法以供查询 podspec，这些方法是
<code>Manager</code>
所提供的查询方法的最终实现，具体的方法实现不在详细介绍，有兴趣可以去阅读源码。</p>
<h3 id="cdnsource">CDNSource</h3>
<p><code>CDNSource</code> 是 <code>Source</code>
的子类，其提供了一种按需加载的策略，该策略的核心逻辑由
<code>download_and_save_with_retries_async</code>
方法实现，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CDNSource</span> &lt; <span class="title class_ inherited__">Source</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download_and_save_with_retries_async</span>(<span class="params">partial_url, file_remote_url, etag, retries = <span class="variable constant_">MAX_NUMBER_OF_RETRIES</span></span>)</span><br><span class="line">      <span class="comment"># 获取 txt 文件</span></span><br><span class="line">      path = repo + partial_url</span><br><span class="line">      <span class="comment"># 获取 etag 文件路径</span></span><br><span class="line">      etag_path = path.sub_ext(path.extname + <span class="string">&#x27;.etag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      download_task = download_typhoeus_impl_async(file_remote_url, etag).<span class="keyword">then</span> <span class="keyword">do</span> |<span class="params">response</span>|</span><br><span class="line">        <span class="keyword">case</span> response.response_code</span><br><span class="line">        <span class="keyword">when</span> <span class="number">301</span>, <span class="number">302</span></span><br><span class="line">          <span class="comment"># 使用 CDN 分发的重定向位置，重新请求</span></span><br><span class="line">          redirect_location = response.headers[<span class="string">&#x27;location&#x27;</span>]</span><br><span class="line">          debug <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> Redirecting from <span class="subst">#&#123;file_remote_url&#125;</span> to <span class="subst">#&#123;redirect_location&#125;</span>&quot;</span></span><br><span class="line">          download_and_save_with_retries_async(partial_url, redirect_location, etag)</span><br><span class="line">        <span class="keyword">when</span> <span class="number">304</span></span><br><span class="line">          <span class="comment"># 根据 etag 判断远端 txt 文件未修改，则使用本地文件</span></span><br><span class="line">          debug <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> Relative path not modified: <span class="subst">#&#123;partial_url&#125;</span>&quot;</span></span><br><span class="line">          <span class="comment"># We need to update the file modification date, as it is later used for freshness</span></span><br><span class="line">          <span class="comment"># optimization. See #initialize for more information.</span></span><br><span class="line">          <span class="title class_">FileUtils</span>.touch path</span><br><span class="line">          partial_url</span><br><span class="line">        <span class="keyword">when</span> <span class="number">200</span></span><br><span class="line">          <span class="comment"># 获取远端最新 txt 文件，并更新 etag 文件内容</span></span><br><span class="line">          <span class="title class_">File</span>.open(path, <span class="string">&#x27;w&#x27;</span>) &#123; |<span class="params">f</span>| f.write(response.response_body.force_encoding(<span class="string">&#x27;UTF-8&#x27;</span>)) &#125;</span><br><span class="line"></span><br><span class="line">          etag_new = response.headers[<span class="string">&#x27;etag&#x27;</span>] <span class="keyword">unless</span> response.headers.<span class="literal">nil</span>?</span><br><span class="line">          debug <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> Relative path downloaded: <span class="subst">#&#123;partial_url&#125;</span>, save ETag: <span class="subst">#&#123;etag_new&#125;</span>&quot;</span></span><br><span class="line">          <span class="title class_">File</span>.open(etag_path, <span class="string">&#x27;w&#x27;</span>) &#123; |<span class="params">f</span>| f.write(etag_new) &#125; <span class="keyword">unless</span> etag_new.<span class="literal">nil</span>?</span><br><span class="line">          partial_url</span><br><span class="line">        <span class="keyword">when</span> <span class="number">404</span></span><br><span class="line">          debug <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> Relative path couldn&#x27;t be downloaded: <span class="subst">#&#123;partial_url&#125;</span> Response: <span class="subst">#&#123;response.response_code&#125;</span>&quot;</span></span><br><span class="line">          <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">when</span> <span class="number">502</span>, <span class="number">503</span>, <span class="number">504</span></span><br><span class="line">          <span class="comment">#服务器出错，重试</span></span><br><span class="line">          <span class="keyword">if</span> retries &lt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> URL couldn&#x27;t be downloaded: <span class="subst">#&#123;file_remote_url&#125;</span> Response: <span class="subst">#&#123;response.response_code&#125;</span> <span class="subst">#&#123;response.response_body&#125;</span>&quot;</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            debug <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> URL couldn&#x27;t be downloaded: <span class="subst">#&#123;file_remote_url&#125;</span> Response: <span class="subst">#&#123;response.response_code&#125;</span> <span class="subst">#&#123;response.response_body&#125;</span>, retries: <span class="subst">#&#123;retries - <span class="number">1</span>&#125;</span>&quot;</span></span><br><span class="line">            exponential_backoff_async(retries).<span class="keyword">then</span> <span class="keyword">do</span></span><br><span class="line">              download_and_save_with_retries_async(partial_url, file_remote_url, etag, retries - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">when</span> <span class="number">0</span></span><br><span class="line">          <span class="comment"># 网络层错误，重试</span></span><br><span class="line">          <span class="keyword">if</span> retries &lt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> URL couldn&#x27;t be downloaded: <span class="subst">#&#123;file_remote_url&#125;</span> Response: <span class="subst">#&#123;response.return_message&#125;</span>&quot;</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            debug <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> URL couldn&#x27;t be downloaded: <span class="subst">#&#123;file_remote_url&#125;</span> Response: <span class="subst">#&#123;response.return_message&#125;</span>, retries: <span class="subst">#&#123;retries - <span class="number">1</span>&#125;</span>&quot;</span></span><br><span class="line">            exponential_backoff_async(retries).<span class="keyword">then</span> <span class="keyword">do</span></span><br><span class="line">              download_and_save_with_retries_async(partial_url, file_remote_url, etag, retries - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">raise</span> <span class="title class_">Informative</span>, <span class="string">&quot;CDN: <span class="subst">#&#123;name&#125;</span> URL couldn&#x27;t be downloaded: <span class="subst">#&#123;file_remote_url&#125;</span> Response: <span class="subst">#&#123;response.response_code&#125;</span> <span class="subst">#&#123;response.response_body&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="trunksource">TrunkSource</h3>
<p><code>TrunkSource</code> 是 <code>CDNSource</code>
的子类，其实现非常简单，仅仅是重写了 trunk repo
的远端地址，具体如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">TrunkSource</span> &lt; <span class="title class_ inherited__">CDNSource</span></span><br><span class="line">    <span class="comment"># On-disk master repo name</span></span><br><span class="line">    <span class="variable constant_">TRUNK_REPO_NAME</span> = <span class="string">&#x27;trunk&#x27;</span>.freeze</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remote CDN repo URL</span></span><br><span class="line">    <span class="variable constant_">TRUNK_REPO_URL</span> = <span class="string">&#x27;https://cdn.cocoapods.org/&#x27;</span>.freeze</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">url</span></span><br><span class="line">      <span class="variable">@url</span> |<span class="params"></span>|= <span class="variable constant_">TRUNK_REPO_URL</span></span><br><span class="line">      <span class="variable language_">super</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="metadata">Metadata</h2>
<p><code>Metadata</code> 使用一个 <code>CocoaPods-version.yml</code>
文件记录 source 的元信息，并保存在source repo 的根目录下。CocoaPods
通过该文件实例化一个 <code>Metadata</code> 对象，如下所示为
<code>Metadata</code> 类的核心部分定义。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Source</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Metadata</span></span><br><span class="line">      <span class="comment"># 最低可支持的 CocoaPods 版本，对应 `min` 字段</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:minimum_cocoapods_version</span></span><br><span class="line">      <span class="comment"># 最高可支持的 CocoaPods 版本，对应 `max` 字段</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:maximum_cocoapods_version</span></span><br><span class="line">      <span class="comment"># 最新 CocoaPods 版本，对应 `last` 字段</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:latest_cocoapods_version</span></span><br><span class="line">      <span class="comment"># 定义 pod name hash 前缀的长度和数量</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:prefix_lengths</span></span><br><span class="line">      <span class="comment"># 可兼容的 CocoaPods 最新版本</span></span><br><span class="line">      <span class="built_in">attr_reader</span> <span class="symbol">:last_compatible_versions</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">hash = &#123;&#125;</span>)</span><br><span class="line">        hash = hash.with_indifferent_access</span><br><span class="line">        <span class="variable">@minimum_cocoapods_version</span> = hash[<span class="string">&#x27;min&#x27;</span>]</span><br><span class="line">        <span class="variable">@minimum_cocoapods_version</span> &amp;&amp;= <span class="title class_">Pod::Version</span>.new(<span class="variable">@minimum_cocoapods_version</span>)</span><br><span class="line">        <span class="variable">@maximum_cocoapods_version</span> = hash[<span class="string">&#x27;max&#x27;</span>]</span><br><span class="line">        <span class="variable">@maximum_cocoapods_version</span> &amp;&amp;= <span class="title class_">Pod::Version</span>.new(<span class="variable">@maximum_cocoapods_version</span>)</span><br><span class="line">        <span class="variable">@latest_cocoapods_version</span> = hash[<span class="string">&#x27;last&#x27;</span>]</span><br><span class="line">        <span class="variable">@latest_cocoapods_version</span> &amp;&amp;= <span class="title class_">Pod::Version</span>.new(<span class="variable">@latest_cocoapods_version</span>)</span><br><span class="line">        <span class="variable">@prefix_lengths</span> = <span class="title class_">Array</span>(hash[<span class="string">&#x27;prefix_lengths&#x27;</span>]).map!(&amp;<span class="symbol">:to_i</span>)</span><br><span class="line">        <span class="variable">@last_compatible_versions</span> = <span class="title class_">Array</span>(hash[<span class="string">&#x27;last_compatible_versions&#x27;</span>]).map(&amp;<span class="title class_">Pod</span><span class="symbol">:</span><span class="symbol">:Version</span>.method(<span class="symbol">:new</span>)).sort</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 加载 YAML 文件进行实例化</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">self</span>.from_file(file)</span><br><span class="line">        hash = file.file? ? <span class="title class_">YAMLHelper</span>.load_file(file) : &#123;&#125;</span><br><span class="line">        new(hash)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># pod 存储路径的各级目录名称截取</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">path_fragment</span>(<span class="params">pod_name, version = <span class="literal">nil</span></span>)</span><br><span class="line">        prefixes = <span class="keyword">if</span> prefix_lengths.empty?</span><br><span class="line">                     []</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                     hashed = <span class="title class_">Digest</span><span class="symbol">:</span><span class="symbol">:MD5</span>.hexdigest(pod_name)</span><br><span class="line">                     prefix_lengths.map <span class="keyword">do</span> |<span class="params">length</span>|</span><br><span class="line">                       hashed.slice!(<span class="number">0</span>, length)</span><br><span class="line">                     <span class="keyword">end</span></span><br><span class="line">                   <span class="keyword">end</span></span><br><span class="line">        prefixes.concat([pod_name, version]).compact</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>Metadata</code> 中定义的 <code>path_fragment</code> 方法会根据
pod name 和 version 来生成 pod 对应的索引目录：</p>
<ul>
<li>根据 pod name 计算 MD5 值</li>
<li>遍历 <code>prefix_lengths</code> 对生成的 MD5
值迭代截取指定长度，并作为分级目录的名称</li>
</ul>
<p>以 <code>AFNetworking</code> 为例，其 MD5 值如下所示： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">irb&gt; <span class="title class_">Digest</span><span class="symbol">:</span><span class="symbol">:MD5</span>.hexdigest(<span class="string">&quot;AFNetworking&quot;</span>)</span><br><span class="line"> =&gt; <span class="string">&quot;a75d452377f3996bdc4b623a5df25820&quot;</span></span><br></pre></td></tr></table></figure>
由于 <code>prefix_lengths</code> 的值为
<code>[1, 1, 1]</code>，那么其生成的目录名称分别是：<code>a</code>、<code>7</code>、<code>5</code>。</p>
<h2 id="specification">Specification</h2>
<p><code>Specification</code> 用于表示 podspec 文件，其相关的内容我们在
<a
href="http://chuquan.me/2022/01/03/podspec-analyze-principle/">《CocoaPods
podspec 解析原理》</a> 中进行了介绍，这里不再进行赘述。</p>
<h2 id="dependency">Dependency</h2>
<p><code>Dependency</code> 用于描述一个 pod 的依赖，我们在 Podfile
中为一个 pod 声明的 dependency，或者，在 podspec 指定的
dependency，最终都由 <code>Dependency</code>
进行描述。其核心定义如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">Pod</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Dependency</span></span><br><span class="line">    <span class="comment"># dependency 所关联的 pod name</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line">    <span class="comment"># 通过外部 source 提供 podspec 文件</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:external_source</span></span><br><span class="line">    <span class="comment"># 解析 denpendency 所使用的 podspec repo</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:podspec_repo</span></span><br><span class="line">    <span class="comment"># 指定的 dependency 版本</span></span><br><span class="line">    <span class="built_in">attr_accessor</span> <span class="symbol">:specific_version</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本文，通过阅读 CocoaPods-Core 源码，梳理了一下 source
管理机制及其设计结构，简化的结构示意图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-source-03.png?x-oss-process=image/resize,w_800" /></p>
<p>此外，我们还了解了 CocoaPods 中的两种 source
管理机制：master、trunk。这两种机制基本原理相同，在实现细节上有所区别，一种是全量下载，一种是按需下载，因此在下载速度方面有着明显的区别。</p>
<p>后面有时间的话，我们再根据一些具体的 pod
命令来分析它们的执行逻辑，了解 CocoaPods 中更多的实现细节。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/CocoaPods/Core">CocoaPods-Core</a></li>
<li><a
href="https://juejin.cn/post/6844904002686042125#heading-10">CocoaPods
CDN 机制中文解析</a></li>
<li><a
href="https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935">GitHub
taking a very long time to download changes to the Specs Repo</a></li>
<li><a
href="https://blog.cocoapods.org/Master-Spec-Repo-Rate-Limiting-Post-Mortem/#too-many-directory-entries">Master
spec-repo rate limiting post‑mortem</a></li>
<li><a
href="https://hcldirgit.github.io/2017/10/13/Apache/40.%20%E4%BB%80%E4%B9%88%E6%98%AFetag%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE/">什么是etag工作原理及配置</a></li>
</ol>
]]></content>
      <categories>
        <category>CocoaPods</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>Master Repo</tag>
        <tag>Trunk Repo</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH 协议实践</title>
    <url>/2017/12/27/ssh-protocol-practice/</url>
    <content><![CDATA[<h1 id="ssh概述">SSH概述</h1>
<p>类似于HTTP，SSH（Secure
Shell）是一种加密的网络传输协议，常用于加密远程登录。</p>
<span id="more"></span>
<p>1995年，芬兰赫尔辛基理工大学的塔图·于勒宁因为发现自己学校存在嗅探密码的网络攻击，设计了一套保护信息传输的程序，即Secure
Shell（简称SSH），其目标是取代先前的<code>rlogin</code>、<code>Telnet</code>、<code>FTP</code>、<code>rsh</code>等安全性不足的协议。如今，最为广泛使用的<code>OpenSSH</code>便是SSH协议的一种免费开源实现。</p>
<h2 id="基本原理">基本原理</h2>
<p>SSH使用非对称加密算法实现身份验证，即采用<strong>公钥-私钥对</strong>来进行加密网络连接。私钥由用户（本地主机）自行保管，公钥由远程主机（如：服务器）保管。</p>
<h2 id="应用实践">应用实践</h2>
<p>下面使用<code>OpenSSH</code>进行具体实践。</p>
<h3 id="ssh协议语法格式">SSH协议语法格式</h3>
<p>SSH主要用于远程登录，如下所示为SSH协议的语法格式。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh [&lt;username&gt;@]&lt;server&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure></p>
<h2 id="关于ssh公钥认证">关于SSH公钥认证</h2>
<p>为实现公钥认证，作为认证的客户端一方需要拥有两个文件，即<strong>公钥-私钥对</strong>。一般公钥-私钥对文件创建在用户的主目录下的<code>.ssh</code>目录中。如果用户主目录下不存在<code>.ssh</code>目录，说明SSH公钥-私钥对尚未创建。</p>
<h3 id="创建公钥-私钥对">创建公钥-私钥对</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure>
<p>该命令会在用户主目录下创建<code>.ssh</code>目录，并在其中创建两个文件：
- <code>id_rsa</code>：私钥文件。是基于RSA算法创建的。 -
<code>id_rsa.pub</code>：公钥文件。</p>
<h3 id="分发公钥">分发公钥</h3>
<p>创建了公钥-私钥对后，需要将公钥交给远程主机保管，这样才能在之后的登录实现无口令登录。如下命令，会将<code>.ssh</code>目录下指定的公钥文件拷贝至远程服务器。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub &lt;user&gt;@&lt;server&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>该命令会提示输入用户user在server上的SSH登录口令<br />
</li>
<li>此命令执行成功后，再以user用户用ssh命令登录server远程主机时，不必输入口令可直接登录</li>
<li>该命令实际上是<code>.ssh/id_rsa.pub</code>公钥文件拷贝到远程主机server的user主目录下的<code>.ssh/authorized_keys</code>文件中，内容类似如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHJu4oVxIbLS2LBH5wI7htvDxuIMZ5IFUaZjbWI8z...M4yGEWcr7OVPdQa4DIEbrrl8MzsAZ baochuquan@baochuquandeMacBoo    k-Pro.local</span><br></pre></td></tr></table></figure>
<h2 id="关于ssh主机别名">关于SSH主机别名</h2>
<p>在实际应用中，有时需要使用多套公钥/私钥对。然而，上述创建公钥-私钥对的命令只会生成默认名为<code>id_rsa</code>的密钥对。</p>
<h3 id="创建公钥-私钥对-1">创建公钥-私钥对</h3>
<p>为了创建不同的公钥/私钥对，在使用<code>ssh-keygen</code>命令时就需要通过<code>-f</code>参数指定不同的私钥名称。用法如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -f ~/.ssh/&lt;filename&gt;</span><br></pre></td></tr></table></figure>
命令会在<code>.ssh/</code>目录下创建指定的公钥/私钥对：文件<code>&lt;filename&gt;</code>是私钥，文件<code>&lt;filename&gt;.pub</code>是公钥。</p>
<h3 id="分发公钥-1">分发公钥</h3>
<p>将新生成的公钥添加到远程主机登录用户主目录下的<code>.ssh/authorized_keys</code>文件中，就可以使用新创建的公钥建立到远程主机<server>的<user>账户的无口令登录：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/&lt;filename&gt;.pub &lt;user&gt;@&lt;server&gt;</span><br></pre></td></tr></table></figure>
在有多个公钥/私钥对时，默认使用<code>~/.ssh/id_rsa.pub</code>。那么如何使用新建的公钥连接server呢？</p>
<h3 id="管理本地私钥">管理本地私钥</h3>
<p>SSH的客户端配置文件<code>~/.ssh/config</code>可以通过创建主机别名，连接主机时选择用指定的私钥。例如<code>/.ssh/config</code>文件中的下列配置
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用默认的id_rsa私钥</span><br><span class="line">Host gerrit.zhenguanyu.com</span><br><span class="line">    Hostname gerrit.zhenguanyu.com</span><br><span class="line">    Port 29418</span><br><span class="line">    User baocq</span><br><span class="line">    </span><br><span class="line"># 使用指定的chuquan01私钥</span><br><span class="line">Host chuquan</span><br><span class="line">  user root</span><br><span class="line">  hostname 115.28.167.128</span><br><span class="line">  port 22</span><br><span class="line">  identityfile ~/.ssh/chuquan01</span><br><span class="line">      </span><br><span class="line"># 使用指定的gerrit01私钥</span><br><span class="line">Host gerrit</span><br><span class="line">  user gerrit</span><br><span class="line">  hostname 115.28.167.128</span><br><span class="line">  port 22</span><br><span class="line">  identityfile ~/.ssh/gerrit01</span><br></pre></td></tr></table></figure></p>
<h3 id="无口令远程登录">无口令远程登录</h3>
<p>执行下面的SSH登录命令，即可登录Host为<code>chuquan</code>的主机：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh chuquan</span><br></pre></td></tr></table></figure></p>
<p>（完）</p>
<p>【参考】<br />
1. <a href="https://zh.wikipedia.org/wiki/Secure_Shell">Secure
Shell</a><br />
2. <a
href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH原理与运用（一）：远程登录</a><br />
3. <a
href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">SSH原理与运用（二）：远程操作与端口转发</a><br />
4. 《Git权威指南》，蒋鑫</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>公钥/私钥</tag>
      </tags>
  </entry>
  <entry>
    <title>俄罗斯·圣彼得堡之旅</title>
    <url>/2018/11/03/st-petersburg/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400" /></p>
<span id="more"></span>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=5261430&amp;auto=1&amp;height=66">
</iframe>
<p>盼了一年，终于盼来了公司的年度旅行。经过两轮的投票角逐，圣彼得堡众望所归！旅行时间计划是
10 月 27 日~ 11 月1 日，总共 6 天。我们此次行程总共 29
人，走团签，使用公司的旅行基金，每个人额外补贴 1020 元。</p>
<p>出发前两天，我花了两个晚上做了一下圣彼得堡的旅行攻略。首先，定位各个推荐景点和餐厅的位置，做到心里有点逼数。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg003.png?x-oss-process=image/resize,w_600" /></p>
<p>然后，综合日期、天气、距离、开/闭馆等情况（圣彼得堡有不少景点会周期性地选择闭馆），做了一个大致的行程计划。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg002.png?x-oss-process=image/resize,w_500" /></p>
<h1 id="day-1周六">Day 1（周六）</h1>
<p>前一天周五，我们照常上班，部分人（包括我）选择在公司一直待到凌晨，然后一起打车去机场。服务器一帮人去附近的网吧开黑，客户端则在公司打升级，玩任天堂游戏。我在
B
站上看了几个关于圣彼得堡的纪录片。对我来说，旅行中很大一部分乐趣是源自于旅行前的准备工作。</p>
<p>北京时间凌晨五点，我们从 T3 航站楼启程飞往新西伯利亚。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg004.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg008.png?x-oss-process=image/resize,w_600" /></p>
<p>经过四个半小时的飞行，飞越了数千公里的冰川，最终抵达新西伯利亚。降落前，从新西伯利亚上空俯瞰整个城市，第一感觉便是衰败。这与我的预期完全不符，心里难免有一些失落。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg005.png?x-oss-process=image/resize,w_500" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg006.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg007.png?x-oss-process=image/resize,w_500" /></p>
<p>在新西伯利亚机场转机等待了近2个小时，我们踏上了飞往圣彼得堡的行程。经历四个半小时，飞机成功降落于圣彼得堡普尔科沃机场，机舱里响起来热烈的掌声。</p>
<p>导游和大巴早已在机场等候多时，安置好行李后，我们从机场出发。沿着机场高速，经过跨海大桥，最终抵达我们位于瓦西里岛上的
Park inn 酒店。安排完入住后已经差不多下午2点多了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg009.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg010.png?x-oss-process=image/resize,w_600" /></p>
<p>在客房稍事休息，洗漱一下，我们（<span class="citation"
data-cites="大龙哥">@大龙哥</span>，<span class="citation"
data-cites="邱老师">@邱老师</span>，<span class="citation"
data-cites="张成">@张成</span>）便出门去逛附近的超市。买了烤鸡、黄瓜、香蕉、面包、啤酒、果汁，然后便是回酒店嗨。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg011.png?x-oss-process=image/resize,w_600" /></p>
<p>来圣彼得堡之前，我听说酒店有游泳池。于是晚上一闲下来，便在酒店一楼大厅瞎转，找游泳池。大厅绕了一圈，一对青年毛子情侣看到了我，小哥立马过来跟我尬聊了起来。小哥用带卷舌的英语，我用蹩脚的
Chinglish。聊了二十分钟，我还是没明白他到底想表达什么。。。</p>
<h1 id="day-2周日">Day 2（周日）</h1>
<p>一大早起来，打开窗帘，外面已然是白茫茫一片。天气与预期一样，那么计划也是一样。今天行程是冬宫。</p>
<p>来圣彼得堡之前，我们便以在飞猪上购买了电子票。冬宫早上10点半开放，我们分了好几拨，早早便抵达了冬宫快速通道门口。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg012.png?x-oss-process=image/resize,w_600" /></p>
<p>我们差不多画了5个小时的时间走马观花地逛了一遍冬宫。一楼是古埃及相关的展厅，我没怎么逛。二楼是沙俄以及西方中世纪的一些展品。三楼主要东方的一些展品。二楼的展品尤为绚烂，其中包括两幅达芬奇的真迹（世界仅存14副真迹）。果然不愧为世界四大博物馆，不禁感慨如果圆明园未毁，也许可以与其相媲美。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg013.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg016.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg017.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg015.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg014.png?x-oss-process=image/resize,w_600" /></p>
<p>逛完冬宫差不多已经下午三点半了，早已饥渴难耐，我们打车去附近一家小餐厅Varvara。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg018.png?x-oss-process=image/resize,w_600" /></p>
<p>简餐过后，我们沿着涅瓦大街闲逛，欣赏一下沿途的风景。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg019.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day3周一">Day3（周一）</h1>
<p>今天计划的第一站是圣以撒大教堂。刚刚抵达圣以撒大教堂，便遇到一群当地的小孩，冲着我们喊“你好”。尴尬的是我们居然不知道“你好”用俄语怎么说，只能也挥手喊着“你好”予以回应。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg020.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg021.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg022.png?x-oss-process=image/resize,w_600" /></p>
<p>圣以撒大教堂可以允许游客登顶观光，俯瞰整个圣彼得堡。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg023.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg026.png?x-oss-process=image/resize,w_600" /></p>
<p>与圣以撒大教堂合完影之后，我们便步行向北前往十二月党人广场，广场的中央是彼得大帝青铜骑士像。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg024.png?x-oss-process=image/resize,w_600" /></p>
<p>在广场逗留了一会儿，大家分头行动，我们（<span class="citation"
data-cites="邱老师">@邱老师</span>，<span class="citation"
data-cites="大龙哥">@大龙哥</span>，<span class="citation"
data-cites="刘杨">@刘杨</span>）决定去救世主滴血大教堂。抵达滴血大教堂，有一些一行，教堂的洋葱头正在维修，据说从去年至今一直在维修。不过教堂的内饰真的是美轮美奂，所有的壁画都是用指甲大小的马赛克拼接而成的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg027.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg025.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg028.png?x-oss-process=image/resize,w_500" /></p>
<p>救世主滴血大教堂参观完毕，我们（<span class="citation"
data-cites="吴迪">@吴迪</span>，<span class="citation"
data-cites="海侠">@海侠</span>，<span class="citation"
data-cites="大龙哥">@大龙哥</span>，<span class="citation"
data-cites="邱老师">@邱老师</span>，<span class="citation"
data-cites="刘杨">@刘杨</span>）来到了涅瓦大街吃午餐。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg030.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg029.png?x-oss-process=image/resize,w_600" /></p>
<p>吃完饭，我们在旁边的纪念品店里逛了一会儿，然后他们准备去商场购物。而我则打算去马路对面的喀山大教堂去拍照。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg032.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg031.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg034.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg033.png?x-oss-process=image/resize,w_500" /></p>
<p>拍完照，我便独自向我们约定的商场步行而去，与大家汇合。</p>
<h1 id="day4周二">Day4（周二）</h1>
<p>雪后第一天尤其寒冷，今天的计划则是去彼得保罗要塞观光。彼得堡罗要塞其实就是一个小岛，岛上有监狱（曾关押过高尔基）、教堂（埋葬了历代沙皇）、博物馆，我们也是挨个儿参观了一遍。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg035.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg037.png?x-oss-process=image/resize,w_500" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg036.png?x-oss-process=image/resize,w_600" /></p>
<p>差不多下午一点参观完各个景点，我们在一个小博物馆里逗留了一会儿，然后决定去岛上的一家推荐餐厅。餐厅位于小岛的西边，迎着涅瓦河。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg039.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg038.png?x-oss-process=image/resize,w_600" /></p>
<p>餐后，大家决定一起去看阿芙乐尔号巡洋舰。在路上顶着寒风大概走了半个小时终于到了阿芙乐尔号巡洋舰的地址。参观的总体感觉是比较坑，门票大约70元人民币，比冬宫还贵。里面只有一个小小的博物馆而已。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg040.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day5周三">Day5（周三）</h1>
<p>昨天在去往阿芙乐尔号的路上简直被吹成了傻逼，对于今天去叶卡捷琳娜宫的计划我有些犹豫。“既然都来了，就去看看吧”这样的念头促成我又做了一次傻逼的决定。叶卡捷琳娜宫只在下午一点后对散客开放，并且每15分钟放入20来人。我们上午到叶宫，在前面的花园里逛了一圈。差不多下午一点，到叶宫入口排队。寒风中吹了近两个小时才进入叶宫。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg041.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg042.png?x-oss-process=image/resize,w_600" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg043.png?x-oss-process=image/resize,w_600" /></p>
<p>说实话，叶宫真心无法与冬宫相比，除了琥珀宫，里面基本都是些宴会大厅。另外，加上这几天的行程，基本已经属于审美疲劳状态。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg044.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day5周四">Day5（周四）</h1>
<p>早上10:20在酒店大厅集合去机场。第一次来俄罗斯，并且是有如此浓厚艺术气息的圣彼得堡，虽然旅程很短暂，但是内心很满足。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>自由行</tag>
        <tag>俄罗斯</tag>
        <tag>圣彼得堡</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化并发</title>
    <url>/2023/03/11/structured-concurrency/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/structured-concurrency-logo.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>对于异步与并发，一直以来，业界都有着非常广泛的研究，针对特定场景提出了很多相关的技术，如：Future/Promise、Actor、CSP、异步函数等等。本文，我们来介绍一个近些年才出现的一个概念——<strong>结构化并发（Structured
Concurrency）</strong>。</p>
<p>2016 年，ZeroMQ 的作者 Martin Sústrik 于在其 C 语言结构化并发库
libdill
中首次提出了“结构化并发”的概念。事实上，这个概念其实是受到了更早期
Dijkstra 所提出的 <strong>结构化编程（Structured Programming）</strong>
的启发。</p>
<p>为了引出结构化并发，我们首先来介绍一下什么是结构化编程，这一切要从
GOTO 有害论说起。</p>
<h1 id="goto-有害论">GOTO 有害论</h1>
<p>计算机发展的早期，程序员使用汇编语言进行编程，在之后的一段时期，诞生了比汇编略微高级的编程语言，如
FORTRAN、FLOW-MATIC
等。这些语言虽然在一定程度上提高了可读性，但是仍然存在很大的局限性。如下所示就是一段
FLOW-MATIC 代码。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-01.png?x-oss-process=image/resize,w_800" /></p>
<p>由于当时块语法还没有发明，因此 FLOW-MATIC 不支持 <code>if</code>
块、循环块、函数调用、块修饰符等现代语言必备的基础特性。整段代码就是一系列按顺序排列并打平的命令。关于控制流，程序支持两种方式，分别是：</p>
<ul>
<li><strong>顺序执行</strong></li>
<li><strong>跳转执行</strong>，即 GOTO 语句。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-03.png?x-oss-process=image/resize,w_800" /></p>
<p>顺序执行的逻辑非常简单，它总是能够找到执行入口与出口。与之相反，跳转执行则充满了不确定性。如果程序中存在
GOTO 语句，那么它可以在
<strong>任何时候跳转至任何指令位置</strong>。一旦程序大量使用了 GOTO
语句，那么最终将变成 <strong>面条式代码（Spaghetti code）</strong>。</p>
<p>如下所示，我们对 FLOW-MATIC
代码的控制流使用箭头进行变标记，可以发现整个逻辑变成了一团糟，如同面条一般。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="结构化编程">结构化编程</h1>
<p>在发表 <a
href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">《Goto
Statement Considered Harmful》</a> 之后，Dijkstra 又发表了 <a
href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF">《Notes on
Structured Programming》</a> 表达了其理想的编程范式，提出了
<strong>结构化编程</strong> 的概念。</p>
<p>结构化编程在现在看来是理所当然的，但是在当时并不是。结构化编程的核心是
<strong>基于块语句，实现代码逻辑的抽象与封装，从而保证控制流具有单一入口和单一出口</strong>。现代编程语言中的条件语句、循环语句、函数定义与调用都是结构化编程的体现。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-01.png?x-oss-process=image/resize,w_800" /></p>
<p>相比 GOTO
语句，基于块的控制流有一个显著的特征：控制流从程序入口进入，中途可能会经历条件、循环、函数调用等控制流转换，但是最终控制流都会从程序出口退出。这种编程范式使得代码结构变得更加结构化，思维模型变得更加简单，也为编译器在低层级提供了优化的可能。</p>
<p>因此，完全禁用 GOTO
语句已经成为了大部分现代编程语言的选择。虽然，少部分编程语言仍然支持
GOTO，但是它们大都支持高德纳（Donald Ervin
Knuth）所提出的前进分支和后退分支不得交叉的理论。类似
<code>break</code>、<code>continue</code>
等控制流命令，依然遵循结构化的基本原则：<strong>控制流拥有单一的入口与出口</strong>。</p>
<p>如今，我们基于现代编程语言所编写的程序，绝大部分都是结构化的，结构化编程范式早已深入人心。</p>
<h1 id="并发编程">并发编程</h1>
<p>在单线程编程模型中，编程语言
<strong>通过代码块避免控制流随意跳转</strong>，从而实现程序的结构化。但是，在多线程编程（并发编程）模型中，线程之间控制和归属关系仍然存在很多问题，其面临的问题与
GOTO 的问题非常相似，这也是结构化并发所要解决的问题。</p>
<p>下面，我们先来看一下非结构化并发的问题。</p>
<h2 id="非结构化并发">非结构化并发</h2>
<p>我们首先来看一个使用 Swift 编写的非结构化并发的例子，如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        foo(completion: &#123; <span class="built_in">print</span>(<span class="string">&quot;main get <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">foo</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        bar(completion: &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;foo get <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">            completion(<span class="variable">$0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">bar</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">Int</span>(arc4random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bar get <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">    completion(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程执行</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>上述代码中，主线程执行 <code>main</code> 方法是一个结构化的过程。而
<code>main</code> 和 <code>foo</code>
内部则以非阻塞的方式执行并发任务，并通过 <code>completion</code>
获取结果。<code>bar</code> 内部则以阻塞的方式执行计算任务，并调用
<code>completion</code> 返回结果。</p>
<p>进一步分析这段代码中各个方法，可以发现 <code>main</code> 和
<code>foo</code> 中的并发任务派发其实是一种函数间的无条件 “跳转”
行为。虽然，<code>main</code> 和 <code>foo</code>
都会立即将控制流返回至调用者，但是它们各自生成了新的并发任务。这些并发任务并不知道自己从哪里来，它们的初始调用不存在于其所属线程的调用栈中，其生命周期也与调用者的作用域完全无关。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-02.png?x-oss-process=image/resize,w_800" /></p>
<p>这样的非结构化并发不仅使得代码的控制流变得非常复杂，而且还会带来了一个致命的后果：<strong>由于和调用者具有不同的调用栈，因此无法得知原始的调用者，进而无法以抛出的方式向上传递错误</strong>。</p>
<p>在非结构化并发的编程范式下，我们在调用任意一个方法，我们都会存在很多担忧：</p>
<ul>
<li>方法是否会产生一个后台任务？</li>
<li>方法虽然返回了，它所产生的后台任务是否仍然在运行？什么时候完成？其又会产生什么行为？</li>
<li>作为调用者，应该在哪里处理回调？如何处理回调？</li>
<li>是否保持这个方法用到的资源？后台任务是否会自动持有这些资源？还是要手动释放资源？</li>
<li>后台任务是否可以被管理？如果取消这些后台任务？</li>
<li>后台任务时候会产生其他后台任务？这些任务是否可以被正确管理？当任务取消时，二次派发的任务是否也会被取消？</li>
</ul>
<p>这些问题都是非结构化并发可能存在的问题，而结构化并发正是为了解决这些问题而提出的。</p>
<h2 id="结构化并发">结构化并发</h2>
<p>那么，到底什么是结构化并发呢？结构化并发的核心是
<strong>在并发模型下，也要保证控制流的单一入口和单一出口</strong>。程序可以产生多个控制流来实现并发，但是所有并发控制流在出口时都应该处于完成或取消状态，控制流最终在出口处完成合并。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-03.png?x-oss-process=image/resize,w_800" /></p>
<p>在结构化并发的编程范式下，<code>foo</code>
方法将所产生的并发控制流最终都会收束至 <code>foo</code>
方法中，<code>main</code>
方法也是如此，实现了真正的自包含。此时，我们调用黑盒方法，能够确信即使方法会产生额外的并发任务，控制流最终也会回归到方法调用的位置，一切尽在掌握之中！</p>
<h1 id="通用实现模式">通用实现模式</h1>
<h2 id="整体技术栈">整体技术栈</h2>
<p>大多数情况下，结构化并发的实现技术栈如下图所示。从上层到底层可以分为五个部分，分别是：</p>
<ul>
<li>作用域（Scope）</li>
<li>异步函数（Async function）</li>
<li>协程（Coroutine）</li>
<li>计算续体（Continuation）</li>
<li>内核态线程（Kernel Thread）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-08.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="作用域">作用域</h2>
<p>结构化编程是以 <strong>代码块（Code Block）</strong>
为基本要素进行组织的，而结构化并发则是以
<strong>作用域（Scope）</strong>
为基本要素进行组织的。在不同的编程语言或技术框架中，对于作用域的命名所有不同，如：Kotlin
称为 <code>Scope</code>，Swift 称为 <code>Task</code>，Python trio 称为
<code>nursery</code>，C libdll 称为 <code>bundle</code>。</p>
<p>类似于块语法用于标注结构化编程中的代码逻辑块，作用域则用于标注并发操作的执行范围。下图所示，为作用域标识并发操作作用域的示意图。另外，作用域之间的关系只有包含和并列关系，而没有部分重叠关系，这一点与块语法规则相同。这使得作用域之间的关系变得非常清晰，而易于管理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-04.png?x-oss-process=image/resize,w_800" /></p>
<p>在基于作用域的实现模式下，很多并发问题变得简单很多，比如：</p>
<ul>
<li>对于数据交换：以作用域为中心进行数据交互和传递，避免多线程数据操作导致问题。</li>
<li>对于返回值/异常传递：以作用域构成的关系链进行传递，类似于 UI
事件传递。</li>
<li>对于异步取消：以作用域为粒度，取消其所包含的异步任务以及子作用域，从而递归取消所有异步任务。</li>
</ul>
<h2 id="异步函数">异步函数</h2>
<p>很多编程语言都支持了异步函数，为了与同步函数进行区分，基本都提供了特定的关键词来进行声明或调用，比如：<code>async</code>/<code>await</code>，<code>suspend</code>、<code>yield</code>/<code>resume</code>
等。通过异步函数，我们可以通过同步调用的方式来编写代码，从而避免出现低于回调，进而提高代码的可读性。</p>
<p>如果编程语言只提供了异步函数，而不支持作用域，事实上也能够避免内部异步任务生命周期超出外部调用方法声明周期，因为异步函数的调用是通过以阻塞式的方式执行的。</p>
<p>相比而言，作用域的作用则在于管理多任务并发执行，解决多任务取消，值/异常传递等问题，这些是异步函数所无法解决的。</p>
<h2 id="协程">协程</h2>
<p>对于并发任务本身，其运算调度则由线程来支持。但是在高并发的场景下，基于传统意义上的线程池可能会面临性能瓶颈，如：线程爆炸、线程切换等。</p>
<p>为了解决性能和效率问题，大部分支持结构化并发的编程语言都以
<strong>协程（Coroutine）</strong>
作为运算调度的最小单元。那么到底什么是协程？协程本质上就是
<strong>用户态线程</strong>，关于协程的进一步介绍可以阅读我之前写过的一篇博客——
<a
href="http://chuquan.me/2021/05/05/getting-to-know-coroutine/">《初识协程》</a>。</p>
<p>我们知道操作系统线程模型主要有 3
种，如下图所示。其中，纯用户态线程模型是早期单核 CPU
的产物，纯内核态线程模式是多核 CPU
下相对高效的模型。现代操作系统普遍采用的是组合式线程模型，支持提供远超
CPU
核心数量的用户态线程池。用户态线程的切换不涉及线程资源（包括寄存器、栈指针、栈内存等）切换，因此性能开销相对较小。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-user-kernel-thread.png?x-oss-process=image/resize,w_800" /></p>
<p>在传统的同步编程模式下，我们始终维护一个线性的调用栈，而在基于作用域和协程实现的并发编程模式下，我们可以维护一个树形的调用栈，如下图所示。基于树形调用栈，我们可以有效记录父子并发任务之间的调用关系，便于问题定位与追踪。注意，协程可以根据是否基于调用栈实现，分为有栈协程和无栈协程，这里我们以有栈协程为例，介绍结构化并发的优势。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="计算续体">计算续体</h2>
<p>在代码层面，异步函数之后的代码是怎么实现等待异步函数执行完成之后再执行的呢？试想一下如下这段伪代码，为什么
<code>print result</code> 会等待异步函数 <code>asyncOperation</code>
完成之后才会执行的呢？怎么做到的？</p>
<pre><code>val result = await asyncOperation()
print result</code></pre>
<p>事实上，这样要归功于
<strong>计算续体（Continuation）</strong>。知道回调函数的人很多，但是知道计算续体的人并不多。<strong>当一个计算过程在中间被打断，其剩余部分可以使用一个对象进行表示</strong>，这个对象就是计算续体。当然，操作系统暂停一个线程时保存的那些数据快照，也可以看成是一个计算续体。基于计算续体，我们就能实现从上次中断的地方继续执行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-06.png?x-oss-process=image/resize,w_800" /></p>
<p>既然可以利用续体来等待异步操作执行完成，那么执行过程中运行时系统是如何选择哪些部分作为续体呢？对此，大多数编程语言会提供相关的关键词进行修饰，最常见的就是
<code>async</code> 和 <code>await</code>。一般 <code>async</code>
用于声明一个异步函数，<code>await</code>
用于挂起（执行）一个异步函数。事实上，计算续体就是异步函数的底层实现技术。</p>
<p>当使用 <code>await</code> 调用一个异步函数时，那么编译器会
<strong>将后续部分的代码转换成续体，当异步任务执行完毕之后，再将值传递至续体中继续执行，有点类似于方法回调</strong>。</p>
<p>在不同的编程语言中，计算续体的表示也有所不同。Kotlin 和 Swift 使用
<code>Continuation</code> 表示，Lua 使用 <code>Coroutine Object</code>
表示，JavaScript 使用 <code>Generator</code> 表示，Dart 使用
<code>Async Generator</code> 表示。</p>
<h3 id="续体与栈帧">续体与栈帧</h3>
<p>事实上，计算续体与函数栈帧有着非常紧密的关系，前者是保存和恢复栈帧的一种机制。</p>
<p>在函数调用时，每个函数都会创建一个栈帧，其包含函数的局部变量、参数以及返回地址等信息。栈帧被存放在进程空间的栈区，当函数返回时，对应的栈帧会从栈中弹出，程序恢复到调用该函数的地方。</p>
<p>计算续体则是将 <strong>当前栈帧</strong> 以及
<strong>程序计算器</strong>
等信息保存至一个对象中，然后将该对象传递给一个续体函数。续体函数可以在需要时将保存的状态恢复，从而继续执行程序。</p>
<p>因此，从运行时层面看，计算续体就是当前函数的栈帧与现场状态；从代码层面看，计算续体就是等待异步操作完成的后续代码。</p>
<h3 id="cps-变换">CPS 变换</h3>
<p>提到计算续体，我们就不得不提一下 <strong>CPS
变换（Continuation-Passing-Style Transformation）</strong>。</p>
<p>CPS 变换本质上就是
<strong>将等待执行的代码转换成一个函数，计算续体作为函数的参数，参数名通常命名成
<code>Continuation</code></strong>。</p>
<p>下面，我们以 Swift 为例进行介绍。假如，我们有一个旧版
<code>oldLoad</code>
方法，通过闭包进行异步回调。此时，我们希望设计基于异步函数的新版
<code>newLoad</code> 方法，但是内部仍然使用旧版 <code>oldLoad</code>
方法进行复用。在这种场景下，我们就可以利用 CPS 变换来实现预期目标。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"># 旧版方法</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">oldLoad</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ([<span class="type">String</span>]<span class="operator">?</span>, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"># 新版方法</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">newLoad</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withUnsafeThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        oldLoad &#123; values, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> values <span class="operator">=</span> values &#123;</span><br><span class="line">                continuation.resume(returing: values)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                continuation.resume(throwing: error)   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assertFailure(<span class="string">&quot;both parameters are nil&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图所示，当我们使用新版 <code>newLoad</code>
方法时，等待异步执行的代码被封装成了一个函数，函数的参数是一个
<code>Continuation</code>。我们可以根据不同的情况向
<code>Continuation</code>
传递值或错误，从而让等待异步执行的代码继续执行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-07.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，Kotlin 协程就是通过 CPS
转换实现的，其在编译期间对调用挂起函数的上下文进行拆分，完成 CPS
转换。这也是为什么 Kotlin 可以不用修改 VM 或 OS
就能够支持协程的原因。</p>
<h1 id="并发调度模型">并发调度模型</h1>
<p>通过上一节我们知道了结构化并发所涉及的各种技术。下面，我们来通过一段
Swift 代码，介绍一下并发任务的调度模型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">save</span>(<span class="keyword">_</span> <span class="params">contents</span>: [<span class="type">Contents</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">ID</span>] &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handle</span>(<span class="keyword">_</span> <span class="params">contents</span>: [<span class="type">Content</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ids <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> save(contents)</span><br><span class="line">    <span class="keyword">for</span> (id, content) <span class="keyword">in</span> <span class="built_in">zip</span>(ids, contents) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(id)</span>: <span class="subst">\(content)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设一个线程调用了一个 <code>handle</code>
方法。在这个阶段，最近的堆栈将是 <code>handle</code>。当
<code>handle</code> 遇到内部的 <code>await</code>
关键词修饰的异步操作时，运行时会将 <code>handle</code>
方法的计算续体存储至堆中，从而等待异步操作完成。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-09.png?x-oss-process=image/resize,w_800" /></p>
<p>当运行时发现存在空闲的线程时，则将异步操作 <code>save</code>
加入对应线程的栈中并开始执行。但是 <code>save</code> 方法内部又存在异步
I/O 操作，因此 <code>save</code>
方法的计算续体又会被存储至堆中，从而等待 I/O 操作完成。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-10.png?x-oss-process=image/resize,w_800" /></p>
<p>在等待 I/O
操作的过程中，线程会被让出，从而允许其他任务进行复用。下图中，运行时会将
<code>otherWork1</code> 方法加入线程并执行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-11.png?x-oss-process=image/resize,w_800" /></p>
<p>当 <code>save</code> 所等待的 I/O
操作完成之后，运行时会寻找空闲的线程，并将 <code>save</code>
的计算续体加入栈中并执行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-12.png?x-oss-process=image/resize,w_800" /></p>
<p>当 <code>save</code> 执行完毕，运行时会将与 <code>save</code>
计算续体关联等待的 <code>handle</code>
续体取出，选择一个空闲的线程来执行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-13.png?x-oss-process=image/resize,w_800" /></p>
<p>在 <code>handle</code> 计算续体执行过程中，会调用同步方法如
<code>zip</code>，那么栈上将会正常加入 <code>zip</code> 的栈帧。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-14.png?x-oss-process=image/resize,w_800" /></p>
<p><code>zip</code> 执行完毕之后，对应的栈帧出栈，继续执行
<code>hanle</code> 计算续体。由于这里是一个 <code>for</code>
循环，<code>zip</code>
栈帧的入栈和出栈会循环往复多次。最终，<code>handle</code>
计算续体也执行完毕。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-15.png?x-oss-process=image/resize,w_800" /></p>
<!--# 应用-->
<!--最后，我们来举一个例子看看不同编程语言是如何使用结构化并发来解决并发问题的。假如，我们需要一张图片来显示头像，图片有两个备选分别是 imageA 和imageB，其中 imageA 被分割成了两部分：imageA-1 和imageA-2。当 imageA-1 和 imageA-2 同时下载完成后才能使用。此时，我们需要构造三个下载任务，只要有一个完整的图片下载成功，就取消其他下载任务。-->
<!--下面，我们来分别看一下 Kotlin 和 Swift 可以如何使用结构化合并解决这个问题的。-->
<!--## Kotlin 结构化并发-->
<!--```kotlin-->
<!--import kotlinx.coroutines.*-->
<!--fun downloadImage(imageName: String): String {-->
<!--    // 模拟下载过程，打印下载状态以及返回图片名称-->
<!--    println("开始下载 $imageName")-->
<!--    Thread.sleep(1000)-->
<!--    println("完成下载 $imageName")-->
<!--    return imageName-->
<!--}-->
<!--suspend fun downloadImageA(): String {-->
<!--    val imageA1 = async { downloadImage("imageA-1") }-->
<!--    val imageA2 = async { downloadImage("imageA-2") }-->
<!--    return "${imageA1.await()},${imageA2.await()}"-->
<!--}-->
<!--suspend fun downloadImageB(): String {-->
<!--    return async { downloadImage("imageB") }.await()-->
<!--}-->
<!--fun main() = runBlocking<Unit> {-->
<!--    // 创建一个父级 CoroutineScope-->
<!--    coroutineScope {-->
<!--        // 在父级 CoroutineScope 内创建一个新的 CoroutineScope，并将 downloadImageA 协程放在其中，启动 imageA 任务。-->
<!--        val scopeForImageA = CoroutineScope(coroutineContext)-->
<!--        val imageAJob = scopeForImageA.launch { downloadImageA() }-->
<!--        // 在父级 CoroutineScope 内启动 imageB 任务-->
<!--        val imageBJob = launch { downloadImage("imageB") }-->
<!--        // 等待 imageA 和 imageB 中有一个完成-->
<!--        val downloadedImage = select<String> {-->
<!--            imageAJob.onJoin {-->
<!--                imageBJob.cancel()-->
<!--            }-->
<!--            imageBJob.onJoin {-->
<!--                scopeForImageA.cancel()-->
<!--            }-->
<!--        }-->
<!--        // 输出完成的图片-->
<!--        println("成功下载：$downloadedImage")-->
<!--    }-->
<!--}-->
<!--```-->
<h1 id="总结">总结</h1>
<p>本文通过 GOTO
有害论引出编程历史中结构化编程的演化。以结构化编程作为类比，介绍了结构化并发的核心观点，以及结构化并发的设计理念。结构化并发主要包括作用域、异步函数、计算续体、协程等技术，此外还需要运行时系统的调度，才能最终实现理想的结构化并发。</p>
<p>关于高级编程语言中结构化并发的实践，后续我们将继续在其他文章中进行讨论。目前原生支持结构化并发的编程语言并不多，幸运的是移动端开发的编程语言
Kotlin、Swift
是支持的，后面我们会研究一下这两者对于结构化并发的实现。另外，有时间的话，我们也会介绍一些结构化并发的辅助框架，比如：trio、libdll
等，进而加深对于结构化并发的理解。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://en.wikipedia.org/wiki/Continuation">Continuation</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Structured_concurrency">Structured
concurrency</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Structured_programming">Structured
programming</a></li>
<li><a href="https://pic.plover.com/knuth-GOTO.pdf">Structured
Programming with go to Statements</a></li>
<li><a href="http://jacques.rouillard.org/A_l_epoch/goto.pdf">Go To
Statement Considered Harmful</a></li>
<li><a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD249.PDF">Notes on
structured programming</a></li>
<li><a
href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes
on structured concurrency, or: Go statement considered harmful</a></li>
<li><a href="https://250bpm.com/blog:71/index.html">Structured
Concurrency</a></li>
<li><a href="https://250bpm.com/blog:124/index.html">Structured
Concurrency in High-level Languages</a></li>
<li><a
href="https://archive.fosdem.org/2019/schedule/event/structured_concurrency/">Structured
Concurrency Finding our way out of callback hell</a></li>
<li><a
href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">Some
thoughts on asynchronous API design in a post-async/await world</a></li>
<li><a
href="https://trio.discourse.group/t/structured-concurrency-resources/21">Structured
concurrency resources</a></li>
<li><a
href="https://trio.discourse.group/t/structured-concurrency-kickoff/55">Structured
Concurrency Kickoff</a></li>
<li><a
href="https://elizarov.medium.com/structured-concurrency-722d765aa952">Structured
concurrency</a></li>
<li><a href="https://www.youtube.com/watch?v=_hfBv0a09Jc">KotlinConf
2017 - Introduction to Coroutines by Roman Elizarov</a></li>
<li><a
href="https://gist.github.com/belm0/4c6d11f47ccd31a231cde04616d6bb22">Structured
concurrency and Lua(part1)</a></li>
<li><a
href="https://gist.github.com/belm0/abbe9acb832eafa10dcbfd2b26eb74fc">Structured
concurrency and Lua(part2)</a></li>
<li><a
href="https://gist.github.com/belm0/20bc069ca676fcfc591f29930069f788">Structured
concurrency and Lua(part2)</a></li>
<li><a
href="https://developer.apple.com/videos/play/wwdc2021/10134/">Explore
structured concurrency in Swift</a></li>
<li><a
href="https://developer.apple.com/videos/play/wwdc2021/10254/">Swift
concurrency: Behind the scenes</a></li>
<li>《swift 异步与并发》</li>
<li><a
href="https://aisia.moe/2018/02/08/kotlin-coroutine-kepa/">Kotlin协程 -
先入个门吧</a></li>
<li><a
href="https://www.kotlincn.net/docs/reference/coroutines/basics.html">Kotlin协程</a></li>
</ol>
]]></content>
      <categories>
        <category>异步与并发</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>作用域</tag>
        <tag>计算续体</tag>
        <tag>异步函数</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 泛型协议</title>
    <url>/2021/09/25/swift-generic-protocol/</url>
    <content><![CDATA[<p>之前在一些分享会上经常听到 <strong>类型擦除</strong>（Type
Erase）这个概念，从其命名上大概知道它要干什么，但是对于为什么要用它？以及什么场景下使用它？对此，我并没有深刻的理解。于是，借着假期好好研究了一下。问题的一切要从泛型协议说起。</p>
<span id="more"></span>
<h1 id="协议如何支持泛型">协议如何支持泛型？</h1>
<p>我们知道，在 Swift 中，protocol 支持泛型的方式与 class/struct/enum
不同，具体说来：</p>
<ul>
<li>对于 class/struct/enum，其采用 <strong>类型参数（Type
Parameters）</strong> 的方式。</li>
<li>对于 protocol，其采用 <strong>抽象类型成员（Abstract Type
Member）</strong> 的方式，具体技术称为 <strong>关联类型（Associated
Type）</strong>。</li>
</ul>
<p>分别如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;<span class="title class_">T</span>&gt; &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GenericStruct</span>&lt;<span class="title class_">T</span>&gt; &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GenericEnum</span>&lt;<span class="title class_">T</span>&gt; &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">GenericProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">AbstractType</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">next</span>() -&gt; <span class="type">AbstractType</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们可能会有一个疑问：为什么 class/enum/struct 使用泛型参数，而
protocol 则使用抽象类型成员？我查阅了很多讨论，原因可以归纳为两点：</p>
<ul>
<li>采用类型参数的泛型其实是定义了整个类型家族，我们可以通过传入类型参数可以转换成具体类型（类似于函数调用时传入不同参数），如：<code>Array&lt;Int&gt;</code>，<code>Array&lt;String&gt;</code>，很显然类型参数适用于多次表达。然而，协议的表达是一次性的，我们只会实现
<code>GenericProtocol</code>，而不会特定地实现
<code>GenericProtocol&lt;Int&gt;</code> 或
<code>GenericProtocol&lt;String&gt;</code>。</li>
<li>协议在 Swift 中有两个目的，第一个目的是
<strong>用来实现多继承</strong>（Swift
语言被设计成单继承），第二个目的是
<strong>强制实现者必须遵守协议所指定的泛型约束</strong>。很明显，<strong>协议并不是用来表示某种类型，而是用来约束某种类型</strong>，比如：<code>GenericProtocol</code>
约束了 <code>next()</code> 方法的返回类型，而不是定义
<code>GenericProtocol</code>
的类型。而抽象类型成员则可以用来实现类型约束的。</li>
</ul>
<h1 id="如何存储非泛型协议">如何存储非泛型协议？</h1>
<p>下面，我们来看一下协议的存储。首先，我们来考虑非泛型协议。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Drawable</span> &#123; </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x1, y1, x2, y2: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value: <span class="type">Drawable</span> <span class="operator">=</span> arc4random()<span class="operator">%</span><span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>) : <span class="type">Line</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">1</span>, y2: <span class="number">1</span>)</span><br></pre></td></tr></table></figure> 从上述代码可以看出，value 既可以表示 Point
类型，又可以表示 Line 类型。事实上，value
的实际类型是编译器生成的一种特殊数据类型
<code>Existential Container</code>。<code>Existential Container</code>
对具体类型进行封装，从而实现存储一致性。关于 Existential Container
的具体内容，可以参考<a
href="http://chuquan.me/2020/02/19/swift-performance-protocol-type-generic-type/">《Swift性能优化(2)——协议与泛型的实现》</a>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/existential-container.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="如何存储泛型协议">如何存储泛型协议？</h1>
<p>接下来，我们再来考虑泛型协议的存储。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">AbstractType</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">AbstractType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntGenerator</span>: <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">AbstractType</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StringGenerator</span>: <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">AbstractType</span> <span class="operator">=</span> <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zero&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value: <span class="type">Generator</span> <span class="operator">=</span> arc4random()<span class="operator">%</span><span class="number">2</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="type">IntGenerator</span>() : <span class="type">StringStore</span>()</span><br></pre></td></tr></table></figure>
通过非泛型协议的例子，我们理所当然会觉得上述代码没有问题，因为有
<code>Existential Container</code> 类型可以保证存储一致性。</p>
<p>事实上，上述代码从表面上看的确不会有问题，但是我们忽略了泛型协议的本质——约束类型。我们可以在上述代码的基础上，继续加上如下代码：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> value.generate()</span><br></pre></td></tr></table></figure> 由于 <code>Generator</code> 协议约束了
<code>generate()</code> 方法的返回类型，在本例中，<code>x</code>
的类型既可能是 <code>Int</code>，又可能是 <code>String</code>。而 Swift
本身又是一种强类型语言，所有的类型必须在编译时确定。因此，swift
无法直接支持泛型协议的存储。</p>
<p>所以，在实际开发中，Xcode 会对以下这种类型的定义报错。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="type">Generator</span> <span class="operator">=</span> <span class="type">IntGenerator</span>()</span><br><span class="line"><span class="comment">// Error: Protocol &#x27;Generator&#x27; can only be used as a generic constraint because it has Self or associated type requirements</span></span><br></pre></td></tr></table></figure></p>
<p>那么，如何解决泛型协议的存储呢？</p>
<h1 id="解决方法">解决方法</h1>
<p>问题的本质是要将泛型协议的所约束的类型进行擦除，即 <strong>类型擦除
（Type Erase）</strong>，从而骗过编译器，解决该问题的思路有两种：</p>
<ul>
<li>泛型协议转换成非泛型协议。</li>
<li>泛型协议封装成的具体类型。</li>
</ul>
<p>对于『泛型协议转换成非泛型协议』，由于泛型协议的实现采用的是抽象类型成员，而不是类型参数，只能基于抽象类型成员进行泛型约束，然而通过转换而来的协议本质上仍然是泛型协议，如下所示。此方法无效。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">BoolGenerator</span>: <span class="title class_">Generator</span> <span class="title class_">where</span> <span class="title class_">AbstractType</span> == <span class="title class_">String</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoolGeneratorObj</span>: <span class="title class_">BoolGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bool&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value: <span class="type">BoolGenerator</span> <span class="operator">=</span> <span class="type">BoolGeneratorObj</span>()</span><br><span class="line"><span class="comment">// Error: Protocol &#x27;BoolGenerator&#x27; can only be used as a generic constraint because it has Self or associated type requirements</span></span><br></pre></td></tr></table></figure></p>
<p>对于『泛型协议封装成的具体类型』，事实上，这是业界普遍的解决方案，swift
中很多系统库都是采用这种思路来解决的。</p>
<p>为此，我们可以使用 thunk 技术来解决。什么是 thunk？<strong>一个 thunk
通常是一个子程序，它被创造出来，用于协助调用其他的子程序</strong>。说到底，就是通过创造一个中间层来解决遇到的问题。</p>
<blockquote>
<p>thunk 技术应用非常广泛，比如：oc swift
混编时，我们可以在调用栈中看到存在 thunk 函数。</p>
</blockquote>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p>
<p>具体的解决方法是：</p>
<ul>
<li>定义一个『中间层结构体』，该结构体实现了协议的所有方法。</li>
<li>在『中间层结构体』实现的具体协议方法中，再转发给『实现协议的抽象类型』。</li>
<li>在『中间层结构体』的初始化过程中，『实现协议的抽象类型』会被当做参数传入（依赖注入）。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">AbstractType</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">AbstractType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GeneratorThunk</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _generate: () -&gt; <span class="type">T</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">G</span>: <span class="type">Generator</span>&gt;(<span class="keyword">_</span> <span class="params">gen</span>: <span class="type">G</span>) <span class="keyword">where</span> <span class="type">G</span>.<span class="type">AbstractType</span> <span class="operator">==</span> <span class="type">T</span> &#123;</span><br><span class="line">        _generate <span class="operator">=</span> gen.generate</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _generate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们拥有一个
thunk，我们可以把它当做类型使用（需要提供具体类型）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StringGenerator</span>: <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">AbstractType</span> <span class="operator">=</span> <span class="type">String</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">generate</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;zero&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gens: <span class="type">GeneratorThunk</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> <span class="type">GeneratorThunk</span>(<span class="type">StringGenerator</span>())</span><br></pre></td></tr></table></figure>
<p>采用 thunk
技术，我们把泛型协议封装成的具体类型，其本质就是对泛型协议进行了
<strong>类型擦除（Type
Erase）</strong>，从而解决了泛型类型的存储问题。</p>
<h1 id="类型擦除">类型擦除</h1>
<p>关于类型擦除，在 Swift 标准库的实现中，一般会创建一个包装类型（class
或
struct）将遵循了协议的对象进行封装。包装类型本身也遵循协议，它会将对协议方法的调用传递到内部的对象中。包装类型一般命名为
<code>Any&#123;protocol-name&#125;</code>，如：<code>AnySequence</code>、<code>AnyCollection</code>。</p>
<p>下面，是以 Swift 标准库的方式对泛型协议进行类型擦除。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyPrinter</span>&lt;<span class="title class_">U</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T</span> <span class="operator">=</span> <span class="type">U</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _print: (<span class="type">U</span>) -&gt; ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Base</span>: <span class="type">Printer</span>&gt;(<span class="params">base</span> : <span class="type">Base</span>) <span class="keyword">where</span> <span class="type">Base</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">U</span> &#123;</span><br><span class="line">        _print <span class="operator">=</span> base.print</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        _print(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Logger</span>&lt;<span class="title class_">U</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T</span> <span class="operator">=</span> <span class="type">U</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">&quot;<span class="subst">\(val)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logger <span class="operator">=</span> <span class="type">Logger</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">let</span> printer <span class="operator">=</span> <span class="type">AnyPrinter</span>(base: logger)</span><br><span class="line">printer.print(<span class="number">5</span>)        <span class="comment">// prints 5</span></span><br></pre></td></tr></table></figure>
在这里，<code>AnyPrinter</code> 并没有显式地引用 <code>base</code>
实例。事实上我们也不能这么做，因为我们不能在 <code>AnyPrinter</code>
中声明一个 <code>Printer&lt;T&gt;</code>
的属性。对此，我们使用一个方法指针 <code>_print</code> 指向了
<code>base</code> 的 <code>print</code>
方法，通过这种方式，<code>base</code> 被柯里化成了
<code>self</code>，从而隐式地引用了 <code>base</code> 实例。</p>
<h1 id="具体应用">具体应用</h1>
<p>在 RxSwift
中，就有针对泛型协议类型擦除的相关应用，我们来看下面这段代码：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">ObserverType</span> &#123;</span><br><span class="line">    <span class="comment">/// The type of elements in sequence that observer can observe.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Notify observer about sequence event.</span></span><br><span class="line">    <span class="comment">/// - parameter event: Event that occurred.</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">on</span>(<span class="keyword">_</span> <span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A type-erased `ObserverType`.</span></span><br><span class="line"><span class="comment">/// Forwards operations to an arbitrary underlying observer with the same `Element` type, hiding the specifics of the underlying observer type.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">AnyObserver</span>&lt;<span class="title class_">Element</span>&gt; : <span class="title class_">ObserverType</span> &#123;</span><br><span class="line">    <span class="comment">/// Anonymous event handler type.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">EventHandler</span> <span class="operator">=</span> (<span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> observer: <span class="type">EventHandler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Construct an instance whose `on(event)` calls `eventHandler(event)`</span></span><br><span class="line">    <span class="comment">/// - parameter eventHandler: Event handler that observes sequences events.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">eventHandler</span>: <span class="keyword">@escaping</span> <span class="type">EventHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.observer <span class="operator">=</span> eventHandler</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Construct an instance whose `on(event)` calls `observer.on(event)`</span></span><br><span class="line">    <span class="comment">/// - parameter observer: Observer that receives sequence events.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">Observer</span>: <span class="type">ObserverType</span>&gt;(<span class="keyword">_</span> <span class="params">observer</span>: <span class="type">Observer</span>) <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.observer <span class="operator">=</span> observer.on</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Send `event` to this observer.</span></span><br><span class="line">    <span class="comment">/// - parameter event: Event instance.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">on</span>(<span class="keyword">_</span> <span class="params">event</span>: <span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.observer(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Erases type of observer and returns canonical observer.</span></span><br><span class="line">    <span class="comment">/// - returns: type erased observer.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">asObserver</span>() -&gt; <span class="type">AnyObserver</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>ObserverType</code>
是一个泛型协议，<code>AnyObserver</code>
是一个用于类型擦除的包装类型。<code>AnyObserver</code>
定义了方法指针（闭包），向实现协议的抽象类型实例所声明的方法。同时
<code>AnyObserver</code> 自身又遵循 <code>ObserverType</code>
协议，在调用 <code>AnyObserver</code>
对应的协议时，它会将方法调用转发至对应方法指针所对应的方法。</p>
<p>除了 <code>AnyObserver</code> 之外，<code>Observable</code>
同样也是一个用于类型擦除的包装类型，其工作原理也是基本相似。</p>
<p>此外，swift
标准库中也大量应用了类型擦除，比如：<code>AnySequence</code>、<code>AnyIterator</code>、<code>AnyIndex</code>、<code>AnyHashable</code>、<code>AnyCollection</code>
等等。后续有时间，我们再来看看标准库中对于泛型协议的类型擦除是怎么做，可以肯定的是，其实现原理基本是一致的</p>
<h1 id="总结">总结</h1>
<p>本文，我们通过泛型协议的例子，了解了类型擦除的作用。这里，类型擦除将泛型协议所关联的类型信息进行了擦除，本质上是通过类型参数的方式，让实现抽象类型成员具体化。在面向协议编程中，类型擦除也是一种非常常见的手段，后续我们阅读相关代码时，也就不会对包装类型产生迷惑了。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="http://www.russbishop.net/swift-why-associated-types">Swift: Why
Associated Types?</a></li>
<li><a href="http://russbishop.net/swift-associated-types">Swift:
Associated Types</a></li>
<li><a
href="http://www.russbishop.net/swift-associated-types-cont">Swift:
Associated Types, cont.</a></li>
<li><a href="http://www.russbishop.net/inception">Inception</a></li>
<li><a href="https://robnapier.net/type-erasure-in-stdlib">Type-erasure
in Stdlib</a></li>
<li><a href="https://robnapier.net/erasure">A Little Respect for
AnySequence</a></li>
<li><a
href="https://stackoverflow.com/questions/27725803/how-to-use-generic-protocol-as-a-variable-type">How
to use generic protoco as a variable type</a></li>
<li><a href="https://en.wikipedia.org/wiki/Thunk">Thunk.
Wikipedia</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html">Thunk
函数的含义和用法</a></li>
<li><a href="https://milen.me/writings/swift-generic-protocols/">Swift
Generic Protocols</a></li>
<li><a href="https://toutiao.io/posts/211178/app_preview">当 Swift
中的协议遇到泛型</a></li>
<li><a
href="https://academy.realm.io/cn/posts/altconf-hector-matos-type-erasure-magic/">神奇的类型擦除</a></li>
<li><a
href="https://academy.realm.io/posts/tryswift-gwendolyn-weston-type-erasure/">Keep
Calm and Type Erase On</a></li>
<li><a
href="http://blog.benjamin-encz.de/post/compile-time-vs-runtime-type-checking-swift/">Compile
Time vs. Run Time Type Checking in Swift</a></li>
<li><a
href="https://www.jianshu.com/p/ef4a9b56f951">swift的泛型协议为什么不用<T>语法</a></li>
<li><a
href="https://medium.com/swiftworld/swift-world-type-erasure-5b720bc0318a">Swift
World: Type Erasure</a></li>
<li><a
href="https://github.com/rnapier/MyAnySequence/blob/master/MyAnySequence.playground/Contents.swift">MySequece</a></li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>泛型协议</tag>
        <tag>类型擦除</tag>
        <tag>thunk</tag>
        <tag>抽象类型成员</tag>
        <tag>类型参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 性能优化(1)——基本概念</title>
    <url>/2020/02/15/swift-performance-optimization-basic-concepts/</url>
    <content><![CDATA[<p>最近看了关于 Swift
底层原理的一些视频和文章，收获颇丰，感觉对于编程语言有了新的理解。因此，趁热打铁，记录并总结对
Swift
底层原理的理解。由于相关的内容非常多，这里准备分成多篇文章来进行阐述。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>本文主要介绍关于 Swift
性能优化的一些基本概念。编程语言的性能主要涵盖三个指标：</p>
<ul>
<li><strong>内存分配</strong>（Memory Allocation）</li>
<li><strong>引用计数</strong>（Reference Counting）</li>
<li><strong>派发方式</strong>（Method Dispatching）</li>
</ul>
<p>下面，以 Swift 为例，分别对这三个指标进行介绍。</p>
<h1 id="内存分配">内存分配</h1>
<p>每一个进程都有独立的进程空间，如下图所示。进程空间中能够用于内存分配的区域主要分为两种：</p>
<ul>
<li><strong>栈区</strong>（Stack）</li>
<li><strong>堆区</strong>（Heap）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/process-memory-space.png?x-oss-process=image/resize,w_800" /></p>
<p>为什么会有这两种区别呢？因为它们的设计目的不同。</p>
<p>栈区主要用于函数（方法）调用和局部变量管理，每调用一次函数，就会在栈区中生成一个栈帧，栈帧中包含函数运行时产生的局部变量。函数调用返回后立即执行出栈，所有局部变量就此销毁。</p>
<p>堆区主要用于多线程模型，每个线程有独立的栈区，但却共享同一个堆区，多线程之间通过堆区进行数据访问，对此我们需要对堆区的数据进行锁定和同步。</p>
<p>Swift
中的数据类型可以分成两种：<strong>值类型</strong>、<strong>引用类型</strong>。两者的内存分配区域是不同的，值类型默认分配在栈区，引用类型默认分配在堆区。</p>
<h2 id="栈区分配">栈区分配</h2>
<p>值类型，包括：基本数据类型、结构体，默认在栈区进行分配。栈区的内存都是连续的，通过入栈和出栈进行分配和销毁，速度很快，比堆区的分配速度更快。</p>
<p>下面，通过 WWDC 的一个例子来说明： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> point2 <span class="operator">=</span> point1</span><br><span class="line">point2.x <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
其内存分配及布局如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/struct-in-stack.png?x-oss-process=image/resize,w_800" /></p>
<p>上述 <code>Struct</code> 的内存是在栈区分配的。将 <code>point1</code>
赋值给 <code>point2</code>
会在栈区分配一块内存区域，创建新的实例。两者相互独立，操作互不影响。</p>
<h2 id="堆区分配">堆区分配</h2>
<p>引用类型，如：类，默认分配在堆区。堆区的内存采用完全二叉树的形式进行维护，多次进行分配/销毁之后，堆区的内存空间就能难连续。因此，在分配内存时，需要查询可用的内存，所以比栈区的分配速度更慢。</p>
<p>下面，通过 WWDC 的一个例子来说明： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> point2 <span class="operator">=</span> point1</span><br><span class="line">point2.x <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
其内存分配及布局如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/class-in-heap.png?x-oss-process=image/resize,w_800" /></p>
<p>上述 <code>Class</code> 的内存是在堆区分配的，栈区仅仅分配了
<code>point1</code> 和 <code>point2</code>
两个指针。值得注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（本例中是
<code>Double</code> 类型的 <code>x</code>,
<code>y</code>），还分配了两个字段：<strong><code>type</code></strong>、<strong><code>refCount</code></strong>。其中，<code>type</code>
表示类型，<code>refCount</code> 表示引用计数。</p>
<h2 id="小结">小结</h2>
<p>从内存分配角度而言，<code>Class</code>
在堆区分配，使用了指针，通过引用计数进行管理，具有更强大的特性，但是性能较低。</p>
<p>因此，对于需要频繁分配内存的需求，应尽量使用 <code>Struct</code> 代替
<code>Class</code>。因为栈区的内存分配速度更快，更安全。</p>
<h1 id="引用计数">引用计数</h1>
<p>在上述堆区分配中提到，对象在堆区初始化时会额外分配两个字段，其中一个就是用于引用计数。Swift
通过引用计数管理堆区的对象内存，当引用计数为 0 时，Swift
会将对应的内存释放。一方面，引用计数的管理是一个非常高频的操作，另一方面，由于对象处于堆中，还需额外考虑多线程安全，所以产生引用计数的操作会有较高的性能消耗。</p>
<p>对于数据结构而言，只要包含引用类型，就会出现堆区分配。一旦产生堆区分配，则必然出现引用计数。下面，以一个例子来说明：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Label</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">UIFont</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> label1 <span class="operator">=</span> <span class="type">Label</span>(text: <span class="string">&quot;Hi&quot;</span>, font: font)</span><br><span class="line"><span class="keyword">let</span> label2 <span class="operator">=</span> label1</span><br></pre></td></tr></table></figure> 其内存分配及布局如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/struct-with-reference-type.png?x-oss-process=image/resize,w_800" /></p>
<p>对比 <code>Struct Label</code> 和前文的
<code>Class Point</code>，虽然属性数量相同，但是
<code>Struct Label</code> 产生的引用计数要比 <code>Class Point</code>
多一倍！</p>
<p>如下图所示，是关于复杂 <code>Struct</code> 和 <code>Class</code>
结构引用计数数量的对比。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/double-reference-count.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/reference-count-of-wrapper-class.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="小结-1">小结</h2>
<p>对于 <code>Struct</code>
类型，再次引用时会触发内存拷贝，由此引用计数数量会呈倍数增长；对于
<code>Class</code> 类型，则只会增加一次引用计数。</p>
<p>因此，我们应该尽量避免在 <code>Struct</code>
类型中包含引用类型，因为这可能产生大量的引用计数。</p>
<p>对于常用的引用类型 <code>String</code>，我们可以使用精确类型
<code>UUID</code> 或者 <code>Enum</code> 来替代。</p>
<h1 id="派发方式">派发方式</h1>
<p>派发方式，也可称为 <strong>函数派发</strong> 或
<strong>方法派发</strong>，是程序调用一个函数的机制。编译型语言有三种派发方式：</p>
<ul>
<li><strong>直接派发</strong>（Direct Dispatching）</li>
<li><strong>函数表派发</strong>（Table Dispatch）</li>
<li><strong>消息派发</strong>（Message Dispatch）</li>
</ul>
<p>根据函数调用能否在编译时或运行时确定，可以将派发机制分成两种类型：</p>
<ul>
<li><strong>静态派发</strong>（Static Dispatching）</li>
<li><strong>动态派发</strong>（Dynamic Dispatching）</li>
</ul>
<p>其中，直接派发属于静态派发，函数表派发、消息派发属于动态派发。</p>
<p>大多数编程语言都会支持一到两种派发方式，Java
默认使用函数表派发，但是可以通过 <code>final</code>
修饰符改成直接派发。C++ 默认使用直接派发，但是可以通过
<code>virtual</code> 修饰符改成函数表派发。Objective-C
总是使用消息派发，但是允许开发者使用 C 直接派发来获得性能的提升。</p>
<p>下面，依次来介绍这三种派发方式。</p>
<h2 id="直接派发">直接派发</h2>
<p>直接派发是最快的，原因是调用的指令少，而且还可以通过编译器进行优化，如：代码内联。其缺点是缺少动态性，因此无法支持继承。</p>
<p>下面，以一个例子来说明： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">pointDraw</span>(<span class="keyword">_</span> <span class="params">point</span>: <span class="type">Point</span>) &#123;</span><br><span class="line">    point.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">pointDraw(point)</span><br><span class="line"><span class="comment">// point.draw()</span></span><br></pre></td></tr></table></figure>
在这个情况下，编译器会对代码进行内联优化，调用 <code>pointDraw()</code>
方法会变成直接调用
<code>point.draw()</code>。这样，函数调用栈会减少一层，从而能够进一步提升性能。</p>
<h2 id="函数表派发">函数表派发</h2>
<p>函数表派发是编译型语言中为实现动态行为而使用的一种最常见的实现方式。函数表使用一个数组来存储类所声明的每一个函数的指针。大部分语言将其称为“virtual
table”（虚函数表），Swift 中也称为 “virtual table”。除此之外，Swift
还包含 “witness table”（见证表），主要用于实现
协议类型和泛型的动态派发。</p>
<p>在函数表派发的实现中，每一个类都会维护一个函数表，里面记录着所有的所有的函数指针。如果子类将父类的函数
<code>override</code>，那么子类的函数表只会保存 <code>override</code>
之后的函数指针。如果子类添加新的函数，则会在子类的函数表的最后插入新的函数指针。运行时会根据对应类的函数表去查找要指定的函数。</p>
<p>下面，以一个例子来说明： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClasss</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">method1</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">method2</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>: <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">method2</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">method3</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objc <span class="operator">=</span> <span class="type">ChildClass</span>()</span><br><span class="line">obj.method2()</span><br></pre></td></tr></table></figure> 在这个情况下，编译器会为
<code>ParentClass</code> 和 <code>ChildClass</code>
各自创建一个函数表。如下图所示，展示了 <code>ParentClass</code> 和
<code>ChildClass</code> 函数表中各个方法在内存中的布局。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/method-table.png?x-oss-process=image/resize,w_800" /></p>
<p>当一个函数被调用时，会经历以下几个步骤：</p>
<ul>
<li>读取对象 <code>0xB00</code> 的函数表。</li>
<li>读取函数表中对应的索引项。<code>method2</code> 的索引是
1（偏移量），即 <code>0xB00+1</code>。</li>
<li>根据索引项的记录，跳转至函数位置。<code>method2</code> 的位置是
<code>0x222</code>。</li>
</ul>
<p>查表是一种简单、易实现，且性能可预知的实现方式。一方面，由于多了一次查找和跳转，另一方面，由于编译器无法通过类型推导进一步进行优化，所以相比直接派发而言，函数表派发的性能稍差。</p>
<h2 id="消息派发">消息派发</h2>
<p>消息派发是一种更加动态的函数调用方式。ObjC 中的
KVO、UIAppearence、CoreData
都是对这种机制的运用。消息派发可以在运行时改变函数的行为，如：ObjC 中的
swizzling 技术。消息派发甚至还可以在运行时修改对象的继承关系，如：ObjC
中的 isa-swizzling 技术。</p>
<p>下面，以一个例子来说明： <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">func</span> <span class="title function_">method1</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">func</span> <span class="title function_">method2</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>: <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">method2</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">func</span> <span class="title function_">method3</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个情况下，会利用 Objective-C
的运行时进行消息派发。每个类只包含自己所定义的方法，一旦调用的方法不存在，会通过父类指针，去父类中进行查找，以此类推。如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/message-dispatch.png?x-oss-process=image/resize,w_800" /></p>
<p>当消息被派发时，运行时会顺着继承关系向上查找被调用的方法。很显然，消息派发要比函数表派发的效率更低。为了能够提升消息派发的性能，一般都会将查找进行缓存，从而让效率接近函数表派发。</p>
<h2 id="swift-派发方式">Swift 派发方式</h2>
<p>Swift 支持上述三种派发方式，那么 Swift
是如何选择派发方式呢？事实上，影响 Swift 的派发方式有以下几个方面：</p>
<ul>
<li><strong>声明位置</strong>（Declare Location）</li>
<li><strong>指定派发</strong>（Specifying Dispatch Behavior）</li>
<li><strong>优化派发</strong>（Optimize Dispatch Behavior）</li>
</ul>
<h3 id="声明位置">声明位置</h3>
<p>在 Swift 中，一个函数有两个可以声明的位置。</p>
<ul>
<li>初始声明的作用域</li>
<li>扩展声明的作用域</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始声明的作用域</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">mainMethod</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展声明的作用域</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">extensionMethod</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，初始声明的作用域中的函数 <code>mainMethod</code> 会使用
<strong>函数表派发</strong>；扩展声明的作用域中的函数
<code>extensionMethod</code> 会使用 <strong>直接派发</strong>。</p>
<p>上述例子是关于 <code>Class</code>
类型中不同的声明位置对于派发方式的影响。事实上，不同的类型的作用域中声明的函数，派发方式也不一定相同。下表展示了默认情况下，类型、声明位置与派发方式的关系图。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Initial Declaration</th>
<th style="text-align: center;">Extension Declaration</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Value Type</strong></td>
<td style="text-align: center;">static</td>
<td style="text-align: center;">static</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Protocol</strong></td>
<td style="text-align: center;">table</td>
<td style="text-align: center;">static</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Class</strong></td>
<td style="text-align: center;">table</td>
<td style="text-align: center;">static</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>NSObject Subclass</strong></td>
<td style="text-align: center;">table</td>
<td style="text-align: center;">message</td>
</tr>
</tbody>
</table>
<p>上表的总结有以下几点：</p>
<ul>
<li>值类型：无论初始声明还是扩展声明，都使用
<strong>直接派发</strong>。</li>
<li><code>Protocol</code> 类型：初始声明使用
<strong>函数表派发</strong>，扩展声明使用
<strong>直接派发</strong>。即默认实现均使用</li>
<li><code>Class</code> 类型：初始声明使用
<strong>函数表派发</strong>，扩展声明使用
<strong>直接派发</strong>。</li>
<li><code>NSObject</code> 类型：初始声明使用
<strong>函数表派发</strong>，扩展声明使用
<strong>消息派发</strong>。</li>
</ul>
<h3 id="指定派发">指定派发</h3>
<p>Swift 有一些修饰符可以指定派发方式。</p>
<h4 id="final"><code>final</code></h4>
<p><code>final</code> 修饰符允许类中的函数使用
<strong>直接派发</strong>。<code>final</code>
修饰符会让函数失去动态性。任何函数都可以使用 <code>final</code>
修饰符，包括 <code>extension</code> 中原本就是直接派发的函数。</p>
<p>需要注意的是，Objective-C 的运行时获取不到使用 <code>final</code>
修饰符的函数的 <code>selector</code>。</p>
<h4 id="dynamic"><code>dynamic</code></h4>
<p><code>dynamic</code> 修饰符允许类中的函数使用
<strong>消息派发</strong>。使用 <code>dynamic</code>
修饰符之前，必须导入 <code>Foundation</code> 框架，因为框架中包含了
<code>NSObject</code> 和 Objective-C 的运行时。<code>dynamic</code>
修饰符可以修饰所有的 <code>NSObject</code> 子类和 Swift 原生类。</p>
<p>此外，<code>dynamic</code>
修饰符可以让扩展声明（<code>extension</code>）中的函数也能够被
<code>override</code>。</p>
<h4 id="objc-nonobjc"><code>@objc</code> &amp;
<code>@nonobjc</code></h4>
<p><code>@objc</code> 和 <code>@nonobjc</code>
显式地声明了一个函数能否被 Objective-C 运行时捕获到。</p>
<p><code>@objc</code> 典型的用法就是给 <code>selector</code>
一个命名空间 <code>@objc(xxx_methodName)</code>，从而允许该函数可以被
Objective-C 的运行时捕获到。</p>
<p><code>@nonobjc</code>
会改变派发方式，可以禁用消息派发，从而阻止函数注册到 Objective-C
的运行时中。<code>@nonobjc</code> 的效果类似于
<code>final</code>，使用的场景几乎也是一样，个人猜测，<code>@nonobjc</code>
主要是用于兼容 Objective-C，<code>final</code>
则是作为原生修饰符，以用于让 Swift 写服务端之类的代码。</p>
<h4 id="final-objc"><code>final @objc</code></h4>
<p>在使用 <code>final</code> 修饰符的同时，可以使用 <code>@objc</code>
修饰符让函数可以使用消息派发。同时使用这两个修饰符的结果是：调用函数时会使用直接派发，但也会在
Objective-C 运行时中注册响应的 <code>selector</code>。函数可以响应
<code>perform(seletor:)</code> 以及别的 Objective-C
特性，但在直接调用时又可以具有直接派发的性能。</p>
<h4 id="inline"><code>@inline</code></h4>
<p><code>@inline</code> 修饰符告诉编译器函数可以使用直接派发。</p>
<h3 id="派发优化">派发优化</h3>
<p>Swift 会在这上面做优化，比如一个函数没有 override，Swift
就可能会使用直接派发的方式，所以如果属性绑定了 KVO，那么属性的 getter 和
setter 方法可能会被优化成直接派发而导致 KVO 的失效，所以记得加上 dynamic
的修饰来保证有效。后面 Swift 应该会在这个优化上去做更多的处理。</p>
<h2 id="小结-2">小结</h2>
<p>下表总结了引用类型、修饰符对 Swift 派发方式的影响。</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Direct Dispatch</th>
<th style="text-align: center;">Table Dispatch</th>
<th style="text-align: center;">Message Dispatch</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>NSObject</strong></td>
<td style="text-align: center;"><code>@nonobjc</code>,
<code>final</code></td>
<td style="text-align: center;">Initial Declaration</td>
<td style="text-align: center;">Extension Declaration,
<code>dynamic</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Class</strong></td>
<td style="text-align: center;">Extension Declaration,
<code>final</code></td>
<td style="text-align: center;">Initial Declaration</td>
<td style="text-align: center;"><code>dynamic</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Protocol</strong></td>
<td style="text-align: center;">Extension Declaration</td>
<td style="text-align: center;">Initial Declaration</td>
<td style="text-align: center;"><code>@objc</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Value Type</strong></td>
<td style="text-align: center;">All Method</td>
<td style="text-align: center;">n/a</td>
<td style="text-align: center;">n/a</td>
</tr>
</tbody>
</table>
<h1 id="总结">总结</h1>
<p>本文总结了评测 Swift
性能的几个方面，我们可以通过内存分配、引用计数、派发方式等几个方面了对
Swift 代码进行优化。</p>
<p>总体而言，对于内存分配，我们应该尽量使用栈区内存分配；对于引用计数，我们需要进行权衡，使用引用计数能带来灵活性，但也会带来性能开销；对于派发方法，我们应该尽量使用更加高效的派发方式，同时也需要进行权衡，动态派发能够带来更强大的编程特性，但也会带来性能开销。</p>
<h1 id="扩展">扩展</h1>
<ol type="1">
<li><a
href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html">Friday
Q&amp;A 2010-01-29: Method Replacement for Fun and Profit</a></li>
<li><a
href="https://stackoverflow.com/questions/38877465/are-method-swizzling-and-isa-swizzling-the-same-thing/38878119#38878119">Are
method swizzling and isa siwzzling the same thing?</a></li>
<li><a href="https://developer.apple.com/swift/blog/?id=27">Increasing
Performance by Reducing Dynamic Dispatch</a></li>
</ol>
<h1 id="参考">参考</h1>
<ol type="1">
<li>WWDC 2016, Session 416, Understanding Swift Performance.</li>
<li>LLVM Developer's Meeting: "Implementing Swift Generics".</li>
<li><a
href="https://www.rightpoint.com/rplabs/switch-method-dispatch-table">Method
Dispatch in Swift</a></li>
<li><a href="https://juejin.im/post/5a6fe89af265da3e290c7cb3">Why Swift?
Generics(泛型), Collection(集合类型), POP(协议式编程), Memory
Management(内存管理)</a></li>
<li><a
href="https://juejin.im/post/5bdbdc876fb9a049f36186c3">【基本功】深入剖析Swift性能优化</a></li>
<li><a href="https://www.youtube.com/watch?v=ERYNyrfXjlg">GOTO 2016 •
Exploring Swift Memory Layout • Mike Ash</a></li>
<li><a href="https://kemchenj.github.io/2016-12-25-1/">深入理解 Swift
派发机制</a></li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 性能优化(2)——协议与泛型的实现</title>
    <url>/2020/02/19/swift-performance-protocol-type-generic-type/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>前一篇文章《Swift
性能优化(1)——基本概念》中我们提到了编程语言的派发方式，Swift
支持文中所提到的三种派发方式。其中，函数表派发是 Swift OOP
的底层支持，那么，Swift POP 以及泛型编程底层又是如何实现的呢？</p>
<span id="more"></span>
<p>本文，我们就来简单探讨一下协议和泛型的底层实现原理。如果想深入学习协议和泛型的更多细节和原理，建议去学习一下
Swift Intermediate Language
相关的内容。以后要是有时间，我也想去学习了解一下 SIL。</p>
<h1 id="协议类型-protocol-type">协议类型 Protocol Type</h1>
<p>首先我们举一个例子来看一下 OOP 是如何实现多态的。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Drawable</span> &#123; <span class="keyword">func</span> <span class="title function_">draw</span>() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> : <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y:<span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> : <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x1, y1, x2, y2:<span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> line <span class="operator">=</span> <span class="type">Line</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">1</span>, y2: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> drawables: [<span class="type">Drawable</span>] <span class="operator">=</span> [point, line]</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> drawables &#123;</span><br><span class="line">    d.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从上述代码可以看出，变量 <code>drawables</code> 是一个元素类型为
<code>Drawable</code> 的数组，由于 <code>class</code> 关键字标记了
<code>Drawable</code> 及其子类 <code>Point</code>、<code>Line</code>
都是引用类型，因此 <code>drawables</code>
的内存布局是固定的，数组里的每一个元素都是一个指针。如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/polymorphism-through-reference-semantics.png?x-oss-process=image/resize,w_800" /></p>
<p>接下来，我们再来看 OOP 是如何通过 <code>virtual table</code>
来实现动态派发的。如下图所示</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/polymorphism-through-v-table-dispatch.png?x-oss-process=image/resize,w_800" /></p>
<p>运行时执行 <code>d.draw()</code>，会根据 <code>d</code>
所指向的对象的 <code>type</code>
字段索引到该类型所对应的函数表，最终调用正确的方法。</p>
<p>下面我们举一个例子看一下 POP 是如何实现多态的。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Drawable</span> &#123; <span class="keyword">func</span> <span class="title function_">draw</span>() &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> : <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> : <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x1, y1, x2, y2: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedLine</span>: <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x1, y1, x2, y2: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> line <span class="operator">=</span> <span class="type">Line</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">1</span>, y2: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> sharedLine <span class="operator">=</span> <span class="type">SharedLine</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">1</span>, y2: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> drawables: [<span class="type">Drawable</span>] <span class="operator">=</span> [point, line, sharedLine]</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> drawables &#123;</span><br><span class="line">    d.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
需要注意的是，此时 <code>Point</code> 和 <code>Line</code> 都是值类型的
<code>struct</code>，只有 <code>SharedLine</code> 是引用类型的
<code>class</code>，并且 <code>Drawable</code> 不再是一个基类，而是一个
<strong>协议类型</strong>（Protocol Type）。</p>
<p>那么此时，变量 <code>drawables</code>
的内存布局是怎样呢？毕竟，运行时 <code>d</code>
可能是遵循协议的任意类型，类型不同，内存大小也会不同。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/polymorphism-without-inheritance-or-reference-semantics.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，在这种情况下，变量 <code>drawables</code>
中存储的元素是一种特殊的数据类型：<strong>Existential
Container</strong>。</p>
<h2 id="existential-container">Existential Container</h2>
<p>Existential Container
是编译器生成的一种特殊的数据类型，用于管理遵守了相同协议的协议类型。因为这些数据类型的内存空间尺寸不同，使用
Extential Container 进行管理可以实现存储一致性。</p>
<p>我们在上述代码的基础上执行下面的示例代码。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> line <span class="operator">=</span> <span class="type">Line</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">1</span>, y2: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> sharedLine <span class="operator">=</span> <span class="type">SharedLine</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">1</span>, y2: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(MemoryLayout.size(ofValue: point))</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(MemoryLayout.size(ofValue: line))</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(MemoryLayout.size(ofValue: sharedLine))</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> drawables: [<span class="type">Drawable</span>] <span class="operator">=</span> [point, line, sharedLine]</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> drawables &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(MemoryLayout.size(ofValue: d))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始类型的内存大小，单位：字节</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment">// 协议类型的内存大小，单位：字节</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure></p>
<p>由于本机内存对齐是 8 字节，可见 <code>Extension Container</code>
类型占据 5 个内存单元（也称
<strong>词</strong>，Word）。其结构如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/existential-container.png?x-oss-process=image/resize,w_800" /></p>
<ul>
<li>3 个词作为 <strong>Value Buffer</strong>。</li>
<li>1 个词作为 <strong>Value Witness Table</strong> 的索引。</li>
<li>1 个词作为 <strong>Protocol Witness Table</strong> 的索引。</li>
</ul>
<p>下面，我们依次进行介绍。</p>
<h3 id="value-buffer">Value Buffer</h3>
<p>Value Buffer 占据 3 个词，存储的可能是值，也可能是指针。对于 Small
Value（存储空间小于等于 Value Buffer），可以直接内联存储在 Value Buffer
中。对于 Large Value（存储空间大于 Value
Buffer），则会在堆区分配内存进行存储，Value Buffer
只存储对应的指针。如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/existential-container-inline-or-reference.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="value-witness-table">Value Witness Table</h3>
<p>由于协议类型的具体类型不同，其内存布局也不同，Value Witness Table
则是对协议类型的生命周期进行专项管理，从而处理具体类型的初始化、拷贝、销毁。如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/value-witness-table.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="protocol-witness-table">Protocol Witness Table</h3>
<p>Value Witness Table 管理协议类型的生命周期，Protocol Witness Table
则管理协议类型的方法调用。</p>
<p>在 OOP 中，基于继承关系的多态是通过 Virtual Table 实现的；在 POP
中，没有继承关系，因为无法使用 Virtual Table
实现基于协议的多态，取而代之的是 Protocol Witness Table。</p>
<blockquote>
<p>注：关于 Virtual Table 和 Protocol Witness Table
的区别，我的理解是：<br />
它们都是一个记录函数地址的列表（即函数表），只是它们的生成方式是不同的。<br />
对于 Virtual
Table，在编译时，子类的函数表是通过对基类函数表进行拷贝、覆写、插入等操作生成的。<br />
对于 Protocol Witness
Table，在编译时，函数表是通过检查具体类型对协议的实现，直接生成的。</p>
</blockquote>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/protocol-witness-table.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="协议类型存储属性优化">协议类型存储属性优化</h2>
<p>由上述 Value Buffer 相关内容可知，协议类型的存储分两种情况</p>
<ul>
<li>对于 Small Value，直接内联存储在 Existential Container 的 Value
Buffer 中；</li>
<li>对于 Large Value，通过堆区分配进行存储，使用 Existential Containter
的 Value Buffer 进行索引。</li>
</ul>
<p>那么，协议类型的存储属性是如何拷贝的呢？事实上，对于 Small
Value，就是直接拷贝 Existential Container，值也内联在其中。但是，对于
Large Value，Swift 采用了 <strong>Indirect Storage With
Copy-On-Write</strong> 技术进行了优化。</p>
<p>这种技术可以提高内存指针利用率，降低堆区内存消耗，从而实现性能提升。该技术的原理是：拷贝时仅仅拷贝
Extension Container，当修改值时，先检测引用计数，如果引用计数大于
1，则开辟新的堆区内存。其实现伪代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LineStorage</span> &#123; </span><br><span class="line">    <span class="keyword">var</span> x1, y1, x2, y2:<span class="type">Double</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> : <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> storage : <span class="type">LineStorage</span></span><br><span class="line">    <span class="keyword">init</span>() &#123; storage <span class="operator">=</span> <span class="type">LineStorage</span>(<span class="type">Point</span>(), <span class="type">Point</span>()) &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">draw</span>() &#123; <span class="operator">…</span> &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">move</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>isUniquelyReferencedNonObjc(<span class="operator">&amp;</span>storage) &#123; </span><br><span class="line">        <span class="comment">// 如果存在多份引用，则开启新内存，否则直接修改</span></span><br><span class="line">            storage <span class="operator">=</span> <span class="type">LineStorage</span>(storage)</span><br><span class="line">        &#125;</span><br><span class="line">        storage.start <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型类型-generic-type">泛型类型 Generic Type</h1>
<p>下面，我们来讨论泛型的实现。首先来看一个例子。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">foo</span>&lt;<span class="type">T</span>: <span class="type">Drawable</span>&gt;(<span class="params">local</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    bar(local)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">bar</span>&lt;<span class="type">T</span>: <span class="type">Drawable</span>&gt;(<span class="params">local</span>: <span class="type">T</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">foo(point)</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，泛型方法的调用过程大概如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// foo 方法执行时，Swift 将泛型 T 绑定为具体类型。示例中是 Point</span><br><span class="line">foo(point) --&gt; foo&lt;T = Point&gt;(point)</span><br><span class="line">// 调用内部 bar 方法时，Swift 会使用已绑定的变量类型 Point 进一步绑定到 bar 方法的泛型 T 上。</span><br><span class="line">bar(local) --&gt; bar&lt;T = Point&gt;(local)</span><br></pre></td></tr></table></figure></p>
<p>相比协议类型而言，泛型类型在调用时总是能确定类型，因此无需使用
Existential Container。在调用泛型方法时，只需要将 Value Witness
Table/Protocol Witness Table 作为额外参数进行传递。</p>
<blockquote>
<p>注：根据方法调用时数据类型是否确定可以将多态分为：<strong>静态多态</strong>（Static
Polymorphism）和 <strong>动态多态</strong>（Dynamic
Polymorphism）。<br />
在泛型类型调用方法时， Swift
会将泛型绑定为具体的类型。因此泛型实现的是静态多态。<br />
在协议类型调用方法时，类型是 Existential
Container，需要在方法内部进一步根据 pwt
进行方法索引。因此协议实现的是动态多态。</p>
</blockquote>
<h2 id="泛型特化">泛型特化</h2>
<p>我们以一个例子来说明编译器对于泛型的一种优化技术：<strong>泛型特化</strong>。
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">min</span>&lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt;(<span class="params">x</span>: <span class="type">T</span>, <span class="params">y</span>: <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y <span class="operator">&lt;</span> x <span class="operator">?</span> y : x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Int</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">min</span>(a, b)</span><br></pre></td></tr></table></figure> 上述代码，编译器在编译期间就能通过类型推导确定调用
<code>min()</code> 方法时的类型。此时，编译器就会通过泛型特化，进行
<strong>类型取代</strong>（Type Substitute），生成如下的一个方法：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">min</span>&lt;<span class="type">Int</span>&gt;(<span class="params">x</span>: <span class="type">Int</span>, <span class="params">y</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y <span class="operator">&lt;</span> x <span class="operator">?</span> y :x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
泛型特化会为每个类型生成一个对应的方法。那么是不是会出现代码空间爆炸的情况呢？事实上，并不会出现这种情况。因为编译器可以进行代码内联以及进一步的优化，从而降低方法数量并提高性能。</p>
<h3 id="全模块优化">全模块优化</h3>
<p>泛型特化的前提是编译器在编译期间可以进行类型推导，这就要求在编译时提供类型的上下文。如果调用方和类型是单独编译的，就无法在编译时进行类型推导，因此无法使用泛型特化。为了能够在编译期间提供完整的上下文，我们可以通过
<strong>全模块优化</strong>（Whole Module Optimization）
编译选项，实现调用方和类型在不同文件时也能进行泛型特化。</p>
<p>全模块优化是用于 Swift 编译器的优化机制。从 Xcode 8
开始默认开启。</p>
<h1 id="总结">总结</h1>
<p>本文，我们了解了协议类型和泛型类型对于多态的实现，从中我们也看到了编译器对于
Swift 性能的优化发挥了巨大的作用，如：泛型特化、生成代码实现
Copy-On-Write。</p>
<p>此外，我们了解了关于泛型和协议关于性能优化的启示，能够我们制定技术方案时进行权衡。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>WWDC 2016, Session 416, Understanding Swift Performance.</li>
<li>LLVM Developer’s Meeting: “Implementing Swift Generics”.</li>
<li><a
href="https://github.com/apple/swift/blob/master/docs/SIL.rst">Swift
Intermediate Languages(SIL)</a></li>
<li><a
href="https://www.fewbutripe.com/talks/#protocol-witnesses">Protocol
Witnesses</a></li>
<li><a
href="https://medium.com/@pofattseng/%E9%87%8D%E6%96%B0%E6%AA%A2%E8%A6%96-swift-%E7%9A%84-protocol-%E4%BA%8C-2bca0d58cb9">重新檢視
Swift 的 Protocol (二）</a></li>
<li><a
href="https://medium.com/@pofattseng/%E9%87%8D%E6%96%B0%E6%AA%A2%E8%A6%96-swift-%E7%9A%84-protocol-%E4%B8%89-d5e465fe8195">重新檢視
Swift 的 Protocol (三）</a></li>
</ol>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>泛型</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 类型擦除</title>
    <url>/2021/10/10/swift-type-erase/</url>
    <content><![CDATA[<p>在 <a
href="http://chuquan.me/2021/09/25/swift-generic-protocol">《Swift
泛型协议》</a> 中，我们探讨了如何基于类型擦除技术解决 Swift
泛型协议的存储问题，通过定义一个类型擦除包装器 <code>AnyPrinter</code>
解决了泛型协议 <code>Printer</code>
的存储问题。但是，<code>AnyPrinter</code> 并没有显式地引用
<code>base</code>
实例，因为当我们定义一个泛型类型的属性时，编译器会报错。</p>
<span id="more"></span>
<p>如果我们在 <code>AnyPrinter</code> 中定义一个 <code>base</code>
属性用于显式引用实例。当我们将 <code>base</code> 声明为
<code>Printer</code>，编译器会报错：<code>Cannot specialize non-generic type 'Printer'</code>；当我们将
<code>base</code> 声明为
<code>Printer&lt;T&gt;</code>，编译器会报错：<code>Protocol 'Printer' can only be used as a generic constraint because it has Self or associated type requirements</code>。如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyPrinter</span>&lt;<span class="title class_">U</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T</span> <span class="operator">=</span> <span class="type">U</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Printer</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line">    <span class="comment">// Error: Protocol &#x27;Printer&#x27; can only be used as a generic constraint because it has Self or associated type requirements</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Printer</span></span><br><span class="line">    <span class="comment">// Error: Cannot specialize non-generic type &#x27;Printer&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Base</span>: <span class="type">Printer</span>&gt;(<span class="params">base</span> : <span class="type">Base</span>) <span class="keyword">where</span> <span class="type">Base</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">U</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.base <span class="operator">=</span> base</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        base.print(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们基于方法指针隐式地引用了 <code>base</code>
实例。如下所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyPrinter</span>&lt;<span class="title class_">U</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T</span> <span class="operator">=</span> <span class="type">U</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _print: (<span class="type">U</span>) -&gt; ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Base</span>: <span class="type">Printer</span>&gt;(<span class="params">base</span> : <span class="type">Base</span>) <span class="keyword">where</span> <span class="type">Base</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">U</span> &#123;</span><br><span class="line">        _print <span class="operator">=</span> base.print</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        _print(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文，我们就来探讨一下，在泛型协议中，如何显式地引用
<code>base</code> 实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中间类型">中间类型</h1>
<p>上述实现中，在 <code>AnyPrinter</code> 中定义了一个 <code>base</code>
属性，在声明其类型时，无论是声明为 <code>Printer&lt;T&gt;</code> 还是
<code>Printer</code>，编译器都会报错。为了解决这个问题，我们还是以那句经典名言为指导思想，<strong>实现一个包装类型作为
<code>base</code> 属性的类型</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p>
<p>这里我们需要另外定义两个类型，两者是基类和子类的关系，并且都遵循泛型协议
<code>Printer</code>。至于为什么定义两个类型，我们后面再解释。在 Swift
标准库实现中，经常使用 <code>box</code>
命名中间类型，或者说是盒子类型、包装类型，这里我们同样以
<code>box</code> 进行命名。</p>
<h2 id="box-基类">Box 基类</h2>
<p>如下所示为 box 基类的实现，由于泛型类型
<code>_AnyPrinterBoxBase</code> 遵循了 <code>Printer</code>
泛型协议，类型参数会自动绑定至关联类型。在真正使用时，<code>_AnyPrinterBoxBase</code>
并不会保持抽象，它最终会被绑定到某个特定类型。 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_AnyPrinterBoxBase</span>&lt;<span class="title class_">E</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T</span> <span class="operator">=</span> <span class="type">E</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">E</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="box-子类">Box 子类</h2>
<p>如下所示为 box 子类的实现，其内部封装了一个实例
<code>var base: Base</code>，并且将方法传递给了实例。<strong>这个
<code>base</code> 实例才是 <code>Printer</code>
协议真正的实现者</strong>。在 <code>_PrinterBox</code>
类型声明的第一行中，其自动将 <code>Base.T</code> （<code>Printer</code>
协议的关联类型）绑定为 <code>_AnyPrinterBoxBase.T</code>
（<code>_AnyPrinterBoxBase</code> 的类型参数） 。此时，我们也无需再在
<code>_PrinterBox</code> 内部通过 <code>typealias T == xxx</code>
的方式手动进行类型绑定。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_PrinterBox</span>&lt;<span class="title class_">Base</span>: <span class="title class_">Printer</span>&gt;: <span class="title class_">_AnyPrinterBoxBase</span>&lt;<span class="title class_">Base</span>.<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Base</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">base</span>: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base <span class="operator">=</span> base</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">Base</span>.<span class="type">T</span>) &#123;</span><br><span class="line">        base.print(val: val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型擦除">类型擦除</h2>
<p>在实现了中间类型后，我们再来修改类型擦除包装器
<code>AnyPrinter</code> 的内部实现。具体如下所示，由于我们使用中间类型
box 对 <code>base</code> 进行了封装，所以这里我们需要将
<code>AnyPrinter</code> 中的 <code>base</code> 的命名修改为
<code>_box</code>。当我们调用 <code>print</code> 方法时，其内部会将
<code>print</code> 方法转发至 <code>_box</code>，而 <code>_box</code>
内部又会将 <code>print</code> 转发至 <code>base</code>
这个真正的实现者。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AnyPrinter</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _box: _AnyPrinterBoxBase<span class="operator">&lt;</span><span class="type">T</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Base</span>: <span class="type">Printer</span>&gt;(<span class="keyword">_</span> <span class="params">base</span>: <span class="type">Base</span>) <span class="keyword">where</span> <span class="type">Base</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">T</span> &#123;</span><br><span class="line">        _box <span class="operator">=</span> _PrinterBox(base)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        _box.print(val: val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们再来看前文留下的问题：为什么中间层需要定义基类和子类两个类型。事实上一开始，我尝试只定义一个
box 类型 <code>_PrinterBox</code>，如下所示，但是编译器会报错：
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_PrinterBox</span>&lt;<span class="title class_">Base</span>&gt;: <span class="title class_">Printer</span> &#123;</span><br><span class="line">    typalias <span class="type">T</span> <span class="operator">=</span> <span class="type">Base</span></span><br><span class="line">    <span class="keyword">var</span> base: <span class="type">Base</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">Base</span>: <span class="type">Printer</span>&gt;(<span class="keyword">_</span> <span class="params">base</span>: <span class="type">Base</span>) <span class="keyword">where</span> <span class="type">Base</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.base <span class="operator">=</span> base</span><br><span class="line">        <span class="comment">// Error: Cannot assign value of type &#x27;Base&#x27; to type &#x27;Base&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>(<span class="params">val</span>: <span class="type">Base</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个报错看上去有点奇怪，我猜测其原因：虽然构造器通过
<code>where Base.T == T</code> 对 <code>Base</code>
类型进行了约束，但是却并没有将 <code>Printer.T</code> 绑定至
<code>Base</code> 类型。不过奇怪的是，我加了
<code>typealias T = Base</code>
也不管用。如果有人知道原因，可以留言告诉我。最终的解决方案是，实现了两个基类和子类两个类型，通过子类的声明对
<code>Printer.T</code> 进行类型绑定。</p>
<p>最后，我们再来简单对比一下类型擦除的两种方案。如下所示，分别是隐式引用
base 和显式引用 base。其中，<code>Logger</code> 才是
<code>Printer</code> 协议真正的实现者。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/type-erase-02.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/type-erase-03.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="具体应用">具体应用</h1>
<p>Codable
源码大量使用了面向协议编程，为了解决泛型协议的存储，其也采用了与上述类似的类型擦除方案。如下所示分别是
Codable
中编解码的核心设计实现，里面涉及到非常多的类，本质上还是在解决泛型擦除。其中，<code>_KeyedEncodingContainerBox</code>
和 <code>_KeyedDecodingContainerBox</code> 中对于 <code>base</code>
的命名有所不同，这里命名成了
<code>concrete</code>。另外，<code>__JSONKeyedEncodingContainer</code>
和 <code>__JSONKeyedDecodingContainer</code> 虽然分别是
<code>KeyedEncodingContainerProcotol</code> 和
<code>KeyedDecodingContainerProtocol</code>
的真正实现者，但是它们内部各自将具体的编码和解码细节转交给了
<code>__JSONEncoder</code> 和 <code>__JSONDecoder</code>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-04.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/codable-type-erase-05.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>事实上，曾经我也尝试阅读过 Codable 源码，当时对 Swift
类型擦除并不太了解，从而导致我根本读不懂 Codable
的源码在干什么，为什么要有这么多的类进行方法转发。如今，在了解了 Swift
类型擦除之后，Codable
的设计架构一下子就清晰了，后续有时间我们再来探讨一下 Codable
的源码实现。</p>
<p>总而言之，只有深入了解了 Swift
类型擦除后，我们才能领会面向协议编程的精髓以及相关设计理念。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>泛型协议</tag>
        <tag>类型擦除</tag>
        <tag>box</tag>
      </tags>
  </entry>
  <entry>
    <title>系统理解 iOS 自动布局</title>
    <url>/2019/09/25/systematic-understand-ios-autolayout/</url>
    <content><![CDATA[<p>最近准备阅读 Masonry
的源代码，学习一下其中的设计思想。然而，阅读了一部分之后，发现自己对 iOS
自动布局了解的不够系统，也不够深入。于是，准备好好学习学习 iOS
自动布局的基础知识。</p>
<span id="more"></span>
<p>下面是我对 iOS
布局系统的一些整理和总结，当然，自动布局是其中的重点。</p>
<h1 id="概述">概述</h1>
<p>苹果在 iPhone 4 时推出了绝对布局，随着 iOS 设备不断增多，苹果在 iOS 6
时又推出了自动布局（Auto
Layout）。在自动布局逐步完善的过程中，苹果也推出了诸如：Size
Class、Stack View、UILayoutGuide
等技术，但是它们的本质都是基于自动布局。</p>
<h1 id="来源">来源</h1>
<p>1997 年，Alan Boring，Kim Marriott，Peter Stuckey
等人在它们发表的论文《Solving Linear Arithmetic Constraints for User
Interface Applications》中提出了解决布局问题的 <strong>Cassowary
constraints-solving</strong> 算法实现。</p>
<p>2011 年，苹果将 Cassowary 算法应用到了自家的布局引擎 Auto Layout
中。</p>
<p><strong>Cassorwary</strong> &gt; Cassowary 能够有效解析
<strong>线性等式系统</strong> 和
<strong>线性不等式系统</strong>，用来表示用户界面的相等关系和不等关系。基于此，Cassowary
开发了一种规则系统，可以通过 <strong>约束</strong>
来描述视图之间的关系。约束就是规则，能够表示出一个视图相对于另一个视图的位置。</p>
<p>由于 Cassowary
算法的先进性，很多编程语言都实现了对应的库，如：JavaScript、.NET、Java、SmallTalk、C++。</p>
<h1 id="约束">约束</h1>
<p>Cassowary 的核心是基于 <strong>约束（Constraint）</strong>
来描述视图之间的关系。约束本质上就是一个方程式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">item1.attribute1 = multiplier × item2.attribute2 + constant</span><br></pre></td></tr></table></figure>
<p>下面我们通过一个简单的约束来介绍约束方程式。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/view-formula.png?x-oss-process=image/resize,w_800" /></p>
<p>该约束表示红色视图的左边界在蓝色视图的右边界再往右 8
个像素点。<strong>注意，这里的 <code>=</code>
并不是赋值的意思，而是相等的意思</strong>。</p>
<p>在自动布局系统中，约束不仅可以定义两个视图之间的关系，还可以定义单个视图的两个不同属性之间的关系，如：在视图的高度和宽度之间设置比例。<strong>一般而言，一个视图需要四个约束来决定其大小和位置</strong>。</p>
<h2 id="约束规则">约束规则</h2>
<p>上述约束方程式主要描述了两个视图属性之间的关系。那么，我们来看一下
iOS 定义了哪些属性和关系。</p>
<h3 id="属性">属性</h3>
<p>苹果使用 <code>NSLayoutAttribute</code>
类型的枚举值来表示布局属性，其主要包含以下这些属性： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutAttribute</span>) &#123;</span><br><span class="line">    <span class="comment">// 视图位置</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeft</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeRight</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTop</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeBottom</span>,</span><br><span class="line">    <span class="comment">// 视图前后</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeading</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTrailing</span>,</span><br><span class="line">    <span class="comment">// 视图宽高</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeWidth</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeHeight</span>,</span><br><span class="line">    <span class="comment">// 视图中心</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterX</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterY</span>,</span><br><span class="line">    <span class="comment">// 视图基线</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeLastBaseline</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeFirstBaseline</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 占位符，在与另一个约束的关系中没有用到某个属性时可以使用占位符</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeNotAnAttribute</span> = <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
值得注意的是，<code>NSLayoutAttribute</code> 有类似
<code>NSLayoutAttributeLeft</code> 和
<code>NSLayoutAttributeLeftMargin</code> 这样的枚举。两者的区别是：</p>
<ul>
<li><code>NSLayoutAttributeLeft</code> 表示视图的最左边；</li>
<li><code>NSLayoutAttributeLeftMargin</code>
表示视图的左边，距离最左边有多大的 margin 与视图的
<code>layoutMargins</code> 有关。</li>
</ul>
<p>关于 <code>layoutMargins</code> 我们会在下文提到。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/layout-attributes.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="关系">关系</h3>
<p>苹果使用 <code>NSLayoutRelation</code>
类型的枚举值来表示属性关系，其主要包含以下这些关系： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutRelation</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLayoutRelationLessThanOrEqual</span> = <span class="number">-1</span>,</span><br><span class="line">    <span class="built_in">NSLayoutRelationEqual</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSLayoutRelationGreaterThanOrEqual</span> = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="约束层级">约束层级</h2>
<p>约束描述两个视图之间的关系，但是前提是：两个视图必须属于同一个视图层级结构。
这种层级结构有两种：</p>
<ol type="1">
<li>一个视图是另一个视图的视图</li>
<li>两个视图在一个窗口下有一个非 <code>nil</code> 的公共祖先视图。</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/constraints-hiecharcy.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="约束优先级">约束优先级</h2>
<p>约束具有优先级。当布局引擎计算布局时，会按照优先级从高到低的顺序逐个计算。如果发现一个可选的约束无法被满足时，就会跳过这个约束，计算下一个约束。有时候，即使一个约束无法被正好适配，它依然可以影响布局。</p>
<p>苹果默认定义了 4
种优先级枚举值。除此之外，苹果允许创建其他的优先级，但是其范围必须在
1~1000 之间。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityRequired</span> = <span class="number">1000</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityDefaultHigh</span> = <span class="number">750</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityDefaultLow</span> = <span class="number">250</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityFittingSizeLevel</span> = <span class="number">50</span>; </span><br></pre></td></tr></table></figure></p>
<h1 id="约束创建">约束创建</h1>
<p>关于约束的创建，苹果提供了 Interface
Build，可以实现以非编程的方式创建约束。但是在大型项目中，我们主要还是以编程的方式创建约束。</p>
<p>以编程方式创建约束的方式主要有三种：</p>
<ul>
<li><strong>约束构造器（NSLayoutConstraint）</strong></li>
<li><strong>布局锚点（Layout Anchors）</strong></li>
<li><strong>可视化格式语言（Visual Format Language, VFL）</strong></li>
</ul>
<p>下面我们依次进行介绍。</p>
<h2 id="nslayoutconstraint">NSLayoutConstraint</h2>
<p>苹果使用 <code>NSLayoutConstraint</code>
类型表示约束。<code>NSLayoutConstraint</code>
类提供了一个构造方法可以直接创建约束。构造方法的各个参数对应着约束方程式的各个项。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)constraintWithItem:(<span class="type">id</span>)view1 </span><br><span class="line">                         attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1 </span><br><span class="line">                         relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation </span><br><span class="line">                            toItem:(<span class="type">id</span>)view2 </span><br><span class="line">                         attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 </span><br><span class="line">                        multiplier:(<span class="built_in">CGFloat</span>)multiplier </span><br><span class="line">                          constant:(<span class="built_in">CGFloat</span>)c;</span><br></pre></td></tr></table></figure></p>
<h2 id="layout-anchors">Layout Anchors</h2>
<p>苹果使用 <code>NSLayoutAnchor</code> 类型表示布局锚点。在介绍
<code>NSLayoutAnchor</code>
之前，我们需要介绍一些其他的概念，如：<code>UILayoutGuide</code>（使用
<code>NSLayoutAnchor</code> 时会用到）。</p>
<h3 id="uilayoutguide">UILayoutGuide</h3>
<p><code>UILayoutGuide</code> 是一个虚拟的矩形区域，可以认为是一个透明的
<code>UIView</code>，但是它不会被添加到视图层级，也不会拦截消息调用，它只是用来与
Auto Layout 交互。比如：3 个 <code>UIView</code>
排一行，相互之间的间隔相同。那么中间的间隔就可以用
<code>UILayoutGuide</code> 代替。</p>
<p>在了解 <code>UILayoutGuide</code> 之后，我们需要了解
<code>UIView</code> 的两个属性（<code>UILayoutGuide</code>
类型的实例）：</p>
<ul>
<li><code>layoutMarginsGuide</code>：首次出现于 iOS 9</li>
<li><code>safeAreaLayoutGuide</code>：首次出现于 iOS 11</li>
</ul>
<h4 id="layoutmarginsguide">layoutMarginsGuide</h4>
<p><code>UIView</code> 有一个 <code>UIEdgeInsets</code> 类型的属性
<code>layoutMargins</code>，它表示一个视图的内容和它四个边界之间的空隙，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/layout-margins-guide.png?x-oss-process=image/resize,w_800" /></p>
<p><code>UIView</code> 的 <code>layoutMarginsGuide</code> 属性其实是
<code>layoutMargins</code>
的另一种表现形式，可用于创建布局约束。<code>layoutMarginsGuide</code>
是一个 <strong>只读</strong> 属性。</p>
<h4 id="safearealayoutguide">safeAreaLayoutGuide</h4>
<p>在 iOS 11 时，苹果提出了 Safe Area 的概念。因为 iOS 11 搭载的 iPhone
X 取消了 Home 键，要为操作保留一些空间，这正好把原来的 Navigation Bar,
Status Bar, Tab Bar 包含在里面。<code>safeAreaLayoutGuide</code>
属性正是伴随 Safe Area 出现的。</p>
<p><code>safeAreaLayoutGuide</code> 属性和
<code>layoutMarginsGuide</code> 一样，也是 <strong>只读</strong>
属性，因为它们默认都已经设定了一个虚拟区域，我们可以直接基于此区域设置约束。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/safearea-layout-guide.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="nslayoutanchor">NSLayoutAnchor</h3>
<p>在初步了解 <code>UILayoutGuide</code>
之后，我们再来看它所包含的成员。可以发现，<code>UILayoutGuide</code>
内部定义了一系列 <code>NSLayoutAnchor</code> 类型的成员。</p>
<p>事实上，<code>NSLayoutAnchor</code> 类可以通过一系列 API，创建
<code>NSLayoutConstraint</code>
类型的约束对象，来进行布局约束的设置，而不用 <strong>直接</strong> 和
<code>NSLayoutConstraint</code> 对象打交道。</p>
<p>通常，我们不会直接使用
<code>NSLayoutAnchor</code>，而是使用它的三个子类，如下：</p>
<ul>
<li><code>NSLayoutXAxisAnchor</code>：X
轴方向的锚点，用来创建水平方向的约束</li>
<li><code>NSLayoutYAxisAnchor</code>：Y
轴方向的锚点，用来创建垂直方向的约束</li>
<li><code>NSLayoutDimension</code>：尺寸相关的锚点，用来创建尺寸相关的约束</li>
</ul>
<p><code>UILayoutGuide</code>
的诸多锚点属性可以归纳为上述三种子类中的一种。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">X 轴方向的锚点属性</th>
<th style="text-align: center;">Y 轴方向的锚点属性</th>
<th style="text-align: center;">尺寸相关的锚点属性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>centerXAnchor</code></td>
<td style="text-align: center;"><code>centerYAnchor</code></td>
<td style="text-align: center;"><code>widthAnchor</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>leftAnchor</code></td>
<td style="text-align: center;"><code>topAnchor</code></td>
<td style="text-align: center;"><code>heightAnchor</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>rightAnchor</code></td>
<td style="text-align: center;"><code>bottomAnchor</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>leadingAnchor</code></td>
<td style="text-align: center;"><code>firstBaselineAnchor</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>trailingAnchor</code></td>
<td style="text-align: center;"><code>lasBaselineAnchor</code></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>： <code>leadingAnchor</code> 和
<code>leftAnchor</code>、<code>trailingAnchor</code> 和
<code>rightAnchor</code>
在大多数情况下效果是一样的，但还是存在本质区别：<code>leadingAnchor</code>
表示视图最前面的边界锚点，如果在英文等阅读顺序从左向右的国家，leading
就表示 left，但在阿拉伯语等阅读顺序从右向左的国家，leading 就表示
right。</p>
</blockquote>
<p>一个视图那么多的锚点属性（X 轴，Y
轴，尺寸）能够和另外一个视图对应的位置锚点和尺寸锚点交互，从而确定视图的位置和尺寸。视图之间的锚点关系可以通过
API
调用来创建约束。<strong>前提是：只有相同子类的锚点属性之间才能交互</strong>。即：</p>
<ul>
<li>X 轴方向的锚点属性只能与 X 轴方向的锚点属性交互；</li>
<li>Y 轴方向的锚点属性只能与 Y 轴方向的锚点属性交互；</li>
<li>尺寸锚点属性只能与尺寸锚点属性交互。</li>
</ul>
<p>下面我们对比一下两种创建约束的方式： 1. 使用
<code>NSLayoutConstraint</code> 直接创建约束 2. 使用
<code>NSLayoutAnchor</code> 间接创建约束</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.Creating constraints using NSLayoutConstraint</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .leading,</span><br><span class="line">                   relatedBy: .equal,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .leadingMargin,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .trailing,</span><br><span class="line">                   relatedBy: .equal,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .trailingMargin,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Creating the same constraints using Layout Anchors</span></span><br><span class="line"><span class="keyword">let</span> margins <span class="operator">=</span> view.layoutMarginsGuide</span><br><span class="line"></span><br><span class="line">subview.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">subview.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>如下所示为 <code>NSLayoutAnchor</code>
提供的一些间接创建约束的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 NSLayoutAnchor 的共有 API</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalTo</span> <span class="params">anchor</span>: <span class="type">NSLayoutAnchor</span>&lt;<span class="type">AnchorType</span>&gt;) -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalTo</span> <span class="params">anchor</span>: <span class="type">NSLayoutAnchor</span>&lt;<span class="type">AnchorType</span>&gt;, <span class="params">constant</span> <span class="params">c</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutXAxisAnchor 的 API</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalToSystemSpacingAfter</span> <span class="params">anchor</span>: <span class="type">NSLayoutXAxisAnchor</span>, <span class="params">multiplier</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">anchorWithOffset</span>(<span class="params">to</span> <span class="params">otherAnchor</span>: <span class="type">NSLayoutXAxisAnchor</span>) -&gt; <span class="type">NSLayoutDimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutYAxisAnchor 的 API</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalToSystemSpacingBelow</span> <span class="params">anchor</span>: <span class="type">NSLayoutYAxisAnchor</span>, <span class="params">multiplier</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">anchorWithOffset</span>(<span class="params">to</span> <span class="params">otherAnchor</span>: <span class="type">NSLayoutYAxisAnchor</span>) -&gt; <span class="type">NSLayoutDimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutDimension 的 API</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalTo</span> <span class="params">anchor</span>: <span class="type">NSLayoutDimension</span>, <span class="params">multiplier</span> <span class="params">m</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalTo</span> <span class="params">anchor</span>: <span class="type">NSLayoutDimension</span>, <span class="params">multiplier</span> <span class="params">m</span>: <span class="type">CGFloat</span>, <span class="params">constant</span> <span class="params">c</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">constraint</span>(<span class="params">equalToConstant</span> <span class="params">c</span>: <span class="type">CGFloat</span>) -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure>
<h2 id="vfl">VFL</h2>
<p>VFL（Visual Format Language）是苹果推出的为了简化 Auto Layout 编码的
DSL（Domain-Specific Language）。</p>
<h3 id="语法">语法</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">标准间隔</td>
<td style="text-align: center;"><code>[button]-[textField]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">宽度约束</td>
<td style="text-align: center;"><code>[button(&gt;=50)]</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">与父视图的关系</td>
<td style="text-align: center;"><code>|-50-[purpleBox]-50-|</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">垂直布局</td>
<td
style="text-align: center;"><code>V:[topField]-10-[bottomField]</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Flush Views</td>
<td style="text-align: center;"><code>[maroonView][blueView]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">优先级</td>
<td style="text-align: center;"><code>[button(100@20)]</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">宽度相等</td>
<td style="text-align: center;"><code>[button(==button2)]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">Multiple Predicates</td>
<td
style="text-align: center;"><code>[flexibleButton(&gt;=70,&lt;=100)]</code></td>
</tr>
</tbody>
</table>
<p>注意，创建 VFL 语句描述时需要注意以下几点：</p>
<ul>
<li><code>H:</code> 和 <code>V:</code> 每次只能使用一个</li>
<li>视图变量名出现在方括号中，如：<code>[blueView]</code></li>
<li>语句的顺序：从上到下，从左到右</li>
<li>视图间隔以数字常量出现，如：<code>-10-</code></li>
<li><code>|</code> 表示父视图</li>
</ul>
<p><code>NSLayoutConstraint</code> 类提供了相关的 API 允许通过 VFL
语句创建约束。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSLayoutConstraint</span> *&gt; *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format </span><br><span class="line">                                                       options:(<span class="built_in">NSLayoutFormatOptions</span>)opts </span><br><span class="line">                                                       metrics:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="type">id</span>&gt; *)metrics </span><br><span class="line">                                                         views:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="type">id</span>&gt; *)views;</span><br></pre></td></tr></table></figure> 其中，<code>format</code> 表示 VFL
语句；<code>options</code> 表示约束类型；<code>metrics</code> 表示 VFL
语句中用到的具体数值；<code>views</code> 表示 VFL 语句中用到的控件。</p>
<p>下面，我们来看一个使用 VFL 创建约束的例子。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *left = @<span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *top = @<span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *width = @<span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *height = @<span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</span><br><span class="line"><span class="built_in">NSDictionary</span> *metrics = <span class="built_in">NSDictionaryOfVariableBindings</span>(left, top, width, height);</span><br><span class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@&quot;H:|-left-[view(&gt;=width)]&quot;</span> options:<span class="number">0</span> metrics:metrics views:views]];</span><br></pre></td></tr></table></figure></p>
<h1 id="布局因素">布局因素</h1>
<p>布局的构建主要由 <strong>布局引擎</strong>（Layout
Engine）完成。毫无疑问，视图是构建布局的作用对象。约束作为自动布局的核心，是构建布局的重要依据。除此之外，布局引擎在构建布局时还会参考以下这些因素：</p>
<ul>
<li>约束优先级（Constraint Priorities）</li>
<li><strong>内容优先级</strong>（Content Priorities）</li>
<li><strong>固有内容尺寸</strong>（Intrinsic Content Size）</li>
<li><strong>尺寸约束</strong>（Sizing Constraints）</li>
<li>水平对齐（Horizontal Alignment）</li>
<li>垂直对齐（Vertical Alignment）</li>
<li>基线对齐（Baseline Alignment）</li>
<li>对齐矩形（Alignment Rect）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/building-the-layout.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="尺寸约束">尺寸约束</h2>
<p>事实上，在上文 <strong>约束创建</strong>
中创建的约束就已经包含了尺寸约束。这里的再次提到尺寸约束，主要是针对
Self-Sizing 的视图。</p>
<p>比如，我们可以通过自动布局自动计算 TableView 的 Cell
高度。不过，默认情况下未启用该功能。</p>
<p>默认情况下，TabelView 的 Cell 高度由协议声明的
<code>tableView:heightForRowAtIndexPath:</code>
方法确定。除此之外，我们可以通过对 TabeView 的两个属性赋值，从而启用
Self-Sizing 功能，如下所示： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">tableView.estimatedRowHeight = <span class="number">85.0</span></span><br><span class="line">tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span></span><br></pre></td></tr></table></figure></p>
<p>接下来，我们需要在 TableView 的 Cell 的 <code>contentView</code>
中进行布局。为了能让布局引擎自动计算出 Cell 的高度，我们必须对
<code>contentView</code>
的子视图在垂直方向上定义一系列完善的约束，尤其是高度约束。在布局引擎计算高度过程中，它会优先使用尺寸约束，其次它会使用固有内容尺寸。
## 固有内容尺寸 &amp; 内容优先级 iOS
中有部分视图具有固有内容尺寸（intrinsic content
size），固有内容尺寸就是视图内容和边距所占据的尺寸。比如，<code>UIButton</code>
的固有内容尺寸等于 Title 的尺寸加上内容边距（margin）。</p>
<p>具有固有内容尺寸的视图有以下这些：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">View</th>
<th style="text-align: center;">Intrinsic Content Size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Sliders</td>
<td style="text-align: center;">Defines only the width (iOS).Defines the
width, the height, or both—depending on the slider’s type (OS X).</td>
</tr>
<tr class="even">
<td style="text-align: center;">Labels, buttons, switches, and text
fields</td>
<td style="text-align: center;">Defines both the height and the
width.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Text views and image views</td>
<td style="text-align: center;">Intrinsic content size can vary.</td>
</tr>
</tbody>
</table>
<p>固有内容尺寸的大小受很多因素的影响。以 <code>UITextView</code>
为例，其固有内容尺寸的大小取决内容、是否启用了滚动、以及应用于
<code>UITextView</code>
的其他约束。如果可以滚动，则没有固有内容尺寸，如果不可滚动，则取决于所有文字的尺寸。</p>
<p>固有内容尺寸的大小还受内容优先级的影响，内容优先级有以下两个方面：</p>
<ul>
<li><strong><code>Content Hugging Priority</code></strong></li>
<li><strong><code>Content Compression Resistance Priority</code></strong></li>
</ul>
<p><code>Content Hugging Priority</code>：表示一个视图抗拉伸的优先级，数值越高优先级越高，越不容易被拉伸。</p>
<p><code>Content Compressing Priority</code>：表示一个视图抗压缩的优先级，数值越高优先级越高，越不容易被压缩。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/intrinsic_content_size.png?x-oss-process=image/resize,w_800" /></p>
<p>默认情况下，视图的 <code>Content Hugging Priority</code> 值是
<code>250</code>，<code>Content Compression Resistance Priority</code>
值是 <code>750</code>。因此，拉伸视图比压缩视图更容易。</p>
<h3 id="intrinsic-content-size-与-fitting-size-的关系">Intrinsic Content
Size 与 Fitting Size 的关系</h3>
<p>Intrinsic Content Size
是布局引擎的输入，基于此可以生成约束，并最终生成布局； Fitting Size
则相反，它是布局引擎的输出，是基于约束生成的布局结果。</p>
<h2 id="对齐方式">对齐方式</h2>
<p>对齐方式有三种类型：</p>
<ul>
<li>水平对齐</li>
<li>垂直对齐</li>
<li>基线对齐</li>
</ul>
<p>对于前两者，通过前文的描述我们也算是有所了解了。水平对齐，用于在 X
轴上产生约束；垂直对齐，用于在 Y 轴上产生约束。</p>
<p>基线对齐则是文本专有的一种专有的对齐方式。基线对齐包括
<code>firstBaseline</code> 和 <code>lastBaseline</code>
两种对齐方式。如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aligning-baseline.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="对齐矩形">对齐矩形</h2>
<p>在自动布局中，我们可能会认为约束是使用 <code>frame</code>
来确定视图的大小和位置的，但实际上，它使用的是
<strong>对齐矩形</strong>（alignment
rect）。在大多数情况下，<code>frame</code> 和
<code>alignment rect</code> 是相等的，所以我们这么理解也没什么不对。</p>
<p>那么为什么是使用 <code>alignment rect</code>，而不是
<code>frame</code> 呢？</p>
<p>有时候，我们在创建复杂视图时，可能会添加各种装饰元素，如：阴影，角标等。为了降低开发成本，我们会直接使用设计师给的切图。如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/alignment-rect.png?x-oss-process=image/resize,w_800" /></p>
<p>其中，(a) 是设计师给的切图，(c) 是这个图的
<code>frame</code>。显然，我们在布局时，不想将阴影和角标考虑进入（视图的
<code>center</code>
和底边、右边都发生了偏移），而只考虑中间的核心部分，如图 (b)
中框出的矩形所示。</p>
<p>对齐矩形就是用来处理这种情况的。<code>UIView</code>
提供了方法可以实现从 <code>frame</code> 得到 <code>alignment rect</code>
以及从 <code>alignment rect</code> 得到 <code>frame</code>。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The alignment rectangle for the specified frame.</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)alignmentRectForFrame:(<span class="built_in">CGRect</span>)frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The frame for the specified alignment rectangle.</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)frameForAlignmentRect:(<span class="built_in">CGRect</span>)alignmentRect;</span><br></pre></td></tr></table></figure></p>
<p>此外，系统还提供了一个简便方法，有 <code>UIEdgeInsets</code> 指定
<code>frame</code> 和 <code>alignment rect</code> 的关系。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The insets from the view’s frame that define its alignment rectangle.</span></span><br><span class="line">- (<span class="built_in">UIEdgeInsets</span>)alignmentRectInsets;</span><br></pre></td></tr></table></figure></p>
<p>如果希望 <code>alignment rect</code> 比 <code>frame</code> 的下边多
<code>10</code> 个点，可以这些写： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIEdgeInsets</span>)alignmentRectInsets &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">-10.0</span>, <span class="number">.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="布局渲染">布局渲染</h1>
<p>iOS 的布局渲染可以分为三个阶段，如下所示：</p>
<ol type="1">
<li><strong>约束更新</strong>（Constraints Update）</li>
<li><strong>布局更新</strong>（Layout Update）</li>
<li><strong>显示重绘</strong>（Display Redraw）</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/the-render-loop.png?x-oss-process=image/resize,w_800" /></p>
<p>其中，每一步都是依赖前一步操作。显示重绘依赖布局更新，布局更新依赖约束更新。</p>
<h2 id="约束更新">约束更新</h2>
<p>约束更新是
<strong>自下而上</strong>（从子视图到父视图）进行的。我们可以通过调用
<code>setNeedsUpdateConstraints</code>
来触发约束更新。当然，我们对布局因素（约束/内容优先级、约束、固有内容尺寸...）作出的任何修改都会
<strong>自动触发</strong> <code>setNeedsUpdateConstraints</code>
方法。</p>
<p>对于自定义视图，我们可以在约束更新阶段重写
<code>updateConstraints</code> 来为视图增加需要的本地约束。</p>
<h2 id="布局更新">布局更新</h2>
<p>布局更新是
<strong>自上而下</strong>（从父视图到子视图）进行的。事实上，布局更新操作是通过设置
<code>frame</code>（OS X ）或 <code>center</code> 和
<code>bounds</code>（iOS）将布局引擎的计算结果应用到视图上。我们可以通过条用
<code>setNeedsLayout</code>
来触发布局更新。这并不会立刻应用布局，而是延迟进行处理。因为所有的布局请求将会被合并到一个布局操作中。这种延迟处理的过程被称为
<code>Deferred Layout Pass</code>。</p>
<p>我们可以调用 <code>layoutIfNeeded</code>（iOS） 或
<code>layoutSubtreeIfNeeded</code>（OS
X）强制系统立即更新视图树的布局。如果我们下一步的操作依赖于更新后视图的
<code>frame</code>，这将非常有用。</p>
<p>对于自定义视图，我们可以布局更新阶段重写
<code>layoutSubviews</code>（iOS）或 <code>layout</code>（OS
X）来获取控制布局变化的所有权。</p>
<h2 id="显示重绘">显示重绘</h2>
<p>显示重绘时
<strong>自上而下</strong>（从父视图到子视图）进行的。我们可以通过调用
<code>setNeedsDisplay</code>
来触发显示重绘，这回导致所有的调用都被合并到一起延迟重绘。</p>
<p>对于自定义视图，我们可以在显示重绘阶段重新 <code>drawRect:</code>
来获取自显示过程的所有权。</p>
<h2 id="注意事项">注意事项</h2>
<p>要注意的是，这三个阶段并不是单向的。基于约束的布局是一个迭代的过程。布局更新可以基于之前的布局来对约束作出修改，而这将再次触发约束更新，并紧接另一个布局更新。这可以被用来创建高级的自定义视图布局。但是如果我们每一次调用的自定义
<code>layoutSubviws</code>
都会导致另一个布局操作的话，将会陷入无限循环中。</p>
<h1 id="不同版本-ios-的自动布局">不同版本 iOS 的自动布局</h1>
<h2 id="ios-6">iOS 6</h2>
<ul>
<li>苹果在这个版本引入了自动布局，具有了所有核心功能。</li>
</ul>
<h2 id="ios-7">iOS 7</h2>
<ul>
<li>NavigationBar、TabBar、ToolBar 的 <code>translucent</code>
属性默认为 <code>YES</code>。当前 ViewController
的高度是整个屏幕的高度，为了确保不被这些 Bar 覆盖，可以在布局中使用
<code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code>
属性。</li>
</ul>
<h2 id="ios-8">iOS 8</h2>
<ul>
<li>Self-Sizing Cells。传送门: <a
href="https://www.appcoda.com/self-sizing-cells/">https://www.appcoda.com/self-sizing-cells/</a></li>
<li><code>UIViewController</code> 新增两个方法，用来处理
<code>UITraitEnvironment</code> 协议。UIKit 里有
<code>UIScreen</code>、<code>UIViewController</code>、<code>UIPresentationController</code>
支持该协议。当视图 traitCollection 改变时，<code>UIViewController</code>
可以捕获到这个消息进行处理。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setOverrideTraitCollection:(<span class="built_in">UITraitCollection</span> *)collection forChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="built_in">UITraitCollection</span> *)overrideTraitCollectionForChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Size Class。<code>UIViewController</code> 提供了一组新协议支持
<code>UIContentContainer</code>。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)systemLayoutFittingSizeDidChangeForChildContentContainer:(<span class="type">id</span> )container <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeForChildContentContainer:(<span class="type">id</span> )container withParentContainerSize:(<span class="built_in">CGSize</span>)parentSize <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="type">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="type">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="type">void</span>)willTransitionToTraitCollection:(<span class="built_in">UITraitCollection</span> *)newCollection withTransitionCoordinator:(<span class="type">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>UIView</code> 的 margin 新增了 3 个
API，<code>NSLayoutMargins</code>
可以定义视图之间的距离。只对自动布局有效，并且默认值为
<code>&#123;8, 8, 8, 8&#125;</code>。<code>NSLayoutAttribute</code>
的枚举值也有相应的更新。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIView的3个Margin相关API</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> layoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> preservesSuperviewLayoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="type">void</span>)layoutMarginsDidChange <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutAttribute的枚举值更新</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="ios-9">iOS 9</h2>
<ul>
<li><code>UIStackView</code>：提供了更加简单的自动布局方法，如：alignment
的 fill，leading，center，trailing。distribution 的 fill，fill
equally，fill proportionally，equal spacing。</li>
<li><code>NSLayoutAnchor</code> API <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLayoutConstraint</span> *constraint = [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://constraints.cs.washington.edu/solvers/uist97.html">Solving
Linear Arithmetic Constraints for User Interface Applications</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html">Visual
Format Language</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">Understanding
Auto Layout</a></li>
<li><a
href="https://peteruncle.com/2018/01/28/NSLayoutAnchor%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">NSLayoutAnchor基础知识</a></li>
<li><a
href="https://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/">深入剖析Auto
Layout，分析iOS各版本新增特性</a></li>
<li><a
href="https://peteruncle.com/2018/01/08/iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">iOS
自动布局基础知识</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/218/">WWDC
2015 session 218 Mysteries of Auto Layout Part1</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/219/">WWDC
2015 session 219 Mysteries of Auto Layout Part2</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/220">WWDC
2018 session 220 High Performance Auto Layout</a></li>
<li><a
href="https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/">Advanced
Auto Layout Toolbox</a></li>
<li><a
href="http://www.pluto-y.com/wwdc-2015-mystries-of-auto-layout/">WWDC
2015 - 揭开AutoLayout的神秘面纱(Mysteries Of Auto Layout)</a></li>
</ol>
<h1 id="扩展阅读">扩展阅读</h1>
<ol type="1">
<li><a href="https://juejin.im/entry/578354df1532bc005f5c1266">iOS 利用
AutoLayout 实现 view 间隔自动调整</a></li>
<li><a href="https://www.cnblogs.com/lisa090818/p/4303426.html">ios auto
layout demystified (一)</a></li>
<li><a href="https://objccn.io/issue-3-5/">先进的自动布局工具箱</a></li>
<li><a
href="https://samingzhong.github.io/2016/08/30/UIKit/%E5%85%B3%E4%BA%8EUIView%E7%9A%84translatesAutoresizingMaskIntoConstraints%20%E5%B1%9E%E6%80%A7/">关于UIView的translatesAutoresizingMaskIntoConstraints属性</a></li>
<li><a
href="https://github.com/ming1016/study/wiki/Masonry">Masonry</a></li>
<li><a href="https://segmentfault.com/a/1190000015300896">iOS
布局渲染——UIView 方法调用时机</a></li>
<li><a
href="https://peteruncle.com/2017/08/09/UIStackView%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">UIStackView基础知识</a></li>
</ol>
<p>(完)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>自动布局</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业旅行——泰国</title>
    <url>/2017/06/16/tailand/</url>
    <content><![CDATA[<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand124.png?x-oss-process=image/resize,w_600" />
<span id="more"></span></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=408280692&amp;auto=1&amp;height=66">
</iframe>
<h1 id="day-0">Day 0</h1>
<p><strong>6月3日，周六</strong><br />
昨天下午顺利通过硕士论文答辩，必须得感谢各位老师和同学们这三年的关照才得以顺利毕业，和大家相处的三年是非常快乐的。<br />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/dabian.jpeg?x-oss-process=image/resize,w_600" /></p>
<p>今天是辩结束后的第一天，三年来从未像此刻一样如此轻松。遂准备本次泰国之行最后的相关事项，即如何去机场啊、酒店机票的订单截图啊之类的。</p>
<p>机票的时间是21:55，晚饭过后在未名湖畔小散了一会儿步，便启程出发，差不多8点多达到首都T2航站楼。</p>
<p>我们在淘宝上订了泰国的7天Happy电话卡，发货方式是机场自取。自取的地点是在国际航班出发点的某个柜台，然而我们去泰国的航班并不是直达，而是从昆明转机至清迈，显然首次航班是国内航班。电话给淘宝客服，居然还不能送出来，也罢，取消了订单，到当地再买happy卡吧。</p>
<p>接下来又发生了一件意想不到的事情：取机票时，柜台说妹纸机票的订票姓名拼音与护照不符，WTF？！打开东航APP上的订单，居然还真拼错了！尴尬！遂致电客服，客服说会尽快修改，但不保证在确定时间内完成。没办法，只能等。离办理值机只剩不到二十分钟了，心情自然也是极度忐忑。遂再次致电客服，客服确认了好几便，说姓名的拼音是正确的，看来是改好了。最终也是有惊无险地办理了值机，顺利登上了飞机。有了这次遭遇，下次应该就长心眼儿了吧。</p>
<h1 id="day-1">Day 1</h1>
<p><strong>6月4日，周日</strong>
首趟航班差不多凌晨1点达到昆明，下机后先找值机柜台，这个点柜台都已经下班了，需要等到凌晨五点。我们航班的时间是6:30，按照值机时间是来得及的。于是便寻找游客休息室，然而大厅中已经全是游客，更气的是不少人一个人占了多个座位在睡觉，不少人席地而坐，素质啊素质。</p>
<p>席地打盹，好不容易熬到5点，便去值机柜台办理值机。没想到办理国际航班的值机服务，不仅要查看护照、签证，还要查找在目的国的酒店订单信息，返程机票以及钱包里的现金。所幸除了现金还需再取，其他的我们都符合要求。
昆明机场的确也是非常大的，据说是东航的大本营，果不其然，机场上一排排的飞机基本都是东航的。<br />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand011.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand010.png?x-oss-process=image/resize,w_600" /></p>
<p>第二趟航班差不多经历两个多小时，抵达清迈。刚下飞机没多久，手机时间便自动调整为了泰国时间，比北京时间早1个小时整。清迈机场真心非常小，国内随便找个机场都不知道要比它高几个档次。机场大厅里各个角落的指示牌居然同时有三种语言：泰语、英语、汉语，中国游客对于清迈旅游产业的影响可见一斑。</p>
<p>出了机场，便致电给平那科酒店，以寻求接机服务。学了那么多年的英语，从这一刻开始初见成效了。大约十分钟，接机小哥便来到了机场，下车便用很流利的中文跟我确认身份，我们一度以为他是中国人。地图上，平那科酒店与机场的直线距离只有几公里，然而实际却拐了很多弯才到达酒店，这是因为泰国的很多道路是单行道，正是这单行道后面也让我们吃了不少苦。</p>
<p>抵达平那科酒店大概是在泰国时间的上午8点多，由于一晚都没睡，总感觉现在是下午。Check
in的时候，前台小哥便用流利的中文和我们交谈，说房间需要等到12点才会有，可以让我们先把行李寄存在前台，出去玩一会儿。遂即我们便出门去找711超市买happy卡。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand049.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand015.png?x-oss-process=image/resize,w_600" /></p>
<p>由于时间还非常早，我们便打算打乱一下计划，逛一逛宁曼路街区。泰国的环境真的非常好，空气里透露着一股泥土的气息，蓝天和云彩的配合简直完美。<br />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand050.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand051.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand052.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand047.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand048.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand038.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand053.jpg?x-oss-process=image/resize,w_600" /></p>
<p>差不多到了中午，我们就近找了一家餐馆就餐，点了心心念念的芒果糯米饭和泰式酸辣海鲜河粉。第一次吃到芒果糯米饭的时候，汗毛都竖了起来，这糯米真的是入口即化！事实证明，这家店的芒果糯米饭是我们在泰国吃过的所有芒果糯米饭中最赞的！唯一遗憾，没记住店名...
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand042.png?x-oss-process=image/resize,w_600" /></p>
<p>饭后便回酒店准备办理入住。环顾酒店大厅，其装潢还是相当不错的。<br />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand043.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand054.jpg?x-oss-process=image/resize,w_500" /></p>
<p>前台告诉我们行李都已经搬进了房间，对此我是震惊的。在这一方面，国内同样价格的酒店可没这个待遇。我们订的房间大约200多一晚，房间的设施非常完备，吹风机、冰箱、热水壶、电视、衣柜什么都有，性价比非常高。房间的空间很大，装修也是简约大方，不多说，推荐推荐！
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand044.png?x-oss-process=image/resize,w_600" /></p>
<p>这一天真实特别漫长，当然也是非常累，回房便是洗澡睡觉。恰好老天爷眷顾，外面开始下起了阵雨，等到三点左右我们醒来，雨也停了，气温也降了，给力呀！</p>
<p>遂即按照计划步行去古城，路上遇到些水果摊显然是管不住自己的手的，榴莲、芒果、红毛丹，买买买。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand046.jpg?x-oss-process=image/resize,w_600" /></p>
<p>酒店到古城西门大约2公里，期间我们还晃悠进了一个公园，似乎是个马戏团，外面还摆着演出广告。就这样边吃边看边走，最终大概花了1个小时才到达古城。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand045.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand055.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand056.jpg?x-oss-process=image/resize,w_600" /></p>
<p>今天是周日，古城内会有周日夜市，这也是我们今晚来古城的原因。我们到古城内的街道时，小贩们已经开始陆续占领街道，支帐篷，挂吊灯，备战夜市。</p>
<p>显然小吃是我们此行的重要任务。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand057.jpg?x-oss-process=image/resize,w_600" /></p>
<p>穿着拖鞋从酒店走到古城，着实累脚。路中央，一位马杀鸡小哥在盛情揽客，于是就此躺了半小时，腿脚也是满血复活。不吹不黑，马杀鸡，好牛逼！
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand060.jpg?x-oss-process=image/resize,w_600" /></p>
<p>夜幕降临之前，我们尽可能地多逛逛古城。最后来到一个广场，这似乎是古城的行政中心。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand059.jpg?x-oss-process=image/resize,w_600" /></p>
<p>夜市的吊灯陆续被点亮，游客也越积越多。我们沿着夜市，边吃边逛，挑选购买看上眼的异国小商品。差不多到7点半，我们回到了夜市的入口，搭了辆Tuk-Tuk，回到了平那科。</p>
<h1 id="day-2">Day 2</h1>
<p><strong>6月5日，周一</strong>
平那科酒店是提供早餐的，从8点提供至10点。酒店的一楼大厅便是自助餐厅，餐厅的布局很漂亮，有室内餐桌和室外餐桌。食物也非常丰盛，主要以西餐和泰式菜为主。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand061.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand062.png?x-oss-process=image/resize,w_600" /></p>
<p>安静地享受完早餐，便托前台小哥帮忙租辆摩托车。五分钟后，租车小哥便风尘仆仆地赶来了。用蹩脚的英语与小哥聊了聊，签了合同，抵押了护照，然后预支了一天的租金300B。小哥还提醒我，归还摩托车时需要加满油，need
be full，need be
full。第一次开摩托，既兴奋又紧张，戴好头盔，便以每小时30公里的速度飞奔古城，游览泰国的知名寺庙。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand063.png?x-oss-process=image/resize,w_500" /></p>
<p>我们在古城内依次逛了帕辛寺、清迈寺、契迪龙寺等寺庙。说实话，这些寺庙的风格基本上是一致的，只是规模和颜色稍有差别。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand066.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand067.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand068.png?x-oss-process=image/resize,w_600" /></p>
<p>很快就到了中午，借着谷歌地图我们来到了大众点评上口碑不错的Mogo
Tango餐厅。该餐厅以甜食和冰淇淋为主，平嘴而论，口味对得起评分，可以可以。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand069.png?x-oss-process=image/resize,w_600" /></p>
<p>因为我们预定了下午一点半去素贴山玩，所以没在餐厅久留，吃完便回酒店睡午觉。</p>
<p>大概一点半左右，导游和司机便来接我们。导游的中文很不错，长得很像张家辉，很可惜没和他合影。</p>
<p>此趟行程的第一站是位于素贴山最高峰的蒲屏皇宫。蒲屏皇宫有点类似于国内的承德避暑山庄，都是皇室避暑的行宫。蒲屏皇宫里面种满了各种花草，环境也是相当的静谧，显然是个避暑好去处。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand070.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand071.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand072.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand073.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand074.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand075.jpg?x-oss-process=image/resize,w_600" /></p>
<p>素贴山的下一站便是双龙寺，这里导游给我们讲了讲双龙寺的来历，并参观了里面的一个舍利塔。在这里可以鸟瞰整个清迈，是一个非常值得推荐的旅游景点。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand076.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand077.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand078.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand079.png?x-oss-process=image/resize,w_600" /></p>
<p>半日游结束后，导游便送我们回来。我们在宁曼路的玛雅购物中心下了车。玛雅购物中心应该是清迈最大的购物商场，有6层，内部设施非常现代化。我们在这里找了一家游客较多的餐厅就餐。在这里，第一次品尝了正宗的泰国菜。泰国菜，特别是汤类菜肴，基本都会放香茅。这玩意儿味道很重，吃起来就像在吃化妆品，真心不符合中国人的口味。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand080.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-3">Day 3</h1>
<p><strong>6月6日，周二</strong>
7点起床，早早地便在餐厅吃完了早餐，然后就是等待导游来接我们去拜县一日游。拜县位于清迈西北方向100多公里，地处山区，一趟行程就要经历700多个弯道。对此，我们不仅准备了晕车药，还有晕车贴。一路上，不仅上下颠，还左右晃，难受得无法形容。没多久，minivan里就有游客交代了早餐。在车上煎熬了40分钟平地和2小时山路，终于抵达拜县。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand081.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand082.jpg?x-oss-process=image/resize,w_600" /></p>
<p>此次拜县之旅一共有8个景点，我们去了其中的7个。首先是小树屋。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand087.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand083.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand084.png?x-oss-process=image/resize,w_500" /></p>
<p>其次是二战桥。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand085.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand086.jpg?x-oss-process=image/resize,w_600" /></p>
<p>二战桥之后便是草莓园。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand088.jpg?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand089.jpg?x-oss-process=image/resize,w_600" /></p>
<p>随后抵达小黄屋，据说是《爱在拜城》的取景地，我表示没看过... <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand090.png?x-oss-process=image/resize,w_600" /></p>
<p>午饭前终于达到了期待已久的大树秋千。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand091.jpg?x-oss-process=image/resize,w_500" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand092.jpg?x-oss-process=image/resize,w_600" /></p>
<p>等大家都排完队与大树秋千合影之后，便来到了“中华饭店”就餐，肘子、青菜豆腐汤、醋溜土豆丝...几道菜而已。据说此地是云南村，此地大量土著都是华裔，解放时期国共内战，很多人逃离至此。导游本人也是在泰国的华裔二代，所以中文说得溜也是有原因的。</p>
<p>午饭过后在饭店附近玩了玩土著的射箭。稍事休息，便再次踏上旅程。
之后依次游览了粉色房子、倒立屋、农场。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand093.jpg?x-oss-process=image/resize,w_500" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand094.png?x-oss-process=image/resize,w_600" /></p>
<p>差不多下午两点，景点游玩到此结束。然后便是回清迈，又是经历700多个弯。在我看来，拜县就是那种去一次再也不想去的地方，来回1400多个弯！。在快离开山区时，我们在路边买了芒果。半斤重的一个大芒果，折合成人民币仅需1元！买不了吃亏，买不了上当！</p>
<p>差不多四点多，我们到达玛雅购物中心。从玛雅购物中心步行至平那科酒店大概需要20分钟，在回酒店的路上，看到街边有家店叫“我爱冬阴功”，看着似乎还不错，便进去点了餐。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand095.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-4">Day 4</h1>
<p><strong>6月7日，周二</strong>
在清迈这几天每天都是起早，今天准备放松一下，自由发挥。吃完早餐便租了摩托车，准备从古城西边出发，经过北部，再至东部，最后从古城东门穿越古城返回。清迈的道路真的令人很痛苦，大量的单行单，我们从古城东北角南下时基本都是在单行道上逆行。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand096.png?x-oss-process=image/resize,w_600" /></p>
<p>好不容易在中午抵达古城，在一个寺庙对面找了家餐馆就餐，一份芒果糯米饭，一份冬阴功汤。期间，又下起了太阳雨。好在我们吃完，雨也停了。</p>
<p>清迈的下午艳阳高照，我们还是决定回酒店等到傍晚再出来。待到6点多，我们赶到古城北部的凤飞飞猪脚饭餐馆，毕竟这家店也算是名声在外。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand097.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-5">Day 5</h1>
<p><strong>6月8日，周三</strong>
凌晨4点起床，因为要赶6点50的航班，飞往甲米。在前台刚刚退完房，门口的送机小哥就迎了上来，非常准时，靠谱！为了感激小哥半夜起床给我们送机，我们也给了他20B，以示感激。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand098.png?x-oss-process=image/resize,w_600" /></p>
<p>出了甲米机场之后，便步行了大概300米，来到minivan的候车点。大约1点半，minivan准时出现在候车的凉亭前面。Minivan中已经是满满一车人了，我们坐在最后面，虽然长途奔波很是难受，但是相比于拜县的旅程真的无比轻松了。行车1个半小时后便来到了兰塔岛的海峡入口处，经历半小时的车船联运后，抵达兰塔岛。司机依次运送乘客，我们车船联运后20分钟抵达CoCo
Lanta Resort。</p>
<p>到达酒店，前台便是热情招待，递上两杯橙汁。CoCo
Lanta的房间都是一个个的独栋小别墅。我们入住时发现只有很少的游客入住了，也许是淡季的原因吧。说实话，我们当时是有些后悔来到兰塔岛的。因为与清迈相比，这里显得十分凄凉，酒店附属的酒吧处于休业中，泳池边的遮阳伞都是收着的，躺椅、泳池也没有人。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand099.png?x-oss-process=image/resize,w_600" /></p>
<p>经过一天的奔波，再加上心理预期上的落差，当时的心情是非常低落的，晚饭也没不想去那个酒店的餐厅去吃，转而去了附近的一家711超市买了泡面，零食等。傍晚，在海边稍许逛了一会，心情也有所复苏。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand100.jpg?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-6">Day 6</h1>
<p><strong>6月9日，周四</strong>
早晨9点匆忙来到前台大厅，等待今天出海一日游的minivan。上了车之后没多久便来到了汽艇停靠的港口。港口中泊着一艘红色汽艇，汽艇上的工作人员都很酷，黑皮肤（当然是亚洲人）、黑墨镜、反鸭舌。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand101.png?x-oss-process=image/resize,w_600" /></p>
<p>汽艇在驶出海湾过程中经过静谧美丽的兰塔红树林，导游说红树林里有猴子，但是我们运气不够好，没遇到。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand102.png?x-oss-process=image/resize,w_600" /></p>
<p>大约10点，到达Talabeng岛。汽艇靠近海蚀洞穴，以便大家游至洞穴中去。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand103.png?x-oss-process=image/resize,w_600" /></p>
<p>探索完海蚀洞穴后，汽艇来到了BUBU岛。在BUBU岛沙滩自由浮潜20分钟。</p>
<p>之后便前往奈岛，奈岛是这几个岛中最美的岛屿。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand104.png?x-oss-process=image/resize,w_600" /></p>
<p>靠近奈岛近海处，导游便带领我们下海浮潜。浮潜了大约半小时，便上岸就餐。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand105.png?x-oss-process=image/resize,w_600" /></p>
<p>午餐过后便是1个半小时的海滩休闲时光。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand106.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand107.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand108.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand109.png?x-oss-process=image/resize,w_600" /></p>
<p>1点多，我们离开美丽的奈岛，前往MA岛和CHUEK岛，在汽艇上欣赏海岛屿风光。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand110.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand111.png?x-oss-process=image/resize,w_600" /></p>
<p>汽艇在海上漂游时，偶然发现一片海域的水特别清澈，于是导游带领我们下海浮潜。这里的珊瑚礁特别美丽，由各种色彩斑斓的海鱼，还有海胆。可惜没有租用GoPro进行水下摄影。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand112.png?x-oss-process=image/resize,w_600" /></p>
<p>一段美妙的浮潜之旅结束了本次出海。早晨汽艇从兰塔岛的东岸南下，返程从兰塔岛的西岸飞驰回港。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand113.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-7">Day 7</h1>
<p><strong>6月10日，周五</strong>
今天的计划是环岛游。早晨睡个懒觉起床，然后到海滩吹了一下海风。</p>
<p>到了10点半左右，从酒店租了辆摩托车，价格要比清迈便宜，只要200B一天。我们的目的是前往老镇吃海鲜。</p>
<p>CoCo Lanta
Resort在兰塔岛的西岸中部，老镇则在兰塔岛的东岸南部。摩托一路狂奔，花了一个小时抵达老镇。我们寻找昨天同行游客推荐的Fresh
Restaurant。餐厅很不错，架在海上。我们选了一个临海的餐桌就座。服务员递上菜单，菜单上菜品的价格相对北京的海鲜价位而言是比较便宜的。显然，来到海岛当然是点海鲜咯。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand114.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand115.png?x-oss-process=image/resize,w_600" /></p>
<p>饭后，我们来到了餐厅旁边的小港口转了转。之后便前往兰塔岛最南部的灯塔，一路上的山路蜿蜒陡峭，并且道路边树林密布。随着行程的深入，道路原来越窄，车辆也没了。后来开到大路的尽头，还没到达灯塔，我们便掉头回去。昨天那位游客也说路上很阴森很可怕，的确属实。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand116.png?x-oss-process=image/resize,w_600" /></p>
<p>傍晚照例先去了711超市，然后回来煮泡面。不同的是，今晚是在海边吃的泡面。看着日落，迎着海风，惬意的傍晚。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand117.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand118.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand119.png?x-oss-process=image/resize,w_600" /></p>
<p>夜色渐浓，想到远离灯火的海边是绝佳的观星地点。于是，下载了一个“星空”APP，对照着星空寻找星座，狮子座、半人马座、室女座、天平座、大熊座（含北斗七星）、天蝎座...</p>
<h1 id="day-8">Day 8</h1>
<p><strong>6月11日，周六</strong>
这是在岛上最后完整的一天，准备在海边度过。</p>
<p>早上来到海边，躺椅上有个五六十岁大爷主动与我们搭话：是中国人吗？之后便与他侃了起来，大爷还给我散烟，我委婉地拒绝了，后来便跟他推荐一些岛上的景点。直到11点，大爷包的车来了，海边这块地便被我占领了。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand120.png?x-oss-process=image/resize,w_600" /></p>
<p>午饭过后，一直在海滩边躺着，期间还打了个盹儿。</p>
<div data-align="center">
<video src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/video-tailand001.mp4" type="video/mp4" controls="controls" width="60%" height="60%">
</video>
</div>
<p>直到下午4点多，海水逐渐退去，近海的礁石都显露了出来。此时是在浅海中玩耍的好时机。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand121.png?x-oss-process=image/resize,w_600" /></p>
<p>临近黄昏，我们在酒店的餐厅点了一份冬阴功面、炒饭、炸软壳蟹，靠着栏杆，欣赏落日的余晖。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand122.png?x-oss-process=image/resize,w_600" />
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand123.png?x-oss-process=image/resize,w_600" /></p>
<p>落日之后，便躺在海滩边的吊床中享受在兰塔最后的休暇时光。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand124.png?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-9">Day 9</h1>
<p><strong>6月12日，周日</strong>
今天将离开兰塔岛，早上去海滩看了最后一眼清晨的大海，将要离开时总会不舍，希望我们还能再见。</p>
<p>再见，CoCo。 再见，Lanta。 再见，Tailand。 <img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/tailand/tailand125.png?x-oss-process=image/resize,w_600" /></p>
<p>(完)</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>自由行</tag>
        <tag>兰塔岛</tag>
        <tag>清迈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机那些事(7)——线程</title>
    <url>/2018/07/10/thread-introduce/</url>
    <content><![CDATA[<p>现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。</p>
<span id="more"></span>
<h1 id="线程基础">线程基础</h1>
<h2 id="线程概念">线程概念</h2>
<p><strong>线程（Thread）</strong>，也称<strong>轻量级进程（Lightweight
Process，LWP）</strong>，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合、堆栈组成。通常，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（如打开文件和信号）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-in-process.png" /></p>
<p>同一进程中的多个线程可以互不干扰地并发执行，并且共享进程的全局变量和堆的数据。相对于单线程进程，使用多线程的原因有一下几点：</p>
<ul>
<li>某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待时间进行线程切换。如等待网络响应。</li>
<li>某个操作可能会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会被中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li>
<li>程序本身要求并发操作，如一个多端下载软件（如Bittorrent）。</li>
<li>多CPU或多核处理器，本身具备同时执行多个线程的能力，因此单线程程序无法全面发挥计算机的全部计算能力。</li>
<li>相对于多进程应用，多线程在数据共享方面效率更高。</li>
</ul>
<h2 id="线程访问权限">线程访问权限</h2>
<p>线程可以访问进程内存中的所有的数据，包括如下几个方面：</p>
<ul>
<li><strong>全局变量</strong></li>
<li><strong>堆数据</strong></li>
<li><strong>函数里的静态变量</strong></li>
<li><strong>程序代码，任何线程都有权利读取并执行任何代码</strong></li>
<li><strong>打开的文件，A线程打开的文件可以由B线程读取</strong></li>
</ul>
<p>当然实际上线程也拥有自己的私有存储空间，包括如下几个方面：</p>
<ul>
<li><strong>栈</strong>：尽管并非完全无法被其他线程访问，但是一般情况下还是认为栈是私有数据。</li>
<li><strong>线程局部存储（Thread Local
Storage，TLS）</strong>：线程局部存储是某些操作系统为线程单独提供的私有空间，容量有限。</li>
<li><strong>寄存器</strong>：寄存器是执行流的基本数据，为线程私有。</li>
</ul>
<h2 id="线程调度与优先级">线程调度与优先级</h2>
<p>当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上。当线程数据大于处理器数量时，此时至少有一个处理器会运行多个线程。</p>
<p>在单处理器运行多线程情况下，并发是一种模拟出来的状态。操作系统会让这些多线程轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样每个线程“看起来”在同时执行。这样一个不断在处理器上切换不同的线程的行为称为
<strong>线程调度</strong>。</p>
<p>在线程调度中，线程通常拥有至少三种状态，分别是：</p>
<ul>
<li><strong>运行（Running）</strong>：此时线程正在执行。</li>
<li><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPI已被占用。</li>
<li><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。</li>
</ul>
<p>处于运行中的线程拥有一段可以执行的时间，这段时间称为
<strong>时间片（Time
Slice）</strong>。当时间片用尽时，线程进入就绪状态。如果线程在时间片用尽前就开始等待某事件，则它将进入等待状态。当一个线程离开运行状态时，系统会选择一个处于就绪状态的线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。如下图所示为线程的状态转移图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-state-transition-diagram.png" /></p>
<p>在线程调度中，主要有两种调度算法：</p>
<ul>
<li><strong>优先级调度（Priority Schedule）</strong>：线程拥有各自的
<strong>线程优先级（Thread
Priority）</strong>，高优先级的线程会更早执行，低优先级的线程需要等待系统中没有高优先级的可执行线程存在时才能执行。</li>
<li><strong>轮转调度（Round Robin
Schedule）</strong>：让各个线程轮流执行一段时间片。</li>
</ul>
<p>实际应用中，系统还会根据不同线程的表现自动调整优先级，提高线程调度效率。在系统中，一般把频繁等待的线程称为
<strong>IO密集型线程（IO Bound Thread）</strong>；把很少等待的线程称为
<strong>CPU密集型线程（CPU Bound Thread）</strong>。通常，IO
密集型线程比 CPU 密集型线程更容易得到优先级的提升。</p>
<p>在优先级调度中，存在一种 <strong>饿死（Starvation）</strong>
现象，即一个线程的优先级较低，在它执行之前，总是有较高优先级的线程在它之前执行。当一个CPU密集型的线程获得较高优先级时，许多低优先级的进程就可能饿死。当一个IO密集型的线程获得较高优先级时，由于大部分之间处于等待状态，因此相对不容易造成其他线程饿死。为了避免饿死现象，调度系统通常会逐步提升那些等待时间过长且未得到执行的线程的优先级。</p>
<h2 id="可抢占线程和不可抢占线程">可抢占线程和不可抢占线程</h2>
<p>轮转调度中，线程在用尽时间片后会被强制剥夺继续执行的权利，而进入就绪状态，该过程称为
<strong>抢占（Preemption）</strong>。在早期的一些操作系统中，线程是不可抢占的。在这种调度模型下，线程必须主动进入就绪状态，而不是靠时间片用尽来被强制进入。如果线程始终拒绝进入就绪状态，并且不进行任何等待操作，其他线程将永远无法执行。</p>
<p>在不可抢占线程中，线程会在两种情况下主动放弃执行：</p>
<ul>
<li>当线程试图等待某些事件时（如I/O事件）。</li>
<li>线程主动放弃时间片。</li>
</ul>
<h1 id="线程安全">线程安全</h1>
<p>多线程程序处于一个多变的环境中，可以访问的全局变量和堆数据随时都可能被其他的线程改变。因此，多线程程序在并发时数据的一致性非常重要。</p>
<h2 id="竞争与原子操作">竞争与原子操作</h2>
<p>多线程同时访问一个共享数据，可能会造成严重的后果。以一个著名的例子为例，假设有两个线程分别执行如下所示的
C 代码。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程 1</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line">--i;</span><br></pre></td></tr></table></figure> 在很多体系结构中，++i 的实现方式一般如下：</p>
<ol type="1">
<li><strong>读取 i 到某个寄存器 X</strong></li>
<li><strong>X++</strong></li>
<li><strong>将 X 的内容存储至 i</strong></li>
</ol>
<p>由于线程 1 和线程 2并发执行，因此两个线程的执行可能如下（注意，寄存器
X 的 内容在不同的线程中是不一样的，这里用 X[1] 和 X[2] 分别表示线程 1
和线程 2 中的 X），如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">执行序号</th>
<th style="text-align: left;">执行指令</th>
<th style="text-align: left;">语句执行后的变量值</th>
<th style="text-align: left;">线程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">i = 1</td>
<td style="text-align: left;">i = 1, X[1] = 未知</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;">X[1] = i</td>
<td style="text-align: left;">i = 1, X[1] = 1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;">X[2] = i</td>
<td style="text-align: left;">i = 1, X[2] = 1</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;">X[1]++</td>
<td style="text-align: left;">i = 1, X[1] = 2</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: left;">X[2]--</td>
<td style="text-align: left;">i = 1, X[2] = 0</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;">i = X[1]</td>
<td style="text-align: left;">i = 2, X[1] = 2</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">7</td>
<td style="text-align: left;">i = X[2]</td>
<td style="text-align: left;">i = 0, X[2] = 0</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<p>从程序逻辑上看，两个线程都执行完毕之后，i 的值应该是
1，但从表中的执行序列可以看到，i 的实际值是
0。实际上，这两个线程如果同时执行，i 的结果有可能是 0 或 1 或 2。</p>
<p>很明显，由于 i++
操作在多线程环境下会出现错误是因为该操作被编译成汇编代码后不止一条指令，因此在执行时可能会被调度系统打断，去执行别的代码。通常，我们把单指令的操作称为
<strong>原子操作</strong>，因为单条指令的执行是不会被打断的。很多体系结构都提供了一些常用的原子指令，如
i386 就有一条 inc
指令可以直接增加一个内存单元值，可以避免上例的错误情况。</p>
<p>尽管原子操作指令非常方便，但是它们仅适用于比较简单特定的场合。在复杂的场合下，比如要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。这里需要更加通用的手段：锁。</p>
<h2 id="同步与锁">同步与锁</h2>
<p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，需要将各个线程对同一个数据的访问进行
<strong>同步（Synchronization）</strong>。即在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。</p>
<p>同步最常见的方法是使用
<strong>锁（Lock）</strong>。锁是一种非强制机制，每个线程在访问数据或资源之前首先试图
<strong>获取（Acquire）</strong> 锁，并在访问结束之后
<strong>释放（Release）</strong>
锁。在锁已经被占用时试图获取锁时，线程会等待，直到锁重新可用。</p>
<h3 id="二元信号量">二元信号量</h3>
<p><strong>二元信号量（Binary Semaphore）</strong>
是最简单的一种锁，只有两种状态：<strong>占用</strong>、<strong>非占用</strong>。二元信号量适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</p>
<h3 id="多元信号量">多元信号量</h3>
<p>多元信号量是二元信号量的扩展，简称
<strong>信号量（Semaphore）</strong>。一个初始值为 N 的信号量允许 N
个线程并发访问。</p>
<p>当线程访问资源时，首先获取信号量，进行如下操作：</p>
<ul>
<li>将信号量减 1。</li>
<li>如果信号量的值小于 0，则进入等待状态，否则继续执行。</li>
</ul>
<p>当线程结束访问资源后，线程释放信号量，进行如下操作：</p>
<ul>
<li>将信号量的值加 1。</li>
<li>如果信号量的值小于 1，唤醒一个等待中的线程。</li>
</ul>
<h3 id="互斥量">互斥量</h3>
<p><strong>互斥量（Mutex）</strong>
和二元信号量很相似，资源仅同时允许一个线程访问，但和信号量不同的是：信号量在整个系统中可以被任意线程获取并释放，即同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。</p>
<h3 id="临界区">临界区</h3>
<p><strong>临界区（Read-Write Lock）</strong>
是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于：互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的；临界区的作用范围仅限于本进程，其他的进程无法获取该锁。</p>
<h3 id="读写锁">读写锁</h3>
<p><strong>读写锁（Read-Write Lock）</strong>
致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对该数据进行修改，就必须使用同步手段来避免出错。对此，可以使用上述的信号量、互斥量或临界区中的任何一种来进行同步。虽然这样可以保证程序正确执行，但是对于读取频繁的程序，会显得非常低效。读写锁就是用来提高这种情况下的执行效率的。</p>
<p>读写锁有两种获取方式：<strong>共享的（Shared）</strong>、<strong>独占的（Exclusive）</strong>。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有线程释放。处于独占状态的锁将阻止任何其他线程获取该锁。</p>
<h3 id="条件变量">条件变量</h3>
<p><strong>条件变量（Condition Variable）</strong>
作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作：首先，线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时所有等待此条件变量的线程都会被唤醒并继续执行。</p>
<h1 id="线程模型">线程模型</h1>
<p>线程的并发执行是由多处理器或操作系统调度来实现的。但实际情况要更为复杂：大多数操作系统，包括
Windows 和
Linux，都在内核里提供线程的支持，内核态线程由多处理器或调度来实现并发。然而用户实际使用的线程并不是内核态线程，而是用户态线程。用户态线程并不一定在操作系统内核里对应同等数量的内核态线程。它们之间的对应关系有三种类型。</p>
<h2 id="一对一模型">一对一模型</h2>
<p>对于直接支持线程的系统，一对一模型始终是最简单的模型。对于一对一模型，一个用户态线程唯一对应一个内核态线程，但一个内核态线程并不一定存在相应的用户态线程。模型示意图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-one-to-one.png" /></p>
<p>一对一模型中，用户态线程具有和内核态线程一致的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程的执行不会受到影响。此外，一对一模型也可以让多线程程序在多处理器的系统上有更高的效率。</p>
<p>一对一线程模型也有两个缺点：</p>
<ul>
<li>由于许多操作系统限制了内核态线程的数量，因此一对一线程会让用户态线程的数量受到限制。</li>
<li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li>
</ul>
<h2 id="多对一模型">多对一模型</h2>
<p>多对一模型将多个用户态线程映射到一个内核态线程上，线程之间的切换由用户态的代码完成。因此相对于一对一模型，多对一模型的切换要快速许多。模型示意图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-one.png" /></p>
<p>多对一模型的问题在于：如果其中一个用户态线程阻塞，将导致所有线程都无法执行。另外，在多处理器系统中，处理器的增多对于多对一模型的线程性能也不会有明显的提升。多对一模型的优点在于高效的上下文切换和几乎无限制的线程数量。</p>
<h2 id="多对多模型">多对多模型</h2>
<p>多对多模型结合了多对一模型和一对一模型的特点，将多个用户态线程映射到少数但不止一个内核态线程。模型示意图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-many.png" /></p>
<p>多对多模型中，一个用户态线程阻塞并不会导致所有的用户态线程阻塞，因为此时还有其他的线程可以被调度来执行。此外，多对多模型对用户线程的数量也没什么限制，在多处理器系统中，多对多模型的线程也能得到一定的性能提升，但是提升幅度步入一对一模型。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《程序员的自我修养——链接、装载与库》</li>
<li>《深入理解计算机系统》</li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>信号量</tag>
        <tag>临界区</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu + Gerrit + Apache 搭建代码审核服务器</title>
    <url>/2017/12/12/ubuntu-gerrit-apache/</url>
    <content><![CDATA[<p>我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容...</p>
<span id="more"></span>
<h1 id="一gerrit介绍">一、Gerrit介绍</h1>
<p>Gerrit的目的是提供一个轻量级的框架来review每一个commit，review通过之后，commit会被合入代码库。</p>
<p>Gerrit是一个中间区域，可以看到提交至Gerrit上的代码相对于服务器代码仓库中代码的差异，从而便于检查代码的改动。Gerrit也是整个代码review的推动者。</p>
<p>任何拥有多个成员的团队都应该有一个中央代码仓库。
Git在理论上可以在没有这样的中心位置的情况下工作，但实际上通常有一个中央仓库库作为项目实际内容的权威副本。
开发者从该中央仓库fetch和push</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gerrit-central-source-repository.png?x-oss-process=image/resize,w_800" /></p>
<p>Gerrit被部署在上图的中央仓库的位置，并增加一个新的概念：<strong>a
store of pending
changes（未决的修改）</strong>。每个人仍然可以从中央仓库fetch，但是push操作则有所变化，push操作会直接push到中央仓库，而是push到了<strong>pending
changes
location</strong>，以供review。只有在commit通过了review之后，才会被submit到中央仓库。如下图所示。</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gerrit-in-place-of-central-repository.png?x-oss-process=image/resize,w_800" /></p>
<p>Gerrit具有强大的访问控制模型。用户可以被授予访问权限，绕过review，直接推送到中央仓库。Gerrit甚至可以在没有代码review的情况下使用，只用于托管仓库和访问控制。</p>
<h1 id="二应用场景">二、应用场景</h1>
<p>在安装gerrit之前，我使用<code>node</code>在服务器上部署了一个站点，也就是本博客，其占用了<code>80</code>端口。</p>
<p>在安装gerrit之后，我的服务器又将多出一个站点，用户该如何访问？我又该如何部署呢？这时候，我们就需要了解一下<code>反向代理</code>和<code>端口转发</code>了。</p>
<h2 id="正向代理与反向代理">1. 正向代理与反向代理</h2>
<p>如下所示为正向代理和反向代理的示意图。一般来说，我们会把正向代理是与客户端划为一体，把反向代理和服务器划为一体。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/proxy-both.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，重新思考一下我们的应用场景：博客是一个web服务器，gerrit是一个web服务器，apache作为反向代理，这样就可以满足我们的需求了。</p>
<p>那么反向代理到底是如何做到的呢？答案就是<code>端口转发</code>。</p>
<p>我们知道在浏览器输入网址后，它会在解析后的IP地址之后加上一个默认的端口号<code>80</code>。所以，我们访问<code>chuquan.me</code>时就不需要输入完整的地址<code>chuquan.me:80</code>了。正因为如此，绝大多数服务器软件（包括apache）的默认监听端口也是<code>80</code>。</p>
<p>在安装了apache之后，<code>80</code>端口被apache占用了。因此，gerrit和博客都不能使用<code>80</code>端口了。这时候，我们需要给这两个站点配置使用其他的端口号，如：gerrit的HTTP协议使用<code>8081</code>端口，博客使用<code>8082</code>端口。它们与apache之间使用<code>端口转发</code>来实现<code>反向代理</code>。
<img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/apache-gerrit-blog.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="三开发环境">三、开发环境</h1>
<ul>
<li>Ubuntu 14.04.5 LTS</li>
<li>Java 1.8.0_151</li>
<li>Git 1.9.1</li>
<li>Apache/2.4.7</li>
</ul>
<h1 id="四安装gerrit">四、安装Gerrit</h1>
<h2 id="新建专用用户">1. 新建专用用户</h2>
<p>新建一个用户来专门管理Gerrit相关内容。在root用户下新建一个gerrit用户。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adduser gerrit</span><br><span class="line">$ su gerrit</span><br></pre></td></tr></table></figure></p>
<h2 id="下载gerrit安装包">2. 下载Gerrit安装包</h2>
<p>Gerrit下载地址：<a
href="https://www.gerritcodereview.com/releases/2.14.md">https://www.gerritcodereview.com/releases/2.14.md</a></p>
<p>我安装的Gerrit版本是2.14.6。在Linux环境下使用<code>wget</code>进行下载，最终得到一个<code>war</code>包，位于<code>/home/gerrit/</code>目录下。<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget https://gerrit-releases.storage.googleapis.com/gerrit-2.14.6.war</span><br></pre></td></tr></table></figure></p>
<h2 id="安装gerrit">3. 安装Gerrit</h2>
<p>在<code>/home/gerrit/</code>目录下，进行安装： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -jar gerrit-2.14.6.war init -d review_site</span><br></pre></td></tr></table></figure>
上述命令会在当前目录下创建一个<code>review_site</code>目录。接下来就开始进行对话式安装，我们可以直接回车，表示采用默认安装选项。之后还可以通过配置文件进行详细配置。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** Gerrit Code Review 2.14.6</span><br><span class="line">***</span><br><span class="line">*** Git Repositories  </span><br><span class="line">***  </span><br><span class="line">Location of Git repositories   [git]:   </span><br><span class="line">*** SQL Database  </span><br><span class="line">***  </span><br><span class="line">Database server type           [h2]:   </span><br><span class="line">*** User Authentication  </span><br><span class="line">***  </span><br><span class="line">Authentication method          [OPENID/?]: http  </span><br><span class="line">Get username from custom HTTP header [y/N]?  </span><br><span class="line">SSO logout URL                 :  </span><br><span class="line">*** Email Delivery  </span><br><span class="line">***  </span><br><span class="line">SMTP server hostname           [localhost]:  </span><br><span class="line">SMTP server port               [(default)]:  </span><br><span class="line">SMTP encryption                [NONE/?]:  </span><br><span class="line">SMTP username                  :  </span><br><span class="line">*** Container Process  </span><br><span class="line">***  </span><br><span class="line">Run as                         [gerrit]:  </span><br><span class="line">Java runtime                   [/usr/lib/jvm/java-7-openjdk-amd64/jre]:  </span><br><span class="line">Copy gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war [Y/n]?  </span><br><span class="line">Copying gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war  </span><br><span class="line">*** SSH Daemon  </span><br><span class="line">***  </span><br><span class="line">Listen on address              [*]:  </span><br><span class="line">Listen on port                 [29418]:  </span><br><span class="line">*** HTTP Daemon  </span><br><span class="line">***  </span><br><span class="line">Behind reverse proxy           [y/N]?   </span><br><span class="line">Proxy uses SSL (https://)      [y/N]?  </span><br><span class="line">Subdirectory on proxy server   [/]:  </span><br><span class="line">Listen on address              [*]:  </span><br><span class="line">Listen on port                 [8080]:</span><br><span class="line">*** Plugins  </span><br><span class="line">***  </span><br><span class="line">Installing plugins.  </span><br><span class="line">Install plugin download-commands version v2.11 [y/N]?  </span><br><span class="line">Install plugin reviewnotes version v2.11 [y/N]?  </span><br><span class="line">Install plugin singleusergroup version v2.11 [y/N]?  </span><br><span class="line">Install plugin replication version v2.11 [y/N]?  </span><br><span class="line">Install plugin commit-message-length-validator version v2.11 [y/N]?  </span><br><span class="line">Initializing plugins.  </span><br><span class="line">No plugins found with init steps.  </span><br><span class="line">Initialized /home/gerrit/review_site</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
安装完毕，Gerrit会自动启动，不过我们大概率会启动失败，因为默认的配置并不一定与你当前的环境相匹配。不过，没关系，我们可以根据系统环境对gerrit进行配置。</p>
<h2 id="gerrit配置">4. Gerrit配置</h2>
<p>Gerrit安装完成后，会在<code>review_site</code>目录下生成多个目录。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ll review_site</span><br><span class="line">./</span><br><span class="line">../</span><br><span class="line">bin/</span><br><span class="line">cache/</span><br><span class="line">data/</span><br><span class="line">db/</span><br><span class="line">etc/</span><br><span class="line">git/</span><br><span class="line">index/</span><br><span class="line">lib/</span><br><span class="line">logs/</span><br><span class="line">plugins/</span><br><span class="line">static/</span><br><span class="line">tmp/</span><br></pre></td></tr></table></figure>
其中<code>etc/</code>目录下存放着gerrit的配置文件<code>gerrit.config</code>，其中已有的内容是根据安装时的选择生成的。我们可以编辑<code>gerrit.config</code>来进行配置更改。其中<code>115.28.168.118</code>是服务器的公网IP地址。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[gerrit]</span><br><span class="line">        basePath = git</span><br><span class="line">        serverId = 084efaf9-3bf6-401c-a4b1-8778c998bde2</span><br><span class="line">        canonicalWebUrl = http://115.28.168.118 # 指定web访问Gerrit的网址或IP地址</span><br><span class="line">[database]</span><br><span class="line">        type = h2</span><br><span class="line">        database = /home/gerrit/review_site/db/ReviewDB</span><br><span class="line">[index]</span><br><span class="line">        type = LUCENE</span><br><span class="line">[auth]</span><br><span class="line">        type = HTTP # 默认是OPENID，改成HTTP后，才能通过浏览器进行访问</span><br><span class="line">[receive]</span><br><span class="line">        enableSignedPush = true</span><br><span class="line">[sendemail]</span><br><span class="line">        smtpServer = localhost</span><br><span class="line">[container]</span><br><span class="line">        user = gerrit</span><br><span class="line">        javaHome = /usr/lib/jvm/java-8-oracle/jre</span><br><span class="line">[sshd]</span><br><span class="line">        listenAddress = *:29418</span><br><span class="line">[httpd]</span><br><span class="line">        listenUrl = proxy-http://115.28.168.118:8081/ # HTTP代理地址及端口，这里我们配置成8081</span><br><span class="line">[cache]</span><br><span class="line">        directory = cache</span><br></pre></td></tr></table></figure></p>
<h1 id="四配置apache">四、配置Apache</h1>
<p>不同系统以及不同版本的Apache的配置文件可能会不一样，无外乎两种：<code>httpd.conf</code>、<code>apache2.conf</code>。本环境的配置文件是<code>apache2.conf</code>。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /etc/apache2/</span><br><span class="line">$ vim apache2.conf</span><br></pre></td></tr></table></figure> 在配置文件的末尾添加apache的端口转发配置。如下所示
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"># Blog相关配置</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">	ServerName www.chuquan.me       # 用于Apache过滤检测的域名</span><br><span class="line">	ServerAlias chuquan.me</span><br><span class="line">    ProxyPass / http://115.28.168.118:8082/     # Blog正向代理转发的端口</span><br><span class="line">    ProxyPassReverse / http://localhost:8082/   # Blog反向代理转发的端口</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"># Gerrit相关配置</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName gerrit.chuquan.me    # 用户Apache过滤检测的域名    </span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyVia Off</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    &lt;Proxy *&gt;</span><br><span class="line">          Order deny,allow</span><br><span class="line">          Allow from all</span><br><span class="line">    &lt;/Proxy&gt;</span><br><span class="line">    &lt;Location /login/&gt;</span><br><span class="line">        AuthType Basic</span><br><span class="line">        AuthName &quot;Gerrit Code Review&quot;</span><br><span class="line">        Require valid-user</span><br><span class="line">        AuthBasicProvider file</span><br><span class="line">        AuthUserFile /home/gerrit/review_site/etc/passwords</span><br><span class="line">    &lt;/Location&gt;</span><br><span class="line">    AllowEncodedSlashes On</span><br><span class="line">    ProxyPass / http://115.28.168.118:8081/         # Gerrit正向代理转发的端口</span><br><span class="line">    ProxyPassReverse / http://115.28.168.118:8081/  # Gerrit反向代理转发端口，应该与ProxyPass一致</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="五服务重启">五、服务重启</h1>
<p>Apache和Gerrit配置（当然也包括blog的端口）完之后，我们需要重启服务，包括apache、gerrit，其重启命令分别如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ /etc/init.d/apache2 restart </span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /home/gerrit/</span><br><span class="line">$ ./bin/gerrit.sh restart</span><br></pre></td></tr></table></figure></p>
<h2 id="gerrit启动失败">1. Gerrit启动失败</h2>
<p>在执行重启Gerrit的命令后，shell很可能会出现如下的信息：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting Gerrit Code Review: FAILED</span><br></pre></td></tr></table></figure></p>
<p>我在安装过程中页出现了这个问题，于是，我通过在<code>./bin/gerrit.sh</code>脚本中的首行添加了一个<code>-x</code>选项，以打印脚本执行的相关信息。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh -x</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
然后再执行该脚本，发现打印信息是一组循环信息。其中，当<code>TIMEOUT</code>的值递减至0时，启动失败。</p>
<p>经过调研发现：<br />
&gt;
Gerrit启动慢是因为java程序启动慢，导致Gerrit启动非常慢，大概需要10分钟左右，而默认的超时时间（TIMEOUT）是90秒，导致一直提示“Starting
Gerrit Code Review: FAILEDStarting Gerrit Code Review:
FAILED”。对此有如下两种解决方案。</p>
<p>第一种解决方案是：修改java的<code>java.security</code>文件。首先，根据<code>gerrit.config</code>中配置<code>javaHome = /user/lib/jvm/java-8-oracle/jre</code>，找到并进入该目录，然后再进入<code>lib/security/</code>目录，修改<code>java.security</code>文件。将<code>securerandom.source=file:/dev/random</code>改为<code>securerandom.source=file:/dev/urandom</code>。由此，解决gerrit启动慢的问题。</p>
<p>第二种解决方案是：在gerrit.conf文件中的<code>[container]</code>字段下增加`startupTimeout
= 900。</p>
<h2 id="反向代理异常">2. 反向代理异常</h2>
<p>当我们配置结束并重启之后，在浏览器中访问很有可能会得到如下的页面：</p>
<p><img
src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/gerrit-configure-error.png?x-oss-process=image/resize,w_800" /></p>
<p>这个页面在安装过程中，出现次数不下于10次。主要是两种情况，一种是Gerrit配置文件和Apache配置文件可能配置有误。另一种情况是配置没有生效，需要多试试重启。</p>
<h2 id="创建第一个gerrit账户">3. 创建第一个Gerrit账户</h2>
<p>当所有问题解决完之后，通过浏览器访问Gerrit，将不会出现上面的Error界面，而是会弹出输入对话框，需要你填写账户和密码。</p>
<p>这时候，我们需要为Gerrit创建一个账户，默认第一个创建的账户是管理员。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch /home/gerrit/review_site/etc/passwords</span><br><span class="line">$ htpasswd /home/gerrit/review_site/etc/passwords &quot;admin&quot;</span><br><span class="line">New password:</span><br><span class="line">Re-type new password:</span><br><span class="line">Adding password for user root</span><br></pre></td></tr></table></figure>
重启服务后，再用浏览器打开，登录后就出现久违的界面了！</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>Gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币那些事(1)——入门</title>
    <url>/2019/10/07/understand-bitcoin/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin-logo01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>2008 年 11 月 1 日，中本聪（Satoshi Nakamoto）在 metzdowd
的加密技术邮件列表发布比特币白皮书：<a
href="https://bitcoin.org/bitcoin.pdf">《BitCoin: A Peer-to-Peer
Electronic Cash System》</a>，首次提出比特币（BitCoin，BTC）的概念。</p>
<p>2009 年 1 月 3
日，中本聪在位于芬兰赫尔辛基（Helsinki）的一个小型服务器上挖出了第一批
50 个比特币。至此，比特币电子现金系统正式诞生。</p>
<p>比特币是一个完全去中心化的电子现金系统，它不依赖于中央机构进行货币发行、结算、验证交易。<strong>区块链</strong>
则是支持比特币系统的核心技术。</p>
<h1 id="举例">举例</h1>
<p>下面，我们以一个具体例子来介绍比特币的工作原理以及相关概念。</p>
<p>假如，有 A、B、C、D 四个人，它们之间发生了三笔交易：</p>
<ul>
<li>A 向 B 转账 10 比特币</li>
<li>B 向 C 转账 20 比特币</li>
<li>C 向 D 转账 30 比特币</li>
</ul>
<p>那么，通过在比特币网络中进行广播，比特币网络中的
<strong>所有节点</strong> 都将获得这一系列交易信息。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/bitcoin-example01.png?x-oss-process=image/resize,w_800" /></p>
<p>这些交易信息最终会由 <strong>某个节点</strong> 负责组装到一个
<strong>区块</strong>（Block）中，并将该区块添加至
<strong>全局区块链</strong>
中。<strong>注意，每个节点都保存了完整的全局区块链</strong>。</p>
<p>这里，就产生了三个问题：</p>
<ul>
<li>节点为何工作？</li>
<li>如何选择节点？</li>
<li>如何验证交易内容的真实性？</li>
</ul>
<p>下面，我们依次来回答这几个问题，并引出相关概念。</p>
<h1 id="节点为何工作">节点为何工作？</h1>
<p>比特币网络的节点为什么要创建并添加区块？因为，这是有奖励的，奖励包含两部分：</p>
<ul>
<li>每比交易提供的手续费</li>
<li>系统提供的比特币奖励</li>
</ul>
<p>关于系统的奖励规则，系统规定：</p>
<ul>
<li>每向全局区块链中添加一个区块，系统会奖励 50 个比特币，每 4
年奖励减半。</li>
<li>平均每 10 分钟生成一个新的区块。</li>
</ul>
<p>由此，我们可以通过计算得出系统总共包含的比特币数量。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比特币总数 = ((60 分钟 × 24 小时 × 365 天 × 4 年) / 10 分钟) × 50 比特币 × (1 + 1/2 + (1/2)² + (1/2)³ ...) ≈ 2100 万</span><br></pre></td></tr></table></figure></p>
<h1 id="如何选择节点">如何选择节点？</h1>
<p>如何选择节点？因为比特币是一个典型的分布式系统，分布式系统则是通过
<strong>共识算法</strong>（Consensus Algorithm）来进行节点选择。</p>
<p>分布式系统的共识算法有很多，常见的有以下这些：</p>
<ul>
<li>Paxos</li>
<li>Raft</li>
<li>PoW（工作量证明，Proof-of-Work）</li>
<li>PBFT（practival Byzantine Fault Tolerance）</li>
<li>XFT（Cross Fault Tolerance）</li>
<li>...</li>
</ul>
<p>比特币系统采用的则是 <strong>工作量证明</strong>
共识算法。关于工作量证明的详细原理，我们需要先介绍哈希函数。</p>
<h2 id="哈希函数">哈希函数</h2>
<p>哈希函数可以对任意内容计算出一个长度相同的特征值。比特币区块链使用
<code>SHA256</code> 算法作为哈希函数，其哈希特征值长度为 256
位。无论原始内容是什么，最后都会计算出一个 256
位的二进制数值。如下所示，为字符串 <code>123</code> 基于
<code>SHA256</code> 算法的十六进制哈希值： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHA256(&quot;123&quot;) = 0xa8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0</span><br></pre></td></tr></table></figure></p>
<p>哈希函数具有一个重要特征：</p>
<ul>
<li><strong>正向计算容易，反向逆推困难</strong></li>
</ul>
<p>什么意思？以如下一道数学题为例，我们通过已知的 <code>x</code> 计算
<code>y</code> 的值是非常简单的。但是通过已知的 <code>y</code> 计算
<code>x</code>
的值则是非常困难的。所以，想要通过哈希值求解原始值只能通过暴力求解，挨个试。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x³ * ln(ln(x)) + x² * sin(x) = y</span><br></pre></td></tr></table></figure></p>
<h2 id="工作量证明">工作量证明</h2>
<p>工作量证明要做的事情其实就是
<strong>逆推哈希值</strong>。由于只能使用暴力求解，所以这是一个非常耗时的过程。不过，一旦某个节点在整个比特币网络中第一个计算出正确值，那么它将会获得丰富的奖励，所以工作量证明也被称为
<strong>挖矿</strong>（Mining）。</p>
<p>那么工作量证明究竟要解决一道什么样的难题呢？我们需要先从区块的结构说起。</p>
<p>如下图所示，为区块链的基本结构——区块。区块主要包含两部分：</p>
<ul>
<li><strong>区块头</strong>（Block Header）
<ul>
<li>生成时间</li>
<li>当前区块体的哈希值</li>
<li>上一区块体的哈希值</li>
<li>. . .</li>
</ul></li>
<li><strong>区块体</strong>（Block Body）
<ul>
<li>交易内容</li>
</ul></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-structure-of-one-block.png?x-oss-process=image/resize,w_800" /></p>
<p>在了解了区块结构之后，我们再来看工作量证明到底要解决一道什么难题。题目如下所示：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHA256(字符串) -&gt; 符合某个条件的哈希值（小于某个目标值）</span><br></pre></td></tr></table></figure> 其中，字符串由 <strong>当前区块头 + 当前区块体 + 生成时间
+ 某个随机数</strong> 组成。求解字符串中的
<strong>某个随机数</strong>，使得最终的哈希值小于某个目标值（Target）。这里的
<strong>某个随机数</strong> 也被称为 <code>Nonce</code>。</p>
<p><code>Nonce</code> 是一个 32
位的二进制值，非常难猜的，目前只能通过穷举法一个个试错。</p>
<h2 id="难度系数">难度系数</h2>
<p>比特币系统中，难度系数（Difficulty）可以控制区块的生成速度。难度系数可以决定上述目标值的大小。</p>
<p>目标值和难度系数的计算关系如下，可见难度系数越大，目标值越小，因此符合条件哈希值范围越小，难度则越大。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标值 = 理论最大哈希值 / 难度系数</span><br></pre></td></tr></table></figure></p>
<h2 id="速度恒定">速度恒定</h2>
<p>比特币系统将区块的生成速度定为 <strong>每 10 分钟生成 1
个区块</strong>。那么，这是怎么做到的呢？</p>
<p>其实本质上就是难度系数的动态调整。由于目标值决定了符合条件的值范围，所以我们能够计算出任意一个随机数符合条件的概率为：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任意一个随机数符合条件的概率 = 目标值 / 理论最大哈希值 = 1 / 难度系数</span><br></pre></td></tr></table></figure></p>
<p>那么，这又是如何做到对时间的控制呢？</p>
<p>假设，世界上有 10000 台矿机，每台矿机的计算速度是 20T/s，即每秒能够
20T 次哈希运算。因此可以计算出整个世界的算力是 2 × 10^17 次/s。那么 10
分钟的算力则是： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十分钟的算力 = 10 × 60 × 2 × 10^17 = 1.2 × 10^20 次哈希运算</span><br></pre></td></tr></table></figure></p>
<p>因为 10
分钟内只能成功一次，所以我们可以得出以下等式，从而得出最终的难度系数。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 分钟的算力 × 符合条件的概率 = 1 次</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">1.2 × 10^20 × (1 / 难度系数) = 1</span><br><span class="line"></span><br><span class="line">求解 -&gt; 难度系数？</span><br></pre></td></tr></table></figure></p>
<p>由于全世界的算力一直都在变化，为了能够将产出速度控制在 10
分钟，比特币系统规定：难度系数每两周调整一次。如果这两周内，区块的平均生成速度是
9 分钟（意味着比法定速度快 10 %），则将难度系数调高 10 %。反之亦然。</p>
<h1 id="如何验证交易内容的真实性">如何验证交易内容的真实性？</h1>
<p>以示例为例，交易内容的真实性主要包含两个问题：</p>
<ul>
<li>A 向 B 转账 10 BTC 是否真的是 A 发出的消息？</li>
<li>A 是否真的有 10 BTC 以上资产？</li>
</ul>
<p>针对第一个问题，我们需要简单了解一下比特币的
<strong>账户地址</strong> 概念。</p>
<p>比特币用户在注册账户时，系统会自动生成一个随机数。利用随机数，系统可以生成一对非对称密钥（公钥+私钥）。比特币账户地址则是由公钥进行一系列哈希以及编码运算后生成的
160 位（20 字节）字符串。</p>
<p>用户 A 在发起一个交易时，会先对交易内容进行哈希运算，从而得到
<strong>摘要</strong>（Digest）；然后再用私钥对摘要进行加密，从而得到
<strong>数字签名</strong>（Signature）。最后，广播到比特币网络的内容则是：交易内容
+ 公钥 + 数字签名。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-verify01.png?x-oss-process=image/resize,w_800" /></p>
<p>当比特币网络的其他节点收到消息后，会对它进行验证：</p>
<ol type="1">
<li>对交易内容进行哈希运算，得到摘要 1</li>
<li>对数字签名使用公钥进行解密，得到摘要 2</li>
<li>判断摘要 1 和摘要 2 是否一致</li>
</ol>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-verify02.png?x-oss-process=image/resize,w_800" /></p>
<p>如果摘要 1 和摘要 2
一致，则证明交易内容是真实的，在广播过程中并未被篡改。那么如何证明消息的发起者也是
A 呢？毕竟，我们不能认可 B 发消息说 C 向 B 付款 10 BTC
这种内容。消息发起者必须是付款方。</p>
<p>为了解释这个问题，我们需要了解交易的生成。事实上，每个交易需要包括若干个
<strong>输入</strong> 和
<strong>输出</strong>。未经引用的交易输出（Unspent Transaction
Outputs，UTXO）可以被新的交易引用作为其合法的输入。已被引用的交易输出（Spent
Transaction Outputs，STXO）无法被新的交易引用作为其合法输入。</p>
<p>因此，比特币网络中的一笔合法的交易，必须是引用某些已存在交易的
UTXO（必须是属于付款方才能合法引用）作为新的交易的输入，并生成新的
UTXO（将属于收款方）。</p>
<p>如下所示为一些简单的交易示例。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">交易</th>
<th style="text-align: left;">目的</th>
<th style="text-align: left;">输入</th>
<th style="text-align: left;">输出</th>
<th style="text-align: left;">签名</th>
<th style="text-align: left;">差额</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">T0</td>
<td style="text-align: left;">A 转给 B</td>
<td style="text-align: left;">他人向 A 交易的输出</td>
<td style="text-align: left;">B 可以引用该交易</td>
<td style="text-align: left;">A 签名确认</td>
<td style="text-align: left;">输入减输出，为交易服务费</td>
</tr>
<tr class="even">
<td style="text-align: left;">T1</td>
<td style="text-align: left;">B 转给 C</td>
<td style="text-align: left;">T0 的输出</td>
<td style="text-align: left;">C 可以引用该交易</td>
<td style="text-align: left;">B 签名确认</td>
<td style="text-align: left;">输入减输出，为交易服务费</td>
</tr>
<tr class="odd">
<td style="text-align: left;">T2</td>
<td style="text-align: left;">X 转给 Y</td>
<td style="text-align: left;">他人向 X 交易的输出</td>
<td style="text-align: left;">Y 可以引用该交易</td>
<td style="text-align: left;">X 签名确认</td>
<td style="text-align: left;">输入减输出，为交易服务费</td>
</tr>
</tbody>
</table>
<p>至此，第一个问题得以解决。注：这里的解释相对简单，更深入的细节请参阅后文。</p>
<p>针对第二个问题，A 是否真的有 10 BTC 以上的资产。</p>
<p>这个问题的验证非常简单，可以通过在全局区块链进行追溯，即可得以验证。</p>
<h1 id="其他问题">其他问题</h1>
<h2 id="经济博弈">经济博弈</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-two-chain01.png?x-oss-process=image/resize,w_800" /></p>
<p>假设，全局区块链有一个区块，其内部记载了 A 向 B 转账 100 BTC
的交易内容。然而，比特币网络中有一个恶意节点，该恶意节点希望对该区块的交易记录进行篡改，因此在该区块前开辟了一个分叉。那么它最终能得逞吗？</p>
<p>为了解释这个问题，我们需要先介绍比特币系统的
<strong>最长链原则</strong>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最长链原则：所有节点默认信任全局区块链中最长的分支。</span><br></pre></td></tr></table></figure></p>
<p>根据最长链原则，除恶意节点以外的其他节点，都会信任区块链的最长分支。如果恶意节点希望其所在分支成为最长分支，那么它占据全局
51%
以上的算力，才可能战胜其他所有节点。这从经济学角度而言，它需要付出巨大的成本，却只能获得不大的收益，投入与产出严重不匹配。</p>
<h1 id="总结">总结</h1>
<p>比特币采用区块链这种分布式数据库作为底层支撑，从 2009
年开始运行，经历了大规模长时间检验。证明它是可行的。</p>
<p>区块链虽然有去中心化、解决信任问题等优点，但是它也有很明显的缺点：</p>
<ul>
<li>效率低。数据写入区块，需要等待十分钟，所有节点的数据需要进行同步，效率低下。</li>
<li>高能耗。所有节点中只有一个节点的工作是真正有效的，其他节点都是无意的，就这一点来说是非常耗费资源的。</li>
</ul>
<p>因此，我们不能偏执地认为新的技术或科技产物就一定是先进的，而需要理性看待它的优点和缺点。</p>
<p>最后，比特币所包含的区块链技术在很多场景下得以扩展和应用，值得我们去学习。另外，比特币所蕴含的分布式系统设计思想和密码学原理也同样值得我们去深入学习。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://bitcoin.org">bitcoin</a></li>
</ol>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>比特币</tag>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Xcode 中的各种概念</title>
    <url>/2021/12/03/understand-concepts-in-xcode/</url>
    <content><![CDATA[<p>Xcode
有非常多的概念，比如：workspace、project、target、product、scheme
等，这些概念之间有着千丝万缕的关系，当我们理解了这些概念及其关系之后，会对整个
Xcode
工程体系有一个整体的理解，对我们自身工程能力的提升也会有所帮助。本文将对这些概念及其关系进行梳理，从而为后续的学习提供基础。</p>
<span id="more"></span>
<h1 id="整体关系">整体关系</h1>
<p>下图所示是 Xcode
的核心概念之间的关系示意图，我们简单地进行介绍一下。</p>
<ul>
<li><strong>Workspace</strong>：Xcode 提供的一个工作空间，其可以包含多个
project。通过组合 project，我们可以实现非常庞大、复杂的工程。</li>
<li><strong>Project</strong>：一个 Xcode 工程的核心，project
维护并管理源代码、资源文件、框架和库等。此外，project 还提供了默认的
build configurations，用于指导构建 product。<strong>其中，每个 build
configuration 包含一组 build setting</strong>。</li>
<li><strong>Target</strong>：其包含构建特定 product 所需的 build
configuration、build rule、build phase，并指定对应的构建产物
product。</li>
<li><strong>Product</strong>：基于 project 的源文件，根据 build
phase、build rule 以及 project 和 target 的 build configuration
所构建的产物。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-02.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们分别介绍一下这几个核心概念。</p>
<h1 id="workspace">Workspace</h1>
<p>Xcode Workspace 主要用于为 Xcode project 提供一个工作空间，通过组合
project 可以实现一个复杂的工程。</p>
<p><strong>一个 workspace 可以包含任意数量的
project，以及任意其他要处理的文件</strong>。<strong>Xcode
能够记录或推导这些 project 和 target
之间显式或隐式的依赖关系</strong>。</p>
<ul>
<li>对于隐式依赖，比如，在同一个 workspace 中，project A
构建了一个库，该库又被 project B 链接，那么 Xcode 会在构建 project B
之前，自动构建 project A（即使 build setting
中并没有明确此依赖关系）。</li>
<li>对于显式依赖，我们必须创建 project 进行引用。</li>
</ul>
<p>Workspace 也是 Xcode
工作流的一种扩展。比如：文件的索引（indexing）是在 workspace
中进行的，因此代码补全、定义跳转以及其他内容感知的相关功能都可以在
workspace 下的所有 project 中使用。</p>
<p>默认情况下，workspace 中的所有 project 都在同一个目录下构建，即
workspace 构建目录。<strong>由于同一个 workspace 下的 project
的所有文件都在同一个构建目录下，所以该目录下的所有文件对于每一个 project
都是可见的</strong>。因此，如果有两个或多个 project
使用了相同的库，我们无需将它们复制到每个 project 中。如果某个 project
指定了构建目录，那么在构建该 project 时，该构建目录会被 project 所在的
workspace 的构建目录所覆盖。</p>
<p>同一个 workspace 下的每个 project 都是独立的。因此，为了不影响其他
project 或不受其他 project 影响，我们可以在不打开 workspace
的情况下直接打开 project，或者将 project 添加到另一个 workspace。由于
<strong>一个 project 可以同时属于多个
workspace</strong>，因此我们可以以任意组合 project，而无需重新配置任何
project 或 workspace。</p>
<h1 id="project">Project</h1>
<p><strong>Xcode Project 是一个 Xcode
工程的核心部分，其本质上是一个文件、资源、构建信息所组成的仓库，能够构建一个或多个
product</strong>。一个 project 包含了所有用于构建 product
的元素，并且维护了这些元素之间的关系。<strong>Project 包含一个或多个
target，这些 target 各自定义了如何构建一个 product</strong>。一个
project 为其所包含的所有 target 定义了默认的 build
configurations，其中的每个 target 又可以指定自己的 build
configurations，target 定义的 build configurations 能够覆盖 project
定义的 build configurations。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-03.png?x-oss-process=image/resize,w_800" /></p>
<p>Project 使用一个 <code>.pbxproj</code>
为后缀的文件进行描述，其主要包含了以下内容：</p>
<ul>
<li>对源文件的引用，如上图左侧导航栏所示。
<ul>
<li>源代码，包含头文件和实现文件</li>
<li>库和框架，内部或外部的</li>
<li>资源文件</li>
<li>图片文件</li>
<li>nil 文件</li>
</ul></li>
<li>用于在 Xcode 项目导航栏中组织源文件的组（Group）</li>
<li><strong>Project 级别的 build
configurations</strong>。如上图所示，我们会为一个 project 指定多个 build
configuration，比如，我们会定义 Debug 和 Release 两种类型的 build
configuration，并分别为它们定义 build settings，如上图所示。</li>
<li><strong>一个或多个 target</strong>，每个 target 均包含以下内容：
<ul>
<li>对应 product 的引用</li>
<li>构建 product 所需源文件的引用</li>
<li>用于构建 product 的 build configurations</li>
</ul></li>
<li>用于调试或测试的可执行环境，其中每个可执行环境均包含以下内容：
<ul>
<li>当通过 Xcode 运行或调试时，要启动哪个可执行文件</li>
<li>当执行可执行文件时，要传递哪些命令行参数</li>
<li>当程序运行时，要设置哪些环境变量</li>
</ul></li>
</ul>
<p>我们可以通过 scheme 来指定某一时刻哪个 target、哪个 build
configuration 是有效的。</p>
<h1 id="target">Target</h1>
<p><strong>Xcode Target 主要用于指导如何从 project 或 workspace 构建
product，其定义了构建系统的输入——源文件和处理源文件的配置，从而构建
product</strong>。</p>
<p>如下所示，当我们通过 Xcode 创建 project 时，Xcode 会默认自动创建
target 用于指导构建主 app，此外 Xcode 会默认勾选 【include
Tests】选项从而创建测试相关的 target，分别用于单元测试、UI 测试。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-01.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-02.png?x-oss-process=image/resize,w_800" /></p>
<p>Target 中构建 product 的 build configurations 主要包括：build
settings、build configuration 的名称（如：Debug）以及对 project 级别的
build configuration 的引用。</p>
<p>对于 build settings，我们应该都很熟悉，在日常开发中我们一般都通过
Xcode 项目编辑器直接进行编辑。Target 默认继承 project 定义的 build
settings，当然，target 也可以通过自定义 build settings 进行覆盖。</p>
<p>一个 target 及其创建的 product 可以与另一个 target 产生关联。如果
target A 需要 target B 的输出才能构建，即 target A 依赖了 target
B。如果两个 target 在同一个 workspace 中，那么 Xcode
就能够找到其中的依赖关系，在这种场景下，Xcode 会按顺序构建
product。这种关系称为隐式依赖。</p>
<p>我们还可以在 build settings 中显式地指定 target
的依赖项，并且我们可以将 Xcode 认为具有隐式依赖关系的两个 target
指定为不相关。比如：我们可以在同一个 workspace
中同时构建一个库和一个链接了这个库的应用程序。但是，如果我们想要链接到某个版本的库，而
workspace 中构建的这个库并不是这个版本，那么我们可以在 build settings
中创建一个显式依赖，它将覆盖隐式依赖。</p>
<p>同一时刻只能有一个活跃的 target，由 scheme 指定。</p>
<h1 id="product">Product</h1>
<p>Xcode Product 是基于 project 或 workspace 提供的源文件，根据 project
和 target 的 build configuration 构建而成的产物。苹果预定义了几种
Product
类型，主要有：应用程序（application）、测试（test）、静态库（static
library）、框架（framework）等。这些 Product
类型，可以从文件的后缀进行区分。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-05.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="build-settings">Build Settings</h1>
<p>Xcode Build Settings 是一组变量，包含有关 product
构建过程的各种信息。比如：build settings 中的信息可以指定 Xcode
传递哪些选项给编译器。</p>
<p>我们可以在 project 级别或 target 级别设置 build settings。每个
project 级别的 build setting 都会应用到 project 中的所有 target，除非
target 显式地覆盖了 build setting。</p>
<p>每个 target 组织构建一个 product 所需的所有源文件。Build
Configuration 则指定了一组 build settings，从而以特定方式为 target 构建
product。比如：对于构建 Debug 和 Release 类型的
product，我们会分别定义两个 build configuration，每个 build
configuration 各自包含一组 build settings。</p>
<p>Xcode 中的 build setting 有两个部分：</p>
<ul>
<li><strong>setting title</strong>：标识了 build setting，并且可以被其他
setting 所使用。</li>
<li><strong>setting definition</strong>：一个常量或公式，Xcode
在构建时会用它来确定 build setting 的值。</li>
</ul>
<p>Build setting 也可能有一个显示名称，用于在 Xcode 用户界面中显示 build
setting。如下所示就是 Xcode 中的一些 build setting。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ALWAYS_SEARCH_USER_PATHS: &#x27;NO&#x27;</span><br><span class="line">CLANG_ANALYZER_NONNULL: &#x27;YES&#x27;</span><br><span class="line">CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION: YES_AGGRESSIVE</span><br><span class="line">CLANG_CXX_LANGUAGE_STANDARD: gnu++14</span><br><span class="line">CLANG_CXX_LIBRARY: libc++</span><br><span class="line">CLANG_ENABLE_MODULES: &#x27;YES&#x27;</span><br><span class="line">CLANG_ENABLE_OBJC_ARC: &#x27;YES&#x27;</span><br><span class="line">CLANG_ENABLE_OBJC_WEAK: &#x27;YES&#x27;</span><br><span class="line">GCC_WARN_UNUSED_FUNCTION: &#x27;YES&#x27;</span><br><span class="line">GCC_WARN_UNUSED_VARIABLE: &#x27;YES&#x27;</span><br><span class="line">IPHONEOS_DEPLOYMENT_TARGET: &#x27;10.0&#x27;</span><br><span class="line">MTL_ENABLE_DEBUG_INFO: INCLUDE_SOURCE</span><br><span class="line">MTL_FAST_MATH: &#x27;YES&#x27;</span><br><span class="line">ONLY_ACTIVE_ARCH: &#x27;YES&#x27;</span><br><span class="line">SDKROOT: iphoneos</span><br><span class="line">SWIFT_ACTIVE_COMPILATION_CONDITIONS: DEBUG</span><br><span class="line">SWIFT_OPTIMIZATION_LEVEL: &quot;-Onone&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>当我们使用模板创建一个新的 project 时，除了 Xcode 提供的默认的 build
settings，我们还可以为 project 或 target 创建自定义的 build
setting。我们还可以指定 <strong>条件式 build setting</strong>。条件式
build setting 的值取决于是否满足一个或多个先决条件。例如：我们可以根据
target 的架构决定是否使用某个 SDK。</p>
<h1 id="build-phases">Build Phases</h1>
<p>Xcode Build Phases 是一系列在构建一个 target
期间执行的任务，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-06.png?x-oss-process=image/resize,w_800" /></p>
<p>在 Xcode 中，主要包含 7 种类型的 build phase，分别如下：</p>
<ul>
<li><strong>Compile sources</strong>
<ul>
<li>将可编译的源文件（如 Swift、Objective-C、Lex、Yacc）与当前 target
进行关联，并进行编译。如果有必要，为每个源文件指定编译选项。</li>
<li><strong>此种类型的 build phase 可以为每个 target 使用一次，但是对于
Aggregate Target 和 External Build Tool Target，此种类型的 build phase
无法使用</strong>。</li>
</ul></li>
<li><strong>Copy bundle resources</strong>
<ul>
<li>将资源与当前 target 进行关联，在合适时进行处理，并将它们复制到
product 的 Resource 子文件夹中。</li>
<li><strong>此种类型的 build phase 可以为每个 target
使用一次，并且当且仅当 target 的 product
支持嵌入式资源时才能使用</strong>。</li>
</ul></li>
<li><strong>Copy files</strong>
<ul>
<li>将其他 target 的 product 与当前 target 进行关联，必要时对他们进行
code sign，然后将它们复制到目标地址（一般是 product
中的一个子文件夹）。</li>
<li><strong>此种类型的 build phase
在所有构建过程或进行安装构建过程中使用，每个 target
可以多次使用它</strong>。</li>
</ul></li>
<li><strong>Headers</strong>
<ul>
<li>将 public header、private header、project header 文件与当前 target
进行关联。public/private header 定义对外的 API，并且会被复制到 product
中进行安装。比如：一个 framework target 中的 public/private header
会被复制到 product 的 Headers 和 PrivateHeaders 子文件夹中。project
header 定义 target 使用的 API，但不会复制到 product 中。</li>
<li><strong>每个 target 只能使用一次此种类型的 build
phase</strong>。</li>
</ul></li>
<li><strong>Link binary with libraries</strong>
<ul>
<li>将 Apple frameworks 等库与当前 target
进行关联。这些库可以是平台库、其他 target 生成的库、外部预构建的
XCFramework
和库。这些库可以被指定为必选的或可选的（弱链接——即库不存在，应用程序也可以加载）。</li>
<li><strong>此种类型的 build phase 可以为每个 target 使用一次，但是对于
Aggregate Target 和 External Build Tool Target，此种类型的 build phase
无法使用</strong>。</li>
</ul></li>
<li><strong>Run script</strong>
<ul>
<li>在构建过程中运行指定的 shell 脚本。此脚本可以使用当前 target 的
build settings
所定义的变量，比如：$(SRCROOT)，表示包含目标源文件的目录。此外，还允许我们提供输入和输出文件的列表。当没有提供输入和输出文件时，脚本也会运行。当提供输入和输出文件时，脚本仅在之前从未运行、或输入文件发生过变化、或输出文件发生过丢失时运行。</li>
<li><strong>此种类型的 build phase
在所有构建过程或进行安装构建过程中使用，每个 target
可以多次使用它</strong>。</li>
</ul></li>
<li><strong>Target dependencies</strong>
<ul>
<li>显式指定在同一 project（非同一 workspace）或链接 project 中的其他
target，这些 target 必须在当前 target 自身构建之前进行构建。比如：依赖于
project 中另一个框架的 target 通常会配置有对该框架的 target
依赖项。Xcode 能够隐式地推断出一些依赖项，但是此 build phase
能够提供对依赖项及其构建顺序的更优的控制。</li>
</ul></li>
</ul>
<h1 id="scheme">Scheme</h1>
<p>Xcode Scheme
定义一组操作，默认有：Build、Test、Launch、Profile、Analyze、Archive。每一种操作定义了一系列的指令，包括：target、build
configuration、arguments、options
等等，这些参数、指令共同构成一个构建方案，从而用于构建一个或多个
target。</p>
<p>我们可以拥有任意数量的 scheme，但一次只能激活一个 scheme，对应在
Xcode 的右上角我们每次只能选中一个 scheme。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-07.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文简单梳理了一下 Workspace、Project、Target、Product、Scheme
等概念，对 Xcode 的整个构建体系有了一个大致的认识。</p>
<p>后续我们再来详细介绍一下这些概念在 Xcode 中具体是如何表示的。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://developer.apple.com/library/archive/featuredarticles/XcodeConcepts/Concept-Targets.html">Xcode
Concepts</a></li>
<li><a href="https://michele.io/the-project-file-part-1/">The Project
File Part 1: Composition</a></li>
<li><a href="https://michele.io/the-project-file-part-2/">The Project
File Part 2: Schemes and Targets</a></li>
<li><a
href="http://www.monobjc.net/xcode-project-file-format.html">Xcode
Project File Format</a></li>
<li><a
href="http://yulingtianxia.com/blog/2016/09/28/Let-s-Talk-About-project-pbxproj/">Let's
Talk About project.pbxproj</a></li>
<li><a
href="https://github.com/genify/nei/blob/master/doc/ObjectiveCGenRules/XcodeProjectRules/xcode_project_file_format.md">Xcode
Project File Format</a></li>
<li><a href="https://www.cnblogs.com/lxlx1798/p/9369537.html">Xcode
编辑器之Workspace，Project，Scheme，Target</a></li>
<li><a href="https://www.jianshu.com/p/2ddba8c0062c">iOS Xcode工程目录的
folder 和 group的区别</a></li>
<li><a
href="https://help.apple.com/xcode/mac/11.4/index.html?localePath=en.lproj#/dev0bee46f46">Configure
schemes</a></li>
<li><a href="http://github.com/CocoaPods/Xcodeproj">Xcodeproj</a></li>
<li><a
href="https://help.apple.com/xcode/mac/current/#/dev50bab713d">What are
build phases?</a></li>
</ol>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>Workspace</tag>
        <tag>Project</tag>
        <tag>Target</tag>
        <tag>Product</tag>
        <tag>Scheme</tag>
        <tag>Build Phase</tag>
        <tag>Build Setting</tag>
        <tag>Build Configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Xcode 中的各种文件</title>
    <url>/2021/12/14/understand-files-in-xcode/</url>
    <content><![CDATA[<p>上一篇文章我们介绍了 Xcode 中的各种概念，本文我们来看看这些概念在
Xcode 中的具体表示。其中，有一个最常见的文件
<code>project.pbxproj</code>，其描述了描述了整个 Xcode Project
的相关信息，包括：文件、Target、Product 等。另外，Xcode Workspace 则使用
<code>contents.xcworkspacedata</code> 进行描述，主要描述了其所包含的
Project 的位置。Xcode Scheme 则使用 <code>.xcscheme</code>
后缀的文件进行描述。</p>
<span id="more"></span>
<p>下面，我们来对这几个文件分别进行介绍。</p>
<h1 id="project.pbxproj">project.pbxproj</h1>
<p>Xcode Project 使用 <code>project.pbxproj</code> 来描述一个 Xcode
工程所包含的所有内容，包括文件、配置、库等，其存储在 Xcode 工程文件
<code>*.xcodeproj</code> 中。</p>
<h2 id="文件格式">文件格式</h2>
<p><code>project.pbxproj</code> 是一种旧风格的 Property List 文件（简称
<code>plist</code>）。Property List 与 JSON
最主要的区别在于数组和字典的表示：</p>
<ul>
<li>数组：使用小括号表示，数组元素使用逗号进行分隔</li>
<li>字典：使用大括号表示，键和值之间使用等号链接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># plist 数组</span><br><span class="line">(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)</span><br><span class="line"></span><br><span class="line"># plist 字典</span><br><span class="line">&#123;</span><br><span class="line">    &quot;key&quot; = &quot;value&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象关系">对象关系</h2>
<p>本质上，<code>project.pbxproj</code> 是一个对象关系图，所有的对象都与
Xcode 中的某个文件、配置、操作相对应，<strong>每一个对象都使用一个 96
bit（24 位的十六进制）的UUID 进行唯一标识</strong>，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00004989A1D96C5B52A8E09B8A3BC4B5 /* DoraemonFPSPlugin.h in Headers */ = &#123;isa = PBXBuildFile; fileRef = 3B3712CE0D0A78D8379015D4C5647631 /* DoraemonFPSPlugin.h */; settings = &#123;ATTRIBUTES = (Project, ); &#125;; &#125;;</span><br><span class="line">00010094FB6FF27A828CF8A15DEAA184 /* TTCommonModelUtils.h in Headers */ = &#123;isa = PBXBuildFile; fileRef = 740D1037D25E920AA9913B575B6AF7C0 /* TTCommonModelUtils.h */; settings = &#123;ATTRIBUTES = (Project, ); &#125;; &#125;;</span><br><span class="line">0007199E29D1EB8473295A64FB7C1D99 /* CLIColor.h in Headers */ = &#123;isa = PBXBuildFile; fileRef = 4B0381C866EF001605422EEE7598F3CB /* CLIColor.h */; settings = &#123;ATTRIBUTES = (Project, ); &#125;; &#125;;</span><br></pre></td></tr></table></figure>
<p><code>project.pbxproj</code>
整体构成了一个树状的对象关系图，其类图大体如下所示。Xcode
中的各种概念大多数在类图中能够找到对应的类，比如：</p>
<ul>
<li>Project 对应 PBXProject</li>
<li>Build Configuration 对应 XCBuildConfiguration</li>
<li>Target 对应 PBXTarget</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-03.png" /></p>
<h3 id="root-element">Root Element</h3>
<p><code>project.pbxproj</code> Root Element
作为整个对象树的根节点。通过 <code>rootObejct</code> 为键引用一个
<code>PBXProject</code> 对象。<code>objects</code> 则定义了整个 project
中的所有相关文件。</p>
<h3 id="pbxproject">PBXProject</h3>
<p><code>PBXProject</code> 定义了一个编译配置列表对象
<code>buildConfigurationList</code>，该对象中定义了一组
<code>XCBuildConfiguration</code>，其中每一个
<code>XCBuildConfiguration</code> 定义了一系列的 build settings。</p>
<p>关于文件的组织和维护，<code>PBXProject</code> 以
<code>mainGroup</code> 为键引用了一个 <code>PBXGroup</code>
对象。<code>PBXGroup</code> 对应 Xcode 中的 Group 的概念，类似于
Folder，但有所区别，主要用于 Xcode
中组织管理源文件。<code>mainGroup</code>
定义了文件组织结构的根节点，通过层层递进，可以索引到工程中的所有文件。</p>
<p>当然，<code>PBXProject</code> 还定义了一系列的
<code>PBXTarget</code>。这里的 <code>PBXTarget</code> 对应上述的 Xcode
Target。</p>
<h3 id="pbxtarget">PBXTarget</h3>
<p>类图中定义的 <code>PBXTarget</code>
是一个抽象类，其主要有以下几种具体类型：</p>
<ul>
<li><strong><code>PBXNativeTarget</code></strong>：一次构建一个
target。Xcode 项目中最常用的 target。</li>
<li><strong><code>PBXLegacyTarget</code></strong>：通过命令行进行构建。如果一个
project 的依赖项需要通过 <code>make</code> 来构建，那么应该使用这种
target。</li>
<li><strong><code>PBXAggregateTarget</code></strong>：同时构建多个
target，也可以用于执行不输出 product 的场景。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-01.png" /></p>
<p>这些具体类型的 target，比如
<code>PBXNativeTarget</code>，引用了一系列的
<code>PBXBuildRule</code>、<code>PBXBuildPhase</code>，还定义了输出的
product 的相关信息。</p>
<p>当然，这些 target 还引用了一组
<code>XCBuildConfiugration</code>，<code>XCBuildConfiguration</code>
中通过 <code>baseConfigurationReference</code> 引用了 project 级别的
<code>XCBuildConfiguration</code>，从而进行继承或覆盖。</p>
<p><code>PBXTarget</code> 还定义了一组
<code>PBXTargetDependency</code>，即上述提到的如果 target A 依赖了
target B，那么 target B 就是 target A 的一个依赖项。</p>
<h3 id="pbxbuildphase">PBXBuildPhase</h3>
<p><code>PBXBuildPhase</code> 也是一个抽象类，其主要包含 7
种具体类型，正好与 Xcode 中的 7 种 build phase 相对应：</p>
<ul>
<li><strong><code>PBXHeadersBuildPhase</code></strong>：对应 Headers
Phase</li>
<li><strong><code>PBXSourcesBuildPhase</code></strong>：对应 Compile
Sources Phase</li>
<li><strong><code>PBXFrameworksBuildPhase</code></strong>：对应 Link
Binary With Libraries Phase</li>
<li><strong><code>PBXCopyFilesBuildPhase</code></strong>：对应 Copy
Files Phase</li>
<li><strong><code>PBXShellScriptBuildPhase</code></strong>：对应 Run
Script Phase</li>
<li><strong><code>PBXResourcesBuildPhase</code></strong>：对应 Copy
Bundle Resources Phase</li>
<li><strong><code>PBXRezBuildPhase</code></strong>：对应 Build Carbon
Resources Phase</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-04.png" /></p>
<h3 id="pbxbuildfile">PBXBuildFile</h3>
<p><code>project.pbxproj</code> 使用 <code>PBXBuildFile</code>
表示构建文件，其定义了以下五种类型的文件引用。</p>
<ul>
<li><strong><code>PBXFileReference</code></strong></li>
<li><strong><code>PBXGroup</code></strong></li>
<li><strong><code>PBXReferenceProxy</code></strong></li>
<li><strong><code>PBXVariantGroup</code></strong></li>
<li><strong><code>XCVersionGroup</code></strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-07.png" /></p>
<p>这里提到了 group 的概念，group 和 folder
是存在区别的，主要有以下两方面：</p>
<ul>
<li>Group
只在工程一般是文件夹的形式，但是在本地的目录还是以散乱的形式放在一起，除非是从外部以
group 的形式引用进来，这种情况下的 group 同时是一个文件夹实体。</li>
<li>Folder 只能作为资源，folder
下的所有内容都会引入项目，不会被编译。也就是说，以 folder
形式引用进来的文件，不能被放在 compile sources 列表中。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-05.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="contents.xcworkspacedata">contents.xcworkspacedata</h1>
<p>Xcode Workspace 使用 <code>contents.xcworkspacedata</code> 来描述
workspace 中 project 的组成。如下所示，一个 workspace 包含两个
project，分别是：<code>Demo.xcodeproj</code> 和
<code>Pods/Pods.xcodeproj</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Workspace</span><br><span class="line">   version = &quot;1.0&quot;&gt;</span><br><span class="line">   &lt;FileRef</span><br><span class="line">      location = &quot;group:Demo.xcodeproj&quot;&gt;</span><br><span class="line">   &lt;/FileRef&gt;</span><br><span class="line">   &lt;FileRef</span><br><span class="line">      location = &quot;group:Pods/Pods.xcodeproj&quot;&gt;</span><br><span class="line">   &lt;/FileRef&gt;</span><br><span class="line">&lt;/Workspace&gt;</span><br></pre></td></tr></table></figure>
<h1 id="xcscheme">.xcscheme</h1>
<p>Xcode Scheme 使用 <code>.xcscheme</code> 后缀的 XML
文件进行描述，其存储在 <code>xcshareddata</code> 目录下。Xcode Scheme
默认定义了 6 种操作，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-07.png?x-oss-process=image/resize,w_800" /></p>
<p>对应在 <code>.xcscheme</code> 文件中，同样定义了这 6 个默认
action，如下所示。每个操作中具体定义相关的 build
configuration、arguments、options 等信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Scheme</span><br><span class="line">   LastUpgradeVersion = &quot;0500&quot;</span><br><span class="line">   version = &quot;1.7&quot;&gt;</span><br><span class="line">   &lt;BuildAction&gt;</span><br><span class="line">   	...</span><br><span class="line">   &lt;/BuildAction&gt;</span><br><span class="line">   &lt;TestAction&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/TestAction&gt;</span><br><span class="line">   &lt;LaunchAction&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/LaunchAction&gt;</span><br><span class="line">   &lt;ProfileAction&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/ProfileAction&gt;</span><br><span class="line">   &lt;AnalyzeAction&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/AnalyzeAction&gt;</span><br><span class="line">   &lt;ArchiveAction&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/ArchiveAction&gt;</span><br><span class="line">&lt;/Scheme&gt;</span><br></pre></td></tr></table></figure>
<h2 id="buildablereference">BuildableReference</h2>
<p><code>.xcscheme</code> 每一个 action 的依赖被定义在
<code>BuildableReference</code> 中。如果有一个 action 中包含了
<code>BuildableReference</code>，那么就意味着 Build Action 被作为当前
action 的依赖，首先被执行。在 <code>.xcscheme</code> 中，同一个
<code>BuildableReference</code> 可能会被包含多次，从而引用同一个
target。这里使用 UUID 来引用一个 target，由
<code>BlueprintIdentifier</code> 指定。这里的 UUID 对应的 target 定义在
<code>project.pbxproj</code> 文件中。如下所示，是一个
<code>BuildableReference</code> 的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;BuildableReference</span><br><span class="line">   BuildableIdentifier = &quot;primary&quot;</span><br><span class="line">   BlueprintIdentifier = &quot;3AA4FE2703EA4DC3A89C1CCC&quot;</span><br><span class="line">   BuildableName = &quot;libPods.a&quot;</span><br><span class="line">   BlueprintName = &quot;Pods&quot;</span><br><span class="line">   ReferencedContainer = &quot;container:Pods/Pods.xcodeproj&quot;&gt;</span><br><span class="line">&lt;/BuildableReference&gt;</span><br></pre></td></tr></table></figure>
<h2 id="actions">Actions</h2>
<p>Xcode Scheme 中的 action 中只有 Build Action 可以引用多个
target。因此，它在 <code>BuildActionEntries</code> 中包含了一个
<code>BuildableReferences</code> 列表，这些列表项引用了 target
所指定的显式依赖项。这些依赖项来源于 Target Dependencies 或 Link Binary
With Library。对于其他的 action，它们会将
<code>BuildableReference</code> 嵌套在其内部，如果需要的话。</p>
<p>此外，每一个 action 都有这不同的配置选项，如下所示。所有的 action
都有 <code>pre-actions</code> 和 <code>post-actions</code>，它们可以在主
action 执行之前执行。相对来说，Analyze 和 Archive 的选项最少，Launch
的选项最多。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/xcodeproj-target-08.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="options">Options</h2>
<p>所有的 action 都有相关的选项，它们会以属性的形式存储在 Action
中，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LaunchAction</span><br><span class="line">  buildConfiguration = &quot;Debug&quot;</span><br><span class="line">  selectedDebuggerIdentifier = &quot;Xcode.DebuggerFoundation.Debugger.LLDB&quot;</span><br><span class="line">  selectedLauncherIdentifier = &quot;Xcode.DebuggerFoundation.Launcher.LLDB&quot;</span><br><span class="line">  launchStyle = &quot;0&quot;</span><br><span class="line">  useCustomWorkingDirectory = &quot;NO&quot;</span><br><span class="line">  ignoresPersistentStateOnLaunch = &quot;NO&quot;</span><br><span class="line">  debugDocumentVersioning = &quot;YES&quot;</span><br><span class="line">  debugServiceExtension = &quot;internal&quot;</span><br><span class="line">  allowLocationSimulation = &quot;YES&quot;&gt;</span><br><span class="line">  &lt;BuildableProductRunnable</span><br><span class="line">     runnableDebuggingMode = &quot;0&quot;&gt;</span><br><span class="line">     &lt;BuildableReference</span><br><span class="line">        BuildableIdentifier = &quot;primary&quot;</span><br><span class="line">        BlueprintIdentifier = &quot;65851935276F4EFB000D11BE&quot;</span><br><span class="line">        BuildableName = &quot;Demo.app&quot;</span><br><span class="line">        BlueprintName = &quot;Demo&quot;</span><br><span class="line">        ReferencedContainer = &quot;container:Demo.xcodeproj&quot;&gt;</span><br><span class="line">     &lt;/BuildableReference&gt;</span><br><span class="line">  &lt;/BuildableProductRunnable&gt;</span><br><span class="line">&lt;/LaunchAction&gt;</span><br></pre></td></tr></table></figure>
<h2 id="pre-actions-post-actions">Pre-Actions &amp; Post-Actions</h2>
<p>Pre-Actions 和 Post-Action 主要有两种类型：</p>
<ul>
<li>发送邮件</li>
<li>运行脚本</li>
</ul>
<p>对于 Send Email Action，它会打开 Mail.app 并发送邮件，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ExecutionAction</span><br><span class="line">   ActionType = &quot;Xcode.IDEStandardExecutionActionsCore.ExecutionActionType.SendEmailAction&quot;&gt;</span><br><span class="line">   &lt;ActionContent</span><br><span class="line">      title = &quot;Send Email&quot;</span><br><span class="line">      emailRecipient = &quot;thedoctor@tardis.space&quot;</span><br><span class="line">      emailSubject = &quot;Sup&quot;</span><br><span class="line">      emailBody = &quot;Bowties are cool&quot;</span><br><span class="line">      attachLogToEmail = &quot;NO&quot;&gt;</span><br><span class="line">   &lt;/ActionContent&gt;</span><br><span class="line">&lt;/ExecutionAction&gt;</span><br></pre></td></tr></table></figure>
<p>对于 Script Action，它可以运行任何脚本。类似于
<code>PBXShellScriptBuildPhase</code>，脚本会被包含在
<code>.xcscheme</code>
文件中。默认，脚本会在构建目录下运行。因此，如果我们想修改 workspace
的内容，则可以运行 <code>cd $&#123;SRCROOT&#125;</code>，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $&#123;SRCROOT&#125;</span><br><span class="line"></span><br><span class="line">pod install #&gt;&gt; /tmp/output.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ExecutionAction</span><br><span class="line">   ActionType = &quot;Xcode.IDEStandardExecutionActionsCore.ExecutionActionType.ShellScriptAction&quot;&gt;</span><br><span class="line">   &lt;ActionContent</span><br><span class="line">      title = &quot;Run Script&quot;</span><br><span class="line">      scriptText = &quot;cd $&#123;SRCROOT&#125;&amp;#10;&amp;#10;pod install #&amp;gt;&amp;gt; /tmp/output.txt&quot;</span><br><span class="line">      shellToInvoke = &quot;/usr/bin/env bash&quot;&gt;</span><br><span class="line">      &lt;EnvironmentBuildable&gt;</span><br><span class="line">         &lt;BuildableReference</span><br><span class="line">            BuildableIdentifier = &quot;primary&quot;</span><br><span class="line">            BlueprintIdentifier = &quot;D9B6428F176A2E17003D8169&quot;</span><br><span class="line">            BuildableName = &quot;Catstagrame.app&quot;</span><br><span class="line">            BlueprintName = &quot;Catstagrame&quot;</span><br><span class="line">            ReferencedContainer = &quot;container:Catstagrame.xcodeproj&quot;&gt;</span><br><span class="line">         &lt;/BuildableReference&gt;</span><br><span class="line">      &lt;/EnvironmentBuildable&gt;</span><br><span class="line">   &lt;/ActionContent&gt;</span><br><span class="line">&lt;/ExecutionAction&gt;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>本文我们简单地介绍了一下 Xcode
中的三个文件：<code>project.pbxproj</code>、<code>contents.xcworkspacedata</code>、<code>.xcscheme</code>。后两个文件分别描述了
workspace 和 scheme 的具体信息。<code>project.pbxproj</code>
则包含了除此之外的所有信息，包括：target、product、files、build
configuration 等等。</p>
<p>了解了 Xcode
中的概念和文件之后，我们可以针对特定场景对这些文件进行修改、适配，从而解决特定问题。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://developer.apple.com/library/archive/featuredarticles/XcodeConcepts/Concept-Targets.html">Xcode
Concepts</a></li>
<li><a href="https://michele.io/the-project-file-part-1/">The Project
File Part 1: Composition</a></li>
<li><a href="https://michele.io/the-project-file-part-2/">The Project
File Part 2: Schemes and Targets</a></li>
<li><a
href="http://www.monobjc.net/xcode-project-file-format.html">Xcode
Project File Format</a></li>
<li><a href="https://github.com/CocoaPods/Xcodeproj">Xcodeproj</a></li>
</ol>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>project.pbxproj</tag>
        <tag>contents.xcworkspacedata</tag>
        <tag>xcscheme</tag>
      </tags>
  </entry>
  <entry>
    <title>如何从链接原理的角度理解 fishhook 的设计思想？</title>
    <url>/2023/06/24/understand-fishhook-design/</url>
    <content><![CDATA[<p>最近在三刷《程序员的自我修养：链接、装载与库》，为了加深对于相关知识的理解，我又阅读了
fishhook 的源码。本文希望从程序的链接原理出发，详细介绍 fishhook
的设计原理，学习其中的设计思想。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>Fishhook 是 Facebook 开源的一款面向 iOS/macOS 平台的
<strong>符号动态重绑定</strong> 工具，允许开发者在运行时修改 Mach-O
中的符号（函数），从而实现 <strong>动态库</strong> 的函数 hook
能力。</p>
<p>Fishhook 提供了两个用于符号重绑定的接口，分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], <span class="type">size_t</span> rebindings_nel)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols_image</span><span class="params">(<span class="type">void</span> *header,</span></span><br><span class="line"><span class="params">                         <span class="type">intptr_t</span> slide,</span></span><br><span class="line"><span class="params">                         <span class="keyword">struct</span> rebinding rebindings[],</span></span><br><span class="line"><span class="params">                         <span class="type">size_t</span> rebindings_nel)</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>rebind_symbols</code>
可以在所有动态库范围内进行符号重绑定，而
<code>rebind_symbols_image</code>
则限制了动态库的范围，只能指定某一个动态库。</p>
<p>这里，我们先预设几个问题，后面会逐步进行解答：</p>
<ul>
<li>问题一：fishhook 是在什么时候完成函数 hook 的？</li>
<li>问题二：fishhook 为什么只支持 hook 动态库函数？</li>
</ul>
<p>为了能介绍清楚 fishhook
的实现原理，本文我将重点介绍程序的链接原理，包括：静态链接、动态链接。其中，涉及到的术语和概念主要是基于
ELF 可执行文件（或目标文件），在真正介绍 fishhook 的原理时，我会将
Mach-O 中的术语与 ELF 进行比较和映射，从而达到一个举一反三的效果。</p>
<h1 id="可执行文件格式">可执行文件格式</h1>
<p>在介绍链接原理之前，我们有必要先了解一下可执行文件（目标文件）的基本格式，不同的平台有着不同的格式，分别是：</p>
<ul>
<li>对于 Windows 平台，其采用的是 <strong>PE（Portable
Executable）</strong> 格式</li>
<li>对于 Linux 平台，其采用的是 <strong>ELF（Executable Linkable
Format）</strong> 格式</li>
<li>对于 iOS/macOS 平台，其采用的是 <strong>Mach-O（Mach
Object）</strong> 格式</li>
</ul>
<p>尽管不同平台的可执行文件格式不同，但是它们的组织结构和规则是基本类似的。如下图所示，不同格式的可执行文件基本都包含如下几个部分：</p>
<ul>
<li>文件头</li>
<li>segment 表</li>
<li>section 表</li>
<li>section 数据</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-01.png?x-oss-process=image/resize,w_800" /></p>
<p>文件头用于描述可执行文件的元信息，包括：文件类型、系统版本、segment
表的位置和大小、section 表的位置和大小等等。Section
表本质上是一个索引表，其存储了每一个 section 的元信息，比如对应 section
在文件中的位置和大小。至于 section，它是可执行文件的基本组成单元，常见
section
有：<code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.symtab</code>、<code>.strtab</code>
等。</p>
<p>那么 segment 表的作用又是什么呢？</p>
<h2 id="section-与-segment">section 与 segment</h2>
<p>事实上，两者的区别主要在于：section
用于描述可执行文件的静态存储布局，segment
用于描述可执行文件的装载内存布局。</p>
<p>我们知道可执行文件是以 section 为基本单元存储的，section
的类型非常多，如：<code>.data</code>、<code>.text</code>、<code>.rodata</code>
等。假如，我们的可执行文件中有两个 section，分别是 <code>.init</code> 和
<code>.text</code>，两者的大小分别是 3500B 和
4100B。假设系统的页面大小为 4KB，我们来分别看一下基于 section 装载和基于
segment 装载的内存占用情况。</p>
<p>下图右部所示为基于 section 装载的内存占用情况，其中
<code>.init</code> 单独占用一个页，且页没有全部使用；<code>.text</code>
会单独占用两个页，且第二页绝大多数内存空间没有使用，总共浪费内存 3 x 4KB
- 3500B - 4100B = 4688B。</p>
<p>下图左部所示为基于 segment 装载的内存占用情况，<code>.text</code>
占用了两个页，且与 <code>.init</code> 共享了一个页，总共浪费内存 2 x 4KB
- 3500B - 4100B = 592B。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-02.png?x-oss-process=image/resize,w_800" /></p>
<p>很显然，相比于基于 section 装载，基于 segment
装载对于内存占用的优化非常明显，内存碎片更少。在实际中，程序在装载时会将相同权限的
section 合并在一个 segment 中，比如：<code>.init</code> 和
<code>.text</code> 都合并成为可读可执行权限的
segment，作为代码段；可读可写的 section 合并在为一个
segment，作为数据段。</p>
<h1 id="程序的链接原理">程序的链接原理</h1>
<p><strong>链接（Linking）</strong>
的本质是把多个目标文件相互拼接到一起，使得函数调用、变量访问等指令能够找到正确的内存地址。然而，这一切都是围绕着
<strong>符号（Symbol）</strong> 完成的。</p>
<p>那么到底什么是符号？举个例子，目标文件 B 调用了目标文件 A 中的函数
<code>foo</code>。对此，我们认为目标文件 A 定义了函数
<code>foo</code>，目标文件 B 引用了函数
<code>foo</code>。在链接过程中，我们将函数和变量统称为
<strong>符号（Symbol）</strong>，函数名和和变量名统称为
<strong>符号名（Symbol Name）</strong>。因此，我们也可以认为目标文件 A
包含了函数 <code>foo</code> 的 <strong>符号定义（Symbol
Definition）</strong>，目标文件 B 包含了函数 <code>foo</code> 的
<strong>符号引用（Symbol Reference）</strong>。</p>
<p>这时候问题来了，链接过程是如何基于符号完成对二进制指令中内存地址的修正呢？对此，我们可以先来了解一下静态链接。</p>
<h2 id="静态链接">静态链接</h2>
<p>静态链接会在编译期将多个目标文件合并为一个可执行文件。因此，里面包含了所有的符号、重定位项、字符串等。</p>
<p>在编译过程中，编译器会为每一个变量或函数生成一个符号项，符号项包含的信息主要有：</p>
<ul>
<li><strong>符号名</strong>：即一个指向字符串表的索引，比如：字符串
<code>foo</code> 在字符串表中的偏移量。</li>
<li><strong>符号类型</strong>：类型有很多，比如：全局符号、局部符号、未定义符号等。</li>
<li><strong>符号值</strong>：<strong>符号定义</strong>
的内存地址，用于修正二进制指令中的内存地址。这个地址修正的过程被称为
<strong>重定位</strong>。</li>
</ul>
<p>此外，编译器还会为每个变量引用或函数引用生成一个重定位项。由于每一个重定位项记录了每一次对于符号的引用，因此，我们可以将其称为符号引用项。这样也就构成了符号定义和符号引用的一对多关系，毕竟，我们可以在不同的地方引用同一个变量或函数。</p>
<p>基于如下示意图，静态链接的整体工作原理大概可以分为以下三个步骤：</p>
<ul>
<li>根据重定位项中的符号索引，去符号表找到对应的符号项，并获取到对应符号的符号值，即内存地址。</li>
<li>根据重定位项中的重定位地址，找到代码段中对应的字节地址，将其修正为步骤一获取到的内存地址。</li>
<li>遍历重定位表中的所有重定位项，重复步骤一和步骤二。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/static-linking-01.png?x-oss-process=image/resize,w_800" /></p>
<p>由于静态链接时，程序所依赖的所有目标文件都已经合并在了一个可执行文件中，因此几乎不存在符号项中的符号值（内存地址）不确定的情况，对此，静态链接器只需要基于重定位表进行重定位即可。这其实就是大家常说『静态链接的重点是重定位』的原因。</p>
<h2 id="动态链接">动态链接</h2>
<p>动态链接的基本思想是
<strong>将程序按照模块拆分成各个独立的部分，在运行时将它们链接在一起形成一个完整的程序</strong>，而不是像静态链接一样在编译时把所有的模块都链接成一个独立的可执行文件。因此，动态链接可以有效解决静态链接存在的
<strong>内存空间浪费</strong> 和 <strong>程序更新困难</strong>
的问题。</p>
<p>那么对于动态链接，我们是否可以直接采用静态链接的做法呢？这种方案理论上可以，但却不是最优解，因为静态链接会修改代码段，我们很难让共享对象在被多次重定位之后也能继续安全稳定的运行。</p>
<p>举一个例子，如下所示，一个动态共享对象 <code>X</code>
内部会引用外部的一个变量 <code>a</code>。当程序 <code>A</code>
与动态共享对象 <code>X</code> 完成重定位后，<code>X</code>
代码段中的某个指令的访存地址可能是一个值；当程序 <code>B</code>
与动态共享对象 <code>X</code> 完成重定位后，<code>X</code>
代码段中同位置的访存地址可能会被修改成另一个值。这时候，必然会出现其他程序无法正常执行的情况。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-01.png?x-oss-process=image/resize,w_800" /></p>
<p>关于如何解决多进程之间的重定位冲突问题，我们可以引用下图所示的经典名言来描述动态链接的解决方案。当然，在具体的实现中，动态链接根据链接的时机，还可以分为
<strong>装载时链接（Load-Time Linking）</strong> 和
<strong>延迟链接（Lazy
Linking）</strong>。两者的实现思路只有略微的差异，下面我们将分别进行介绍。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="装载时链接">装载时链接</h3>
<p>下图所示为装载时链接的工作原理示意图。对于共享对象而言，其代码段会被多个进程所共享，因此不能直接在代码段中进行重定位，修改内存地址。考虑到多进程共享对象时，共享对象会为每个进程拷贝一份数据段，支持修改。因此，一种称为
<strong>地址无关代码（PIC，Position-Independent Code）</strong>
的技术诞生了，其基本思想是：在编译时配置 PIC
编译选项，将指令部分中需要被修改的部分分离出来，跟数据部分放在一起。这样指令部分可以保持不变，而数据部分可以在每个进程中有一个独立的副本。</p>
<p>对于 PIC
技术，代码运行性能会比静态链接要差一点。因为指令在访问外部变量或外部函数时，必须先通过指针去数据段找到对应的位置，再从中取出真实的内存地址，很显然多了一次间接操作，损耗了性能。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-02.png?x-oss-process=image/resize,w_800" /></p>
<p>在装载前，共享对象 <code>X</code> 的符号表中的外部符号
<code>bar</code> 的内存地址是未定义的。但是，程序 <code>A</code>
的符号表中的符号 <code>bar</code> 的内存地址是确定的（因为符号
<code>bar</code> 的符号定义位于程序 <code>A</code>
中）。因此，在装载时我们就可以决议出共享对象 <code>X</code> 的外部符号
<code>bar</code> 的地址。这个过程，我们称之为
<strong>装载时绑定（Load-Time Binding）</strong> 或
<strong>装载时符号绑定（Load-Time Symbol Binding）</strong>。</p>
<p>当外部符号 <code>bar</code>
的内存地址绑定完成后，我们就可以进行后续的重定位了。其步骤和静态链接的重定位类似，主要包括以下几步：</p>
<ul>
<li>根据动态重定位项中的符号索引，去动态符号表中找到对应的符号项，并获取对应符号的符号值，即装载时绑定的内存地址。</li>
<li>根据动态重定位项中的重定位地址，找到 <strong>数据段</strong>
中对应的字节地址，将其修正为步骤一获取到的内存地址。</li>
<li>遍历动态重定位表中的所有重定位项，重复步骤一和步骤二。</li>
</ul>
<p>在 PIC
技术中，编译器会在数据段中为每一个符号存储一个占位桩（stub），用于存储符号的真实内存地址。这些占位桩组成了一个表，我们称之为
<strong>全局偏移表（GOT，Global Offset Table）</strong>。</p>
<p>综上述可以看出，装载时链接包含了两个重要的步骤，分别是装载时绑定和重定位。虽然中间多了一步间接索引内存地址，损耗了一些性能，但是程序的灵活性和复用性提高了很多。</p>
<h3 id="延迟链接">延迟链接</h3>
<p>考虑到程序运行的局部性，实际上在进程生命周期中很多变量或函数并不会被调用。于是，诞生了延迟链接技术，可以支持进程只在第一次调用符号时才进行链接。</p>
<p>下图所示为延迟链接的工作原理示意图，本质上与装载时链接差不多，主要区别在于：装载时链接在数据段中使用了
GOT 存储符号地址，延迟链接则在数据段中使用了
<strong>过程链接表（PLT，Procedure Linkage Table）</strong>
存储符号地址。当 PLT 表项中符号的内存地址未决议时，PLT
表项中的占位桩（stub）存储的是一段代码的地址。当这段代码完成符号绑定和重定位后，会将符号的真实内存地址回填到占位桩中，覆盖默认的代码地址，从而实现仅在第一次调用符号时才进行链接。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-03.png?x-oss-process=image/resize,w_800" /></p>
<p>延迟链接的关键是如何实现在第一次调用符号时进行链接，这个过程包含了
<strong>延迟绑定（Lazy Binding）</strong> 和重定位。关于 PLT
的存储，很多目标文件会将其存储在命名为 <code>got.plt</code> 的 section
中，Mach-O 和 ELF 都是如此，这一点需要注意。</p>
<h1 id="fishhook-实现原理">Fishhook 实现原理</h1>
<h2 id="核心思想">核心思想</h2>
<p>上述介绍了程序的链接原理，尤其是在理解了动态链接之后，如果你细想思考一下，很容易就能想到
fishhook 的设计思想。</p>
<p>下图展示了 fishhook 的设计思想，非常简单巧妙，核心思想就是
<strong>将目标符号（函数）对应的 GOT 表项或 PLT
表项中存储的符号值（内存地址），替换成 hook
函数的内存地址</strong>。通过这种方式，无论是装载时链接还是延迟链接，我们都可以实现对动态共享库函数的
hook。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-04.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们来介绍一下 fishhook 实现细节中与 Mach-O 的相关概念。</p>
<h2 id="non-lazy-symbol-pointer-lazy-symbol-pointer">Non-lazy Symbol
Pointer &amp; Lazy Symbol Pointer</h2>
<p>如下所示为《Mach-O Programming Topics》中对两者的解释：</p>
<blockquote>
<p>Non-lazy symbol references are resolved (bound to their definitions)
by the dynamic linker when a module is loaded.A non-lazy symbol
reference is essentially a symbol pointer—a pointer-sized piece of data.
The compiler generates non-lazy symbol references for data symbols or
function addresses.</p>
<p>Lazy symbol references are resolved by the dynamic linker the first
time they are used (not at load time). Subsequent calls to the
referenced symbol jump directly to the symbol’s definition.Lazy symbol
references are made up of a symbol pointer and a symbol stub, a small
amount of code that directly dereferences and jumps through the symbol
pointer. The compiler generates lazy symbol references when it
encounters a call to a function defined in another file.</p>
</blockquote>
<p>Non-lazy Symbol Pointer 存储的是指向符号定义的指针，它与 GOT
中的表项定义非常类似。由 Non-lazy Symbol Pointer 组成的表，在 Mach-O
中我们称为 Non-lazy Symbol Pointer Table。</p>
<p>Lazy Symbol Pointer
包含一个指向符号定义的指针、一个占位桩以及一段代码（可用于延迟绑定和重定位），它与
PLT 中的表项定义非常类似。由 Lazy Symbol Pointer 组成的表，在 Mach-O
中我们称之为 Lazy Symbol Pointer Table。</p>
<h2 id="indirect-symbol-table">Indirect Symbol Table</h2>
<p>上述的 Non-lazy Symbol Pointer 和 Lazy Symbol Pointer
并没有包含符号名相关的信息，然而在实际的符号查找、绑定的过程是需要用到的。因此，对于
Non-lazy Symbol Pointer Table 和 Lazy Symbol Pointer Table
各自有一个同步的间接符号表，可以用于配合完成链接工作。Fishhook 也是借助
Indirect Symbol Table
间接获取符号名，然后与目标符号进行判等比较，从而最终完成 hook 工作。</p>
<p>Indirect Symbol Table 与 Symbol Pointer Table
的表项是一一对应的，比如：Indirect Symbol Table 中第 1601 项存储的就是
Symbol Pointer Table 中第 1601 项的符号索引，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="symbol-pointer-目标符号地址替换">Symbol Pointer
目标符号地址替换</h2>
<p>Fishhook 的核心是 <strong>完成 Symbol Pointer
的地址替换</strong>，无论是 Non-lazy Symbol Pointer 还是 Lazy Symbol
Pointer。其实现的关键步骤主要包括以下几步：</p>
<ul>
<li>查找数据段，即 <code>SEG_DATA</code> 或
<code>SEG_DATA_CONST</code></li>
<li>在数据段中查找 <code>LAZY_SYMNBOL_POINTERS</code> 和
<code>NON_LAZY_SYMBOL_POINTERS</code> 类型的 section</li>
<li>分别对 <code>LAZY_SYMBOL_POINTERS</code> 和
<code>NON_LAZY_SYMBOL_POINTERS</code> section 进行 Symbol Pointer
目标符号地址替换</li>
</ul>
<p>Symbol Pointer 目标符号地址替换的过程主要有以下几步：</p>
<ul>
<li>根据 <code>LAZY_SYMBOL_POINTERS</code> 或
<code>NON_LAZY_SYMBOL_POINTERS</code> section 获取其对应的 Indirect
Symbol Table</li>
<li>遍历 section，同步遍历 Indirect Symbol Table，获取对应的符号名</li>
<li>遍历过程中，判断符号名是否与目标符号名匹配。如果匹配，则将 Symbol
Pointer 的符号地址替换成 hook
函数的地址；否则，继续遍历，直到结束。</li>
</ul>
<p>这里涉及到了 fishhook 中的两个函数实现，分别是
<code>rebind_symbols_for_image</code> 函数和
<code>perform_rebinding_with_section</code>
函数，有兴趣的朋友可以自行阅读，本文就不粘贴代码了。</p>
<h1 id="总结">总结</h1>
<p>至此，我们从链接原理的角度介绍了 fishhook
的设计思路。通过这种自顶向下的方法来分析，我们很快就可以联想到如何去实现一个针对
ELF 格式的 hook 工具。</p>
<p>最后，我们再来回顾一下本文开头预留的几个问题。</p>
<p>问题一：fishhook 是在什么时候完成函数 hook 的？fishhook 会在调用
<code>rebind_symbols</code> 或 <code>rebind_symbols_image</code>
方法时去遍历镜像，从而完成对目标符号的地址替换。</p>
<p>问题二：fishhook 为什么只支持 hook 动态库函数？动态库的 PIC
技术支持在数据段进行重定位，因此允许我们进行目标地址修改。而 fishhook
的整个机制就是建立在动态链接原理的基础上，因此仅支持 hook
动态库函数。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《程序员的自我修养：装载、链接与库》</li>
<li><a href="https://studfile.net/preview/2082911/">OS X ABI Mach-O File
Format Reference</a></li>
<li>Mach-O Programming Topics</li>
<li><a href="https://github.com/facebook/fishhook">fishhook</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">BSD
Library Functions Manual——dyld(3)</a></li>
<li><a
href="https://man7.org/linux/man-pages/man3/dladdr.3.html">dladdr(3) —
Linux manual page</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>静态链接</tag>
        <tag>动态链接</tag>
        <tag>fishhook</tag>
        <tag>PIC</tag>
        <tag>GOT</tag>
        <tag>PLT</tag>
        <tag>延迟绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>系统理解 iOS 库与框架</title>
    <url>/2021/02/14/understand-ios-library-and-framework/</url>
    <content><![CDATA[<p>在软件开发中，静态库和动态库在各个方面为我们提供了便利。在计算机专业相关课程中，我们学习过静态库和动态库的一些理论，那么这些理论如何映射到
iOS 开发之中呢？iOS
中有很多相关概念和术语，对此，我并不是非常清晰。为了能够向编译优化的最终目标更近一步，我花了些时间进行了学习，并总结此文以供回顾复习。如果有什么写得不对的地方，欢迎指正。</p>
<span id="more"></span>
<h1 id="静态库-vs-动态库">静态库 VS 动态库</h1>
<p><strong>静态库和动态库的共同点在于：它们都是编译好的二进制文件；不同点在于：它们的用法不同</strong>。下面两张图可以看出两者在用法上的差异。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-static-library.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-dynamic-library.png?x-oss-process=image/resize,w_800" /></p>
<p>对于静态库，在应用程序进行编译链接时，会将静态库中的
<strong>被使用的部分</strong>
都添加到应用程序的可执行文件，这意味着应用程序的可执行文件大小会随着静态库数量的增加而增大。在运行时，静态库会随着应用程序的可执行文件一起加载到同一代码区。在
iOS 开发中，应用程序的可执行文件就是 ipa 解压后，包内容中与 app
同名的可执行文件。</p>
<p>对于动态库，事实上可以根据其加载时机分为两种：<strong>动态链接库</strong>、<strong>动态加载库</strong>。</p>
<ul>
<li><strong>动态链接库</strong>：当加载目标主程序的可执行文件时，动态库也会被加载到内存中，即
<strong>在程序启动时加载</strong>。在 Build Phase 中的 Linked Framework
and Library 阶段中声明的就是动态链接库，它们随着</li>
<li><strong>动态加载库</strong>：当用到相关功能时，使用
<code>dlopen</code> 或其他方式对相关动态库进行加载，即
<strong>在程序启动后加载</strong>。</li>
</ul>
<p>在 iOS 开发中，在项目设置【General】-&gt;【Frameworks, Libraries, and
Embedded Content】中，定义了应用程序所依赖的静态库和动态库。</p>
<ul>
<li>对于 <strong>系统动态库</strong>，可以将 <code>Embed</code>
属性设置成 <code>Do Not Embed</code>，因为 iOS
系统提供了相关的库，我们无需将它们再嵌入到应用程序的 ipa
包中，如：<code>Foundation.framework</code>、<code>UIKit.framework</code>。</li>
<li>对于 <strong>用户动态库</strong>，需要将 <code>Embed</code>
属性设置成
<code>Embed</code>，因为链接发生在运行时，链接器需要从应用程序的 ipa
包中加载完整的动态库。</li>
<li>对于 <strong>静态库</strong>，需要将 <code>Embed</code> 属性设置成
<code>Do Not Embed</code>，因为链接发生在编译时，编译完成后相关代码都已经包含在了应用程序的可执行文件中了，无需在应用程序的
bundle 中再保存一份。</li>
</ul>
<h1 id="library-vs-framework">Library VS Framework</h1>
<p>在 iOS
开发中，有两个令人难以分清的概念：<strong>框架</strong>（Framework）、<strong>库</strong>（Library）。下面，我们来捋一捋这两个概念。</p>
<p>库是所有 UNIX 系统共有的，可移植；框架是 OSX/iOS
特有的，不可移植。为了提供对 OSX/iOS
的高级特性的支持，同时又不愿意这些特性被移植到其他平台，苹果提出了
<strong>框架</strong>
的概念。不过，从本质而言，框架是基于库实现的，可以认为框架是对库进行了封装，是一种特殊形式的库。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">框架 = 库（静态库/动态库）+ .h（头文件） + bundle（资源包）</span><br></pre></td></tr></table></figure></p>
<p>从本质而言，<strong>库是一个二进制文件</strong>。因此，对于 OSX/iOS
和 UNIX 而言，其具体格式也有所不同。在 OSX/iOS 中，库采用 Mach-O
格式进行存储；在 UNIX 中，库采用 ELF
格式进行存储。除此之外，库在两种操作系统中的命名后缀也有所一定的差异。<strong>对于
OSX/iOS，静态库的后缀是 <code>.a</code>，动态库的后缀是
<code>.dylib</code>；在 UNIX 中，静态库的后缀是
<code>.a</code>，动态库的后缀是 <code>.so</code></strong>。</p>
<p>在 OSX/iOS 中，还有一种后缀为 <code>.tbd</code>
的动态库。<code>.tbd</code> 文件本质上是一个 YAML
文本文件，其描述了需要链接的动态库信息，其主要目的是
<strong>减小应用程序的下载大小</strong>。当应用程序引用了用户设备中
<code>/usr/lib/</code> 目录下的 <code>.dylib</code>
动态库时，会自动生成一个 <code>.tbd</code>
文件，其仅仅描述了项目中引用的动态库信息，因此可以减小应用程序的下载大小。具体细节见
<a
href="https://stackoverflow.com/questions/31450690/why-xcode-7-shows-tbd-instead-of-dylib">传送门</a>。</p>
<h1 id="umbrella-framework">Umbrella Framework</h1>
<p><strong>保护伞框架</strong>（Umbrella Framework）本质上可以认为是
<strong>对普通框架进行了封装，其包含了多个框架并隐藏它们彼此之间复杂的依赖关系</strong>。举个例子，Cocoa
框架就是一个保护伞框架，其包含了三个框架：AppKit、CoreData、Foundation。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  Cocoa.h</span></span><br><span class="line"><span class="comment">  Cocoa Framework</span></span><br><span class="line"><span class="comment">  Copyright (c) 2000-2004, Apple Computer, Inc.</span></span><br><span class="line"><span class="comment">  All rights reserved.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;AppKit/AppKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;CoreData/CoreData.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="framework-bundle-structure">Framework Bundle Structure</h1>
<p>上文提到框架本质上就是对库进行了封装，其包含一个或多个共享库以及相关的支持文件。下面，我们分别来看看普通框架和保护伞框架的目录结构。</p>
<p>首先，我们需要找到框架的保存位置。事实上，框架保存在文件系统中的多个位置：</p>
<ul>
<li><code>/System/Library/Frameworks</code>：保存苹果提供的框架，如：<code>Foundation.framework</code>，<code>AVFoundation.framework</code></li>
<li><code>/Library/Frameworks</code>：保存第三方框架。iOS
上该目录为空。如：<code>OpenVPN.framework</code>，<code>Carthage.framework</code>。</li>
<li><code>~/Library/Frameworks</code>：保存用户提供的框架（如果有的话）。</li>
</ul>
<p>此外，应用程序也可能会包含自己的框架，在其
<code>Contents/Frameworks</code>
目录下保存了应用程序专用的框架。其实，这里对应的就是应用程序 ipa 包中的
<code>Frameworks</code> 目录。</p>
<p>通过查看这些路径下的框架结构，我们可以发现大多是普通框架，其目录结构大致如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyFramework.framework/</span><br><span class="line">    Headers      -&gt; Versions/Current/Headers</span><br><span class="line">    MyFramework  -&gt; Versions/Current/MyFramework</span><br><span class="line">    Resources    -&gt; Versions/Current/Resources</span><br><span class="line">    Versions/</span><br><span class="line">        A/</span><br><span class="line">            MyFramework</span><br><span class="line">            Resources/</span><br><span class="line">                English.lproj/</span><br><span class="line">                    InfoPlist.strings</span><br><span class="line">                Info.plist</span><br><span class="line">        Current  -&gt; A</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>框架使用了与应用程序不同的 bundle 结构。框架基于早期的 bundle
格式，<strong>支持同时将多个版本的框架和头文件存放在一个 bundle
中</strong>，也就是上述这种结构。这种类型的 bundle 被称为
<strong>Versioned Bundle</strong>。</p>
<p>系统通过目录名称上的 <code>.framework</code>
扩展名来识别框架。框架目录下的各个目录和文件的作用如下：</p>
<ul>
<li><code>Versions</code>：存放了多个版本的框架，分别用
<code>A</code>、<code>B</code>、<code>C</code>...
这样的子目录进行保存。通过一个 <code>Current</code>
符号链接来选择使用哪个版本的框架。</li>
<li><code>Resources</code>：基于 <code>Versions/Current</code>
的符号链接，指向当前版本的框架的 <code>Resources</code> 目录。</li>
<li><code>MyFramework</code>：基于 <code>Versions/Current</code>
的符号链接，指向当前版本的框架的 <code>MyFramework</code> 目录。</li>
<li><code>Headers</code>：基于 <code>Version/Current</code>
的符号链接，指向当前版本的框架的 <code>Headers</code>
目录，存放了希望暴露给开发者的公开头文件。</li>
</ul>
<p>上面介绍了普通框架的结构，而保护伞框架的结构其实跟普通框架的结构基本一致，唯一区别在于：保护伞框架会多一个
<code>Frameworks</code> 目录，用于保存其封装的子框架。如下所示是
<code>Core Servives</code> 保护伞框架的结构： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CoreServices.framework/</span><br><span class="line">    CoreServices           -&gt; Versions/Current/CoreServices</span><br><span class="line">    CoreServices_debug     -&gt; Versions/Current/CoreServices_debug</span><br><span class="line">    CoreServices_profile   -&gt; Versions/Current/CoreServices_profile</span><br><span class="line">    Frameworks             -&gt; Versions/Current/Frameworks</span><br><span class="line">    Headers                -&gt; Versions/Current/Headers</span><br><span class="line">    Resources              -&gt; Versions/Current/Resources</span><br><span class="line">    Versions/</span><br><span class="line">        A/</span><br><span class="line">            CoreServices</span><br><span class="line">            CoreServices_debug</span><br><span class="line">            CoreServices_profile</span><br><span class="line">            Frameworks/</span><br><span class="line">                CarbonCore.framework</span><br><span class="line">                CFNetwork.framework</span><br><span class="line">                OSServices.framework</span><br><span class="line">                SearchKit.framework</span><br><span class="line">                WebServicesCore.framework</span><br><span class="line">            Headers/</span><br><span class="line">                Components.k.h</span><br><span class="line">                CoreServices-gcc3.p</span><br><span class="line">                CoreServices-gcc3.pp</span><br><span class="line">                CoreServices.h</span><br><span class="line">                CoreServices.p</span><br><span class="line">                CoreServices.pp</span><br><span class="line">                CoreServices.r</span><br><span class="line">            Resources/</span><br><span class="line">                Info-macos.plist</span><br><span class="line">                version.plist</span><br><span class="line">        Current             -&gt; A</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>除此之外，我们在构建自定义框架时，会发现框架结构下会有一个
<code>Modudles</code> 目录，该目录下默认有一个
<code>module.modulemap</code>
文件。事实上，<strong><code>module.modulemap</code>
是一个模块映射文件，能够使框架支持模块（以及子模块），在编译时也能够利用模块编译的优势进行加速</strong>。关于模块相关的内容，可见
<a
href="http://chuquan.me/2021/02/11/clang-module/#more">传送门</a>。</p>
<p><strong>注意：CocoaPods 会将每个 pod 转换为 Umbrella Framework 并添加
module map 使其支持模块</strong>。因此，每个 Pod 的
<code>Supporting File</code>
中会有两个对应的文件：<code>PodName-umbrella.h</code>（Umbrella
Header）、<code>PodName.modulemap</code>（Module Map）。</p>
<h1 id="cocoapods">CocoaPods</h1>
<p>在 Podfile
中有两个选项经常令人迷惑：<code>use_frameworks!</code>、<code>use_modular_headers!</code>。那么这两者有什么区别呢？</p>
<p>我们知道在 Xcode 9 之前，不支持 Swift 静态库编译，因此 Swift pod
不得不使用动态库编译，即使用
<code>use_frameworks!</code>。但是，引用了大量动态库会导致应用程序启动时间变长。</p>
<p>好在 Xcode 9 之后开始支持 Swift 静态库编译。为了充分利用该特性，从
CocoaPods 1.5.0 开始，对于 Swift pod，开发者不用必须在 Podfile 中指定
<code>user_frameworks!</code>
以强制使用动态库编译。不过，要注意的是，如果一个 Swift pod 依赖了一个 OC
pod，那么我们要为对应的 OC pod 开启
<code>modular headers</code>（<code>use_modular_headers!</code> 就会开启
<code>modular headers</code>）。那么，Swift 引用 OC 时为什么要开启
<code>modular headers</code>？<strong>事实上，开启
<code>modular headers</code> 的本质就是将 pod 转换为
Modular（也就是支持模块），而 Modular 是可以直接在 Swift 中 import
的，不需要再经过 bridging-header 进行桥接，从而简化了 Swift 引用 OC
的方式</strong>。</p>
<blockquote>
<p>只有支持了模块的框架，才能支持通过模块化头文件（Modular
Header）的方式进行导入。Clang
支持模块编译，能够加速编译，减少出错。我们可以通过添加 modulemap
文件使框架支持模块。</p>
</blockquote>
<p>简化 Swift 引用 OC 的方式是使用 <code>use_modular_headers!</code>
的一个原因，除此之外，<code>use_modular_headers!</code>
还能够解决一个历史原因。</p>
<p>在 CocoaPods
诞生之初，其致力于封装尽可能多的第三方库。为此，CocoaPods
使用了较为宽松的头文件搜索路径（Header Search Paths），允许 pod
之间的相互引用，无需考虑命名空间，不必采用
<code>#import &lt;NameSpace/fileName.h&gt;</code>
的模块导入方式，允许采用 <code>#import "fileName.h"</code>
的导入方式。</p>
<p>但是，如果给 pod 添加 module map 使其支持模块化，会导致
<code>#import "fileName.h"</code> 无法正常导入。使用
<code>use_modular_headers!</code> 可以强制使用更优的模块导入方式。</p>
<p>在 CocoaPods 1.5.0 中，为了使用模块导入方式。对于 pod 开发者，可以在
<code>pod_target_xxconfig</code> 内设置
<code>'DEFINES_MODULE' =&gt; 'YES'</code>。对于 pod 使用者，可以在
<code>Podfile</code> 中添加 <code>use_modular_headers!</code>
指定采用模块导入的方式，也可以通过
<code>:modular_headers =&gt; true</code> 配置只让特定的 pod
采用模块导入的方式。</p>
<h1 id="总结">总结</h1>
<p>本文首先介绍了静态库和动态库的区别，然后介绍了 iOS
中库与框架的概念及其区别，最后介绍了 CocoaPods 中
<code>use_frameworks!</code> 和 <code>use_modular_headers!</code>
的区别。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://juejin.cn/post/6844903992082825224#h">iOS静态库与动态库的区别与打包</a></li>
<li><a
href="https://freelf.me/%E5%88%9D%E8%AF%86iOS%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93">初识iOS中的动态库和静态库</a></li>
<li><a
href="https://www.jianshu.com/p/1de663f64c05">深入剖析iOS动态链接库</a></li>
<li><a
href="https://github.com/Damonvvong/DevNotes/blob/master/Notes/framework.md">iOS
开发中的『库』(一)</a></li>
<li><a
href="https://github.com/Damonvvong/DevNotes/blob/master/Notes/framework2.md">iOS
开发中的『库』(二)</a></li>
<li><a
href="https://juejin.cn/post/6844904031937101838">细说iOS静态库和动态库</a></li>
<li><a
href="https://www.raywenderlich.com/17753301-creating-a-framework-for-iosx">Creating
a Framework for iOS</a></li>
<li><a
href="https://stackoverflow.com/questions/32375687/what-is-the-difference-between-embedded-binaries-and-linked-frameworks">What
is the difference between Embedded Binaries and Linked
Frameworks</a></li>
<li><a
href="https://www.jianshu.com/p/2e7bf6e7cf45">通过dlopen使用动态库</a></li>
<li><a
href="https://developer.apple.com/library/archive/technotes/tn2435/_index.html">Embedding
Frameworks In An App</a></li>
<li><a
href="https://www.jianshu.com/p/be108227cbd3">iOS的静态库和动态库</a></li>
<li><a
href="https://stackoverflow.com/questions/31450690/why-xcode-7-shows-tbd-instead-of-dylib">Why
Xcode 7 shows <em>.tbd instead of </em>.dylib?</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">Overview
of Dynamic Libraries</a></li>
<li><a
href="https://stackoverflow.com/questions/57687170/do-not-embed-embed-sign-embed-without-signing-what-are-they-what-th">“Do
Not Embed”, “Embed &amp; Sign”, “Embed Without Signing”. What are they?.
What they do?</a></li>
<li>《深入解析 MacOSX 与 iOS 操作系统》</li>
<li><a href="https://blog.cocoapods.org/CocoaPods-1.5.0/">CocoaPods
1.5.0 — Swift Static Libraries</a></li>
<li><a
href="http://www.uml.org.cn/c%2B%2B/201212115.asp">为什么应该用模块取代C/C++中的头文件？</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1">Introduction
to Framework Programming Guide</a></li>
<li><a href="https://cloud.tencent.com/developer/news/252403">应用 Swift
静态库的各种坑</a></li>
<li><a
href="http://blog.startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/">iOS
- Umbrella Header在framework中的应用</a></li>
<li><a
href="https://andelf.github.io/blog/2014/06/19/modules-for-swift/">Module
System of Swift</a></li>
<li><a
href="https://www.jianshu.com/p/3d0ae289dee0">cocoapods的静态库和动态库</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>framework</tag>
        <tag>umbrella framework</tag>
        <tag>modulemap</tag>
        <tag>module header</tag>
      </tags>
  </entry>
  <entry>
    <title>Run Loop 原理详解</title>
    <url>/2018/10/06/understand-ios-runloop/</url>
    <content><![CDATA[<h1 id="event-loop">Event Loop</h1>
<p>通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或框架中，需要实现一种这样机制：线程能够随时处理事件或消息，并且不会在执行完成后退出。这种机制称为
Event Loop，其一般逻辑吐下所示：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function main</span><br><span class="line">    initialize()</span><br><span class="line">    while message != quit</span><br><span class="line">        message := get_next_message()</span><br><span class="line">        process_message(message)</span><br><span class="line">    end while</span><br><span class="line">end function</span><br></pre></td></tr></table></figure>
<p>Event Loop 在很多系统或框架中都有对应的实现，如 Node.js
的事件处理，Windows 程序的消息循环，OSX/iOS 中的
RunLoop。实现这种机制的关键在于：如何管理事件/消息，如何让线程在没有处理任务时休眠以避免资源占用，如何在事件/消息到来时唤醒。</p>
<h1 id="run-loop">Run Loop</h1>
<p>Run Loop 是 OSX/iOS 平台下对 Event Loop
机制的一种实现。当没有事件/消息时，Run Loop
进入休眠状态。当有事件/消息时，Run Loop 调用对应的 Handler
进行处理。如下图所示为 Run Loop 的工作模式示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop.png" /></p>
<p>由上图可知，Run Loop 从 <strong>Input sources</strong> 和
<strong>Timer sources</strong> 接收事件，然后在线程中处理。</p>
<p>Run Loop
本质上就是一个对象，其管理需要处理的事件/消息，并提供一个入口函数来执行上面
Event Loop
的逻辑。线程执行该函数后，会一直处于其内部的“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环中，直到循环结束（比如传入
<code>quit</code> 的消息），函数返回。</p>
<p>OSX/iOS 中提供了两种 Run Loop 的实现：</p>
<ul>
<li><code>CFRunLoopRef</code>：CoreFoundation 框架对于 Run Loop
的实现，其提供纯 C 函数的 API（线程安全）。</li>
<li><code>NSRunLoop</code>：基于 <code>CFRunLoopRef</code>
的封装，其提供面向对象的 API（非线程安全）。</li>
</ul>
<h1 id="run-loop-与线程">Run Loop 与线程</h1>
<p>Run Loop 和线程是一一对应的。每个线程（包括主线程）都有一个对应的 Run
Loop 对象。Run Loop
对象的创建发生在第一次获取时（如果不主动获取，它一直都不会被创建）；Run
Loop 对象的销毁发生在线程结束时。</p>
<p>用户无法创建 Run Loop 对象，但可以获取系统提供的 Run Loop
对象。注意：<strong>只能在一个线程的内部获取其 Run Loop
对象，主线程不受限制</strong>。</p>
<p>关于 Run Loop 的启动，主线程的 Run Loop
在应用启动时自动启动，其他线程的 Run Loop
默认不会自动启动，需手动启动。</p>
<h1 id="run-loop-source">Run Loop Source</h1>
<p>从上面 Run Loop 工作模式示意图中可知，Run Loop
有两种接收事件的渠道：Input Source、Timer Source。</p>
<h2 id="input-source">Input Source</h2>
<p>Input Source 可分为两类：</p>
<ul>
<li><code>Custom Input Sources</code>（<code>Source0</code>）：用户自定义的事件，不会主动触发事件，也不会主动唤醒
Run Loop
的线程。如：<code>UIEvent</code>、<code>CFSocket</code>、普通函数调用、系统调用等。</li>
<li><code>Port-Based Sources</code>（<code>Source1</code>）：系统底层的
Port 事件（Mac Port），如
<code>CFMachPort</code>，<code>CFMessagePort</code>。一般用于通过内核和其他线程相互发送消息，应用层很少使用。这种
Source 可以主动唤醒 Run Loop 的线程。</li>
</ul>
<h2 id="timer-source">Timer Source</h2>
<p>Timer Source 即定时器事件。本质上仍然属于
<code>Port-Based Source</code>，所有的 Timer 都共用一个端口“Mode Timer
Port”。</p>
<h1 id="run-loop-observer">Run Loop Observer</h1>
<p>Run Loop 通过监控 Source 来决定是否执行处理程序。而 Runloop Observer
则监控 Runloop 本身的状态。 Runloop Observer 可监控的 runloop
事件如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0),   // 即将进入 Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1),   // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6),   // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7),   // 即将退出 Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="run-loop-mode">Run Loop Mode</h1>
<p>Run Loop Mode 即 Run Loop 工作模式。苹果文档中定义了 5 种 Mode：</p>
<ul>
<li><code>NSDefaultRunLoopMode</code></li>
<li><code>NSConnectionReplyMode</code></li>
<li><code>NSModalPanelRunLoopMode</code></li>
<li><code>NSEventTrackingRunLoopMode</code></li>
<li><code>NSRunLoopCommonModes</code></li>
</ul>
<p>iOS 中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和
<code>NSRunLoopCommonModes</code>。 <code>NSRunLoopCommonModes</code>
实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和
<code>NSEventTrackingRunLoopMode</code>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-mode.png" /></p>
<p>一个 Run Loop 可以包含若干个 Mode，每个 Mode 又包含若干个
Source/Timer/Observer。Run Loop 在某个时刻只能工作在一个 Mode 下，处理该
Mode 中的 Source/Timer/Observer。如果需要切换 Mode，只能退出 Run
Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的
Source/Timer/Observer，使其互不影响。</p>
<p>如下所示为 Run Loop Mode 和 Run Loop 的部分源码定义。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">  </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Source/Timer/Observer 被统称为 <code>Mode Item</code>，一个 Item
可以被同时加入多个 Mode。但一个 Item 被重复加入同一个 Mode
时是不会有效果的。如果一个 Mode 中一个 Item 都没有，则 Run Loop
会直接退出，不进入“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环。</p>
<h2 id="common-mode">Common Mode</h2>
<p>一个 Mode 可以将自己标记为 <code>Common</code>（通过将其 Mode Name
添加到 Run Loop 的 <code>_commonModes</code> 中）。<strong>每当 Run Loop
内容发生变化，Run Loop 都会自动将 <code>_commonModeItems</code> 里的
Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode
里</strong>。</p>
<h3 id="举例">举例</h3>
<p>主线程的 Run Loop 里有两个预置的
Mode：<code>kCFRunLoopDefaultMode</code> 和
<code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为
<code>Common</code>。<code>kCFRunLoopDefaultMode</code> 是 App
平时所处的状态，<code>UITrackingRunLoopMode</code> 是追踪 ScrollView
滑动时的状态。当创建一个 Timer 并加到 <code>kCFRunLoopDefaultMode</code>
时，Timer 会得到重复回调，但此时滑动 TableView 时，Run Loop 会将 Mode
切换为
<code>UITrackingRunLoopMode</code>。这是系统为了保持滑动流畅而做出的
Mode 切换。但这会导致 Timer 不被回调。</p>
<p>为了让 Timer 能在这两种 Mode 下都能得到回调，有 3 种解决方案：</p>
<ol type="1">
<li>将 Timer 分别加入两种 Mode</li>
<li>将 Timer 加入 Run Loop 的 <code>_commonModeItems</code>
中。因为，Run Loop 发生变化时，Run Loop 都会自动将
<code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有
<code>Common</code> 标记的所有 Mode 里。</li>
<li>在另一个线程执行和处理 Timer 事件，然后在主线程更新 UI。</li>
</ol>
<h1 id="run-loop-工作流程">Run Loop 工作流程</h1>
<p>下图所示为 Run Loop 工作流程示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-internal-logic.png" /></p>
<p>如下所示为 Run Loop 工作流程的核心代码整理。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">     </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">     </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">  </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// ? 一个基于 port 的Source 的事件。</span><br><span class="line">            /// ? 一个 Timer 到时间了</span><br><span class="line">            /// ? RunLoop 自身的超时时间到了</span><br><span class="line">            /// ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">             </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其内部是一个 do-while 循环。当调用 <code>CFRunLoopRun()</code>
时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基于-run-loop-的系统功能">基于 Run Loop 的系统功能</h1>
<p>如下所示为 App 启动后 Run Loop 的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 <code>modes</code> 成员的状态可知，系统默认注册了 5 个
Mode：</p>
<ul>
<li><code>kCFRunLoopDefaultMode</code>：App 的默认
Mode，通常主线程是在这个 Mode 下运行的。</li>
<li><code>UITrackingRunLoopMode</code>：界面跟踪 Mode，用于 ScrollView
追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li><code>UIInitializationRunLoopMode</code>：在刚启动 App
时进入的第一个 Mode，启动完成后就不再使用。</li>
<li><code>GSEventReceiveRunLoopMode</code>：接收系统事件的内部
Mode，通常用不到。</li>
<li><code>kCFRunLoopCommonModes</code>：占位的 Mode，无实际作用。</li>
</ul>
<h2 id="autoreleasepool">AutoReleasePool</h2>
<p>App 启动后，系统在主线程 Run Loop 中注册了两个 Observer，其回调都是
<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 Observer 监听了一个事件：</p>
<ul>
<li><strong>kCFRunLoopEntry</strong>（即将进入 Loop）：调用
<code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是
-2147483647，优先级最高，保证在其他所有回调之前创建。</li>
</ul>
<p>第二个 Observer 监听了两个事件：</p>
<ul>
<li><strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）：调用
<code>_objc_autoreleasePoolPop()</code> 和
<code>_objc_autoreleasePoolPush()</code> 释放旧池并创建新池。</li>
<li><strong>kCFRunLoopExit</strong>（即将退出 Loop）：调用
<code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。其 order 是
2147483647，优先级最低，保证在其他所有回调之后释放。</li>
</ul>
<p>事件回调、Timer 回调一般在主线程执行。这些回调会被 Run Loop 创建的
AutoreleasePool
所环绕，所以不会出现内存泄漏，开发者也不必显式创建自动释放池。</p>
<h2 id="事件响应">事件响应</h2>
<p>苹果注册了一个 Source1（Mach Port）用来接收系统事件，其回调函数为
<code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework
生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard
只接收按键（锁屏/静音等）、触摸、加速、接近传感器等几种 Event，随后用
mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1
就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code>
进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent
处理并包装成 UIEvent 进行处理或分发，其中包括：识别
UIGesture、处理屏幕旋转、发送给 UIWindow
等。在此回调中完成的事件包括：UIButton
点击、touchesBegin/Move/End/Cancel 事件等。</p>
<h2 id="手势识别">手势识别</h2>
<p>当上面的 <code>_UIApplicationHandleEventQueue()</code>
识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End
系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监听
<strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）事件，这个
Observer 的回调函数是
<code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的
GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer
的变化（创建/销毁/状态改变）时，这个回调都会进行相应处理。</p>
<h2 id="界面更新">界面更新</h2>
<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer
的层次时，或者手动调用了 UIView/CALayer 的
<code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer
就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听
<strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠） 和
<strong>kCFRunLoopExit</strong>（即将退出
Loop），回调执行的函数会遍历所有待处理的 UIView/CAlayer
以执行实际的绘制和调整，并更新 UI 界面。</p>
<h2 id="定时器">定时器</h2>
<p>NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 Run Loop
后，Run Loop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20
这几个时间点。Run Loop为了节省资源，并不会在非常准确的时间点回调
Timer。Timer 有个属性叫做
Tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果
10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink
是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer
并不一样，其内部实际是操作了一个
Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和
NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView
时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink
就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p>
<h2 id="performselecter">PerformSelecter</h2>
<p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code>
后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop
中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个
Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop
该方法也会失效。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Run
Loops</a></li>
<li><a
href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></li>
<li><a
href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html">RunLoop</a></li>
<li><a href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/"><span
class="citation"
data-cites="autoreleasepool-内存的分配与释放">@autoreleasepool-内存的分配与释放</span></a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Run Loop</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 构建幕后原理</title>
    <url>/2021/02/16/understand-ios-xcode-build-process/</url>
    <content><![CDATA[<p>Xcode 10 中的 new build system 是使用 Swift
从零开始编写实现的，其在性能和可靠性方面有着显著的提升。</p>
<p>本文，我们将来探索一下 Xcode 构建的幕后原理，这一切都是从在我们点击了
Xcode 的 “build” 按钮（或按下了快捷键
<code>Command + B</code>）之后开始的。</p>
<span id="more"></span>
<p>下面，我们将以一个名为 PetWall 的 iOS app
项目作为例子来进行介绍。</p>
<h1 id="概述">概述</h1>
<p>事实上，Xcode 的构建过程的本质就是
<strong>执行一系列构建任务</strong>，比如：编译链接源代码、拷贝资源（图片、storyboard
等）、代码签名、代码静态检查等。其中，绝大多数任务的本质就是
<strong>执行命令行工具</strong>，比如：<code>clang</code>、<code>ld</code>、<code>actool</code>、<code>codesign</code>
等，如下所示。基于 Xcode 的项目配置信息，这些工具会
<strong>选择特定的参数、按照特定的顺序</strong>
来执行。而构建系统（build system）的职责就是
<strong>创建任务并调度执行</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">swiftc -module-name PetWall -target arm64-apple-ios12.0 -swift-version 4.2 ...</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang -x objective-c -<span class="built_in">arch</span> arm64 ... PetViewController.m -o PetViewController.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ld -o PetWall -framework PetKit PetViewController.o ...</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">actool --app-icon AppIcon ... Assets.xcassets</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure>
<p>下面我们从构建系统如何确定任务的执行顺序说起。</p>
<h1 id="构建系统">构建系统</h1>
<h2 id="任务依赖">任务依赖</h2>
<p>事实上，<strong>构建任务的顺序是根据任务之间的依赖关系而确定的</strong>。根据任务的输入和输出就可以分析任务之间的依赖关系，举个例子，对于编译任务而言，以源代码文件作为输入（如：<code>PetController.m</code>），以目标文件作为输出（如：<code>PetController.o</code>）；对于链接任务而言，以多个编译任务所输出的目标文件作为输入（如：<code>PetController.o</code>、<code>PetView.o</code>、<code>PeteViewController.o</code>），以可执行文件或库作为输出（如：<code>PetWall</code>）。</p>
<p>由此，我们可以得出如下所示的任务依赖关系。很显然，编译任务可以并行执行，而链接任务依赖了编译任务的输出，所以需要在编译任务之后执行。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-task-dependency-order.png?x-oss-process=image/resize,w_800" /></p>
<p>在实际情况中，当我们点击 “Build” 按钮后，Xcode 构建系统会解析 Xcode
project 文件，分析项目中的所有文件、目标和依赖关系，结合 build
setting，最终得到一个树形结构的 <strong>定向图</strong>（directed
graph），如下图所示，其详细描述了项目构建中所有的依赖关系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-directed-graph.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，<strong>低级执行引擎</strong>（low-level execution
engin）会根据定向图来执行任务。有些任务可以并行执行，有些任务则有先后顺序，如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-execute-build-graph.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>注意：Xcode new build system 使用的低级执行引擎是
<code>llbuild</code></strong>，这是一个开源项目，详见 <a
href="https://github.com/apple/swift-llbuild/">传送门</a>。</p>
<h2 id="依赖记录">依赖记录</h2>
<p>对于开发者而言，很难发现太多的依赖信息，但是对于 Xcode
而言，它能够在任务执行过程中找到更多的信息。比如，clang 在编译 OC
文件时会生成一个以 <code>.d</code> 后缀的文件，该文件记录了对应 OC
文件包含的所有头文件信息。下一次构建时，构建系统会根据 <code>.d</code>
文件检查其所依赖的头文件是否存在修改，如果存在修改，那么将重新编译此 OC
文件。这是构建系统通过利用过往的依赖记录进行优化的一种手段。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-discovered-dependencies.png?x-oss-process=image/resize,w_800" /></p>
<p>上图示例中，当 clang 编译 <code>PetController.m</code> 时会生成
<code>PetController.o</code> 和
<code>PetController.d</code>。<code>PetController.d</code> 记录了
<code>PetController.m</code> 所包含的头文件。当下一次编译时，如果检测到
<code>PetController.d</code>
中记录的头文件发生了变化，构建系统会重新编译
<code>PetController.m</code>。</p>
<h2 id="增量构建">增量构建</h2>
<p>在 Xcode
构建系统中，增量构建是一个非常重要的功能，能够极大地提升构建效率。增量构建是基于精准的依赖信息来检测用户的修改，具体细节如下：</p>
<ul>
<li>在构建时为每个任务生成一个签名。该签名是基于任务输入的统计信息（如修改时间、文件路径）的哈希值。</li>
<li>在下一次构建时，构建系统校验对每个任务的前后两次签名，从而决定是否需要重新执行。</li>
</ul>
<p>举个例子，如果用户只修改了
<code>PetViewController.m</code>，那么构建系统只会重新执行 3
个任务，从而实现了增量构建。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-incremental-build.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="clang">Clang</h1>
<p>Clang 是 Apple 的 C 语言家族的官方编译器，支持
C、C++、Objective-C、Objective-C++。</p>
<p>在 Objective-C 中，头文件 <code>.h</code> 是一个承诺，表示该实现
<code>.m</code> 存在于其他位置。如果仅修改 <code>.h</code>
文件，在里面添加新的函数 A，而未在 <code>.m</code>
文件中实现该函数，那么就没有遵循承诺。 随后，我们在 B 类中使用函数
A。这在编译期间不会报错，因为编译器相信我们约定的承诺，但是在链接过程中，就会出现
<code>symbol undefined error</code>。</p>
<p>这里可能会有一个问题：Clang
是如何查找头文件的？事实上，用户头文件和系统头文件的查找方式所有不同，下文我们将通过
PetWall 的例子分别进行介绍。PetWall 是一个混编项目，其组成大致如下：</p>
<ul>
<li>主体部分使用 Swift 编写</li>
<li>PetKit 库使用 Objective-C 编写</li>
<li>PetSupport 库使用 C++ 编写</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-petwall-example.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="clang-如何查找用户头文件">Clang 如何查找用户头文件</h2>
<p>对于用户头文件，Xcode 构建系统是从 header map
文件开始查找头文件。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-user-header-search.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="header-map">Header Map</h3>
<p>那么 header map 到底是什么呢？Header map
本质上记录了头文件的位置。如下例子中，<code>PetKit-project-headers.hmap</code>
是面向 Project 的 header
map，<code>PetKit-own-target-headers.hmap</code> 是面向 Target 的 header
map。</p>
<blockquote>
<p>Project 和 Target 关系：Project 是一系列相关 Target
的集合，包含了所有 Target 的文件，每个 Target 的文件都是 Project
文件的子集。</p>
</blockquote>
<p><code>PetKit-project-headers.hmap</code> 的前两项
<code>PetKit.h</code> 和 <code>Cat.h</code>，header map
仅仅是给它们加上了框架的名称，分别得到 <code>PetKit/PetKit.h</code> 和
<code>PetKit/Cat.h</code>，这两个是共有头文件。这样的映射能够使现有项目正常运行，但是对于
Clang Module 可能会有遇到一些问题，下文将介绍其中的原因。</p>
<p><code>PetKit-project-headers.hmap</code> 的第三项
<code>CatLogic_Private.h</code> 是一个项目头文件。header map
将它指向原始位置。</p>
<p>对于
<code>PetKit-own-target-headers.hmap</code>，所有的头文件都指向对应的原始位置。</p>
<p><strong>我的理解是，如果通过 <code>import "PetKit.h"</code>
的方式导入，Clang 通过 <code>PetKit-project-headers.hmap</code> 转换成
<code>import "PetKit/PetKit.h"</code>，然后 Clang 再通过
<code>PetKit-own-target-headers.hmap</code> 转换实际的位置，即
<code>/x/src/PetKit/PetKit/Cat/Cat.h</code></strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-petkit-project-headermap.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="clang-如何查找系统头文件">Clang 如何查找系统头文件</h2>
<p>Header map 只是用于 Clang 查找用户头文件。对于系统头文件，它们并没有
header map，因此 Clang
直接从下面这两个目录中开始查找。事实上，在查找用户头文件时，如果通过
header map
没有找到头文件，也会采取与查找系统头文件相同的方式继续查找。这两个目录如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-system-header-search.png?x-oss-process=image/resize,w_800" /></p>
<p>以 <code>import &lt;Foundation/Foundation.h&gt;</code> 为例，Clang
会在 <code>(SDKROOT)/usr/include</code> 之后拼接上
<code>Foundation/Foundation.h</code>，在如下的路径中进行查找：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SDKROOT)/usr/include/Foundation/Foundation.h</span></span><br></pre></td></tr></table></figure>
<p>如果在 <code>$(SDKROOT)/usr/include</code>
中没找到对应的头文件，则继续在框架目录下进行查找：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(SDKROOT)/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h</span></span><br></pre></td></tr></table></figure>
<p>在本例子中，每一次导入 <code>Foundation.h</code>，Clang 都要处理超过
800 个头文件。每一次编译，都要解析差不多 9 MB
的源代码文件。对于如此大量的重复工作，Clang 是如何解决这个问题的呢？</p>
<h2 id="clang-module">Clang Module</h2>
<p>为了加速编译，通过使用 Module，Clang
可以只解析一次头文件，并且将相关信息存储在磁盘中，作为缓存用于下一次构建时进行重用。</p>
<p>为了能够实现这个目标，Clang module 必须要有以下这些特性：</p>
<ul>
<li><strong>上下文无关</strong>（context-free）：比如在某些情况下，我们可能会在导入头文件之前，通过宏定义修改模块内部状态，这种情况会导致模块无法重用。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-contexxt-free.png?x-oss-process=image/resize,w_800" /></p>
<ul>
<li><strong>自包含</strong>（self-contained）：即管理自身所有依赖，不用在导入该模块时还必须导入其他模块。</li>
</ul>
<h3 id="module-map">Module Map</h3>
<p>那么，Clang 如何知道是否应该构建一个模块呢？</p>
<p><strong>以 <code>#import &lt;Foundation/NSString.h&gt;</code>
为例，Clang 会先去 <code>Foundation.framework</code> 中查找对应的头文件
<code>NSString.h</code>。然后 Clang 会再去
<code>Foundation.framework</code> 中查找
<code>Modules/module.modulemap</code>，通过分析
<code>module.modulemap</code> 判断 <code>NSString.h</code>
是否是模块的一部分。如果找到了，Clang
会将文本导入转换成模块导入，然后才开始构建模块。</strong></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-foundation-framework.png?x-oss-process=image/resize,w_800" /></p>
<p>那么什么是 Module Map 呢？</p>
<p>Module map 描述了如何将头文件映射成模块。如下所示，是
<code>Foundation.framework</code> 的 module map 文件。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-modulemap.png?x-oss-process=image/resize,w_800" /></p>
<p>Module map 文件中定义了模块的名称
<code>Foundation</code>，并指定了模块的保护伞头文件（umbrella
header）<code>Foundation.h</code>。如果想要查找
<code>NSString.h</code>，需要到 <code>Foundation.h</code> 中去查找。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-foundation-header.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="build-module">Build Module</h3>
<p>当 Clang 确定将文本导入转换成模块导入时，那么就需要构建模块了。</p>
<p>在构建 Foundation
模块时，我们可能也需要构建其所依赖的模块，如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-build-module.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="module-cache">Module Cache</h3>
<p>模块构建完之后，会被缓存到磁盘中的 Module Cache，位于
<code>~/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/</code>
目录下。当构建模块时，Clang
会根据命令行参数得到一个哈希值，并以此作为模块的存储索引。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-module-cache.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="用户模块">用户模块</h3>
<p>上面介绍了如何查找并构建系统模块，那么对于用户模块该怎么做呢？</p>
<p>以 PetWall 为例，我们通过 <code>#import &lt;PetKit/Cat.h&gt;</code>
导入并启用模块。此时，我们会先通过 header map 进行查找，找到
<code>cat.h</code> 后，却没有找到 <code>Modules/</code>
目录，很显然也没有 <code>module.modulemap</code>。因此，Clang
也就不会构建模块。此时该怎么办呢？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-user-clang-module.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，对于这种情况，可以采用 <strong>Clang
虚拟文件系统</strong>（Clang's Virtual File System） 的技术来解决。Clang
会创建抽象的 <code>PetKit.framework</code>（其中包含
<code>Modules/module.modulemap</code>），从而使 Clang 能够构建模块。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-clang-vfs.png?x-oss-process=image/resize,w_800" /></p>
<p>注意，如果在开启模块的情况下，在导入时却不指定框架的名称，可能会报错。如下所示为例，有两个导入声明，对于第二个导入声明，我们知道
<code>Cat.h</code> 是 PetKit 模块的一部分，但是 Clang
并不知道，因为我们没有指定框架的名称。在这种情况下，可能会出现重复定义的报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;PetKit/PetKit.h&gt;</span><br><span class="line">#import &quot;Cat.h&quot;</span><br></pre></td></tr></table></figure>
<p>为了避免这种报错，我们应该在导入时指定框架的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;PetKit/PetKit.h&gt;</span><br><span class="line">#import &lt;PetKit/Cat.h&gt;</span><br></pre></td></tr></table></figure>
<h1 id="swift">Swift</h1>
<p>接下来，我们再来看一下构建系统是如何查找 Swift 声明的呢？</p>
<p>我们知道，Clang 会分开编译配一个 OC
文件。如果我们要引用一个文件中的某个类，那么必须要导入声明了这个类的头文件。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-declaration-oc.png?x-oss-process=image/resize,w_800" /></p>
<p>不过，在 Swift
中我们并不需要导入头文件。这样能够使代码更加简洁，但也意味着编译器要做更多的工作。</p>
<p>以 PetWall 为例，<code>PetViewController</code> 使用 Swift
编写，<code>AppDelegate</code> 使用 OC 编写，单元测试使用 Swift
编写。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-swift-example.png?x-oss-process=image/resize,w_800" /></p>
<p>为了编译 <code>PetViewController</code>，编译器做两步操作：</p>
<ul>
<li><strong>查找声明</strong></li>
<li><strong>生成接口</strong></li>
</ul>
<h2 id="查找声明">查找声明</h2>
<p>很显然，查找的声明有两种来源：</p>
<ul>
<li>Swift Target</li>
<li>Objective-C</li>
</ul>
<h3 id="查找-swift-target-中的声明">查找 Swift Target 中的声明</h3>
<p>关于查找 Swift Target 中的声明，在编译
<code>PetViewController.swift</code> 时，编译器需要找到
<code>PetView</code>
的初始化方法，然后才能检查调用方式。在此之前，根据依赖关系，编译器需要先解析并验证
<code>PetView.swift</code>，从而确保 <code>PetView</code>
的初始化方法调用正确。不过，编译器不需要解析 <code>PetView</code>
初始化方法的函数体部分。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-find-declaration.png?x-oss-process=image/resize,w_800" /></p>
<p>在编译 Swift 文件过程中，编译器会查找 Swift Target 中的所有 Swift
文件。当并行编译文件时，由于需要查找声明，所以会产生大量的重复工作，如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-repeat-work.png?x-oss-process=image/resize,w_800" /></p>
<p>为了解决这个问题，Xcode 10
将文件进行分组编译，从而减少冗余工作，如下所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-group-compile.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="查找-objective-c-中的声明">查找 Objective-C 中的声明</h3>
<p>除了 Swift Target 中的声明，编译器还需要查找 OC 声明。事实上，swiftc
编译器中嵌入了 Clang，所以我们可以直接导入 Clang 框架。</p>
<p>OC 中的声明主要有三种来源：</p>
<ul>
<li>导入的 OC framework：源自 Clang module map 暴露的头文件</li>
<li>混编 framework 的内部：源自 umbrella header</li>
<li>application 和 单元测试内部：源自 target 的 bridging header</li>
</ul>
<p>导入器在找到声明后，通常会对它们进行命名修饰（Name
Mangling），使其更具 Swift 风格。比如，导入器会将
<code>- (void)drawPet:(nonnull Pet *)pet atPoint:(CGPoint)point;</code>
命名修饰为 <code>draw(fluffy, at: origin)</code>
这样的风格。事实上，编译器是通过内部的一个单词表来实现这个功能的，当然有些单词没有被收录其中，所以转换后的命名也并不一定符合预期。对于这种情况，我们可以使用
<code>NS_SWIFT_NAME</code> 来显式定义导入命名。</p>
<h2 id="生成接口">生成接口</h2>
<p>很显然，生成的接口有两种用途：</p>
<ul>
<li>用于 Objective-C</li>
<li>用于 Swift Target</li>
</ul>
<h3 id="生成用于-objective-c-的接口">生成用于 Objective-C 的接口</h3>
<p>事实上，编译器会为 Swift 生成一个头文件。这个头文件中会包含继承自
<code>NSObject</code> 的类和使用 <code>@objc</code>
修饰的方法的声明。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-generated-oc-header.png?x-oss-process=image/resize,w_800" /></p>
<p>对于不同的场景，生成的头文件也有所不同。</p>
<ul>
<li>对于应用内部，头文件会包含 <code>public</code> 和
<code>internal</code> 的声明，允许在 OC 中使用 Swift
内部的方法和属性。</li>
<li>对于框架，头文件只会包含 <code>public</code> 的声明。</li>
</ul>
<p>在上述例子中，<code>PetCollar</code> 自动生成的 OC 类名是
<code>_TtC7PetWall9PetCollar</code>，这样是为了避免与 OC
中定义的类名产生冲突。当然，我们也可以通过 <code>@objc(Name)</code>
的方式指定其在 OC 中的命名，这时需要我们自己保证命名不会产生冲突。</p>
<h3 id="生成用于-swift-target-的接口">生成用于 Swift Target 的接口</h3>
<p>当我们要在其他 Swift Target 中引用 Swift 时，首先需要导入模块。在
Swift
中，一个模块是一个可分配的声明单元。为了使用这些声明，我们必须要导入模块。每个
Swift Target 都会生成一个单独的模块。对于 <code>PetWall</code>
也是如此。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-swift-module.png?x-oss-process=image/resize,w_800" /></p>
<p>当导入一个模块后，编译器会反序列化一个特殊的 swiftmodule
文件，用于检查用到的类型。比如，在上述例子中，编译器会加载
<code>PetWall.swiftmodule</code> 中的 <code>PetViewController</code>
的部分来确保创建的 <code>PetViewController</code> 的代码是正确的。</p>
<h4 id="swiftmodule-vs-header">swiftmodule VS header</h4>
<p>swiftmodule
文件是一个序列化的二进制表示，描述了模块的声明。编译器可以反序列化
swiftmodule 文件，用于检查类型。因此，swiftmodule 有点类似于生成的 OC
头文件（generated Objective-C
header）。区别在前者是二进制表示，后者是文本表示。此外，swiftmodule
还包含了私有声明的命名和类型，因此我们可以用于进行调试。</p>
<p>对于增量编译，编译器会部分地生成 swiftmodule 文件，并最终合并成一个
swiftmodule 文件和一个 OC 头文件，如下图所示：</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/behind-the-xcode-swiftmodule-build.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文分别从构建系统、Clang、Swift 混编等方面介绍了 Xcode
构建过程的幕后原理。从中，我们了解了之前所不知道的一些细节，如：header
map、clang module、module map、swift module 等。</p>
<p>关于链接这一部分，本文没有进行介绍，链接的本质就是对符号进行修正，转换成实际的地址。具体后面有时间再进行补充。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://developer.apple.com/videos/play/wwdc2018/415/">Behind the
Scenes of the Xcode Build Process</a></li>
<li><a href="https://objccn.io/issue-6-1/">Build 过程</a></li>
<li><a
href="https://developer.apple.com/videos/play/wwdc2018/408/">Building
faster in xcode</a></li>
<li><a href="https://clang.llvm.org/docs/Modules.html">Clang
Modules</a></li>
<li><a
href="https://medium.com/flawless-app-stories/swift-compiler-what-we-can-learn-96872ea4b1b8">Swift
Compiler: What we can learn</a></li>
<li><a
href="https://medium.com/@jyaunches/introduction-to-the-llvm-for-a-ios-engineer-8c00ed0f9ff0">Introduction
to the LLVM for a iOS Engineer</a></li>
<li><a
href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift">Importing
Objective-C into Swift</a></li>
<li><a
href="https://medium.com/flawless-app-stories/swift-compiler-what-we-can-learn-96872ea4b1b8">Swift
Compiler: What we can learn</a></li>
<li><a
href="https://dmtopolog.com/code-optimization-for-swift-and-objective-c/">Compile-time
code optimization for Swift and Objective-C</a></li>
<li><a
href="https://developer.apple.com/videos/play/wwdc2016/413/">Introduction
to Xcode</a></li>
<li><a href="https://www.jianshu.com/p/9c3855f543dd">(WWDC) Xcode
构建过程的幕后 —— Clang 编译器</a></li>
<li><a href="https://www.jianshu.com/p/8bcb0ffb3677">(WWDC) Xcode
构建过程的幕后 —— Swift</a></li>
<li><a href="https://www.jianshu.com/p/a541d77944d4">(WWDC) Xcode
构建过程的幕后 —— Linker</a></li>
<li><a href="https://github.com/apple/swift-llbuild/">llbuild</a></li>
</ol>
]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>clang</tag>
        <tag>xcode</tag>
        <tag>clang module</tag>
        <tag>module map</tag>
        <tag>swift module</tag>
        <tag>header map</tag>
        <tag>module cache</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解读——Masonry</title>
    <url>/2019/10/02/understand-masonry/</url>
    <content><![CDATA[<h1 id="masonry-概述">Masonry 概述</h1>
<p>Masonry 是基于 Apple 的自动布局封装的一个轻量级布局框架。Masonry
通过一种链式的 DSL（Domain-Specific Language）来描述
<code>NSLayoutConstraint</code>。相比原生的自动布局语法，Masonry
提供了更为简便的语法来构造布局。Masonry 同时支持 iOS 和 Mac OS X。</p>
<span id="more"></span>
<p>关于原生的自动布局的详细内容，可以阅读另一篇文章——<a
href="http://chuquan.me/2019/09/25/systematic-understand-ios-autolayout/">《系统理解
iOS 自动布局》</a>。</p>
<p>本文所分析的 Masonry 源码版本是 <code>7.4.2</code>。</p>
<h1 id="auto-layout-vs-masonry">Auto Layout VS Masonry</h1>
<p>苹果提供的自动布局（Auto
Layout）能够对视图进行灵活有效的布局。但是，使用原生的自动布局相关的语法创建约束的过程是非常冗长的，可读性也比较差。</p>
<p>如下所示代码，其作用是让一个子视图填充其父视图，其中子视图的每一边相对父视图缩进
10 像素。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *superview = <span class="keyword">self</span>.view;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">[superview addSubview:view1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIEdgeInsets</span> padding = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">[superview addConstraints:@[</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view1 constraints</span></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:padding.top],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeLeft</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeLeft</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:padding.left],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:-padding.bottom],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                                multiplier:<span class="number">1</span></span><br><span class="line">                                  constant:-padding.right],</span><br><span class="line"></span><br><span class="line"> ]];</span><br></pre></td></tr></table></figure>
由上可见，使用原生的自动布局语法，对于如此简单的一个布局，也是非常冗长的。如果使用
VFL（Visual Format Language）可以有效减少冗余，但是其 ASCII
类型语法使得编译器无法做类型检查，存在一定的安全隐患。</p>
<p>Masonry 的目标其实就是
<strong>为了解决原生自动布局语法冗长的问题</strong>。对于上述示例，使用
Masonry 只需要一下几行代码即可解决。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIEdgeInsets</span> padding = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(superview.mas_top).with.offset(padding.top); <span class="comment">//with is an optional semantic filler</span></span><br><span class="line">    make.left.equalTo(superview.mas_left).with.offset(padding.left);</span><br><span class="line">    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);</span><br><span class="line">    make.right.equalTo(superview.mas_right).with.offset(-padding.right);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>甚至还可以更加简单： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.equalTo(superview).with.insets(padding);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h1 id="masonry-架构">Masonry 架构</h1>
<h2 id="基本组成">基本组成</h2>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/masonry-overview.png?x-oss-process=image/resize,w_800" /></p>
<p>Masonry 主要方法由上述例子就可一窥全貌。Masonry 主要通过对
<code>UIView</code>（<code>NSView</code>）、<code>NSArray</code>、<code>UIViewController</code>
进行分类扩展，从而提供自动布局的构建方法。相关方法定义在上图所示部分文件中：</p>
<ul>
<li><code>View+MASAddtions</code></li>
<li><code>NSArray+MASAddtions</code></li>
<li><code>ViewController+MASAddtions</code></li>
</ul>
<p>通过分类提供的自动布局构建方法主要有以下这些： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// View+MASAddtions</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="type">void</span>(<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="type">void</span>(<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="type">void</span>(<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray+Addtions</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="type">void</span> (<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="type">void</span> (<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="type">void</span> (<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="type">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedSpacing:(<span class="built_in">CGFloat</span>)fixedSpacing leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br><span class="line">- (<span class="type">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedItemLength:(<span class="built_in">CGFloat</span>)fixedItemLength leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br></pre></td></tr></table></figure></p>
<p>上述自动布局构建方法均使用一个<code>void(NS_NOESCAPE ^)(MASConstraintMaker *make)</code>
类型的 block 作为参数。的确，<code>MASConstraintMaker</code> 就是
Mansonry 框架中构建布局约束的核心。<code>MASConstraintMaker</code>
引用了 <code>MASConstraint</code>
的一系列方法及其子类（包括：<code>MASCompositeConstraint</code>、<code>MASViewConstraint</code>），从而实现约束的创建与添加。</p>
<p><code>MASConstraint</code> 则提供了一系列返回类型为
<code>MASConstraint</code> 的方法，从而实现了链式 DSL，使 Masonry
具备了简洁灵活的优点。</p>
<p>下面，我们依次来介绍 Masonry 框架中的几个重要类：</p>
<ul>
<li><code>MASLayoutConstraint</code></li>
<li><code>MASViewAttribute</code></li>
<li><code>MASConstraint</code></li>
<li><code>MAConstraintMaker</code></li>
</ul>
<h3 id="maslayoutconstraint">MASLayoutConstraint</h3>
<p><code>MASLayoutConstraint</code> 类继承自
<code>NSLayoutConstraint</code> 类。相比其父类，它就多了一个属性
<code>mas_key</code>。</p>
<p><code>MASLayoutConstraint</code> 用来表示
<strong>布局约束</strong>。</p>
<h3 id="masviewattribute">MASViewAttribute</h3>
<p>我们知道在自动布局系统中，约束的本质是一个方程式： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">item1.attribute1 = multiplier × item2.attribute2 + constant</span><br></pre></td></tr></table></figure> <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/view-formula.png?x-oss-process=image/resize,w_800" /></p>
<p><code>MASViewAttribute</code> 就是约束方程式中一个 <code>item</code>
与 <code>attribute</code> 组成的单元。</p>
<p>如下所示便是 <code>MASViewAttribute</code> 定义的属性。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MASViewAttribute</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The view which the reciever relates to. Can be nil if item is not a view.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) MAS_VIEW *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The item which the reciever relates to.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span> item;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The attribute which the reciever relates to</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> layoutAttribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
其中，关于 <code>NSLayoutAttribute</code> 枚举所包含的类型，详见 《<a
href="http://chuquan.me/2019/09/25/systematic-understand-ios-autolayout/">系统理解
iOS 自动布局</a>》中 <strong>约束/约束规则/属性</strong> 小节。</p>
<h3 id="masconstraint">MASConstraint</h3>
<p><code>MASConstraint</code> 是一个抽象类，主要为其子类
<code>MASViewConstraint</code> 和 <code>MASCompositeConstraint</code>
声明了一些共有的方法。<code>MASConstraint</code>
为这些共有的方法实现了部分功能，底层的细节实现则由其子类决定。</p>
<p>根据约束方程式的组成，可将这些方法分为以下几类：</p>
<ul>
<li>属性操作方法（Attribute）</li>
<li>关系操作方法（Relationship）</li>
<li>倍数操作方法（Multiplier）</li>
<li>常量操作方法（Constant）</li>
</ul>
<p>除此之外，还有优先级操作方法。</p>
<p><strong>属性操作方法</strong></p>
<p>属性操作方法根据对应的 <code>NSLayoutAttribute</code>
枚举类型创建约束属性项。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)left;</span><br><span class="line">- (MASConstraint *)top;</span><br><span class="line">- (MASConstraint *)right;</span><br><span class="line">- (MASConstraint *)bottom;</span><br><span class="line">- (MASConstraint *)leading;</span><br><span class="line">- (MASConstraint *)trailing;</span><br><span class="line">- (MASConstraint *)width;</span><br><span class="line">- (MASConstraint *)height;</span><br><span class="line">- (MASConstraint *)centerX;</span><br><span class="line">- (MASConstraint *)centerY;</span><br><span class="line">- (MASConstraint *)baseline;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)firstBaseline;</span><br><span class="line">- (MASConstraint *)lastBaseline;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)leftMargin;</span><br><span class="line">- (MASConstraint *)rightMargin;</span><br><span class="line">- (MASConstraint *)topMargin;</span><br><span class="line">- (MASConstraint *)bottomMargin;</span><br><span class="line">- (MASConstraint *)leadingMargin;</span><br><span class="line">- (MASConstraint *)trailingMargin;</span><br><span class="line">- (MASConstraint *)centerXWithinMargins;</span><br><span class="line">- (MASConstraint *)centerYWithinMargins;</span><br></pre></td></tr></table></figure>
这些操作方法内部都是通过一个抽象方法实现，须由子类具体实现，该方法为：
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span> __unused)layoutAttribute</span><br></pre></td></tr></table></figure></p>
<p><strong>关系操作方法</strong></p>
<p>关系操作方法根据 <code>NSLayoutRelation</code>
枚举类型创建约束关系项。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="type">id</span> attr))equalTo;</span><br><span class="line">- (MASConstraint * (^)(<span class="type">id</span> attr))greaterThanOrEqualTo;</span><br><span class="line">- (MASConstraint * (^)(<span class="type">id</span> attr))lessThanOrEqualTo;</span><br></pre></td></tr></table></figure>
这些操作方法内部都是通过一个抽象方法实现，须由子类具体实现，该方法为：
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="type">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation;</span><br></pre></td></tr></table></figure></p>
<p><strong>倍数操作方法</strong></p>
<p>两个倍数操作方法都是抽象方法，须由子类具体实现。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> multiplier))multipliedBy;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> divider))dividedBy;</span><br></pre></td></tr></table></figure></p>
<p><strong>常量操作方法</strong></p>
<p>常量操作方法内部各自调用对应的 <code>setter</code> 方法，而这些
<code>setter</code> 方法都是抽象方法，须由子类具体实现。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(MASEdgeInsets insets))insets;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> inset))inset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGSize</span> offset))sizeOffset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGPoint</span> offset))centerOffset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> offset))offset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">NSValue</span> *value))valueOffset;</span><br></pre></td></tr></table></figure></p>
<p><strong>优先级操作方法</strong></p>
<p>后三个优先级操作方法根据 <code>NSLayoutPriority</code>
枚举类型设置约束优先级，其内部都是通过调用第一个优先级操作方法实现的，该方法为抽象方法，须子类具体实现。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(MASLayoutPriority priority))priority;</span><br><span class="line">- (MASConstraint * (^)())priorityLow;</span><br><span class="line">- (MASConstraint * (^)())priorityMedium;</span><br><span class="line">- (MASConstraint * (^)())priorityHigh;</span><br></pre></td></tr></table></figure></p>
<h4 id="masviewconstraint">MASViewConstraint</h4>
<p><code>MASViewConstraint</code> 是 <code>MASConstraint</code>
的子类，可以称之为 Masonry 中 <strong>最重要的类</strong>。</p>
<p><code>MASViewConstraint</code> 除了能够
<strong>完整表示约束方程式</strong> 之外，还存储了约束的
<strong>优先级</strong> 属性。我们来看一下其外部属性和内部属性。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Public</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *firstViewAttribute;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *secondViewAttribute;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Private</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) MASViewAttribute *secondViewAttribute;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MAS_VIEW *installedView;                <span class="comment">// 约束被添加到的位置（视图）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MASLayoutConstraint *layoutConstraint;  <span class="comment">// 约束</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSLayoutRelation</span> layoutRelation;      <span class="comment">// 关系</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) MASLayoutPriority layoutPriority;     <span class="comment">// 优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutMultiplier;             <span class="comment">// 倍数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutConstant;               <span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> hasLayoutRelation;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> mas_key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> useAnimator;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看一下 <code>MASViewConstraint</code>
实现的父类抽象方法。</p>
<p>首先，属性操作方法所调用的一个抽象方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 必须是没有设置过布局关系，即 hasLayoutRelation 为 NO</span></span><br><span class="line">    <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@&quot;Attributes should be chained before defining the constraint relation&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，<code>MASViewConstraint</code>
其实将该方法的具体实现交给了它的代理。</p>
<p>其次，关系操作方法所调用的一个抽象方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="type">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="type">id</span> attribute, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([attribute isKindOfClass:<span class="built_in">NSArray</span>.class]) &#123;</span><br><span class="line">            <span class="comment">// 必须是没有设置过布局关系，即 hasLayoutRelation 为 NO</span></span><br><span class="line">            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@&quot;Redefinition of constraint relation&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果 attribute 是一组属性，则生成一组约束</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *children = <span class="built_in">NSMutableArray</span>.new;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">id</span> attr <span class="keyword">in</span> attribute) &#123;</span><br><span class="line">                MASViewConstraint *viewConstraint = [<span class="keyword">self</span> <span class="keyword">copy</span>];</span><br><span class="line">                viewConstraint.layoutRelation = relation;</span><br><span class="line">                viewConstraint.secondViewAttribute = attr;</span><br><span class="line">                [children addObject:viewConstraint];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将一组约束转换成组合约束，并将代理所持有对应的约束进行替换</span></span><br><span class="line">            MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">            compositeConstraint.delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">            [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">            <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation || <span class="keyword">self</span>.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:<span class="built_in">NSValue</span>.class], <span class="string">@&quot;Redefinition of constraint relation&quot;</span>);</span><br><span class="line">            <span class="comment">// 如果 attribute 是单个属性，则设置约束的第二项</span></span><br><span class="line">            <span class="keyword">self</span>.layoutRelation = relation;</span><br><span class="line">            <span class="keyword">self</span>.secondViewAttribute = attribute;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，针对 <code>attribute</code>
的不同，<code>equalToWithRelation</code> 方法实现了不同的逻辑。</p>
<p>接着，倍数操作方法所调用的两个抽象方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span>))multipliedBy &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="built_in">CGFloat</span> multiplier) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasBeenInstalled,</span><br><span class="line">                 <span class="string">@&quot;Cannot modify constraint multiplier after it has been installed&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.layoutMultiplier = multiplier;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span>))dividedBy &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="built_in">CGFloat</span> divider) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasBeenInstalled,</span><br><span class="line">                 <span class="string">@&quot;Cannot modify constraint multiplier after it has been installed&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.layoutMultiplier = <span class="number">1.0</span>/divider;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，这两个方法本质上就是修改了 <code>MASViewConstraint</code>
的倍数属性 <code>layoutMultiplier</code>。</p>
<p>然后，常量操作方法所调用的几个抽象方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有约束方程式第一项的属性是：</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeLeft、NSLayoutAttributeLeading、</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeTop、NSLayoutAttributeBottom、</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeRight、NSLayoutAttributeTrailing </span></span><br><span class="line"><span class="comment">// 时，方法才会有效设置常量属性</span></span><br><span class="line">- (<span class="type">void</span>)setInsets:(MASEdgeInsets)insets &#123;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> layoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="keyword">switch</span> (layoutAttribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeLeading</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = insets.left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeTop</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = insets.top;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeBottom</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = -insets.bottom;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeTrailing</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = -insets.right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInsets 的特殊情况</span></span><br><span class="line">- (<span class="type">void</span>)setInset:(<span class="built_in">CGFloat</span>)inset &#123;</span><br><span class="line">    [<span class="keyword">self</span> setInsets:(MASEdgeInsets)&#123;.top = inset, .left = inset, .bottom = inset, .right = inset&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接设置常量属性</span></span><br><span class="line">- (<span class="type">void</span>)setOffset:(<span class="built_in">CGFloat</span>)offset &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstant = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有约束方程式第一项的属性是：</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeWidth、NSLayoutAttributeHeight</span></span><br><span class="line"><span class="comment">// 时，方法才会有效设置常量属性</span></span><br><span class="line">- (<span class="type">void</span>)setSizeOffset:(<span class="built_in">CGSize</span>)sizeOffset &#123;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> layoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="keyword">switch</span> (layoutAttribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeWidth</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = sizeOffset.width;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeHeight</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = sizeOffset.height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有约束方程式第一项的属性是：</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeCenterX、NSLayoutAttributeCenterY</span></span><br><span class="line"><span class="comment">// 时，方法才会有效设置常量属性</span></span><br><span class="line">- (<span class="type">void</span>)setCenterOffset:(<span class="built_in">CGPoint</span>)centerOffset &#123;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> layoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="keyword">switch</span> (layoutAttribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeCenterX</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = centerOffset.x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeCenterY</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = centerOffset.y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，这些 <code>setter</code> 方法会根据
<code>MASViewConstraint</code> 已有的 <code>firstViewAttribute</code>
约束项的约束属性 <code>layoutAttribuet</code>
的类型来设置常量属性。当属性不匹配值，对常量属性的设置并不会生效。</p>
<p>最后，优先级操作方法的一个抽象方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(MASLayoutPriority))priority &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(MASLayoutPriority priority) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasBeenInstalled,</span><br><span class="line">                 <span class="string">@&quot;Cannot modify constraint priority after it has been installed&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.layoutPriority = priority;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到，该方法内部直接设置了 <code>MASViewConstraint</code>
的优先级属性 <code>layoutPriority</code>。</p>
<h4 id="mascompositeconstraint">MASCompositeConstraint</h4>
<p><code>MASCompositeConstraint</code> 也是 <code>MASConstraint</code>
的子类。与 <code>MASViewConstraint</code>
只表示一个约束不同，<code>MASCompositeConstraint</code>
可以表示一组约束。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MASCompositeConstraint</span> () &lt;<span class="title">MASConstraintDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> mas_key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *childConstraints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure> 其中，<code>childConstraints</code>
属性持有了一组约束。</p>
<p>我们再来看一下 <code>MASCompositeConstraint</code>
实现的父类抽象方法。</p>
<p>首先，属性操作方法所调用的一个抽象方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    [<span class="keyword">self</span> constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 该方法调用了
<code>MASCompositeConstraint</code> 所实现的
<code>MASConstraintDelegate</code> 的一个方法。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="type">id</span>&lt;MASConstraintDelegate&gt; strongDelegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">    MASConstraint *newConstraint = [strongDelegate constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">    newConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.childConstraints addObject:newConstraint];</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看出，该方法内部将通过其代理新创建的普通约束或组合约束添加至
<code>MASCompositeConstraint</code> 的 <code>childConstraints</code>
数组中，并设置子约束的代理为 <code>MASCompositeConstraint</code>
的代理。</p>
<p>事实上，在 Masonry 中，下文将要提到的 <code>MASConstraintMaker</code>
充当了所有约束的最终代理，如下图所示。<code>MASCompositeConstraint</code>
只是充当了转接和补充的作用。 <img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/relation-of-masconstraintmaker-and-masconstraint.png?x-oss-process=image/resize,w_800" /></p>
<p>至于关系操作方法、倍数操作方法、常量操作方法、优先级操作方法所调用的抽象方法。<code>MASCompositeConstraint</code>
对此的实现基本相同，都是对 <code>childConstraints</code>
中的约束进行遍历设置。</p>
<h3 id="masconstraintmaker">MASConstraintMaker</h3>
<p><code>MASConstraintMaker</code> 是 Masonry 的核心。</p>
<p><code>MASConstraintMaker</code>
指定了构建布局的目标视图以及相关的约束。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MASConstraintMaker</span> () &lt;<span class="title">MASConstraintDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MAS_VIEW *view;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *constraints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><code>MASConstraintMaker</code> 提供了一系列只读的
<code>MASConstraint</code> 属性。这些属性在其 <code>getter</code>
方法内创建了对应 <code>NSLayoutAttribute</code>
枚举类型的约束项。这些属性包括以下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *firstBaseline;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *lastBaseline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leftMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *rightMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *topMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottomMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leadingMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailingMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerXWithinMargins;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerYWithinMargins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *edges;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *size;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *center;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *(^attributes)(MASAttribute attrs);</span><br></pre></td></tr></table></figure></p>
<p>上面提到，<code>MASViewConstraint</code> 和
<code>MASCompositeConstraint</code>
都会利用其代理来创建并添加约束项，而它们的代理都是
<code>MASConstraintMaker</code>。那么，我们来看一下
<code>MASConstraintMaker</code> 对于 <code>MASConstraintDelegate</code>
的实现是怎么样的。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)constraint:(MASConstraint *)constraint shouldBeReplacedWithConstraint:(MASConstraint *)replacementConstraint &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> index = [<span class="keyword">self</span>.constraints indexOfObject:constraint];</span><br><span class="line">    <span class="built_in">NSAssert</span>(index != <span class="built_in">NSNotFound</span>, <span class="string">@&quot;Could not find constraint %@&quot;</span>, constraint);</span><br><span class="line">    [<span class="keyword">self</span>.constraints replaceObjectAtIndex:index withObject:replacementConstraint];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 根据 约束属性 和 视图 创建一个约束单元</span></span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="comment">//创建约束，以约束单元作为约束的第一项</span></span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">// 如果是在已有约束的基础上再创建的约束，则将它们转换成一个 组合约束，并将原约束替换成该组合约束。</span></span><br><span class="line">        <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        <span class="comment">// 如果不是在已有约束的基础上再创建约束，则添加约束至列表</span></span><br><span class="line">        newConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 我们先看
<code>constraint:shouldBeReplacedWithConstraint:</code>
方法，该方法的职责非常简单，就是在已有的约束中查找某个约束并进行替换。</p>
<p>我们再看<code>constraint:addConstraintWithLayoutAttribute:</code>
方法，该方法是被调用较多的一个方法，其职责主要就是创建并添加约束至
<code>constraints</code> 列表属性中。</p>
<h2 id="工作流程">工作流程</h2>
<p>在了解了 Masonry 的基本组成之后，我们再通过一个示例来介绍一下 Masonry
的工作流程。</p>
<p>示例如下所示。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[view mas_makeConstraints::^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(@<span class="number">10</span>);</span><br><span class="line">    make.left.equalTo(superview.mas_left).offset(<span class="number">10</span>);</span><br><span class="line">    make.width.height.equalTo(@<span class="number">100</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>首先执行分类方法 <code>mas_makeConstraints:</code>。 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="type">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
方法内部先设置 <code>translatesAutoresizingMaskIntoConstraints</code> 为
<code>NO</code>。因为，Autoresize Mask 和 Auto Layout
是两套布局系统，前者默认可以转换成后者。为了避免前者对自动布局系统产生干扰，这里需要关闭布局转换。</p>
<p>方法内部还会创建一个 <code>MASConstraintMaker</code>
实例，然后以此为参数调用 block 执行。</p>
<p><code>constraintMaker</code> 创建完约束后，在调用
<code>install</code>
方法将约束添加至正确的约束层级位置。<code>install</code>
方法的内部实现如下： <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line">    <span class="comment">// 只有在 mas_remakeConstraints 时，removeExisting 才为 YES</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line">        <span class="comment">// 此时，需要先删除所有的约束</span></span><br><span class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加约束</span></span><br><span class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line">        <span class="comment">// 设置约束的 updateExisting 属性</span></span><br><span class="line">        <span class="comment">// 只有在 mas_updateConstraints 时，updateExisting 才为 YES</span></span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空 constraints 数组缓存</span></span><br><span class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>install</code> 方法内部会对
<code>constraints</code> 列表中的所有约束依次执行各自的
<code>install</code> 方法来添加约束。我们来看一下约束的
<code>install</code> 方法 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MASCompositeConstraint</span></span><br><span class="line">- (<span class="type">void</span>)install &#123;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> <span class="keyword">self</span>.childConstraints) &#123;</span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (<span class="type">void</span>)install &#123;</span><br><span class="line">    <span class="comment">// 约束是否已被添加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hasBeenInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果约束支持 isActive 方法，且 self.layoutConstraint 有值了</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> supportsActiveProperty] &amp;&amp; <span class="keyword">self</span>.layoutConstraint) &#123;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint.active = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span>.firstViewAttribute.view.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MAS_VIEW *firstLayoutItem = <span class="keyword">self</span>.firstViewAttribute.item;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> firstLayoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    MAS_VIEW *secondLayoutItem = <span class="keyword">self</span>.secondViewAttribute.item;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> secondLayoutAttribute = <span class="keyword">self</span>.secondViewAttribute.layoutAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alignment attributes must have a secondViewAttribute</span></span><br><span class="line">    <span class="comment">// therefore we assume that is refering to superview</span></span><br><span class="line">    <span class="comment">// eg make.left.equalTo(@10)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute &amp;&amp; !<span class="keyword">self</span>.secondViewAttribute) &#123;</span><br><span class="line">        secondLayoutItem = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">        secondLayoutAttribute = firstLayoutAttribute;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个 NSLayoutConstraint</span></span><br><span class="line">    MASLayoutConstraint *layoutConstraint</span><br><span class="line">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line">                                         constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line">    layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</span><br><span class="line">    layoutConstraint.mas_key = <span class="keyword">self</span>.mas_key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定约束layoutConstraint 的约束层级（即要被添加到的位置）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line">        MAS_VIEW *closestCommonSuperview = [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line">        <span class="built_in">NSAssert</span>(closestCommonSuperview,</span><br><span class="line">                 <span class="string">@&quot;couldn&#x27;t find a common superview for %@ and %@&quot;</span>,</span><br><span class="line">                 <span class="keyword">self</span>.firstViewAttribute.view, <span class="keyword">self</span>.secondViewAttribute.view);</span><br><span class="line">        <span class="keyword">self</span>.installedView = closestCommonSuperview;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</span><br><span class="line">        existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existingConstraint) &#123;</span><br><span class="line">        <span class="comment">// just update the constant</span></span><br><span class="line">        <span class="comment">// 约束存在，则更新constant值</span></span><br><span class="line">        existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint = existingConstraint;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 约束不存在，则在该位置添加约束</span></span><br><span class="line">        [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</span><br><span class="line">        [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 无论是
<code>MASCompositeConstraint</code> 还是
<code>MASViewConstraint</code>，本质上还是调用
<code>MASViewConstraint</code> 的 <code>install</code> 方法。该方法根据
<code>MASViewConstraint</code>
的各个属性创建一个原生的约束（<code>NSLayoutConstraint</code>
类型），并在定位约束层级后，将约束添加到相应层级的视图上。</p>
<p>下面，我们再来看看执行 block 又发生了什么。</p>
<p>首先，看一下 <code>make.top.equalTo(@10);</code> 的执行流程。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MASConstraintMaker</span></span><br><span class="line">- (MASConstraint *)top &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeTop</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> constraint:<span class="literal">nil</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 根据 约束属性 和 视图 创建一个约束单元</span></span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="comment">//创建约束，以约束单元作为约束的第一项</span></span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        <span class="comment">// 如果不是在已有约束的基础上再创建约束，则添加约束至列表</span></span><br><span class="line">        newConstraint.delegate = <span class="keyword">self</span>;      <span class="comment">// 注意这一步，会对 make.top.left 这种情形产生关键影响，详见下文</span></span><br><span class="line">        [<span class="keyword">self</span>.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.top 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="type">id</span>))equalTo &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="type">id</span> attribute) &#123;</span><br><span class="line">        <span class="comment">// attribute 可能是 @0 类似的值，也可能是 view.mas_width等这样的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="type">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="type">id</span> attribute, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([attribute isKindOfClass:<span class="built_in">NSArray</span>.class]) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation || <span class="keyword">self</span>.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:<span class="built_in">NSValue</span>.class], <span class="string">@&quot;Redefinition of constraint relation&quot;</span>);</span><br><span class="line">            <span class="keyword">self</span>.layoutRelation = relation;</span><br><span class="line">            <span class="keyword">self</span>.secondViewAttribute = attribute;   <span class="comment">// 设置约束第二项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setSecondViewAttribute:(<span class="type">id</span>)secondViewAttribute &#123;</span><br><span class="line">    <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:<span class="built_in">NSValue</span>.class]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setLayoutConstantWithValue:secondViewAttribute];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        <span class="comment">// _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        <span class="comment">// _secondViewAttribute = secondViewAttribute;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (<span class="type">void</span>)setLayoutConstantWithValue:(<span class="built_in">NSValue</span> *)value &#123;</span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:<span class="built_in">NSNumber</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.offset = [(<span class="built_in">NSNumber</span> *)value doubleValue];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(value.objCType, <span class="keyword">@encode</span>(<span class="built_in">CGPoint</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CGPoint point;</span></span><br><span class="line">        <span class="comment">// [value getValue:&amp;point];</span></span><br><span class="line">        <span class="comment">// self.centerOffset = point;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(value.objCType, <span class="keyword">@encode</span>(<span class="built_in">CGSize</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CGSize size;</span></span><br><span class="line">        <span class="comment">// [value getValue:&amp;size];</span></span><br><span class="line">        <span class="comment">// self.sizeOffset = size;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(value.objCType, <span class="keyword">@encode</span>(MASEdgeInsets)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// MASEdgeInsets insets;</span></span><br><span class="line">        <span class="comment">// [value getValue:&amp;insets];</span></span><br><span class="line">        <span class="comment">// self.insets = insets;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NSAssert(NO, @&quot;attempting to set layout constant with unsupported value: %@&quot;, value);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (<span class="type">void</span>)setOffset:(<span class="built_in">CGFloat</span>)offset &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstant = offset;       <span class="comment">// 设置约束常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.top.equalTo(@10) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>然后，我们再看
<code>make.left.equalTo(superview.mas_left).offset(10);</code>
的执行流程。 其实，这个执行流程也就是执行 <code>equalTo</code> 内部的
<code>setSecondViewAttribute</code>
时有所不同。另外，<code>offset</code> 方法做了一步额外的操作。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (<span class="type">void</span>)setSecondViewAttribute:(<span class="type">id</span>)secondViewAttribute &#123;</span><br><span class="line">    <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:<span class="built_in">NSValue</span>.class]) &#123;</span><br><span class="line">        <span class="comment">// [self setLayoutConstantWithValue:secondViewAttribute];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        <span class="comment">// _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        _secondViewAttribute = secondViewAttribute;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NSAssert(NO, @&quot;attempting to add unsupported attribute: %@&quot;, secondViewAttribute);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.left.equalTo(superview.mas_left) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span>))offset &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="built_in">CGFloat</span> offset)&#123;</span><br><span class="line">        <span class="keyword">self</span>.offset = offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setOffset:(<span class="built_in">CGFloat</span>)offset &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstant = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.left.equalTo(superview.mas_left).offset(10) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></p>
<p>最后，我们再看 <code>make.width.height.equalTo(@100);</code>
的执行流程。 其实到 <code>make.width</code>
这一步与前面没有什么差别，再执行 <code>height</code> 时出现了转换。
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint *)height &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeHeight</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@&quot;Attributes should be chained before defining the constraint relation&quot;</span>);</span><br><span class="line">    <span class="comment">// 见上述 make.top.equalTo(@10) 分析代码中的介绍，此时 self.delegate 早已被设置成了 NSConstraintMaker 了</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraintMaker</span></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 根据 约束属性 和 视图 创建一个约束单元</span></span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="comment">// 创建约束，以约束单元作为约束的第一项</span></span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">// 如果是在已有约束的基础上再创建的约束，则将它们转换成一个 组合约束，并将原约束替换成该组合约束。</span></span><br><span class="line">        <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 这里会将原来 make.width 添加的约束 替换成一个 组合约束（宽度约束 + 高度约束）</span></span><br><span class="line">        [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        <span class="comment">// 返回组合约束</span></span><br><span class="line">        <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)constraint:(MASConstraint *)constraint shouldBeReplacedWithConstraint:(MASConstraint *)replacementConstraint &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> index = [<span class="keyword">self</span>.constraints indexOfObject:constraint];</span><br><span class="line">    <span class="built_in">NSAssert</span>(index != <span class="built_in">NSNotFound</span>, <span class="string">@&quot;Could not find constraint %@&quot;</span>, constraint);</span><br><span class="line">    [<span class="keyword">self</span>.constraints replaceObjectAtIndex:index withObject:replacementConstraint];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.width.height 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="type">id</span>))equalTo &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="type">id</span> attribute) &#123;</span><br><span class="line">        <span class="comment">// attribute 可能是 @0 类似的值，也可能是 view.mas_width等这样的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASCompositeConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="type">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="type">id</span>(<span class="type">id</span> attr, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="comment">// CompositeConstraint 的 childConstraits 中每一项，调用 equalToWithRelation</span></span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> <span class="keyword">self</span>.childConstraints.copy) &#123;</span><br><span class="line">            constraint.equalToWithRelation(attr, relation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.width.height.equalTo(@100) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结">总结</h1>
<p>Masonry 巧妙利用了面向对象的继承、多态思想以及 block
的特性，从而实现了非常简便的链式
DSL，极大地提升了自动布局开发的效率。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/SnapKit/Masonry">Masonry</a></li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Masonry</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Aspects 设计原理</title>
    <url>/2022/11/13/understand-principle-of-aspects/</url>
    <content><![CDATA[<p>最近希望在业务中实现一套基于 AOP
的埋点方案，调研过程中，我花了些时间阅读了一下 Aspects 的源码，对于
Aspects
设计有了一些更深入的理解。因此，通过本文记录我在阅读源码后的一些收获和思考，以供后续进行回顾。</p>
<span id="more"></span>
<h1 id="概述">概述</h1>
<p>Aspects 是一款轻量且简易的面向切面编程的框架，其基于 Objective-C
Runtime 原理实现。Aspects 允许我们对
<strong>类的所有实例的实例方法</strong> 或
<strong>单个实例的实例方法</strong>
添加额外的代码，并且支持设置代码的执行时机，包括：<code>before</code>、<code>instead</code>、<code>after</code>
三种。</p>
<p><strong>注意：Aspects
无法为类方法提供面向切面编程的能力</strong>。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 22%" />
<col style="width: 26%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">对象类型</th>
<th style="text-align: left;">目标方法类型</th>
<th style="text-align: left;">Aspects 是否支持 hook</th>
<th style="text-align: left;">hook 效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">类对象（UIViewController）</td>
<td style="text-align: left;">类方法（“+”开头的方法）</td>
<td style="text-align: left;">不支持</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;">类对象（UIViewController）</td>
<td style="text-align: left;">实例方法（“-”开头的方法）</td>
<td style="text-align: left;">支持</td>
<td style="text-align: left;">对类的所有实例对象生效</td>
</tr>
<tr class="odd">
<td style="text-align: left;">实例对象（vc）</td>
<td style="text-align: left;">类方法（“+”开头的方法）</td>
<td style="text-align: left;">不支持</td>
<td style="text-align: left;">-</td>
</tr>
<tr class="even">
<td style="text-align: left;">实例对象（vc）</td>
<td style="text-align: left;">实例方法（“-”开头的方法）</td>
<td style="text-align: left;">支持</td>
<td style="text-align: left;">对单个实例对象生效</td>
</tr>
</tbody>
</table>
<p>这里我们提出第一个问题：为什么 Aspects 仅支持对实例方法进行
hook？</p>
<p>另一方面，Aspects 的作者在框架的 README
中明确表示不要在生产环境中使用
Aspects。这里我们提出第二个问题：在项目中使用 Aspects 进行 hook
是否有什么坑？</p>
<h1 id="基础">基础</h1>
<p>Aspects 巧妙利用了 Objective-C 的消息传递和消息转发机制，实现了一套与
KVO 类似的技术方案。为了能够更加清晰地理解 Aspects
的设计，这里我们简单地回顾一下 Objective-C
的消息传递和消息转发机制。</p>
<h2 id="消息传递">消息传递</h2>
<p>Objective-C 是一门动态语言，其 <strong>方法调用</strong>
在底层的实现是 <strong>消息传递（Message
Passing）</strong>。本质上，消息发送是
<strong>沿着一条引用链依次查找不同的对象，判断该对象是否能够处理消息</strong>。在
Objective-C
中，一切都是对象，包括类、元类，消息就是在这些对象之间进行传递的。</p>
<p>因此，我们需要了解这些对象之间的关系。下图所示，为 Objective-C
对象在内存中的引用关系图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-passing-01.png?x-oss-process=image/resize,w_800" /></p>
<p>在 Objective-C
中，涉及消息传递的方法主要有两种：实例方法、类方法。下面，我们来分别介绍。</p>
<h3 id="实例方法">实例方法</h3>
<p>对于实例方法，消息传递时，根据当前实例对象的 <code>isa</code>
指针，找到其所属的类对象，并在类对象的方法列表中查找。如果找到，则执行；否则，根据
<code>superclass</code>
指针，找到类对象的超类对象，并在超类对象的方法列表中查找，以此类推，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-passing-02.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="类方法">类方法</h3>
<p>虽然 Aspects 不支持 hook
类方法，但是为了方便进行对照，这里我们也介绍一下类方法的查找。</p>
<p>对于类方法，消息传递时，根据当前类对象的 <code>isa</code>
指针，找到其所属的元类对象，并在元类对象的方法列表中查找。如果找到，则执行；否则，根据
<code>superclass</code>
指针，找到元类对象的元超类对象，并在元超类对象的方法列表中查找，以此类推，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-passing-03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="消息转发">消息转发</h2>
<p>如果消息传递无法找到可以处理消息的对象，那么，Objective-C runtime
将进入消息转发（Message Forwarding）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-forward.png?x-oss-process=image/resize,w_800" /></p>
<p>消息转发包含三个阶段：</p>
<ul>
<li><strong>动态消息解析</strong></li>
<li><strong>备用接收者</strong></li>
<li><strong>完整消息转发</strong></li>
</ul>
<h3 id="动态消息解析">动态消息解析</h3>
<p>当对象接收到未知消息时，首先会调用所属类的实例方法
<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code> 或类方法
<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>。我们可以在方法内部动态添加一个“处理方法”，通过
<code>class_addMethod</code> 函数动态添加到类中。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicMethodIMP</span><span class="params">(id self, SEL _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == @<span class="built_in">selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        <span class="built_in">class_addMethod</span>([self <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="备用接收者">备用接收者</h3>
<p>如果上一步无法处理消息，则 runtime 会继续调用
<code>forwardingTargetForSelector:</code> 方法。</p>
<p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是
<code>self</code>）
的对象，则这个对象会作为消息的新接收者，消息会被分发到这个对象。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:@<span class="string">&quot;walk&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h3 id="完整消息转发">完整消息转发</h3>
<p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。</p>
<p>这步调用 <code>methodSignatureForSelector:</code>
进行方法签名，这可以将函数的参数类型和返回值进行封装。如果返回
<code>nil</code>，则说明消息无法处理并报错
<code>unrecognized selector sent to instance</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:@<span class="string">&quot;testInstanceMethod&quot;</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> [NSMethodSignature signatureWithObjcTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回 <code>methodSignature</code>，则进入
<code>forwardInvocation</code>。对象会创建一个表示消息的
<code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在
<code>anInvocation</code> 中，包括
<code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错
<code>unrecognized selector sent to instance</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@<span class="built_in">selector</span>(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="核心原理">核心原理</h1>
<p>Aspects 的核心原理主要包括三个部分：</p>
<ul>
<li><strong>注册关联对象</strong>：在 hook 实例方法时，均会注册关联对象
<code>AspectsContainer</code>。</li>
<li><strong>创建动态类</strong>：只有在 hook
实例对象的实例方法时，才会创建动态类。</li>
<li><strong>核心方法交换</strong>：在 hook
实例方法时，均会对核心方法的实现进行交换。</li>
</ul>
<h2 id="注册关联对象">注册关联对象</h2>
<p>当 hook 实例方法时，Aspects 会为 <strong>实例对象</strong> 或
<strong>类对象</strong> 注册关联对象
<code>AspectsContainer</code>。<code>AspectsContainer</code> 保存了用户
hook 的目标方法、执行闭包、闭包参数、执行时机等信息。下图所示，为
<code>AspectsContainer</code> 引用关系图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-uml.png?x-oss-process=image/resize,w_800" /></p>
<p>关联对象注册的目标分两种情况，这种设计策略是有原因的：</p>
<ul>
<li><strong>在实例对象中注册关联对象，可以实现让每个实例对象单独管理
aspects，从而保证实例之间相互不影响。</strong></li>
<li><strong>在类对象中注册关联对象，可以实现让类的每个实例对象共享
aspects，从而实现影响所有实例对象。</strong></li>
</ul>
<h2 id="创建动态类">创建动态类</h2>
<p>当且仅当 hook 实例对象的实例方法时，Aspects 会为实例的所属类
<code>TestClass</code> 创建一个子类
<code>TestClass_Aspects_</code>（同时创建对应的元类），并修改实例的
<code>isa</code> 指针，使其指向 <code>TestClass_Aspects_</code>
子类，同时 hook <code>TestClass_Aspects_</code> 的 <code>class</code>
方法，使其返回实例的所属类 <code>TestClass</code>，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-01.png?x-oss-process=image/resize,w_800" /></p>
<p>整体的实现方式与 KVO 原理一致，尤其是修改动态类 <code>class</code>
方法的实现，使得在外部看来，实例的所属类并没有发生任何变化。</p>
<p>这里，我们可以思考一下第三个问题：为什么在 hook
实例对象的实例方法时要创建动态类？</p>
<h2 id="核心方法交换">核心方法交换</h2>
<p>当 hook 实例方法时，最重要的一步是对
<strong>动态创建的类对象</strong>（下文简称：动态类对象） 或
<strong>原始继承链中的类对象</strong>（下文简称：目标类对象）
的两个核心方法与 Aspects 提供的方法进行交换。这两个方法分别是：目标
selector 和
<code>forwardInvocation:</code>。具体的交换逻辑如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-02.png?x-oss-process=image/resize,w_800" /></p>
<p>Aspects 会将目标 selector 的实现设置为 Aspects 提供的
<code>aspect_getMsgForwardIMP</code>
方法的返回值。<code>aspects_getMsgForwardIMP</code>
的返回值本质上是一个能够直接触发消息转发机制的方法。更加特殊的地方在于，这里会直接进入消息转发的最后一步
<code>forwardInvocation:</code>。</p>
<p>与此同时，Aspects 会将动态类对象或目标类对象的
<code>forwardInvocation:</code> 的实现设置为 Aspects 提供的
<code>__ASPECTS_ARE_BEING_CALLED__</code>
方法实现。<code>__ASPECTS_ARE_BEING_CALLED__</code> 内部会从
<strong>实例对象</strong> 或 <strong>类对象</strong> 中取出关联对象
<code>AspectsContainer</code>，并根据其所保存的 hook 信息执行闭包和目标
selector 的原始实现。</p>
<p><strong>注意：对于核心方法交换，Aspects
支持幂等。即如果对同一个实例方法 hook 多次，Aspects
会保证对这两个方法只交换一次</strong>。</p>
<h1 id="具体实现">具体实现</h1>
<p>下面，我们来通过源码，具体分析一下 Aspects 中的设计细节。</p>
<h2 id="数据结构">数据结构</h2>
<p>首先，简要介绍一下 Aspects 定义的数据结构，主要包括三种数据结构：</p>
<ul>
<li><code>AspectsContainer</code></li>
<li><code>AspectIdentifier</code></li>
<li><code>AspectInfo</code></li>
</ul>
<h3 id="aspectscontainer">AspectsContainer</h3>
<p>如下所示，为 <code>AspectsContainer</code>
的数据结构定义。<code>AspectsContainer</code> 是 Aspects
所有信息的根容器，其包含了三个数组，用于保存三种类型的
<code>AspectIdentifier</code>。</p>
<ul>
<li><code>beforeAspects</code>：用于保存执行时机为
<code>AspectPositionBefore</code> 的
<code>AspectIdentifier</code>。</li>
<li><code>insteadAspects</code>：用于保存执行时机为
<code>AspectPositionInstead</code> 的
<code>AspectIdentifier</code>。</li>
<li><code>afterAspects</code>：用于保存执行时机为
<code>AspectPositionAfter</code> 的 <code>AspectIdentifier</code>。</li>
</ul>
<p>除此之外，<code>AspectsContainer</code>
还提供了对于数组进行增删操作的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tracks all aspects for an object/class.</span></span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (<span class="type">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@<span class="built_in">property</span> (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@<span class="built_in">property</span> (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@<span class="built_in">property</span> (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="aspectidentifer">AspectIdentifer</h3>
<p>如下所示，为 <code>AspectIdentifier</code>
的数据结构定义。<code>AspectIdentifier</code> 是用于表示一个 aspect
的相关信息，其包含了目标
selector、执行闭包、闭包签名、目标对象、执行时机等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tracks a single aspect.</span></span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, assign) SEL selector;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) id block;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, weak) id object;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="aspectinfo">AspectInfo</h3>
<p>如下所示，为 <code>AspectInfo</code>
的数据结构定义。<code>AspectInfo</code> 的作用是保存目标 selector
的原始实现的执行环境。由于目标 selector 会被交换方法实现，因此
<code>originalInvocation</code> 的 <code>selector</code> 其实是 Aspects
交换的 selector，即 <code>aspects__SEL</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="代码流程">代码流程</h2>
<p>如下所示，Aspects 对外提供两个接口，分别用于 hook
类方法和实例方法，即添加 aspect。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Adds a block of code before/instead/after the current `selector` for a specific class.</span></span><br><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(id)block</span><br><span class="line">                            error:(NSError **)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span></span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(id)block</span><br><span class="line">                            error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>两者的内部实现都只调用了同一个方法
<code>aspect_add</code>，其内部实现逻辑如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> id <span class="title">aspect_add</span><span class="params">(id self, SEL selector, AspectOptions options, id block, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(self);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    <span class="built_in">aspect_performLocked</span>(^&#123;</span><br><span class="line">        <span class="comment">// 判断是否允许 add aspect</span></span><br><span class="line">        <span class="comment">// 如果允许，会顺带构建 tracker 链。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">aspect_isSelectorAllowedAndTrack</span>(self, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">// 加载或创建 container，每个 selector 对应一个 container。</span></span><br><span class="line">            AspectsContainer *aspectContainer = <span class="built_in">aspect_getContainerForObject</span>(self, selector);</span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                <span class="built_in">aspect_prepareClassAndHookSelector</span>(self, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>aspect_add</code> 方法内部实现中，首先通过
<code>aspect_isSelectorAllowedAndTrack</code> 方法判断是否允许添加
aspect。如果允许，则初始化
<code>AspectsContainer</code>，并将其设置成实例对象或类对象的关联对象。一个
selector 对应一个 container，一个实例对象或类对象可包含多个
container。最后通过 <code>aspect_prepareClassAndHookSelector</code>
执行核心方法交换，对于实例对象，还会创建动态类。</p>
<h3
id="aspect_isselectorallowedandtrack"><code>aspect_isSelectorAllowedAndTrack</code></h3>
<p>Aspects 通过 <code>aspect_isSelectorAllowedAndTrack</code>
方法来判断是否允许添加
aspect，如果允许则进行追踪。具体实现逻辑如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> BOOL <span class="title">aspect_isSelectorAllowedAndTrack</span><span class="params">(NSObject *self, SEL selector, AspectOptions options, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// part 1</span></span><br><span class="line">    <span class="comment">// 静态变量，作为黑名单</span></span><br><span class="line">    <span class="type">static</span> NSSet *disallowedSelectorList;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        <span class="comment">// 不允许添加 aspect 的方法黑名单</span></span><br><span class="line">        disallowedSelectorList = [NSSet setWithObjects:@<span class="string">&quot;retain&quot;</span>, @<span class="string">&quot;release&quot;</span>, @<span class="string">&quot;autorelease&quot;</span>, @<span class="string">&quot;forwardInvocation:&quot;</span>, nil];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查方法是否属于黑名单</span></span><br><span class="line">    NSString *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</span><br><span class="line">        NSString *errorDescription = [NSString stringWithFormat:@<span class="string">&quot;Selector %@ is blacklisted.&quot;</span>, selectorName];</span><br><span class="line">        <span class="built_in">AspectError</span>(AspectErrorSelectorBlacklisted, errorDescription);</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 dealloc 方法，只允许在 before 阶段进行 hook</span></span><br><span class="line">    AspectOptions position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:@<span class="string">&quot;dealloc&quot;</span>] &amp;&amp; position != AspectPositionBefore) &#123;</span><br><span class="line">        NSString *errorDesc = @<span class="string">&quot;AspectPositionBefore is the only valid position when hooking dealloc.&quot;</span>;</span><br><span class="line">        <span class="built_in">AspectError</span>(AspectErrorSelectorDeallocPosition, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能 hook 不存在的实例方法</span></span><br><span class="line">    <span class="keyword">if</span> (![self respondsToSelector:selector] &amp;&amp; ![self.<span class="keyword">class</span> instancesRespondToSelector:selector]) &#123;</span><br><span class="line">        NSString *errorDesc = [NSString stringWithFormat:@<span class="string">&quot;Unable to find selector -[%@ %@].&quot;</span>, <span class="built_in">NSStringFromClass</span>(self.<span class="keyword">class</span>), selectorName];</span><br><span class="line">        <span class="built_in">AspectError</span>(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// part 2</span></span><br><span class="line">    <span class="comment">// 如果 hook 目标是类对象，必须保证类继承链上，只允许对一个方法进行一次 hook</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">class_isMetaClass</span>(<span class="built_in">object_getClass</span>(self))) &#123;</span><br><span class="line">        Class klass = [self <span class="keyword">class</span>];</span><br><span class="line">        NSMutableDictionary *swizzledClassesDict = <span class="built_in">aspect_getSwizzledClassesDict</span>();</span><br><span class="line">        Class currentClass = [self <span class="keyword">class</span>];</span><br><span class="line">        <span class="comment">// 检查继承链中是否 hook 过目标类方法</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">            <span class="comment">// 依次遍历超类直到根类，根据类对应的 track 进行判断</span></span><br><span class="line">            <span class="comment">// 如果类方法已经 hook 过，则进一步判断</span></span><br><span class="line">            <span class="keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tracker.parentEntry) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类中 hook 过，则不允许 hook</span></span><br><span class="line">                    <span class="comment">// 同时查找最顶层 tracker，打印日志</span></span><br><span class="line">                    AspectTracker *topmostEntry = tracker.parentEntry;</span><br><span class="line">                    <span class="keyword">while</span> (topmostEntry.parentEntry) &#123;</span><br><span class="line">                        topmostEntry = topmostEntry.parentEntry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    NSString *errorDescription = [NSString stringWithFormat:@<span class="string">&quot;Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&quot;</span>, selectorName, <span class="built_in">NSStringFromClass</span>(topmostEntry.trackedClass)];</span><br><span class="line">                    <span class="built_in">AspectError</span>(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</span><br><span class="line">                    <span class="keyword">return</span> NO;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (klass == currentClass) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前类的方法已经 hook 过，则允许 hook</span></span><br><span class="line">                    <span class="keyword">return</span> YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((currentClass = <span class="built_in">class_getSuperclass</span>(currentClass)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果继承链上没有类对目标方法hook过，则允许 hook，并记录 tracker</span></span><br><span class="line">        <span class="comment">// Add the selector as being modified.</span></span><br><span class="line">        currentClass = klass;</span><br><span class="line">        AspectTracker *parentTracker = nil;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">            <span class="keyword">if</span> (!tracker) &#123;</span><br><span class="line">                tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];</span><br><span class="line">                swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker;</span><br><span class="line">            &#125;</span><br><span class="line">            [tracker.selectorNames addObject:selectorName];</span><br><span class="line">            <span class="comment">// All superclasses get marked as having a subclass that is modified.</span></span><br><span class="line">            parentTracker = tracker;</span><br><span class="line">        &#125;<span class="keyword">while</span> ((currentClass = <span class="built_in">class_getSuperclass</span>(currentClass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>aspect_isSelectorAllowedAndTrack</code>
的内部逻辑可以分为两部分：<strong>方法黑名单检查</strong>、<strong>对象类型检查</strong>。</p>
<p>对于方法黑名单检查，可细分为三个步骤：</p>
<ul>
<li>判断目标方法是不是
<code>retain</code>、<code>release</code>、<code>autorelease</code>
等，如果是，则不允许 hook。</li>
<li>如果目标方法是 <code>dealloc</code>，则只允许 hook
<code>before</code> 时机，其他时机，则不允许 hook。</li>
<li>进一步确认 hook 的目标方法是否存在，如果不存在，则不允许 hook。</li>
</ul>
<p>对于对象类型检查，如果对象类型是实例对象，则允许
hook。如果对象类型是类对象，则进一步判断。根据目标类对象，遍历继承链，对于继承链中的每一个类对象，从全局字典
<code>swizzledClassesDict</code> 中读取对应的追踪器
<code>AspectTracker</code>。根据追踪器的记录，我们可以处理两种情况：</p>
<ul>
<li><strong>如果目标类没有 hook 过目标方法，但其父类 hook 过，则不允许
hook。</strong></li>
<li><strong>如果目标类 hook 过父类方法，但其子类没有 hook 过，则允许
hook。</strong></li>
</ul>
<p>如下图所示，为追踪器工作原理示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-03.png?x-oss-process=image/resize,w_800" /></p>
<p>当对 <code>SubClass</code> 类对象 hook 实例方法 <code>SEL01</code>
时，Aspects 会从 <code>SubClass</code>
类对象开始，遍历其继承链，读取继承链上的每一个类对象所对应的追踪器（如果没有则创建），将目标方法
<code>SEL01</code> 保存至其内部的 <code>selectorNames</code>
数组中作为记录。</p>
<p>后续，如果对 <code>Class</code> 类对象 hook 实例方法
<code>SEL01</code> 时，由于其子类 <code>SubClass</code> 已经 hook
过同名方法，则不允许 <code>Class</code> 对其再次
hook。根据消息传递的原理，对 <code>Class</code> 进行 hook
是不会生效的，因为子类 <code>SubClass</code> 会在消息传递链中提前返回
<code>SEL01</code>。所以，Aspects 的设计不允许在这种情况下再次 hook
同名方法。</p>
<p>当然，如果对 <code>Class</code> 类对象 hook 实例方法
<code>SEL02</code> 时，由于所有其子类均没有 hook 过同名方法，因此允许
<code>Class</code> 对其再次 hook。</p>
<p>本质上，Aspects 利用了 <strong>正向的类对象继承链</strong> 和
<strong>反向的追踪器链</strong>，通过全局字典
<code>swizzledClassDict</code>
进行绑定，形成了一个双向链表，便于判断是否允许对类对象的实例方法进行
hook。</p>
<h3
id="aspect_prepareclassandhookselector"><code>aspect_prepareClassAndHookSelector</code></h3>
<p>如下所示，为 <code>aspect_prepareClassAndHookSelector</code>
的实现逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aspect_prepareClassAndHookSelector</span><span class="params">(NSObject *self, SEL selector, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">// Aspects_Class_</span></span><br><span class="line">    Class klass = <span class="built_in">aspect_hookClass</span>(self, error);</span><br><span class="line">    <span class="comment">// 读取 Aspects_Class_ 的 selector 方法</span></span><br><span class="line">    Method targetMethod = <span class="built_in">class_getInstanceMethod</span>(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = <span class="built_in">method_getImplementation</span>(targetMethod);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">aspect_isMsgForwardIMP</span>(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="comment">// IMP 不能是 _objc_msgForward 或 _objc_msgForward_stret</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *typeEncoding = <span class="built_in">method_getTypeEncoding</span>(targetMethod);</span><br><span class="line">        <span class="comment">// aspects__SEL</span></span><br><span class="line">        SEL aliasSelector = <span class="built_in">aspect_aliasForSelector</span>(selector);</span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在 aspects__SEL，即没有被交换过，则新增一个 aspects__SEL 方法，其实现指向 selector IMP</span></span><br><span class="line">            __unused BOOL addedAlias = <span class="built_in">class_addMethod</span>(klass, aliasSelector, <span class="built_in">method_getImplementation</span>(targetMethod), typeEncoding);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(addedAlias, @<span class="string">&quot;Original implementation for %@ is already copied to %@ on %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 selector 方法的实现指向 _objc_msgForward，从而直接触发消息转发</span></span><br><span class="line">        <span class="built_in">class_replaceMethod</span>(klass, selector, <span class="built_in">aspect_getMsgForwardIMP</span>(self, selector), typeEncoding);</span><br><span class="line">        <span class="built_in">AspectLog</span>(@<span class="string">&quot;Aspects: Installed hook for -[%@ %@].&quot;</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>aspect_hookClass</code>
将判断对象类型，如果是实例对象，则创建一个动态类对象返回；如果是类对象，则返回对应的类对象。</p>
<p>基于 <code>aspect_hookClass</code> 返回的对象，Aspects
将修改该对象的两个方法，使其指向 Aspects
的两个方法实现，即上述我们介绍的 <strong>核心方法交换</strong>。</p>
<p>在 <code>aspect_prepareClassAndHookSelector</code> 的实现中，Aspects
会在进行方法交换之前进行检查，避免重复交换，从而实现幂等。</p>
<h3 id="aspect_hookclass"><code>aspect_hookClass</code></h3>
<p>如下所示，为 <code>aspect_hookClass</code> 的实现逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Class <span class="title">aspect_hookClass</span><span class="params">(NSObject *self, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(self);</span><br><span class="line">    Class statedClass = self.<span class="keyword">class</span>;         <span class="comment">// 其所声明的类</span></span><br><span class="line">    Class baseClass = <span class="built_in">object_getClass</span>(self);<span class="comment">// isa</span></span><br><span class="line">    NSString *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">        <span class="comment">// 如果是实例对象，且实例对象已经 hook 过方法，即其 isa 指向的是动态类对象 Aspects_Class_，则直接复用动态类对象</span></span><br><span class="line">        <span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">class_isMetaClass</span>(baseClass)) &#123;</span><br><span class="line">        <span class="comment">// 如果是类对象，则将该类对象 forwardInvocation: 的实现设置为 _aspects_forwardInvocation:。</span></span><br><span class="line">        <span class="comment">// 方法交换完成后，返回该类对象。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">aspect_swizzleClassInPlace</span>((Class)self);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="comment">// 如果是被 KVO 的实例对象。</span></span><br><span class="line">        <span class="comment">// baseClass 为 KVO 所创建的动态类，则直接对 KVO 创建的动态类对象进行方法交换，交换 forwardInvocation: 与 _aspects_forwardInvocation: 的方法实现。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">aspect_swizzleClassInPlace</span>(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是实例对象，且实例对象未 hook 过方法，则创建动态子类 Aspects_Class_</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">    Class subclass = <span class="built_in">objc_getClass</span>(subclassName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subclass == nil) &#123;</span><br><span class="line">        subclass = <span class="built_in">objc_allocateClassPair</span>(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (subclass == nil) &#123;</span><br><span class="line">            NSString *errrorDesc = [NSString stringWithFormat:@<span class="string">&quot;objc_allocateClassPair failed to allocate class %s.&quot;</span>, subclassName];</span><br><span class="line">            <span class="built_in">AspectError</span>(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将动态类对象的 forwardInvocation: 与 _aspects_forwardInvocation: 进行方法交换</span></span><br><span class="line">        <span class="built_in">aspect_swizzleForwardInvocation</span>(subclass);</span><br><span class="line">        <span class="comment">// 将动态类对象的 class 设置成 statedClass</span></span><br><span class="line">        <span class="built_in">aspect_hookedGetClass</span>(subclass, statedClass);</span><br><span class="line">        <span class="comment">// 将动态类对象的元类的 class 设置成 stateClass</span></span><br><span class="line">        <span class="built_in">aspect_hookedGetClass</span>(<span class="built_in">object_getClass</span>(subclass), statedClass);</span><br><span class="line">        <span class="built_in">objc_registerClassPair</span>(subclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 isa 指针，指向 subclass</span></span><br><span class="line">    <span class="built_in">object_setClass</span>(self, subclass);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>aspect_hookClass</code> 方法主要用于
<strong>选择对哪个对象的目标方法执行 hook</strong>，这里面包含了 4
种具体的情况，依次为：</p>
<ul>
<li>如果目标对象是实例对象，且实例对象曾经 hook
过方法，则直接返回已创建的动态类对象。</li>
<li>如果目标对象是类对象，则对类对象的 <code>forwardInvocation:</code>
方法的实现设置为 Aspects 提供的
<code>_aspects_forwardInvocation:</code>，并返回该类对象。</li>
<li>如果目标对象是被 KVO 的对象，则直接复用 KVO
所创建的动态类，并对动态类对象的 <code>forwardInvocation:</code>
方法的实现设置为 Aspects 提供的
<code>_aspects_forwardInvocation:</code>，并返回 KVO 的动态类对象。</li>
<li>如果目标对象是实例对象，且实例对象没有 hook
过方法，则创建一个动态类对象
<code>Aspects_Class_</code>，同时包括元类对象，并对动态类对象的
<code>forwardInvocation:</code>
方法执行方法交换，并且设置动态类与原始类之间的关系，最终返回动态类对象。</li>
</ul>
<h1 id="相关问题">相关问题</h1>
<p>本节，我们将来介绍上文所提出的几个问题。</p>
<h2 id="问题一为什么-aspects-仅支持对实例方法进行-hook">问题一：为什么
Aspects 仅支持对实例方法进行 hook？</h2>
<p>在 Aspects 的实现中，在判断能够添加 aspect 的逻辑中，会通过
<code>aspect_isCompatibleBlockSignature</code> 方法来判断 block 与
selector 的方法签名是否匹配，如下所示。其中，它会通过类的
<code>instanceMethodSignatureForSelector</code> 方法获取 selector
的方法签名。对于类方法，通过这种方式必然返回
<code>nil</code>，从而导致判断条件无法满足，因此无法 hook 类方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> BOOL <span class="title">aspect_isCompatibleBlockSignature</span><span class="params">(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(blockSignature);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(object);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line"></span><br><span class="line">    BOOL signaturesMatch = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于类方法，通过 instanceMethodSignatureForSelector: 读取必然返回 nil</span></span><br><span class="line">    NSMethodSignature *methodSignature = [[object <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</span><br><span class="line">        signaturesMatch = NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="问题二在项目中使用-aspects-进行-hook-是否有什么坑">问题二：在项目中使用
Aspects 进行 hook 是否有什么坑？</h2>
<p>如果我们真正理解了 Aspects
的设计原理，很容易明白为什么作者不推荐在生产环境中使用
Aspects。事实上，在实际的项目开发中，我们经常会用到对已有方法进行
hook。当然，我们可以保证自己写的代码只使用 Aspects 进行
hook，但是我们无法确定引入的第三方库是否使用其他方式对方法进行
hook。那么，这时候埋下了未知的风险。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-04.png?x-oss-process=image/resize,w_800" /></p>
<p>如上图所示，假如我们对 <code>SEL</code> 与 <code>bcq_SEL</code>
进行了 swizzle。那么，<code>bcq_SEL</code> 的实现将指向 <code>SEL</code>
的实现 <code>aspect_getMsgForwardIMP</code>；<code>SEL</code>
的实现将指向 <code>bcq_SEL</code> 的实现 <code>bcq_IMP</code>。</p>
<p>在有些情况下，比如：hook <code>viewWillAppear:</code>
方法。<code>bcq_IMP</code> 里会再次调用
<code>bcq_SEL</code>，从而再次调用原始实现。这时候，我们调用
<code>SEL</code>，它最终仍然会调用
<code>aspect_getMsgForwardIMP</code>，Aspects 的设置不受影响。</p>
<p>但是有些情况下，<code>bcq_IMP</code>
的内部逻辑可能只在特定条件下调用原始实现，其他条件下调用自定义实现。这时候，我们调用
<code>SEL</code>，在某些条件下将不会触发
<code>aspect_getMsgForwardIMP</code>，最终导致 Aspects
的设置不生效。</p>
<p>显而易见，在生产环境在使用 Aspects
的确可能会出现不确定的异常问题。因此，作者不建议我们在生产环境中使用
Aspects。</p>
<h2
id="问题三为什么在-hook-实例对象的实例方法时要创建动态类">问题三：为什么在
hook 实例对象的实例方法时要创建动态类？</h2>
<p>对于实例对象的实例方法，我们显然不能直接 hook
继承链中的类对象，否则将影响类的所有实例的实例方法。因此，Aspects
选择了一种类似于 KVO 的设计，动态创建一个子类，并将实例对象的
<code>isa</code> 指针指向动态子类。动态子类的 <code>class</code>
方法则指向实例对象的声明类，从而是外部看来没有任何变化。</p>
<p>这种做法，为实例对象单独开辟了一条继承链分支，如下图所示。只有被 hook
的实例对象才会走这条分支继承链，因此不影响其他实例。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-05.png?x-oss-process=image/resize,w_800" /></p>
<p>如果对同一个类的多个实例进行
Aspects，那么会怎么样？从上图中，我们也能猜到，Aspects
会复用动态子类。只不过 hook 的闭包由各个实例对象自己管理而已。</p>
<h1 id="总结">总结</h1>
<p>通过分析 Aspects 的源码及其设计原理，我们同时加深了对于 Objective-C
Runtime 的理解。从中，我们也了解到 Aspects 的局限性，引入需谨慎。</p>
<p>在 Aspects 中，我们看到了很多 Objective-C 的黑魔法 API，比如：</p>
<ul>
<li><code>_objc_msgForward</code>/<code>_objc_msgForward_stret</code>：直接触发
<code>forwardInvocation:</code></li>
<li><code>objc_allocateClassPair</code>：动态创建类对象和元类对象</li>
<li><code>objc_registerClassPair</code>：注册类对象和元类对象</li>
<li><code>object_setClass</code>：设置 <code>isa</code> 指针指向。</li>
</ul>
<p>除此之外，Aspects
使用了非常底层的方式实现了闭包的参数检查与匹配，这一块非常值得我们深入学习，后续有机会我们再来研究一下。</p>
<p>最后，向作者表达一下敬意！如果对 Objective-C
底层原理没有如此深刻的理解，一般人是写不出来这样的框架的！</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/steipete/Aspects">Aspects</a></li>
<li><a
href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C
Runtime 消息传递与转发</a></li>
<li><a
href="https://www.mikeash.com/pyblog/friday-qa-2009-03-27-objective-c-message-forwarding.html">Friday
Q&amp;A 2009-03-27: Objective-C Message Forwarding</a></li>
<li><a
href="https://wereadteam.github.io/2016/06/30/Aspects/">面向切面编程之
Aspects 源码解析及应用</a></li>
<li><a
href="https://www.jianshu.com/p/ae5c32708bc6">object_getClass(obj)与[obj
class]的区别</a></li>
<li><a
href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type
Encodings</a></li>
<li><a
href="https://www.jianshu.com/p/a420751e3e93">Aspects关联&amp;调用流程浅析</a></li>
<li><a
href="https://juejin.cn/post/6844903828265893895#heading-6">Aspects源码分析</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>KVO</tag>
        <tag>Aspects</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Linux Ext 文件系统设计原理</title>
    <url>/2022/05/01/understand-principle-of-filesystem/</url>
    <content><![CDATA[<h1 id="硬盘格式化">硬盘格式化</h1>
<p>我们知道，一个硬盘必须要经过格式化之后才能使用。那么，格式化到底做了什么呢？</p>
<span id="more"></span>
<p>本质上，硬盘格式化可以分为两个步骤，分别是：</p>
<ul>
<li><strong>低级格式化</strong>，或称 <strong>物理格式化</strong>。</li>
<li><strong>高级格式化</strong>，或称 <strong>逻辑格式化</strong>。</li>
</ul>
<h2 id="低级格式化">低级格式化</h2>
<p>在 <a
href="http://chuquan.me/2019/04/05/linux-disk-introduce/">《计算机那些事(1)——硬盘》</a>
一文中，我们介绍了硬盘的两种寻址方式，分别是：</p>
<ul>
<li><strong>CHS
寻址方式</strong>：由柱面数（Cylinders）、磁头数（Headers）、扇区数（Sectors）组成
3D 参数，简称 CHS 寻址方式，硬盘容量相对较小。如传统的机械硬盘（Hard
Disk Drive，HDD）。</li>
<li><strong>LBA
寻址方式</strong>：线性寻址，以逻辑区块为单位进行寻址，全称为 Logic
Block Address（即扇区的逻辑块地址），硬盘容量相对较大。如固态硬盘（Solid
State Disk，SSD）</li>
</ul>
<p>对于 CHS
硬盘，低级格式化会对硬盘进行划分柱面、磁道、扇区的操作，也称为
<strong>扇区初始化</strong>。一般由硬盘制造商进行低级格式化。</p>
<p>对于 LBA 硬盘，并不存在低级格式化，因为 LBA
寻址的硬盘使用集成电路替代物理旋转磁盘，主要由主控和闪存芯片组成。</p>
<p>低级格式化完成后，硬盘控制器即可使用格式化的结果。</p>
<h2 id="高级格式化">高级格式化</h2>
<p>相对而言，低级格式化是在硬件层面进行初始化，而高级格式化则是在软件层面进行初始化。</p>
<p>高级格式化一般会有两个步骤：</p>
<ul>
<li><strong>硬盘分区初始化</strong>：在硬盘的特定区域写入特定的数据，即重写分区表。关于硬盘分区的细节，可以阅读
<a
href="http://chuquan.me/2019/04/05/linux-disk-introduce/">《计算机那些事(1)——硬盘》</a>。</li>
<li><strong>文件系统初始化</strong>：根据用户选定的文件系统（如：FAT、NTFS、EXT2、EXT3
等），在特定分区中规划一系列表结构进行逻辑区块管理等。</li>
</ul>
<p>通常，一个硬盘可以被划分为多个分区。传统的硬盘，每个分区只能初始化一种文件系统。现代的
LVM 与 RAID
技术则能够支持将一个分区格式化为多个文件系统，也支持将多个分区合并成一个文件系统。</p>
<h2 id="软硬件映射">软硬件映射</h2>
<p>在硬件层面，对于 CHS 硬盘，最小的物理存储单元是扇区，大小为 512
byte；对于 LBA 硬盘，最小的物理存储单元是闪存（本质是晶体管），大小为 1
bit。</p>
<p>在软件层面，为了与操作系统的页大小对齐，文件系统定义的逻辑区块大小一般为
1K、2K 或 4K。</p>
<p>下图所示，为文件系统逻辑区块与硬盘物理区块之间的映射关系。对于 CHS
硬盘，一个逻辑区块所对应的物理区块可能由多个扇区组成。对于 LBA
硬盘，一个逻辑区块则对应一片集成电路存储单元。</p>
<p>在通信时，首先由文件系统的 I/O
管理器将逻辑区块转换成物理区块地址，然后由硬盘控制器根据物理区块（扇区）地址，进行数据读写。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-map.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="文件系统类型">文件系统类型</h1>
<p>常见的文件系统类型非常多，比如：</p>
<ul>
<li>CentOS 5/6 默认使用 ext2/ext3/ext4</li>
<li>CentOS 7 默认使用 xfs</li>
<li>Windows 默认使用 NTFS</li>
<li>MacOS、iOS、watchOS 默认使用 APFS（曾经使用 HFS）</li>
</ul>
<p>虽然文件系统的种类很多，但是它们的底层实现大同小异。本文，我们来聊一聊
Linux 系统下的默认文件系统——Ext
文件系统族，举一反三，从而来理解文件系统的底层设计。</p>
<h1 id="文件系统结构">文件系统结构</h1>
<p>以 Linux 经典的 Ext2 文件系统进行分析，其整体结构如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-01.png?x-oss-process=image/resize,w_800" /></p>
<p>从宏观角度来看，文件系统将硬盘分为两部分：</p>
<ul>
<li><strong>引导区块（Boot Block）</strong></li>
<li><strong>区块组（Block Groups）</strong></li>
</ul>
<h2 id="boot-block">Boot Block</h2>
<p>引导区块是分区的第一个区块，当然，并不是所有分区都有引导区块，只有安装了操作系统的主分区和逻辑分区才有引导区块。</p>
<p>引导区块存储了 Boot Loader，当系统加电启动时，Boot Loader
会被引导装载并执行，从而最终启动操作系统。</p>
<h2 id="block-groups">Block Groups</h2>
<p>文件系统的另一主要组成是区块组，ext2
文件系统包含多个区块组，那么为什么要划分那么多区块组呢？事实上，如果直接管理逻辑区块，逻辑区块的数量是非常庞大的，难以管理，因此为了简化，划分出了区块组，从而进行分级管理。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-02.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，区块组内部又可以分成多个部分，分别是：</p>
<ul>
<li><strong>超级区块（Super Block）</strong></li>
<li><strong>组描述符表（Group Descriptor Table，GDT）</strong></li>
<li><strong>区块位图（Block Bitmap）</strong></li>
<li><strong>索引节点位图（Inode Bitmap）</strong></li>
<li><strong>索引节点表（Inode Table）</strong></li>
<li><strong>数据区块（Data Blocks）</strong></li>
</ul>
<blockquote>
<p>注意<br />
<strong>区块组的 “区块”
对应的文件系统的逻辑区块。区块组中的各个组成部分都使用 “区块”
作为载体进行存储</strong>。</p>
</blockquote>
<p>下面，我们将分别介绍区块组的各个组成部分。</p>
<h1 id="block-inode">Block &amp; Inode</h1>
<p>在介绍区块组的各个组成部分之前，我们先来了解一下 Block 和 Inode。</p>
<h2 id="block">Block</h2>
<p>Block 主要用于 <strong>存储文件的内容数据</strong>。不同大小的 Block
使得文件系统能够支持的最大容量和最大单一文件大小各不相同，其限制如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Block size</th>
<th style="text-align: left;">1KB</th>
<th style="text-align: left;">2KB</th>
<th style="text-align: left;">4KB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">最大单一文件限制</td>
<td style="text-align: left;">16GB</td>
<td style="text-align: left;">256GB</td>
<td style="text-align: left;">2TB</td>
</tr>
<tr class="even">
<td style="text-align: left;">最大文件系统容量</td>
<td style="text-align: left;">2TB</td>
<td style="text-align: left;">8TB</td>
<td style="text-align: left;">16TB</td>
</tr>
</tbody>
</table>
<p>Block 有一些基本限制，如下：</p>
<ul>
<li>Block 的大小和数量在格式化后无法改变。</li>
<li>一个 Block 只能存放一个文件的数据。</li>
<li>如果文件大于 Block 的大小，则一个文件会占用多个 Block。</li>
<li>如果文件小于 Block 的大小，则 Block
中多余的容量将无法再被使用。</li>
</ul>
<h2 id="inode">Inode</h2>
<p>上述，我们提到了一个大文件会占用多个
Block，那么，文件系统是如何判断哪些 Block
是属于同一个文件的呢？答案就是索引节点（index node，inode）。</p>
<p>Inode 主要用于
<strong>存储文件的属性元数据</strong>，其记录的信息包括：</p>
<ul>
<li>文件的类型</li>
<li>文件的权限：read/write/execute</li>
<li>文件的拥有者：owner</li>
<li>文件的群组：group</li>
<li>文件的容量</li>
<li>文件的创建时间：ctime</li>
<li>文件的最近读取时间：atime</li>
<li>文件的最近修改时间：mtime</li>
<li>文件的内容指针：<strong>即指向属于文件的 Block 的指针</strong></li>
<li>...</li>
</ul>
<blockquote>
<p>注意<br />
Inode 并不包含文件名，文件名则存储在 <strong>目录项</strong>
中，详细信息可见下文。</p>
</blockquote>
<p>根据 inode 中存储的文件内容指针，文件系统就能找到哪些 Block
是属于该文件的。</p>
<p>在高级格式化时，inode 的数量和大小就已经固定下来了，其大小一般为 128
byte 或 256 byte。同样，inode 也有一些基本限制，如下：</p>
<ul>
<li>一个文件只会占用一个 inode。</li>
<li>文件系统支持的最大文件数量与 inode 的相关。</li>
<li>文件系统读取文件时，判断对应 inode
的权限与使用者是否符合，如果符合才能读取 Block 的数据。</li>
</ul>
<p>如下所示为 ext2 中 inode 的数据结构定义。<strong>注意，inode
的定义并没有 inode id，那么这种情况下如何索引 inode
呢</strong>？关于这个问题，我们在 Inode Table 一节进行解释。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* linux/fs/ext2/ext2.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">	__le16	i_mode;		            <span class="comment">/* File mode */</span></span><br><span class="line">	__le16	i_uid;	            	<span class="comment">/* Low 16 bits of Owner Uid */</span></span><br><span class="line">	__le32	i_size;		            <span class="comment">/* Size in bytes */</span></span><br><span class="line">	__le32	i_atime;	            <span class="comment">/* Access time */</span></span><br><span class="line">	__le32	i_ctime;	            <span class="comment">/* Creation time */</span></span><br><span class="line">	__le32	i_mtime;	            <span class="comment">/* Modification time */</span></span><br><span class="line">	__le32	i_dtime;	            <span class="comment">/* Deletion Time */</span></span><br><span class="line">	__le16	i_gid;		            <span class="comment">/* Low 16 bits of Group Id */</span></span><br><span class="line">	__le16	i_links_count;	        <span class="comment">/* Links count */</span></span><br><span class="line">	__le32	i_blocks;	            <span class="comment">/* Blocks count */</span></span><br><span class="line">	__le32	i_flags;	            <span class="comment">/* File flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le32  l_i_reserved1;</span><br><span class="line">		&#125; linux1;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le32  h_i_translator;</span><br><span class="line">		&#125; hurd1;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le32  m_i_reserved1;</span><br><span class="line">		&#125; masix1;</span><br><span class="line">	&#125; osd1;				            <span class="comment">/* OS dependent 1 */</span></span><br><span class="line">	__le32	i_block[EXT2_N_BLOCKS]; <span class="comment">/* Pointers to blocks */</span></span><br><span class="line">	__le32	i_generation;	        <span class="comment">/* File version (for NFS) */</span></span><br><span class="line">	__le32	i_file_acl;	            <span class="comment">/* File ACL */</span></span><br><span class="line">	__le32	i_dir_acl;	            <span class="comment">/* Directory ACL */</span></span><br><span class="line">	__le32	i_faddr;	            <span class="comment">/* Fragment address */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8	l_i_frag;	    <span class="comment">/* Fragment number */</span></span><br><span class="line">			__u8	l_i_fsize;	    <span class="comment">/* Fragment size */</span></span><br><span class="line">			__u16	i_pad1;</span><br><span class="line">			__le16	l_i_uid_high;	<span class="comment">/* these 2 fields    */</span></span><br><span class="line">			__le16	l_i_gid_high;	<span class="comment">/* were reserved2[0] */</span></span><br><span class="line">			__u32	l_i_reserved2;</span><br><span class="line">		&#125; linux2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8	h_i_frag;	    <span class="comment">/* Fragment number */</span></span><br><span class="line">			__u8	h_i_fsize;	    <span class="comment">/* Fragment size */</span></span><br><span class="line">			__le16	h_i_mode_high;</span><br><span class="line">			__le16	h_i_uid_high;</span><br><span class="line">			__le16	h_i_gid_high;</span><br><span class="line">			__le32	h_i_author;</span><br><span class="line">		&#125; hurd2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8	m_i_frag;	    <span class="comment">/* Fragment number */</span></span><br><span class="line">			__u8	m_i_fsize;	    <span class="comment">/* Fragment size */</span></span><br><span class="line">			__u16	m_pad1;</span><br><span class="line">			__u32	m_i_reserved2[<span class="number">2</span>];</span><br><span class="line">		&#125; masix2;</span><br><span class="line">	&#125; osd2;				            <span class="comment">/* OS dependent 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件系统预留-inode">文件系统预留 Inode</h3>
<p>Ext 文件系统预留了一部分 Inode 作为特殊用途，如下所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Inode</th>
<th style="text-align: left;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">不存在，可用于标识目录的 Data Block
中已删除的文件</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td
style="text-align: left;">虚拟文件系统，如：<code>/proc</code>、<code>/sys</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">根目录</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">ACL 索引</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">ACL 数据</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">Boot Loader</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">未删除的目录</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">预留的区块组描述符 Inode</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">日志 Inode</td>
</tr>
<tr class="even">
<td style="text-align: left;">11</td>
<td style="text-align: left;">第一个非预留的 Inode，通常是
<code>lost+fount</code> 目录</td>
</tr>
</tbody>
</table>
<h1 id="区块组结构">区块组结构</h1>
<h2 id="data-blocks">Data Blocks</h2>
<p>Data Blocks 包含了区块组中剩余的所有 Block。Block
的数量在高级格式化完成后就已经确定下来了。</p>
<h2 id="block-bitmap">Block Bitmap</h2>
<p>Block Bitmap 用于标识区块组中所有的 Block 的使用状态，其使用 1 bit
来表示：0 表示空闲，1 表示占用。</p>
<p>区块组使用一个 Block 存储 Block Bitmap。如果 Block 的大小为
4K，那么其总共有 4 x 1024 x 8 = 32768 个比特位，可用于描述可使用的
Block。</p>
<p>注意，Block Bitmap 只在写数据时使用，因为只有写数据才需要找到空闲的
Block。</p>
<h2 id="inode-table">Inode Table</h2>
<p>Inode Table 包含了区块组中所有的 Inode。Inode
的数量在高级格式化完成后就已经确定下来了。</p>
<p>如果 Block 的大小为 4K 且 inode 的大小为 256 byte，那么一个 Block
可以存储 4 x 1024 / 256 = 16 个 inode。区块组中的 Inode Table
通过占用了多个连续的 Block，在逻辑上形成一张表记录了所有
inode，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-03.png?x-oss-process=image/resize,w_800" /></p>
<p>根据上述原理，当给定一个 inode id 时，我们只需要结合 inode
数据结构的大小，在这个 Inode Table 中查找到对应项即可找到对应的
inode。这也就解释了为什么 inode 没有 inode id 也能找到 inode
的原因。</p>
<h2 id="inode-bitmap">Inode Bitmap</h2>
<p>Inode Bitmap 用于标识区块组中所有的 inode 的使用状态，其使用 1 bit
来表示：0 表示空闲，1 表示占用。</p>
<p>区块组使用一个 Block 存储 Inode Bitmap。如果 Block 的大小为
4K，那么其总共有 4 x 1024 x 8 = 32768 个比特位，可用于描述可使用的
inode。</p>
<h2 id="group-descriptor-table">Group Descriptor Table</h2>
<p>区块组使用组描述符来记录区块组的信息和属性元信息，如：Block
Bitmap、Inode Bitmap、Inode Table 等。如下所示为 ext2
中组描述符的数据结构定义。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* linux/fs/ext2/ext2.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_group_desc</span> &#123;</span></span><br><span class="line">	__le32	bg_block_bitmap;		<span class="comment">/* Blocks bitmap block */</span></span><br><span class="line">	__le32	bg_inode_bitmap;		<span class="comment">/* Inodes bitmap block */</span></span><br><span class="line">	__le32	bg_inode_table;		    <span class="comment">/* Inodes table block */</span></span><br><span class="line">	__le16	bg_free_blocks_count;	<span class="comment">/* Free blocks count */</span></span><br><span class="line">	__le16	bg_free_inodes_count;	<span class="comment">/* Free inodes count */</span></span><br><span class="line">	__le16	bg_used_dirs_count;	    <span class="comment">/* Directories count */</span></span><br><span class="line">	__le16	bg_pad;</span><br><span class="line">	__le32	bg_reserved[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>区块组使用连续的 Block
记录了文件系统中所有区块组的组描述符，从而在逻辑上形成一张表，即 Group
Descriptor Table（简称 GDT），如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-04.png?x-oss-process=image/resize,w_800" /></p>
<p>这里会有一个疑问，为什么区块组中存储了一个描述整个文件系统区块组的信息？很多区块组都存储了内容重复的
GDT，这样是否会造成存储空间的浪费？其实这么做的原因是为了进行
<strong>备份</strong>，如果只在某片区域存储这部分信息，一旦这片存储区域出现了损坏，那么将导致整个文件系统无法使用并且无法恢复。</p>
<h2 id="super-block">Super Block</h2>
<p>类似于 GDT，Super Block
也是一个描述文件系统整体的数据结构，其存储在区块组中也是为了备份。</p>
<p><strong>Super Block 是文件系统的核心</strong>，其保存了
<strong>文件系统的所有元数据</strong>，比如：</p>
<ul>
<li>Block 和 Inode 的总量</li>
<li>空闲/占用的 Block 和 Inode 的数量</li>
<li>Block 和 Inode 的大小</li>
<li>文件系统的挂载时间</li>
<li>文件系统的最近写入时间</li>
<li>...</li>
</ul>
<p>如下所示为 ext2 中 Super Block 的数据结构定义。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* linux/fs/ext2/ext2.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_super_block</span> &#123;</span></span><br><span class="line">	__le32	s_inodes_count;		                <span class="comment">/* Inodes count */</span></span><br><span class="line">	__le32	s_blocks_count;		                <span class="comment">/* Blocks count */</span></span><br><span class="line">	__le32	s_r_blocks_count;	                <span class="comment">/* Reserved blocks count */</span></span><br><span class="line">	__le32	s_free_blocks_count;	            <span class="comment">/* Free blocks count */</span></span><br><span class="line">	__le32	s_free_inodes_count;	            <span class="comment">/* Free inodes count */</span></span><br><span class="line">	__le32	s_first_data_block;	                <span class="comment">/* First Data Block */</span></span><br><span class="line">	__le32	s_log_block_size;	                <span class="comment">/* Block size */</span></span><br><span class="line">	__le32	s_log_frag_size;	                <span class="comment">/* Fragment size */</span></span><br><span class="line">	__le32	s_blocks_per_group;	                <span class="comment">/* # Blocks per group */</span></span><br><span class="line">	__le32	s_frags_per_group;	                <span class="comment">/* # Fragments per group */</span></span><br><span class="line">	__le32	s_inodes_per_group;	                <span class="comment">/* # Inodes per group */</span></span><br><span class="line">	__le32	s_mtime;		                    <span class="comment">/* Mount time */</span></span><br><span class="line">	__le32	s_wtime;		                    <span class="comment">/* Write time */</span></span><br><span class="line">	__le16	s_mnt_count;		                <span class="comment">/* Mount count */</span></span><br><span class="line">	__le16	s_max_mnt_count;	                <span class="comment">/* Maximal mount count */</span></span><br><span class="line">	__le16	s_magic;		                    <span class="comment">/* Magic signature */</span></span><br><span class="line">	__le16	s_state;		                    <span class="comment">/* File system state */</span></span><br><span class="line">	__le16	s_errors;		                    <span class="comment">/* Behaviour when detecting errors */</span></span><br><span class="line">	__le16	s_minor_rev_level; 	                <span class="comment">/* minor revision level */</span></span><br><span class="line">	__le32	s_lastcheck;		                <span class="comment">/* time of last check */</span></span><br><span class="line">	__le32	s_checkinterval;	                <span class="comment">/* max. time between checks */</span></span><br><span class="line">	__le32	s_creator_os;		                <span class="comment">/* OS */</span></span><br><span class="line">	__le32	s_rev_level;		                <span class="comment">/* Revision level */</span></span><br><span class="line">	__le16	s_def_resuid;		                <span class="comment">/* Default uid for reserved blocks */</span></span><br><span class="line">	__le16	s_def_resgid;		                <span class="comment">/* Default gid for reserved blocks */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These fields are for EXT2_DYNAMIC_REV superblocks only.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: the difference between the compatible feature set and</span></span><br><span class="line"><span class="comment">	 * the incompatible feature set is that if there is a bit set</span></span><br><span class="line"><span class="comment">	 * in the incompatible feature set that the kernel doesn&#x27;t</span></span><br><span class="line"><span class="comment">	 * know about, it should refuse to mount the filesystem.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * e2fsck&#x27;s requirements are more strict; if it doesn&#x27;t know</span></span><br><span class="line"><span class="comment">	 * about a feature in either the compatible or incompatible</span></span><br><span class="line"><span class="comment">	 * feature set, it must abort and not try to meddle with</span></span><br><span class="line"><span class="comment">	 * things it doesn&#x27;t understand...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__le32	s_first_ino; 		                <span class="comment">/* First non-reserved inode */</span></span><br><span class="line">	__le16  s_inode_size; 		                <span class="comment">/* size of inode structure */</span></span><br><span class="line">	__le16	s_block_group_nr; 	                <span class="comment">/* block group # of this superblock */</span></span><br><span class="line">	__le32	s_feature_compat; 	                <span class="comment">/* compatible feature set */</span></span><br><span class="line">	__le32	s_feature_incompat; 	            <span class="comment">/* incompatible feature set */</span></span><br><span class="line">	__le32	s_feature_ro_compat; 	            <span class="comment">/* readonly-compatible feature set */</span></span><br><span class="line">	__u8	s_uuid[<span class="number">16</span>];		                    <span class="comment">/* 128-bit uuid for volume */</span></span><br><span class="line">	<span class="type">char</span>	s_volume_name[<span class="number">16</span>]; 	                <span class="comment">/* volume name */</span></span><br><span class="line">	<span class="type">char</span>	s_last_mounted[<span class="number">64</span>]; 	            <span class="comment">/* directory where last mounted */</span></span><br><span class="line">	__le32	s_algorithm_usage_bitmap;           <span class="comment">/* For compression */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Performance hints.  Directory preallocation should only</span></span><br><span class="line"><span class="comment">	 * happen if the EXT2_COMPAT_PREALLOC flag is on.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u8	s_prealloc_blocks;	                <span class="comment">/* Nr of blocks to try to preallocate*/</span></span><br><span class="line">	__u8	s_prealloc_dir_blocks;	            <span class="comment">/* Nr to preallocate for dirs */</span></span><br><span class="line">	__u16	s_padding1;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u8	s_journal_uuid[<span class="number">16</span>];	                <span class="comment">/* uuid of journal superblock */</span></span><br><span class="line">	__u32	s_journal_inum;		                <span class="comment">/* inode number of journal file */</span></span><br><span class="line">	__u32	s_journal_dev;		                <span class="comment">/* device number of journal file */</span></span><br><span class="line">	__u32	s_last_orphan;		                <span class="comment">/* start of list of inodes to delete */</span></span><br><span class="line">	__u32	s_hash_seed[<span class="number">4</span>];		                <span class="comment">/* HTREE hash seed */</span></span><br><span class="line">	__u8	s_def_hash_version;	                <span class="comment">/* Default hash version to use */</span></span><br><span class="line">	__u8	s_reserved_char_pad;</span><br><span class="line">	__u16	s_reserved_word_pad;</span><br><span class="line">	__le32	s_default_mount_opts;</span><br><span class="line"> 	__le32	s_first_meta_bg; 	                <span class="comment">/* First metablock block group */</span></span><br><span class="line">	__u32	s_reserved[<span class="number">190</span>];	                <span class="comment">/* Padding to the end of the block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="文件存储">文件存储</h1>
<p>在了解了文件系统的底层结构之后，我们再来看看不同类型的文件在文件系统中是如何存储的。</p>
<h2 id="普通文件存储">普通文件存储</h2>
<p>在讨论普通文件存储时，我们可以根据普通文件大小分为两种类型：</p>
<ul>
<li>小文件存储：占用 Block 数量小于 <code>EXT2_N_BLOCKS</code></li>
<li>大文件存储：占用 Block 数量大于 <code>EXT2_N_BLOCKS</code></li>
</ul>
<p>对于小文件存储，其基本原理是：根据 inode 的 <code>i_block[]</code>
数组中保存的 Block 指针（Block 序号），找到对应所有的 Block
即可，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-05.png?x-oss-process=image/resize,w_800" /></p>
<p>对于大文件存储，由于一个 inode 可引用的 Block 数量的上限是
<code>EXT2_N_BLOCKS</code>，因此可以使用 Data Block 存储间接的
inode，从而扩大最终可引用的 Block 数量，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-06.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="目录文件存储">目录文件存储</h2>
<p>目录文件的 <strong>内容数据</strong> 是由一系列
<strong>目录项</strong> 组成。Ext2
文件系统中目录项的数据结构定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linux/include/linux/ext2_fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT2_NAME_LEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux/fs/ext2/ext2.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_dir_entry_2</span> &#123;</span></span><br><span class="line">	__le32	inode;			<span class="comment">/* Inode number */</span></span><br><span class="line">	__le16	rec_len;		<span class="comment">/* Directory entry length */</span></span><br><span class="line">	__u8	name_len;		<span class="comment">/* Name length */</span></span><br><span class="line">	__u8	file_type;</span><br><span class="line">	<span class="type">char</span>	name[];			<span class="comment">/* File name, up to EXT2_NAME_LEN */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个目录项定义了一个文件所对应的 inode
序号、目录项长度、文件名长度、文件类型等。关于文件类型，ext2
定义了以下这些文件类型。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">编码</th>
<th style="text-align: left;">文件类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">Unknown</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">Regular File</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">Director</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">Character Device</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">Block Device</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: left;">Named Pipe</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">Socket</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">Symbolic Link</td>
</tr>
</tbody>
</table>
<p>以一个 <code>test</code> 目录文件为例，其包含以下这些文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -la <span class="built_in">test</span>/</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x  3 baochuquan staff       4096 Apr 24 12:12 .</span><br><span class="line">drwxrwxrwt 13 baochuquan staff       8192 Apr 24 12:12 ..</span><br><span class="line">brw-r--r--  1 baochuquan staff     3,   0 Apr 24 12:12 harddisk</span><br><span class="line">lrwxrwxrwx  1 baochuquan staff         14 Apr 24 12:12 linux -&gt; /usr/src/linux</span><br><span class="line">-rw-r--r--  1 baochuquan staff         13 Apr 24 12:12 sample</span><br><span class="line">drwxr-xr-x  2 baochuquan staff       4096 Apr 24 12:12 sources</span><br></pre></td></tr></table></figure>
<p><code>test</code> 目录文件在文件系统中的 <strong>内容数据</strong>
的存储如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-07.png?x-oss-process=image/resize,w_800" /></p>
<p>这里需要重点注意是 <code>rec_len</code>，<code>rec_len</code> 表示
<strong>从当前目录项的 <code>rec_len</code> 末尾开始，到下一个目录项的
<code>rec_len</code>
末尾结束的偏移量字节数</strong>。当文件系统从目录文件中删除某一个子目录时，比如
<code>deldir</code>
目录，这时候并不会删除对应的目录项，仅仅是修改删除项之前目录项的
<code>rec_len</code> 值，从而使得文件系统在扫描目录内容时，跳过
<code>deldir</code> 目录项。这也是为什么图中 <code>deldir</code>
之前的目录项的 <code>rec_len</code> 为 32。</p>
<h2 id="软链接存储">软链接存储</h2>
<p>软链接，即符号链接，类似于 Windows
操作系统中的快捷方式，它的作用是指向原文件或目录。</p>
<p>软链接一般情况下不占用 Data Block，仅仅通过它对应的 inode
完成信息记录，只有当目标路径占用的字符数超过 60
字节时，文件系统才会分配一个 Data Block 来存储目标路径。</p>
<p>注意，软链接的 Data Block 存储的是
<strong>目标文件名</strong>，比如：<code>nox -&gt; /Users/baochuquan/Develop/nox/nox.sh</code>
中 <code>/Users/baochuquan/Develop/nox/nox.sh</code> 即目标路径。</p>
<h2 id="硬链接存储">硬链接存储</h2>
<p>通过上文，我们知道目录项存储了 inode
序号、文件名等信息。假如，有两个目录项存储了不同的文件名，但它们的 inode
序号却相同，这会是一种什么样的情况呢？事实上，这就是硬链接，即 inode
相同的文件。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-08.png?x-oss-process=image/resize,w_800" /></p>
<p>与编程语言中的引用计数类似，inode 也是用一个字段
<code>i_links_count</code> 来记录其被引用的数量。</p>
<ul>
<li>当创建一个文件的硬链接时，对应的 inode 的链接数会加 1；</li>
<li>当删除一个文件时，如果对应的 inode 的链接数大于 1
时，则仅仅对链接数进行减 1 操作；如果对应的 inode 的链接数等于 1
时，则会删除 inode 中的 Block 指针。</li>
</ul>
<h3 id="目录的硬链接数量">目录的硬链接数量</h3>
<p>在创建目录的同时，文件系统会为它创建两个目录：<code>.</code> 和
<code>..</code>，分别对应当前目录的硬链接、上级目录的硬链接。因此，每一个目录都会包含这两个硬链接，它包含了两个信息：</p>
<ul>
<li>一个不包含子目录的目录文件，其硬链接数量为 2。其一是目录本身，即目录
Data Block 中的 <code>.</code>；其二是父级目录 Data Block
中该目录的目录项。</li>
<li>一个包含子目录的目录文件，其硬链接数量为 2 +
子目录数。因为每一个子目录都关联一个父级目录的硬链接
<code>..</code>。</li>
</ul>
<p>文件系统会自动为目录创建硬链接，该权限未对用户开放，用户无法对目录创建硬链接。因此，硬链接只能对文件创建。</p>
<h1 id="文件操作">文件操作</h1>
<h2 id="文件读取">文件读取</h2>
<p>关于文件读取，可以分为两个部分：首先，找到父级目录中关于目标文件的元信息；然后，根据目标文件的元信息找到目标文件的内容数据。整体可以分为如下几个步骤：</p>
<ul>
<li>step 1：根据 Super Block 和 GDT 找到目标文件的父级目录的区块组</li>
<li>step 2：根据区块组描述符找到区块组中的 Inode Table</li>
<li>step 3：根据 Inode 序号，从 Inode Table 中找到父级目录的 Inode</li>
<li>step 4：根据 Inode 找到父级目录 Data Block</li>
<li>step 5：遍历父级目录的 Data Block
中的目录项，找到与目标文件名匹配的目录项</li>
<li>step 6：根据目录项中的 Inode 序号，找到目标文件的 Data Block</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-09.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们以 <code>cat /var/log/message</code>
命令为例，来介绍一下其具体过程。</p>
<p>文件系统在查找 <code>/var/log/message</code> 时，会将它转换成 4
个类似的步骤，逐步完成。这 4 个阶段分别是：</p>
<ul>
<li>查找根目录 <code>/</code></li>
<li>查找 <code>/</code> 目录下的 <code>var</code> 子目录</li>
<li>查找 <code>/var</code> 目录下的 <code>log</code> 子目录</li>
<li>查找 <code>/var/log</code> 目录下的 <code>message</code> 文件</li>
</ul>
<p>在详细介绍这 4 个阶段之前，我们需要知道一个前提：在操作系统启动后，
操作系统会挂载根文件系统，此时 Super Block 和 GDT
会被加载至内存之中。</p>
<h3 id="查找根目录">查找根目录</h3>
<p>上文，我们提到文件系统预留了一些 inode 序号，其中根目录
<code>/</code> 的 inode 序号为 2。因此，可以根据 Super Block
的参数定位到 inode 所在的区块组，结合 GDT
获取到区块组的元信息，即区块描述符。</p>
<p>根据区块描述符，找到对应的 Inode Table，从而定位到具体的
inode，并根据 <code>i_blocks[]</code> 数组，找到对应的 Data Block。</p>
<p>此时，我们获取到了根目录 <code>/</code> 的所有信息。</p>
<h3 id="查找-var-目录">查找 <code>var</code> 目录</h3>
<p>获取到了根目录 <code>/</code> 的 Data Block
之后，我们可以遍历其中的目录项 <code>dir entry</code>，找到文件名与
<code>var</code> 匹配的目录项。根据目录项中的 inode 序号，结合 Super
Block 和 GDT，依次定位到区块组、Inode Table、Inode、Data Block。</p>
<p>此时，我们获取到了 <code>/var</code> 目录的所有信息。</p>
<h3 id="查找-log-目录">查找 <code>log</code> 目录</h3>
<p>获取到了 <code>/var</code> 目录的 Data Block
之后，我们可以遍历其中的目录项，找到文件名与 <code>log</code>
匹配的目录项。根据目录项中的 inode 序号，结合 Super Block 和 GDT，与查找
<code>var</code> 目录一样，也能够定位到区块组、Inode Table、Inode、Data
Block。</p>
<p>此时，我们获取到了 <code>/var/log</code> 目录的所有信息。</p>
<h3 id="查找-message-文件">查找 <code>message</code> 文件</h3>
<p>获取到了 <code>/var/log</code> 目录的 Data Block
之后，我们可以遍历其中的目录项，找到文件名与 <code>message</code>
匹配的目录项。根据目录项中的 inode 序号，结合 Super Block 和
GDT，我们最终就能找到文件内存数据所存放的一组 Data Block 中。</p>
<h2 id="文件删除">文件删除</h2>
<p>关于文件的删除，我们分别介绍一下 <strong>普通文件</strong> 和
<strong>目录文件</strong> 的删除操作。</p>
<h3 id="普通文件删除">普通文件删除</h3>
<p>对于普通文件删除，其大致可分为以下几个步骤：</p>
<ul>
<li>step 1：找到目标文件 Inode 和 Data Block</li>
<li>step 2：将 Inode Table 中对应 Inode 中的 Data Block 指针删除（位于
<code>i_blocks[]</code> 中）</li>
<li>step 3：在 Inode Bitmap 中，将对应 Inode 标记为未使用</li>
<li>step 4：找到目标文件的父级目录的 Data
Block，将与目标文件匹配的目录项删除。具体做法是：
<ul>
<li>修改对应目录项的 inode 序号设置为 0</li>
<li>修改前一个目录项的
<code>rec_len</code>，使文件系统在扫描时能够跳过被删除的目录项</li>
</ul></li>
<li>step 5：在 Block Bitmap 中，将对应的 Block 标记为未使用</li>
</ul>
<h3 id="目录文件删除">目录文件删除</h3>
<p>对于目录文件删除，其大致可分为以下几个步骤：</p>
<ul>
<li>step 1：找到目录及其目录下的所有文件、子目录、子文件的 Inode 和 Data
Block</li>
<li>step 2：在 Inode Bitmap 中，将所有对应的 Inode 标记为未使用</li>
<li>step 3：在 Block Bitmap 中，将所有对应的 Block 标记为未使用</li>
<li>step 4：找到目标目录的父级目录的 Data
Block，将与目标目录匹配的目录项删除。</li>
</ul>
<p>相比而言，目录文件删除时，需要将子目录和子文件全部删除。</p>
<h2 id="文件重命名">文件重命名</h2>
<p>关于文件的重命名，我们分别介绍一下 <strong>同目录内</strong> 和
<strong>非同目录内</strong> 的重命名操作。</p>
<h3 id="同目录内重命名">同目录内重命名</h3>
<p>同目录内重命名，其仅仅是找到目录的 Data Block
中对应的目录项，并将原始文件名修改为目标文件名。</p>
<h3 id="非同目录内重命名">非同目录内重命名</h3>
<p>非同目录内重命名，本质上就是文件移动操作。具体细节，见下一节。</p>
<h2 id="文件移动">文件移动</h2>
<p>文件移动，可分两种情况讨论，分别是
<strong>目标路径下有同名文件</strong> 和
<strong>目标路径下无同名文件</strong>。</p>
<p>假设，我们要将执行 <code>mv /origin/file /target/file</code>
操作。</p>
<p>如果目标路径下有同名文件，文件移动操作可以分为两部分：</p>
<ul>
<li>找到 <code>/origin</code> 目录的 Data Block，将 <code>file</code>
文件的目录项删除。</li>
<li>找到 <code>/target</code> 目录的 Data Block，将同名文件
<code>file</code> 的目录项的 inode 序号修改为新的 inode 序号。</li>
</ul>
<p>如果目标路径下无同名文件，文件移动操作也可以分为两部分：</p>
<ul>
<li>找到 <code>/origin</code> 目录的 Data Block，将 <code>file</code>
文件的目录项删除。</li>
<li>找到 <code>/target</code> 目录的 Data Block，新增一个
<code>file</code> 文件的目录项。</li>
</ul>
<p>文件移动本质上就是修改了文件的目录项中 Inode
的指针或新增目录项，因此速度非常快。</p>
<h1 id="多文件系统">多文件系统</h1>
<p>上文所有的内容的前提都是在一个文件系统内完成的，下面，我们在来讨论一下多文件系统的相关内容。</p>
<h2 id="根文件系统">根文件系统</h2>
<p>任何一个文件系统要在 Linux
中正常使用，必须挂载到一个以挂载的文件系统的某个目录下。</p>
<p>类似于一棵多叉树，操作系统也会有一个根文件系统。根文件系统下某个目录如果挂载了某个文件系统，该目录节点被称为
<strong>一级挂载点</strong>；如果这个挂载的文件系统下的某个目录又挂载了某个文件系统，该目录节点被称为
<strong>二级挂载点</strong>。以此类推。</p>
<p>举个例子，如果 <code>/dev/sdb1</code> 挂载至根文件系统的
<code>/mydata</code> 目录下，那么 <code>/mydata</code> 就是
<strong>一级挂载点</strong>；如果 <code>/dev/cdrom</code> 又挂载至
<code>/dev/sdb1</code> 文件系统的 <code>/mydata/cdrom</code>
目录下，那么 <code>/mydata/cdrom</code> 就是
<strong>二级挂载点</strong>。</p>
<h2 id="文件系统挂载">文件系统挂载</h2>
<p>关于文件系统挂载，我们以 <code>mount /dev/cdrom /mnt</code>
为例，进行介绍。</p>
<p>在文件系统 <code>/dev/cdrom</code> 挂载至挂载点 <code>/mnt</code>
之前，<code>/mnt</code> 是根文件系统的一个目录，其父级目录
<code>/</code> 的 Data Block 中存储了 <code>/mnt</code>
文件对应的目录项，其中包含了文件元信息，如：Inode 序号、文件名等。</p>
<p>当文件系统 <code>/dev/cdrom</code> 挂载至挂载点 <code>/mnt</code>
之后，<code>/mnt</code>
变成了另一个文件系统的入口。对于挂载，操作系统具体做了以下这些内容。</p>
<ul>
<li>在根文件系统的 Inode Table 中，新增一个 Inode 指向文件系统
<code>/dev/cdrom</code> 中的 Data Block。</li>
<li>找到根文件系统的 <code>/</code> 目录的 Data Block，将
<code>/mnt</code> 对应的目录项的 Inode 序号修改为新增的 Inode
序号。</li>
<li>在根文件系统的 Inode Table 中，将原始的 <code>/mnt</code> 的 Inode
标记为暂不可用。</li>
</ul>
<p>如下所示，为文件系统挂载操作的示意图。<strong>文件系统挂载完成后，挂载点的元数据和内容数据分别存储在不同的文件系统中</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/filesystem-arch-10.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="文件系统卸载">文件系统卸载</h2>
<p>关于文件系统卸载，其本质就是挂载的还原操作，它会移除新增的
Inode，并将指针指向原来的 Data Block。同时挂载点所对应的目录项的 Inode
指针也会恢复原来的设置。</p>
<h1 id="总结">总结</h1>
<p>本文，我们通过 Linux 的 Ext
文件系统，介绍了经典文件系统的底层设计原理。由于各种文件系统的设计其实大同小异，通过本文我们能够举一反三，了解文件系统的设计。</p>
<p>文件系统的很多细节设计都采用了分层设计的思想，比如：采用区块组分层管理底层数据，采用
Inode 和 Block 分别管理元数据和内容数据等。</p>
<p>此外，文件系统的目录项设计也是能够极大提升性能的，很多文件操作仅仅通过操作目录项就可以实现最终的目的。</p>
<p>后续，我们再来探讨一下具体文件系统的上层——虚拟文件系统的实现。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/torvalds/linux">linux</a></li>
<li><a href="https://en.wikipedia.org/wiki/Disk_formatting">Disk
formatting</a></li>
<li><a
href="https://github.com/torvalds/linux/blob/master/Documentation/filesystems/vfs.rst">Overview
of the Linux Virtual File System</a></li>
<li>《Linux 内核设计与实现》</li>
<li>《深入 Linux 内核架构》</li>
<li><a
href="https://www.jianshu.com/p/dde6a01c4094">5分钟让你明白“软链接”和“硬链接”的区别</a></li>
<li>《鸟哥的 Linux 私房菜：基础学习篇》</li>
<li><a href="https://tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html">A
tour of the Linux VFS</a></li>
<li><a href="https://www.zhihu.com/question/22479338">SSD
固态硬盘是分区好还是不分区好？</a></li>
<li><a
href="https://www.cnblogs.com/f-ck-need-u/p/7016077.html#auto_id_4">第4章
ext文件系统机制原理剖析</a></li>
<li>《UNIX 环境高级编程》</li>
</ol>
]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>Ext</tag>
        <tag>Inode</tag>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Git 底层实现原理</title>
    <url>/2022/05/21/understand-principle-of-git/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-01.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>一直以来，关于 Git
的底层原理其实是一知半解的。直到最近，在理解了文件系统的设计原理，并阅读了
Linus Torvalds 的第一版 Git 源码之后，终于彻底搞明白了 Git
的设计哲学。</p>
<p>借此机会，总结一下自己对于 Git 底层原理的理解。当然，关于 Git
的学习，《Pro
Git》仍然是最权威的参考书籍。本文只不过是在此基础上，梳理了一下笔者自己的理解，希望能够达到深入浅出的效果。</p>
<p>注：Git
本质上是一个内容寻址的文件系统，如果你希望有一个更加深入的理解，建议先阅读
<a
href="http://chuquan.me/2022/05/01/understand-principle-of-filesystem/">《深入理解
Linux Ext 文件系统设计原理》</a>。</p>
<h1 id="起源">起源</h1>
<p>从 Linux
诞生以来，它就有着为数众多的参与者，在很长一段时间里，绝大多数的 Linux
内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991-2002年期间）。直到
2002 年，整个开源项目组开始启用一个专有的分布式版本控制系统 BitKeeper
来管理和维护代码。</p>
<p>2005 年，一位社区开发者反编译 BitKeeper 并利用了其未公开的接口，导致
BitKeeper 回收了 Linux 内核社区关于 BitKeeper 的使用许可。对此，Linus
Torvalds 利用假期时间开发了一款全新的分布式版本控制工具——Git。</p>
<h1 id="整体架构">整体架构</h1>
<p>下图所示为 Git 的整体架构示意图，其主要包含三大部分：</p>
<ul>
<li><strong>上层命令</strong>（Porcelain Commands）</li>
<li><strong>底层命令</strong>（Plumbing Commands）</li>
<li><strong>对象数据库</strong>（Object Database）</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-02.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="上层命令">上层命令</h2>
<p>在日常开发中，我们所使用的
Git命令基本上都是上层命令，如：<code>commit</code>、<code>add</code>、<code>checkout</code>、<code>branch</code>、<code>remote</code>
等。上层命令通过组合底层命令或直接操作底层数据对象，使 Git
底层实现细节对用户透明，从而为用户提供了一系列简单易用的命令集合。</p>
<h2 id="底层命令">底层命令</h2>
<p>在日常开发中，我们基本接触不到 Git
的底层命令，如果要想使用这些底层命令，我们必须要对 Git
的设计原理有一定的认知。Linus Torvalds 的第一版
Git，其实就是实现了几个核心的底层命令，如：<code>update-cache</code>、<code>write-tree</code>、<code>read-tree</code>、<code>commit-tree</code>、<code>cat-file</code>、<code>show-diff</code>
等。注意，在底层命令的命名上，我们当前版本与最初版本存在细微的差异，下表是几个核心底层命令的简单对照。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">当前版本</th>
<th style="text-align: left;">原始版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>git update-index</code></td>
<td style="text-align: left;"><code>update-cache</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>git write-tree</code></td>
<td style="text-align: left;"><code>write-tree</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>git read-tree</code></td>
<td style="text-align: left;"><code>read-tree</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>git commit-tree</code></td>
<td style="text-align: left;"><code>commit-tree</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>git cat-file</code></td>
<td style="text-align: left;"><code>cat-file</code></td>
</tr>
</tbody>
</table>
<h2 id="对象数据库">对象数据库</h2>
<p>Git <strong>最核心、最底层</strong> 的部分则是其所实现的一套
<strong>对象数据库</strong>（Object Database），其本质是一个基于
Key-Value 的内容寻址文件系统（Content-addressable File
System）。笔者认为其设计理念与传统的文件系统的设计理念极其相似，为了方便理解和对照，因此在下文中，我们将以
<strong>Git 文件系统</strong> 作为简称。</p>
<p>Git
文件系统中存储了所有文件的所有历史快照，通过索引不同的历史快照，Git
才能够实现版本控制。下面，我们来介绍一下 Git 文件系统。</p>
<h1 id="git-文件系统-vs-ext-文件系统">Git 文件系统 vs Ext 文件系统</h1>
<p>为了便于理解，我们使用 Linux Ext 文件系统与 Git
文件系统进行对比。</p>
<h2 id="存储方式">存储方式</h2>
<p>在 Ext 文件系统中，<strong>使用 Block 存储所有类型的内容</strong>；在
Git 文件系统中，<strong>使用 Object 存储所有类型的内容</strong>，也称为
Git 对象，不同类型的 Object 共同构成了一整套对象模型。</p>
<p>对于普通类型文件，Ext 文件系统 <strong>使用一个或多个 Block
存储文件内容</strong>；Git 文件系统 <strong>使用一个 Blob
Object（二进制对象）存储文件内容</strong>。</p>
<p>对于目录类型文件，Ext 文件系统 <strong>使用一个 Block
存储一系列目录项（dir
entry），每个目录项存储一个普通文件或目录文件的元数据</strong>；Git
文件系统 <strong>使用一个 Tree
Object（树对象）存储一系列树对象记录（tree
entry），每个树对象记录存储一个 Blob Object（对应一个普通文件）或一个
Tree Object（对应一个目录文件）的元数据</strong>。</p>
<p>下图所示，为两种文件系统关于目录和文件的组织方式的对比示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="索引方式">索引方式</h2>
<p>上图中，我们使用 “index”
简单地表示了文件的索引过程。事实上，文件系统的索引方式也是经过特殊设计的。</p>
<p>在 Ext 文件系统中，<strong>使用一个 Inode
记录一个文件或目录存储内容时占用的所有 Block
的序号</strong>，最终通过硬盘控制器进行索引；在 Git
文件系统中，<strong>使用一个 40 位的 SHA-1
值作为一个文件或目录存储内容时所占用的一个 Object
文件的唯一标识符</strong>，最终在 <code>.git/objects/</code>
目录下进行匹配查找，其中前 2 位 SHA-1 值作为存储子目录，后 38 位 SHA-1
值作为文件名。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-04.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="对象模型">对象模型</h1>
<p>通过对比 Git 文件系统和 Ext 文件系统，我们基本了解了 Git
是如何存储和索引文件及目录的。接下来，我们来深入了解 Git
的对象模型，即数据存储的基本单元及类型。</p>
<p>Git 对象模型主要包括以下 4 种对象</p>
<ul>
<li><strong>二进制对象（Blob Object）</strong></li>
<li><strong>树对象（Tree Object）</strong></li>
<li><strong>提交对象（Commit Object）</strong></li>
<li><strong>标签对象（Tag Object）</strong></li>
</ul>
<p><strong>所有对象均存储在 <code>.git/objects/</code>
目录下，并采用相同格式进行表示，其可以分为两部分</strong>：</p>
<ul>
<li>头部信息：<strong>类型 + 空格 + 内容字节数 + \0</strong></li>
<li>存储内容</li>
</ul>
<p><strong>Git 使用两部分内容的 40 位 SHA-1 值（前 2 为作为子目录，后 38
位作为文件名）作为快照文件的唯一标识，并对它们进行 zlib
压缩，然后将压缩后的结果作为快照文件的实际内容进行存储。</strong></p>
<p>下面，我们来主要介绍一下其中前三种对象类型。</p>
<h2 id="blob-object">Blob Object</h2>
<p>Block Object 用于存储普通文件的内容数据，其头部信息为 <strong>"blob"
+ 空格 + 内容字节数 + \0</strong>，存储内容为对应文件的内容快照。</p>
<p>下面，我们使用底层命令 <code>git cat-file</code> 来查看 <a
href="https://github.com/baochuquan/analyze-git">analyze-git</a>
仓库的一个 Blob Object 的存储内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看对象的类型</span></span><br><span class="line">$ git cat-file -t fa49b077972391ad58037050f2a75f74e3671e92</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看对象的内容长度</span></span><br><span class="line">$ git cat-file -s fa49b077972391ad58037050f2a75f74e3671e92</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看对象的内容</span></span><br><span class="line">$ git cat-file -p fa49b077972391ad58037050f2a75f74e3671e92</span><br><span class="line">new file</span><br></pre></td></tr></table></figure>
<h2 id="tree-object">Tree Object</h2>
<p>Tree Object 用于存储目录文件的内容数据，其头部信息为 <strong>"tree" +
空格 + 内容字节数 + \0</strong>，存储内容为
<strong>一个或多个树对象记录（Tree Entry）</strong>。</p>
<p>其中，树对象记录的结构（Git v2.0.0）为：<strong>文件模式 + 空格 +
树对象记录的字节数 + 文件路径 + \0 + SHA-1</strong>。</p>
<p>如果某一时刻，Git 仓库的文件结构如下所示，那么在 Git
文件系统中，会建立一个对象关系图，如下图所示。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── bak</span><br><span class="line">│   └── test.txt</span><br><span class="line">├── new.txt</span><br><span class="line">└── test.txt</span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-05.png?x-oss-process=image/resize,w_800" /></p>
<p><strong>注意，当我们执行 <code>git add</code>（进入暂存区）时，Git
会为暂存文件创建 Blob Object，为暂存目录创建 Tree Object
，结合未修改文件和目录的
Object，建立一个整体的索引关系，从而形成一个版本快照。</strong></p>
<h2 id="commit-object">Commit Object</h2>
<p>Tree Object 和 Blob Object <strong>用于表示版本快照</strong>，Commit
Object 则不同，它 <strong>用于表示版本索引和版本关系</strong>。</p>
<p>此外，Tree Object 和 Blob Object 的 SHA-1
值是根据内容计算得到的，只要内容相同，SHA-1 值相同；而 Commit Object
会结合内容、时间、作者等数据，因此 SHA-1 值很难出现冲突。</p>
<p>Commit Object 的头部信息为 <strong>"commit" + 空格 + 内容字节数 +
\0</strong>，存储内容包含多个部分（Git v2.0.0），具体如下图所示。</p>
<ul>
<li>对应的根 Tree Object 对应的 SHA-1</li>
<li>一个或多个父级 Commit Object 对应的
SHA-1。当进行分支合并时就会出现多个父级 Commit Object。</li>
<li>提交相关内容，包括：作者信息、提交者信息、编码、提交描述等</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-06.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示，为 Commit Object 与 Tree Object 的关系示意图。每一个 Commit
Object 索引一个版本快照，每一个版本快照则是由一个 Tree Object
作为根节点进行构建。不同的版本快照之间会进行数据复用，从而最大限度地节省磁盘空间。每一个
Commit Object 记录了其父版本的索引信息，即另一个 Commit Object 的 SHA-1
值，从而构建了一个完整的版本关系图（有向无环图）。通过版本关系图，我们可以基于一个
Commit Object 回溯其任意历史版本。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-07.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="引用">引用</h1>
<p>如果我们对仓库的某一个提交及其历史版本感兴趣，那么我们可以使用该提交的
SHA-1 值进行查找。显然，直接使用 SHA-1
值来记忆是非常不便且易错的。对此，Git 提供了容易记忆的 “别名” 来代替
SHA-1 值，这就是 “<strong>引用</strong>（referrences，简称 refs）”。</p>
<p>Git 支持三种引用类型，不同的引用类型对应的引用文件各自存储在
<code>.git/refs/</code> 下的不同子目录中。</p>
<ul>
<li><strong>HEAD 引用</strong></li>
<li><strong>标签引用</strong></li>
<li><strong>远程引用</strong></li>
</ul>
<h2 id="head-引用">HEAD 引用</h2>
<p>当我们执行 <code>git branch &lt;branch&gt;</code> 新建一个分支时，Git
是如何知道最新提交的 SHA-1 值呢？答案就是 <strong>HEAD
文件</strong>。</p>
<p>HEAD 文件通常是一个 <strong>符号引用</strong>（symbolic
reference），指向当前所在的分支。所谓符号引用，表示它是一个指向其他引用的指针，类似于符号链接。</p>
<p>在某些特殊情况下，HEAD 文件可能会包含一个 Git 对象的 SHA-1
值。当我们在检出一个标签、提交或远程分支时，让仓库变成 “<strong>分离
HEAD</strong>” 状态时，就会出现这种情况。</p>
<p>我们可以通过 <a
href="https://github.com/baochuquan/analyze-git">analyze-git</a> 来查看
HEAD 文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/master</span><br><span class="line"></span><br><span class="line">$ git checkout <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure></p>
<p>当我们执行 <code>git commit</code> 时，该命令会使用 HEAD
文件中引用所指向的 SHA-1 值作为其父提交，创建一个 Commit Object。</p>
<h2 id="标签引用">标签引用</h2>
<p>标签引用（Tag Reference）包含两种类型：<strong>轻量标签</strong> 和
<strong>附注标签</strong>。</p>
<h3 id="轻量标签">轻量标签</h3>
<p>对于轻量标签，我们可以通过如下命令进行创建。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 a9f2652cb992f300c0a251d3607bdabfe8901bb2</span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/tags/v1.0</span><br><span class="line">a9f2652cb992f300c0a251d3607bdabfe8901bb2</span><br></pre></td></tr></table></figure></p>
<p>该命令会创建一个以标签名命名的文本文件，文件内容为其所引用的 Commit
Object 的 SHA-1 值。</p>
<h3 id="附注标签">附注标签</h3>
<p>对于附注标签，我们可以通过如下命令进行创建。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  git tag -a v1.1 e73b484c6e1802c36dceae4535f6c85 -m <span class="string">&quot;test tag&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>该命令会创建一个 <strong>标签对象</strong>（Tag Object），存储在
<code>.git/objects/</code> 目录下。</p>
<p>Tag Object 是第 4 种 Git 对象，其头部信息为 <strong>"tag" + 空格 +
内容字节数 + \0</strong>，存储内容包含多个部分（Git
v2.0.0），具体如下图所示。</p>
<ul>
<li>所引用对象的 SHA-1 值</li>
<li>所引用对象的类型</li>
<li>标签名称</li>
<li>标签创建者和日期</li>
<li>注释信息</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-08.png?x-oss-process=image/resize,w_800" /></p>
<p>Tag Object 通常指向一个 Commit Object，而不是 Tree
Object。它像是一个永不移动的分支引用——永远指向同一个 Commit
Object，只不过给这个 Commit Object 加上一个更友好的名字罢了。</p>
<p>我们可以通过 <a
href="https://github.com/baochuquan/analyze-git">analyze-git</a>
来查看一个附注标签所创建的 Tag Object。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/resfs/tags/v1.1</span><br><span class="line">163827fe0e0a63112bee25a48bdcca2de89982e3</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 163827fe0e0a63112bee25a48bdcca2de89982e3</span><br><span class="line">object e73b484c6e1802c36dceae4535f6c8517716650c</span><br><span class="line"><span class="built_in">type</span> commit</span><br><span class="line">tag v1.1</span><br><span class="line">tagger baocq &lt;baocq@fenbi.com&gt; 1652526376 +0800</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> tag</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到 Tag Object 的 object 字段为我们打了标签的的 Commit
Object 的 SHA-1 值。从 Tag Object 的内容定义上能看出，Tag Object
并非必须指向某个 Commit Object；我们可以对任意类型的 Git
对象打标签。比如，在 Git 源码中，项目维护者将他们的 GPG
公钥添加为一个数据对象，然后对这个对象打了个标签。我们可以在 Git
源码仓库下执行以下命令查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cat-file blob junio-gpg-pub</span><br></pre></td></tr></table></figure>
<h2 id="远程引用">远程引用</h2>
<p>远程引用（Remote
Reference）主要用于远程仓库与本地仓库进行映射和对比。如果我们添加了一个远程仓库并对其执行过推送操作，Git
会记录下最近一次推送操作时每一个分支所对应的值，并保存在
<code>.git/refs/remotes/</code> 目录下。</p>
<p>远程引用和分支（位于 <code>.git/refs/heads/</code>
目录下的引用）之间的最主要区别在于：远程引用是只读的。虽然我们可以
<code>git checkout</code> 到某个远程引用，但是 Git 并不会将 HEAD
引用指向该远程引用。因此，我们永远不能通过 <code>git commit</code>
命令来更新远程引用。Git
将这些远程引用作为记录远程服务器上各个分支最后已知位置状态的书签来管理。</p>
<h1 id="包文件">包文件</h1>
<p>通过上文我们知道，如果我们对任意一个文件进行修改，Git
就会创建一个新的 Blob
Object，并将该文件的所有内容存储到里面。那么这时候问题来了，如果一个文件非常大，而每次我们只修改其中极小一部分内容，这样的话，Git
会创建很多 Blob
Object，而它们的绝大部分的内容都是相同的，因此会存在严重的磁盘空间浪费问题。如果
Git
只完整保存其中一个，在保存另外一个对象与之前版本的差异内容，岂不是更好？</p>
<p>对于这方面的优化，Git
的确采用了增量存储的方式进行了优化。那么具体怎么做的呢？</p>
<p>事实上，Git
会不定时地自动对仓库中的对象进行打包并移除，最终生成两个文件：</p>
<ul>
<li><strong>包文件（Pack File）</strong> ：采用 <strong>原始内容 +
增量内容</strong> 的形式进存储，从而节省存储空间。</li>
<li><strong>索引文件（Index
File）</strong>：存储了各个包文件中各个对象的大小、偏移、类型等数据，从而便于重建文件快照和对象关系。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-09.png?x-oss-process=image/resize,w_800" /></p>
<p>我们可以使用 <code>git verify-pack</code> 这个底层命令来查看 <a
href="https://github.com/baochuquan/analyze-git">analyze-git</a>
中的索引文件。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-b850d8225332999ae75a6a83e36c4729173c1e8d.idx</span><br><span class="line">92261eb83bf2bf5da2a0b2ca5e88d4099ee2b71f commit 217 150 12</span><br><span class="line">3103a76a8bc9daea112a4fdbee03f8c5686d8f86 commit 208 144 162</span><br><span class="line">e73b484c6e1802c36dceae4535f6c8517716650c commit 207 143 306</span><br><span class="line">a9f2652cb992f300c0a251d3607bdabfe8901bb2 commit 208 142 449</span><br><span class="line">163827fe0e0a63112bee25a48bdcca2de89982e3 tag    126 117 591</span><br><span class="line">bc36caf5d579e4275ec0c8b32a6d620b99d37e8d commit 159 112 708</span><br><span class="line">fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 820</span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 956</span><br><span class="line">deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1002</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1138 1 deef2e1b793907545e50a2ea2ddb5ba6c58c4506</span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1157</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1233</span><br><span class="line">fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1252</span><br><span class="line">b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1270</span><br><span class="line">033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7069 1 b042a60ef7dff760008df33cee372b945b6e884e</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7089</span><br><span class="line">non delta: 14 objects</span><br><span class="line">chain length = 1: 2 objects</span><br><span class="line">.git/objects/pack/pack-b850d8225332999ae75a6a83e36c4729173c1e8d.pack: ok</span><br></pre></td></tr></table></figure> 其中，各列数据分别是：</p>
<ul>
<li>SHA-1：对象的 SHA-1 值</li>
<li>type：对象的类型</li>
<li>size：对象的大小</li>
<li>size-in-packfile：对象在包文件中的大小</li>
<li>offset-in-packfile：对象在包文件中的偏移</li>
<li>depth：对象在包文件所处的索引关系中的深度</li>
<li>base-SHA-1：增量对象的父级对象的 SHA-1 值</li>
</ul>
<p>关于包文件，Git 经常自动进行打包来节省空间，当然我们也可以手动执行
<code>git gc</code>
命令来进行打包。注意，当我们执行将代码推送至远程仓库时，Git
也会进行打包。我们可以看到 <code>git push</code> 或
<code>git pull</code> 时控制台输出的打包相关的信息，如下所示。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 7, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 6.27 KiB | 6.27 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 1), reused 6 (delta 1)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">To https://github.com/baochuquan/analyze-git.git</span><br><span class="line">   e73b484..92261eb  master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure></p>
<h1 id="基于底层原理的应用">基于底层原理的应用</h1>
<p>关于 Git 底层原理的应用例子其实很多，这里我们来介绍一个 CocoaPods
Source 管理机制的例子。</p>
<p>下图所示为 CocoaPods Source 管理机制的 <code>Master</code>
方案。<code>Specs</code> 目录下为什么要细分出来多级子目录？</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cocoapods-source-01.png?x-oss-process=image/resize,w_800" /></p>
<p>这样设计的目的为了在 Git 版本变更时尽可能少地增加 Git
对象体积。假设，有个 Git 仓库包含 100
个文件，我们使用两种方式进行管理：</p>
<ul>
<li>分级管理：两级目录，根目录下有 10 个子目录，每个子目录下 10
个文件。</li>
<li>扁平管理：100个文件全部放在根目录下。</li>
</ul>
<p>我们分别计算一下两种方案下版本变更时，产生的 git 对象体积。</p>
<p>下图所示为分级管理的情况下，修改一个文件所产生的对象示意图。新增的数据包括：1
个 Commit Object、2 个 Tree Object、1 个 Blob Object。两个 Tree Object
总共包含 20 个记录项。新建两个 Tree Object 总共需要遍历 10 + 10
个对象即可。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-11.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示为扁平管理的情况下，修改一个文件所产生的对象示意图。新增的数据包括：1
个 Commit Object、1 个 Tree Object、1 个 Blob Object。虽然新增的 Tree
Object 数量少，但是新增的 Tree Object 的记录项非常多，有 100
个。此外，新建这个 Tree Object 需要遍历 100 个对象。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-principle-10.png?x-oss-process=image/resize,w_800" /></p>
<p>对比之下，我们可以发现分级管理虽然产生的对象多，但是实际占用的空间反而是更小的，并且新建对象时遍历的对象更少，效率更高。</p>
<h1 id="总结">总结</h1>
<p>本文主要介绍了 Git
的底层实现原理，首先是其架构，大概分为三层，分别是：上层命令、底层命令、对象数据库（内容寻址文件系统）。</p>
<p>我们重点介绍了对象数据库，使用 Linux Ext
文件系统跟它进行了对比，两者在设计理念上基本是一致的。整个设计理念非常清晰，将文件和目录进行区分存储。使用轻量级数据结构表示目录可以在某些场景下提升效率，比如重命名等。</p>
<p>关于底层数据，我们介绍了其核心的 4 种：Blob Object、Tree
Object、Commit Object 以及 Tag Object。这些对象各司其职，在底层支持了
Git 的设计理念。</p>
<p>最后，我们介绍了一个真实的设计案例——CocoaPods Source
管理机制，其正是应用了 Git
的底层原理对自身系统进行了性能优化。未来，我们在设计自己的软件时，也可以借鉴
Git 底层原理进行优化。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/git/git">git</a></li>
<li><a href="https://git-scm.com/book">Pro Git</a></li>
<li>《开源软件架构》</li>
<li><a
href="https://hutusi.com/articles/the-greatest-git-commit">改变世界的一次代码提交</a></li>
<li><a
href="https://blog.cocoapods.org/Master-Spec-Repo-Rate-Limiting-Post-Mortem/#too-many-directory-entries">Master
spec-repo rate limiting post‑mortem</a></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Blob</tag>
      </tags>
  </entry>
  <entry>
    <title>系统理解 Ruby 工具链</title>
    <url>/2021/01/20/understand-ruby-tool-chain/</url>
    <content><![CDATA[<p>一直以来，我对 Ruby 工具链环境都没有一个系统的认识，这使得我在 iOS
开发时遇到的 Ruby 环境问题都难以把握其本质原因。最近开始学习 Ruby
开发，借此机会深入学习了一下 Ruby
工具链，并整理出本文以供后续的学习。</p>
<span id="more"></span>
<h1 id="版本管理系统">版本管理系统</h1>
<p>在软件工程中，<strong>版本管理系统</strong>（Version Control
System，简称
VCS）是用于管理团队协作开发重要的工具，能够为后续的持续继承提供保障。<strong>源码管理器</strong>（Source
Code Manager，简称 SCM）就是 VCS
的一种，常见的工具如：<code>git</code>、<code>svn</code>。<strong>包管理器</strong>（Package
Manager，简称 PM）也是 VCS
的一种，常见的工具如：<code>cocoapods</code>、<code>swift package manager</code>、<code>npm</code>、<code>git submodule</code>。</p>
<p>源码管理器一般是针对单个文件进行版本控制；包管理器则是针对单个
package 进行版本控制。</p>
<p>通常在一个项目中，会同时使用源码管理器和包管理器，由于包管理器能够限定包的版本范围，所以通常不会将包加入源码管理中。举个例子：对于
iOS 项目，我们会使用 <code>git</code> 进行源码管理，使用
<code>cocoapods</code> 进行包管理，在 <code>Pods</code>
目录下存放项目所依赖的包，并在 <code>.ignore</code> 中忽略
<code>Pods</code> 目录。</p>
<h2 id="包管理器">包管理器</h2>
<p>包管理工具通常具备语义化版本检查，依赖递归查找，依赖冲突解决，构建具体依赖等能力。这些能力则主要围绕以下两个文件来实现：</p>
<ul>
<li><strong>描述文件</strong>：声明了项目的依赖及其版本限制。</li>
<li><strong>锁存文件</strong>：记录了依赖更新后的全版本列表。</li>
</ul>
<p>除了上述两个文件之外，中心化的包管理器一般会提供依赖包的托管服务，比如：npm
提供的 npmjs.com 可以集中查找和下载 npm 包；去中心化的包管理器一般会通过
git 仓库的地址查找和下载依赖包，比如：iOS 的 <code>carthage</code> 和
<code>spm</code> 中所声明的依赖都会有各自的 <code>git</code>
仓库地址。</p>
<p>下面我们对常见的几种包管理器进行简要的对比：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Key File</th>
<th style="text-align: left;">Git Submodule</th>
<th style="text-align: left;">CocoaPods</th>
<th style="text-align: left;">SPM</th>
<th style="text-align: left;">npm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">描述文件</td>
<td style="text-align: left;">.gitmodule</td>
<td style="text-align: left;">Podfile</td>
<td style="text-align: left;">Package.swift</td>
<td style="text-align: left;">Package.json</td>
</tr>
<tr class="even">
<td style="text-align: left;">锁存文件</td>
<td style="text-align: left;">.git/modules</td>
<td style="text-align: left;">Podfile.lock</td>
<td style="text-align: left;">Package.resolved</td>
<td style="text-align: left;">Package-lock.json</td>
</tr>
</tbody>
</table>
<p>下面我们来介绍这里提到的两种包管理器：<code>git submodule</code> 和
<code>cocoapods</code>。</p>
<h3 id="git-submodule">Git Submodule</h3>
<p>Git submodule
是一种原始的包管理器，它不具备常见包管理器工具所特有的语义化管理功能，无法处理依赖共享和冲突。Git
submodule 将单独的 <code>git</code>
仓库以子目录的形式嵌入在项目中，保存每个依赖仓库的文件状态。</p>
<h4 id="gitmodules"><code>.gitmodules</code></h4>
<p>Git submodule 以 <code>.gitmodules</code>
文件作为描述文件，其描述了模块的基本信息，如：<code>path</code>、<code>url</code>、<code>branch</code>。如下所示是一个
<code>.gitmodule</code> 文件的实例： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[submodule &quot;flutter&quot;]</span><br><span class="line">	path = flutter</span><br><span class="line">	url = https://github.com/flutter/flutter.git</span><br><span class="line">	branch = stable</span><br></pre></td></tr></table></figure> ####
<code>.git/modules</code> <code>Git submodule</code> 以
<code>.git/modules</code> 目录作为锁存文件，其中 <code>HEAD</code>
文件记录了项目所依赖的子仓库的 commit 信息。</p>
<h3 id="cocoapods">CocoaPods</h3>
<p>CocoaPods 是 iOS 开发中常用的一个第三方库的依赖管理工具。</p>
<h4 id="podfile"><code>Podfile</code></h4>
<p>CocoaPods 以 <code>Podfile</code> 文件作为描述文件，使用基于 Ruby 的
DSL 来描述依赖关系，用于描述项目所依赖的第三方库。</p>
<h4 id="podfile.lock"><code>Podfile.lock</code></h4>
<p>CocoaPods 以 <code>Podfile.lock</code>
文件作为锁存文件，其记录了每个已安装 Pod 的版本。项目中，一般会把
<code>Podfile.lock</code> 加入到版本控制中，有助于保持团队的一致性。</p>
<h4 id="manifest.lock"><code>Manifest.lock</code></h4>
<p>CocoaPods 使用未加入版本控制的
<code>Manifest.lock</code>，对比已加入版本控制的
<code>Podfile.lock</code>，从而判断是否需要更新本地的依赖。我们常见的
<strong><code>The sandbox is not in sync with the Podfile.lock</code></strong>
报错就是由于 <code>Manifest.lock</code> 与 <code>Podfile.lock</code>
不一致所引起的。每次执行完 <code>pod install</code> 命令时会重新生成
<code>Podfile.lock</code> 及其副本 <code>Manifest.lock</code>。</p>
<h1 id="ruby-环境版本控制">Ruby 环境版本控制</h1>
<p>我们都知道 CocoaPods 是通过 Ruby 实现的，是一个 <code>gem</code>
包。在 iOS 开发中，我们经常会遇到由于 Ruby 环境变化而导致 CocoaPods
出错。一旦我们理解了 Ruby 的依赖管理，那么有助于我们更好的管理不同版本的
CocoaPods 和其他
<code>gem</code>，从而顺利解决开发过程中遇到的各种环境问题。</p>
<h2 id="rvm-rbenv">RVM &amp; rbenv</h2>
<p><strong>RVM 和 rbenv 都是管理多个 Ruby
环境的工具，它们都能够提供不同版本的 Ruby 环境管理和切换。</strong></p>
<p>关于 RVM 和 rbenv 孰好孰坏，各有各的说法，我选择 RVM 作为 Ruby
版本管理工具主要是因为工作中团队使用的是 RVM。</p>
<h2 id="rubygems">RubyGems</h2>
<p><strong>RubyGems 是 Ruby
的一个包管理器，它所管理的包或者依赖，我们称之为 gem</strong>。</p>
<p>上述介绍的包管理器，一般都是围绕着 <strong>描述文件</strong> 和
<strong>锁存文件</strong>
来工作的。这种情况只是针对项目而言，因为不同的项目有着不同的环境。然而，RubyGems
作为系统的包管理器，它的工作环境只有一个，因此无需描述文件和锁存文件。</p>
<p>作为一个中心化的包管理器，RubyGems 提供了 Ruby
组件的托管服务，可以集中式的查找和安装工具和依赖。当我们使用
<strong><code>gem install xxx</code></strong> 时，会通过
<code>rubygems.org</code> 来查询对应的 gem。iOS
开发中常用的工具都可以通过 RubyGems
进行安装，如：<code>bundler</code>、<code>fastlane</code>、<code>cocoapods</code>
等。</p>
<p><strong>默认情况下，RubyGems 总是下载 gem
的最新版本</strong>，这无法确保所安装的 gem
符合我们的预期。因此我们还缺一个工具。</p>
<h2 id="bundler">Bundler</h2>
<p><strong>Bundler 是管理 gem 依赖的工具，它能够隔离不同项目中 gem
的版本。本质上，Bundler 是一个包管理器，也是一个 gem</strong>。</p>
<h3 id="gemfile"><code>Gemfile</code></h3>
<p>Bundler 以 <code>Gemfile</code> 文件作为描述文件，从而确定各个 gem
的版本号或范围，从而提供稳定的应用环境。</p>
<p>在 iOS 开发中，为了让团队的工作环境保持一致性，通常使用
Bundler，结合项目中的 <code>Gemfile</code>
来指定项目所使用工具的具体版本。如下所示是 <code>Gemfile</code>
配置的示例： <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://gems.ruby-china.com&#x27;</span></span><br><span class="line"></span><br><span class="line">gem <span class="string">&#x27;cocoapods&#x27;</span>, <span class="string">&#x27;~&gt; 1.10.0&#x27;</span></span><br><span class="line">gem <span class="string">&#x27;fastlane&#x27;</span>, <span class="string">&#x27;~&gt; 2.153.1&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>当我们执行 <code>bundle exec pod install</code> 时，bundler 会读取
Gemfile 选择指定版本的 cocoapods 来执行 <code>pod install</code>
命令，从而让团队的工作环境保持一致。</p>
<h3 id="gemfile.lock"><code>Gemfile.lock</code></h3>
<p>Bundler 以 <code>Gemfile.lock</code> 文件作为锁存文件，将各个 gem
的具体安装版本写入其中。</p>
<p>当团队中的其他人通过 <code>bundle install</code> 来安装 gem
时，会读取 <code>Gemfile.lock</code> 中的 gem
名称及其版本信息，从而安装对应的 gem 版本。</p>
<h1 id="ruby-工具链">Ruby 工具链</h1>
<p>如下所示为 Ruby 工具链的关系图，<strong>我们可以使用
<code>homebrew</code> + <code>rvm</code> + <code>RubyGems</code> +
<code>Bundler</code> 组成的 Ruby 工具链来管理一个项目中 Ruby
工具的版本依赖</strong>，具体管理流程如下：</p>
<ul>
<li>使用 <code>homebrew</code> 安装 Ruby 版本管理工具 <code>rbenv</code>
或 <code>rvm</code>（<code>rvm</code> 目前不支持通过
<code>homebrew</code> 进行安装）</li>
<li>使用 <code>rbenv</code> 或 <code>rvm</code> 安装并指定一个系统默认的
Ruby 版本，每个版本的 Ruby 都有一个对应的 <code>RubyGems</code>
包管理器</li>
<li>使用 <code>RubyGems</code> 安装 gem
包，如：<code>cocoapods</code>、<code>bundler</code>、<code>fastlane</code></li>
<li>使用 <code>bundler</code> 管理单个项目中所依赖 gem 包的版本</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ruby-tool-chain.png?x-oss-process=image/resize,w_800" /></p>
<p>对于项目而言，可以使用 <code>bundler</code> 管理其所依赖的 gem
包的版本。具体操作是在项目中新增一个 <code>Gemfile</code>
描述文件，从而锁定项目中依赖 <code>gem</code> 包的版本。</p>
<p>在 <code>Gemfile</code> 所在目录下执行
<code>bundle install</code>，能够安装 <code>Bundler</code> 环境下的
<code>gem</code> 依赖。通过如下命令可以分别查看系统环境下和
<code>Bundler</code> 环境下的 gem 列表。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统环境下的 gem 列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gem list</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Bundler 环境下的 gem 列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bundle <span class="built_in">exec</span> gem list</span></span><br></pre></td></tr></table></figure></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ruby-bundler.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文，我们从版本管理系统出发，分别介绍了源码管理器和包管理器。然后，重点介绍了包管理器中几种常见的工具：<code>git submodule</code>、<code>cocoapods</code>。包管理器一般围绕着
<strong>描述文件</strong>、<strong>锁存文件</strong>
实现，<code>cocoapods</code>、<code>bundler</code>、<code>npm</code>
都是如此。</p>
<p>最后，我们梳理了一下 Ruby
工具链中各种工具之间的关系，并绘制了两个关系图。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://brew.sh/">Homebrew</a></li>
<li><a href="https://rvm.io/">RVM</a></li>
<li><a href="https://github.com/rbenv/rbenv">rbenv</a></li>
<li><a href="https://cocoapods.org/">Cocoapods</a></li>
<li><a href="https://swift.org/package-manager/">Package
Manager</a></li>
<li><a href="https://www.npmjs.com/">npm</a></li>
<li><a href="https://gradle.org/">Gradle</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/147537112">版本管理工具及 Ruby
工具链环境</a></li>
<li><a href="https://github.com/rbenv/rbenv/wiki/Why-rbenv%3F">Why
rbenv?</a></li>
<li><a href="https://bundler.io/">Bundler</a></li>
<li><a
href="https://ruby-china.org/wiki/rvm-guide">Ruby实用指南</a></li>
</ol>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>Ruby</tag>
        <tag>RubyGems</tag>
        <tag>Bundler</tag>
        <tag>RVM</tag>
        <tag>rbenv</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew 的设计哲学</title>
    <url>/2023/08/27/understand-the-design-of-homebrew/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-00.png?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<p>如果你是一位 MacOS 用户，那么你一定知道 Homebrew。Homebrew 是 MacOS
下的包管理工具，类似 apt-get/apt 之于 Linux，yum 之于
CentOS。如果一款软件发布时支持了 homebrew 安装渠道，那么我们就可以通过
homebrew 一键安装，省时省力省心。</p>
<p>本文，我们将来探索一下 homebrew 的底层工作原理。</p>
<p>通过学习其工作原理，我们可以举一反三，推测并理解其他平台的包管理工具的设计思想。此外，我们还能借此理解开源软件的设计范式，从而为软件设计提供思路和指导。当然，最直接的收益则是加深对于
homebrew 的理解，可以基于其原理来解决日常工作中的相关问题。</p>
<h1 id="酿酒术语">酿酒术语</h1>
<p>Homebrew 的作者 Max Howell
借用了西方的酿酒文化，为软件定义了一系列的术语。因此，想要捋清楚各个术语及其之间的关系，我们有必要先简单了解一下酿酒文化中的相关术语。</p>
<p>对于工厂而言，酒一般会以 <strong>木桶（Cask）</strong>
的形式存放在规模较大的厂房中，即
<strong>酒桶房（Caskroom）</strong>。通常，木桶可以直接安装
<strong>酒龙头（Tap）</strong> 来打酒或装罐。具体如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-01.png?x-oss-process=image/resize,w_800" /></p>
<p>对于家庭而言，酒一般会以 <strong>瓶装酒（Bottle）</strong> 或
<strong>罐装酒（Keg）</strong> 的形式存放在规模较小的屋子里，即
<strong>酒窖（Cellar）</strong>。由于瓶装酒和罐装酒体积较小，同时为了便于分类和存取，一般会摆放在
<strong>酒架（Rack）</strong> 上。具体如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="软件术语">软件术语</h1>
<p>Homebrew
将软件比喻成酒，对于不同类型的软件，其管理（保存）方式有所不同：</p>
<ul>
<li><strong>对于原生应用，将其比作桶装酒，以 Cask 作为容器，保存在
Caskroom 中。</strong></li>
<li><strong>对于非原生应用，将其比作瓶装酒或罐装酒，以 Bottle 或 Keg
作为容器，保存在 Cellar 的 Rack 中。</strong></li>
</ul>
<blockquote>
<p>什么是 MacOS 原生应用？ MacOS 原生应用是指为 MacOS
操作系统专门设计和开发的应用程序。通常使用 Apple 提供的软件开发工具（如
Xcode）和编程语言（Swift 或
Objective-C）进行开发，直接调用操作系统提供的 API 进行各种操作。 每个
MacOS 原生应用都会有一个唯一的Bundle
Identifier，系统以此标识符来管理和区分不同应用。</p>
</blockquote>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-04.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示，为 MacOS 系统中 homebrew
对于软件管理的层级结构。这里有一个细节，我们发现 Caskroom 和 Casks
构建了一个两层关系，而 Cellar、Racks、Kegs/Bottles
则构建了一个三层关系。对此，我的理解是：</p>
<ul>
<li><strong>对于非原生应用，其索引方式是通过软链接实现的，因此同一台机器中可以存储同一应用的不同版本，通过修改软链接的指向来使用不同的版本。</strong></li>
<li><strong>对于原生应用，系统以应用的 Bundle Identifier
作为唯一标识，同一应用的不同版本的 Bundle Identifier
是相同的，因此同一台机器中只能覆盖安装，不同版本无法共存。</strong></li>
</ul>
<p>综合上述原因，非原生应用需要三层结构进行管理，而原生应用只需两层结构进行管理。从这个角度来看，正好与
Cellar 和 Caskroom 的层级结构相匹配。</p>
<p>从图中，我们还可以看到 Cellar 的管理下包含了两种类型的软件，分别使用
<strong>罐装酒（Keg）</strong> 和 <strong>瓶装酒（Bottle）</strong>
来描述，它们是存在一些细微的区别的：</p>
<ul>
<li><strong>对于 Keg，表示的是 homebrew
通过使用源码进行编译构建的软件。</strong></li>
<li><strong>对于 Bottle，表示的是 homebrew
直接下载预编译的二进制的软件。</strong></li>
</ul>
<p>既然 homebrew
将软件比喻成酒，那么很显然，软件的安装过程则对等比喻成酿酒。对此，homebrew
使用 <strong>木桶（Cask）</strong> 和 <strong>配方（Formula）</strong>
作为软件安装的两个基本元素，它们分别作为原生应用的包定义和非原生应用的包定义。为了便于管理，homebrew
统一将它们放在 <strong>酒龙头（Tap）</strong> 下进行管理，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-05.png?x-oss-process=image/resize,w_800" /></p>
<p>对于 homebrew 这样设计 Tap 和 Formula、Cask
之间的关系，我个人认为，从语义上来说属实有点牵强，因为它们在任何维度上都不是包含关系。这里，我们只要知道它们之间存在着包含关系即可，无需深究。</p>
<h1 id="存储结构">存储结构</h1>
<p>通过上文，我们大致了解了 homebrew
中术语的含义与关系。下面，我们来看一下它们具体在文件系统中的存储结构。</p>
<p>对于 MacOS 系统，homebrew 在 ARM 架构（Apple Silicon）和 X86
架构（Intel）中的存储位置所有不同，但是术语之间相对关系是一致的。作出这种区分的主要原因是，当从
X86 架构迁移至 ARM 架构时，支持在 Rosetta 模式下继续运行在 X86
架构下安装的软件应用。</p>
<p>对于 X86 架构，Caskroom 的路径是
<code>/usr/local/Caskroom</code>，Cellar 的路径是
<code>/usr/local/Cellar</code>，Taps 的路径是
<code>/usr/local/Homebrew/Library/Taps</code>。</p>
<p>对于 ARM 架构，Caskroom 的路径是
<code>/opt/homebrew/Caskroom</code>，Cellar 的路径是
<code>/opt/homebrew/Cellar</code>，Taps 的路径是
<code>/opt/homebrew/Library/Taps</code>。</p>
<h2 id="caskroom">Caskroom</h2>
<p>Caskroom
主要负责管理原生应用，由于原生应用无法同时维护多个版本，所以在 Caskroom
下对应只会存在一个版本目录。如下所示，以 <code>aerial</code>
为例，在两次安装时，后一次会覆盖前一次的版本数据。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-03.jpg?x-oss-process=image/resize,w_800" /></p>
<h2 id="cellar">Cellar</h2>
<p>Cellar 主要负责管理非原生应用，由于是通过软链接进行版本管理，所以在
Cellar 下对应会存在多个版本目录。如下所示，以 <code>git</code>
为例，它会保存多个版本的数据。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-06.jpg?x-oss-process=image/resize,w_800" /></p>
<p>对于非原生应用，我们还可以在
<code>/usr/local/bin</code>（Intel）目录下看到 homebrew
为命令行应用创建的所有软链接，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-07.jpg?x-oss-process=image/resize,w_800" /></p>
<p>由于 <code>PATH</code> 环境变量包含了
<code>/usr/local/bin</code>，所以系统能查找 homebrew
所安装的软件的软链接，进而找到真正的可执行文件。不过在某些情况下，我们可能需要让
homebrew
安装的软件对于用户不可见，比如：避免版本冲突、仅用于依赖构建等。这时候，homebrew
不会为这些软件创建软链接，对于这种类型的软件，homebrew 称之为
<strong>keg-only</strong>，比如：<code>openjdk</code>。</p>
<h2 id="taps">Taps</h2>
<p>Taps 主要负责管理 <strong>包定义</strong> 和
<strong>外部命令</strong>。</p>
<ul>
<li>包定义：一个包定义对应一款软件，主要用于指导对应软件的安装。</li>
<li>外部命令：支持用户对 homebrew 进行扩展，提供更多的命令和功能。</li>
</ul>
<p>Taps 目录维护了多个 Git 仓库（Tap
仓库å），包括开发者自建的仓库，以及官方维护的仓库，比如：<code>homebrew/homebrew-core</code>
和 <code>homebrew/homebrew-cask</code> 等。</p>
<p>如下所示，这些仓库大多数都维护了一个 <code>Formula</code> 或
<code>Casks</code> 目录，其中存放了软件的包定义。这些包定义本质上是一个
Ruby 类定义，图中的 <code>muesli/homebrew-tap</code> 中虽然没有定义
<code>Formula</code> 或 <code>Casks</code> 目录，但其保存的 Ruby
文件都是包定义。</p>
<p>除此之外，部分仓库维护了一个 <code>cmd</code>
目录，其中存放了一些外部命令的定义，我们可以以文件名作为子命令进行调用，比如：<code>cmd</code>
目录中有一个 <code>check-ci-status.rb</code> 文件，我们可以通过
<code>brew check-ci-status</code>
命令来调用执行。通过这种方式，我们可以对 homebrew 的命令进行扩展。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-08.jpg?x-oss-process=image/resize,w_800" /></p>
<h1 id="包定义">包定义</h1>
<p>作为一个软件包管理工具，homebrew 中最核心的设计便是包定义（Package
Definition）。通过包定义，homebrew 才能够正确地安装对应的软件。</p>
<p>在上文 Taps 一节中，我们知道 homebrew
支持两种管理方式，具体而言分别是：</p>
<ul>
<li><strong>官方仓库管理</strong>，我们可以实现自己的包定义，并向
<code>homebrew/homebrew-core</code>（用于 Formula）或
<code>homebrew/homebrew-cask</code>（用于 Cask）提交 Pull
Request。这种方式会对包定义有着严格的规范和约束。</li>
<li><strong>自建仓库管理</strong>，我们在自定义的仓库中实现包定义，并自行维护。在安装软件时，我们将该仓库加入至
Taps 目录进行管理。</li>
</ul>
<p>对于自建仓库，我们可以使用
<code>brew tap-new &lt;user&gt;/&lt;repo&gt;</code>
命令来创建一个模板仓库。如下所示，我们使用
<code>brew tap-new baochuquan/homebrew-nox</code> 创建了一个 Tap
仓库。命令会在 Taps 目录下创建一个仓库，并默认创建一个 Formula
目录用于存放 Formula 包定义。如果希望存放 Cask
包定义，我们可以再手动创建一个 Casks 目录。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-10.jpg?x-oss-process=image/resize,w_800" /></p>
<p>Homebrew 中的包定义有两种：Formula 和 Cask。</p>
<h2 id="formula">Formula</h2>
<p>Formula 是非原生应用的包定义，如下所示是 CocoaPods 的 Formula
包定义。</p>
<figure class="highlight rb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cocoapods</span> &lt; <span class="title class_ inherited__">Formula</span></span><br><span class="line">  desc <span class="string">&quot;Dependency manager for Cocoa projects&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://cocoapods.org/&quot;</span></span><br><span class="line">  url <span class="string">&quot;https://github.com/CocoaPods/CocoaPods/archive/1.12.1.tar.gz&quot;</span></span><br><span class="line">  sha256 <span class="string">&quot;da018fc61694753ecb7ac33b21215fd6fb2ba660bd7d6c56245891de1a5f061c&quot;</span></span><br><span class="line">  license <span class="string">&quot;MIT&quot;</span></span><br><span class="line"></span><br><span class="line">  bottle <span class="keyword">do</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_ventura:</span>  <span class="string">&quot;6f1fca1cb0df79912e10743a80522e666fe605a1eaa2aac1094c501608fb7ee4&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_monterey:</span> <span class="string">&quot;8f7eff899cc1807286374e29e634c1008e286c3360df6cbcb90e27b0fe5567a9&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_big_sur:</span>  <span class="string">&quot;346833fef239df933ddb67341c55c9c4a7e547fc03afdc332861ac2ae8ba3372&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">ventura:</span>        <span class="string">&quot;b114ec0a11a2e472026f0f7337d17558bead2ac1122d9c2bb9278fc6b31fd744&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">monterey:</span>       <span class="string">&quot;946f0282afe0000ba9e23f30ce2175bc4b1f0c6d7e27145f01be4665b9786f8a&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">big_sur:</span>        <span class="string">&quot;1fe6f0c45e0c13e122aa1d8bf1f9bd9496fa3bb00fe7bc19286425e029e5c278&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any_skip_relocation</span>, <span class="symbol">x86_64_linux:</span>   <span class="string">&quot;e297731632b715118c13688acff976ce56c49df705ba2ae616445fb68cb49152&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  depends_on <span class="string">&quot;pkg-config&quot;</span> =&gt; <span class="symbol">:build</span></span><br><span class="line">  depends_on <span class="string">&quot;ruby&quot;</span></span><br><span class="line">  uses_from_macos <span class="string">&quot;libffi&quot;</span>, <span class="symbol">since:</span> <span class="symbol">:catalina</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">install</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Mac</span>OS.version &gt;= <span class="symbol">:mojave</span> &amp;&amp; <span class="title class_">Mac</span>OS::<span class="variable constant_">CLT</span>.installed?</span><br><span class="line">      <span class="variable constant_">ENV</span>[<span class="string">&quot;SDKROOT&quot;</span>] = <span class="variable constant_">ENV</span>[<span class="string">&quot;HOMEBREW_SDKROOT&quot;</span>] = <span class="title class_">Mac</span>OS::<span class="variable constant_">CLT</span>.sdk_path(<span class="title class_">Mac</span>OS.version)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="variable constant_">ENV</span>[<span class="string">&quot;GEM_HOME&quot;</span>] = libexec</span><br><span class="line">    system <span class="string">&quot;gem&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;cocoapods.gemspec&quot;</span></span><br><span class="line">    system <span class="string">&quot;gem&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;cocoapods-<span class="subst">#&#123;version&#125;</span>.gem&quot;</span></span><br><span class="line">    <span class="comment"># Other executables don&#x27;t work currently.</span></span><br><span class="line">    bin.install libexec/<span class="string">&quot;bin/pod&quot;</span>, libexec/<span class="string">&quot;bin/xcodeproj&quot;</span></span><br><span class="line">    bin.env_script_all_files(libexec/<span class="string">&quot;bin&quot;</span>, <span class="variable constant_">GEM_HOME</span>: <span class="variable constant_">ENV</span>[<span class="string">&quot;GEM_HOME&quot;</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  test <span class="keyword">do</span></span><br><span class="line">    system <span class="string">&quot;<span class="subst">#&#123;bin&#125;</span>/pod&quot;</span>, <span class="string">&quot;list&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Formula 包定义本质上是定义一个 <code>Formula</code>
的子类，将子类的名称转换成小写，以 <code>-</code> 代替驼峰命名，即可得到
homebrew 对应的应用名称，比如：<code>brew install cocoapods</code>。</p>
<p>Formula
包含一些必须的属性设置，比如：<code>desc</code>、<code>homepage</code>、<code>url</code>、<code>sha256</code>、<code>license</code>
等，用于描述应用的基本信息，源码下载地址，完整性校验值等。</p>
<p>此外，它支持了非常多的属性和方法，通过配置这些属性和方法，我们可以自定义应用的安装方式。比如：<code>bottle</code>
可以指定预编译二进制（针对不同系统）的相关配置；<code>depends_on</code>
可以指定应用安装所需的依赖；<code>install</code>
方法可以指定安装的具体操作，等等。关于 Formula
定义的更多细节，我们可以参考 <code>homebrew/homebrew-core</code>
中的其他示例，或者参考官方文档 <a
href="https://docs.brew.sh/Formula-Cookbook">Formula Cookbook</a>。</p>
<p>总而言之，对于非原生应用，homebrew 会根据对应的 Formula
包定义，去下载对应的二进制或源码，然后在本地进行构建、安装。</p>
<h2 id="cask">Cask</h2>
<p>Cask 是原生应用的包定义，如下所示是 SourceTree 的 Cask 定义。</p>
<figure class="highlight rb"><table><tr><td class="code"><pre><span class="line">cask <span class="string">&quot;sourcetree&quot;</span> <span class="keyword">do</span></span><br><span class="line">  on_sierra <span class="symbol">:or_older</span> <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;2.7.6a&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;d60614e9ab603e0ed158b6473c36e7944b2908d9943e332c505eba03dc1d829e&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://downloads.atlassian.com/software/sourcetree/Sourcetree_<span class="subst">#&#123;version&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;downloads.atlassian.com/software/sourcetree/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_high_sierra <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;3.2.1,225&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;4bd82affa3402814c3d07ff613fbc8f45da8b0cda294d498ffbb0667bf729c9f&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_mojave <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;4.2.1,248&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;3dac6ab514c7debe960339e2aee99f018342a41baf743dbb59524728b373561f&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_catalina <span class="symbol">:or_newer</span> <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;4.2.4,254&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;62dfaeedd63ac491ba3e49a5129d338c60886cb935e3654622147369023daf77&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/Appcast/SparkleAppcast.xml&quot;</span></span><br><span class="line">      strategy <span class="symbol">:sparkle</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  name <span class="string">&quot;Atlassian SourceTree&quot;</span></span><br><span class="line">  desc <span class="string">&quot;Graphical client for Git version control&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://www.sourcetreeapp.com/&quot;</span></span><br><span class="line"></span><br><span class="line">  auto_updates <span class="literal">true</span></span><br><span class="line">  depends_on <span class="symbol">macos:</span> <span class="string">&quot;&gt;= :el_capitan&quot;</span></span><br><span class="line"></span><br><span class="line">  app <span class="string">&quot;Sourcetree.app&quot;</span></span><br><span class="line">  binary <span class="string">&quot;<span class="subst">#&#123;appdir&#125;</span>/Sourcetree.app/Contents/Resources/stree&quot;</span></span><br><span class="line"></span><br><span class="line">  uninstall <span class="symbol">launchctl:</span> <span class="string">&quot;com.atlassian.SourceTreePrivilegedHelper2&quot;</span>,</span><br><span class="line">            <span class="symbol">quit:</span>      <span class="string">&quot;com.torusknot.SourceTreeNotMAS&quot;</span></span><br><span class="line"></span><br><span class="line">  zap <span class="symbol">trash:</span> [</span><br><span class="line">    <span class="string">&quot;~/Library/Application Support/com.apple.sharedfilelist/com.apple.LSSharedFileList.ApplicationRecentDocuments/com.torusknot.sourcetreenotmas.sfl2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Application Support/SourceTree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Caches/com.torusknot.SourceTreeNotMAS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Logs/Sourcetree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Preferences/com.torusknot.SourceTreeNotMAS.LSSharedFileList.plist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Preferences/com.torusknot.SourceTreeNotMAS.plist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Saved Application State/com.torusknot.SourceTreeNotMAS.savedState&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Cask 包定义本质上是初始化一个 cask
实例。它同样包含了一系列基本属性，如：<code>token</code>、<code>name</code>、<code>desc</code>、<code>homepage</code>、<code>app</code>、<code>url</code>、<code>sha256</code>
等。</p>
<p>Cask 的安装逻辑基上和 Formula 是类似的。示例中，SourceTree
针对不同平台提供了不同的下载地址和 sha256 校验值，如：sierra、high
sierra、mojave、catalina 等。</p>
<p>除此之外，Cask 也包含了大量的属性和方法，关于 Cask
的更多细节，我们可以参考 <code>homebrew/homebrew-cask</code>
中的其它示例，或者参考官方文档 <a
href="https://docs.brew.sh/Cask-Cookbook">Cask Cookbook</a>。</p>
<h1 id="外部命令">外部命令</h1>
<p>类似于 git，homebrew 也支持外部命令，通过这种方式可以允许用户对 brew
进行定制和扩展，其运行方式如下所示，<code>extcmd</code>
可以替换成任意自定义的子命令。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew extcmd --option1 --option2 &lt;formula&gt;</span><br></pre></td></tr></table></figure></p>
<p>Homebrew
支持外部命令，从编程语言实现角度而言，可以分两种，分别是：Ruby
和其他语言。从本质上而言，它们都是可执行的（chmod+ x）脚本，存放在
<code>PAHT</code> 环境变量的路径中，支持系统索引。</p>
<p>由于 homebrew 是使用 Ruby 实现的，因此基于 Ruby
的外部命令会比较特殊。只要我们将脚本命名为
<code>brew-extcmd.rb</code>（<code>extcmd</code>
可替换成任意自定义的子命令），homebrew 通过 <code>require</code>
加载后，<code>brew-extcmd.rb</code> 会进入 homebrew
的执行环境，因此可以访问 homebrew
定义的所有环境变量和功能模块，开发者可使用的工具和模块会非常多。</p>
<p>对于其他语言实现的脚本，脚本实现中必须使用 <code>#!</code>
来指定脚本的解释器，因此可支持 Python、Bash、Perl 等各种脚本语言。不同于
Ruby 脚本，对于其他语言的脚本，homebrew
要求脚本的名称不能有后缀，比如：<code>brew-extcmd.sh</code>
脚本必须命名为 <code>brew-extcmd</code>。在运行时，homebrew
会导入脚本参数和一部分环境变量。相比 Ruby 脚本而言，homebrew
对于其他语言的脚本，在功能上支持会相对弱一些。</p>
<p>上述两种方式都是在本地扩展外部命令，如果我们希望外部命令能给其他用户使用，那应该怎么办？对此，我们仍然可以通过
Taps 来实现。 类似于 Formula 使用 <code>Formula</code> 目录管理，Cask
使用 <code>Casks</code> 目录管理，对于外部命令，我们使用
<code>cmd</code>
管理外部命令的实现脚本。当然，外部命令的维护也分为官方仓库和自建仓库，只是官方仓库的要求和规范会更加严格。</p>
<p>关于外部命令的具体细节，我们可以参考
<code>homebrew/homebrew-core/cmd</code> 中的例子，也可以参考官方文档 <a
href="https://docs.brew.sh/External-Commands">External
Commands</a>。</p>
<h1 id="工作原理">工作原理</h1>
<p>整体而言，homebrew 的设计架构是比较清晰的。下面，我们来介绍 homebrew
中的一些重要设计的工作原理，主要包括：</p>
<ul>
<li>命令分发</li>
<li>软件搜索</li>
<li>软件安装</li>
</ul>
<h2 id="命令分发">命令分发</h2>
<p>命令分发是所有命令行工具的核心功能之一，绝大部分的设计思路是：<strong>通过入口脚本对命令进行解析，一个子命令匹配一个脚本，最终由对应的脚本来解析参数、选项，并执行</strong>。</p>
<p>Homebrew 也不例外，我们执行的 <code>brew</code> 命令本质上是一个指向
<code>Homebrew/bin/brew</code>
脚本的软链接，子命令、参数、选项都会作为脚本的输入进行解析。</p>
<p><code>Homebrew/bin/brew</code> 脚本的核心作用是
<strong>初始化一系列环境变量，并将导入 homebrew
的执行环境</strong>。它并没有对命令的参数和选项进行解析，而是直接转发给了
<code>Homebrew/brew.sh</code> 脚本。</p>
<p><code>Homebrew/brew.sh</code>
脚本的职责相对而言更多，主要包括以下几分部：</p>
<ul>
<li>初始化并导入一系列环境变量。</li>
<li>定义了一部分工具方法，主要包括：不同等级的打印方法、自动更新方法等。</li>
<li>处理根命令选项和特定子命令，直接派发至 <code>Homebrew/cmd/</code>
目录下对应的 Shell
脚本，比如：<code>shellenv.sh</code>、<code>--cellar.sh</code> 等。</li>
<li>设置执行环境，包括 CA 证书、语言设置、常用工具（git、curl）等。</li>
<li>处理命令缩写，比如：<code>brew ls</code> 识别为
<code>brew list</code>。</li>
<li>根据子命令加载 <code>Homebrew/cmd/</code> 目录下对应的 Shell
脚本，如果加载成功，则执行匹配的方法；否则将转发至
<code>Homebrew/brew.rb</code> 脚本继续解析。</li>
</ul>
<p><code>Homebrew/brew.rb</code> 脚本的职责相对简单，主要是负责处理
<code>Homebrew/brew.sh</code> 未识别的命令、选项、参数。上文，我们提到
brew 支持外部命令。因此，这里 <code>Homebrew/brew.rb</code>
处理了一部分的逻辑：</p>
<ul>
<li>查找内部的 <code>cmd</code> 和 <code>dev-cmd</code>
目录下对应的脚本，如果有则执行，否则进入下一步。</li>
<li>查找 <code>PATH</code> 路径和 Taps 路径下查找的符合
<code>brew-&lt;cmd&gt;.rb</code> 或 <code>brew-&lt;cmd&gt;</code>
模式的脚本，如果有则执行，否则报错。</li>
</ul>
<p>命令分发的整体流程如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="软件搜索">软件搜索</h2>
<p>当我们希望安装某个应用时，我们会使用
<code>brew search &lt;formula&gt;</code> 或
<code>brew search &lt;cask&gt; --cask</code> 来搜索一下 homebrew
是否支持安装该应用。</p>
<p>通过上述的介绍，我们很容易猜到软件搜索的逻辑，其核心原理就是借助 Taps
进行搜索和查找，包括官方的 <code>homebrew/homebrew-core</code> 和
<code>homebrew/homebrew-cask</code>，以及其他自定义的 Tap
仓库，从中查找各种 Formula 和 Cask
的定义，从而显示精确匹配或模糊匹配的应用。</p>
<h2 id="软件安装">软件安装</h2>
<p>上文提到包定义是用于辅助完成软件安装，在安装过程中，homebrew
会使用包定义中指定的 url 下载对应的源码或预编译二进制，并根据对应的
<code>sha256</code> 值校验其完整性，防止被替换或篡改。</p>
<p>如果包定义中指定了安装过程所需要的依赖，那么 homebrew
会先下载并安装对应的依赖。</p>
<p>然后，执行 <code>install</code>
方法进行安装，对于源码则需要编译、构建，对于预编译二进制则可以执行安装。</p>
<p>最后，为应用创建软链接，软链接的存储路径加入了 <code>PATH</code>
环境变量，因此可以被系统索引。</p>
<h1 id="总结">总结</h1>
<p>本文，我们首先介绍了 homebrew
中酿酒术语与软件术语的对应关系，从而理清了术语之间的关系，建立对
homebrew 的基本认知。然后介绍了 homebrew
安装的软件在文件系统中的存储结构、两种包定义的基本概念，以及外部命令的实现方式。最后介绍了
homebrew
中几个关键设计的工作原理，包括：命令分发、软件搜索、软件安装等。</p>
<p>这里我们没有深入探讨 homebrew
中的各种实现细节，而是着重介绍了整体的实现结构和理念。如果你有兴趣的话，可以自行探索其中的各种实现细节，相信也能获益不少。</p>
<p>通过学习开源软件的设计，我们能学到很多学习系统设计的方法，包括：如何规划软件的各个部分，比如，在什么地方存储日志，什么地方存储文件，软件的更新策略，软件的调度方式等。当然也能学到很多编程技巧，比如
homebrew 中对于 Shell
的使用，这些技巧简洁高效，能体现出作者深厚的编程功力。</p>
<p>后面，我还会继续学习各种开源软件的设计，总结并分享我的看法和理解~</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://github.com/Homebrew/brew">brew</a></li>
<li><a href="https://docs.brew.sh/">Homebrew Documentation</a></li>
<li><a href="https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap">How
to Create and Maintain a Tap</a></li>
<li><a href="https://docs.brew.sh/Formula-Cookbook">Formula
Cookbook</a></li>
<li><a href="https://docs.brew.sh/Cask-Cookbook">Cask Cookbook</a></li>
<li><a href="https://docs.brew.sh/External-Commands">External
Commands</a></li>
</ol>
]]></content>
      <categories>
        <category>开源软件</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
        <tag>Formula</tag>
        <tag>Cask</tag>
        <tag>Cellar</tag>
        <tag>Bottle</tag>
        <tag>Keg</tag>
      </tags>
  </entry>
  <entry>
    <title>二战欧洲东线战场战线动画--苏德战场</title>
    <url>/2019/09/07/world-war-2-su-de/</url>
    <content><![CDATA[<p>最近在网上看到一组视频，介绍二战时期苏德战场的战线动画演示过程。看了之后，对苏德战场有了更加深刻的理解。特此收藏。</p>
<span id="more"></span>
<h1 id="年">1941年</h1>
<div align=center>
<video src='https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1941.mp4' type='video/mp4' controls='controls' width='60%' height='60%'>
</div>
<h1 id="年-1">1942年</h1>
<div align=center>
<video src='https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1942.mp4' type='video/mp4' controls='controls' width='60%' height='60%'>
</div>
<h1 id="年1944年">1943年/1944年</h1>
<div align=center>
<video src='https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1943-to-1944.mp4' type='video/mp4' controls='controls' width='60%' height='60%'>
</div>
<h1 id="年1945年">1944年/1945年</h1>
<div align=center>
<video src='https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1944-to-1945.mp4' type='video/mp4' controls='controls' width='60%' height='60%'>
</div>
]]></content>
      <categories>
        <category>收录</category>
      </categories>
      <tags>
        <tag>二战</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业旅行——厦门</title>
    <url>/2014/05/27/xiamen/</url>
    <content><![CDATA[<p>清理照片时，看到了我们毕业旅行去厦门的照片，满满的都是回忆。想着好久都没写过博文了，就写一篇旅游回忆吧~</p>
<span id="more"></span>
<h1 id="day-1">Day 1</h1>
<p>5月18日启程，普快卧铺。从合肥站上车，目的地是厦门站。妹纸人生第一次坐火车，我却是第一次吃康师傅的新款泡面——爱鲜大餐。
<img
src="http://images.chuquan.me/xiamen/IMG_1788.JPG?x-oss-process=image/resize,w_600" />
这是我们的床铺~<br />
<img
src="http://images.chuquan.me/xiamen/IMG_1793.JPG?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-2">Day 2</h1>
<p>在火车进入福建境内后，开始在山区中曲折前行，路边的植物也开始热带化了，滴水观音什么的随处可见。抵达目的地已经是下午5点左右了，我们到来之前的厦门刚刚经历一场阵雨，空气中弥漫着浓厚的湿气。
下车后，我们在车站关于坐公交还是打的去旅馆纠结了一会儿，最终还是上了黑的。我们住的第一家旅馆是在曾厝垵，不过当时根本没发现这里居然离芙蓉隧道非常近。
<strong>品尝了当地的大青芒和路边摊~</strong> <img
src="http://images.chuquan.me/xiamen/IMG_1803.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1804.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1806.JPG@90r?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-3">Day 3</h1>
<p>计划去鼓浪屿，清晨的时候下着大雨，我们等到雨停了出发。到达码头后坐船进发鼓浪屿，抵达鼓浪屿的三丘田码头。
<strong>三丘田码头<sub><strong> <img
src="http://images.chuquan.me/xiamen/IMG_1819.JPG?x-oss-process=image/resize,w_600" />
</strong>导游图</sub></strong> <img
src="http://images.chuquan.me/xiamen/IMG_1823.JPG?x-oss-process=image/resize,w_600" />
鼓浪屿一眼望去都是些西洋楼，完整地保留着大使馆的样式。 <img
src="http://images.style.chuquan.me/xiamen/IMG_1824.JPG@90r?x-oss-process=image/resize,w_600" />
我们选了一条路线，这条路线的开始便是一道小巷子，有一侧是石墙，墙内红杏出墙，哈哈。
<img
src="http://images.chuquan.me/xiamen/IMG_1828.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1835.JPG@90r?x-oss-process=image/resize,w_600" />
转过小巷子便是一片文艺清新的民宅。 <img
src="http://images.style.chuquan.me/xiamen/IMG_1833.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1834.JPG@90r?x-oss-process=image/resize,w_600" />
每家宅子里都装饰的非常漂亮，花草满院。 <img
src="http://images.style.chuquan.me/xiamen/IMG_1838.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1842.JPG@90r?x-oss-process=image/resize,w_600" />
再往深处走便是各种古树与建筑交叠。 <img
src="http://images.chuquan.me/xiamen/IMG_1844.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1851.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1853.JPG@90r?x-oss-process=image/resize,w_600" />
我们的目的是先把行李放到岛上旅馆————程程家旮旯。 <img
src="http://images.chuquan.me/xiamen/IMG_1881.JPG?x-oss-process=image/resize,w_600" />
旅馆是在岛上，网上评分还挺高的，院子内的装饰布置都是很清新的。 <img
src="http://images.chuquan.me/xiamen/IMG_1854.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1857.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1864.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1867.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1869.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1873.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1874.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1879.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2059.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2061.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2065.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2067.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2068.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2070.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2071.JPG?x-oss-process=image/resize,w_600" />
行李放下后，可以肆意地潇洒了。
<strong>尝了尝当地的果子，好像叫奇异果，忘记叫什么名字了，有点酸<sub><strong>
<img
src="http://images.style.chuquan.me/xiamen/IMG_1894.JPG@90r?x-oss-process=image/resize,w_600" />
随后我们到了鼓浪屿著名的商业区，各种文艺小店铺依次呈现。 <img
src="http://images.style.chuquan.me/xiamen/IMG_1898.JPG@90r?x-oss-process=image/resize,w_600" />
</strong>闽台地区的肠粉</sub></strong> <img
src="http://images.chuquan.me/xiamen/IMG_1902.JPG?x-oss-process=image/resize,w_600" />
<strong>豆来豆去的土豆卷儿</strong> <img
src="http://images.style.chuquan.me/xiamen/IMG_1908.JPG@90r?x-oss-process=image/resize,w_600" />
然后就是各种奇葩小店铺。 <img
src="http://images.chuquan.me/xiamen/IMG_1910.JPG?x-oss-process=image/resize,w_600" />、
<img
src="http://images.chuquan.me/xiamen/IMG_1911.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1914.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1917.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1922.JPG?x-oss-process=image/resize,w_600" />
我们在来玩之前看了不少攻略推荐，美式什么的啥都少不了，挨个儿品尝。
<strong>林氏鱼丸</strong> <img
src="http://images.chuquan.me/xiamen/IMG_1927.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1929.JPG?x-oss-process=image/resize,w_600" />
<strong>马拉桑</strong>——有些桑果的味道 <img
src="http://images.style.chuquan.me/xiamen/IMG_1931.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1926.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1944.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1946.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1949.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1954.JPG@90r?x-oss-process=image/resize,w_600" />
<strong>沙茶面</strong> <img
src="http://images.chuquan.me/xiamen/IMG_1961.JPG?x-oss-process=image/resize,w_600" />
<strong>海蛎煎</strong> <img
src="http://images.chuquan.me/xiamen/IMG_1963.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1972.JPG@90r?x-oss-process=image/resize,w_600" />
后来到了一个环形的建筑内，顶部是敞空的，还有人在拍婚纱。 <img
src="http://images.chuquan.me/xiamen/IMG_1974.JPG?x-oss-process=image/resize,w_600" />
接着就转悠到了海边。 <img
src="http://images.chuquan.me/xiamen/IMG_1978.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_1980.JPG?x-oss-process=image/resize,w_600" />
<strong>虾扯蛋</strong>——有点像章鱼小丸子 <img
src="http://images.chuquan.me/xiamen/IMG_1988.JPG?x-oss-process=image/resize,w_600" />
旅游怎么能没有自拍呢 <img
src="http://images.chuquan.me/xiamen/IMG_2045.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2042.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_1986.JPG@90r?x-oss-process=image/resize,w_600" />
<strong>麻糍</strong>——感觉像是糯米团子 <img
src="http://images.chuquan.me/xiamen/IMG_1987.JPG?x-oss-process=image/resize,w_600" />
一逛就是一下午，来海边看一下日落。 <img
src="http://images.chuquan.me/xiamen/IMG_1996.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2005.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2012.JPG@90r?x-oss-process=image/resize,w_600" />
<strong>我也来个自拍吧</strong> <img
src="http://images.style.chuquan.me/xiamen/IMG_2013.JPG@90r?x-oss-process=image/resize,w_600" />
天很快进入夜色，我们海边找了家馆子，吃了些海瓜子什么的。 <img
src="http://images.chuquan.me/xiamen/IMG_2021.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2023.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2024.JPG?x-oss-process=image/resize,w_600" />
打开QQ，封面是520，因为这天正好是520，我们算好这天登陆鼓浪屿。 <img
src="http://images.chuquan.me/xiamen/IMG_2037.PNG?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-4">Day 4</h1>
<p>今天要离岛，我们出门便退了房，背上了行李，告别前，妹纸在墙上贴了留言。
<img
src="http://images.chuquan.me/xiamen/IMG_2077.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2083.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2088.JPG@90r?x-oss-process=image/resize,w_600" />
我们继续游览鼓浪屿，首先就是路经安献堂。安献堂门口是一条通幽曲径。 <img
src="http://images.style.chuquan.me/xiamen/IMG_2093.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2097.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2098.JPG@90r?x-oss-process=image/resize,w_600" />
然后，我们径直向日光岩出发，日光岩是鼓浪屿的制高点，在顶峰可以一览鼓浪屿全貌。
<img
src="http://images.chuquan.me/xiamen/IMG_2117.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2118.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2126.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2129.JPG?x-oss-process=image/resize,w_600" />
下一个目的地是郑成功纪念馆。 <img
src="http://images.style.chuquan.me/xiamen/IMG_2139.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2143.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2148.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2177.JPG@90r?x-oss-process=image/resize,w_600" />
<strong>我把你拍的那么美，你把我拍成一团黑~</strong> <img
src="http://images.style.chuquan.me/xiamen/IMG_2179.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2184.JPG?x-oss-process=image/resize,w_600" />
然后就是漫无目的的逛岛。 <img
src="http://images.chuquan.me/xiamen/IMG_2213.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2219.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2224.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2225.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2238.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2252.JPG@90r?x-oss-process=image/resize,w_600" />
大约中午，我们乘船离开了鼓浪屿。 <img
src="http://images.chuquan.me/xiamen/IMG_2255.JPG?x-oss-process=image/resize,w_600" />
回到第一天住的地方后，我们就去曾厝垵找传说中的亚尖大排档，不过并没有传说中那么好吃。
<img
src="http://images.style.chuquan.me/xiamen/IMG_2261.JPG@90r?x-oss-process=image/resize,w_600" />
饭后，曾厝垵必须逛一逛。 <img
src="http://images.style.chuquan.me/xiamen/IMG_2272.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2274.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2277.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2278.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2279.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2280.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2290.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2295.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2296.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2297.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2298.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2300.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2302.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2303.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2306.JPG@90r?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-5">Day 5</h1>
<p>清晨，下着小雨，我们启程去南普陀和厦大。 <img
src="http://images.style.chuquan.me/xiamen/IMG_2326.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2329.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2332.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2348.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2350.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2354.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2359.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2361.JPG@90r?x-oss-process=image/resize,w_600" />
南普陀的旁边就是厦大，和清北很像，厦大也是有很多人排队参观。 <img
src="http://images.style.chuquan.me/xiamen/IMG_2363.JPG@90r?x-oss-process=image/resize,w_600" /><br />
<img
src="http://images.chuquan.me/xiamen/IMG_2385.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2393.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2396.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2401.JPG@90r?x-oss-process=image/resize,w_600" />
<strong>芙蓉湖里好多鲶鱼</strong> <img
src="http://images.chuquan.me/xiamen/IMG_2413.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2417.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2419.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2426.JPG?x-oss-process=image/resize,w_600" />
前方便是芙蓉隧道，隧道有一公里长，在里面时间太久会有缺氧感，我们没有久留。
<img
src="http://images.chuquan.me/xiamen/IMG_2428.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2432.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2433.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2434.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2435.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2437.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2440.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2443.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2444.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2449.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2453.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2454.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2457.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2460.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2461.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2465.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2468.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2471.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2476.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2479.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.chuquan.me/xiamen/IMG_2481.JPG?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2484.JPG@90r?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-6">Day 6</h1>
<p>这天，天有小雨，我们逛了中山街，类似于各个城市的步行街，然后晚上去了湖里区，因为那里离机场比较近。
<img
src="http://images.style.chuquan.me/xiamen/IMG_2376.JPG@90r?x-oss-process=image/resize,w_600" />
<img
src="http://images.style.chuquan.me/xiamen/IMG_2378.JPG@90r?x-oss-process=image/resize,w_600" /></p>
<h1 id="day-7">Day 7</h1>
<p>在烟雨蒙蒙的清晨告别厦门。果然计划赶不上变化，我们有好多地方没有去玩，当然天气也是有原因的。如果是晴天，便可以允许骑行环岛路，游白城沙滩。童话村也没来得及去等等。以后有机会，我们还会再来的。
<img
src="http://images.chuquan.me/xiamen/IMG_2493.JPG?x-oss-process=image/resize,w_600" /></p>
<p>（完）</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>厦门</tag>
        <tag>鼓浪屿</tag>
        <tag>曾厝垵</tag>
      </tags>
  </entry>
  <entry>
    <title>《徐彬说投资》笔记</title>
    <url>/2018/02/23/xubing-investment/</url>
    <content><![CDATA[<p>几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记<a
href="https://note.youdao.com/share/?id=ce6a0c26ad775e2ac31665738ebfc131&amp;type=note#/">在这里</a>。</p>
<span id="more"></span>
<h1
id="如何计算自己有多少钱可以用于理财">如何计算自己有多少钱可以用于理财？</h1>
<p>对于我们普通人来说，每个月能够剩余下来的钱（<strong>自由现金流</strong>）均可以用于理财。自由现金流计算公式如下：
&gt; <strong>自由现金流 = 收入 - 支出</strong><br />
&gt; <strong>收入</strong> = 劳动收入（工资）<br />
&gt; <strong>支出</strong> = 必需支出（房租、房贷、生活费等） +
可选支出（娱乐费用）</p>
<p>因此，要想有多余的钱理财，必须保证自由现金流为正。如何保证自由现金流为正？两个方法：</p>
<ul>
<li><strong>开源</strong>：增加收入</li>
<li><strong>节流</strong>：减少支出</li>
</ul>
<p>很明显，自己容易控制的便是减少支出，其中<strong>可选支出</strong>可控程度是比较大的。</p>
<p>生活处处有风险，常见有两种风险可能会导致自由现金流为负：<strong>重大疾病</strong>、<strong>失业</strong>。为应对这两种风险，一般我们的措施是：</p>
<ul>
<li><strong>重大疾病</strong>：购买重疾险</li>
<li><strong>失业</strong>：预存应急资金。假设失业以后6个月后必能找到工作。可以将6个月的总支出定为应急资金。应急资金需要充分利用，应该放在货币基金，风险相对较小。</li>
</ul>
<p>一般而言，理财收入不能算入收入，各种奖金也不应该算入收入。通过上述公式便可计算出自己有多少钱可用于理财。</p>
<h1 id="理财的基本概念">理财的基本概念</h1>
<p>在理财前，投资者需要了解一下这些概念：</p>
<ol type="1">
<li><p>任何理财产品都是具有风险的，而风险的本质便是<strong>波动</strong>。比如：股票价格的涨跌波动。</p></li>
<li><p><strong>风险与收益成正比</strong>。另外还需要有充分的<strong>时间</strong>进行保障。</p></li>
<li><p><strong>可投资标的</strong>：哪些资产可以在自己的投资期限内进行投资。</p></li>
<li><p><strong>风险承受能力</strong>：评估可投资标的在投资期限内的最大投资亏损。很多投资亏损就是由于投资前没有评估好自己的风险承受能力，心态受到市场情绪影响导致的。</p></li>
</ol>
<h1 id="股票与债券">股票与债券</h1>
<p>我们都知道股票和债券，那么这两者是什么？有什么区别呢？</p>
<p>一切要从<strong>价值分配模型</strong>说起，价值分配模型包含两部分，分别是<strong>劳动价值</strong>、<strong>剩余价值</strong>。</p>
<p>一般来说，一个公司的资本分为两类：<strong>债券</strong>、<strong>股票</strong>。相应的投资人也分为两类：<strong>债券投资人</strong>、<strong>股票投资人</strong>（股东）。公司将其运营产生的<strong>剩余价值</strong>通过债券、股票分配给投资人。</p>
<blockquote>
<p>假设公司不用交税，一年挣了3千万（即剩余价值）。假设去年发行了一个亿3年期，每年利息10%的债券。那么公司的3千万，债券投资人拿走1千万（1亿
x 10%）。其他全部分给股票投资人。</p>
</blockquote>
<blockquote>
<p>如果一年收益1亿，债券投资人只能拿1千万，而股票投资人则可以拿9千万。</p>
</blockquote>
<p>相比而言，债券投资人获取收益的优先级更高，收益比股票投资人更明确。即无论有多少剩余价值，都优先分给债券投资人。在上述例子中，债券的收益是每年10%。而股票的风险比较大，对应的收益也可能更高。</p>
<p>通常，大企业的优势是收益稳定，劣势是发展空间有限；中小企业的优势是发展潜力，劣势是收益。因此，大企业的债券比较可靠，股票的增值空间相对较小；中小企业的债券短期内不一定有收益，长期来看其股票增值空间相对较大。</p>
<p>关于股票，公司分配给股票投资者的价值有两种方式：</p>
<ol type="1">
<li><strong>发放现金分红</strong></li>
<li><strong>股票价格上涨</strong>：如果公司在一段时间内的收益越高，希望投资的人越多，股票价格会变得越高。</li>
</ol>
<h1 id="货币基金">货币基金</h1>
<p>如果投资期限为一年，最好的投资标的是<strong>货币基金</strong>，如余额宝。货币基金是<strong>公募基金</strong>的一种。货币基金有以下优点：</p>
<ul>
<li>货币基金的门槛很低，一块钱都可以</li>
<li>货币基金的各种费用很低</li>
<li>风险极低</li>
<li>每天都有收益，包括节假日</li>
<li>货币基金非常灵活，买入后立刻产生收益。</li>
<li>货币基金往往在其他投资标的表现不好时，收益会更好。</li>
</ul>
<p>货币基金主要有两个指标:</p>
<ul>
<li><strong>七日年化收益率</strong>：过去七天平均每天的收益如果持续一年可以产生的收益</li>
<li><strong>万份收益</strong>：货币基金会保持每份一元的净值水平。因此，货币基金的总资产等于货币基金的总份数。每一万份货币基金，在过去一天产生的收益。</li>
</ul>
<p>那么为什么货币基金风险很低？这是因为货币基金的投资标的是<strong>短期国债</strong>、<strong>中央银行票据</strong>、<strong>银行背书的商业汇票</strong>、<strong>银行承兑汇票</strong>、<strong>银行定存</strong>、<strong>大额可转让存单</strong>等。这些都是金融投资风险最低。另一方面，货币基金的管理要求非常高，如果基金经理的货币基金做亏了，基本职业生涯完了。所以，货币基金的风险非常低。</p>
<p>货币基金适合投资期限小于一年，随取随存的场景，对于应急资金和工资来说非常适合。我们平时所用的余额宝、活期宝便是货币基金。相对其它投资标的，货币基金收益也较低，一年的收益率大概为4%左右。</p>
<h2 id="货币基金的4个投资技巧">货币基金的4个投资技巧</h2>
<ul>
<li>季度末，半年末，年末，货币基金的收益率比较高。</li>
<li>关注央行的行为。其会影响金融市场的流动性。央行加息，提高存款准备金率，会造成市场的钱变少，从而提高货币基金的收益率。</li>
<li>当股市、债市表现不好时候，往往货币基金表现较好（目前市场共有616支货币基金）。</li>
<li>平时买规模大（5亿元以上）的基金，收益比较稳定。在季度末、年底买规模较小（2亿~5亿）的基金博取高收益。</li>
</ul>
<h1 id="银行理财与货币基金">银行理财与货币基金</h1>
<p>根据如下2017年的数据显示，理财产品的期限越长，予以的收益也越多。 -
银行活期存款利息：一年0.35% - 一年期定期存款：一年1.5% -
三年期定期存款：每年2.75%</p>
<p>通常，银行理财都是定期，且5万元起购，这与货币基金的差距较大。另一方面，货币基金的监管比银行理财更严格。网上也经常爆出银行理财的一些骗局，我们可以通过网上银行来进行真伪辨认。</p>
<h1 id="国债逆回购">国债逆回购</h1>
<p>国债逆回购，本质就是一种短期贷款。也就是说，个人通过国债回购市场把自己的资金借出去，获得固定的利息收益；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p>
<p>投资者通过股票账户即可投资国债逆回购，国债逆回购具有以下几个基本特点：</p>
<ul>
<li><strong>国债逆回购的门槛</strong>：上证交易所，金额必须是10万的整数倍；深证交易所，金额必须是1000的整数倍。</li>
<li><strong>国债逆回购的价格</strong>：任何股票软件都可查询。</li>
<li><strong>国债逆回购的收益</strong>：价格、实际占款天数（1、2、3、7）。</li>
<li><strong>国债逆回购价格的规律</strong>：季度末、年末的利率较高。一般上午高于下午。</li>
</ul>
<h1 id="债券基金">债券基金</h1>
<p>根据2006至2016的数据显示，债券基金平均每年的收益大约为7%。债券的本质是发行债券的机构向投资者借钱，债券基金的收益主要包含两部分：</p>
<ul>
<li>利息</li>
<li>债券的价格波动</li>
</ul>
<p>目前市场中的债券基金一共有1000多只。通常而言，债券基金和股票基金呈跷跷板效应，两者的表现是相反的。</p>
<p><strong>通常不建议自选债券基金进行投资</strong>，其知识门槛较高。此外，债券基金进行为期1~2年的投资。长期投资债券基金必然是赚钱的。</p>
<h2 id="债券涨跌原理">债券涨跌原理</h2>
<p>在金融体系中钱多（收紧或加速流动性）的时候，债券就会上涨；反之，则下跌。</p>
<p>金融体系受两方面影响：</p>
<ul>
<li><strong>中央银行（中国人民银行，简称央行）货币政策</strong>：如加息降息</li>
<li><strong>影响金融机构买债的监管政策</strong></li>
</ul>
<p>央行主要有两个职能：控制物价（通货膨胀CPI）、维持经济增长（GDP增长率）。如果发生矛盾，以第一项为准。当CPI突破3%，表示通货膨胀过快，需要注意；GDP增长率较低时是投资债券的好时机。</p>
<h2 id="债券基金投资方法">债券基金投资方法</h2>
<p>债券基金有一个指标——<strong>到期收益率</strong>，表示如果债券没有出现违约，每年的收益率。债券收益率越高，则债券的估值越低。如果在三年期AA+企业债到期收益率超过5%时，投资债券基金，则未来三年，每年收益率大约为8%~10%。</p>
<p>相关数据表明，长期投资债券基金，亏钱的概率极低。对于债券基金的投资有两个建议：</p>
<ul>
<li>债券基金的到期收益率越高，投资债券基金赚得越多</li>
<li>债券基金应该越跌越买</li>
</ul>
<h1 id="什么决定了股票的价格">什么决定了股票的价格</h1>
<p>前面说到股票投资者的收益主要有两部分：<strong>分红</strong>、
<strong>股票价格的变化</strong>。那么股票的价格是由什么决定的呢？股票的价格可以通过如下公式进行计算：
&gt; <strong>股票的价格</strong> = <strong>盈利</strong>（每股的盈利） *
<strong>市盈率</strong>（每股市价与每股盈利的比率）</p>
<p>比如，某公司一年盈利1000万元，该公司有一亿股股票，则平均每股的盈利为0.1元。如果市盈率是10倍，即每1元的盈利能力是10元。通过公式计算得出，股票的价格为1元。
&gt; 1元（股票价格） = 0.1（每股的盈利）* 10（市盈率）</p>
<p>因此，市盈率是衡量股票价格高低的重要指标。<strong>市盈率是由股票市场中所有的股票投资者决定的</strong>。在绝大多数情况下，投资者的情绪比较稳定，市盈率也比较稳定。在某些情况下，投资者的情绪会出现集体波动，在投资者投资情绪乐观时，市盈率偏高；投资情绪悲观时，市盈率偏低。</p>
<h2 id="如何投资股票">如何投资股票</h2>
<p>首先需要评估市场的情绪，乐观、平稳还是悲观？因为投资者的情绪决定了市盈率。有两种评估方法：</p>
<ul>
<li><strong>定量分析</strong>：分析历史数据进行总结，对于沪深300指数，市盈率为12-14倍是合理的；对于中证500指数，市盈率为30-35倍是合理的。高于则是乐观，低于则是悲观。</li>
<li><strong>定性分析</strong>：观察财经媒体和大众市场的情绪。情绪乐观时会多买入，情绪悲观时会多卖出。比如：当很多不懂市场的投资者也在争相买入，则是非常乐观。</li>
</ul>
<p>在了解市场情绪之后，只需要做到三点：</p>
<ul>
<li>在市场情绪平稳时进行投资，但是不要把所有的前都投进去</li>
<li>在市场情绪悲观时，不仅自己不能恐慌，而应该鼓起勇气追加投资</li>
<li>在市场情绪乐观时，不应该追加投资，应该准备卖出</li>
</ul>
<h2 id="股票选择">股票选择</h2>
<p>一般而言，优质、稳定的投资标的应该会产生持续、稳定的<strong>内生收益</strong>。公司的盈利、收益是内生收益的来源。股票投资最重要的收益来源就是内生收益。持续、稳定的内生收益会让投资标的有不断上涨的动力。但是在单只股票中寻找能够产生持续、稳定内生收益的股票非常难。</p>
<p>投资者可以通过市场表现来挑选股票，比如每半年对A股上市公司进行市值排名，只投资排名前300的公司。A股市场最常用的两个指数是：<strong>沪深300指数</strong>、<strong>中证500指数</strong>。前者包含A股中市值最大的前300家公司；后者包含市值排名第301至800的500家公司。一般排名靠前的大公司，内生收益比较低，稳定性较高，长期收益低。
相对而言，中证500指数包含的公司内生收益相对较高，稳定性一般。</p>
<h2 id="ah优选">50AH优选</h2>
<p><strong>上证50指数</strong>：表示上海证券交易所上市的市值最大的50家公司。
<strong>50AH优选指数</strong>：看上证50指数中哪些公司在大陆和香港同时上市，挑选价格便宜的进行投资。</p>
<p>根据2015至2017年数据显示，50AH优选指数跑赢了上证50指数8个百分数。因此，投资者也可以根据50AH优选指数来进行股票选择</p>
<h1 id="基金的选择">基金的选择</h1>
<p>目前市场中共有3485只基金，其从投资标的上来分可分为三种：</p>
<ul>
<li><strong>货币基金</strong></li>
<li><strong>债券基金</strong></li>
<li><strong>股票基金</strong>：变数最大，主要是对比业绩基准。</li>
</ul>
<p>根据管理方式来分类，基金可以分为两类：</p>
<ul>
<li><strong>被动管理型基金</strong>（指数基金）：其跟随沪深300指数。管理费较低，每年0.7%。</li>
<li><strong>主动管理型基金</strong>：想尽一切办法打败业绩基准。研究员使用数据模型定量分析，管理费相对较高，每年1.5%。</li>
</ul>
<p>国外一个惊人的理论：绝大多数主动管理型基金很难跑过大盘指数。然而，在中国则截然相反，这是因为美国绝大部分的投资者是投资机构。中国股市有大量的散户，投资机构很容易跑赢散户。在中国，主动型管理基金更好。港股和美股则相反。在中国，股票基金平均收益率约为20%，沪深300每年约为10%。</p>
<h1 id="如何选择基金">如何选择基金</h1>
<p>股票基金的收益有两个来源：</p>
<ul>
<li>对标的股票指数的股票收益</li>
<li>股票基金跑赢股票指数的跑赢收益，即<strong>跑赢收益</strong>。跑赢收益是真正衡量基金经理能力的指标。</li>
</ul>
<p>选择基金的完整流程：</p>
<ul>
<li>第一步，选择未来会上涨的股票指数。只要股票指数的市盈率处于合理或偏低的水平，都可以选择。</li>
<li>第二步，在所有以这个股票指数为业绩基准，即对标的股票指数的股票基金里，选择跑赢收益比较高，且稳定性比较好的股票基金。量化基金的跑赢收益更低，稳定性更好。传统基金的跑赢收益更好，稳定性更差。</li>
<li>第三步，研究基金的策略，判断基金收益是否可持续。比如：通过基金经理访谈。</li>
</ul>
<h1 id="股票基金收益来源的终极公式">股票基金收益来源的“终极”公式</h1>
<blockquote>
<p><strong>股票基金的收益</strong> = <strong>对标股票指数的收益</strong>
+ <strong>跑赢收益</strong></p>
</blockquote>
<p><strong>股票指数</strong>是由若干股票组成，可以用于分析股票。每只股票都是一个公司的代表，绝大部分长期来说，其价值在不断提升。通常使用<strong>内生收益</strong>表示股票价值提升带来的收益。但是有内生收益不一定会带来投资收益。</p>
<p>股票价格的终极计算公式为，其中内生收益代表盈利的上升速度，长期来说内生收益都是正的。
&gt; <strong>股票价格</strong> = <strong>盈利</strong> *
<strong>市盈率</strong></p>
<p>那么应该如何确定内生收益？沪深300指数的内生收益和名义GDP增速差不多，稍微高一点。名义GDP和统计局公布的GDP不是一回事，后者是实际GDP增速，前者在实际GDP增速的基础上加上物价增速（即CPI）。名义GDP更多的体现实际的经济发展，更适合描述企业收入和盈利的增长速度。中国的GDP大概维持在6-7%，CPI大概在2%，所以名义GDP大概维持在8-9%。因此，沪深300指数的内生收益大约8-9%（非客观）。</p>
<p>另一方面，市盈率会围绕着合理水平波动。投资者给出的价格水平，乐观时比较高，悲观时比较低。当市盈率回归到合理水平的过程中，产生的收益叫<strong>储备收益</strong>。因此，可以得到股票指数的收益的公式。
&gt; <strong>股票指数的收益</strong> = <strong>内生收益</strong> +
<strong>储备收益</strong></p>
<p>进一步得出股票基金的收益公式： &gt; <strong>股票基金的收益</strong> =
<strong>内生收益</strong>（经济发展） +
<strong>储备收益</strong>（投资者心理波动） +
跑赢收益（基金经理的能力）</p>
<h1 id="定投">定投</h1>
<p>定投：表示定期、定额地投资某一个理财产品的投资方式。这是一种兼顾省心、高收益的投资方式。其适用于长期投资。例如：每个月买1000元的公募基金。</p>
<p>定投为何会赚钱？这是定投可以大幅降低投资风险，只要坚持就能赚钱。定投期间如果基金曲线呈现微笑曲线，则必然是赚钱的，即<strong>定投第一定理</strong>。</p>
<p>定投是一种守株待兔的方式，经济是由周期的，只要耐心定投，就肯定能赚钱。</p>
<h2 id="定投开始时机">定投开始时机</h2>
<p>在低于市盈率合理值时投资。在沪深300市盈率14倍或中证500市盈率35倍以下可以投。</p>
<h2 id="定投结束时机">定投结束时机</h2>
<p>3个原则：</p>
<ul>
<li>定投还没开始赚钱，永远不要考虑结束</li>
<li>只要股市估值还没有达到正常水平以上，就不要考虑退出。</li>
<li>当股市估值回到正常水平以上，应该跟随市场不断变化、计划卖出的点位，即止盈点。比如，当这轮行情市盈率跌倒最高点10%以下，止盈。</li>
</ul>
<h2 id="一个真实的定投案例">一个真实的定投案例</h2>
<p>3-5年长期的准备，定投。
2011年开始，定投沪深300指数4年，总收益80%，平均每年收益15.2%。
分为七个阶段</p>
<ul>
<li>2011年4月开始定投到A点，截止2011年12月27日累计亏损19%。从2011年4月开始，中国经济增长率从每年10%下调至8%。同时CPI很高，在2011年年终，达到了6%以上。央行通过加息来降低CPI。沪深300指数从2011年4月的3400点一路跌到年底的2300点，跌幅达到32%。</li>
<li>A点到B点，截止2012年5月累计盈利0.1%。从2011年底到2012年5月，沪深300指数从2300点反弹到2700点，赚0.1%。</li>
<li>B点到C点，截止2012年12月累计亏损17.5%。从2012年5月到2012年12月，沪深300指数开启长达8个月的下跌。从2700点跌至2100点，跌幅达到22%。创出了3年新低。</li>
<li>C点到D点，两年累计盈利8.7%。2012年12月5日的大涨，开启了一波小牛市。沪深300指数用了两个月一口气从2100点涨到了2800点附近，涨幅达到33%。</li>
<li>D点到E点，累计亏8.5%。2013年2月之后，沪深300指数开始调整，2013年6月开始从2600到2300，跌幅达到22%。2014年7月底，市盈率只有8.2倍，储备收益高达70%。</li>
<li>F点到完美结局，累计大赚80%。2014年7月到2015年6月，沪深300指数从2200点一路上涨到5380点，上涨幅度达到145%。</li>
</ul>
<p>定投总共4年2个月中，有3年3个月是处于亏损状态。是否掌握一定的定投知识将决定成败。经济每五年一个周期，对应到股市就是每5年一个大牛市。定投就是抓住这5年一次的牛市。定投很有可能三年不开张，开张顶三年！</p>
<h1 id="如何做投资决策">如何做投资决策</h1>
<p>做投资决策前需要做到以下几点：</p>
<ul>
<li>分析一笔钱可能出现的结果有哪几类？</li>
<li>对每一种结果评估概率</li>
<li>对每一种结果给出一种应对措施
<ul>
<li>如果赚钱了是否止盈，什么时候止盈</li>
<li>如果亏钱了是否止损，什么时候止损</li>
<li>如果赚钱了是否追加投资，什么时候</li>
<li>如果亏钱了是否追加投资，什么时候</li>
</ul></li>
</ul>
<p>在投资前思考风险可以让我们在投资过程中保持良好的心态。另外，还需要评估好投资周期、盈亏幅度。</p>
<p>关于如何控制风险？这里也有两种参考方式：</p>
<ul>
<li>选择一条移动平均线，一旦大盘跌破这条线就止损。根据历史数据显示，60天移动平均线是最优化的选择。</li>
<li>设定一个自己愿意接受的亏损比例，如10%。每天记录总资产额。当某天的总资产额比最高总资产额低10%时，可以止损了。</li>
</ul>
<h1 id="关于投资笔记">关于投资笔记</h1>
<p>投资笔记是执行投资、学习投资过程中一个非常重要且有意义的方式。投资笔记有以下优点：</p>
<ul>
<li>投资笔记可以帮我们指定投资决策，包括分析过程，思考逻辑，决策分析。投资是不能随机应变的。这是因为，一方面，投资相对比较复杂，需要实现做好预案。另一方面，投资是逆直觉，逆决策的。</li>
<li>投资笔记可以更好地帮助我们复盘。比如在投资过程中哪些地方做对了，结果及其原因又是什么。通过投资笔记，可以对每一个节点的行为逻辑和心态，复盘结果，更重要的是原因。</li>
<li>投资笔记可以帮助我们获得更多的知识。</li>
</ul>
<h1 id="投资时需要掌握的重要数据">投资时需要掌握的重要数据</h1>
<p>投资标的一定是不停生长出价值的投资标的。</p>
<ul>
<li><strong>经济增长率</strong>：经济增长率分为两种：<strong>季度增长率</strong>、<strong>年度增长率</strong>。GDP同比前一年同期增长多少。绝对值。增长率。实现国家经济调控的部门是央行，其主要有两个职责：<strong>控制物价</strong>、<strong>促进经济增长</strong>。当两者冲突时，往往以第一个为主。物价增长率（CPI），中文学名：通货膨胀率。和GDP不同，CPI是每个月都公布的。<strong>如何解读CPI数据：在中国如果CPI达到3%以上，说明物价增长过快了。这时候央行会通过加息，提高存款准备金率等方法来收紧货币。如果CPI跌倒了1%以下，说明物价增长过慢，意味着经济比较低迷，这时候央行会通过降息、降低存款金率等手段来刺激经济。如果CPI处于1~3%为健康状态，央行一般不会进行干涉</strong>。<strong>GDP在6.5%是合适的；CPI在1-3%是合适的。经济增长率的数据由国家统计局公布，www.stats.gov.cn</strong>。GDP和CPI能够勾勒出四个不同的经济周期，见下文。</li>
</ul>
<p>股票、债券方面的数据。</p>
<p>关于股票，A股共有3000多支股票，关注股票指数就够了，包括：<strong>上证50</strong>（超大规模）、<strong>沪深300</strong>（大规模）、<strong>中证500</strong>（中小规模）。平时需要关注着三个指数的盈利增长率和估值水平</p>
<ul>
<li><strong>估值水平</strong>：对于估值水平的描述一般用市盈率这个指标，<strong>对于上证50（10-12倍是合理的），对于沪深300（12-15倍是合理的），对于中证500（30-35倍是合理的）</strong>。如果低于，越跌越买；如果处理合理区间，继续持有；如果高于，原则上是不能追加，应该持有+设置好止盈条件等策略。</li>
<li><strong>盈利增长率</strong>：必须等每个季度上司公司的财报都公布了以后才知道。与GDP类似，盈利增长的趋势比绝对值更加重要。如果盈利增长在减速，股市的增长水平（市盈率水平）就会下降。如果盈利增长在加速，市盈率就会上升。由于关注的是指数的盈利增长，而这些指数包含的公司都是整个经济体系中的中流砥柱，因此可以用GDP的增长趋势来估计指数盈利增长的趋势。</li>
</ul>
<blockquote>
<p>估值水平：每周六公众号公布；盈利增长率：可以用GDP估算。</p>
</blockquote>
<p>债券</p>
<ul>
<li><strong>到期收益率</strong>：如果持有债券到期，并且借钱的机构没有耍赖不还钱的情况，投资者平均每年能赚百分之多少。不同期限，不同评级的债券的到期收益率都不一样。一般来说，关注三年期，AA+的企业债券的到期收益率就够了。只要这个数据高于5%，投资债券基金都是比较安全的，未来1-2年的收益也是比较可观的。</li>
</ul>
<h1
id="美林团队判断经济周期转折点的重点理论">美林团队判断经济周期转折点的重点理论</h1>
<p><strong>美林时钟理论</strong>：只用经济增长率（GDP增速）和通货膨胀率（CPI增速）两个宏观经济指标来描述复杂的经济周期。</p>
<p>运用美林时钟理论，在2006年至2016年，通过资产配置获得11.5倍的收益。全国房价平均每年的年化收益率只有8%。北京的房价平均每年的年化收益率15%。之所以房子赚钱，是因为房价稳定，愿意长期持，复利使得房子显得很赚钱。数据显示，资产配置如果做好了，可以比投资房产更赚钱。</p>
<p>美林时钟理论用到两个宏观经济指标：<strong>GDP增长率</strong>（描述经济增长速度），<strong>CPI增长率</strong>（描述通货膨胀速度）</p>
<ul>
<li><strong>GDP增长率高、CPI增长率低：复苏期</strong></li>
<li><strong>GDP增长率高、CPI增长率高：过热期</strong></li>
<li><strong>GDP增长率低、CPI增长率高：滞障期</strong></li>
<li><strong>GDP增长率低、CPI增长率低：衰退期</strong></li>
</ul>
<p><strong>1 -&gt; 2 -&gt; 3 -&gt; 4：美林时钟</strong></p>
<blockquote>
<p>复苏期：重仓股票基金（下一周期GDP仍高）。债券的表现不会差（一时半会不会加息，持有债券去赚利息），应该紧盯通胀，高通货膨胀来了应该减仓。</p>
</blockquote>
<blockquote>
<p>过热期：中国股市会快速、甚至疯狂上涨。股票继续持有。不应该持有债券基金。关注熊市出现。</p>
</blockquote>
<blockquote>
<p>滞涨期：股票基金表现不会，不应该持有。债券不太好。这个时期的目标是不亏钱。应该投资货币基金。</p>
</blockquote>
<blockquote>
<p>衰退期：其末期是特别好的抄底机会。重仓持有债券基金。密切关注股票基金。关注股票基金减仓机会。</p>
</blockquote>
<p>（完）</p>
]]></content>
      <categories>
        <category>投资理财</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>猿辅导招聘</title>
    <url>/2020/04/01/yuanfudao-zhaopin/</url>
    <content><![CDATA[<p>猿辅导公司研发岗位持续招聘中...</p>
<span id="more"></span>
<p>社招、校招、实习生...</p>
<p>发送简历至：baocq@fenbi.com，投递时请注明投递岗位</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/others/yuanfudao-zhaopin01.png?x-oss-process=image/resize,w_800" /></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>校招</tag>
        <tag>社招</tag>
        <tag>猿辅导校招</tag>
        <tag>猿辅导社招</tag>
        <tag>猿辅导实习</tag>
        <tag>猿辅导</tag>
      </tags>
  </entry>
  <entry>
    <title>Zsh 自动补全脚本入门</title>
    <url>/2020/10/02/zsh-completion-tutorial/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zsh-completion.jpeg?x-oss-process=image/resize,w_800" /></p>
<span id="more"></span>
<h1 id="入门基础">入门基础</h1>
<h2 id="zsh-如何补全一个命令">zsh 如何补全一个命令</h2>
<p>命令的补全方法保存在以下划线 <code>_</code>
开头的补全文件中，这些文件通常保存在 <code>$fpath</code>
变量所指定的路径下。当然，我们也通过可以在 <code>~/.zshrc</code>
文件中增加如下一行代码，从而给 <code>$fpath</code>
新增一个搜索路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fpath=(~/newdir <span class="variable">$fpath</span>)</span><br></pre></td></tr></table></figure>
<p>补全文件的第一行定义如下所示： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#compdef foobar</span></span><br></pre></td></tr></table></figure></p>
<p>上述这行代码表示本文件定义了为 <code>foobar</code>
命令进行自动补全的代码。</p>
<p>我们还可以直接使用 <code>compdef</code> （比如：在
<code>~/.zshrc</code>
中）命令指定将哪个方法作为自动补全的补全方法，如下所示：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; compdef _function foobar</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我们还可以同时为多个命令指定同一个补全方法。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; compdef _function foobar goocar hoobar</span><br></pre></td></tr></table></figure></p>
<p>甚至，还可以传递参数至补全方法中。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; compdef <span class="string">&#x27;_function arg1 arg2&#x27;</span> foobar</span><br></pre></td></tr></table></figure></p>
<p>更多细节参见 <a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Functions-4">传送门</a>。</p>
<h2 id="通用-gnu-命令补全">通用 GNU 命令补全</h2>
<p>很多 GNU 命令都有着一套标准的方式来对选项的描述进行罗列显示（当使用
<code>--help</code> 选项时）。对于这些命令，我们可以使用
<code>_gnu_generic</code> 方法自动创建补全方法，如下所示：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; compdef _gnu_generic foobar</span><br></pre></td></tr></table></figure></p>
<p>当然，也可以同时为多个命令指定 <code>_gnu_generic</code> 补全方法。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; compdef _gnu_generic foobar goocar hoodar</span><br></pre></td></tr></table></figure></p>
<p>这行代码可以直接添加到 <code>~/.zshrc</code> 中。</p>
<h2 id="复制补全功能">复制补全功能</h2>
<p>假设我们希望一个命令 <code>cmd1</code> 具有与 <code>cmd2</code>
一样的补全功能，并且 <code>cmd2</code>
的自动补全功能已经定义好了，那么我们可以使用如下方式进行复制。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; compdef cmd1=cmd2</span><br></pre></td></tr></table></figure></p>
<p>当我们为一个命令创建了一个 <code>alias</code>
时，使用这种方式可以完整复制原始命令的补全功能！</p>
<h1 id="如何编写补全方法">如何编写补全方法</h1>
<p>那么，如何编写属于我们自己的补全方法呢？照葫芦画瓢是一种非常好的上手方式。我们可以阅读一些别人写的补全方法。在本机的文件系统下，我们可以通过
<code>$fpath</code>
环境变量去搜索已有的补全功能文件，比如：<code>/usr/local/share/zsh/site-functions</code>。</p>
<p>我们可以看到有一个 <code>_arguments</code>
方法在这些补全功能文件中被大量使用。<code>_arguments</code>
是一个可以快速实现简单补全功能的工具方法。本质上，<code>_arguments</code>
方法是对内置方法 <code>compadd</code> 进行了封装。内置方法
<code>compadd</code>
是将补全单词添加至命令行，并控制补全行为的关键方法。不过，在大多数情况下，我们都不需要使用
<code>compadd</code> 方法，因为 zsh 提供了大量类似
<code>_arguments</code>、<code>_describe</code>
这样的工具方法，简单易用。</p>
<p>对于非常简单的补全功能，<code>_describe</code> 方法甚至都够用了。</p>
<h2 id="工具方法">工具方法</h2>
<p>本文仅罗列一部分常用的工具方法。完整的工具方法及其使用说明，参见 <a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-Functions">传送门</a>。</p>
<p>本节我们将简单介绍一部分常用的工具方法，下一节我们将介绍如何使用这些工具方法。</p>
<h3 id="用于整体补全功能的工具方法">用于整体补全功能的工具方法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>_alternative</code></td>
<td style="text-align: left;">用于生成补全候选列表</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_arguments</code></td>
<td
style="text-align: left;">用于指定如何对一个命令进行选项补全和参数补全，采用
UNIX 风格选项</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_describe</code></td>
<td
style="text-align: left;">用来创建仅由单词、描述信息组成的简单补全（不包含
Action）。比 <code>_arguments</code> 方法更简单</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_gnu_generic</code></td>
<td style="text-align: left;">用来为能够响应 <code>--help</code>
选项的命令进行补全</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_regex_arguments</code></td>
<td
style="text-align: left;">创建一个方法，能够使用正则表达式匹配命令行参数，从而执行
Action 或补全方法</td>
</tr>
</tbody>
</table>
<h3 id="为单个单词进行复杂补全的方法">为单个单词进行复杂补全的方法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>_values</code></td>
<td
style="text-align: left;">用于为任意关键词（值）及其参数进行补全，或者此类组合的逗号分隔列表</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_combination</code></td>
<td
style="text-align: left;">用于补全值的组合，比如：<code>hostname</code>
和 <code>username</code> 的组合</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_multi_parts</code></td>
<td
style="text-align: left;">用于对单词的多个部分进行补全，其中每个部分使用某个字符分隔，例如对部分文件路径进行补全：<code>/u/i/sy</code>
补全为 <code>/usr/include/sys</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_sep_parts</code></td>
<td style="text-align: left;">类似
<code>_multi_parts</code>，不过它允许不同的补全部分使用不同的分隔符</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_sequence</code></td>
<td
style="text-align: left;">用于封装另一个补全方法，从而对另一个补全方法生成的匹配项进行补全</td>
</tr>
</tbody>
</table>
<h3
id="为指定类型的对象进行补全的方法">为指定类型的对象进行补全的方法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>_path_files</code></td>
<td
style="text-align: left;">用于补全文件路径。有多个选项可以控制其行为</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_files</code></td>
<td style="text-align: left;">使用除了 <code>-g</code> 和
<code>-/</code> 以外的所有选项调用 <code>_path_files</code>
方法。这些选项取决于文件模式样式设置</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_net_interfaces</code></td>
<td style="text-align: left;">用于补全网络接口名称</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_users</code></td>
<td style="text-align: left;">用于补全用户名</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_groups</code></td>
<td style="text-align: left;">用于补全用户组名称</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_options</code></td>
<td style="text-align: left;">用于补全 shell 选项的名称</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_parameters</code></td>
<td style="text-align: left;">用于补全 shell
参数、变量的名称（可以限定为与模式匹配的名称）</td>
</tr>
</tbody>
</table>
<h3 id="处理已缓存补全逻辑的方法">处理已缓存补全逻辑的方法</h3>
<p>如果我们有大量的补全，可以将它们保存在缓存文件中，以便快速加载。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>_cache_invalid</code></td>
<td
style="text-align: left;">设置指定的缓存标识符对应的补全逻辑是否需要重建</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_retrieve_cache</code></td>
<td style="text-align: left;">从缓存文件中检索补全逻辑信息</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_store_cache</code></td>
<td
style="text-align: left;">将指定的缓存标识符对应的补全逻辑信息存储在缓存文件中</td>
</tr>
</tbody>
</table>
<h3 id="其他方法">其他方法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>_message</code></td>
<td style="text-align: left;">用于在无法补全时显示帮助信息</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_regex_words</code></td>
<td style="text-align: left;">用于为 <code>_regex_arguments</code>
命令生成调用参数。比手动编写参数更简单</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_guard</code></td>
<td style="text-align: left;">可以在 <code>_arguments</code>
的调用参数的 <code>ACTION</code>
部分中使用，也可以在类似的方法用来检查单词是否已补全</td>
</tr>
</tbody>
</table>
<h3 id="action">Action</h3>
<p>类似
<code>_arguments</code>、<code>_regex_arguments</code>、<code>_alternative</code>、<code>_value</code>
这样的工具方法，它都都可以有一系列的调用参数。不过这些参数都遵循了一些预定义格式（或规范）的字符串，我们称之为
<strong>参数格式</strong>，每个参数格式的最后一个参数/选项是 Action
部分。<strong>Action 表示如何补全相应的参数</strong>。Action
可以有多种类型：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>()</code></td>
<td
style="text-align: left;">参数是必须的，但是没有匹配项。相当于空白占位符</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>(ITEM1 ITEM2)</code></td>
<td style="text-align: left;">可能的匹配列表</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>((ITEM1\:'DESC1' ITEM2\:'DESC2'))</code></td>
<td style="text-align: left;">可能的匹配列表，附带描述信息。注意：Action
中的引号不能和其所在的参数格式字符串的引号相同</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-&gt;STRING</code></td>
<td style="text-align: left;">将 <code>$state</code> 设置为 STRING
并继续后续逻辑（当工具方法被调用后，可以使用 <code>case</code> 语句检查
<code>$state</code>）</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>FUNCTION</code></td>
<td
style="text-align: left;">将要调用的方法名称，该方法能够生成匹配项或调用其他
Action，如：<code>_file</code>、<code>_message</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&#123;EVAL-STRING&#125;</code></td>
<td style="text-align: left;">将字符串作为 Shell
代码执行，可以生成匹配项。也可以调用工具方法并传入参数，如：<code>_values</code>、<code>_describe</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>=ACTION</code></td>
<td
style="text-align: left;">在不改变补全位置节点的情况下，向补全命令行中插入一个伪单词</td>
</tr>
</tbody>
</table>
<p>注意：并不是所有的工具方法都可以使用所有类型的
Action。比如：<code>_regex_arguments</code>、<code>_alternative</code>
方法不能使用 <code>-&gt;STRING</code> 类型。</p>
<h2 id="基于-_describe-的简单补全功能">基于 <code>_describe</code>
的简单补全功能</h2>
<p><code>_describe</code> 方法可用于
<strong>选项/参数的顺序和位置并不重要</strong>
的简单补全功能。我们只需要创建一个数组参数来持有选项及其描述信息，然后将这个数组参数作为一个参数传递给
<code>_describe</code>。下面的例子中，创建了两个补全候选项
<code>c</code> 和
<code>d</code>，并提供了描述信息（注意：代码应该定义在名为
<code>_cmd</code> 文件中，并位于 <code>$fpath</code> 的路劲下）：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#compdef cmd</span></span><br><span class="line"><span class="built_in">local</span> a -subcmds</span><br><span class="line">subcmds=(<span class="string">&#x27;c:description for c command&#x27;</span> <span class="string">&#x27;d:description for d command&#x27;</span>)</span><br><span class="line">_describe <span class="string">&#x27;command&#x27;</span> subcmds</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我们还可以向 <code>_describe</code>
方法传入多个不同的列表，并使用 <code>--</code> 进行分隔。
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">local</span> -a subcmds topics</span><br><span class="line">subcmds=(<span class="string">&#x27;c:description for c command&#x27;</span> <span class="string">&#x27;d:description for d command&#x27;</span>)</span><br><span class="line">topics=(<span class="string">&#x27;e:description for e help topic&#x27;</span> <span class="string">&#x27;f:description for f help topic&#x27;</span>)</span><br><span class="line">_describe <span class="string">&#x27;command&#x27;</span> subcmds -- topics</span><br></pre></td></tr></table></figure></p>
<p>如果两个候选项的描述信息相同，<code>_describe</code>
会将两者合并到同一行，并确保所有候选项的描述信息列对齐。<code>_describe</code>
方法可以用在
<code>_alternative</code>、<code>_arguments</code>、<code>_regex_arguments</code>
的参数格式中的 <code>ACTION</code>
部分。在这种情况下，我们必须将其与参数放在一起，如：<code>'TAG:DESCRIPTION:&#123;_describe 'value' options'&#125;</code></p>
<h2 id="基于-_alternative-的补全功能">基于 <code>_alternative</code>
的补全功能</h2>
<p>与 <code>_describe</code> 方法类似，<code>_alternative</code>
方法可用于 <strong>选项/参数的顺序和位置并不重要</strong>
的简单补全功能。与 <code>_describe</code>
方法不同，<code>_alternative</code>
方法并不使用固定的匹配项，而是调用其他方法来生成候选项。此外，<code>_alternative</code>
允许混合使用不同类型的补全候选项。</p>
<p><code>_alternative</code> 方法的参数格式是
<code>'TAG:DESCRIPTION:ACTION'</code>。其中，<code>TAG</code>
指定补全匹配项的类型；<code>DESCRIPTION</code>
表示补全候选项列表的描述信息；<code>ACTION</code> 则是前文所描述的一种
Action 类型（<code>_alternative</code> 不支持 <code>-&gt;STRING</code>
和 <code>=ACTION</code> 类型）。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_alternative <span class="string">&#x27;arguments:custom arg:(a b c)&#x27;</span> <span class="string">&#x27;files:filename:_files&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><code>_alternative</code> 方法的第一个参数中加入了三个候选项
<code>a</code>、<code>b</code>、<code>c</code>；第二个参数调用了
<code>_files</code> 方法来对文件路径进行补全。</p>
<p>我们可以将 <code>_alternative</code> 方法参数分成多行，使用
<code>\</code> 进行换行。如下所示，为每个自定义参数添加了描述信息：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_alternative \</span><br><span class="line">  <span class="string">&#x27;args:custom arg:((a\:&quot;description a&quot; b\:&quot;description b&quot; c\:&quot;description c&quot;))&#x27;</span> \</span><br><span class="line">  <span class="string">&#x27;files:filename:_files&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们想把参数传递给 <code>_files</code>
方法，可以像下面一下直接包含进来： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_alternative \</span><br><span class="line">  <span class="string">&#x27;args:custom arg:((a\:&quot;description a&quot; b\:&quot;description b&quot; c\:&quot;description c&quot;))&#x27;</span>\</span><br><span class="line">  <span class="string">&#x27;files:filename:_files -/&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>如果想使用参数扩展来创建补全列表，我们需要使用双引号来引用
<code>_alternative</code> 方法的调用参数。如下所示为一个简单示例：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_alternative \</span><br><span class="line">  <span class="string">&quot;dirs:user directory:(<span class="variable">$userdirs</span>)&quot;</span> \</span><br><span class="line">  <span class="string">&quot;pids:process ID:(<span class="subst">$(ps -A | awk &#x27;&#123;print $1&#125;&#x27;)</span>)&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，第一个调用参数添加了存储在 <code>$userdirs</code>
变量中的单词，第二个调用参数则执行 <code>ps -A | awk '&#123;print $1&#125;'</code>
来获取一系列的 PID
以作为补全候选项。在实际开发中，我们可以直接使用已有的
<code>_pids</code> 方法。</p>
<p>我们还可以在 <code>ACTION</code>
中使用其他的工具方法（如：<code>_values</code>）来生成实现更加复杂的补全功能，如下所示为一个简单示例：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_alternative \</span><br><span class="line">  <span class="string">&quot;directories:user directory:(<span class="variable">$userdirs</span>)&quot;</span> \</span><br><span class="line">  <span class="string">&#x27;options:comma-separated opt: _values -s , letter a b c&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>上述例子会对 <code>$userdirs</code> 中的项进行补全，同时也会对包含
<code>a</code>、<code>b</code>、<code>c</code>
的逗号分隔列表进行补全。注意：在 <code>_values</code>
方法前需要有一个初始的空格。</p>
<p>和 <code>_describe</code> 方法一样，<code>_alternative</code>
方法自身也可以作为
<code>_arguments</code>、<code>_regex_arguments</code>
等方法的调用参数中的 <code>ACTION</code> 部分。</p>
<h2 id="基于-_arguments-的补全功能">基于 <code>_arguments</code>
的补全功能</h2>
<p>通过调用 <code>_arguments</code>
方法，我们就能够实现复杂的补全功能。<code>_arguments</code>
方法能够处理带有各种选项及常规参数的命令。与
<code>_alternative</code>，<code>_arguments</code>
方法相似，它以格式化的字符串作为其调用参数。这些格式化参数能够指定选项及其对应的选项参数（如：<code>-f filename</code>）、命令参数。</p>
<p><code>_arguments</code> 方法的调用参数的基本参数格式为
<code>-OPT[DESCRIPTION]</code>，如下所示为一个简单示例：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_arguments <span class="string">&#x27;-s[sort output]&#x27;</span> <span class="string">&#x27;--l[long output]&#x27;</span> <span class="string">&#x27;-l[long output]&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>稍微复杂一点的 <code>_arguments</code> 方法的参数格式可以是
<code>-OPT[DESCRIPTION]:MESSAGE:ACTION</code>。其中，<code>MESSAGE</code>
和 <code>ACTION</code> 的含义与上述 <code>_alternative</code>
中描述的一样。如下所示为一个简单示例： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_arguments <span class="string">&#x27;-f[input file]:filename:_files&#x27;</span> </span><br></pre></td></tr></table></figure></p>
<p><code>_arguments</code> 方法的参数格式还可以是
<code>N:MESSAGE:ACTION</code>。其中，<code>N</code> 表示第 N
个命令参数，<code>MESSAGE</code> 和 <code>ACTION</code>
还是和之前一样。如果省略
<code>N</code>，则仅表示下一个命令参数（在已指定的参数之后）。如果在
<code>N</code> 的前面或后面加上冒号
<code>:</code>，则表示参数是可选的。如下为一个简单的示例：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_arguments <span class="string">&#x27;-s[sort output]&#x27;</span> <span class="string">&#x27;1:first arg:_net_interfaces&#x27;</span> <span class="string">&#x27;::optional arg:_files&#x27;</span> <span class="string">&#x27;:next arg:(a b c)&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>上面这个例子中，第一个参数是网络接口名，下一个可选参数是一个文件名，最后一个参数是
<code>a</code>、<code>b</code>、<code>c</code> 其中之一，<code>s</code>
选项可以在任意位置进行补全。</p>
<p><code>_arguments</code> 方法支持上述所有类型的
<code>ACTION</code>。这样的话，我们可以使用 <code>case</code>
分支来调用不同的 Action。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_arguments <span class="string">&#x27;-m[music file]:filename:-&gt;files&#x27;</span> <span class="string">&#x27;-f[flags]:flag:-&gt;flags&#x27;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$state</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    files)</span><br><span class="line">        <span class="built_in">local</span> -a music_files</span><br><span class="line">        music_files=( Music/**/*.&#123;mp3,wav,flac,ogg&#125; )</span><br><span class="line">        _multi_parts / music_files</span><br><span class="line">        ;;</span><br><span class="line">    flags)</span><br><span class="line">        _values -s , <span class="string">&#x27;flags&#x27;</span> a b c d e</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，music file 的路径调用 <code>_multi_parts</code>
方法来进行目录补全；flags 则可以调用 <code>_value</code> 方法，以逗号
<code>,</code> 分隔列表的形式进行补全。</p>
<p>本节，我们简单地介绍了 <code>_arguments</code>
方法的基本使用方法，当然，我们还可以指定互斥选项、重复选项/参数、以
<code>+</code> 开头而非 <code>-</code>
开头的选项等等。更多的使用方法，可以参见<a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">官方教程</a>。此外，还可以参考本文末尾提到的教程。</p>
<h2 id="基于-_regex_arguments-和-_regex_words-的补全功能">基于
<code>_regex_arguments</code> 和 <code>_regex_words</code>
的补全功能</h2>
<p>如果我们有一个复杂的命令行格式，它有多种可能的参数序列，那么
<code>_regex_arguments</code> 方法可能就是一个比较适合的补全方法。</p>
<p><code>_regex_arguments</code>
方法会创建一个补全方法，补全方法的名字由第一个调用参数指定。因此，我们需要先调用
<code>_regex_arguments</code>
方法来创建补全方法，然后再调用该补全方法。如下所示： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_regex_arguments _cmd OTHER_ARGS..</span><br><span class="line">_cmd <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>上述例子中， <code>OTHER_ARGS</code>
用于匹配并补全命令行中的单词，其可以是多个调用参数列表。这些调用参数列表可以用
<code>'|'</code>
进行二选一。我们还可以使用括号来指定选择的层级，不过，括号必须使用斜杠
<code>\</code> 或引号 <code>''</code> 进行转义，
如：<code>\(</code>、<code>\)</code> 或
<code>'('</code>、<code>')'</code>。</p>
<p>如下所示为一个简单示例： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_regex_arguments _cmd SEQ1 <span class="string">&#x27;|&#x27;</span> SEQ2 \( SEQ2a <span class="string">&#x27;|&#x27;</span> SEQ2b \)</span><br><span class="line">_cmd <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>上述例子中，指定了一个与 <code>SEQ1</code> 或 <code>SEQ2</code>（后跟
<code>SEQ2a</code> 或
<code>SEQ2b</code>）相匹配的命令行。这本质上就是使用正则表达式描述命令行的参数。</p>
<p>每个调用参数列表之前必须包含一个 <code>/PATTERN/</code>
部分，后跟一个可选的 <code>:TAG:DESCRIPTION:ACTION</code> 部分。</p>
<p>每个 <code>PATTERN</code>
是一个正则表达式，用于匹配命令行上的一个单词。这些模式（pattern）会被顺序处理，直到遇到一个不匹配的模式，此时将执行对应的
Action 以得到该单词的补全项。</p>
<p>注意，必须要有一个模式来匹配命令自身。后面，我们将进一步介绍
<code>PATTERN</code>。</p>
<p><code>_regex_arguments</code> 方法参数中
<code>:TAG:DESCRIPTION:ACTION</code> 部分的含义与
<code>_alternative</code> 方法参数类似，不同的地方在于
<code>_regex_arguments</code> 中开头多了一个
<code>:</code>，此外，它还允许调用所有的 Action 类型。</p>
<p>如下所示为一个简单示例： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_regex_arguments _cmd /$<span class="string">&#x27;[^\0]##\0&#x27;</span>/ \( /$<span class="string">&#x27;word1(a|b|c)\0&#x27;</span>/ <span class="string">&#x27;:word:first word:(word1a word1b word1c)&#x27;</span> <span class="string">&#x27;|&#x27;</span>\</span><br><span class="line">   /$<span class="string">&#x27;word11(a|b|c)\0&#x27;</span>/ <span class="string">&#x27;:word:first word:(word11a word11b word11c)&#x27;</span> \( /$<span class="string">&#x27;word2(a|b|c)\0&#x27;</span>/ <span class="string">&#x27;:word:second word:(word2a word2b word2c)&#x27;</span>\</span><br><span class="line">   <span class="string">&#x27;|&#x27;</span> /$<span class="string">&#x27;word22(a|b|c)\0&#x27;</span>/ <span class="string">&#x27;:word:second word:(word22a word22b word22c)&#x27;</span> \) \)</span><br><span class="line">_cmd <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，第一个单词可以是 <code>word1</code>（后跟
<code>a</code>、<code>b</code>、<code>c</code> 中的任意一个）或
<code>word11</code>（后跟 <code>a</code>、<code>b</code>、<code>c</code>
中的任意一个）；如果第一个单词包含 <code>11</code>，那么第二个单词可以是
<code>word2</code>（后跟 <code>a</code>、<code>b</code>、<code>c</code>
中的任意一个）或文件名。</p>
<p>这个例子看起来太复杂了，有一种简单的方式是使用
<code>_regex_words</code> 方法为 <code>_regex_arguments</code>
创建方法调用参数。</p>
<h3 id="模式">模式</h3>
<p>我们可能注意到上面这个示例中， <code>/PATTERN/</code>
看上去并不像正常的正则表达式。这里的字符串参数采用 <code>$'foo\0'</code>
的形式，通过这种形式将字符串中的 <code>\0</code> 解释为
<code>null</code>
字符，从而对参数内容进行单词分隔。如果我们没有在模式的末尾添加
<code>\0</code>，则可能无法匹配下一个单词。如果要在模式中使用变量的内容，我们可以给它添加双引号，以便对其进行扩展，然后再在后面添加一个含有
<code>null</code> 字符的字符串，如：<code>"$somevar"$'\0'</code>。</p>
<p>模式的正则表达式语法似乎与普通的正则表达式有些不同。虽然没有找到相应的说明文档，但是能够总结出以下特殊字符的用法：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">字符</th>
<th style="text-align: left;">使用描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;">通配符-任意数量的字符</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>?</code></td>
<td style="text-align: left;">通配符-单个字符</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>#</code></td>
<td style="text-align: left;">零个或多个前一个字符（类似于正则表达式中的
<code>*</code>）</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>##</code></td>
<td style="text-align: left;">一个或多个前一个字符（类似于正则表达式中的
<code>+</code>）</td>
</tr>
</tbody>
</table>
<h3 id="regex_words"><code>_regex_words</code></h3>
<p><code>_regex_words</code> 方法使得我们可以更容易地为
<code>_regex_arguments</code>
方法创建调用参数。<code>_regex_words</code>
方法的结果可以存储在一个变量中，从而能够作为
<code>_regex_arguments</code> 方法的调用参数。</p>
<p>使用 <code>_regex_words</code> 创建 <code>_regex_arguments</code>
的调用参数时，需要向其提供一个标签，其次是描述信息，接着是描述各个单词的参数格式。参数格式为
<code>WORD:DESCRIPTION:SPEC</code>，其中 <code>WORD</code>
表示要补全的单词，<code>DESCRIPTION</code>
表示描述信息，<code>SPEC</code> 可以是 <code>_regex_words</code>
创建的另一个变量，用于指定当前单词之后的单词，如果当前单词之后没有其他单词，则为空白。如下所示为一个简单的例子：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_regex_words firstword <span class="string">&#x27;The first word&#x27;</span> <span class="string">&#x27;word1a:a word:&#x27;</span> <span class="string">&#x27;word1b:b word:&#x27;</span> <span class="string">&#x27;word1c:c word&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><code>_regex_words</code> 方法执行的结果会被存储在
<code>$reply</code> 数组中，因此我们需要在 <code>$reply</code>
的值改变之前将其保存到其他数组中，如下所示： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">local</span> -a firstword</span><br><span class="line">_regex_words word <span class="string">&#x27;The first word&#x27;</span> <span class="string">&#x27;word1a:a word:&#x27;</span> <span class="string">&#x27;word1b:b word:&#x27;</span> <span class="string">&#x27;word1c:c word&#x27;</span></span><br><span class="line">firstword=<span class="string">&quot;<span class="variable">$reply</span>[@]&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>基于此，我们可以这样调用 <code>_regex_arguments</code> 方法：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_regex_arguments _cmd /$<span class="string">&#x27;[^\0]##\0&#x27;</span>/ <span class="string">&quot;<span class="variable">$&#123;firstword[@]&#125;</span>&quot;</span></span><br><span class="line">_cmd <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们来为初始命令添加了一个其他的模式。</p>
<p>下面是一个更加复杂的例子，我们为命令行中不同的单词调用
<code>_regex_words</code> 方法。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">local</span> -a firstword firstword2 secondword secondword2</span><br><span class="line">_regex_words word1 <span class="string">&#x27;The second word&#x27;</span> <span class="string">&#x27;woo:tang clan&#x27;</span> <span class="string">&#x27;hoo:not me&#x27;</span></span><br><span class="line">secondword=(<span class="string">&quot;<span class="variable">$reply</span>[@]&quot;</span>)</span><br><span class="line">_regex_words word2 <span class="string">&#x27;Another second word&#x27;</span> <span class="string">&#x27;yee:thou&#x27;</span> <span class="string">&#x27;haa:very funny!&#x27;</span></span><br><span class="line">secondword2=(<span class="string">&quot;<span class="variable">$reply</span>[@]&quot;</span>)</span><br><span class="line">_regex_words commands <span class="string">&#x27;The first word&#x27;</span> <span class="string">&#x27;foo:do foo&#x27;</span> <span class="string">&#x27;man:yeah man&#x27;</span> <span class="string">&#x27;chu:at chu&#x27;</span></span><br><span class="line">firstword=(<span class="string">&quot;<span class="variable">$reply</span>[@]&quot;</span>)</span><br><span class="line">_regex_words word4 <span class="string">&#x27;Another first word&#x27;</span> <span class="string">&#x27;boo:scare somebody:$secondword&#x27;</span> <span class="string">&#x27;ga:baby noise:$secondword&#x27;</span>\</span><br><span class="line"> <span class="string">&#x27;loo:go to the toilet:$secondword2&#x27;</span></span><br><span class="line">firstword2=(<span class="string">&quot;<span class="variable">$reply</span>[@]&quot;</span>)</span><br><span class="line"></span><br><span class="line">_regex_arguments _hello /$<span class="string">&#x27;[^\0]##\0&#x27;</span>/ \( <span class="string">&quot;<span class="variable">$&#123;firstword[@]&#125;</span>&quot;</span> <span class="string">&#x27;|&#x27;</span>  <span class="string">&quot;<span class="variable">$&#123;firstword2[@]&#125;</span>&quot;</span> \)<span class="string">&quot;</span></span><br><span class="line"><span class="string">_hello &quot;</span><span class="variable">$@</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>在上面这个例子中，第一个单词可以是
<code>foo</code>、<code>man</code>、<code>chu</code>、<code>boo</code>、<code>ga</code>、<code>loo</code>
其中之一。如果第一个单词是 <code>boo</code> 或
<code>ga</code>，那么第二个单词可以是 <code>woo</code> 或
<code>hoo</code>。如果第一个单词是 <code>loo</code> 那么第二个单词可以是
<code>yee</code> 或 <code>haa</code>，其他情况下没有第二个单词。</p>
<p>我们可以看一下 <code>_ip</code> 方法的具体实现，其内部很好地运用了
<code>_regex_words</code> 方法。</p>
<h2 id="基于-_values_sep_parts_multi_parts-的复杂补全功能">基于
<code>_values</code>、<code>_sep_parts</code>、<code>_multi_parts</code>
的复杂补全功能</h2>
<p><code>_values</code>、<code>_sep_parts</code>、<code>_multi_parts</code>
方法可以单独使用，也可以在
<code>_alternative</code>、<code>_arguments</code>、<code>_regex_arguments</code>
方法的调用参数的 <code>ACTION</code> 中使用。</p>
<p>如下所示是使用空格分隔 mp3 文件列表的例子： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_values <span class="string">&#x27;mp3 files&#x27;</span> ~/*.mp3</span><br></pre></td></tr></table></figure></p>
<p>如下所示是使用逗号分隔 session id 列表的例子： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_values -s , <span class="string">&#x27;session id&#x27;</span> <span class="string">&quot;<span class="variable">$&#123;(uonzf)$(awk &#x27;&#123;print $1&#125;</span>&#x27;)&#125;&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>如下所示是补全 <code>foo@news:woo</code>、<code>foo@news:laa</code>
或 <code>bar@news:woo</code> 等的例子： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_sep_parts <span class="string">&#x27;(foo bar)&#x27;</span> @ <span class="string">&#x27;(news ftp)&#x27;</span> : <span class="string">&#x27;(woo laa)&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>如下所示是一次补全 MAC 地址的例子： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">_multi_parts : <span class="string">&#x27;(00:11:22:33:44:55 00:23:34:45:56:67 00:23:45:56:67:78)&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用-compadd-直接添加补全单词">使用 compadd
直接添加补全单词</h2>
<p>为了更准确地进行控制，我们可以使用内置的 <code>compadd</code>
方法直接添加补全单词。这个方法有很多不同的参数，用于控制如何显示补全以及单词补全后如何更改命令行上的文本。更多信息可以查看官方文档
<a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">传送门</a>。这里只给出一些简单的示例。</p>
<p>在可能的补全列表中添加单词： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compadd foo bar blah</span><br></pre></td></tr></table></figure></p>
<p>和上面例子一样，区别在于会额外显示解释信息： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compadd -X <span class="string">&#x27;Some completions&#x27;</span> foo bar blah</span><br></pre></td></tr></table></figure></p>
<p>和第一个例子一样，区别在于会在自动补全的单词之前插入前缀
<code>what_</code>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compadd -P what_ foo bar blah</span><br></pre></td></tr></table></figure></p>
<p>和第一个例子一样，区别在于会在自动补全的单词之后插入后缀
<code>_todo</code>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compadd -S _todo foo bar blah</span><br></pre></td></tr></table></figure></p>
<p>和第一个例子一样，区别在于当在后缀之后输入空白字符时，会自动删除
<code>_todo</code> 后缀： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compadd -P _todo -q foo bar blah</span><br></pre></td></tr></table></figure></p>
<p>将 <code>$wordsarray</code> 数组中的单词添加至可能的补全列表中：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">compadd -a wordsarray</span><br></pre></td></tr></table></figure></p>
<h1 id="测试与调试">测试与调试</h1>
<p>重载补全方法： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">unfunction</span> _func</span><br><span class="line">&gt; <span class="built_in">autoload</span> -U _func</span><br></pre></td></tr></table></figure></p>
<p>下面这些方法能够提供一些有用的信息。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>_complete_help</code></td>
<td
style="text-align: left;">当对当前光标位置进行补全时，显示相关的上下文名称、标签以及补全方法</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>_complete_debug</code></td>
<td
style="text-align: left;">执行普通的补全，会在一个临时文件重保存补全系统所执行的
shell 命令 trace 信息</td>
</tr>
</tbody>
</table>
<h1 id="注意事项">注意事项</h1>
<p>请记住，在包含补全方法的文件的开头应该包含 <code>#compdef</code>
这一行。</p>
<p>请注意对 <code>_arguments</code>、<code>_regex_arguments</code>
方法的参数格式使用正确的引号类型：如果在参数格式中需要扩展参数，请使用双引号，否则请使用单引号。</p>
<p>检查
<code>_arguments</code>、<code>_alternative</code>、<code>_regex_arguments</code>
的参数格式中的冒号 <code>:</code> 数量和位置是否正确。</p>
<p>在使用 <code>_regex_arguments</code>
方法是，请记住要包含一个初始模式以匹配命令自身。</p>
<p>请记住在 <code>_regex_arguments</code> 的任何 <code>PATTERN</code>
参数的末尾加上一个空字符 <code>$'\0'</code>。</p>
<h1 id="提示">提示</h1>
<p>有时候我们会遇到这样的情况：子命令后面只能有一个选项，而在子命令后输入
tab 键时，zsh
会自动补全此选项。如果我们希望它在补全之前列出其描述信息，则可以向
<code>ACTION</code>
中添加另一个空选项（如：<code>\:</code>），例如：<code>TAR:DESCRIPTION:((opt1\:"description for opt1" \:))</code>。注意，这仅适用于其支持
<code>ACTION</code>
的工具方法（如：<code>_arguments</code>、<code>_regex_arguments</code>）。</p>
<h1 id="其他资料">其他资料</h1>
<p>一个关于 <code>_arguments</code> 方法的基本教程，<a
href="https://wikimatze.de/writing-zsh-completion-for-padrino/">传送门</a>。</p>
<p>一个关于 <code>_arguments</code> 方法的高级教程，<a
href="https://web.archive.org/web/20190411104837/http://www.linux-mag.com/id/1106/">传送门</a>。</p>
<p><code>zshcompsys</code> 手册，<a
href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-System">传送门</a>。</p>
]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>zsh</tag>
        <tag>自动补全</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络的分层设计原理</title>
    <url>/2024/09/21/deep-learning-layer/</url>
    <content><![CDATA[<p>在深度学习中，为了便于组合任意结构、任意层次的神经网络，通常会对神经网络进行分层设计，这也是一种模块化的设计思想。</p>
<span id="more"></span>
<p>我们知道，神经网络的核心功能是 <strong>推理</strong> 和
<strong>学习</strong>，也称为 <strong>正向传播</strong>（Forward
Propagation） 和 <strong>反向传播</strong>（Backward
Propagation）。为了实现结构化的分层设计，在局部层面，每个分层都必须同样具备对应的能力。</p>
<h1 id="计算图">计算图</h1>
<p>为了理解神经网络各个分层的工作原理，我们将使用
<strong>计算图</strong>（Computational
Graphic）的方式来分析推理和学习的过程。</p>
<p>下面，我们尝试计算图使用来分析一个简单的问题：</p>
<blockquote>
<p>张三在超市买了 2 个西瓜，其中西瓜每个 100 元，消费税为
10%。对此，请计算两个问题： 1. 本次消费的总金额是多少？ 2.
西瓜价格的上涨会在多大程度上影响最终的支付金额？即“支付金额关于西瓜价格的导数”是什么？</p>
</blockquote>
<h2 id="正向传播">正向传播</h2>
<p>对于第一个问题，我们可以得到如下所示的计算图的正向传播路径。其中，每个节点是一个数学函数，对其输入进行计算，得到对应的输出，并正向传播至下一个节点。</p>
<p>计算图可以将一个复杂的整体运算拆分成多个简单的局部运算。同时，将各个局部运算的结果不断地传递至其他计算节点，进而可以得到整体结果。最终可得：本次消费的总金额为
220 元。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="反向传播">反向传播</h2>
<p>对于第二个问题，我们可以进一步得到计算图的反向传播路径。这里从右向左依次传递导数，1，1.1，2.2。最终可得：支付金额关于西瓜的价格的导数为
2.2，即西瓜价格每上涨 1 元，最终支付价格会增加 2.2 元。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-02.png?x-oss-process=image/resize,w_800" /></p>
<p>这里为什么使用反向传播计算导数呢？因为神经网络的学习过程就是基于损失函数的导数（更准确地说，是梯度）来进行的，所以列举了一个类似的问题。</p>
<h3 id="损失函数">损失函数</h3>
<p>神经网络的反向传播是围绕 <strong>损失函数</strong>（Loss
Function，或称误差函数）完成的，其表示神经网络的性能，即当前神经网络的推理结果对比监督数据的正确值在多大程度上不拟合。</p>
<p>神经网络的学习过程的核心思想就是
<strong>通过损失函数计算其梯度，并结合梯度下降法，根据梯度的正负值来更新权重</strong>。如果梯度值为负，通过调整权重参数向正方向改变，可以减小损失函数的值；如果梯度值为正，通过调整权重参数向负方向改变，可以减小损失函数的值。</p>
<p>下面，我们来介绍两个最常见的损失函数。</p>
<h4 id="均方误差">均方误差</h4>
<p><strong>均方误差</strong>（Mean Squared
Error）的计算公式如下所示：</p>
<span class="math display">\[\begin{aligned}

E = \frac{1}{2} \sum_k (y_k - t_k)^2

\end{aligned}\]</span>
<p>其中，<span class="math inline">\(y_k\)</span>
表示神经网络的输出，<span class="math inline">\(t_k\)</span>
表示监督数据的正确值，<span class="math inline">\(k\)</span>
表示数据的维度。</p>
<p>均方误差会计算神经网络的输出和监督数据的各个元素之差的平方，再求总和。我们在
<a
href="https://chuquan.me/2024/07/21/neural-network-introduce/">《初识人工神经网络（1）——基本原理》</a>
中介绍的损失函数就是均方误差。</p>
<p>根据定义，我们可以完成均方误差的代码实现，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mean_squared_error</span>(<span class="params">y, t</span>): </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * np.<span class="built_in">sum</span>((y-t)**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="交叉熵误差">交叉熵误差</h4>
<p><strong>交叉熵误差</strong>（Cross Entropy
Error）的计算公式如下所示：</p>
<span class="math display">\[\begin{aligned}

E = - \sum_k t_k log y_k

\end{aligned}\]</span>
<p>其中，<span class="math inline">\(log\)</span> 表示以 <span
class="math inline">\(e\)</span> 为底数的自然对数 <span
class="math inline">\(log_e\)</span>，<span
class="math inline">\(y_k\)</span> 表示神经网络的输出，<span
class="math inline">\(t_k\)</span> 为监督数据的正确值。</p>
<p>这里采用 one-hot 表示法，即 <span class="math inline">\(t_k\)</span>
中只有正确值的位置的值为 1，其他均为
0。因此，交叉熵误差实际上只计算对应正确值标签的输出的自然对数。比如：当正确值标签的索引是
2，如果对应的神经网络的输出是 0.6，那么交叉熵误差为 <span
class="math inline">\(-log0.6 =
0.51\)</span>；如果对应的神经网络的输出是 0.1，那么交叉熵误差为 <span
class="math inline">\(-log0.1 =
2.30\)</span>。由此可以看出，在正确值的位置的输出值越接近
1，则误差越小。</p>
<p>根据定义，我们可以完成交叉熵误差的代码实现，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy_error</span>(<span class="params">y, t</span>): </span><br><span class="line">    delta = <span class="number">1e-7</span></span><br><span class="line">    <span class="keyword">return</span> -np.<span class="built_in">sum</span>(t * np.log(y + delta))</span><br></pre></td></tr></table></figure>
<h3 id="链式法则">链式法则</h3>
<p>神经网络的学习过程是基于损失函数的导数（梯度）来完成的，由于反向传播的路径中包含了多个分层，以及大量的权重参数，因此我们需要考虑如何对损失函数的导数进行拆分，以便在计算图中的路径中进行传播。</p>
<p>很幸运，<strong>链式法则</strong>（Chain
Rule）可以完美地解决这个问题。什么是链式法则？链式法则是关于复合函数的导数的性质，其定义如下：</p>
<blockquote>
<p>如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。</p>
</blockquote>
<p>举个例子，有一个函数定义为 <span class="math inline">\(z = (x +
y)^2\)</span>，此时我们可以将它拆解成两个函数，分别是：</p>
<span class="math display">\[\begin{aligned}

z =&amp; t^2
\\
t =&amp; x + y

\end{aligned}\]</span>
<p>对此，我们可以基于链式法则对复合函数 <span
class="math inline">\(z\)</span> 关于 <span
class="math inline">\(x\)</span> 到导数 <span
class="math inline">\(\frac{\partial z}{\partial x}\)</span>
进行求解，如下所示。</p>
<span class="math display">\[\begin{aligned}

\frac{\partial z}{\partial x} = &amp;
\frac{\partial z}{\partial t} \frac{\partial t}{\partial x}
\\
= &amp;
2t \cdot 1
\\
= &amp;
2(x + y)

\end{aligned}\]</span>
<p>使用计算图进行拆解，可以得到如下所示的反向传播的计算路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="运算节点">运算节点</h2>
<p>在计算图中，节点是决定正向传播和反向传播的关键。下面，我们来看几种典型的运算节点。</p>
<h3 id="加法节点">加法节点</h3>
<p>加法节点用于处理加法运算，比如：<span class="math inline">\(z = x +
y\)</span>。<span class="math inline">\(z\)</span> 关于 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的导数都是常量 <span
class="math inline">\(1\)</span>，其正向传播和反向传播的计算图如下所示。反向传播的导数仍然保持“上游传来的梯度”不变。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-14.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="乘法节点">乘法节点</h3>
<p>乘法节点用于处理乘法运算，比如：<span class="math inline">\(z = x
\times y\)</span>。此时，我们可以分别求出 <span
class="math inline">\(z\)</span> 关于 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的导数，分别是：</p>
<span class="math display">\[\begin{aligned}

\frac{\partial z}{\partial x} = y
\\
\frac{\partial z}{\partial y} = x

\end{aligned}\]</span>
<p>乘法节点的正向传播和反向传播如下所示，其中反向传播会将“上游传来的梯度”乘以“将正向传播时的输入替换后的值”。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-04.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="分支节点">分支节点</h3>
<p>下图所示，分支节点是有分支的节点，本质上就是相同的值被复制并分叉，其反向传播是上游传来的梯度之和。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-05.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="repeat-节点">Repeat 节点</h3>
<p>分支节点有两个分支，Repeat 节点则有 N
个分支。与分支节点类似，其反向传播也是通过 N 个梯度的总和求出。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-06.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="sum-节点">Sum 节点</h3>
<p>Sum 节点是通用的加法节点。Sum
节点的反向传播将上游传来的梯度复制并分配至所有分支。我们可以发现，Sum
节点和 Repeat 存在一种逆向关系，即 Sum 节点的正向传播相当于 Repeat
节点的反向传播；Sum 节点的反向传播相当于 Repeat 节点的正向传播。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-07.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="matmul-节点">MatMul 节点</h3>
<p>MatMul 节点，即矩阵乘积（Matrix
Multiply）节点。我们考虑一个矩阵乘法的例子 <span class="math inline">\(y
= xW\)</span>。其中，<span class="math inline">\(x\)</span>、<span
class="math inline">\(W\)</span>、<span class="math inline">\(y\)</span>
的形状分别是 <span class="math inline">\(1 \times D\)</span>、<span
class="math inline">\(D \times H\)</span>、<span class="math inline">\(1
\times H\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-08.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，我们可以通过如下方式求解关于 <span
class="math inline">\(x\)</span> 的第 <span
class="math inline">\(i\)</span> 个元素的导数 <span
class="math inline">\(\frac{\partial L}{\partial x_i}\)</span>。<span
class="math inline">\(\frac{\partial L}{\partial x_i}\)</span>
表示变化程度，当 <span class="math inline">\(x_i\)</span>
发生微小变化时，<span class="math inline">\(L\)</span>
会有多大程度的变化。如果此时改变 <span
class="math inline">\(x_i\)</span>，则向量 <span
class="math inline">\(y\)</span> 的所有元素都会发生变化。由于 <span
class="math inline">\(y\)</span> 的各个元素发生变化，最终 <span
class="math inline">\(L\)</span> 也会发生变化。因此，<span
class="math inline">\(x_i\)</span> 到 <span
class="math inline">\(L\)</span> 的链式法则路径存在多个，它们的和是
<span class="math inline">\(\frac{\partial L}{\partial
x_i}\)</span>。</p>
<span class="math display">\[\begin{aligned}

\frac{\partial L}{\partial x_i} = &amp;
\sum_j \frac{\partial L}{\partial y_j} \frac{\partial y_j}{\partial x_i}
\\
= &amp;
\sum_j \frac{\partial L}{\partial y_j} W_{ij}

\end{aligned}\]</span>
<p>由上式可知，<span class="math inline">\(\frac{\partial L}{\partial
x_i}\)</span> 由向量 <span class="math inline">\(\frac{\partial
L}{\partial y}\)</span> 和 <span class="math inline">\(W\)</span> 的第
<span class="math inline">\(i\)</span>
行向量的内积求得，进而推导得到：</p>
<span class="math display">\[\begin{aligned}

\frac{\partial L}{\partial x} = \frac{\partial L}{\partial y} W^T

\end{aligned}\]</span>
<p><span class="math inline">\(\frac{\partial L}{\partial x}\)</span>
可由矩阵乘积一次求得，其中 <span class="math inline">\(W^T\)</span>
表示矩阵 <span class="math inline">\(W\)</span> 的转置矩阵。</p>
<p>当我们考虑 mini-batch 处理的情况，即 <span
class="math inline">\(x\)</span> 中保存了 <span
class="math inline">\(N\)</span> 份数据。此时，<span
class="math inline">\(x\)</span>、<span
class="math inline">\(W\)</span>、<span class="math inline">\(y\)</span>
的形状分别是 <span class="math inline">\(N \times D\)</span>、<span
class="math inline">\(D \times H\)</span>、<span class="math inline">\(N
\times H\)</span>，其计算图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-09.png?x-oss-process=image/resize,w_800" /></p>
<p>从 <span class="math inline">\(\frac{\partial L}{\partial x}\)</span>
的关系式，我们发现矩阵乘积的反向传播与乘法的反向传播类似，同样可以总结出“上游传来的梯度”乘以“将正向传播时的输入替换后的值”。最后，我们进一步通过确认矩阵的形状，可以推导出矩阵乘法的反向传播的数学式，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-10.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="分层设计">分层设计</h1>
<p>在 <a
href="https://chuquan.me/2024/07/21/neural-network-introduce/">《初识人工神经网络（1）——基本原理》</a>
中我们介绍了一个数字识别的神经网络，其结构如下所示，隐藏层的节点具备两个处理函数，分别是求和函数、激活函数。对此，为了实现分层设计，我们将进一步拆分成仿射层、激活函数层。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-14.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="affine">Affine</h2>
<p>求和函数本质上对各个输入进行加权求和，通过矩阵点乘实现。此时，我们再引入一个偏置，用于控制神经元被激活的容易程度。由于神经网络的加权求和运算与加偏置运算，正好对应仿射变换的一次线性变换和一次平移，因此将其称为仿射层，或
Affine 层。如下所示是 Affine 计算图的正向传播路径。其中，<span
class="math inline">\(X\)</span> 表示输入矩阵，<span
class="math inline">\(W\)</span> 表示权重矩阵，<span
class="math inline">\(B\)</span> 表示偏置矩阵。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-11.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="计算图-1">计算图</h3>
<p>通过上述计算图，我们可以发现 Affine 层是由一个 MatMul
节点和一个加法节点组成。由此，我们可以得到其计算图的反向传播路径，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-12.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="代码实现">代码实现</h3>
<p>根据计算图，我们可以很容易得到 Affine 层的代码实现，如下所示。
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Affine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, W, b</span>):</span><br><span class="line">        self.W = W </span><br><span class="line">        self.b = b </span><br><span class="line">        self.x = <span class="literal">None</span> </span><br><span class="line">        self.dW = <span class="literal">None</span> </span><br><span class="line">        self.db = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): </span><br><span class="line">        self.x = x</span><br><span class="line">        out = np.dot(x, self.W) + self.b</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        dx = np.dot(dout, self.W.T) </span><br><span class="line">        self.dW = np.dot(self.x.T, dout) </span><br><span class="line">        self.db = np.<span class="built_in">sum</span>(dout, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure></p>
<h2 id="sigmoid">Sigmoid</h2>
<p>Sigmoid 是激活函数的一种，其数学定义如下所示。</p>
<span class="math display">\[\begin{aligned}

y = &amp;
\frac{1}{1 + exp(-x)}
\\
= &amp;
\frac{1}{1 + e^{-x}}

\end{aligned}\]</span>
<p>根据其数学定义，我们对其运算步骤进行节点拆解，可以得到如下所示计算图的正向传播路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-13.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="计算图-2">计算图</h3>
<p>在 sigmoid 计算图中，我们注意到有两个没有介绍过的节点，分别是：<span
class="math inline">\(exp\)</span> 节和除法节点。</p>
<p>对于 <span class="math inline">\(exp\)</span> 节点，其数学表示为
<span class="math inline">\(y = exp(x)\)</span>，其导数由下式表示。</p>
<span class="math display">\[\begin{aligned}

\frac{\partial y}{\partial x}
=&amp; log_e e \cdot e^x
\\
=&amp; e^x
\\
=&amp; exp(x)

\end{aligned}\]</span>
<p>对于除法节点，其数学表示为 <span class="math inline">\(y =
\frac{1}{x}\)</span>，其导数由下式表示。</p>
<span class="math display">\[\begin{aligned}

\frac{\partial y}{\partial x}
=&amp; -\frac{1}{x^2}
\\
=&amp; -y^2

\end{aligned}\]</span>
<p>然后，我们根据链式法则可以推导出如下所示的反向传播路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-15.png?x-oss-process=image/resize,w_800" /></p>
<p>接下来，我们对 sigmoid 反向输出的导数进行简化，推导如下。</p>
<span class="math display">\[\begin{aligned}

\frac{\partial L}{\partial y} y^2 exp(-x)
=&amp; \frac{\partial L}{\partial y} \frac{1}{(1 + exp(-x))^2} exp(-x)
\\
=&amp; \frac{\partial L}{\partial y} \frac{1}{1 + exp(-x)}
\frac{exp(-x)}{1 + exp(-x)} \\
=&amp; \frac{\partial L}{\partial y} y (1 - y)

\end{aligned}\]</span>
<p>然后，我们再隐藏计算图过程中节点，合并成一个 sigmoid
节点，可以得到如下所示的计算图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-16.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="代码实现-1">代码实现</h3>
<p>根据计算图，我们可以很容易得到 Sigmoid 层的代码实现，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.out = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x)) </span><br><span class="line">        self.out = out</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        dx = dout * (<span class="number">1.0</span> - self.out) * self.out</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure>
<h2 id="relu">ReLU</h2>
<p>ReLU 是另一种常用的激活函数，其数学表达式非常简单，如下所示。</p>
<span class="math display">\[\begin{aligned}

y = \begin{cases}
x &amp; (x &gt; 0)
\\
0 &amp; (x \leq 0)
\end{cases}

\end{aligned}\]</span>
<h3 id="计算图-3">计算图</h3>
<p>根据 ReLU 的数学定义，我们可以求解 <span
class="math inline">\(y\)</span> 关于 <span
class="math inline">\(x\)</span> 的导数，如下所示。</p>
<span class="math display">\[\begin{aligned}

\frac{\partial y}{\partial x} = \begin{cases}
1 &amp; (x &gt; 0)
\\
0 &amp; (x \leq 0)
\end{cases}

\end{aligned}\]</span>
<p>下图所示为 ReLU 的计算图。当正向传播时的输入 <span
class="math inline">\(x\)</span> 大于
0，则反向传播会将上游的值直接传递至下游；当正向传播时的输入 <span
class="math inline">\(x\)</span> 小于等于 0，则导数传递停止。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-17.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="代码实现-2">代码实现</h3>
<p>根据计算图，我们可以得到 ReLU 层的代码实现，如下所示。其中，变量
<code>mask</code> 是由 True/False 构成的 NumPy 数
组，它会把正向传播时的输入 <code>x</code> 的元素中小于等于 0
的地方保存为 True，其他地方(大于 0 的元素)保存为 False。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Relu</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.mask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): </span><br><span class="line">        self.mask = (x &lt;= <span class="number">0</span>) </span><br><span class="line">        out = x.copy() </span><br><span class="line">        out[self.mask] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>): </span><br><span class="line">        dout[self.mask] = <span class="number">0</span> </span><br><span class="line">        dx = dout</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure>
<h2 id="softmax-with-loss">Softmax-with-Loss</h2>
<p>对于分类问题，尤其是多元分类问题，一般使用 Softmax
函数作为计算输出。Softmax 函数的数学定义如下所示。</p>
<span class="math display">\[\begin{aligned}

y_k = &amp;
\frac{exp(a_k)}{\sum\limits_{i=1}\limits^n exp(a_i)}

\end{aligned}\]</span>
<p>其中，<span class="math inline">\(exp(x)\)</span> 表示 <span
class="math inline">\(e^x\)</span> 的指数函数。如果输出层有 <span
class="math inline">\(n\)</span> 个神经元，<span
class="math inline">\(y_k\)</span> 表示第 <span
class="math inline">\(k\)</span> 个神经元的输出值。Softmax
函数中的分子是输入信号 <span class="math inline">\(a_k\)</span>
的指数函数，分母是所有输入信号的指数函数之和。Softmax 函数的输出是 0.0
到 1.0 之间的实数，且 Softmax 函数的输出值总和为 1。因此，我们将 Softmax
函数的输出解释为“概率”。</p>
<p>神经网络包含 <strong>推理</strong> 和 <strong>学习</strong>
两个阶段。在推理阶段通常不使用 Softmax 层，因为 Softmax
只是对前一层的数据进行了归一化处理。推理阶段只需要用最后的 Affine
层输出的最大值即可。不过，在学习阶段则需要 Softmax
层。为了配合监督数据的正确值进行学习，通常会使用 Softmax
结合交叉熵误差（Cross Entropy Error）损失函数，构成一个
<strong>Softmax-with-Loss</strong> 层。</p>
<p>上文，我们介绍过交叉熵误差，这里我们再简单回顾一下它的数学定义，如下所示。</p>
<span class="math display">\[\begin{aligned}
L = - \sum\limits_k t_k log y_k
\end{aligned}\]</span>
<h3 id="计算图-4">计算图</h3>
<p>下图所示是 Softmax-with-Loss
层的计算图的整体示意图。计算图内部可以分为 Softmax 和 Cross Entropy
Error
两个层，其各自则是由多个基本运算节点构成。注意，在计算图中，我们将指数之和简写为
<span class="math inline">\(S\)</span>，最终的输出计为 <span
class="math inline">\((y_1, y_2, y_3)\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-18.png?x-oss-process=image/resize,w_800" /></p>
<p>这里，我们重点看一下反向传播。</p>
<p>首先是 Cross Entropy Error 层的反向传播，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-19.png?x-oss-process=image/resize,w_800" /></p>
<p>其主要注意以下几个要点：</p>
<ul>
<li>反向传播初始值为 1。因为 <span class="math inline">\(\frac{\partial
L}{\partial L} = 1\)</span>。</li>
<li>乘法节点的反向传播是将正向传播时的输入值进行翻转，乘以上游传来的导数后，传递至下游。</li>
<li>加法节点的反向传播是将上游传来的导数继续进行传递。</li>
<li>对数节点中对数的导数是 <span class="math inline">\(\frac{\partial
y}{\partial x} =
\frac{1}{x}\)</span>，其反向传播则根据链式法则，使用上游传来的导数乘以自身的导数，并将结果传递至下游。</li>
</ul>
<p>其次，我们来看 Softmax 层的反向传播，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/deep-learning-layer-20.png?x-oss-process=image/resize,w_800" /></p>
<p>对于乘法节点，其反向传播将正向传播时的输入值进行翻转，乘以上游传来的导数。其包含两个反向传播分支，具体计算如下所示。</p>
<span class="math display">\[\begin{aligned}

- \frac{t_1}{y_1} exp(a_1) =&amp; - t_1 \frac{S}{exp(a_1)} exp(a_1) = -
t_1 S

\\

- \frac{t_1}{y_1} \frac{1}{S} =&amp; -\frac{t_1}{exp(a_1)}

\end{aligned}\]</span>
<p>接下来是一个 Repeat 节点和除法节点的组合。对于 Repeat
节点，其反向传播时会将上游节点的导数进行求和，得到 <span
class="math inline">\(-S(t_1 + t_2 +
t_3)\)</span>；对于除法节点，其反向传播可以进一步得到 <span
class="math inline">\(\frac{1}{S}(t_1 + t_2 + t_3)\)</span>。由于 <span
class="math inline">\((t_1, t_2, t_3)\)</span> 采用 one-hot
表示法，其和为 1，因此进一步得到反向传播的值为 <span
class="math inline">\(\frac{1}{S}\)</span>。</p>
<p>然后是加法节点，其反向传播将上游传来的导数继续进行传递。</p>
<p>最后是 exp 节点，从计算图看，它其实包含了一个 exp 节点和一个 Repeat
节点。对于 Repeat 节点，其反向传播会将上游节点的导数进行求和；对于 exp
节点，其导数为 <span class="math inline">\(\frac{\partial y}{\partial x}
= exp(x)\)</span>。反向传播推导如下：</p>
<span class="math display">\[\begin{aligned}

\frac{\partial y}{\partial y} = (\frac{1}{S} - \frac{t_1}{exp(a_1)})
exp(a_1) = y_1 - t_1

\end{aligned}\]</span>
<h3 id="代码实现-3">代码实现</h3>
<p>最后，我们根据计算图进行代码实现，结果如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy_error</span>(<span class="params">y, t</span>): </span><br><span class="line">    delta = <span class="number">1e-7</span></span><br><span class="line">    <span class="keyword">return</span> -np.<span class="built_in">sum</span>(t * np.log(y + delta))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">a</span>):</span><br><span class="line">    c = np.<span class="built_in">max</span>(a)</span><br><span class="line">    exp_a = np.exp(a - c) <span class="comment"># 溢出对策 sum_exp_a = np.sum(exp_a)</span></span><br><span class="line">    y = exp_a / sum_exp_a</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoftmaxWithLoss</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.loss = <span class="literal">None</span> <span class="comment"># 损失</span></span><br><span class="line">        self.y = <span class="literal">None</span> <span class="comment"># softmax的输出</span></span><br><span class="line">        self.t = <span class="literal">None</span> <span class="comment"># 监督数据(one-hot vector)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, t</span>): self.t = t</span><br><span class="line">        self.y = softmax(x)</span><br><span class="line">        self.loss = cross_entropy_error(self.y, self.t)</span><br><span class="line">        <span class="keyword">return</span> self.loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout=<span class="number">1</span></span>):</span><br><span class="line">        batch_size = self.t.shape[<span class="number">0</span>]</span><br><span class="line">        dx = (self.y - self.t) / batch_size</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>在实践中，分层设计有利于快速调整和实现各种各样的神经网络。我们经常听说的深度学习，本质上就是一个神经网络层级比较多的结构。</p>
<p>为了介绍神经网络中的分层设计原理，本文以计算图作为出发点，作为分析每个分层正向传播和反向传播的依据。这里，我们还介绍了一个用于反向传播的关键法则——链式法则。最后，我们介绍了神经网络中几种常见的分层，如：Affine、Sigmoid、ReLU、Softmax-with-Loss
等。</p>
<p>本文，我们大致了解了神经网络的分层设计，这种思想是研究复杂神经网络的基础。后续有时间，我们将继续探索神经网络的各种应用，敬请期待吧！</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>计算图</tag>
        <tag>Sigmoid</tag>
        <tag>Affine</tag>
        <tag>Softmax</tag>
        <tag>Softmax-with-Loss</tag>
        <tag>ReLU</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/2024/09/28/cnn-introduction/</url>
    <content><![CDATA[<p>通过前面几篇文章，我们对神经网络有了一个基本的认识。本文，我们来介绍一下神经网络在图像与视觉领域的应用——<strong>卷积神经网络</strong>（Conventional
Neural Network，简称 CNN）。</p>
<span id="more"></span>
<h1 id="视觉认知原理">视觉认知原理</h1>
<p>在深度学习的发展过程中，广泛应用了大脑认知原理，尤其是视觉认知原理，这里我们来简单了解一下视觉认知原理。</p>
<p>1981 年的诺贝尔医学奖，颁发给了 David Hubel 和 TorstenWiesel，以及
Roger
Sperry。前两位的主要贡献，是发现了视觉系统的信息处理，可视皮层是分级的。整体而言，人类的视觉认知原理大体分为以下几个步骤：</p>
<ul>
<li>通过瞳孔摄入原始的像素信号</li>
<li>通过大脑皮层的细胞发现边缘和方向</li>
<li>对边缘和方向进行组合，从而完成形状判定</li>
<li>对形状进行高级视觉抽象，从而完成分类认知</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-01.png?x-oss-process=image/resize,w_800" /></p>
<p>人类视觉认知是一个分层递进的过程：提取边缘特征，抽象高级特征，组合整体图像，最终完成分类。下图所示是对于不同物体的视觉认知过程。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="全连接层的局限性">全连接层的局限性</h1>
<p>理论上，我们可以使用一个由全连接层组成的神经网络来进行图像识别，事实上，在
<a
href="https://chuquan.me/2024/07/31/neural-network-implement/">初识人工神经网络（2）——代码实现</a>
一文中，我们也是这么做的。</p>
<p>然而，对于复杂图像，全连接神经网络的表现并不好，根本原因在于
<strong>全连接层忽略了数据的形状</strong>。图像是 3 维形状（宽、高、RGB
通道），空间上邻近的像素会有相似的值，RGB
各通道之间也有关联性。而全连接层会忽略形状，将数据作为一维数据进行处理，因此无法利用数据的空间关联信息。</p>
<p>因此，为了提取图像数据的空间关联信息，于是诞生了卷积神经网络。</p>
<h1 id="卷积神经网络">卷积神经网络</h1>
<p>我们首先来看一下全连接神经网络和卷积神经网络的整体结构，如下所示。两者的主要区别在于：<strong>在输入端，CNN
络使用「卷积层 + ReLU + 池化层」的结构代替了「全连接层 +
ReLU」的结构</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-08.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-09.png?x-oss-process=image/resize,w_800" /></p>
<p>整体而言，卷积神经网络的工作流程主要分为三个阶段，分别是：</p>
<ul>
<li>通过 <strong>卷积层</strong>（Convolution
Layer）对图像进行特征提取，得到特征图；</li>
<li>通过 <strong>池化层</strong>（Pooling
Layer）对特征图进行降采样，压缩数据量；</li>
<li>通过 <strong>全连接层</strong>（Affine
Layer）对特征图进行分类，得到识别结果。</li>
</ul>
<p>下面，我们分别介绍一下卷积层和池化层。</p>
<h1 id="卷积层">卷积层</h1>
<p>在 <a
href="https://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">《计算机图形学基础（4）——光栅化》</a>
一文中，我们提到过卷积（Convolution）是实现滤波的主要数学工具和底层原理。滤波器的基本原理是
<strong>响应函数与输入信号进行卷积运算</strong>，因此滤波器也可以称为
<strong>卷积核</strong>。</p>
<p>卷积神经网络的核心在于卷积层，卷积层则包含了大量滤波器，这些滤波器通过监督学习，自适应调整内部权重参数，从而能够更加准确地提取特征值。下图所示是一个图片应用不同滤波器的示例。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="卷积运算">卷积运算</h2>
<p>了解了滤波器的作用后，我们再来看一下滤波器的内部原理——卷积运算。如下所示，是一个卷积运算的例子。其中，输入大小是
<span class="math inline">\((4, 4)\)</span>，滤波器大小是 <span
class="math inline">\((3, 3)\)</span>，输出大小是 <span
class="math inline">\((2, 2)\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-06.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示展示了卷积运算的执行顺序。对于输入数据，卷积运算以一定步幅滑动滤波器的窗口，同时将滤
波器元素和对应的输入元素相乘并求和，最终保存至对应的输出位置，即可得到卷积运算结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-07.png?x-oss-process=image/resize,w_800" /></p>
<p>全连接神经网络中，除了权重参数，还存在偏置。同样，在 CNN
中，也存在偏置，下图所示展示了包含偏置的卷积运算。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-10.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="填充">填充</h2>
<p>前面，我们介绍了一个卷积运算的例子，其输入大小是 <span
class="math inline">\((4, 4)\)</span>，滤波器大小是 <span
class="math inline">\((3, 3)\)</span>，输出大小是 <span
class="math inline">\((2,
2)\)</span>。此时可以会发现输出结果的大小已经小于滤波器的大小，将无法继续执行卷积运算，那么该如何解决呢？我们可以使用
<strong>填充</strong>（Padding）来解决。</p>
<p>如下所示，我们对输入数据进行了幅度为 1 的填充，输入大小从 <span
class="math inline">\((4, 4)\)</span> 变成了 <span
class="math inline">\((6, 6)\)</span>，输出大小从 <span
class="math inline">\((2, 2)\)</span> 变成了 <span
class="math inline">\((6,
6)\)</span>。由此可见，填充可以调整卷积运算的输出大小，填充增大，输出大小增大。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="步幅">步幅</h2>
<p>除了填充，我们还可以通过
<strong>步幅</strong>（Stride）来控制输出大小。下图所示，我们设置步幅为
2，滤波器每次滑动的间隔则为 2。整体而言，步幅增大，输出大小减小。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-12.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="滤波器通道">滤波器通道</h2>
<p>上述例子中的输入是 2 维数据，但是图像是 3 维数据（宽、高、RGB
通道），对此，我们也可以为滤波器增加一个维度——通道。</p>
<p>下图所示，纵深方向为通道方向，输入数据的通道数为
3，与此对应，滤波器的通道数也为
3。每个通道的输入数据与对应通道的滤波器进行卷积运算，最后对所有通道的输出进行求和，从而得到输出结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-13.png?x-oss-process=image/resize,w_800" /></p>
<p>此时，我们可以将输入数据抽象为 3 个维度，分别是通道数 <span
class="math inline">\(C\)</span>、高度 <span
class="math inline">\(H\)</span>，宽度 <span
class="math inline">\(W\)</span>，整体使用 <span
class="math inline">\((C, H, W)\)</span> 表示；滤波器也样，高度 <span
class="math inline">\(FH\)</span>（Filter Height）、宽度 <span
class="math inline">\(W\)</span>（Filter Width），通道数为 <span
class="math inline">\(C\)</span>，整体使用 <span
class="math inline">\((C, FH, FW)\)</span> 表示；输出大小为 <span
class="math inline">\((1, OH, OW)\)</span>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-14.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="滤波器数量">滤波器数量</h2>
<p>上述卷积运算一次只能输出一张特征图（Feature
Map），如果希望一次输出多张特征图，我们可以增加滤波器的数量，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-15.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="池化层">池化层</h1>
<p>如果卷积层的输入数据非常大，那么输出特征图的数据量也会非常大。为了降低后续处理的数据量，以及提高鲁棒性、防止过拟合，卷积神经网络会在卷积层之后增加一个池化层。</p>
<p>池化的本质是对输出特征图进行局部采样，也称降采样（Downsampling）。下图所示，是对一个输出特征图进行池化运算的示意图，其中使用的池化层为
Max 池化层，即计算局部区域中的最大值。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-16.png?x-oss-process=image/resize,w_800" /></p>
<p>对于多通道的场景，池化层将同时处理多个通道的数据，并进行池化运算，如下所示展示的是多通道池化运算顺序。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-17.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="全连接层">全连接层</h1>
<p>经过多层「卷积 + ReLU +
池化」的运算，神经网络能够提炼出经过高度简化、高度抽象的特征，这些特征总结了图像的空间信息。最后，为了对图像进行分类识别，我们需要使用全连接层来进行处理。</p>
<p>如下图所示，全连接层会将池化层的输出结果进行降维输入，在监督学习的过程中，除了调整卷积层中的滤波器权重参数，也会调整全连接的权重参数，最终输出准确的分类结果。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-18.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="经典-cnn">经典 CNN</h1>
<p>时至今日，业界已经出现了各种卷积神经网络。这里，我们介绍其中两个经典的网络，一个是
1998 年首次被提出的 CNN——LeNet；另一个是在深度学习受到关注的 2012
年提出的 AlextNet。</p>
<h2 id="lenet">LeNet</h2>
<p>LeNet 在 1998
年提出时是用于解决手写数字识别的问题。如下所示，它包含连续的卷积层和子采样层，最后通过全连接层输出结果。与现在的
CNN 相比，LeNet 有几个不同点：</p>
<ul>
<li>LeNet 使用 sigmoid 函数作为激活函数，而现在的 CNN 主要使用 ReLU
函数作为激活函数</li>
<li>Lext 采用子采样（Subsampling）进行数据压缩，而现在的 CNN
主要使用池化层（Max 池化）进行数据压缩</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-19.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="alexnet">AlexNet</h2>
<p>AlexNet 是图领奖获得者 Geoffrey Hinton 和他的学生 Alex Krizhevsky 在
2012 年提出的，AlexNet 提出后引发了深度学习的浪潮，不过它的网络结构和
LeNet 并没有本质的区别。</p>
<p>AlexNet 和 LeNet 之间的主要区别在于：</p>
<ul>
<li>AlexNet 采用了 ReLU 作为激活函数</li>
<li>AlexNet 采用了局部正规化的 LRN（Local Response
Normalization）层</li>
<li>AlexNet 采用了 Drouput，可以有效抑制过拟合</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cnn-intro-20.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了卷积神经网络的基本概念及其工作原理，相比于全连接神经网络，卷积神经网络主要增加了卷积层和池化层，其中卷积层用于提取图像数据的空间特征，池化层用于压缩数据，提高鲁棒性，最后使用全连接层进行分类结果的计算和输出。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《深度学习入门：基于Python的理论与实现》</li>
<li><a
href="https://cs231n.github.io/convolutional-networks/">Convolutional
Neural Networks (CNNs / ConvNets)</a></li>
<li><a
href="https://www.zhihu.com/question/29366638/answer/3383464185">卷积神经网络和深度神经网络的区别是什么？</a></li>
<li><a
href="https://easyai.tech/ai-definition/cnn/#google_vignette">卷积神经网络-CNN</a></li>
<li><a
href="https://towardsdatascience.com/convolutional-neural-network-1368ee2998d3">Convolutional
Neural Network</a></li>
<li><a href="https://mlnotebook.github.io/post/CNN1/">Convolutional
Neural Networks - Basics</a></li>
<li><a
href="https://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/#%E5%8D%B7%E7%A7%AF">卷积</a></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>卷积层</tag>
        <tag>池化层</tag>
        <tag>AlextNet</tag>
        <tag>LeNet</tag>
      </tags>
  </entry>
  <entry>
    <title>自然语言处理中的单词含义表示</title>
    <url>/2024/10/15/nlp-word-representation/</url>
    <content><![CDATA[<p>我们日常使用的语言，如中文、英文，称为
<strong>自然语言</strong>（natural language）。
<strong>自然语言处理</strong>（Natural Language
Processing，NLP）则是一种让计算机理解人类语言的技术。现在很多知名的工具，比如：搜索引擎、机器翻译、ChatGPT
等，都是基于自然语言处理技术的应用。</p>
<span id="more"></span>
<h1 id="文本分词">文本分词</h1>
<p>大多数情况下，NLP
处理的是由大量单词组成的文本。因此，这里面临的第一个问题是如何进行分词。</p>
<p>英文的分词比较简单，每个单词都是独立的，可以通过空、标点符号、正则表达式等进行分词。相比而言，中文的分词会显得比较复杂。对此，研究人员针对不同语言开发了各种不同的分词工具，比如：</p>
<ul>
<li>英文分词可以使用 NLTK、spaCy 等工具</li>
<li>中文分词可以使用 jieba、THULAC 等工具</li>
</ul>
<p>一些知名的预训练模型 BERT 和 GPT
各自拥有专属的分词器（Tokenizer），比如：WordPiece、Byte Pair
Encoding（BPE）等。</p>
<h1 id="单词含义">单词含义</h1>
<p>自然语言的灵活性非常强，同一个单词在不同的语境下，不同的上下文中具有不同的含义，这与编程语言截然不同。因此，理解单词的含义成为了
NLP 的核心问题之一，也是本文将重点讨论的话题。</p>
<p>在 NLP 技术的发展过程中，单词含义的表示方法主要经历了一下几种：</p>
<ul>
<li>基于同义词词典的方法</li>
<li>基于计数的方法</li>
<li>基于推理的方法</li>
</ul>
<p>下面，我们分别来介绍这几种单词含义的表示方法。</p>
<h1 id="同义词词典法">同义词词典法</h1>
<p>基于 <strong>同义词词典</strong>（Thesaurus）的方法的核心思路是：</p>
<ul>
<li>将含义相同或含义类似的单词归类到同一个组中</li>
<li>同时定义单词之间细粒度的层级关系，比如：上位与下位的关系，整体与局部的关系。</li>
</ul>
<p>如下所示的例子是一个含义组别中，各个单词之间的关系，使用图进行表示。其中，motor
vehicle 和 car 是上位和下位的关系。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-01.png?x-oss-process=image/resize,w_800" /></p>
<p>在 NLP 领域中，最著名的同义词词典是普林斯顿大学开发的 <a
href="https://wordnet.princeton.edu/">WordNet</a>，其至今被应用于各种自然语言处理应用中。</p>
<h2 id="缺陷">缺陷</h2>
<p>首先，同义词词典是一个人工标记的词典，制作词典会耗费巨大的人力成本。</p>
<p>其次，同义词必须要随着语言的发展而更新。一方面，语言会出现新的单词，比如：团购、众筹等；另一方面，语言的含义也会发生变化，比如：卧龙凤雏，其含义从往年的褒义词变成了如今的贬义词。</p>
<p>然而最致命的缺陷还是同义词词典
<strong>无法表示单词含义的微妙差异</strong>。各种语言中都存在单词含义相同，但是用法不同的情况，而这种细微的差别在同义词词典中是无法表示出来的。</p>
<h1 id="计数法">计数法</h1>
<p>计数法，也称为统计法，其核心思想是
<strong>基于语料库（Corpus）中的大量文本数据，自动且高效地提取单词的本质信息</strong>。</p>
<h2 id="语料库预处理">语料库预处理</h2>
<p>语料库本质上就是文本数据而已，比如：Wikipedia、Google
News、文学作品集等。</p>
<p>在使用语料库之前，必须先进行预处理，预处理主要有以下几个步骤：</p>
<ul>
<li>对文本进行分词</li>
<li>为每个单词创建唯一的 ID</li>
<li>基于语料库创建（ID，单词）和（单词，ID）的映射表，便于后续进行查找</li>
</ul>
<p>如下所示，我们对一个简单的语料库进行预处理，分别得到
<code>id_to_word</code> 和 <code>word_to_id</code> 两个映射表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;you say goodbye and i say hello .&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>words</span><br><span class="line">[<span class="string">&#x27;you&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;goodbye&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id_to_word</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;you&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;say&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;goodbye&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;and&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;i&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="number">6</span>:<span class="string">&#x27;.&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word_to_id</span><br><span class="line">&#123;<span class="string">&#x27;you&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;say&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;goodbye&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;and&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;hello&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;.&#x27;</span>: <span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分布式表示">分布式表示</h2>
<p>在 NLP 中，广泛使用 <strong>分布式表示</strong>（Distributed
Representation）来表示单词含义。分布式表示将单词表示为
<strong>固定长度的向量</strong>，其采用密集向量表示，即向量的大多数元素是由非
0 实数表示的。比如，一个三维分布式表示
<code>[0.21, -0.45, 0.83]</code>。</p>
<p>为什么使用向量来表示？因为对于向量，我们可以使用
<strong>余弦相似度</strong>（Cosine
Similarity）来计算两个向量之间的夹角余弦值，余弦值越接近
1，表示向量夹角越小，说明相似度越高。使用向量表示单词，那么就可以计算不同单词含义之间的相似度。</p>
<p>假设，有两个向量 <span class="math inline">\(x = (x_1, x_2, x_3, ...,
x_n)\)</span> 和 <span class="math inline">\(y = (y_1, y_2, y_3, ...,
y_n)\)</span>，那么余弦相似度的定义如下。为了避免分母为
0，一般会给分母加上一个微小值 eps，默认其值为 0.00000001。</p>
<span class="math display">\[\begin{aligned}
similarity(x, y) = \frac{x \cdot y}{ ||x|| \space ||y|| }
=  \frac{x_1 y_1 + ... + x_n y_n}{\sqrt{x_1^2 + ... + x_n^2} \sqrt{y_1^2
+ ... + y_n^2}}
\end{aligned}\]</span>
<h2 id="分布式假设">分布式假设</h2>
<p>在 NLP 中，很多研究都是基于
<strong>分布式假设</strong>（Distributional
Hypothesis）完成的。分布式假设认为，<strong>一个单词的含义是由其周围的单词形成的</strong>。单词本身没有含义，其含义是由上下文（语境）形成的。相同的单词经常出现在相同的语境中，比如："I
drink beer." 和 "I drink wine."，drink 附近经常会出现饮料，beer 和 wine
则是含义相似的单词。</p>
<p>这里提到的“上下文”，指的是某个单词周围的单词。我们将上下文的大小称为
<strong>窗口大小</strong>（Window Size）。假如，窗口大小为
2，则表示上下文包含了目标单词前后各两个单词。如下所示，是一个窗口大小为
2 的示例。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-02.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="词嵌入">词嵌入</h2>
<p><strong>词嵌入</strong>（Word Embedding）表示
<strong>将单词映射到向量中间的过程或方法</strong>，也可以认为是
<strong>基于分布式假设将单词转换成分布式表示的过程或方法</strong>。</p>
<p>计数法的词嵌入，可以分为以下几个步骤：</p>
<ul>
<li>首先，进行语料库预处理，得到每个单词的 ID 以及两个映射表</li>
<li>其次，定义每个单词的向量维度为语料库中不同单词的数量</li>
<li>然后，定义上下文大小，即窗口大小</li>
<li>最后，根据窗口大小，为每个单词统计其上下文的单词数量，并记录在向量中指定位置（各个单词
ID 指定的位置）</li>
</ul>
<p>假设，我们以 “you say goodby and i say hello.”
作为语料库，定义窗口大小为 1。由于语料库中总共有 7
个不同的单词，包括句号，因此单词的向量维度等于 7。</p>
<p>首先，我们来看 "you" 的向量表示，其上下文只有一个单词
"say"，那么我们可以将单词 "say" 的 ID 对应在向量中的位置进行计数，值为
1，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-03.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，我们来看 “say” 的向量表示。语料库中 “say”
出现了两次，因此我们需要分别统计这两个 “say”
的上下文，并在向量对应的位置进行计数，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-04.png?x-oss-process=image/resize,w_800" /></p>
<p>当对语料库中所有单词进行了词嵌入的处理后，我们可以得到所有的单词的向量表示，它们共同构成了一个矩阵，我们称之为
<strong>共现矩阵</strong>（Co-ocurrence Matrix），如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="优化">优化</h2>
<h3 id="高频词汇问题">高频词汇问题</h3>
<p>共现矩阵的元素表示每个单词与其上下文的单词共同出现的次数。这种表示方法对于高频词汇可能会出现问题。比如：the
和 car 的共现次数会非常大，甚至要远远大于 car 和 drive
的共现次数。对于这种情况，实际上我们不应该认为 the 和 car
具有很强的相关性，因为 the 仅仅是一个常用词。</p>
<p>为了解决这个问题，我们可以使用 <strong>点互信息</strong>（Pointwise
Mutual Information，PMI）指标，其定义如下所示。</p>
<span class="math display">\[\begin{aligned}
PMI(x, y) = log_2 \frac{P(x, y)}{P(x) P(y)}
\end{aligned}\]</span>
<p>其中，<span class="math inline">\(P(x)\)</span> 表示 x
发生的概率，<span class="math inline">\(P(y)\)</span> 表示 y
发生的概率，<span class="math inline">\(P(x, y)\)</span> 表示 x 和 y
同时发生的概率。PMI 的值越高，表明相关性越强。</p>
<p>假设语料库的单词数量为 10000，the 出现 100 次，car 出现 20 次，drive
出现 10 次，the 和 car 共出现 10 次，car 和 drive 共出现 5
次。那么，我们可以计算一下 PMI 值，如下所示。</p>
<span class="math display">\[\begin{aligned}
PMI(the, car) = &amp; log_2 \frac{10 \cdot 10000}{1000 \cdot 20} \approx
2.32
\\
PMI(car, drive) = &amp; log_2 \frac{5 \cdot 10000}{20 \cdot 10} \approx
7.97
\end{aligned}\]</span>
<p>通过
PMI，我们可以解决高频词汇在共现矩阵中对于单词关联性的影响。不过，PMI也有一个问题，即当两个单词共现次数为
0 时，<span class="math inline">\(log_2 0 =
-\infty\)</span>。为了解决这问题，在实际中使用
<strong>正的点互信息</strong>（Positive
PMI，PPMI）来处理，其本质就是使用最小值 0
来进行兜底，其定义如下所示。</p>
<span class="math display">\[\begin{aligned}
PPMI(x, y) = max(0, PMI(x, y))
\end{aligned}\]</span>
<p>经过 PPMI 的处理，我们可以将共现矩阵转换成 PPMI 矩阵，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-06.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="向量维度问题">向量维度问题</h3>
<p>计数法还存在一个问题，那就是随着语料库词汇量的增加，各个单词向量的维数也会增加。如果语料库的词汇量达到
10 万，那么单词向量的维度也会达到 10
万。维度过高会导致处理计算量极大增加，而且向量中绝大多数元素都是
0，会造成存储空间浪费。对此，我们要对向量进行
<strong>降维</strong>（Dimensionality Reduction）。</p>
<p>降维的核心思想是
<strong>从稀疏矩阵中找到重要的轴，用更少的维度重新表示</strong>。比如下图所示，我们发现二维向量的分布具有某种特点，而这种特点可以使用一维向量来表示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-07.png?x-oss-process=image/resize,w_800" /></p>
<p>具体而言，我们可以使用 <strong>奇异值分解</strong>（Singular Value
Decomposition，SVD）来进行降维。关于 SVD
的工作原理，要解释明白的话，涉及的篇幅会很大，这里不作具体阐述，有兴趣的朋友可以自行去了解。</p>
<h1 id="推理法">推理法</h1>
<p>基于推理的方法，其本质上是基于神经网络来学习单词的内在含义，最终使用权重来表示单词的含义。推理法使用部分学习数据逐步进行学习；计数法则使用整个语料库进行数据统计，一次性处理得到单词的分布式表示。两者之间的差异如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-08.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="语料库预处理-1">语料库预处理</h2>
<p>类似于计数法，推理法也会对语料库进行预处理，主要有以下几个步骤：</p>
<ul>
<li>对文本进行分词</li>
<li>为每个单词创建唯一的 ID</li>
<li>为每个单词定义 one-hot 表示</li>
</ul>
<p>什么是 one-hot 表示？one-hot
表示会定义一个固定长度的向量，该向量的长度等于语料库中词汇的数量。每个单词的
one-hot 表示中，只有其 ID 对应的元素为 1，其余元素均为 0。如下所示为
one-hot 表示的示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-09.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="分布式表示-1">分布式表示</h2>
<p>推理法中单词的分布式表示是通过神经网络的权重来表示的。如下所示，输入层和中间层会构建一个全连接层，其中输入层的神经元数量等于
one-hot 表示的长度，也就是语料库的词汇数量，比如
7；中间层的神经元数量可以自定义，比如 3。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-10.png?x-oss-process=image/resize,w_800" /></p>
<p>通过学习，我们最终可以得到一个 7 x 3
的权重矩阵。我们使用任意一个单词的 one-hot
表示与权重矩阵进行乘积，即可提取到对应单词的分布式表示，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-11.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="词嵌入-1">词嵌入</h2>
<p>推理法的词嵌入方法很多，本质而言，这些方法都是基于不同的神经网络模型实现的，通常我们会直接用神经网络模型表示不同的方法，比如：word2vec、gloVe
等。这里我们主要介绍 word2vec 模型，其主要有两种架构，分别是：</p>
<ul>
<li>CBOW（Continuous Bag of
Words）模型：根据上下文的多个单词预测中间的单词</li>
<li>skip-gram 模型：根据中间的单词预测上下文的单词</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-12.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们分别来介绍这两种结构。</p>
<h3 id="cbow-模型">CBOW 模型</h3>
<p>CBOW
模型，也称为连续词袋模型，其工作原理是通过上下文的多个单词来预测中间的单词。</p>
<p>CBOW 模型包含了输入层、中间层、输出层。输入层接收单词的 one-hot
表示，中间层通过权重矩阵将输入转换成低维度的密集向量，输出层则使用
softmax 函数预测目标词的概率分布，如下所示。输出层的各个神经元经过
softmax 的计算可以得到各自的概率值，概率值最大的值转换成 1，其余转换成
0，由此得到的 one-hot 表示可以对应一个单词。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-13.png?x-oss-process=image/resize,w_800" /></p>
<p>CBOW 模型基于 softmax 函数和交叉熵误差进行学习，两者可以构建一个
Softmax with Loss 层，学习阶段时完备的神经网络结构如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-14.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="skip-gram-模型">Skip-gram 模型</h3>
<p>Skip-gram 模型，其工作原理是通过中间的单词预测上下文的单词。</p>
<p>Skip-gram
模型同样包含了输入层、中间层、输出。区别在于输出层只接收中间单词的
one-hot
编码，中间层同样通过权重矩阵转换成密集向量，输出层则为上下文中的每个单词分配概率，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-15.png?x-oss-process=image/resize,w_800" /></p>
<p>Skip-gram 模型的输出层数量与上下文单词的个数相同。因此需要通过
Softmax with Loss 层分别求出各个输出层的损失并求和。具体而言，skip-gram
模型的函数可以表示如下所示的函数。</p>
<span class="math display">\[\begin{aligned}
L = - \frac{1}{T} \sum_{t=1}^{T} (logP(w_{t-1}|w_t) + logP(w_{t+1}|w_t))
\end{aligned}\]</span>
<p>其中，<span class="math inline">\(P(w_{t-1}|w_t)\)</span> 表示给定
<span class="math inline">\(w_t\)</span> 时，<span
class="math inline">\(w_{t-1}\)</span> 发生的概率；<span
class="math inline">\(P(w_{t+1}|w_t)\)</span> 表示给定 <span
class="math inline">\(w_t\)</span> 时，<span
class="math inline">\(w_{t+1}\)</span> 发生的概率。</p>
<h3 id="cbow-vs-skip-gram">CBOW vs skip-gram</h3>
<p>关于 CBOW 和 skip-gram
的对比，从单词的分布式表示的准确度而言，skip-gram
的表现更好。从学习速度而言，CBOW 的表现更快。</p>
<p>在实际应用中，更多会选择
skip-gram。因为一旦生成了单词的分布式表示后，我们可以重复应用到各种场景中。因此可以无需考虑学习速度，更应该注重准确度。</p>
<h2 id="优化-1">优化</h2>
<p>推理法存在一个问题，即 one-hot 表示的维度问题。由于 one-hot
表示的维度等于语料库的词汇量数量，如果语料库的词汇量为 100
万，那么神经网络中各个层之间的矩阵运算的数据量将非常大，极其影响性能。</p>
<p>我们假设语料库词汇量有 100 万个，中间层神经元有 100 个，CBOW
模型如下所示。下面，我们将以 word2vec 的 CBOW 模型为例，进行优化。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-16.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="输入层维度问题">输入层维度问题</h3>
<p>首先，我们考虑 one-hot 表示对于输入层维度的影响。我们使用 one-hot
表示作为输入，one-hot 表示和权重矩阵 <span
class="math inline">\(W_{in}\)</span>
的乘积显然会耗费巨大的计算资源，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-17.png?x-oss-process=image/resize,w_800" /></p>
<p>从图中可以看出，矩阵乘法的目的是为了取出单词的 ID 在权重矩阵 <span
class="math inline">\(W_{in}\)</span>
中对应行的向量，即单词对应的向量表示。对此，我们可以创建一个层，专门用于从权重参数中提取
<strong>单词 ID 对应行（向量）</strong>，称之为 <strong>Embedding
层</strong>。</p>
<p>Embedding 层以单词 ID
作为输入，输出单词的向量表示。在反向传播时，权重只会更新单词 ID
对应行的权重，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-18.png?x-oss-process=image/resize,w_800" /></p>
<p>当引入 Embedding 层之后，我们可以得到 CBOW
模型的全貌图，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-20.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="输出层维度问题">输出层维度问题</h3>
<p>其次，我们考虑 one-hot 表示对于输出层维度的影响。</p>
<p>首先，权重矩阵 <span class="math inline">\(W_{out}\)</span> 的大小是
100 x 1000000，中间层的单词向量为 100。很显然，单词向量与权重矩阵 <span
class="math inline">\(W_{out}\)</span>
的乘积页会耗费巨大的计算资源。</p>
<p>其次，基于如下所示的 softmax 公式，我们可以看出 softmax
也存在计算量过大的问题。</p>
<span class="math display">\[\begin{aligned}
y_k = \frac{exp(s_k)}{\sum_{i=1}^{1000000} \space exp(s_i)}
\end{aligned}\]</span>
<p>对此，我们使用 <strong>负采样</strong>（Negative
Sampling）来进行优化。负采样的核心思想是
<strong>使用二分类拟合多分类</strong>。举个例子，在未优化的实现中，我们使用
softmax 计算出所有单词的概率值，由此构建一个 one-hot
结果，来与正确值进行对比。而负采样的实现中，我们给定一个单词，神经网络计算这个单词的概率，判断它是否是正确值。这样就能将计算复杂度从
O(N) 降低至 O(1)，其示意图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-19.png?x-oss-process=image/resize,w_800" /></p>
<p>另一方面，<strong>在多分类的情况下，输出层使用 softmax
函数将得分转化为概率，损失函数使用交叉熵误差。在二分类的情况下，输出层使用
sigmoid 函数，损失函数也使用交叉熵误差</strong>。因此，我们可以进一步将
Softmax-with-Loss 替换成
Sigmoid-with-Loss，得到如下所示的二分类神经网络。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-21.png?x-oss-process=image/resize,w_800" /></p>
<p>至此，我们已经将多分类问题转换成了二分类问题，神经网络结构也进行了优化。下面，我们来看看二分类情况下如何进行学习。</p>
<h4 id="负采样的样本学习">负采样的样本学习</h4>
<p>负采样的样本学习，核心思想是使用一个正例、采样选择若干个负例，对这些数据的损失求和，基于此来进行学习，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nlp-word-presentation-22.png?x-oss-process=image/resize,w_800" /></p>
<p>关于负例的选择，负采样的做法是：基于语料库中单词使用频率，计算出各个单词的概率分布，然后基于概率分布对单词进行采样。这样可以尽可能保证单词的出现概率与真实的情况类似。此外，为了避免稀有单词出现的概率过低，这里还会对概率分布进行调整，如下所示。</p>
<span class="math display">\[\begin{aligned}

P&#39;(w_i) = \frac{P(w_i)^{0.75}}{\sum_j^n P(w_j)^{0.75}}

\end{aligned}\]</span>
<h1 id="计算法-vs-推理法">计算法 vs 推理法</h1>
<p>最后，我们来简单对比一下计数法和推理法。</p>
<p>首先，两种方法在学习机制上存在差异。计数法通过对整个语料库的统计数据进行一次学习来获得单词的分布式表示；推理法则反复基于语料库的部分数据进行学习。每当语料库新增词汇时，计数法需要重新计算，完成共现矩阵生成、SVD
等一系列操作。推理法则可以允许参数的增量学习，可以将之前学习到的权重作为下一次学习的初始值。</p>
<p>其次，两种方法在单词的分布式表示的性质上存在差异。计数法主要是编码单词的相似性。推理法除了单词的相似性之外，还能理解单词之间更复杂的模式，比如能够求解
"king - man + woman = queen" 这样的类推问题。</p>
<p>当然，如果只评判单词的相似性，两种方法则不相上下。</p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了自然语言处理中的核心问题之一——单词含义的表示。由此，我们介绍了三种方法，分别是词典法、计数法、推理法。</p>
<p>词典法的核心思想是
<strong>将含义相同或含义类似的单词归类到同一个组中，同时定义单词之间细粒度的层级关系，比如：上位与下位的关系，整体与局部的关系</strong>。</p>
<p>计数法的核心思想是
<strong>基于语料库（Corpus），根据上下文的窗口大小，统计目标词周围的单词的频率</strong>，这种方法的依据是
<strong>分布式假设</strong>，即一个单词的含义是由其周围的单词形成。</p>
<p>推理法则是采用了神经网络的方式，学习样本数据，更新权重，以权重作为单词含义的表示。文中，我们介绍了
word2vec 模型的两种架构，分别是 CBOW 和 skip-gram。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《深度学习：自然语言处理》</li>
<li>《图解GPT》</li>
<li><a
href="https://www.53ai.com/news/qianyanjishu/2024070628415.html">一文彻底搞懂Transformer
- Word Embedding（词嵌入）</a></li>
<li>Pennington, Jeffrey, Richard Socher, Christopher D. Manning.Glove:
Global Vectors for Word Representation[J]. EMNLP. Vol.14. 2014.</li>
</ol>
]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>词典法</tag>
        <tag>计数法</tag>
        <tag>推理法</tag>
        <tag>word2vec</tag>
        <tag>CBOW</tag>
        <tag>skip-gram</tag>
        <tag>SVD</tag>
        <tag>负采样</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络</title>
    <url>/2024/10/26/rnn-introduction/</url>
    <content><![CDATA[<p>前面，我们介绍了适用于图像和视觉领域的 <a
href="https://chuquan.me/2024/09/28/cnn-introduction/">卷积神经网络</a>。本文，我们来介绍适用于时序数据处理场景的
<strong>循环神经网络</strong>（Recurrent Neural Network，RNN）。</p>
<span id="more"></span>
<h1 id="前馈神经网络的局限性">前馈神经网络的局限性</h1>
<p>我们首先来介绍一下前馈神经网络的局限性。什么是前馈神经网络？其特征是数据在神经网络中单向流动，从输入层经过隐藏层达到输出层，中间不存在反馈连接。前面我们介绍的入门级神经网络、卷积神经网络都属于前馈神经网络。</p>
<p>前馈神经网络的一个缺点是无法处理时序数据，通常只适用于一次输入，一次输出的场景。根本原因在于其不存在记忆能力，类似函数式编程中的纯函数，其内部不存在状态，当输入相同时，则输出也相同。</p>
<h1 id="循环神经网络">循环神经网络</h1>
<p>循环神经网络解决了前馈神经网络无法解决的问题，经过训练后可以处理时序数据。时序数据是指具有顺序或时间关联性的数据，比如：视频流、音频流、构成文章或句子的单词序列等。因此，RNN
非常适合语言翻译、语音识别、图像字幕、自然语言处理等场景。</p>
<p>类似于 CNN 包含卷积层、池化层，RNN 的特征是包含一个循环层（Recurrent
Layer），不过大多数情况下称为 “RNN 层”。下面，我们来重点介绍一下 RNN
层的工作原理。</p>
<h1 id="rnn-与-time-rnn">RNN 与 Time RNN</h1>
<p>下图所示，是 RNN
层的两种数据流向示意图。经典的表示法采用水平流向表示，为了方便分析，后续我们将使用垂直流向表示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-01.png?x-oss-process=image/resize,w_800" /></p>
<p>RNN 层内部具有环路，数据在层内循环。下标 <span
class="math inline">\(t\)</span> 表示时间，当时序数据 <span
class="math inline">\((x_0, x_1, ..., x_t, ...)\)</span> 输入到 RNN
层后，将输出 <span class="math inline">\((h_0, h_1, ..., h_t,
...)\)</span> 等 <strong>隐藏状态</strong>（Hidden State）。</p>
<p>为了进一步分析环路的数据走向，我们对 RNN
层进行循环展开，如下所示。可以看出，各个时刻的 RNN
层接收两个输入，分别是：</p>
<ul>
<li><strong>当前时刻的时序数据输入</strong></li>
<li><strong>前一时刻的隐藏状态输出</strong></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-02.png?x-oss-process=image/resize,w_800" /></p>
<p>很显然，循环展开后包含了各个时刻的 RNN 层。为了区分，我们重新定义 RNN
的不同结构。</p>
<ul>
<li><strong>RNN 层</strong>：表示单一时刻的 RNN 层</li>
<li><strong>Time RNN 层</strong>：表示由多个单一时刻 RNN 层所构成的 RNN
层</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-08.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="正向传播">正向传播</h2>
<p>我们先来看下 RNN
层的正向传播计算图，如下所示。其内部包含三种运算，分别是：</p>
<ul>
<li>矩阵乘法：MatMul 节点</li>
<li>矩阵加法：Sum 节点</li>
<li>激活函数：tanh 节点，即双曲正切函数</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-03.png?x-oss-process=image/resize,w_800" /></p>
<p>可以看出，其内部包含两个权重，分别是将输入 <span
class="math inline">\(x\)</span> 转化为输出 <span
class="math inline">\(h\)</span> 的权重 <span
class="math inline">\(W_x\)</span>
和将前一时刻的输出转换为当前时刻的输出的权重 <span
class="math inline">\(W_h\)</span>。此外，还有偏置 <span
class="math inline">\(b\)</span>。这里的 <span
class="math inline">\(h_{t-1}\)</span> 和 <span
class="math inline">\(x_t\)</span>
都是行向量。根据计算图，我们最终可以得出如下的计算公式。</p>
<span class="math display">\[\begin{aligned}
h_t = tanh(h_{t-1}W_h + x_t W_x + b)
\end{aligned}\]</span>
<p>由此，我们可以认为 RNN 具有 “状态” <span
class="math inline">\(h\)</span>，并基于此进行运算，这也是 RNN 层是
“具有状态的层” 或 “具有记忆的层” 的原因。</p>
<p>相比 RNN 层，Time RNN 层的正向传播在输入和输出侧有所不同。Time RNN 将
<span class="math inline">\((x_0, x_1, ..., x_{T-1})\)</span> 捆绑为
<span class="math inline">\(xs\)</span> 作为输入，将 <span
class="math inline">\((h_0, h_1, ..., h_{T-1})\)</span> 捆绑为 <span
class="math inline">\(hs\)</span> 作为输出，内部则是由多个 RNN
层连接而成。</p>
<h2 id="反向传播">反向传播</h2>
<p>下图所示为 RNN 层的反向传播计算图。结合 <a
href="https://chuquan.me/2024/09/21/deep-learning-layer/">《神经网络的分层设计原理》</a>
中基于计算图计算反向传播梯度的方法，我们可以很容易求解 RNN
层的反向传播梯度。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-07.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示为 Time RNN 层的反向传播计算图。上游的梯度记为 <span
class="math inline">\(dhs\)</span>，下游的梯度记为 <span
class="math inline">\(dxs\)</span>。这是 Time RNN
层作为整体在外部的反向传播路径。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-09.png?x-oss-process=image/resize,w_800" /></p>
<p>关于 Time RNN 层内部各个时刻的 RNN
层的反向传播路径，具体方法有两种，分别是：</p>
<ul>
<li><strong>基于时间的反向传播</strong>（Backpropagation Through
Time，BPTT），简称 BPTT</li>
<li>基于 BPTT 进行分段截断，简称 Truncated BPTT</li>
</ul>
<h3 id="bptt">BPTT</h3>
<p>BPTT 的核心思想很简单，对 Time RNN
层进行循环展开，由此求各个时刻的目标梯度，即按时间顺序展开的神经网络的误差传播法。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-04.png?x-oss-process=image/resize,w_800" /></p>
<p>随着时序数据的时间跨度增大，BPTT 反向传播会出现以下几个问题：</p>
<ul>
<li>内存成比例增大，因为各个时刻的 RNN 层会存储中间数据。</li>
<li>时间成比例变长，因为误差（梯度）会按顺序反向传播。</li>
<li>梯度逐渐不稳定，比如：梯度爆炸、梯度消失。</li>
</ul>
<h3 id="truncated-bptt">Truncated BPTT</h3>
<p>为了解决反向传播的长时序数据问题，一种自然而然的方法是 <strong>将
Time RNN 层循环展开后的反向传播路径进行分段截断</strong>，这就是
Truncated BPTT
的核心思想。这里要注意的是，我们只截断反向传播，而不截断正向传播，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-05.png?x-oss-process=image/resize,w_800" /></p>
<p>下图所示是 Truncated BPTT
的训练示意图。我们来看一下它是如何对时序数据过大产生的问题进行优化的。</p>
<ul>
<li>对于时间问题，由于反向传播依赖正向传播的中间数据，即使是 Truncated
BPTT，也需要按序的正向传播。只不过对于反向传播，每个分段可以并行处理。从而在一定程度上提高训练速度。</li>
<li>对于梯度问题，截断后也能够在一定程度上缓解梯度不稳定的情况，前提是要选择合适的截断长度。</li>
<li>对于内存问题，此时我们无需积累完整路径的所有中间数据后才进行反向传播，因此也有了一定程度的内存优化。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-06.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="rnn-语言模型">RNN 语言模型</h1>
<p>RNN 语言模型（Language Model），简称 RNNLM，是一个基于 RNN
层实现的神经网络，用于理解和生成自然语言文本。</p>
<p>我们考虑一个问题：当输入的内容为 “Tom was watching TV in his room.
Mary came into the room. Mary said hi to _”
时，如何预测最后一个单词是什么？很显然，最后一个单词应该是
“Tom”。但是，由于 “Tom”
单词相距预测点太远，常规的神经网络无法有效地进行预测。对此，基于 RNN
的语言模型 RNNLM 可以有效解决这个问题。</p>
<p>下图所示是一个简单的 RNNLM 的神经网络模型。每一个 RNN
层的上下游都有对应的神经网络层，比如：Embedding、Affine、Softmax
等，用于处理单一时刻的时序数据。类似于 RNN 和 Time RNN
的关系，这里我们将整体处理含有 <span class="math inline">\(T\)</span>
个时序数据的层称为 “Time XX 层”。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-10.png?x-oss-process=image/resize,w_800" /></p>
<p>对于学习阶段，RNNLM 中也有对应的 Time Softmax with Loss
层，如下所示。<span class="math inline">\(x_0\)</span>、<span
class="math inline">\(x_1\)</span> 等数据是推理输出的得分，<span
class="math inline">\(t_0\)</span>、<span
class="math inline">\(t_1\)</span> 等数据是正确解标签。<span
class="math inline">\(T\)</span> 个 Softmax with Loss
层各自计算损失，求和取平均值，作为最终的损失。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-11.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="梯度爆炸和梯度消失">梯度爆炸和梯度消失</h1>
<p>前面我们提到 RNN
在学习时序数据的长期依赖时，会存在梯度爆炸和梯度消失的问题。这里我们来介绍一下深层次的原因。</p>
<p>如下图所示，我们仅关注 Time RNN 层中的梯度传播。这里考虑长度为 <span
class="math inline">\(T\)</span>
的时序数据，在反向传播过程中，梯度会反复经历多次 tanh、sum、MatMul
的运算：</p>
<ul>
<li>sum：加法的导数是常数 1</li>
<li>tanh：当 <span class="math inline">\(y = tanh(x)\)</span>
时，其导数为 <span class="math inline">\(\frac{dy}{dx} = 1 -
y^2\)</span></li>
<li>MatMul：矩阵乘法的导数计算可以参考 <a
href="https://chuquan.me/2024/09/21/deep-learning-layer/#matmul-%E8%8A%82%E7%82%B9">《神经网络的分层设计原理》</a></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-12.png?x-oss-process=image/resize,w_800" /></p>
<p>首先，我们来看 tanh 对于反向传播梯度的影响。下图所示为 tanh
及其导数的曲线图，导数值的范围为 [0, 1]。当多次经过 tanh
节点时，梯度值会不断进行乘积，会逐渐减小，趋近于
0。这正是梯度消失的原因之一。这里主要是因为激活函数 tanh
导致的，如果将其改为 ReLU，可以有效抑制梯度消失的问题。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-13.png?x-oss-process=image/resize,w_800" /></p>
<p>然后，我们考虑 MatMul 对于反向传播梯度的影响。简单起见，我们忽略 tanh
节点的影响。下图所示为 MatMul 的反向传播计算图，其中 <span
class="math inline">\(W_h\)</span> 保持不变，当时序数据越长，<span
class="math inline">\(W_h^T\)</span> 的乘积次数越多。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-14.png?x-oss-process=image/resize,w_800" /></p>
<p>由此可以看出梯度爆炸或者梯度消失，取决于矩阵，更专业的术语是矩阵奇异值。矩阵奇异值本质上表示数据的离散程度，根据奇异值（更准确地说是多个奇异值中的最大值）是否大于
1。如果奇异值的最大值大于
1，可以预测梯度很有可能会呈指数级增加，即梯度爆炸；如果奇异值的最大值小于
1，可以预测梯度会呈指数级减少，即梯度消失。当然，并不是说奇异值比 1
大就一定会出现梯度爆炸。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-15.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="梯度爆炸优化">梯度爆炸优化</h1>
<p><strong>梯度裁剪</strong>（Gradient
Clipping）可以用于解决梯度爆炸，其基本思想可以用如下所示的伪代码表示。</p>
<span class="math display">\[\begin{aligned}
if \space \space \space || \hat g || \geq &amp; \space threshold
\\
\hat g = &amp; \space \frac{threshold}{|| \hat g ||} \hat g
\end{aligned}\]</span>
<p>这里将神经网络所有参数的梯度整合成一个，用符合 <span
class="math inline">\(\hat g\)</span> 表示。<span
class="math inline">\(threshold\)</span> 表示阈值。当 <span
class="math inline">\(\hat g\)</span> 大于或等于阈值，则对 <span
class="math inline">\(\hat g\)</span> 进行裁剪。</p>
<h1 id="梯度消失优化">梯度消失优化</h1>
<p><strong>Gated RNN</strong> 可以用于解决梯度消失，其从根本上改变了 RNN
结构。目前业界已经出现了诸多 Gated RNN 网络结构，其中具有代表性的有 LSTM
和 GRU。下面，我们分别来进行介绍。</p>
<h2 id="lstm">LSTM</h2>
<p>LSTM（Long Short-Term Memory），长短期记忆网络。类似于 RNN 和 Time
RNN，这里也存在 LSTM 和 Time LSTM 的区别。这里，我们主要介绍单个时刻的
LSTM 结构。</p>
<p>如下所示，LSTM 与 RNN 的区别在于 LSTM 具有额外的记忆单元 <span
class="math inline">\(c\)</span>，其只存在于 Time LSTM
内部，不会其它层进行传输。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-16.png?x-oss-process=image/resize,w_800" /></p>
<p>LSTM
内部包含多种结构，包括：输出门、遗忘门、记忆单元、输入门等，下面我们先从
LSTM 的基本结构进行介绍。</p>
<h3 id="基本结构">基本结构</h3>
<p>LSTM 中的记忆单元 <span class="math inline">\(c_t\)</span>
存储了过去到时刻 <span class="math inline">\(t\)</span>
的所有记忆，并基于此向外部层和下一时刻的 LSTM 输出隐藏状态 <span
class="math inline">\(h_t\)</span>。</p>
<p>下图所示，LSTM 中当前记忆单元 <span
class="math inline">\(c_t\)</span> 基于 3 个输入 <span
class="math inline">\(c_{t-1}\)</span>、<span
class="math inline">\(h_{t-1}\)</span>、<span
class="math inline">\(x_t\)</span>
经过“某种计算”得出。最后输出的隐藏状态 <span
class="math inline">\(h_t\)</span> 是在 <span
class="math inline">\(c_t\)</span> 的基础上应用 tanh
函数计算得到的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-17.png?x-oss-process=image/resize,w_800" /></p>
<p>这里提到的“某种计算”是下面要介绍的各种运算，它们都会涉及到一个概念——<strong>门</strong>（Gate）。门的本质就是阀门，可以控制流过数据的大小。在神经网络中，激活函数的概念与它非常相似。因此，LSTM
使用经典的激活函数 <code>sigmoid</code> 作为各种门结构，后续将使用 <span
class="math inline">\(\sigma\)</span> 符号进行表示。</p>
<h3 id="输出门">输出门</h3>
<p>首先，LSTM 增加了 <strong>输出门</strong>（Output Gate）。输入 <span
class="math inline">\(x_t\)</span> 有权重 <span
class="math inline">\(W_x\)</span>，输入隐藏状态 <span
class="math inline">\(h_{t-1}\)</span> 有权重 <span
class="math inline">\(W_h\)</span>。将它们的矩阵乘积和偏置 <span
class="math inline">\(b\)</span> 之和传入 <span
class="math inline">\(sigmoid\)</span> 函数，结果就是输门的输出值 <span
class="math inline">\(o\)</span>。</p>
<span class="math display">\[\begin{aligned}
o = \sigma (x_t W_x + h_{t-1} W_h + b)
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-18.png?x-oss-process=image/resize,w_800" /></p>
<p>输出门的输出值 <span class="math inline">\(o\)</span> 进一步与 <span
class="math inline">\(tanh(c_t)\)</span>
进行乘积。注意，这里的乘积并不是矩阵乘积，而是
<strong>阿达玛乘积</strong>，即矩阵对应元素之间的乘积。如果使用 <span
class="math inline">\(\circ\)</span> 表示阿达玛乘积，其计算式如下。</p>
<span class="math display">\[\begin{aligned}
h_t = o \circ tanh(c_t)
\end{aligned}\]</span>
<h3 id="遗忘门">遗忘门</h3>
<p>为了模拟更真实的记忆效果，LSTM 加入了 <strong>遗忘门</strong>（Forget
Gate），其计算图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-19.png?x-oss-process=image/resize,w_800" /></p>
<p>遗忘门的计算与输出门类似，区别在于两者在计算图中的位置不同，其计算式如下。</p>
<span class="math display">\[\begin{aligned}
f = \sigma (x_t W_x + h_{t-1} W_h + b)
\end{aligned}\]</span>
<h3 id="记忆单元优化">记忆单元优化</h3>
<p>如果针对记忆单元，我们只增加遗忘门，那么会导致记忆逐步遗忘。因此，我们还要增加强化记忆的结构，由此对记忆单元进行优化。这里，我们增加
tanh 节点，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-20.png?x-oss-process=image/resize,w_800" /></p>
<p>tanh 节点计算与其他门的计算类似，如下所示。</p>
<span class="math display">\[\begin{aligned}
g = tanh(x_t W_x + h_{t-1} W_h + b)
\end{aligned}\]</span>
<p>基于 tanh 节点计算得到的结果 <span class="math inline">\(g\)</span>
最终与加到上上一时刻的记忆单元 <span
class="math inline">\(c_{t-1}\)</span> 中，从而形成新的记忆。</p>
<h3 id="输入门">输入门</h3>
<p>输入门判断新增信息 <span class="math inline">\(g\)</span>
的各个元素的价值，会对待添加的信息进行取舍，其计算图如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-21.png?x-oss-process=image/resize,w_800" /></p>
<p>输入门的输出值计算如下所示。</p>
<span class="math display">\[\begin{aligned}
i = \sigma (x_t W_x + h_{t-1} W_h + b)
\end{aligned}\]</span>
<h3 id="完整结构">完整结构</h3>
<p>最后，我们可以得到如下所示的 LSTM 完整结构，可以看出 LSTM 是在 RNN
的基础上增加了一系列门结构以及相关运算实现的。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-22.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="反向传播-1">反向传播</h3>
<p>接下来，我们来看一下为什么 LSTM
能够解决梯度消失的问题。其原因可以通过观察记忆单元 <span
class="math inline">\(c\)</span> 的反向传播来了解，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-23.png?x-oss-process=image/resize,w_800" /></p>
<p>记忆单元的反向传播会反复经过 “+” 和 “×” 节点。“+” 节点的导数是
1，会直接传递上游梯度至下游。“×”
节点并不是矩阵乘积，而是阿达玛乘积。阿达玛乘积是矩阵中对应元素的乘积运算，而且每次都会基于不同的门值进行乘积运算，因此不会发生梯度消失或梯度爆炸。</p>
<p>在反向传播过程中，遗忘门认为应该忘记的记忆单元元素，其梯度会变小；不能忘记的记忆单元元素，其梯度并不会退化。因此，可以期待记忆单元能够保存学习长期的依赖关系。</p>
<h2 id="gru">GRU</h2>
<p>GRU（Gated Recurrent Unit），门控循环单元，其继承了 LSTM
的思路，但是减少了参数，缩短了计算时间。</p>
<p>GRU 的计算图和计算式如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rnn-introduction-24.png?x-oss-process=image/resize,w_800" /></p>
<span class="math display">\[\begin{aligned}
z = &amp; \space \sigma (x_t W_x + h_{t-1} W_h + b)
\\
r = &amp; \space \sigma (x_t W_x + h_{t-1} W_h + b)
\\
\widetilde{h} = &amp; \space tanh (x_t W_x + h_{t-1} W_h + b)
\\
h_t = &amp; \space (1 - z) \circ h_{t-1} + z \circ \widetilde{h}
\end{aligned}\]</span>
<p>GRU 没有记忆单元，只有一个隐藏状态 <span
class="math inline">\(h\)</span>
在时间方向上传播。其使用了两个门结构：<span
class="math inline">\(r\)</span>（reset 门）、<span
class="math inline">\(z\)</span>（update 门）。</p>
<p><span class="math inline">\(r\)</span>
决定在多大程度上“忽略”过去的隐藏状态。如果 <span
class="math inline">\(r\)</span> 为 0，则新的隐藏状态 <span
class="math inline">\(\widetiled{h}\)</span> 只取决于 <span
class="math inline">\(x_t\)</span>，即过去的隐藏状态被忽略。</p>
<p><span class="math inline">\(z\)</span>是更新隐藏状态的门，其包含了
LSTM 中遗忘门和输入门的作用。<span
class="math inline">\(\widetilde{h}\)</span> 中的 <span
class="math inline">\((1-z)\circ h_{t-1}\)</span>
表示遗忘门的功能；<span class="math inline">\(z \circ
\widetilde{h}\)</span> 表示输入门的功能。</p>
<p>整体而言，GRU 是简化版的 LSTM 架构，相比之下，GRU
的参数和计算成本更少。关于 GRU 和 LSTM
的选择，根据不同的任务和超参数的设置，结论可能不同。由于 GRU
超参数少、计算量小，因此比较适合于数据集较小，设计模型需要反复实验的场景。</p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了循环神经网络的结构，其内部根据时序数据可以展开成多个循环结构。为了区分，我们将整体称为
Time RNN，将内部的单个循环结构称为 RNN。</p>
<p>Time RNN 的反向传播主要有两种方法，分别是：BPTT 和 Truncated
BPTT。后者是在前者的基础上对反向传播路径进行分段截断。从而在一定程度上缓解时序数据过长带来的时间问题、梯度问题、内存问题。</p>
<p>之后，我们进一步介绍了梯度问题中，梯度爆炸和梯度消失出现的原因。对于梯度爆炸，我们介绍了梯度裁剪的方法。对于梯度消失，我们介绍了
Gate RNN 的两种结构：LSTM 和 GRU。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《深度学习进阶：自然语言处理》</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>RNN</tag>
        <tag>LSTM</tag>
        <tag>Gated RNN</tag>
        <tag>GRU</tag>
        <tag>Time RNN</tag>
        <tag>BPTT</tag>
        <tag>Truncated BPTT</tag>
      </tags>
  </entry>
  <entry>
    <title>语言模型中的注意力机制</title>
    <url>/2024/11/02/attention-introduction/</url>
    <content><![CDATA[<p>前一篇文章 <a
href="https://chuquan.me/2024/10/26/rnn-introduction/">循环神经网络</a>
中我们介绍了 RNN、LSTM、GRU
等。本文，我们将以此为基础，进一步介绍大名鼎鼎的
<strong>注意力机制</strong>。</p>
<span id="more"></span>
<h1 id="语言模型">语言模型</h1>
<p>我们首先介绍一下 <strong>语言模型</strong>（Language
Model）。语言模型是一种通过学习大量文本数据来理解和生成语言的计算模型，其主要功能包括：</p>
<ul>
<li><strong>文本生成</strong>：根据给定的上下文生成连贯的文本</li>
<li><strong>语言理解</strong>：识别和理解句子的结构和含义</li>
<li><strong>预测下一个词</strong>：基于前面的词预测接下来的词</li>
</ul>
<p>语言模型通常使用深度学习中的神经网络来训练，可以应用于各种自然语言处理任务，如：翻译、情感分析、问答系统等。</p>
<p>2010 年，托马斯·米科洛夫提出了基于 RNN 的语言模型。由于简单 RNN
存在梯度消失和梯度爆炸问题，实际应用中更多会使用 LSTM、GRU 等 Gated
RNN。</p>
<p>下图所示，是一个基于 LSTM
的简单语言模型，其根据输入单词输出下一个出现的单词的概率分布，并概率性地选择下一个单词。然后，将输出单词继续作为下一个输入单词，自回归地进行输出，从而实现文本自动生成。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-02.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="seq2seq-模型">seq2seq 模型</h1>
<p>除了上述普通的语言模型，我们考虑将一种时序数据转换成另一种时序数据的模型，比如：机器翻译、语音识别等场景，这里我们引入一种基于两个
RNN 的模型——seq2seq模型。</p>
<p>seq2seq 模型，也称为 <strong>Encoder-Decoder</strong> 模型，其中
Enoder（编码器）对输入数据进行编码，解码器对已编码的数据进行解码。中间的编码数据本质上就是神经网络的隐藏状态。下图所示，是一个
seq2seq 模型的示意图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="编码器">编码器</h2>
<p>seq2seq 模型的编码器是一个基于 RNN
的简单模型，其层结构如下所示。编码器利用 RNN 将时序数据转换成隐藏状态
<span class="math inline">\(h\)</span>。这里的 RNN 是
LSTM，不过也可以使用简单 RNN 或 GRU 等。</p>
<p>编码器的输出向量 <span class="math inline">\(h\)</span> 是 LSTM
层最后一个的隐藏状态，其中编码了输入文本的关键信息。这里的重点是，LSTM
的隐藏状态 <span class="math inline">\(h\)</span> 是一个
<strong>固定长度</strong>
的向量。本质而言，编码就是将任意长度的文本转换成一个固定长度的向量。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-03.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="解码器">解码器</h2>
<p>seq2seq 面模型的解码器也是一个基于 RNN
的简单模型，如下图所示，其与上一节介绍简单语言模型的神经网络完全相同。唯一的区别在于，LSTM
层会接收隐藏向量 <span
class="math inline">\(h\)</span>。正是这个区别使得普通语言模型变成可以完成翻译功能的解码器。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-04.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="应用">应用</h2>
<p>seq2seq
可以将一个时序数据转换成另一个时序数据，这种时序数据转换可以应用在各种任务中，比如：</p>
<ul>
<li>机器翻译：将 “一种语言的文本” 转换成 “另一种语言的文本”</li>
<li>自动摘要：将 “一个长文本” 转换成 “短摘要”</li>
<li>问答系统：将 “问题” 转换成 “答案”</li>
<li>自动回复：将 “接收文本” 转换成 “回复文本”</li>
</ul>
<p>除了文本之外，seq2seq 还可以处理图像、语音等类型的数据。下图所示是
seq2seq 在 <strong>自动图像描述</strong>（Image
Captioning）中的应用，可以将 “图像” 转换成
“文本”。其神经网络结构与上面介绍的 seq2seq 模型的区别在于，编码器从 LSTM
转换成 CNN，解码器仍然保持不变。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-05.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="问题">问题</h2>
<p>当然，seq2seq
也存在一个很大的问题。编码器输出的是固定长度的向量，这意味着无论输入语句多长，都会被转换成长度固定的向量，如下图所示。很显然，如果文本的信息特别多，固定长度的向量显然是无法承载全部的信息的，如同一个衣柜无法塞下过多的衣服一样。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-06.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="注意力机制">注意力机制</h1>
<p>为了解决 seq2seq 的问题，我们将介绍进一步强化 seq2seq 的
<strong>注意力机制</strong>（Attention Machanism，简称
Attention）。那么到底什么是注意力机制呢？其核心思想是让模型在处理输入数据时，能够“关注”特定的部分，从而更加有效地捕捉上下文信息。</p>
<h2 id="编码器优化">编码器优化</h2>
<p>针对 seq2seq
输出的固定长度向量表现力不足的问题，最直观的解决思路就是将编码器 RNN
各个时刻输出的隐藏状态 <span class="math inline">\(hs\)</span>
全部传递给解码器，从而摆脱一个固定长度向量的表现约束，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-07.png?x-oss-process=image/resize,w_800" /></p>
<p>当然，隐藏状态 <span class="math inline">\(hs\)</span>
中的每个向量都包含了各个时刻之前的所有信息。在实际使用中，考虑到各个向量的平衡性，编码器使用从两个方向处理时序数据的
<strong>双向 RNN</strong> 或 <strong>双向
LSTM</strong>，在向量的平衡性上会更加有效。</p>
<h2 id="解码器优化">解码器优化</h2>
<p>编码器输出了全部隐藏状态 <span
class="math inline">\(hs\)</span>，对此，解码器必须要从全部隐藏状态
<span class="math inline">\(hs\)</span> 中 “关注”
到关键信息，这就是注意力机制的核心目标。</p>
<p>整体而言，解码器的层结构如下图所示，“某种计算”
就是注意力机制的实现层，其接收解码器各个时刻的隐藏层状态和编码器的全部隐藏状态
<span class="math inline">\(hs\)</span>，最终输出至 Affine 层。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-08.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="实现原理">实现原理</h3>
<p>从具体实现而言，注意力机制的目标是从编码器隐藏状态 <span
class="math inline">\(hs\)</span>
中提取出与各个输出的单词有对应关系的单词向量。对此，其实现原理也比较简单，<strong>基于编码器的全部隐藏状态
<span class="math inline">\(hs\)</span>，结合一个注意力权重 <span
class="math inline">\(a\)</span>，进行加权求和，得到一个上下文向量 <span
class="math inline">\(c\)</span></strong>，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-09.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="注意力权重">注意力权重</h4>
<p>首先，我们考虑如何得到注意力权重 <span
class="math inline">\(c\)</span>。我们的目标是基于解码器的 LSTM
层的隐藏状态向量 <span
class="math inline">\(h\)</span>，判断其与编码器的全部隐藏向量 <span
class="math inline">\(hs\)</span>
中各个单词向量的相似性，从而构建注意力权重矩阵。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-10.png?x-oss-process=image/resize,w_800" /></p>
<p>计算向量之间的相似度，这里使用向量内积来表示，下图中使用 dot
节点表示。关于内积运算，假如向量 <span class="math inline">\(a = (a_1,
a_2, ..., a_n)\)</span> 和向量 <span class="math inline">\(b = (b_1,
b_2, ..., b_n)\)</span> 的进行内积运算，其结果如下所示。</p>
<span class="math display">\[\begin{aligned}
a \cdot b = a_1 b_1 + a_2 b_2 + ... + a_n b_n
\end{aligned}\]</span>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-11.png?x-oss-process=image/resize,w_800" /></p>
<p>为了方便一次性计算全部隐藏状态 <span
class="math inline">\(hs\)</span> 的各个向量与 <span
class="math inline">\(h\)</span> 之间的相似度，这里会对 <span
class="math inline">\(h\)</span>
进行广播，从而得到两个形状完全相同的矩阵。然后通过阿达玛乘积实现两个矩阵各自位置元素进行乘积。最后通过求和运算，对各个向量的阿达玛乘积结果进行求和。本质上就是实现上述的内积运算。下图所示，就是广播后进行阿达玛乘积的过程。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-15.png?x-oss-process=image/resize,w_800" /></p>
<p>计算得到初始的注意力权重后，我们还需要对它进行归一化处理，归一化处理一般则都是使用
softmax 函数进行处理，如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-12.png?x-oss-process=image/resize,w_800" /></p>
<p>最后，关于注意力权重的计算，我们可以得到如下所示的计算图。其中包含了阿达玛乘积节点和
Sum 节点。Repeat
节点主要是为了对矩阵进行广播，以符合矩阵运算的基本要求。注意，计算图中标注的
<code>N</code> 是 mini-batch 批量处理的数量。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-13.png?x-oss-process=image/resize,w_800" /></p>
<h4 id="加权求和">加权求和</h4>
<p>然后，我们考虑如何使用注意力权重，结合编码器的全部隐藏状态进行加权求和。这一步运算过程本质上注意力权重计算一样，只不过少了归一化处理。下图所示是基于全部隐藏状态
<span class="math inline">\(hs\)</span> 和注意力矩阵 <span
class="math inline">\(a\)</span> 进行加权求和的计算图。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-14.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="整体架构">整体架构</h3>
<p>我们可以将注意力权重、加权求和两个部分整体转换成如下所示的计算图。两者分别对应
Attention Weight 层和 Weight Sum 层，对外可以整体表示为 Attention
层。Attention 层以编码器的全部隐藏状态 <span
class="math inline">\(hs\)</span> 和解码器当前时刻的 LSTM 输出 <span
class="math inline">\(h\)</span> 作为输入，最终输出上下文向量 <span
class="math inline">\(c\)</span>。这就是注意力机制的技术核心。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-16.png?x-oss-process=image/resize,w_800" /></p>
<p>我们将 Attention
层重新加入解码器的层结构，可以得到如下所所示的层结构图。这里要注意的是，我们不仅将
Attention 层的输出的上下文向量输入至 Affine 层，还将 LSTM
层的隐藏状态也输入至 Affine 层。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-17.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="注意力机制的应用">注意力机制的应用</h1>
<p>在了解了注意力机制之后，我们再来看看 Attention 的相关应用。</p>
<h2 id="基于-attention-的-seq2seq">基于 Attention 的 seq2seq</h2>
<p>首先，我们可以对 seq2seq 模型进行优化。基于 Attention
的优化主要集中在解码器部分，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-18.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="gnmt">GNMT</h2>
<p>在机器翻译领域，经历过 <strong>基于规则的翻译</strong> 到
<strong>基于用例的翻译</strong>，再到
<strong>基于统计的翻译</strong>，以及如今的
<strong>神经机器翻译</strong>（Neural Machine Translation）。</p>
<p>谷歌翻译，全称谷歌神经机器翻译系统（Google，Neural Machine
Translation，GNMT）正是一种基于 Attention 的 seq2seq
模型，其由编码器、解码器、Attention
构成。当然，与我们介绍的简单模型不同，其为了提供精度做了更多的优化，比如：LSTM
层的多层化、双向 LSTM、skip connection 等，以及为了提高学习速度，支持多
GPU 的分布式学习，其层结构如下所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-19.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="transformer">Transformer</h2>
<p>最后，我们来介绍一下著名的 Transformer。</p>
<p>由于 RNN
必须基于上一时刻的计算结果进行迭代，因此难以在时间方向上进行并行计算。对此，在使用了
GPU
的并行计算环境下具有严重的性能瓶颈。于是，研究者提出了一个著名的模型——Transformer。Transformer
不用 RNN，而用 Attention 进行处理，其中使用了
<strong>自注意力</strong>（Self-Attention）技术。</p>
<p>自注意力机制是一种特殊的注意力机制，主要用于同一序列内的元素之间的关系建模，其允许模型在处理一个序列时，动态地关注该序列的其他部分。在结构上，自注意力的特点是两个输入都是同一个时序数据，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-20.png?x-oss-process=image/resize,w_800" /></p>
<p>下面，我们再来看下 Transformer 的简化层结构，如下图所示。Transformer
中使用 Attention 代替了 RNN，并且编码器和解码器都使用了
Self-Attention。图中 Feed Forward
层便是前馈神经网络，具体而言是具有一个隐藏层、激活函数为 ReLU
的全连接神经网络。<span class="math inline">\(N_x\)</span>
表示灰色背景包围的元素被堆叠了 N 次。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/attention-introduction-21.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>本文我们主要介绍了 seq2seq
模型，其主要由编码器和解码器两部分构成，内部使用了 RNN
层结构。但是，seq2seq
存在一个问题，即编码器输出固定长度的向量存在一定的局限性。当输入时序数据过长时，固定长度的向量无法承载全部信息。</p>
<p>为了解决 seq2seq
的问题，我们自然而言地想出使用编码器全部隐藏状态作为解码器的输入。为了让解码器能从全部隐藏状态中关注到关键信息，我们引出了注意力机制。注意力机制的核心思想是基于编码器的全部隐藏状态，结合注意力权重，进行加权求和，得到一个上下文向量。</p>
<p>最后，我们介绍了注意力机制的几种应用，分别是：基于 Attention 的
seq2seq、GMNT、Transformer。在 Transformer
中，其应用了注意力机制的一种特殊实现——自注意力。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li>《深度学习进阶：自然语言处理》</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>seq2seq</tag>
        <tag>Attention</tag>
        <tag>Self-Attention</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>正向理解 Objective-C AutoReleasePool 设计原理</title>
    <url>/2024/12/27/memory-management-autoreleasepool/</url>
    <content><![CDATA[<p>关于 Objective-C 的 AutoReleasePool
的机制，网上有非常多的文章对源码进行了详尽的剖析。不过，这些文章大多迷失在代码细节之中，没有从整体设计来进行介绍。本文，我们将从正向设计的角度来进行介绍。</p>
<span id="more"></span>
<p>这里我们先预设两个问题，后续再进行解答。</p>
<ul>
<li>为什么 AutoReleasePool 底层是双向链表结构？</li>
<li>为什么 AutoReleasePool 采用基于 AutoReleasePoolPage
的分页机制？</li>
</ul>
<h1 id="栈结构">栈结构</h1>
<p>一切要从栈开始说起。栈（Stack）是一种遵循先进后出（FILO，First In
Last
Out）的逻辑数据结构。栈有两个重要属性：栈底指针、栈顶指针。栈的底层实现一般有两种，分别是：</p>
<ul>
<li>基于数组实现</li>
<li>基于链表实现</li>
</ul>
<h2 id="基于数组的栈">基于数组的栈</h2>
<p>基于数组实现的栈结构，一般会使用动态数组来存储元素。</p>
<p>对于栈底指针，本质上保存了一个指向数组头部元素的索引；对于栈顶指针，也会维持一个指向数组尾部元素的索引，当执行
push 操作时，索引加一，当执行 pop 操作时，索引减一。</p>
<p>要注意的是，动态数组初始化时会分配一定大小的连续内存空间，当栈空间不足时（本质上是底层动态数组空间不足），会重新分配一段更大的连续内存空间，将原来的元素复制到新的内存空间中，并释放旧的内存空间。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-01.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="基于链表的栈">基于链表的栈</h2>
<p>基于链表的栈结构，是绝大多数标准库的选择，比如：C++ STL 中的 stack
就是基于 list 实现的，这里的 list 是一个双向链表。</p>
<p>为什么要使用双向链表？根本原因在于栈顶指针的控制。当执行 push
操作时，必须要正向延伸序列，此时需要有一个指向正方向的指针；当执行 pop
操作时，必须要反向回缩序列，此时则需要一个指向反方向的指针。对此，双向链表完美地契合了这个要求。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-02.png?x-oss-process=image/resize,w_800" /></p>
<p>那么为什么栈结构大多数使用双向链表实现，而不是动态数组呢？根本原因在于动态数组要求占用一段连续的内存空间，对于内存提出了更高的要求；而且当分配的内存空间不足时，需要重新分配一段更大的内存空间，同时还要拷贝原始数据，产生了更大的性能开销。</p>
<h1 id="函数栈帧">函数栈帧</h1>
<p>如下所示是 YYImage 中的一个 AutoReleasePool
的使用示例，使用大括号管理其作用域下的对象，这与函数（或方法）使用大括号管理其作用域下的局部变量非常相似。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">    <span class="keyword">if</span> (newImage) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasAlpha) &#123;</span><br><span class="line">            data = <span class="built_in">UIImagePNGRepresentation</span>([<span class="built_in">UIImage</span> imageWithCGImage:imageRef]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = <span class="built_in">UIImageJPEGRepresentation</span>([<span class="built_in">UIImage</span> imageWithCGImage:imageRef], <span class="number">0.9</span>); <span class="comment">// same as Apple&#x27;s example</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对此，我们来回顾一下函数栈帧的基本工作原理。<strong>当函数运行时，进程的栈空间中会为其创建一个对应的栈帧（Stack
Frame）来记录运行时产生的相关信息，当函数返回时则会销毁对应的栈帧</strong>。</p>
<h2 id="栈帧结构">栈帧结构</h2>
<p>下图所示为栈帧的通用结构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-03.png?x-oss-process=image/resize,w_800" /></p>
<p>每个栈帧会通过两个寄存器来表示其内存界限，分别是：</p>
<ul>
<li>EBP（Extended Base
Pointer），保存当前栈帧的基址，即开始位置，主要用于访问函数的参数和局部变量。</li>
<li>ESP（Extended Stack
Pointer），保存当前栈顶的地址，即结束位置，主要用于进行栈操作。</li>
</ul>
<p>栈帧内部保存运行时的相关信息，比如：</p>
<ul>
<li>调用者的栈帧基址，用于恢复调用者栈帧基址</li>
<li>调用者的寄存器，用于恢复调用者的状态</li>
<li>局部变量</li>
<li>下一个函数的参数</li>
<li>返回地址，用于表示调用者调用完成后继续执行的指令地址</li>
</ul>
<h1 id="autoreleasepool-内存管理">AutoReleasePool 内存管理</h1>
<p>AutoReleasePool
的用法与函数调用类似，其底层实现与函数栈帧类似。<strong>AutoReleasePool
的管理是基于栈结构设计的，栈结构底层使用双向链表实现；而函数栈帧的栈结构底层则是使用动态数组实现，本质上是连续的栈空间</strong>。</p>
<h2 id="设计思想">设计思想</h2>
<p>一般而言，链表节点是存储空间固定的数据结构，然而 AutoReleasePool
管理的对象数量是不固定的。那么该如何解决这个问题？</p>
<p>对此，提出了页面的概念——AutoReleasePoolPage。每个 AutoReleasePoolPage
可以存储固定数量的对象指针。一个 AutoReleasePool 由一个或多个
AutoReleasePoolPage 组成，其数量取决于要管理的对象数量。AutoReleasePool
底层就是以 AutoReleasePoolPage 作为链表节点实现的。</p>
<h2 id="结构实现">结构实现</h2>
<p>由于一个 AutoReleasePool 由一个或多个 AutoReleasePoolPage
组成，我们很容易想到如下所示的一种直观、清晰的结构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-04.png?x-oss-process=image/resize,w_800" /></p>
<p>上图所示的结构中，一个 AutoReleasePoolPage 只属于一个
AutoReleasePool。细心的读者可能会发现，这种结构存在一个问题，即
<strong>存在内存碎片</strong>。比如：AutoReleasePoolPage 1
中，只存储了一个对象地址，剩余的空间都没有被利用。</p>
<p>为了解决这个问题，AutoReleasePool 的优化方法是：</p>
<ul>
<li>多个 AutoReleasePool 可以共享一个 AutoReleasePoolPage</li>
<li>不同 AutoReleasePool 之间使用 <strong>哨兵对象</strong>
POOL_SENTINEL 来划分边界</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-05.png?x-oss-process=image/resize,w_800" /></p>
<p>通过哨兵对象，我们解决了内存碎片的问题，当然也改变了 AutoReleasePool
的边界定义。</p>
<ul>
<li>当我们声明一个 AutoReleasePool
时，必须添加一个新哨兵对象，从而标识当前 AutoReleasePool 的边界。</li>
<li>当我们释放一个 AutoReleasePool
时，必须追溯最近的哨兵对象，从而找到当前 AutoReleasePool 的边界。</li>
</ul>
<p>在此基础上，我们可以大致描绘出 AutoReleasePool 是如何管理对象的。</p>
<ul>
<li>当 AutoReleasePool
中实例化一个对象时，我们根据链表的尾指针，正向遍历，查看末端的
AutoReleasePoolPage 是否未满。
<ul>
<li>如果未满，则将对象指针存入 AutoReleasePoolPage 中；</li>
<li>否则，链表尾部新增一个 AutoReleasePoolPage
后，再将对象指针存入其中。</li>
</ul></li>
<li>当 AutoReleasePool
要释放全部对象时，我们根据链表的尾指针，反向遍历，找到最近的哨兵对象，并把中间部分的
AutoReleasePoolPage 、对象指针、哨兵对象全部释放。</li>
</ul>
<h1 id="代码分析">代码分析</h1>
<p>下面，我们通过分析 Objective-C 的 <code>main</code> 函数来了解
AutoReleasePool 的具体执行逻辑。<code>main.m</code>
中的定义如下所示，可以看出整个应用被包含在了一个 AutoReleasePool
中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> * appDelegateClassName;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// Setup code that might create autoreleased objects goes here.</span></span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="autoreleasepool"><span class="citation"
data-cites="autoreleasepool">@autoreleasepool</span></h2>
<p>我们使用 <code>clang</code> 将 <code>main.m</code> 重写转换成 C++
实现，如下所示。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ xcrun --sdk iphonesimulator clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
<p>经过转换后会生成一个 <code>main.cpp</code> 文件，<code>main</code>
函数的内部实现如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        appDelegateClassName = <span class="built_in">NSStringFromClass</span>(((<span class="built_in">Class</span> (*)(id, SEL))(<span class="type">void</span> *)objc_msgSend)((id)<span class="built_in">objc_getClass</span>(<span class="string">&quot;AppDelegate&quot;</span>), <span class="built_in">sel_registerName</span>(<span class="string">&quot;class&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>__AtAutoreleasePool</code>
结构的定义如下所示，构造函数执行了 <code>objc_autoreleasePoolPush</code>
函数，析构函数执行了 <code>objc_autoreleasePoolPop</code>
函数，两者分别对应 AutoReleasePool 的入栈操作和出栈操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__AtAutoreleasePool</span> &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;</span><br><span class="line">    atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;</span><br><span class="line">    <span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>@autoreleasepool</code>
关键词本质上隐藏了栈操作的管理细节，让代码更加简洁、可靠。<code>@autoreleasepool</code>
构造了一个作用域，在作用域的起始执行构造函数，在作用域的结尾执行析构函数。总体而言，<code>main</code>
函数的实现可以简化成如下所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    NSString * appDelegateClassName;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; </span><br><span class="line">        atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do anything</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, __null, appDelegateClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="autoreleasepool-1">AutoReleasePool</h2>
<p>为了深入分析 AutoReleasePool 的实现，我们需要阅读 objc 的源码，详见
<a href="https://github.com/opensource-apple/objc4">传送门</a>。</p>
<p>在上一节，我们注意到有两个函数：<code>objc_autoreleasePoolPush</code>
和 <code>objc_autoreleasePoolPop</code>。它们在 objc
源码中有对应的实现，如下所示。这里就涉及到了 AutoReleasePool
的底层实现原理，其核心就是 <code>AutoReleasePoolPage</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="autoreleasepoolpage">AutoReleasePoolPage</h2>
<p>这里我们再来看一下 <code>AutoReleasePoolPage</code>
的定义，如下所示。<code>AutoReleasePoolPage</code> 定义了两个指针
<code>parent</code> 和 <code>child</code>，它分别对应上述图中的
<code>prev</code> 和
<code>next</code>，作为实现双向链表的关键指针。此外，其自定义了
<code>new</code> 方法，内部可以分配 4096
字节的内存空间，用于存储固定属性和对象指针。</p>
<p><code>AutoReleasePoolPage</code> 还定义了 <code>next</code>
指针，这个指针很重要，类似于栈顶指针，当添加或删除对象后，<code>next</code>
指针会更新为下一个可存储的内存地址。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage &#123;</span><br><span class="line">    PAGE_MAX_SIZE；                     <span class="comment">// 最大 size 4096 字节</span></span><br><span class="line">    magic_t <span class="keyword">const</span> magic;                <span class="comment">// 用来校验 AutoreleasePoolPage 的结构是否完整</span></span><br><span class="line">    <span class="type">id</span> *next;                           <span class="comment">// 指向下一个即将产生的 autoreleased 对象的存放位置，类似于栈顶指针</span></span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;             <span class="comment">// 指向当前线程，一个 AutoreleasePoolPage 只会对应一个线程，但一个线程可以对应多个 AutoreleasePoolPage；</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">// 指向父节点，第一个节点的 parent 值为 nil；</span></span><br><span class="line">    AutoreleasePoolPage *child;         <span class="comment">// 指向子节点，最后一个节点的 child 值为 nil；</span></span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;               <span class="comment">// 表示深度，第一个 page 的 depth 为 0，往后每递增一个 page，depth 会加 1；</span></span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SIZE-sizeof(*this) bytes of contents follow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> * operator new(size_t size) &#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-06.png?x-oss-process=image/resize,w_800" /></p>
<h2 id="objc_autoreleasepoolpush">objc_autoreleasePoolPush</h2>
<p><code>objc_autoreleasePoolPush</code> 内部调用了
<code>AutoReleasePoolPage</code> 的 <code>push</code>
方法，其实现如下所示。可以看出，<code>push</code> 方法的本质就是想
AutoReleasePage 中存入一个哨兵对象 <code>POOL_SENTINEL</code>，用于标识
AutoReleasePool 的边界。这个过程中会遇到一些主要的分支情况，比如：</p>
<ul>
<li>当前没有任何页面时，需要初始化一个页面</li>
<li>当前页面已满时，需要添加一个新页面</li>
<li>当前页面未满时，则直接存入对象指针</li>
</ul>
<p>这些分支情况，在 <code>push</code>
方法中均有体现，相关逻辑详见代码具体实现。<code>push</code> 方法中通过
<code>autoreleaseFast</code> 方法存储哨兵对象。事实上，我们使用 ARC
管理对象时，所有的对象都是通过 <code>autoreleaseFast</code> 方法存入
<code>AutoReleasePoolPage</code> 中的。</p>
<blockquote>
<p>hotPage 表示末尾最后一个非空页面。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    id *dest = <span class="built_in">autoreleaseFast</span>(POOL_SENTINEL);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">        <span class="comment">// 当前页面存在，且未满时，直接存入对象</span></span><br><span class="line">        <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="comment">// 当前页面存在，但已满时，添加一个页面，再存入对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前页面不存在时，初始化一个页面，再存入对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前页面存在的逻辑</span></span><br><span class="line"><span class="comment">// 当前页面已满时，则沿着链表 child 指针，正向遍历，即栈顶方向，查找未满的页面。如果没找到，则初始化一个页面加入链表尾部，即栈顶。</span></span><br><span class="line"><span class="comment">// 最后将对象指针加入该未满的页面中。</span></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(page == <span class="built_in">hotPage</span>());</span><br><span class="line">    <span class="built_in">assert</span>(page-&gt;<span class="built_in">full</span>()  ||  DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;<span class="built_in">full</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前页面不存在的逻辑</span></span><br><span class="line"><span class="comment">// 当链表中没有任何页面时，初始化一个页面，其 parent 设置为 nil，即链表头。</span></span><br><span class="line"><span class="comment">// 此时，如果要加入的对象不是哨兵对象，则加入一个哨兵对象，作为 AutoReleasePool 的边界。然后再加入对象地址。</span></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// No pool in place.</span></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">hotPage</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        <span class="comment">// We are pushing an object with no pool in place, </span></span><br><span class="line">        <span class="comment">// and no-pool debugging was requested by environment.</span></span><br><span class="line">        _objc_inform(<span class="string">&quot;MISSING POOLS: Object %p of class %s &quot;</span></span><br><span class="line">                     <span class="string">&quot;autoreleased with no pool in place - &quot;</span></span><br><span class="line">                     <span class="string">&quot;just leaking - break on &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, </span><br><span class="line">                     (<span class="type">void</span>*)obj, <span class="built_in">object_getClassName</span>(obj));</span><br><span class="line">        <span class="built_in">objc_autoreleaseNoPool</span>(obj);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(nil);</span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push an autorelease pool boundary if it wasn&#x27;t already requested.</span></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;<span class="built_in">add</span>(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the requested object.</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="objc_autoreleasepoolpop">objc_autoreleasePoolPop</h2>
<p><code>objc_autoreleasePoolPop</code> 内部调用了
<code>AutoReleasePoolPage</code> 的 <code>pop</code>
方法。<code>pop</code> 方法的参数 <code>token</code> 则是当前
AutoReleasePool 的哨兵对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = <span class="built_in">pageForPointer</span>(token);</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) <span class="built_in">printHiwat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象</span></span><br><span class="line">    page-&gt;<span class="built_in">releaseUntil</span>(stop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;<span class="built_in">empty</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;<span class="built_in">lessThanHalfFull</span>()) &#123;</span><br><span class="line">            page-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        <span class="comment">// 设置 page 为当前非空页面</span></span><br><span class="line">        AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 parent 指针，反向遍历，即栈顶方向</span></span><br><span class="line">        <span class="comment">// 将尾指针指向非空的页面</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            <span class="built_in">setHotPage</span>(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;<span class="built_in">unprotect</span>();</span><br><span class="line">        <span class="comment">// 地址递减，并释放对应位置</span></span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span>*)page-&gt;next, SCRIBBLE, <span class="built_in">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;<span class="built_in">protect</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果对应位置存储了对象，则进行内存释放</span></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">            <span class="built_in">objc_release</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setHotPage</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到对象释放的关键方法
<code>releaseUntil</code>。其通过循环不断寻找非空的页面，同时对于每个页面，使用其
<code>next</code>
指针，逐步释放每一个对象及其内存，直到找到目标对象，即哨兵对象。</p>
<p>需要注意的是，<code>releaseUntil</code>
只是重置了其记录的对象指针，并释放了对象的内存，但是并没有释放
<code>AutoReleasePoolPage</code> 本身。如果 AutoReleasePool
管理的对象非常多，那岂不是有很多未使用的
<code>AutoReleasePoolPage</code> 没有被使用，也没有被释放吗？</p>
<p>对此，<code>pop</code> 方法中的最后部分解决了这个问题，它通过
<code>kill</code> 方法来释放空的页面。这里有两种情况：</p>
<ul>
<li>当 hotPage
存储已过半时，仅保留一个空页面。因为页面快要满了，很快就会分配一个新的页面，为了提高性能，保存一个即将使用的空页面。</li>
<li>当 hotPage 存储未过半时，不包含任何空页面。</li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-07.png?x-oss-process=image/resize,w_800" /></p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/autoreleasepool-08.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="总结">总结</h1>
<p>首先，我们介绍了栈的两种实现方式，分别是数组和双向链表。</p>
<p>其次，我们对比了函数定义和 AutoReleasePool
定义，两者具有相似之处。作为对比，我们介绍了函数调用是如何通过栈帧管理局部变量的。进一步，我们又介绍了
AutoReleasePool 管理对象的思路。</p>
<p>考虑到性能问题，AutoReleasePool
不能像函数调用栈一样，通过类似数组的方式，即连续内存空间来管理对象，而是通过双向链表的方式进行管理。于是，我们进一步设想了链表节点的定义，即
AutoReleasePoolPage 的定义。</p>
<p>于是，我们设计了一种直观的管理方式：一个 AutoReleasePool
独享一个或多个
AutoReleasePoolPage。但是这种方式存在内存碎片问题。对此，我们重新设计了一种管理方式：一个
AutoReleasePool 可以被多个 AutoReleasePool
共享。其本质上通过哨兵对象来进行定义边界，这种设计正是 AutoReleasePool
的设计方案。</p>
<p>通过正向设计，我们可以深刻理解 AutoReleasePool
的设计思想及其设计原因。</p>
<p>最后，我们再来回顾文章开头的两个问题，想必你已经有答案了。</p>
<ul>
<li>问：为什么 AutoReleasePool 底层是双向链表结构？</li>
<li>答：AutoReleasePool
的本质是通过栈来管理对象，而双向链表是应用层实现栈的一种效率最高的数据结构。</li>
<li>问：为什么 AutoReleasePool 采用基于 AutoReleasePoolPage
的分页机制？</li>
<li>答：基于双向链表结构的设计中，必须要设计一个固定结构的链表节点，AutoReleasePoolPage
正是链表节点的设计。</li>
</ul>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://acodercat.github.io/2020/08/19/function-stack-frame/">函数栈帧的创建与销毁</a></li>
<li><a
href="https://www.cnblogs.com/zlcxbb/p/5759776.html">函数调用过程栈帧变化详解</a></li>
<li>《程序员的自我修养——链接、装载与库》</li>
<li><a href="https://github.com/opensource-apple/objc4">objc</a></li>
<li><a href="https://draveness.me/autoreleasepool/">自动释放池的前世今生
---- 深入解析 autoreleasepool</a></li>
</ol>
]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>AutoReleasePool</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 年度总结</title>
    <url>/2025/01/02/2024-summary/</url>
    <content><![CDATA[<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2168.jpg?x-oss-process=image/resize,w_600" /></p>
<span id="more"></span>
<p>按照惯例，每年做一次回顾总结，让未来的自己能够记得来时走过的路。</p>
<h1 id="工作第七年">工作第七年</h1>
<h2 id="项目流水账">项目流水账</h2>
<p>先说说今年经历的几个大项目吧。</p>
<p>上半年的一个大项目是直播自建项目，说是自建，其实底层的基础直播能力用的还是中台的
SDK。我们做的主要是对 SDK
进行封装，包括接口分装、消息的编解码、消息分发、引擎初始化等。当然，最大的工作量仍然是围绕直播搭建上层业务。组内两位同学
<span class="citation" data-cites="月龙">@月龙</span> 和 <span
class="citation" data-cites="马嘉">@马嘉</span> 各自负责搭建 Android/iOS
的学生端，我负责搭建 iPad 老师端。</p>
<p>第二季度同时进行了另一个大项目——播放器重构。Android 端基于 Redux
架构进行重构优化，使用 ViewModel 管理状态，通过 flow 实现状态绑定。iOS
端基于依赖注入的思想进行模块化改造。项目整体持续了三个月，拆分成三个里程碑分阶段完成。最终的播放器支持服务端下发配置，实现业务功能插件化配置。</p>
<p>六七八三个月，整个研发团队主要在做小学语文项目，其核心就是利用 AI
能力实现辅助教学。六月，我开始调研相关的技术，包括：基于大模型的语音对话的流程和优化的分析，全开麦场景下的
VAD 技术等。关于 VAD，我们最终采用了一个开源的预训练的神经网络模型
Silero。对于 Android，已经有了对应的封装库，而 iOS
并没有。所以我这边要做的就是使用 ONNX 来运行模型，并提供接口实现 VAD
检测。年底的时候，我也写了一个 demo，详见 <a
href="https://github.com/baochuquan/ios-vad">ios-vad</a>，后期计划将它封装成
pod 库。</p>
<p>另外，鸿蒙适配也是今年的一个重点非公开项目。为什么是非公开项目呢？因为上层始终保持着不重视、不投入的态度，一切以业务为优先，所以我只能以研发团队的身份低调、非公开推进。我最早在四五月份开始与华为方面进行接触，来来回回沟通了很多次，但是没有公司的支持，很多事情无法顺利开展，比如：驻场协助、适配计划等。以至于后期华为团队多次了解适配进度，我们甚至都不知道该如何答复。</p>
<p>本身我们也就是一个 10 人的客户端团队，而且清明前离职了一位 iOS
同事（后面也没有入职新人），根本没有多余人力完全投入到鸿蒙适配中，所以一直都是一个断断续续的适配状态。早期，只有我能偶尔抽出一点时间来做鸿蒙基建，比如：技术调研、项目配置、工程结构、数据库、网络库、Cookie管理、登录注册等。直到十一之后，客户端团队才迎来了大约两个多月略微空闲的时间，才能够把大部分时间投入到鸿蒙适配之中。整体来说，我们取得的速度还是挺快的，支持了
3 个 Tab
页及相关落地页（包括播放器），未适配的主要就是学习环节的多个详情页。我在前期支持了一些基本功能，团队可以直接上手进行适配，减少了一些阻碍。因为团队同学的快速学习和通力协作，我们才取得如此不错的成就。当然，鸿蒙
App 还未上架，明年仍需努力。</p>
<p>最后一个大项目是圣诞 Demo
课。这个项目十一月初才评审产品稿，当时还没有设计稿，以至于前期还无法投入开发，时间非常紧急。为了能够按时交付，Android/iOS
各自投入了 3 人，并让年轻同学 <span class="citation"
data-cites="静远">@静远</span>、<span class="citation"
data-cites="马嘉">@马嘉</span>
设计架构并主导研发。我这边负责项目整体进度，每周和各个团队追踪进度、评估风险。整体而言，项目在一个可控的程度内有序进行。不过，项目最后因为邀请的用户时间有冲突，所以项目延期至元旦之后交付。</p>
<h2 id="黑客马拉松">黑客马拉松</h2>
<p>今年有幸参加了一次公司举办的黑客马拉松，主题是
AI。我们团队三人，职能分别是服务端 <span class="citation"
data-cites="梦林">@梦林</span>、客户端和产品经理 <span class="citation"
data-cites="王珊">@王珊</span>，分工协作完成了一个项目——AI旅伴。比赛日只有两天，由于工作量比较大，我们不得不提前一周开始做。比赛过程比较煎熬，prompt
调试的进度不是很顺利，直到路演前才调试完。不过好在结果还不错，AI
旅伴项目获得了「最具潜力奖」，没有陪跑。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2182.jpg?x-oss-process=image/resize,w_480" /></p>
<h2 id="人事变动">人事变动</h2>
<p>所谓「铁打的营盘，流水的兵」，公司里的人事变动在所难免。年初是部门负责人有变动，年中是产品团队大变动。九月份我直属领导也发生了变化，七年老同事+领导+球友
<span class="citation" data-cites="碧峰">@碧峰</span> 离职创业，同时
<span class="citation" data-cites="潜哥">@潜哥</span>
也换了业务线。所幸，我的新领导、课程体验负责人 <span class="citation"
data-cites="栋哥">@栋哥</span>
人很不错，经验丰富，技术过硬，合作起来非常愉快。产研负责人 <span
class="citation" data-cites="宝明">@宝明</span>
也很不错，虽然工作上直接接触并不多，但是能感受到为人非常坦诚。</p>
<p>关于裁员，公司各个业务线也是存在的。大环境不好，我们个体能做的也只能是调整好心态，做好自己，以应对一切可能会发生的事情吧。</p>
<h1 id="业余整点乐子">业余整点乐子</h1>
<p>曾经的猿辅导是小而美的典范，双减之后虽然大不如前，但是好歹保留了「不加班」的优良传统。Work
Life Balance
是一种幸福的状态，很可惜，这样的公司在国内互联网圈子中太少见了。因为不加班，每天回家还能有时间干点自己想干的事，发展自己的爱好，比如看看书、写写博客、做做项目之类的。</p>
<h2 id="side-project">Side Project</h2>
<p>今年业余时间，做的项目不多。去年年底做了个 <a
href="https://apps.apple.com/us/app/morph-rest-break-reminder/id6474056217">莫负休息</a>
App，今年上半年更新了几个主题，比如：代码雨、魔方之类的，很可惜下半年闲置了。一年下来收入也就几十美元，没达到
99 美元的目标，不过在应用商店收获了 50 多个好评，也挺满意了。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-12.png?x-oss-process=image/resize,w_800" /></p>
<p>四五月份的时候，我写了一个小工具——<a
href="https://github.com/baochuquan/git-reviewer">git-reviewer</a>。git-reviewer
是一个 git 插件，支持 homebrew 安装，可以用来分析一个 Merge Request
应该让哪些人来做 Code Review。这个工具底层使用了 <a
href="https://chuquan.me/2023/09/13/myers-difference-algorithm/">Myers
差分算法</a>，也算是对我之前学的东西做了一次实践吧。</p>
<p>十一月份的时候，我用 SwiftUI 写了一个小项目——<a
href="https://github.com/baochuquan/ios-vad">ios-vad</a>。一方面是对我之前调研的
VAD 技术做一个总结，另一方面也算是实践一下 SwiftUI
吧。项目还有很多要完善的地方，比如抽取 pod 库，希望明年能把它完成。</p>
<h2 id="写博客">写博客</h2>
<p>2024 年写了 21
篇博客，技术上主要集中在两个领域：图形学、深度学习。</p>
<p>上半年前几个月主要在看闫令琪老师的《Games
101》课程，因为内容非常多，所以我反复看了好多遍。后面，结合自己的理解，针对图形学的相关技术写了一系列博客进行总结。</p>
<ul>
<li><a
href="https://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">计算机图形学基础（1）——线性代数</a></li>
<li><a
href="https://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/">计算机图形学基础（2）——变换</a></li>
<li><a
href="https://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">计算机图形学基础（3）——观测变换</a></li>
<li><a
href="https://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">计算机图形学基础（4）——光栅化</a></li>
<li><a
href="https://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">计算机图形学基础（5）——着色</a></li>
<li><a
href="https://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/">计算机图形学基础（6）——几何</a></li>
<li><a
href="https://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/">计算机图形学基础（7）——辐射度量学</a></li>
<li><a
href="https://chuquan.me/2024/04/27/foundation-of-computer-graphic-08/">计算机图形学基础（8）——光线追踪</a></li>
</ul>
<p>学了图形学之后，尝试用 Threejs 做了个魔方，并把它融合进了莫负休息 App
中。与此同时，整理了一篇博客——<a
href="https://chuquan.me/2024/06/01/rubiks-cube-01/">基于 Threejs 实现
3D 魔方</a>。</p>
<p>七至十月，我主要在学习深度学习的一些基础理论，看了好几本书，其中有几本看了两遍，也写了几篇总结性的文章。</p>
<ul>
<li><a
href="https://chuquan.me/2024/07/21/neural-network-introduce/">初识人工神经网络（1）——基本原理</a></li>
<li><a
href="https://chuquan.me/2024/07/31/neural-network-implement/">初识人工神经网络（2）——代码实现</a></li>
<li><a
href="https://chuquan.me/2024/09/21/deep-learning-layer/">神经网络的分层设计原理</a></li>
<li><a
href="https://chuquan.me/2024/09/28/cnn-introduction/">卷积神经网络</a></li>
<li><a
href="https://chuquan.me/2024/10/15/nlp-word-representation/">自然语言处理中的单词含义表示</a></li>
<li><a
href="https://chuquan.me/2024/10/26/rnn-introduction/">循环神经网络</a></li>
<li><a
href="https://chuquan.me/2024/11/02/attention-introduction/">语言模型中的注意力机制</a></li>
</ul>
<h2 id="黑神话悟空">黑神话·悟空</h2>
<p>今年最火爆的游戏莫过于《黑神话·悟空》了。我从四年前游戏科学发布的第一个
PV 开始，一直在关注这款游戏，我预感游戏要火，所以在 618 赶紧买了
PS5，担心游戏出来再 PS5 买会涨价。虽然我玩的游戏品类不多，而且只玩 FPS
游戏。我的评价是黑神话真的太上头了，游戏的实际体验比预期还要好非常多，难怪火出圈了。游戏发售后的一个月，我基本上就是每天早早下班，洗完澡后玩到睡觉。如果你还没玩过，真的非常建议你玩一下，战斗系统、音乐、动画、剧情、场景、美术、角色设计、动作设计都是顶级的存在。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2173.jpg?x-oss-process=image/resize,w_800" /></p>
<h2 id="运动健身">运动健身</h2>
<p>今年运动状态保持的挺好，希望来年继续保持。</p>
<p>首先是健身。这一年和健身搭子 <span class="citation"
data-cites="昱总">@昱总</span>、<span class="citation"
data-cites="奎佑">@奎佑</span> 相互监督，基本上能够保持每周 3-4
次健身。不过，因为怕受伤，三大项还是只练卧推。卧推现在能够 80KG
做组，动作可以做到比较标准的那种了。今年 8 月 3
日，健身一周年，特地测了一下体脂。一整年下来，体脂从 17.4% 下降到了
15.0%，骨骼肌增长
2.6KG，效果非常明显，打球的队友们也说我明显维度变大了，希望 2025
年继续坚持下来。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2169.jpg?x-oss-process=image/resize,w_480" /></p>
<p>其次是跑步。这一年也是尽可能地每周跑一次十公里，中间因为旅游、游戏、出差等并没有做到每周都跑步。冬季也没有跑，外面的风实在太大。关于跑步，2025
年也要继续保持，争取参加一次半马（北京马拉松中签真的太难了）。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2171.jpg?x-oss-process=image/resize,w_480" /></p>
<p>最后是篮球。今年基本上每周都会打一次球。年中那会儿研究库里的投篮，学到了一段式投篮的精髓，现在投三分球基本上动作不会变形了，出手速度也变快了，命中率也提上来了。这里贴一张老司机
<span class="citation" data-cites="碧峰">@碧峰</span>
离职前的最后一场球局合影照。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2172.jpg?x-oss-process=image/resize,w_800" /></p>
<h1 id="户外走一走">户外走一走</h1>
<h2 id="春节">春节</h2>
<p>今年春节，和媳妇一起回长兴过节，因为疫情缘故，也是结婚后第一次回家过年。同时也是自老弟军校毕业回军队后，第一次过年相聚，不知下次相聚春节又是何时。</p>
<p>我们那儿的习俗，正月初一不会走亲戚。于是当天就在村子附近走走逛逛，一路发现周围的变化还是挺大的，记忆中很多村庄都消失了，取而代之的是非常大的综合物流园区、物流港口，也算给周边创造了不少就业岗位。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2174.jpg?x-oss-process=image/resize,w_800" /></p>
<p>初二初三两天走亲戚，过年热闹的感觉真的挺好。对比前几年因为疫情，在北京过年，真的太凄凉了。紧凑的两天，饭也吃了，照也拍了，下一个目的地就是合肥。回合肥后，因为我听岳父岳母的合肥普通话很费劲，所以除了和媳妇聊天外，我大部分其他时间就是陪小侄女玩，万幸她还记得我这个姑父。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2175.jpg?x-oss-process=image/resize,w_480" /></p>
<h2 id="外婆北京行">外婆北京行</h2>
<p>去年，外婆在体检时发现了肺癌，还好是早期肺癌，及时做了手术。今年四月天气合适，外加外婆身体状态有所恢复，所以我妈准备带她来北京玩玩。老人家没来过北京，也算是了却一桩心愿吧。不到一周的时间，带外婆去了北京几大景点，颐和园、天坛、天安门、故宫、北大、长城、圆明园等等。另外，还带外婆尝试了各种菜系，毕竟北京的餐厅种类还是非常多的，有条件可以让老人家也尝尝鲜。唯一的遗憾是，没有带她参观到毛主席纪念堂。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2176.jpg?x-oss-process=image/resize,w_480" /></p>
<h2 id="成渝九日游">成渝九日游</h2>
<p>六月初，我请了 5 天年假，凑了一次 9
天长假，和媳妇来了一次成渝九日游。</p>
<p>重庆两天，在魁星楼体验了 8D
城市的奇妙感觉，在嘉陵江边看到了千厮门和洪崖洞的巧妙组合，在朝天门见到了双江交汇的独特景观。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2177.jpg?x-oss-process=image/resize,w_480" /></p>
<p>九寨沟景区，景区公交车在查洼沟、日则沟、树正沟各个景点之间不断载运游客，使得我们一天游玩下来也不会感到那么累。在九寨沟，每个季节都有不同的时令景观，真的如同人间仙境一般，非常值得去游玩。这里有个小插曲，因为浙江有几个城市对阿坝州有援建，所以我也有幸作为湖州群众体验了九寨沟的感恩赠票，免费参观了景区，这里小小地自豪一下。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2178.jpg?x-oss-process=image/resize,w_480" /></p>
<p>九寨沟待了两天后，我们去了乐山。很可惜乐山大佛在维修栈道，所以我们没有去景区，而是在城市内逛吃。总体来讲，乐山的美食很不错，感觉比成都的要好吃，是一个生活节奏比较慢的城市，来度假的话很舒服。</p>
<p>最后，就是在成都待了两天，参观了大熊猫繁育基地和三星堆博物馆。大熊猫很傲娇，温度超过
26
度就不会在室外了，所以以后去还得挑个合适的时间。三星堆博物馆真的很不错，无论是博物馆建筑本身，还是展厅布置、光影效果，亦或馆藏文物，都是非常精妙震撼的，绝对值得参观一次。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2179.jpg?x-oss-process=image/resize,w_480" /></p>
<h2 id="世界人工智能大会">世界人工智能大会</h2>
<p>六月休假回来没多久，又跟随公司出差上海，参加了世界人工智能大会。公司以猿力科技作为主体，作为展商参加了这次大会。我们海豚业务线也有展区，我和
<span class="citation" data-cites="静远">@静远</span>
负责海豚展区的设备调试。展会期间，我也参观了一下其他公司的展厅，大大小小近
200
家，挨个参观了一遍，比如：华为、BAT、字节、亚马逊、谷歌、特斯拉、宇树科技...整体来说，也是个不错的体验，实实在在见识到了科技的真实落地，比如：宇树科技的机器狗，现场的展示效果非常惊艳。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2183.jpg?x-oss-process=image/resize,w_800" /></p>
<h2 id="大同周边游">大同周边游</h2>
<p>十二月，我和媳妇利用周末去大同玩了一遭。去大同玩主要有两个原因，一是离北京近，二是黑神话悟空。第一天去了云冈石窟，数十个石窟中，就属昙曜五窟最为突出。雕刻、壁画精美绝伦，非常震撼，我想这应该算得上是中国古代石雕艺术的巅峰了吧。下午我们又去了华严寺，建筑很有特色，类似于游戏中的旧观音禅院，庙内佛祖、菩萨、星宿、天王等雕塑风格独特且极具年代感。在华严寺，我意外见到了游戏里黄眉住的大雄宝殿，牌匾一模一样。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG173.jpg?x-oss-process=image/resize,w_800" /></p>
<p>第二天我们去了悬空寺和应县木塔。悬空寺在恒山景区，十二月的天气特别冷，零下二十度，手基本伸不出来，在悬空寺打卡拍照没多久就离开了。应县木塔景区内没有其他建筑，不过其本身就已足够传奇，中国建筑史上的一个标志性建筑，也是世界三大奇塔之一。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG174.jpg?x-oss-process=image/resize,w_480" /></p>
<h2 id="博物馆">博物馆</h2>
<p>今年在深度参观了四个博物馆，分别是中国共产党历史展览馆、中国工艺美术馆、中国国家博物馆、安徽美术馆。</p>
<p>党史馆基本上就是中国近代史的实物陈列，结合之前看过蒋廷黻写的《中国近代史》，感触很深刻。从
1840
年开始，中国人民尝试了各种运动和制度试图拯救中国，从清朝末年的虎门销烟、太平天国、戊戌变法、义和团、洋务运动，到民国时期的五四运动、国共合作、北伐战争、抗日战争，最终只有架构于人民史观的中国共产党找到了民族复兴的道路。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2181.jpg?x-oss-process=image/resize,w_480" /></p>
<p>工艺美术馆主要是展示了中国历史各个朝代的各种工艺品，包括服饰、玉器、瓷器、绘画、壁画、石雕等等。工艺美术馆中最为震撼的作品应该是象牙雕，极致繁琐的细节，不失精致的工艺，令人叹为观止。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG2180.jpg?x-oss-process=image/resize,w_480" /></p>
<p>国家博物馆中的几个主展厅展示了中国历史各个朝代的文物，从古代中国到现代中国，即使是走马观花，也要一整天的时间。国家博物馆我来过很多次了，每次来必看古代中国，五千年的辉煌历史总是让人感受到无比伦比的史诗感。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG175.jpg?x-oss-process=image/resize,w_480" /></p>
<p>安徽美术馆离我家只有一公里左右，但是因为各种原因没有去过。今年回家的时候顺便去看了下。美术馆的内饰设计很漂亮，主要还以美术作品为主，适合拍照打卡。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/WechatIMG177.jpg?x-oss-process=image/resize,w_480" /></p>
<h1 id="我劝同志们多读书">「我劝同志们多读书」</h1>
<p>毛主席说过：我劝同志们多读书，免得受知识分子的骗。2024 年我完整阅读了
13 本书，这里按照时间顺序罗列一下：</p>
<ul>
<li>《数学之美》
<ul>
<li>吴军著，虽说是「数学」之美，但内容大多与计算机科学有关，与《计算之魂》有内容重叠，整体还是一本不错的书。不过没有初读《计算之魂》时那么惊艳。</li>
</ul></li>
<li>《浪潮之巅》
<ul>
<li>吴军著，科技/互联网从业者必看系列，讲述一系列知名公司的发展史，比如：AT&amp;T、IBM、硅谷、微软、Google、甲骨文、思科、雅虎、惠普、3M、GE...</li>
</ul></li>
<li>《中国近代史》
<ul>
<li>蒋廷黻著，中国近代史必看系列，讲述自 1840
以来至抗日战争前夕近一百年的历史，主要介绍了无数对外战争的起因、发展、结果，各种不平等条约的签订，以及人民为对抗外部侵略者，争取民族独立和复兴而发起的各种救国运动。强烈推荐。</li>
</ul></li>
<li>《赢》
<ul>
<li>杰克韦尔奇著。主要是介绍了杰克韦尔奇对于其在通用电气公司期间在管理方面的理解和感悟。</li>
</ul></li>
<li>《Python 神经网络编程》
<ul>
<li>一本非常推荐的深度学习入门书籍，我阅读了两遍，写了两篇博客。
<ul>
<li><a
href="https://chuquan.me/2024/07/21/neural-network-introduce/">初识人工神经网络（1）——基本原理</a></li>
<li><a
href="https://chuquan.me/2024/07/31/neural-network-implement/">初始人工神经网络（2）——代码实现</a></li>
</ul></li>
<li>可能是入门书籍的缘故，这本书侧重于用最简单的语句让读者理解神经网络。因此在专业术语的表述、介绍、体系方面稍显欠缺。</li>
</ul></li>
<li>《软件设计哲学》
<ul>
<li>一本软件设计经验总结的书，我看的是中文版，翻译不是很好。不过书中介绍的一些思想还是很独特的。比如：将信息论与软件开发相结合，什么时候应该暴露信息，什么时候应该隐藏信息；软件开发的二次设计思想等等，推荐阅读。</li>
</ul></li>
<li>《深度学习入门：基于 Python 的理论与实现》
<ul>
<li>一本非常推荐的深度学习入门书籍，我读了两遍，建议和《Python
神经网络编程》结合一起看，弥补了后者的缺陷，但是内容比较多，理论稍微难一点。</li>
</ul></li>
<li>《深度学习进阶：自然语言处理》
<ul>
<li>如果你想系统性地学习
GPT，这版书是你的入门首选，介绍了自然语言处理发展过程中的一些关键性技术。</li>
<li>这本书我也读了两遍，并且总结性地写了几篇博客。
<ul>
<li><a
href="https://chuquan.me/2024/10/15/nlp-word-representation/">自然语言处理中的单词含义表示</a></li>
<li><a
href="https://chuquan.me/2024/10/26/rnn-introduction/">循环神经网络</a></li>
<li><a
href="https://chuquan.me/2024/11/02/attention-introduction/">语言模型中的注意力机制</a></li>
</ul></li>
</ul></li>
<li>《这就是 ChatGPT》
<ul>
<li>虽然是科普书籍，但是写得不够浅显易懂，写得不明不白。组织结构也不是特别清晰，需要有一定的基础才能够理解，不推荐。</li>
</ul></li>
<li>《GPT 图解》
<ul>
<li>类似于 Head First
类型的书，与经典的《HTTP图解》等书有差距，不过代码示例写得不错。</li>
</ul></li>
<li>《FFmpeg 入门详解——音视频原理及应用》
<ul>
<li>废话多，重复内容多，让人抓不住重点。干活不够突出，技术推导不清晰。不过好歹介绍了一些基本概念。</li>
</ul></li>
<li>《红星照耀中国》
<ul>
<li>一本非常推荐的红色经典。1937 年出版，埃德加·斯诺著，介绍了在 1936 年
6 月至 10
月，西安事变之前几个月，作者在延安的所见所闻。包含了几位重要领导人的采访记录，关于他们自述的人生经历。另外还包含了大量的农民、士兵的采访记录，以及作者自己对于时局的看法。</li>
<li>书的结尾，斯诺悲伤地写道：也许我是看到他们活着的最后一个外国人了。在他看来，这群理想主义者想要改变中国，真的太难了。没想到最后他们真的做到了。</li>
</ul></li>
<li>《Scrum 要素》
<ul>
<li>主要介绍 scrum
的几个重要的概念和要素，以及各个要素的作用是什么，值得阅读。</li>
</ul></li>
</ul>
<h1 id="一些感悟">一些感悟</h1>
<p>2024 年，我感觉自己最大的变化就是认知水平有了明显地提升。</p>
<p>在技术方面，能够结合知识储备和第一性原理，发现很多技术设计的基本出发点和共通点。在其他方面，对社会科学产生了比较大的兴趣，也开始思考不同规模的团队是如何管理，小到团队管理，企业管理，大到国家层面的内政管理、外交关系。主要也是意识到团队管理的重要性，虽然很多伟大的发现和发明确实是个别天才的成果，但是将这些成果转换成产品或服务时则更需要发挥团队的力量。</p>
<h1 id="写在最后">写在最后</h1>
<p>总体来说，2024
年，我个人的收获和成长还是挺多的，希望来年继续保持！最后，祝大家 2025
年元旦快乐！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>看待问题的几种思考方式</title>
    <url>/2025/02/09/several-ways-of-thinking/</url>
    <content><![CDATA[<p>随着年龄和阅历的增长，自己看待问题的思考方式也逐步变得理性、全面，这里总结几种自己看待问题的思考方式。</p>
<span id="more"></span>
<h1 id="换位思考">换位思考</h1>
<p>换位思考，就是当面对一个情景或局面时，交换立场，重新思考。</p>
<p>换位思考特别适用于人际交往，举个例子，在处理上下级关系时，当自己想和领导抬杠时，换位思考一下，如果你是领导，遇到下属经常在公开场合和自己抬杠，你会怎么看？他在你的人才梯队中如何排序？晋升机会是否会优先考虑？</p>
<h1 id="递进思考">递进思考</h1>
<p>递进思考，就是当面对一个问题或现象时，层层递进，深入思考。</p>
<p>递进思考特别适用于追根溯源，《架构师应该知道的 37
件事》中提到的「五问法」，本质上就是递进思考，多问几个为什么，五只不过是个泛数而已。</p>
<p>举个例子，如果汽车启动不了，你应该追问为什么找出根本原因：启动器无法点火，是因为电池没电；电池没电，是因为车灯一直亮着；车灯一直亮着，是因为警告车灯一直亮着的蜂鸣器没有发声；蜂鸣器没有发声，是因为一个电子设备出了问题。所以你应该修复电子设备而不是尝试接入引线来启动汽车。</p>
<h1 id="底线思维">底线思维</h1>
<p>底线思维，就是当面对一个事情时，设想其最差（或最好）的情况会是什么。</p>
<p>底线思维特别适用于决策、安抚。举个例子，很多人会焦虑，无外乎焦虑自己未来的职业发展、财务状况、身体健康。对于职业发展，最差会怎么样？最差几年内失业？失业时最差有多少积蓄可供生活开销？最差支持你多久另谋出路？通过底线思维思考，很多时候你会发现最差的情况也不过如此，焦虑的根本原因是虚荣心、攀比和贪婪。</p>
<h1 id="终局思维">终局思维</h1>
<p>终局思维，就是当面对一个事情时，设想其最终的情况会是什么。本质上就是用更大的视野去看待事情。</p>
<p>终局思维同样适用于决策。举个例子，新中国成立时，除了教员外，所有人都认为应该先发展轻工业，后发展重工业。教员则认为新中国的崛起必将引来帝国主义的嫉恨和封锁，甚至战争，彼时如果再发展重工业则为时已晚。</p>
]]></content>
      <categories>
        <category>沉思录</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>读《技术为径》——技术导师</title>
    <url>/2025/06/07/the-managers-path-mentor/</url>
    <content><![CDATA[<p>前段时间阅读了一本叫《技术为径》的书，作者是卡米尔·福涅尔，一位女性技术管理者。此书主要介绍了如何从工程师逐步进阶成为技术管理者，这里的技术管理者分为很多种层次，包括：技术导师、技术小组长、中层经理、职业经理人等。考虑到书的内容比较多，这里我分开记录一些读书笔记。本文先从技术导师开始。</p>
<h2 id="技术导师">技术导师</h2>
<p>技术导师，即 Tech
Mentor，其通常负责辅导校招生、实习生，在极少数情况下也负责指导社招新成员，比如：阿里巴巴的「师兄」角色。</p>
<h1 id="如何指导实习生">如何指导实习生</h1>
<p>对于实习生而言，一段很棒的实习经历不仅可以促使他未来加入公司，也能够在提升公司作为雇主在其同学圈中的印象分。</p>
<p>在实习生入职之前，技术导师要准备迎接入职。对此，要着手的事情很多，比如：了解入职时间，安排入职工位、工作环境、工作设备甚至内部账号等。很多工程师其实都不太有「眼力见」，很容易忽视这些细节。事实上，对于一个新员工而言，入职第一天完全被忽视是一种非常糟糕的体验。</p>
<p>入职之后，指导实习生的工作应该围绕着具体的项目来进行。因此，技术导师要先确定一个难度适中的项目，如果没有合适的独立项目，也可以考虑从自己当前的工作中分离出一部分交给实习生完成。当确定了实习生的第一个项目后，技术导师应该和实习生一起对项目进行任务拆分，这样可以快速获得反馈信息，并随时回答实习生的问题。</p>
<p>伴随着项目的进行，技术导师应该始终注意以下三项重点：</p>
<ul>
<li>认真倾听</li>
<li>清晰沟通</li>
<li>因材施教</li>
</ul>
<p>倾听是最基础、最重要的人事管理技能，也是同理心的一种体现。无论未来身处什么职位，懂得如何倾听都极为有用。大多数人都是不善于精准表达自己的想法的，因此认真倾听意味着要透过对方的表面语言，体会其真正的意图。当面对技术导师时，实习生在心理上会处于弱势，在表达或者提问时，可能会因为胆怯或紧张，而无法准确地描述。对此，技术导师的心理应该有所准备，对于实习生提出的问题或表述，可以以自己的理解进行，述，必要时可以通过白板画图，避免沿着错误的方向前进。</p>
<p>沟通的重要性不言而喻。在指导实习生时，技术导师应该清晰地传达自己的期望。比如导师希望实习生在提问之前自己先进行一定的研究，那么就应该明确地跟他讲清楚。导师应该告诉实习生项目各个阶段的目标是什么？做到什么程度？学习什么知识？何时汇报进度？如果在这样清晰的指引下他还做不好，那么你也就明白了他的潜力了。</p>
<p>导师的第三项重点是因材施教。导师应该了解实习生各个方面的能力，从而规划对他的后续指导，加强哪方面的能力。这就需要进一步深入沟通，作者建议至少每周沟通一次；如果有额外时间，也可以聊点工作以外的内容，增进彼此之间的了解。</p>
<h1 id="如何指导正式员工">如何指导正式员工</h1>
<p>指导正式员工是一项非常重要的工作，主要有以下这些目标：</p>
<ul>
<li>帮助新人尽快上手工作内容</li>
<li>帮助新人尽快适应工作氛围</li>
<li>帮助新人尽快构建人际圈子</li>
</ul>
<p>对于帮助新人上手工作内容，首先是新人文档。新人文档包含了各种工具的使用，环境的配置等。随着项目的迭代，文档内容可能与项目实际产生偏差，此时技术导师应该要求新人去更新文档。另外，也可以考虑
<strong>结对编程</strong>，一个人作为驾驶员（编写代码），一个人作为导航员，两人每隔一段时间（比如
40
分钟）互换角色。在结对编程的配合中，新人可以更加深入地理解工作的整体和细节。不过，结对编程在国内公司极其少见，但是我还是觉得可以尝试尝试。</p>
<p>对于帮助新人适应工作氛围，这主要涉及公司的规章制度、审批流程、工作流程、公司文化、常用术语、称呼方式等，当然还有很多小细节或者不成文的规定，这些都需要技术导师去以一个新人的视角去重新观察和理解。</p>
<p>对于帮助新人构建人际圈子，应该带着新人认识团队成员，可以组合各种方式和手段，比如：到各个团队成员的工位介绍两人相互认识、将新人拉进各种成员群。带新人加入自己的人际关系圈，有助于他更快地上手工作，也有助于你进入他未来的人际圈子。毕竟今天你辅导的新人，未来可能是你的引荐人。</p>
<p>指导过程也是一个以全新视角审视公司和团队的机会，导师应该重新思考此前习以为然的一切事务。</p>
<h1 id="总结">总结</h1>
<p>总而言之，导师应该保持关注一下几个要点：</p>
<p>保持好奇心，保持思想开放。辅导工作是一个以全新视角观察自己工作，以及培育自己好奇心的机会。</p>
<p>倾听并以顾及对方背景和立场的方式进行沟通。软件开发是一项团队活动，内部顺畅的沟通是一切成功的前提。</p>
<p>构建人际关系网。任何人任何行业的职业发展归根到底取决于人际关系网络。职场圈子很小，善待对方，保持良好的关系。</p>
]]></content>
      <categories>
        <category>《技术为径》</category>
      </categories>
      <tags>
        <tag>Tech Mentor</tag>
      </tags>
  </entry>
</search>
