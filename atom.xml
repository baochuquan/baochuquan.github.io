<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2018-11-23T11:44:54.863Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objective-C 关联对象与 Method Swizzling</title>
    <link href="http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/"/>
    <id>http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/</id>
    <published>2018-11-23T11:39:37.000Z</published>
    <updated>2018-11-23T11:44:54.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h1><p>关联对象，顾名思义，即通过唯一键（<code>key</code>）连接（关联）至某个类的实例上的对象。</p><p>那么什么时候会用到关联对象呢？</p><p>比如，我们需要对内置类 <code>NSArray</code> 添加一个属性（不使用继承）。如何解决？分类似乎只能添加方法。当我们了解关联对象后，就可以轻松实现。</p><h2 id="关联对象基础"><a href="#关联对象基础" class="headerlink" title="关联对象基础"></a>关联对象基础</h2><h3 id="设置关联对象"><a href="#设置关联对象" class="headerlink" title="设置关联对象"></a>设置关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是 <code>self</code></li><li><code>key</code>: 唯一键，在获取值时通过该键获取，通常是使用 <code>static const void *</code> 来声明</li><li><code>value</code>: 关联所设置的值</li><li><code>policy</code>: 内存管理策略</li></ul><h4 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,             // 表示弱引用关联，通常是基本数据类型</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,   // 表示强引用关联对象，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,     // 表示关联对象copy，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,         // 表示强引用关联对象，不是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403            // 表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象释放时，会根据设置关联对象时采用的策略来决定是否释放关联对象。当策略为 <code>RETAIN/COPY</code> 时，释放关联对象。当策略为 <code>ASSIGN</code> 时，不释放关联对象。</p><h3 id="获取关联对象"><a href="#获取关联对象" class="headerlink" title="获取关联对象"></a>获取关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是传 <code>self</code>，在设置关联时所指定的与哪个对象关联的那个对象</li><li><code>key</code>: 唯一键，在设置关联值所指定的键</li></ul><h3 id="取消关联对象"><a href="#取消关联对象" class="headerlink" title="取消关联对象"></a>取消关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure><p>取消对象的所有关联对象。如果要取消指定的关联对象，可使用 <code>setAssociatedObject</code> 设置为 <code>nil</code> 来实现。</p><h2 id="关联对象应用"><a href="#关联对象应用" class="headerlink" title="关联对象应用"></a>关联对象应用</h2><p>给 <code>UIViewController</code> 添加一个是否需要登录的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL needToLogin;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const char *ViewControllerNeedToLoginKey = &quot;ViewControllerNeedToLoginKey&quot;;</span><br><span class="line"></span><br><span class="line">- (void)setNeedToLogin:(BOOL)needToLogin &#123;</span><br><span class="line">    objc_setAssociatedObject(self, ViewControllerNeedToLoginKey, @(needToLogin), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)needToLogin &#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, ViewControllerNeedToLoginKey) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><p>Method Swizzling，顾名思义，就是将两个方法的实现交换。</p><p>那么什么时候会用到 Method Swizzling 呢？</p><p>比如，在开发中，我们可能会遇到系统提供的 API 不能满足实际需求。我们希望能够修改它以达到期望的效果。</p><h2 id="Method-Swizzling-原理"><a href="#Method-Swizzling-原理" class="headerlink" title="Method Swizzling 原理"></a>Method Swizzling 原理</h2><p>Method Swizzling 的实现充分利用了 <a href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C runtime 动态绑定机制</a>。</p><p>在 Objective-C 中调用方法，其实是向一个对象发送消息，而查找消息的唯一依据是方法名 <code>selector</code>。每个类都有一个方法列表 <code>objc_method_list</code>，存放着其所有的方法 <code>objc_method</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法 <code>objc_method</code> 保存了方法名（<code>SEL</code>）和方法实现（<code>IMP</code>）的映射关系。Method Swizzling 其实就是重置了 <code>SEL</code> 和 <code>IMP</code> 的映射关系。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-method-swizzling.png" alt=""></p><h2 id="Method-Swizzling-基础"><a href="#Method-Swizzling-基础" class="headerlink" title="Method Swizzling 基础"></a>Method Swizzling 基础</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 方法名</li></ul><h3 id="获取方法实现"><a href="#获取方法实现" class="headerlink" title="获取方法实现"></a>获取方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nonnull class_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 要添加方法的方法名</li><li><code>imp</code>: 要添加方法的方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nullable class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 目标方法的方法名</li><li><code>imp</code>: 方法的新方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="交换方法实现"><a href="#交换方法实现" class="headerlink" title="交换方法实现"></a>交换方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h3 id="获取方法的编码类型"><a href="#获取方法的编码类型" class="headerlink" title="获取方法的编码类型"></a>获取方法的编码类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * _Nullable method_getTypeEncoding(Method _Nonnull m)</span><br></pre></td></tr></table></figure><h2 id="Method-Swizzling-应用"><a href="#Method-Swizzling-应用" class="headerlink" title="Method Swizzling 应用"></a>Method Swizzling 应用</h2><p>通过分类允许 <code>NSObject</code> 对任意两个方法进行 Method Swizzling。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSEL);</span><br><span class="line">    if (originalMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(self, targetSEL);</span><br><span class="line">    if (targetMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_addMethod(self, originalSEL, class_getMethodImplementation(self, originalSEL), method_getTypeEncoding(originalMethod));</span><br><span class="line">    class_addMethod(self, targetSEL, class_getMethodImplementation(self, targetSEL), method_getTypeEncoding(targetMethod));</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod(self, originalSEL), class_getInstanceMethod(self, targetSEL));</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Class metaClass = object_getClass((id)self);</span><br><span class="line">    return [metaClass swizzleMethod:originalSEL withMethod:targetSEL error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/c68cc81ef763" target="_blank" rel="noopener">iOS runtime实战应用：关联对象</a></li><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h1&gt;&lt;p&gt;关联对象，顾名思义，即通过唯一键（&lt;code&gt;key&lt;/code&gt;）连接（关联）至某个类的实例上的对象。&lt;/p&gt;
&lt;p&gt;那么
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="关联对象" scheme="http://chuquan.me/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Method Swizzling" scheme="http://chuquan.me/tags/Method-Swizzling/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯·圣彼得堡之旅</title>
    <link href="http://chuquan.me/2018/11/03/st-petersburg/"/>
    <id>http://chuquan.me/2018/11/03/st-petersburg/</id>
    <published>2018-11-03T13:00:47.000Z</published>
    <updated>2018-11-20T14:18:45.563Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400" alt=""></div><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5261430&auto=1&height=66"></iframe><p>盼了一年，终于盼来了公司的年度旅行。经过两轮的投票角逐，圣彼得堡众望所归！旅行时间计划是 10 月 27 日~ 11 月1 日，总共 6 天。我们此次行程总共 29 人，走团签，使用公司的旅行基金，每个人额外补贴 1020 元。</p><p>出发前两天，我花了两个晚上做了一下圣彼得堡的旅行攻略。首先，定位各个推荐景点和餐厅的位置，做到心里有点逼数。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg003.png?x-oss-process=image/resize,w_800" alt=""></p><p>然后，综合日期、天气、距离、开/闭馆等情况（圣彼得堡有不少景点会周期性地选择闭馆），做了一个大致的行程计划。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg002.png?x-oss-process=image/resize,w_500" alt=""></p><h1 id="Day-1（周六）"><a href="#Day-1（周六）" class="headerlink" title="Day 1（周六）"></a>Day 1（周六）</h1><p>前一天周五，我们照常上班，部分人（包括我）选择在公司一直待到凌晨，然后一起打车去机场。服务器一帮人去附近的网吧开黑，客户端则在公司打升级，玩任天堂游戏。我在 B 站上看了几个关于圣彼得堡的纪录片。对我来说，旅行中很大一部分乐趣是源自于旅行前的准备工作。</p><p>北京时间凌晨五点，我们从 T3 航站楼启程飞往新西伯利亚。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg004.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg008.png?x-oss-process=image/resize,w_800" alt=""></p><p>经过四个半小时的飞行，飞越了数千公里的冰川，最终抵达新西伯利亚。降落前，从新西伯利亚上空俯瞰整个城市，第一感觉便是衰败。这与我的预期完全不符，心里难免有一些失落。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg005.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg006.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg007.png?x-oss-process=image/resize,w_500" alt=""></p><p>在新西伯利亚机场转机等待了近2个小时，我们踏上了飞往圣彼得堡的行程。经历四个半小时，飞机成功降落于圣彼得堡普尔科沃机场，机舱里响起来热烈的掌声。</p><p>导游和大巴早已在机场等候多时，安置好行李后，我们从机场出发。沿着机场高速，经过跨海大桥，最终抵达我们位于瓦西里岛上的 Park inn 酒店。安排完入住后已经差不多下午2点多了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg009.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg010.png" alt=""></p><p>在客房稍事休息，洗漱一下，我们（@大龙哥，@邱老师，@张成）便出门去逛附近的超市。买了烤鸡、黄瓜、香蕉、面包、啤酒、果汁，然后便是回酒店嗨。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg011.png" alt=""></p><p>来圣彼得堡之前，我听说酒店有游泳池。于是晚上一闲下来，便在酒店一楼大厅瞎转，找游泳池。大厅绕了一圈，一对青年毛子情侣看到了我，小哥立马过来跟我尬聊了起来。小哥用带卷舌的英语，我用蹩脚的 Chinglish。聊了二十分钟，我还是没明白他到底想表达什么。。。</p><h1 id="Day-2（周日）"><a href="#Day-2（周日）" class="headerlink" title="Day 2（周日）"></a>Day 2（周日）</h1><p>一大早起来，打开窗帘，外面已然是白茫茫一片。天气与预期一样，那么计划也是一样。今天行程是冬宫。</p><p>来圣彼得堡之前，我们便以在飞猪上购买了电子票。冬宫早上10点半开放，我们分了好几拨，早早便抵达了冬宫快速通道门口。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg012.png" alt=""></p><p>我们差不多画了5个小时的时间走马观花地逛了一遍冬宫。一楼是古埃及相关的展厅，我没怎么逛。二楼是沙俄以及西方中世纪的一些展品。三楼主要东方的一些展品。二楼的展品尤为绚烂，其中包括两幅达芬奇的真迹（世界仅存14副真迹）。果然不愧为世界四大博物馆，不禁感慨如果圆明园未毁，也许可以与其相媲美。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg013.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg016.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg017.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg015.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg014.png" alt=""></p><p>逛完冬宫差不多已经下午三点半了，早已饥渴难耐，我们打车去附近一家小餐厅Varvara。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg018.png" alt=""></p><p>简餐过后，我们沿着涅瓦大街闲逛，欣赏一下沿途的风景。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg019.png" alt=""></p><h1 id="Day3（周一）"><a href="#Day3（周一）" class="headerlink" title="Day3（周一）"></a>Day3（周一）</h1><p>今天计划的第一站是圣以撒大教堂。刚刚抵达圣以撒大教堂，便遇到一群当地的小孩，冲着我们喊“你好”。尴尬的是我们居然不知道“你好”用俄语怎么说，只能也挥手喊着“你好”予以回应。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg020.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg021.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg022.png" alt=""></p><p>圣以撒大教堂可以允许游客登顶观光，俯瞰整个圣彼得堡。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg023.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg026.png" alt=""></p><p>与圣以撒大教堂合完影之后，我们便步行向北前往十二月党人广场，广场的中央是彼得大帝青铜骑士像。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg024.png" alt=""></p><p>在广场逗留了一会儿，大家分头行动，我们（@邱老师，@大龙哥，@刘杨）决定去救世主滴血大教堂。抵达滴血大教堂，有一些一行，教堂的洋葱头正在维修，据说从去年至今一直在维修。不过教堂的内饰真的是美轮美奂，所有的壁画都是用指甲大小的马赛克拼接而成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg027.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg025.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg028.png?x-oss-process=image/resize,w_500" alt=""></p><p>救世主滴血大教堂参观完毕，我们（@吴迪，@海侠，@大龙哥，@邱老师，@刘杨）来到了涅瓦大街吃午餐。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg030.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg029.png" alt=""></p><p>吃完饭，我们在旁边的纪念品店里逛了一会儿，然后他们准备去商场购物。而我则打算去马路对面的喀山大教堂去拍照。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg032.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg031.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg034.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg033.png?x-oss-process=image/resize,w_500" alt=""></p><p>拍完照，我便独自向我们约定的商场步行而去，与大家汇合。</p><h1 id="Day4（周二）"><a href="#Day4（周二）" class="headerlink" title="Day4（周二）"></a>Day4（周二）</h1><p>雪后第一天尤其寒冷，今天的计划则是去彼得保罗要塞观光。彼得堡罗要塞其实就是一个小岛，岛上有监狱（曾关押过高尔基）、教堂（埋葬了历代沙皇）、博物馆，我们也是挨个儿参观了一遍。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg035.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg037.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg036.png" alt=""></p><p>差不多下午一点参观完各个景点，我们在一个小博物馆里逗留了一会儿，然后决定去岛上的一家推荐餐厅。餐厅位于小岛的西边，迎着涅瓦河。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg039.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg038.png" alt=""></p><p>餐后，大家决定一起去看阿芙乐尔号巡洋舰。在路上顶着寒风大概走了半个小时终于到了阿芙乐尔号巡洋舰的地址。参观的总体感觉是比较坑，门票大约70元人民币，比冬宫还贵。里面只有一个小小的博物馆而已。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg040.png" alt=""></p><h1 id="Day5（周三）"><a href="#Day5（周三）" class="headerlink" title="Day5（周三）"></a>Day5（周三）</h1><p>昨天在去往阿芙乐尔号的路上简直被吹成了傻逼，对于今天去叶卡捷琳娜宫的计划我有些犹豫。“既然都来了，就去看看吧”这样的念头促成我又做了一次傻逼的决定。叶卡捷琳娜宫只在下午一点后对散客开放，并且每15分钟放入20来人。我们上午到叶宫，在前面的花园里逛了一圈。差不多下午一点，到叶宫入口排队。寒风中吹了近两个小时才进入叶宫。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg041.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg042.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg043.png" alt=""></p><p>说实话，叶宫真心无法与冬宫相比，除了琥珀宫，里面基本都是些宴会大厅。另外，加上这几天的行程，基本已经属于审美疲劳状态。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg044.png" alt=""></p><h1 id="Day5（周四）"><a href="#Day5（周四）" class="headerlink" title="Day5（周四）"></a>Day5（周四）</h1><p>早上10:20在酒店大厅集合去机场。第一次来俄罗斯，并且是有如此浓厚艺术气息的圣彼得堡，虽然旅程很短暂，但是内心很满足。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="游记" scheme="http://chuquan.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="自由行" scheme="http://chuquan.me/tags/%E8%87%AA%E7%94%B1%E8%A1%8C/"/>
    
      <category term="俄罗斯" scheme="http://chuquan.me/tags/%E4%BF%84%E7%BD%97%E6%96%AF/"/>
    
      <category term="圣彼得堡" scheme="http://chuquan.me/tags/%E5%9C%A3%E5%BD%BC%E5%BE%97%E5%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C runtime 消息传递与转发</title>
    <link href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/"/>
    <id>http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/</id>
    <published>2018-10-20T09:15:32.000Z</published>
    <updated>2018-11-19T09:56:57.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，在 C 语言的基础上实现了面向对象的功能。在 runtime 中，对象用结构体表示，方法用函数表示。</p><p>C 语言是一门静态语言，其在编译时决定调用哪个函数。而 Objective-C 则是一门动态语言，其在编译时不能决定最终执行时调用哪个函数（Objective-C 中函数调用称为消息传递）。Objective-C 的这种动态绑定机制正是通过 runtime 这样一个中间层实现的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-runtime-hierachry.png?x-oss-process=image/resize,w_300" alt=""></p><p>为了分析 runtime 是如何进行动态绑定，我们首先需要了解一下 Objective-C 中类与对象等基本结构在 C 语言层面是如何实现的。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Objective-C-类"><a href="#Objective-C-类" class="headerlink" title="Objective-C 类"></a>Objective-C 类</h2><p>Objective-C 类是由 <code>Class</code> 类型表示的，它本质上是一个指向 <code>objc_class</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line"></span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure></p><h2 id="Objective-C-对象"><a href="#Objective-C-对象" class="headerlink" title="Objective-C 对象"></a>Objective-C 对象</h2><p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向 <code>objc_object</code> 结构体的指针。如下所示为 <code>objc/objc.h</code> 中关于对象的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>objc_object</code> 结构体中只有一个成员，即指向其类的 <code>isa</code> 指针。<strong>当向一个 Objective-C 对象发送消息时，runtime 会根据实例对象的 <code>isa</code> 指针找到其所属的类。Runtime 会在类的方法列表以及父类的方法列表中去寻找与消息对应的 <code>selector</code> 指向的方法，找到后即运行该方法。</strong></p><h2 id="Objective-C-元类（meta-class）"><a href="#Objective-C-元类（meta-class）" class="headerlink" title="Objective-C 元类（meta class）"></a>Objective-C 元类（meta class）</h2><p><code>meta-class</code> 是一个<strong>类对象的类</strong>。在 Objective-C 中，所有的类本身也是一个对象。事实上，在很多原型编程语言也采用这种“万物皆对象”的设计思想，如：Io。</p><p>通过向该对象发送消息，即可实现对类方法的调用。前提是类的 <code>isa</code> 指针必须指向一个包含这些类方法的 <code>objc_class</code> 结构体。<code>meta-class</code> 中存储着一个类的所有类方法。所以，类对象的 <code>isa</code> 指针指向的就是 <code>meta-class</code>。</p><ul><li><strong>当向一个对象发送消息时，runtime 会在这个对象所属的类的方法列表中查找方法。</strong></li><li><strong>当向一个类发送消息时，runtime 会在这个类的 meta-class 的方法列表中查找。</strong></li></ul><p>思考一下，<code>meta-class</code> 也是一个类，也可以向它发送一个消息，那么它的 <code>isa</code> 又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C 的设计者让所有的 <code>meta-class</code> 的 <code>isa</code> 指向基类的 <code>meta-class</code>，以此作为它们的所属类。</p><p>下图所示，为 Objective-C 对象在内存中的引用关系图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-time-message-send.png" alt=""></p><h2 id="Objective-C-方法"><a href="#Objective-C-方法" class="headerlink" title="Objective-C 方法"></a>Objective-C 方法</h2><p>方法实际上是一个指向 <code>objc_method</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体中包含成员 <code>SEL</code> 和 <code>IMP</code>，两者将方法的名字与实现进行了绑定。通过 <code>SEL</code>，可以找到对应的 <code>IMP</code>，从而调用方法的具体实现。</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>SEL</code> 又称选择器，是一个指向 <code>objc_selector</code> 结构体的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>方法的 <code>selector</code> 用于表示运行时方法的名字。<strong>Objective-C 在编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ <code>Int</code> 类型的地址），即 <code>SEL</code>。</strong></p><p>由于一个类的方法列表中不能存在两个相同的 <code>SEL</code>，所以 Objective-C 不支持重载。但是不同类之间可以存在相同的 <code>SEL</code>，因为不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中去根据 <code>selector</code> 去寻找自己对应的 <code>IMP</code>。</p><p>通过下面三种方法可以获取 <code>SEL</code>：</p><ul><li><code>sel_registerName</code> 函数</li><li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li><li><code>NSSeletorFromString()</code> 方法</li></ul><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code> 本质上就是一个函数指针，指向方法实现的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL,...);</span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><code>id</code>：指向 <code>self</code> 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）</li><li><code>SEL</code>：方法选择器</li><li><code>...</code>：方法的参数列表</li></ul><p><code>SEL</code> 与 <code>IMP</code> 的关系类似于哈希表中 <code>key</code> 与 <code>value</code> 的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p><h1 id="消息传递（方法调用）"><a href="#消息传递（方法调用）" class="headerlink" title="消息传递（方法调用）"></a>消息传递（方法调用）</h1><p>在 Objective-C 中，<strong>消息直到运行时才绑定到方法实现上</strong>。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息函数的调用，即 <code>objc_msgSend</code>。这个函数将消息接收者和方法名作为主要参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)                    // 不带参数</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)    // 带参数</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 通过以下几个步骤实现了动态绑定机制。</p><ul><li>首先，获取 <code>selector</code> 指向的方法实现。由于相同的方法可能在不同的类中有着不同的实现，因此根据 <code>receiver</code> 所属的类进行判断。</li><li>其次，传递 <code>receiver</code> 对象、方法指定的参数来调用方法实现。</li><li>最后，返回方法实现的返回值。</li></ul><p>消息传递的关键在于前文讨论过的 <code>objc_class</code> 结构体，其有两个关键的字段：</p><ul><li><code>isa</code>：指向父类的指针</li><li><code>methodLists</code>: 类的方法分发表（<code>dispatch table</code>）</li></ul><p>当创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 <code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承链。</p><p>下图所示为消息传递过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-messaging-framework.png" alt=""></p><ul><li>当消息传递给一个对象时，首先从运行时系统缓存 <code>objc_cache</code> 中进行查找。如果找到，则执行。否则，继续执行下面步骤。</li><li><code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法分发表 <code>methodLists</code> 中查找方法的 <code>selector</code>。如果未找到，将沿着类的 <code>isa</code> 找到其父类，并在父类的分发表 <code>methodLists</code> 中继续查找。</li><li>以此类推，一直沿着类的继承链追溯至 <code>NSObject</code> 类。一旦找到 <code>selector</code>，传入相应的参数来执行方法的具体实现，并将该方法加入缓存 <code>objc_cache</code> 。如果最后仍然没有找到 <code>selector</code>，则会进入<strong>消息转发</strong>流程（下文将进行介绍）。</li></ul><h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>当一个对象能接收一个消息时，会走正常的消息传递流程。当一个对象无法接收某一消息时，会发生什么呢？默认情况下，如果以 <code>[object message]</code> 的形式调用方法，如果 <code>object</code> 无法响应 <code>message</code> 消息时，编译器会报错。如果是以 <code>performSeletor:</code> 的形式调用方法，则需要等到运行时才能确定 <code>object</code> 是否能接收 <code>message</code> 消息。如果不能，则程序崩溃。</p><p>对于后者，当不确定一个对象是否能接收某个消息时，可以调用 <code>respondsToSelector:</code> 来进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，当一个对象无法接收某一消息时，就会启动所谓“消息转发（message forwarding）”机制。通过消息转发机制，我们可以告诉对象如何处理未知的消息。</p><p>消息转发机制大致可分为三个步骤：</p><ul><li>动态方法解析（Dynamic Method Resolution）</li><li>备用接收者</li><li>完整消息转发</li></ul><p>下图所示为消息转发过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/ios-message-forwarding.png" alt=""></p><h2 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h2><p>对象在接收到未知的消息时，首先会调用所属类的类方法 <code>+resolveClassMethod:</code> 或实例方法 <code>+resolveInstanceMethod:</code>。</p><p>在这两个方法中，我们可以为未知消息新增一个“处理方法”，通过运行时 <code>class_addMethod</code> 函数动态添加到类中。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // 方法实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方案更多的是为了实现@dynamic属性。</p><h2 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h2><p>如果在上一步无法处理消息，则 runtime 会继续调用 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p><p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是 <code>self</code>） 的对象，则这个对象会称为消息的新接收者，消息会被分发到这个对象。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([selString isEqualToString:@&quot;walk&quot;]) &#123;</span><br><span class="line">        return self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><h2 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h2><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>这步调用 <code>methodSignatureForSelector</code> 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 <code>nil</code>，则说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;  </span><br><span class="line">    return [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回 <code>methodSignature</code>，则进入 <code>forwardInvocation</code>。对象会创建一个表示消息的 <code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在 <code>anInvocation</code> 中，包括 <code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以利用备用接受者和完整消息转发实现对接受消息对象的转移，可以实现“多重继承”的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">Objective-C Runtime · 笔试面试知识整理</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li><li><a href="https://www.jianshu.com/p/f493bc6a949e" target="_blank" rel="noopener">iOS内功篇：runtime</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://chuquan.me/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS 图像渲染原理</title>
    <link href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/"/>
    <id>http://chuquan.me/2018/09/25/ios-graphics-render-principle/</id>
    <published>2018-09-24T16:24:50.000Z</published>
    <updated>2018-09-24T16:27:15.787Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a> 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。</p><h1 id="图形渲染技术栈"><a href="#图形渲染技术栈" class="headerlink" title="图形渲染技术栈"></a>图形渲染技术栈</h1><p>下图所示为 iOS App 的图形渲染技术栈，App 使用 <code>Core Graphics</code>、<code>Core Animation</code>、<code>Core Image</code> 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系。这些框架都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-rendering-framework-relationship.png" alt=""></p><h2 id="iOS-渲染框架"><a href="#iOS-渲染框架" class="headerlink" title="iOS 渲染框架"></a>iOS 渲染框架</h2><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a><code>UIKit</code></h3><p><code>UIKit</code> 是 iOS 开发者最常用的框架，可以通过设置 <code>UIKit</code> 组件的布局以及相关属性来绘制界面。</p><p>事实上， <code>UIKit</code> 自身并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（<code>UIView</code> 继承自 <code>UIResponder</code>），事件响应的传递大体是经过逐层的 <strong>视图树</strong> 遍历实现的。</p><h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a><code>Core Animation</code></h3><p><code>Core Animation</code> 源自于 <code>Layer Kit</code>，动画只是 <code>Core Animation</code> 特性的冰山一角。</p><p><code>Core Animation</code> 是一个复合引擎，其职责是 <strong>尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即 CALayer），这些图层会被存储在一个叫做图层树的体系之中</strong>。从本质上而言，<code>CALayer</code> 是用户所能在屏幕上看见的一切的基础。</p><h3 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a><code>Core Graphics</code></h3><p><code>Core Graphics</code> 基于 Quartz 高级绘图引擎，主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。</p><p>当开发者需要在 <strong>运行时创建图像</strong> 时，可以使用 <code>Core Graphics</code> 去绘制。与之相对的是 <strong>运行前创建图像</strong>，例如用 Photoshop 提前做好图片素材直接导入应用。相比之下，我们更需要 <code>Core Graphics</code> 去在运行时实时计算、绘制一系列图像帧来实现动画。</p><h3 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a><code>Core Image</code></h3><p><code>Core Image</code> 与 <code>Core Graphics</code> 恰恰相反，<code>Core Graphics</code> 用于在 <strong>运行时创建图像</strong>，而 <code>Core Image</code> 是用来处理 <strong>运行前创建的图像</strong> 的。<code>Core Image</code> 框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。</p><p>大部分情况下，<code>Core Image</code> 会在 GPU 中完成工作，但如果 GPU 忙，会使用 CPU 进行处理。</p><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a><code>OpenGL ES</code></h3><p><code>OpenGL ES</code>（OpenGL for Embedded Systems，简称 GLES），是 OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL 是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。</p><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a><code>Metal</code></h3><p><code>Metal</code> 类似于 <code>OpenGL ES</code>，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过 <code>Metal</code>，但其实所有开发者都在间接地使用 <code>Metal</code>。<code>Core Animation</code>、<code>Core Image</code>、<code>SceneKit</code>、<code>SpriteKit</code> 等等渲染框架都是构建于 <code>Metal</code> 之上的。</p><p>当在真机上调试 OpenGL 程序时，控制台会打印出启用 <code>Metal</code> 的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL 命令无缝桥接到 <code>Metal</code> 上，由 <code>Metal</code> 担任真正于硬件交互的工作。</p><h1 id="UIView-与-CALayer-的关系"><a href="#UIView-与-CALayer-的关系" class="headerlink" title="UIView 与 CALayer 的关系"></a>UIView 与 CALayer 的关系</h1><p>在前面的 <code>Core Animation</code> 简介中提到 <code>CALayer</code> 事实上是用户所能在屏幕上看见的一切的基础。为什么 <code>UIKit</code> 中的视图能够呈现可视化内容？就是因为 <code>UIKit</code> 中的每一个 UI 视图控件其实内部都有一个关联的 <code>CALayer</code>，即 <code>backing layer</code>。</p><p>由于这种一一对应的关系，视图层级拥有 <strong>视图树</strong> 的树形结构，对应 <code>CALayer</code> 层级也拥有 <strong>图层树</strong> 的树形结构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-viewtree-layertree.png?x-oss-process=image/resize,w_500" alt=""></p><p>其中，视图的职责是 <strong>创建并管理</strong> 图层，以确保当子视图在层级关系中 <strong>添加或被移除</strong> 时，<strong>其关联的图层在图层树中也有相同的操作</strong>，即保证视图树和图层树在结构上的一致性。</p><blockquote><p>那么为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？</p></blockquote><p>其原因在于要做 <strong>职责分离</strong>，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 <code>UIKit</code> 和 <code>UIView</code>，对应 Mac OS X 有 <code>AppKit</code> 和 <code>NSView</code> 的原因。它们在功能上很相似，但是在实现上有着显著的区别。</p><blockquote><p>实际上，这里并不是两个层级关系，而是四个。每一个都扮演着不同的角色。除了 <strong>视图树</strong> 和 <strong>图层树</strong>，还有 <strong>呈现树</strong> 和 <strong>渲染树</strong>。</p></blockquote><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a><code>CALayer</code></h2><p>那么为什么 <code>CALayer</code> 可以呈现可视化内容呢？因为 <code>CALayer</code> 基本等同于一个 <strong>纹理</strong>。纹理是 GPU 进行图像渲染的重要依据。</p><p>在 <a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a> 中提到纹理本质上就是一张图片，因此 <code>CALayer</code> 也包含一个 <code>contents</code> 属性指向一块缓存区，称为 <code>backing store</code>，可以存放位图（Bitmap）。iOS 中将该缓存区保存的图片称为 <strong>寄宿图</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-contents.png?x-oss-process=image/resize,w_500" alt=""></p><p>图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成纹理），也支持直接使用纹理（图片）进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 <strong>手动绘制</strong>；另一种是 <strong>使用图片</strong>。</p><p>对此，iOS 中也有两种相应的实现方式：</p><ul><li>使用图片：<strong>contents image</strong></li><li>手动绘制：<strong>custom drawing</strong></li></ul><h3 id="Contents-Image"><a href="#Contents-Image" class="headerlink" title="Contents Image"></a>Contents Image</h3><p> Contents Image 是指通过 <code>CALayer</code> 的 <code>contents</code> 属性来配置图片。然而，<code>contents</code> 属性的类型为 <code>id</code>。在这种情况下，可以给 <code>contents</code> 属性赋予任何值，app 仍可以编译通过。但是在实践中，如果 <code>content</code> 的值不是 <code>CGImage</code> ，得到的图层将是空白的。</p><p> 既然如此，为什么要将 <code>contents</code> 的属性类型定义为 <code>id</code> 而非 <code>CGImage</code>。这是因为在 Mac OS 系统中，该属性对 <code>CGImage</code> 和 <code>NSImage</code> 类型的值都起作用，而在 iOS 系统中，该属性只对 <code>CGImage</code> 起作用。</p><p> 本质上，<code>contents</code> 属性指向的一块缓存区域，称为 <code>backing store</code>，可以存放 bitmap 数据。</p><h3 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h3><p>Custom Drawing 是指使用 <code>Core Graphics</code> 直接绘制寄宿图。实际开发中，一般通过继承 <code>UIView</code> 并实现 <code>-drawRect:</code> 方法来自定义绘制。</p><p>虽然 <code>-drawRect:</code> 是一个 <code>UIView</code> 方法，但事实上都是底层的 <code>CALayer</code> 完成了重绘工作并保存了产生的图片。下图所示为 <code>-drawRect:</code> 绘制定义寄宿图的基本原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-bitmap-custom-drawing.png?x-oss-process=image/resize,w_500" alt=""></p><ul><li><code>UIView</code> 有一个关联图层，即 <code>CALayer</code>。</li><li><code>CALayer</code> 有一个可选的 <code>delegate</code> 属性，实现了 <code>CALayerDelegate</code> 协议。<code>UIView</code> 作为 <code>CALayer</code> 的代理实现了 <code>CALayerDelegae</code> 协议。</li><li>当需要重绘时，即调用 <code>-drawRect:</code>，<code>CALayer</code> 请求其代理给予一个寄宿图来显示。</li><li><p><code>CALayer</code> 首先会尝试调用 <code>-displayLayer:</code> 方法，此时代理可以直接设置 <code>contents</code> 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)layer;</span><br></pre></td></tr></table></figure></li><li><p>如果代理没有实现 <code>-displayLayer:</code> 方法，<code>CALayer</code> 则会尝试调用 <code>-drawLayer:inContext:</code> 方法。在调用该方法前，<code>CALayer</code> 会创建一个空的寄宿图（尺寸由 <code>bounds</code> 和 <code>contentScale</code> 决定）和一个 <code>Core Graphics</code> 的绘制上下文，为绘制寄宿图做准备，作为 <code>ctx</code> 参数传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</span><br></pre></td></tr></table></figure></li><li><p>最后，由 <code>Core Graphics</code> 绘制生成的寄宿图会存入 <code>backing store</code>。</p></li></ul><h1 id="Core-Animation-流水线"><a href="#Core-Animation-流水线" class="headerlink" title="Core Animation 流水线"></a>Core Animation 流水线</h1><p>通过前面的介绍，我们知道了 <code>CALayer</code> 的本质，那么它是如何调用 GPU 并显示可视化内容的呢？下面我们就需要介绍一下 Core Animation 流水线的工作原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-steps.png" alt=""></p><p>事实上，app 本身并不负责渲染，渲染则是由一个独立的进程负责，即 <code>Render Server</code> 进程。</p><p>App 通过 IPC 将渲染任务及相关数据提交给 <code>Render Server</code>。<code>Render Server</code> 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。</p><p>Core Animation 流水线的详细过程如下：</p><ul><li>首先，由 app 处理事件（Handle Events），如：用户的点击操作，在此过程中 app 可能需要更新 <strong>视图树</strong>，相应地，<strong>图层树</strong> 也会被更新。</li><li>其次，app 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 <code>Render Server</code>，即完成了一次 <code>Commit Transaction</code> 操作。</li><li><code>Render Server</code> 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU</li><li>GPU 则在物理层上完成了对图像的渲染。</li><li>最终，GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上。</li></ul><p>对上述步骤进行串联，它们执行所消耗的时间远远超过 16.67 ms，因此为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式进行并行执行，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-workflow.png" alt=""></p><h2 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h2><p>在 Core Animation 流水线中，app 调用 <code>Render Server</code> 前的最后一步 Commit Transaction 其实可以细分为 4 个步骤：</p><ul><li><code>Layout</code></li><li><code>Display</code></li><li><code>Prepare</code></li><li><code>Commit</code></li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><code>Layout</code> 阶段主要进行视图构建，包括：<code>LayoutSubviews</code> 方法的重载，<code>addSubview:</code> 方法填充子视图等。</p><h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p><code>Display</code> 阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的 <code>drawRect:</code> 方法可以自定义 <code>UIView</code> 的显示，其原理是在 <code>drawRect:</code> 方法内部绘制寄宿图，该过程使用 CPU 和内存。</p><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p><code>Prepare</code> 阶段属于附加步骤，一般处理图像的解码和转换等操作。</p><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p><code>Commit</code> 阶段主要将图层进行打包，并将它们发送至 <code>Render Server</code>。该过程会递归执行，因为图层和视图都是以树形结构存在。</p><h1 id="动画渲染原理"><a href="#动画渲染原理" class="headerlink" title="动画渲染原理"></a>动画渲染原理</h1><p>iOS 动画的渲染也是基于上述 Core Animation 流水线完成的。这里我们重点关注 app 与 <code>Render Server</code> 的执行流程。</p><p>日常开发中，如果不是特别复杂的动画，一般使用 <code>UIView</code> Animation 实现，iOS 将其处理过程分为如下三部阶段：</p><ul><li>Step 1：调用 <code>animationWithDuration:animations:</code> 方法</li><li>Step 2：在 Animation Block 中进行 <code>Layout</code>，<code>Display</code>，<code>Prepare</code>，<code>Commit</code> 等步骤。</li><li>Step 3：<code>Render Server</code> 根据 Animation 逐帧进行渲染。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-animation-three-stage-process.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/" target="_blank" rel="noopener">Getting Pixels onto the Screen</a>，<a href="https://segmentfault.com/a/1190000000390012" target="_blank" rel="noopener">中文版（iOS 开发：绘制像素到屏幕）</a></li><li><a href="https://lision.me/ios-rendering-process/" target="_blank" rel="noopener">深入理解 iOS Rendering Process</a></li><li><a href="https://zsisme.gitbooks.io/ios-/content/" target="_blank" rel="noopener">iOS Core Animation: Advanced Techniques中文译本</a></li><li><a href="https://www.jianshu.com/p/c49833c04362" target="_blank" rel="noopener">关于drawRect</a></li><li>iOS 绘图与动画原理剖析</li><li>WWDC 2014 Session 419: Advanced Graphics and Animations for iOS Apps</li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a></li><li><a href="https://github.com/seedante/iOS-Note/wiki/Mastering-Offscreen-Render" target="_blank" rel="noopener">Mastering Offscreen Render</a></li><li><a href="https://download.developer.apple.com/wwdc_2012/wwdc_2012_session_pdfs/session_506__optimizing_2d_graphics_and_animation_performance.pdf" target="_blank" rel="noopener">Optimizing 2D Graphics and Animation Performance</a></li><li><a href="http://docs.huihoo.com/apple/wwdc/2012/session_240__polishing_your_interface_rotations.pdf" target="_blank" rel="noopener">Polishing Your Interface Rotation Animations</a></li><li><a href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/421_core_animation_essentials.pdf" target="_blank" rel="noopener">Core Animation Essentials</a></li><li><a href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/121_understanding_uikit_rendering.pdf" target="_blank" rel="noopener">Understanding UIKit Rendering</a></li><li><a href="http://www.lukeparham.com/blog/2016/5/25/ios-rendering-the-ui" target="_blank" rel="noopener">iOS: Rendering the UI</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a></li><li><a href="https://www.jianshu.com/p/d05d19f70bac" target="_blank" rel="noopener">iOS 动画篇：核心动画</a></li><li><a href="https://developer.samsung.com/game/gpu-framebuffer" target="_blank" rel="noopener">GPU Framebuffer Memory: Understanding Tiling</a></li><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li><li><a href="https://www.jianshu.com/p/456c961164d9" target="_blank" rel="noopener">OpenGL ES 框架详细解析（八） —— OpenGL ES 设计指南</a></li><li><a href="https://www.jianshu.com/p/748f9abafff8" target="_blank" rel="noopener">iOS 开发-视图渲染与性能优化</a></li><li><a href="https://segmentfault.com/a/1190000004164291#articleHeader5" target="_blank" rel="noopener">iOS 视图、动画渲染机制探究</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a></li><li><a href="https://www.zybuluo.com/qidiandasheng/note/494700" target="_blank" rel="noopener">iOS界面渲染流程</a></li><li><a href="http://blog.handy.wang/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/" target="_blank" rel="noopener">界面渲染的整体流程</a></li><li><a href="https://www.cnblogs.com/feng9exe/p/6723398.html" target="_blank" rel="noopener">iOS图像处理之Core Graphics和OpenGL ES初见</a></li><li>WWDC 2012 Session 506: Optimizing 2D Graphics and Animations Performances</li><li>WWDC 2011 Session 421: Core Animation Essentials</li><li>WWDC 2011 Session 129: Practical Drawing for iOS Developers</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过 &lt;a href=&quot;http://chuquan.me/2018/08/26/graphics-rending-principle-gpu&quot;&gt;图形渲染原理&lt;/a&gt; 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Core Animation Pipeline" scheme="http://chuquan.me/tags/Core-Animation-Pipeline/"/>
    
      <category term="Render Server" scheme="http://chuquan.me/tags/Render-Server/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(7)——图形图像渲染原理</title>
    <link href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/"/>
    <id>http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/</id>
    <published>2018-08-26T10:07:41.000Z</published>
    <updated>2018-09-24T16:38:51.459Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。</p><p>本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识储备。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为程序员，我们或多或少知道可视化应用程序都是由 CPU 和 GPU 协作执行的。那么我们就先来了解一下两者的基本概念：</p><ul><li><strong>CPU（Central Processing Unit）</strong>：现代计算机的三大核心部分之一，作为整个系统的运算和控制单元。CPU 内部的流水线结构使其拥有一定程度的并行计算能力。</li><li><strong>GPU（Graphics Processing Unit）</strong>：一种可进行绘图运算工作的专用微处理器。GPU 能够生成 2D/3D 的图形图像和视频，从而能够支持基于窗口的操作系统、图形用户界面、视频游戏、可视化图像应用和视频播放。GPU 具有非常强的并行计算能力。</li></ul><p>这时候可能会产生一个问题：CPU 难道不能代替 GPU 来进行图形渲染吗？答案当然是肯定的，不过在看了下面这个视频就明白为什么要用 GPU 来进行图形渲染了。</p><p><a href="http://ugcydzd.qq.com/uwMRJfz-r5jAYaQXGdGnC2_ppdhgmrDlPaRvaV7F2Ic/a0310ca26r9.m701.mp4?vkey=40961BB7F3520A37C85D4E4B4130DD91374BFB11499862930CE40B3E09D41D06125BC9EFC73A98DDDE2E5A64EAEB896492064C775F5C82ECD1D72D91D30C53F874EF2C404B480B719C6B8FAA1FA012CEF8743749150271333535195D599FE9F4E8E5FADC8C1A4FBEE74E1C81AA4206F408DE82EE359B3193&amp;br=29&amp;platform=2&amp;fmt=auto&amp;level=0&amp;sdtfrom=v1010&amp;guid=f401ea7eb4e13983f11cfe58f689e34d" target="_blank" rel="noopener">GPU CPU 模拟绘图视频</a></p><p>使用 GPU 渲染图形的根本原因就是：速度。GPU 的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。</p><p>那么像素是如何绘制在屏幕上的？计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为 <strong>渲染</strong>。渲染过程中最常用的技术就是 <strong>光栅化</strong>。</p><p>关于光栅化的概念，以下图为例，假如有一道绿光与存储在内存中的一堆三角形中的某一个在三维空间坐标中存在相交的关系。那么这些处于相交位置的像素都会被绘制到屏幕上。当然这些三角形在三维空间中的前后关系也会以遮挡或部分遮挡的形式在屏幕上呈现出来。一句话总结：光栅化就是将数据转化成可见像素的过程。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-rasterization-basic-concept.png?x-oss-process=image/resize,w_300" alt=""></p><p>GPU 则是执行转换过程的硬件部件。由于这个过程涉及到屏幕上的每一个像素，所以 GPU 被设计成了一个高度并行化的硬件部件。</p><p>下面，我们来简单了解一下 GPU 的历史。</p><h1 id="GPU-历史"><a href="#GPU-历史" class="headerlink" title="GPU 历史"></a>GPU 历史</h1><p>GPU 还未出现前，PC 上的图形操作是由 <strong>视频图形阵列（VGA，Video Graphics Array）</strong> 控制器完成。VGA 控制器由连接到一定容量的DRAM上的存储控制器和显示产生器构成。</p><p>1997 年，VGA 控制器开始具备一些 3D 加速功能，包括用于 <strong>三角形生成</strong>、<strong>光栅化</strong>、<strong>纹理贴图</strong> 和 <strong>阴影</strong>。</p><p>2000 年，一个单片处图形处理器继承了传统高端工作站图形流水线的几乎每一个细节。因此诞生了一个新的术语 GPU 用来表示图形设备已经变成了一个处理器。</p><p>随着时间的推移，GPU 的可编程能力愈发强大，其作为可编程处理器取代了固定功能的专用逻辑，同时保持了基本的 3D 图形流水线组织。</p><p>近年来，GPU 增加了处理器指令和存储器硬件，以支持通用编程语言，并创立了一种编程环境，从而允许使用熟悉的语言（包括 C/C++）对 GPU 进行编程。</p><p>如今，GPU 及其相关驱动实现了图形处理中的 <code>OpenGL</code> 和 <code>DirectX</code> 模型，从而允许开发者能够轻易地操作硬件。<code>OpenGL</code> 严格来说并不是常规意义上的 API，而是一个第三方标准（由 khronos 组织制定并维护），其严格定义了每个函数该如何执行，以及它们的输出值。至于每个函数内部具体是如何实现的，则由 OpenGL 库的开发者自行决定。实际 OpenGL 库的开发者通常是显卡的生产商。<code>DirectX</code> 则是由 Microsoft 提供一套第三方标准。</p><h1 id="GPU-图形渲染流水线"><a href="#GPU-图形渲染流水线" class="headerlink" title="GPU 图形渲染流水线"></a>GPU 图形渲染流水线</h1><p>GPU 图形渲染流水线的主要工作可以被划分为两个部分：</p><ul><li>把 3D 坐标转换为 2D 坐标</li><li>把 2D 坐标转变为实际的有颜色的像素</li></ul><p>GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示。</p><ul><li><strong>顶点着色器（Vertex Shader）</strong></li><li><strong>形状装配（Shape Assembly）</strong>，又称 <strong>图元装配</strong></li><li><strong>几何着色器（Geometry Shader）</strong></li><li><strong>光栅化（Rasterization）</strong></li><li><strong>片段着色器（Fragment Shader）</strong></li><li><strong>测试与混合（Tests and Blending）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/opengl-graphics-pipeline.png" alt=""></p><p>第一阶段，顶点着色器。该阶段的输入是 <strong>顶点数据（Vertex Data）</strong> 数据，比如以数组的形式传递 3 个 3D 坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器可以对顶点属性进行一些基本处理。</p><p>第二阶段，形状（图元）装配。该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图中则是一个三角形。<strong>图元（Primitive）</strong> 用于表示如何渲染顶点数据，如：点、线、三角形。</p><p>第三阶段，几何着色器。该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p><p>第四阶段，光栅化。该阶段会把图元映射为最终屏幕上相应的像素，生成片段。<strong>片段（Fragment）</strong> 是渲染一个像素所需要的所有数据。</p><p>第五阶段，片段着色器。该阶段首先会对输入的片段进行 <strong>裁切（Clipping）</strong>。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。</p><p>第六阶段，测试与混合。该阶段会检测片段的对应的深度值（<code>z</code> 坐标），判断这个像素位于其它物体的前面还是后面，决定是否应该丢弃。此外，该阶段还会检查 <code>alpha</code> 值（ <code>alpha</code> 值定义了一个物体的透明度），从而对物体进行混合。因此，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>关于混合，GPU 采用如下公式进行计算，并得出最后的颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = S + D * (1 - Sa)</span><br></pre></td></tr></table></figure><p>关于公式的含义，假设有两个像素 S(source) 和 D(destination)，S 在 <code>z</code> 轴方向相对靠前（在上面），D 在 <code>z</code> 轴方向相对靠后（在下面），那么最终的颜色值就是 <strong>S（上面像素） 的颜色 + D（下面像素） 的颜色 * （1 - S（上面像素） 颜色的透明度）</strong>。</p><p>上述流水线以绘制一个三角形为进行介绍，可以为每个顶点添加颜色来增加图形的细节，从而创建图像。但是，如果让图形看上去更加真实，需要足够多的顶点和颜色，相应也会产生更大的开销。为了提高生产效率和执行效率，开发者经常会使用 <strong>纹理（Texture）</strong> 来表现细节。<strong>纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理）</strong>。<strong>纹理一般可以直接作为图形渲染流水线的第五阶段的输入</strong>。</p><p>最后，我们还需要知道上述阶段中的着色器事实上是一些程序，它们运行在 GPU 中成千上万的小处理器核中。这些着色器允许开发者进行配置，从而可以高效地控制图形渲染流水线中的特定部分。由于它们运行在 GPU 中，因此可以降低 CPU 的负荷。着色器可以使用多种语言编写，OpenGL 提供了 GLSL（OpenGL Shading Language） 着色器语言。</p><h1 id="GPU-存储系统"><a href="#GPU-存储系统" class="headerlink" title="GPU 存储系统"></a>GPU 存储系统</h1><p>早期的 GPU，不同的着色器对应有着不同的硬件单元。如今，GPU 流水线则使用一个统一的硬件来运行所有的着色器。此外，nVidia 还提出了 <strong>CUDA（Compute Unified Device Architecture）</strong> 编程模型，可以允许开发者通过编写 C 代码来访问 GPU 中所有的处理器核，从而深度挖掘 GPU 的并行计算能力。</p><p>下图所示为 GPU 内部的层级结构。最底层是计算机的系统内存，其次是 GPU 的内部存储，然后依次是两级 cache：L2 和 L1，每个 L1 cache 连接至一个 <strong>流处理器（SM，stream processor）</strong>。</p><ul><li>SM L1 Cache 的存储容量大约为 16 至 64KB。</li><li>GPU L2 Cache 的存储容量大约为几百 KB。</li><li>GPU 的内存最大为 12GB。</li></ul><p>GPU 上的各级存储系统与对应层级的计算机存储系统相比要小不少。</p><p>此外，GPU 内存并不具有一致性，也就意味着并不支持并发读取和并发写入。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-hierarchy.png?x-oss-process=image/resize,w_400" alt=""></p><h1 id="GPU-流处理器"><a href="#GPU-流处理器" class="headerlink" title="GPU 流处理器"></a>GPU 流处理器</h1><p>下图所示为 GPU 中每个流处理器的内部结构示意图。每个流处理器集成了一个 L1 Cache。顶部是处理器核共享的寄存器堆。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-stream-processor.png?x-oss-process=image/resize,w_400" alt=""></p><h1 id="CPU-GPU-异构系统"><a href="#CPU-GPU-异构系统" class="headerlink" title="CPU-GPU 异构系统"></a>CPU-GPU 异构系统</h1><p>至此，我们大致了解了 GPU 的工作原理和内部结构，那么实际应用中 CPU 和 GPU 又是如何协同工作的呢？</p><p>下图所示为两种常见的 CPU-GPU 异构架构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cpu-gpu-architecture.png" alt=""></p><p>左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e 总线进行连接。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p><p>右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p><p>注意，目前很多 SoC 都是集成了CPU 和 GPU，事实上这仅仅是在物理上进行了集成，并不意味着它们使用的就是耦合式结构，大多数采用的还是分离式结构。耦合式结构是在系统上进行了集成。</p><p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 GPU 共享系统内存，由 MMU 进行存储管理。</p><p>图形应用程序调用 <code>OpenGL</code> 或 <code>Direct3D</code> API 功能，将 GPU 作为协处理器使用。API 通过面向特殊 GPU 优化的图形设备驱动向 GPU 发送命令、程序、数据。</p><h1 id="GPU-资源管理模型"><a href="#GPU-资源管理模型" class="headerlink" title="GPU 资源管理模型"></a>GPU 资源管理模型</h1><p>下图所示为分离式异构系统中 GPU 的资源管理模型示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-management-model.png" alt=""></p><ol><li><strong>MMIO（Memory-Mapped I/O）</strong></li></ol><ul><li>CPU 通过 MMIO 访问 GPU 的寄存器状态。</li><li>通过 MMIO 传送数据块传输命令，支持 DMA 的硬件可以实现块数据传输。</li></ul><ol><li><strong>GPU Context</strong></li></ol><ul><li>上下文表示 GPU 的计算状态，在 GPU 中占据部分虚拟地址空间。多个活跃态下的上下文可以在 GPU 中并存。</li></ul><ol><li><strong>CPU Channel</strong></li></ol><ul><li>来自 CPU 操作 GPU 的命令存储在内存中，并提交至 GPU channel 硬件单元。</li><li>每个 GPU 上下文可拥有多个 GPU Channel。每个 GPU 上下文都包含 GPU channel 描述符（GPU 内存中的内存对象）。</li><li>每个 GPU Channel 描述符存储了channel 的配置，如：其所在的页表。</li><li>每个 GPU Channel 都有一个专用的命令缓冲区，该缓冲区分配在 GPU 内存中，通过 MMIO 对 CPU 可见。</li></ul><ol><li><strong>GPU 页表</strong></li></ol><ul><li>GPU 上下文使用 GPU 页表进行分配，该表将虚拟地址空间与其他地址空间隔离开来。</li><li>GPU 页表与 CPU 页表分离，其驻留在 GPU 内存中，物理地址位于 GPU 通道描述符中。<br>通过 GPU channel 提交的所有命令和程序都在对应的 GPU 虚拟地址空间中执行。</li><li>GPU 页表将 GPU 虚拟地址不仅转换为 GPU 设备物理地址，还转换为主机物理地址。这使得 GPU 页面表能够将 GPU 存储器和主存储器统一到统一的 GPU 虚拟地址空间中，从而构成一个完成的虚拟地址空间。</li></ul><ol><li><strong>PFIFO Engine</strong></li></ol><ul><li>PFIFO 是一个提交 GPU 命令的特殊引擎。</li><li>PFIFO 维护多个独立的命令队列，即 channel。</li><li>命令队列是带有 put 和 get 指针的环形缓冲器。</li><li>PFIFO 引擎会拦截多有对通道控制区域的访问以供执行。</li><li>GPU 驱动使用一个通道描述符来存储关联通道的设置。</li></ul><ol><li><strong>BO</strong></li></ol><ul><li>缓冲对象（Buffer Object）。一块内存，可以用来存储纹理，渲染对象，着色器代码等等。</li></ul><h1 id="CPU-GPU-工作流"><a href="#CPU-GPU-工作流" class="headerlink" title="CPU-GPU 工作流"></a>CPU-GPU 工作流</h1><p>下图所示为 CPU-GPU 异构系统的工作流，当 CPU 遇到图像处理的需求时，会调用 GPU 进行处理，主要流程可以分为以下四步：</p><ol><li>将主存的处理数据复制到显存中</li><li>CPU 指令驱动 GPU</li><li>GPU 中的每个运算单元并行处理</li><li>GPU 将显存结果传回主存</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/cuda_processing_flow.png" alt=""></p><h1 id="屏幕图像显示原理"><a href="#屏幕图像显示原理" class="headerlink" title="屏幕图像显示原理"></a>屏幕图像显示原理</h1><p>介绍屏幕图像显示的原理，需要先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 <strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 <strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" alt=""></p><p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 <code>VSync</code> 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_500" alt=""></p><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png" alt=""></p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" alt=""></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cs.utah.edu/~jeffp/teaching/MCMD/S20-GPU.pdf" target="_blank" rel="noopener">GPU Architecture and Models</a></li><li>计算机组成与设计：硬件、软件接口</li><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">欢迎来到OpenGL的世界</a></li><li><a href="https://pdfs.semanticscholar.org/presentation/52d1/963f6a3409aff1f8d73ba1819a187f39f6e1.pdf" target="_blank" rel="noopener">AMD APU Series</a></li><li><a href="http://m.elecfans.com/article/713834.html" target="_blank" rel="noopener">一文详解GPU结构及工作原理</a></li><li><a href="https://www.slideshare.net/mohamedragabslideshare/p12-29046493" target="_blank" rel="noopener">Revisting Co-Processing for Hash Joins on the Coupled CPU-GPU Architecture</a></li><li><a href="https://insujang.github.io/2017-04-27/gpu-architecture-overview/" target="_blank" rel="noopener">GPU Architecture Overview</a></li><li><a href="https://zh.wikipedia.org/wiki/CUDA" target="_blank" rel="noopener">CUDA</a></li><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流程的技巧</a></li><li><a href="https://segmentfault.com/a/1190000000390012" target="_blank" rel="noopener">iOS 开发：绘制像素到屏幕</a></li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://slideplayer.com/slide/11059244/" target="_blank" rel="noopener">Rendering pipeline: The hardware side</a></li><li><a href="http://meseec.ce.rit.edu/551-projects/spring2015/3-2.pdf" target="_blank" rel="noopener">Graphics Processing Unit(GPU) Memory Hierarchy</a></li><li><a href="http://www.d.umn.edu/~data0003/Talks/gpuarch.pdf" target="_blank" rel="noopener">Graphics Processing Unit Architecture(GPU Arch) With a focus on NVIDIA GeForce 6800 GPU</a></li><li><a href="https://www.jianshu.com/p/d05d19f70bac" target="_blank" rel="noopener">iOS动画篇：核心动画</a></li><li><a href="https://www.anandtech.com/show/7335/the-iphone-5s-review/7" target="_blank" rel="noopener">The iPhone 5s Review</a></li><li><a href="https://www.realworldtech.com/apple-custom-gpu/" target="_blank" rel="noopener">A Look Inside Apple’s Custom GPU for the iPhone</a></li><li><a href="https://appleinsider.com/articles/17/04/17/one-apple-gpu-one-giant-leap-in-graphics-for-iphone-8" target="_blank" rel="noopener">One Apple GPU, one giant leap in graphics for iPhone 8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。&lt;/p&gt;
&lt;p&gt;本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="GPU" scheme="http://chuquan.me/tags/GPU/"/>
    
      <category term="渲染" scheme="http://chuquan.me/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(6)——线程</title>
    <link href="http://chuquan.me/2018/07/10/thread-introduce/"/>
    <id>http://chuquan.me/2018/07/10/thread-introduce/</id>
    <published>2018-07-09T16:15:39.000Z</published>
    <updated>2018-07-09T16:23:56.389Z</updated>
    
    <content type="html"><![CDATA[<p>现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p><strong>线程（Thread）</strong>，也称<strong>轻量级进程（Lightweight Process，LWP）</strong>，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合、堆栈组成。通常，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（如打开文件和信号）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-in-process.png" alt=""></p><p>同一进程中的多个线程可以互不干扰地并发执行，并且共享进程的全局变量和堆的数据。相对于单线程进程，使用多线程的原因有一下几点：</p><ul><li>某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待时间进行线程切换。如等待网络响应。</li><li>某个操作可能会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会被中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li><li>程序本身要求并发操作，如一个多端下载软件（如Bittorrent）。</li><li>多CPU或多核处理器，本身具备同时执行多个线程的能力，因此单线程程序无法全面发挥计算机的全部计算能力。</li><li>相对于多进程应用，多线程在数据共享方面效率更高。</li></ul><h2 id="线程访问权限"><a href="#线程访问权限" class="headerlink" title="线程访问权限"></a>线程访问权限</h2><p>线程可以访问进程内存中的所有的数据，包括如下几个方面：</p><ul><li><strong>全局变量</strong></li><li><strong>堆数据</strong></li><li><strong>函数里的静态变量</strong></li><li><strong>程序代码，任何线程都有权利读取并执行任何代码</strong></li><li><strong>打开的文件，A线程打开的文件可以由B线程读取</strong></li></ul><p>当然实际上线程也拥有自己的私有存储空间，包括如下几个方面：</p><ul><li><strong>栈</strong>：尽管并非完全无法被其他线程访问，但是一般情况下还是认为栈是私有数据。</li><li><strong>线程局部存储（Thread Local Storage，TLS）</strong>：线程局部存储是某些操作系统为线程单独提供的私有空间，容量有限。</li><li><strong>寄存器</strong>：寄存器是执行流的基本数据，为线程私有。</li></ul><h2 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h2><p>当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上。当线程数据大于处理器数量时，此时至少有一个处理器会运行多个线程。</p><p>在单处理器运行多线程情况下，并发是一种模拟出来的状态。操作系统会让这些多线程轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样每个线程“看起来”在同时执行。这样一个不断在处理器上切换不同的线程的行为称为 <strong>线程调度</strong>。</p><p>在线程调度中，线程通常拥有至少三种状态，分别是：</p><ul><li><strong>运行（Running）</strong>：此时线程正在执行。</li><li><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPI已被占用。</li><li><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。</li></ul><p>处于运行中的线程拥有一段可以执行的时间，这段时间称为 <strong>时间片（Time Slice）</strong>。当时间片用尽时，线程进入就绪状态。如果线程在时间片用尽前就开始等待某事件，则它将进入等待状态。当一个线程离开运行状态时，系统会选择一个处于就绪状态的线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。如下图所示为线程的状态转移图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-state-transition-diagram.png" alt=""></p><p>在线程调度中，主要有两种调度算法：</p><ul><li><strong>优先级调度（Priority Schedule）</strong>：线程拥有各自的 <strong>线程优先级（Thread Priority）</strong>，高优先级的线程会更早执行，低优先级的线程需要等待系统中没有高优先级的可执行线程存在时才能执行。</li><li><strong>轮转调度（Round Robin Schedule）</strong>：让各个线程轮流执行一段时间片。</li></ul><p>实际应用中，系统还会根据不同线程的表现自动调整优先级，提高线程调度效率。在系统中，一般把频繁等待的线程称为 <strong>IO密集型线程（IO Bound Thread）</strong>；把很少等待的线程称为 <strong>CPU密集型线程（CPU Bound Thread）</strong>。通常，IO 密集型线程比 CPU 密集型线程更容易得到优先级的提升。</p><p>在优先级调度中，存在一种 <strong>饿死（Starvation）</strong> 现象，即一个线程的优先级较低，在它执行之前，总是有较高优先级的线程在它之前执行。当一个CPU密集型的线程获得较高优先级时，许多低优先级的进程就可能饿死。当一个IO密集型的线程获得较高优先级时，由于大部分之间处于等待状态，因此相对不容易造成其他线程饿死。为了避免饿死现象，调度系统通常会逐步提升那些等待时间过长且未得到执行的线程的优先级。</p><h2 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h2><p>轮转调度中，线程在用尽时间片后会被强制剥夺继续执行的权利，而进入就绪状态，该过程称为 <strong>抢占（Preemption）</strong>。在早期的一些操作系统中，线程是不可抢占的。在这种调度模型下，线程必须主动进入就绪状态，而不是靠时间片用尽来被强制进入。如果线程始终拒绝进入就绪状态，并且不进行任何等待操作，其他线程将永远无法执行。</p><p>在不可抢占线程中，线程会在两种情况下主动放弃执行：</p><ul><li>当线程试图等待某些事件时（如I/O事件）。</li><li>线程主动放弃时间片。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多线程程序处于一个多变的环境中，可以访问的全局变量和堆数据随时都可能被其他的线程改变。因此，多线程程序在并发时数据的一致性非常重要。</p><h2 id="竞争与原子操作"><a href="#竞争与原子操作" class="headerlink" title="竞争与原子操作"></a>竞争与原子操作</h2><p>多线程同时访问一个共享数据，可能会造成严重的后果。以一个著名的例子为例，假设有两个线程分别执行如下所示的 C 代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 1</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line">--i;</span><br></pre></td></tr></table></figure></p><p>在很多体系结构中，++i 的实现方式一般如下：</p><ol><li><strong>读取 i 到某个寄存器 X</strong></li><li><strong>X++</strong></li><li><strong>将 X 的内容存储至 i</strong></li></ol><p>由于线程 1 和线程 2并发执行，因此两个线程的执行可能如下（注意，寄存器 X 的 内容在不同的线程中是不一样的，这里用 X[1] 和 X[2] 分别表示线程 1 和线程 2 中的 X），如下所示：</p><table><thead><tr><th style="text-align:left">执行序号</th><th style="text-align:left">执行指令</th><th style="text-align:left">语句执行后的变量值</th><th style="text-align:left">线程</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">i = 1</td><td style="text-align:left">i = 1, X[1] = 未知</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">X[1] = i</td><td style="text-align:left">i = 1, X[1] = 1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">X[2] = i</td><td style="text-align:left">i = 1, X[2] = 1</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">X[1]++</td><td style="text-align:left">i = 1, X[1] = 2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">X[2]–</td><td style="text-align:left">i = 1, X[2] = 0</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">i = X[1]</td><td style="text-align:left">i = 2, X[1] = 2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">i = X[2]</td><td style="text-align:left">i = 0, X[2] = 0</td><td style="text-align:left">2</td></tr></tbody></table><p>从程序逻辑上看，两个线程都执行完毕之后，i 的值应该是 1，但从表中的执行序列可以看到，i 的实际值是 0。实际上，这两个线程如果同时执行，i 的结果有可能是 0 或 1 或 2。</p><p>很明显，由于 i++ 操作在多线程环境下会出现错误是因为该操作被编译成汇编代码后不止一条指令，因此在执行时可能会被调度系统打断，去执行别的代码。通常，我们把单指令的操作称为 <strong>原子操作</strong>，因为单条指令的执行是不会被打断的。很多体系结构都提供了一些常用的原子指令，如 i386 就有一条 inc 指令可以直接增加一个内存单元值，可以避免上例的错误情况。</p><p>尽管原子操作指令非常方便，但是它们仅适用于比较简单特定的场合。在复杂的场合下，比如要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。这里需要更加通用的手段：锁。</p><h2 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h2><p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，需要将各个线程对同一个数据的访问进行 <strong>同步（Synchronization）</strong>。即在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。</p><p>同步最常见的方法是使用 <strong>锁（Lock）</strong>。锁是一种非强制机制，每个线程在访问数据或资源之前首先试图 <strong>获取（Acquire）</strong> 锁，并在访问结束之后 <strong>释放（Release）</strong> 锁。在锁已经被占用时试图获取锁时，线程会等待，直到锁重新可用。</p><h3 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h3><p><strong>二元信号量（Binary Semaphore）</strong> 是最简单的一种锁，只有两种状态：<strong>占用</strong>、<strong>非占用</strong>。二元信号量适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</p><h3 id="多元信号量"><a href="#多元信号量" class="headerlink" title="多元信号量"></a>多元信号量</h3><p>多元信号量是二元信号量的扩展，简称 <strong>信号量（Semaphore）</strong>。一个初始值为 N 的信号量允许 N 个线程并发访问。</p><p>当线程访问资源时，首先获取信号量，进行如下操作：</p><ul><li>将信号量减 1。</li><li>如果信号量的值小于 0，则进入等待状态，否则继续执行。</li></ul><p>当线程结束访问资源后，线程释放信号量，进行如下操作：</p><ul><li>将信号量的值加 1。</li><li>如果信号量的值小于 1，唤醒一个等待中的线程。</li></ul><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><strong>互斥量（Mutex）</strong> 和二元信号量很相似，资源仅同时允许一个线程访问，但和信号量不同的是：信号量在整个系统中可以被任意线程获取并释放，即同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><strong>临界区（Read-Write Lock）</strong> 是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于：互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的；临界区的作用范围仅限于本进程，其他的进程无法获取该锁。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>读写锁（Read-Write Lock）</strong> 致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对该数据进行修改，就必须使用同步手段来避免出错。对此，可以使用上述的信号量、互斥量或临界区中的任何一种来进行同步。虽然这样可以保证程序正确执行，但是对于读取频繁的程序，会显得非常低效。读写锁就是用来提高这种情况下的执行效率的。</p><p>读写锁有两种获取方式：<strong>共享的（Shared）</strong>、<strong>独占的（Exclusive）</strong>。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有线程释放。处于独占状态的锁将阻止任何其他线程获取该锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>条件变量（Condition Variable）</strong> 作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作：首先，线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时所有等待此条件变量的线程都会被唤醒并继续执行。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>线程的并发执行是由多处理器或操作系统调度来实现的。但实际情况要更为复杂：大多数操作系统，包括 Windows 和 Linux，都在内核里提供线程的支持，内核态线程由多处理器或调度来实现并发。然而用户实际使用的线程并不是内核态线程，而是用户态线程。用户态线程并不一定在操作系统内核里对应同等数量的内核态线程。它们之间的对应关系有三种类型。</p><h2 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h2><p>对于直接支持线程的系统，一对一模型始终是最简单的模型。对于一对一模型，一个用户态线程唯一对应一个内核态线程，但一个内核态线程并不一定存在相应的用户态线程。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-one-to-one.png" alt=""></p><p>一对一模型中，用户态线程具有和内核态线程一致的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程的执行不会受到影响。此外，一对一模型也可以让多线程程序在多处理器的系统上有更高的效率。</p><p>一对一线程模型也有两个缺点：</p><ul><li>由于许多操作系统限制了内核态线程的数量，因此一对一线程会让用户态线程的数量受到限制。</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ul><h2 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h2><p>多对一模型将多个用户态线程映射到一个内核态线程上，线程之间的切换由用户态的代码完成。因此相对于一对一模型，多对一模型的切换要快速许多。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-one.png" alt=""></p><p>多对一模型的问题在于：如果其中一个用户态线程阻塞，将导致所有线程都无法执行。另外，在多处理器系统中，处理器的增多对于多对一模型的线程性能也不会有明显的提升。多对一模型的优点在于高效的上下文切换和几乎无限制的线程数量。</p><h2 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h2><p>多对多模型结合了多对一模型和一对一模型的特点，将多个用户态线程映射到少数但不止一个内核态线程。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-many.png" alt=""></p><p>多对多模型中，一个用户态线程阻塞并不会导致所有的用户态线程阻塞，因为此时还有其他的线程可以被调度来执行。此外，多对多模型对用户线程的数量也没什么限制，在多处理器系统中，多对多模型的线程也能得到一定的性能提升，但是提升幅度步入一对一模型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。&lt;/p&gt;
&lt;h1 id=&quot;线程基础&quot;&gt;&lt;a href=&quot;#线程基础&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="线程" scheme="http://chuquan.me/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="信号量" scheme="http://chuquan.me/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="临界区" scheme="http://chuquan.me/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(5)——可执行文件的装载与运行</title>
    <link href="http://chuquan.me/2018/06/17/executable-file-load-and-execution/"/>
    <id>http://chuquan.me/2018/06/17/executable-file-load-and-execution/</id>
    <published>2018-06-17T15:33:16.000Z</published>
    <updated>2018-06-24T16:13:39.599Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello.out</span><br></pre></td></tr></table></figure></p><p>那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤：</p><ul><li>创建新进程</li><li>检查可执行文件类型</li><li>搜索匹配装载处理过程</li><li>装载执行可执行文件</li></ul><h1 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h1><p>首先在用户层面，bash 进程会调用 <code>fork()</code> 系统调用创建一个新的进程。其次，新的进程通过调用 <code>execve()</code> 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。</p><p><code>execve()</code> 系统调用被定义在 <code>unistd.h</code>，其原型如下所示。其中的三个参数分别对应被执行程序的 <strong>程序文件名</strong>、<strong>执行参数</strong>、<strong>环境变量</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure></p><h1 id="检查可执行文件类型"><a href="#检查可执行文件类型" class="headerlink" title="检查可执行文件类型"></a>检查可执行文件类型</h1><p>当进入 <code>execve()</code> 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，<code>execve()</code> 系统调用相应的入口是 <code>sys_execve()</code>。<code>sys_execve()</code> 进行一些参数的检查复制之后，调用 <code>do_execve()</code>。<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。</p><p>为什么要先读取文件的前 128 个字节？这是因为Linux支持的可执行文件不止 ELF 一种，还包括 <strong>a.out</strong>、<strong>Java 程序</strong>、<strong>以 <code>#!</code> 开头的脚本程序</strong>。<code>do_execve()</code>通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前4个字节，被称为 <strong>魔数（Magic Number）</strong>。比如：ELF的可执行文件格式的头 4 个字节为 <code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头 4 个字节为 <code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果是解释型语言的脚本，则第一行通常是 <code>#!/bin/sh</code> 或 <code>#!/user/bin/python</code>，其中 <code>#</code> 和 <code>!</code> 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p><h1 id="搜索匹配装载处理过程"><a href="#搜索匹配装载处理过程" class="headerlink" title="搜索匹配装载处理过程"></a>搜索匹配装载处理过程</h1><p>当 <code>do_execve()</code> 读取了128个字节的文件头部之后，调用 <code>search_binary_handle()</code> 去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux 中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，<code>search_binary_handler()</code> 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.</p><ul><li>ELF 可执行文件：<code>load_elf_binary()</code></li><li>a.out 可执行文件：<code>load_aout_binary()</code></li><li>可执行脚本程序：<code>load_script()</code></li></ul><h1 id="装载执行可执行文件"><a href="#装载执行可执行文件" class="headerlink" title="装载执行可执行文件"></a>装载执行可执行文件</h1><p>以 ELF 的装载处理过程 <code>load_elf_binary()</code> 为例，其所包含的步骤如下图所示：<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-load-process.png" alt=""></p><ol><li>操作系统读取可执行文件 ELF 的 <code>Header</code>，检查文件的有效性。</li><li>操作系统读取可执行文件 ELF的 <code>Program Header Table</code> 中读取每个 <code>Segment</code> 的虚拟地址、文件地址、属性等。</li><li>操作系统根据 <code>Program Header Table</code> 将可执行文件 ELF 映射至内存。</li><li>如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 <code>.interp</code> 节，找到 <strong>动态链接器（Dynamic Linker）</strong> 的位置，并启动动态链接器。在 Linux 下，动态链接器 <code>ld.so</code> 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。</li><li>动态链接器获得控制权后，开始执行一系列初始化操作。</li><li>动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。</li><li>控制权被转交到可执行文件的入口地址，程序开始正式执行。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="装载" scheme="http://chuquan.me/tags/%E8%A3%85%E8%BD%BD/"/>
    
      <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(4)——链接、静态链接、动态链接</title>
    <link href="http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/"/>
    <id>http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/</id>
    <published>2018-06-03T15:44:39.000Z</published>
    <updated>2018-06-18T15:51:57.891Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="http://chuquan.me/2018/05/21/elf-introduce/">前面</a>对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？一切都要从链接说起。</p><h1 id="链接概述"><a href="#链接概述" class="headerlink" title="链接概述"></a>链接概述</h1><p>模块化设计是软件开发中最常用的设计思想。<strong>链接（Linking）</strong> 本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。比如：</p><blockquote><p>我们在模块<code>main.c</code>中使用另一个模块<code>func.c</code>中的<code>foo()</code>函数。我们在<code>main.c</code>模块中每一处调用<code>foo</code>时都必须确切知道<code>foo</code>函数的地址。但由于每个模块都是单独编译的。编译器在编译<code>main.c</code>的时候并不知道<code>foo</code>函数的地址。所以编译器会暂时把这些调用<code>foo</code>的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。这就是静态链接最基本的过程和作用。</p></blockquote><p>如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和 <strong>库（Library）</strong> 一起链接形成最终的可执行文件。</p><p>其中，最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/linking-process.png" alt=""></p><p>链接过程主要包含了三个步骤：</p><ol><li><strong>地址与空间分配（Address and Storage Allocation）</strong></li><li><strong>符号解析（Symbol Resolution）</strong></li><li><strong>重定位（Relocation）</strong></li></ol><p>下面，我们以两个源代码文件<code>a.c</code>和<code>b.c</code>为例展开分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.c</span><br><span class="line">extern int shared;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 100;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// b.c</span><br><span class="line">int shared = 1;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>b.c</code>中定义了两个全局符号：变量<code>shared</code>、函数<code>swap</code>；<code>a.c</code>中定义了一个全局符号：<code>main</code>。<code>a.c</code>引用了<code>b.c</code>中的<code>swap</code>和<code>shared</code>。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件<code>ab</code>。</p><p>使用<code>gcc -c</code>命令我们可以分别编译得到<code>a.o</code>和<code>b.o</code>两个目标文件。</p><h2 id="地址与空间分配"><a href="#地址与空间分配" class="headerlink" title="地址与空间分配"></a>地址与空间分配</h2><p>在介绍ELF文件结构关于段与节的区别时，我们就提到过可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。</p><h3 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h3><p>一个最简单的方案就是将输入的文件按序叠加，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-simple-merge.png" alt=""></p><p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p><h3 id="合并相似节"><a href="#合并相似节" class="headerlink" title="合并相似节"></a>合并相似节</h3><p>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-similar-merge.png" alt=""></p><p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p><ol><li>在输出的可执行文件中的空间</li><li>在装载后的虚拟地址中的空间</li></ol><p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p><p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong> 的方法。即整个链接过程分为两步：</p><ul><li><strong>第一步 地址与空间分配</strong><br>  扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</li><li><strong>第二步 符号解析与重定位</strong><br>  使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/two-step-linking.png" alt=""></p><p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了<a href="http://chuquan.me/2018/05/21/elf-introduce/">ELF文件结构</a>一文中没有介绍的 <strong>程序头表（Program Header Table）</strong> 结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png" alt=""></p><p>我们使用ld或gcc将<code>a.o</code>和<code>b.o</code>链接起来，然后使用objdump工具来查看链接前后的地址分配情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h a.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h b.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004b  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h ab</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  ...</span><br><span class="line">  13 .text         00000202  0000000000400450  0000000000400450  00000450  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  ...</span><br><span class="line">  24 .data         00000014  0000000000601028  0000000000601028  00001028  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  25 .bss          00000004  000000000060103c  000000000060103c  0000103c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>可以发现，链接前目标文件中所有节的 <strong>VMA（Virtual Memory Address）</strong> 都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个节被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>0x0000000000400450</code>。</p><p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>0x0000000000400450</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>0x0000000000400450</code>。</p><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>在<strong>两步链接</strong>中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。</p><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p><p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p><p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p><h3 id="多重定义的全局符号解析"><a href="#多重定义的全局符号解析" class="headerlink" title="多重定义的全局符号解析"></a>多重定义的全局符号解析</h3><p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p><p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p><p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong>  </p><p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p><ul><li><strong>规则1：不允许有多个同名的强符号。</strong></li><li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li><li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li></ul><p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p><ul><li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li><li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li><li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li></ul><p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 <strong>COMMON块（Common Block<br>）</strong> 的机制来处理。其过程如下：</p><p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p><p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong> 专门用来保存这些与重定位相关的信息。</p><p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p><p>我们可以使用objdump工具来查看目标文件中的重定位表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000023 R_X86_64_32       share</span><br><span class="line">0000000000000030 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line">0000000000000049 R_X86_64_PC32     __stack_chk_fail-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p><p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation Entry）</strong>。利用数据结构成员包含的信息，即可完成重定位。</p><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>事实上，静态链接的过程就是上文所描述的过程。在Linux中，静态链接器（static linker）<code>ld</code>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。</p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等。在静态链接中，C语言静态库是很典型的浪费空间的例子。关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序。</p><p>解决空间浪费和更新困难最简单的方法便是将程序的模块相互分割开来，形成独立文件。简而言之，就是不对那些组成程序的目标文件进行链接，而是等到程序要运行时才进行链接。</p><h2 id="动态链接的基本实现"><a href="#动态链接的基本实现" class="headerlink" title="动态链接的基本实现"></a>动态链接的基本实现</h2><p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p><p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong>，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong>，一般以<code>.dll</code>为后缀。</p><p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p><h2 id="动态链接程序运行时地址空间分布"><a href="#动态链接程序运行时地址空间分布" class="headerlink" title="动态链接程序运行时地址空间分布"></a>动态链接程序运行时地址空间分布</h2><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p><p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p><ul><li><strong>静态共享库（Static Shared Library）</strong>（地址固定）</li><li><strong>动态共享库（Dynamic Shared Libary）</strong>（地址不固定）</li></ul><h3 id="静态共享库"><a href="#静态共享库" class="headerlink" title="静态共享库"></a>静态共享库</h3><p>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在<strong>某个特定的地址</strong>划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为<strong>静态</strong>。</p><p>但是静态共享库的目标地址会导致地址冲突、升级等问题。</p><h3 id="动态共享库"><a href="#动态共享库" class="headerlink" title="动态共享库"></a>动态共享库</h3><p>采用动态共享库的方式，也称为<strong>装载时重定位（Load Time Relocation）</strong>。其基本思路是：<strong>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。</strong></p><p>但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。</p><p>然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为<strong>地址无关代码</strong>的技术被提出以克服这个问题。</p><h4 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h4><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p><strong>地址无关代码（PIC，Position-independent Code）</strong> 技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型：</p><ul><li><strong>类型1：模块内部的函数调用。</strong></li><li><strong>类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。</strong></li><li><strong>类型3：模块外部的函数调用。</strong></li><li><strong>类型4：模块外部的数据访问，如其他模块中定义的全局变量。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">extern int b;</span><br><span class="line">extern void ext();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    a = 1;      // 类型2：模块内部数据访问</span><br><span class="line">    b = 2;      // 类型4：模块外部数据访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    bar();      // 类型1：模块内部函数调用</span><br><span class="line">    ext();      // 类型4：模块外部函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="类型1-模块内部函数调用"><a href="#类型1-模块内部函数调用" class="headerlink" title="类型1 模块内部函数调用"></a>类型1 模块内部函数调用</h5><p>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</p><h5 id="类型2-模块内部数据访问"><a href="#类型2-模块内部数据访问" class="headerlink" title="类型2 模块内部数据访问"></a>类型2 模块内部数据访问</h5><p>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p><h5 id="类型3-模块间数据访问"><a href="#类型3-模块间数据访问" class="headerlink" title="类型3 模块间数据访问"></a>类型3 模块间数据访问</h5><p>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个<strong>指向这些变量的指针数组</strong>，也称为<strong>全局偏移表（Global Offset Table，GOT）</strong>，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/inter-module-data-access.png" alt=""></p><p>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以<strong>在模块装载时被修改</strong>，并且每个进程都可以有独立的副本，相互不受影响。</p><h5 id="类型4-模块间函数调用"><a href="#类型4-模块间函数调用" class="headerlink" title="类型4 模块间函数调用"></a>类型4 模块间函数调用</h5><p>对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上文的描述，我们基本理清了链接的过程以及静态链接和动态链接的区别。事实上，链接的具体实现细节是非常复杂，本文只是对其进行了概述，更多细节以及优化实现还是需要我们自己进一步去探索。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Executable and Linkable Format (ELF)</li><li>《Linux 二进制分析》</li><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;http://chuquan.me/2018/05/21/elf-introduce/&quot;&gt;前面&lt;/a&gt;对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="链接" scheme="http://chuquan.me/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(3)——ELF文件结构</title>
    <link href="http://chuquan.me/2018/05/21/elf-introduce/"/>
    <id>http://chuquan.me/2018/05/21/elf-introduce/</id>
    <published>2018-05-21T14:45:18.000Z</published>
    <updated>2018-06-18T05:37:29.592Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://chuquan.me/2018/05/12/compiler-principle/#more">前文</a>结尾说到编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，而目标文件经过编译器链接之后得到的就是<strong>可执行文件</strong>。那么目标文件到底是什么？它和可执行文件又有什么区别？链接到底又做了什么呢？接下来，我们将探索一下目标文件的本质。</p><h1 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h1><p>目前，PC平台流行的 <strong>可执行文件格式（Executable）</strong> 主要包含如下两种，它们都是 <strong>COFF（Common File Format）</strong> 格式的变种。</p><ul><li>Windows下的 <strong>PE（Portable Executable）</strong> </li><li>Linux下的 <strong>ELF（Executable Linkable Format）</strong> </li></ul><p><strong>目标文件就是源代码经过编译后但未进行连接的那些中间文件（Windows的<code>.obj</code>和Linux的<code>.o</code>），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储</strong>。在Windows下采用<strong>PE-COFF</strong>文件格式；Linux下采用<strong>ELF</strong>文件格式。</p><p>事实上，除了<strong>可执行文件</strong>外，<strong>动态链接库（DDL，Dynamic Linking Library）</strong>、<strong>静态链接库（Static Linking Library）</strong> 均采用可执行文件格式存储。它们在Window下均按照PE-COFF格式存储；Linux下均按照ELF格式存储。只是文件名后缀不同而已。</p><ul><li>动态链接库：Windows的<code>.dll</code>、Linux的<code>.so</code></li><li>静态链接库：Windows的<code>.lib</code>、Linux的<code>.a</code></li></ul><p>下面，我们将以ELF文件为例进行介绍。</p><h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-file-format.png" alt=""></p><p><strong>注意：段（<code>Segment</code>）与节（<code>Section</code>）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</strong></p><p>如图所示，为ELF文件的基本结构，其主要由四部分组成：</p><ul><li>ELF Header</li><li>ELF Program Header Table (或称Program Headers、程序头)</li><li>ELF Section Header Table (或称Section Headers、节头表)</li><li>ELF Sections</li></ul><p>从图中，我们就能看出它们各自的数据结构以及相互之间的索引关系。下面我们依次进行介绍。</p><hr><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>我们可以使用readelf工具来查看ELF Header。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h hello.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          672 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure></p><p>ELF文件结构示意图中定义的<code>Elf_Ehdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">e_ident</td><td style="text-align:left">Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Class: ELF32</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Data:  2’s complement, little end</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Version: 1(current)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">OS/ABI: UNIX - System V</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ABI Version: 0</td></tr><tr><td style="text-align:left">e_type</td><td style="text-align:left">Type: REL (Relocatable file)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF文件类型</td></tr><tr><td style="text-align:left">e_machine</td><td style="text-align:left">Machine: Advanced Micro Devices X86-64</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF文件的CPI平台属性</td></tr><tr><td style="text-align:left">e_version</td><td style="text-align:left">Version: 0x1</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF版本号。一般为常数1</td></tr><tr><td style="text-align:left">e_entry</td><td style="text-align:left">Entry point address: 0x0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位指令一般没有入口地址，则该值为0</strong></td></tr><tr><td style="text-align:left">e_phoff</td><td style="text-align:left">Start of program headers: 0(bytes into file)</td></tr><tr><td style="text-align:left">e_shoff</td><td style="text-align:left">Start of section headers: 672 (bytes into file)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header Table 在文件中的偏移</td></tr><tr><td style="text-align:left">e_word</td><td style="text-align:left">Flags: 0x0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF标志位，用来标识一些ELF文件平台相关的属性。</td></tr><tr><td style="text-align:left">e_ehsize</td><td style="text-align:left">Size of this header: 64 (bytes)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF Header本身的大小</td></tr><tr><td style="text-align:left">e_phentsize</td><td style="text-align:left">Size of program headers: 0 (bytes)</td></tr><tr><td style="text-align:left">e_phnum</td><td style="text-align:left">Number of program headers: 0</td></tr><tr><td style="text-align:left">e_shentsize</td><td style="text-align:left">Size of section headers: 64 (bytes)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">单个Section Header大小</td></tr><tr><td style="text-align:left">e_shnum</td><td style="text-align:left">Number of section headers: 13</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header的数量</td></tr><tr><td style="text-align:left">e_shstrndx</td><td style="text-align:left">Section header string table index: 10</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header字符串表在Section Header Table中的索引</td></tr></tbody></table><h3 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h3><p>每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，通常被称为<strong>魔数（Magic Number）</strong>。通过对魔数的判断可以确定文件的格式和类型。如：ELF的可执行文件格式的头4个字节为<code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头4个字节为<code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是<code>#!/bin/sh</code>或<code>#!/usr/bin/perl</code>或<code>#!/usr/bin/python</code>，此时前两个字节<code>#</code>和<code>!</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。</p><h3 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h3><p>ELF文件主要有三种类型，可以通过ELF Header中的<code>e_type</code>成员进行区分。</p><ul><li><strong>可重定位文件（Relocatable File）</strong>：<code>ETL_REL</code>。一般为<code>.o</code>文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。</li><li><strong>可执行文件（Executable File）</strong>：<code>ET_EXEC</code>。可以直接执行的程序。</li><li><strong>共享目标文件（Shared Object File）</strong>：<code>ET_DYN</code>。一般为<code>.so</code>文件。有两种情况可以使用。<ul><li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li><li>动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像。</li></ul></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png" alt=""></p><hr><h2 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h2><p>ELF 节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</strong></p><p>我们可以使用readelf工具来查看节头表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S hello.o</span><br><span class="line"></span><br><span class="line">There are 13 section headers, starting at offset 0x2a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000001f0</span><br><span class="line">       0000000000000030  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  00000055</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  00000062</span><br><span class="line">       0000000000000035  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000097</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000098</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000220</span><br><span class="line">       0000000000000018  0000000000000018   I      11     8     8</span><br><span class="line">  [10] .shstrtab         STRTAB           0000000000000000  00000238</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  000000d0</span><br><span class="line">       0000000000000108  0000000000000018          12     9     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  000001d8</span><br><span class="line">       0000000000000013  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></p><p>ELF文件结构示意图中定义的<code>Elf_Shdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">sh_name</td><td style="text-align:left">节名</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">节名是一个字符串，保存在一个名为<code>.shstrtab</code>的字符串表（可通过Section Header索引到）。sh_name的值实际上是其节名字符串在<code>.shstrtab</code>中的偏移值</td></tr><tr><td style="text-align:left">sh_type</td><td style="text-align:left">节类型</td></tr><tr><td style="text-align:left">sh_flags</td><td style="text-align:left">节标志位</td></tr><tr><td style="text-align:left">sh_addr</td><td style="text-align:left">节地址：节的虚拟地址</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">如果该节可以被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td></tr><tr><td style="text-align:left">sh_offset</td><td style="text-align:left">节偏移</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>如果该节存在于文件中，则表示该节在文件中的偏移；否则无意义，如sh_offset对于BSS 节来说是没有意义的</strong></td></tr><tr><td style="text-align:left">sh_size</td><td style="text-align:left">节大小</td></tr><tr><td style="text-align:left">sh_link、sh_info</td><td style="text-align:left">节链接信息</td></tr><tr><td style="text-align:left">sh_addralign</td><td style="text-align:left">节地址对齐方式</td></tr><tr><td style="text-align:left">sh_entsize</td><td style="text-align:left">节项大小</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">有些节包含了一些固定大小的项，如符号表，其包含的每个符号所在的大小都一样的，对于这种节，sh_entsize表示每个项的大小。<strong>如果为0，则表示该节不包含固定大小的项。</strong></td></tr></tbody></table><h3 id="节类型（sh-type）"><a href="#节类型（sh-type）" class="headerlink" title="节类型（sh_type）"></a>节类型（sh_type）</h3><p>节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）。</p><p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。常见的节类型如下表所示：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHT_NULL</td><td style="text-align:left">0</td><td style="text-align:left">无效节</td></tr><tr><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:left">1</td><td style="text-align:left"><strong>程序节</strong>。代码节、数据节都是这种类型。</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:left">2</td><td style="text-align:left"><strong>符号表</strong></td></tr><tr><td style="text-align:left">SHT_STRTAB</td><td style="text-align:left">3</td><td style="text-align:left"><strong>字符串表</strong></td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:left">4</td><td style="text-align:left"><strong>重定位表</strong>。该节包含了重定位信息。</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">5</td><td style="text-align:left"><strong>符号表的哈希表</strong></td></tr><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">6</td><td style="text-align:left">动态链接信息</td></tr><tr><td style="text-align:left">SHT_NOTE</td><td style="text-align:left">7</td><td style="text-align:left">提示性信息</td></tr><tr><td style="text-align:left">SHT_NOBITS</td><td style="text-align:left">8</td><td style="text-align:left">表示该节在文件中没有内容。如<code>.bss</code>节</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:left">9</td><td style="text-align:left">该节包含了重定位信息</td></tr><tr><td style="text-align:left">SHT_SHLIB</td><td style="text-align:left">10</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">SHT_DNYSYM</td><td style="text-align:left">11</td><td style="text-align:left"><strong>动态链接的符号表</strong></td></tr></tbody></table><h3 id="节标志位（sh-flag）"><a href="#节标志位（sh-flag）" class="headerlink" title="节标志位（sh_flag）"></a>节标志位（sh_flag）</h3><p>节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以<code>SHF_</code>开头。常见的节标志位如下表所示：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHF_WRITE</td><td style="text-align:left">1</td><td style="text-align:left">表示该节在进程空间中可写</td></tr><tr><td style="text-align:left">SHF_ALLOC</td><td style="text-align:left">2</td><td style="text-align:left">表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td></tr><tr><td style="text-align:left">SHF_EXECINSTR</td><td style="text-align:left">4</td><td style="text-align:left">表示该节在进程空间中可以被执行</td></tr></tbody></table><h3 id="节链接信息（sh-link、sh-info）"><a href="#节链接信息（sh-link、sh-info）" class="headerlink" title="节链接信息（sh_link、sh_info）"></a>节链接信息（sh_link、sh_info）</h3><p>如果节的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的节，这两个成员没有意义。</p><table><thead><tr><th style="text-align:left">sh_type</th><th style="text-align:left">sh_link</th><th style="text-align:left">sh_info</th></tr></thead><tbody><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">该节所使用的<strong>字符串表</strong>在节头表中的下标</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">该节所使用的<strong>符号表</strong>在节头表中的下标</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td><td style="text-align:left">该重定位表所作用的节在节头表中的下标</td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td><td style="text-align:left">该重定位表所作用的节在节头表中的下标</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:left">操作系统相关</td><td style="text-align:left">操作系统相关</td></tr><tr><td style="text-align:left">SHT_DYNSYM</td><td style="text-align:left">操作系统相关</td><td style="text-align:left">操作系统相关</td></tr><tr><td style="text-align:left">other</td><td style="text-align:left">SHN_UNDEF</td><td style="text-align:left">0</td></tr></tbody></table><hr><h2 id="ELF-Sections"><a href="#ELF-Sections" class="headerlink" title="ELF Sections"></a>ELF Sections</h2><h3 id="节的分类"><a href="#节的分类" class="headerlink" title="节的分类"></a>节的分类</h3><p>上述ELF Section Header Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。</p><h4 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h4><p><code>.text</code>节是保存了程序代码指令的<strong>代码节</strong>。<strong>一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中</strong>。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h4><p><code>rodata</code>节保存了只读的数据，如一行C语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="plt节（过程链接表）"><a href="#plt节（过程链接表）" class="headerlink" title=".plt节（过程链接表）"></a>.plt节（过程链接表）</h4><p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，<strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码</strong>。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h4><p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h4><p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本省的空间。<strong><code>.bss</code>节保存了未进行初始化的全局数据</strong>。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p><h4 id="got-plt节（全局偏移表-过程链接表）"><a href="#got-plt节（全局偏移表-过程链接表）" class="headerlink" title=".got.plt节（全局偏移表-过程链接表）"></a>.got.plt节（全局偏移表-过程链接表）</h4><p><code>.got</code>节保存了<strong>全局偏移表</strong>。<strong><code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改</strong>。由于<code>.got.plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="dynsym节（动态链接符号表）"><a href="#dynsym节（动态链接符号表）" class="headerlink" title=".dynsym节（动态链接符号表）"></a>.dynsym节（动态链接符号表）</h4><p><code>.dynsym</code>节保存在<code>text</code>段中。<strong>其保存了从共享库导入的动态符号表</strong>。节类型为<code>SHT_DYNSYM</code>。</p><h4 id="dynstr节（动态链接字符串表）"><a href="#dynstr节（动态链接字符串表）" class="headerlink" title=".dynstr节（动态链接字符串表）"></a>.dynstr节（动态链接字符串表）</h4><p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p><h4 id="rel-节（重定位表）"><a href="#rel-节（重定位表）" class="headerlink" title=".rel.*节（重定位表）"></a>.rel.*节（重定位表）</h4><p>重定位表保存了重定位相关的信息，<strong>这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改</strong>。由于重定位表保存了重定位相关的数据，所以节类型为<code>SHT_REL</code>。</p><h4 id="hash节"><a href="#hash节" class="headerlink" title=".hash节"></a>.hash节</h4><p><code>.hash</code>节也称为<code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p><h4 id="symtab节（符号表）"><a href="#symtab节（符号表）" class="headerlink" title=".symtab节（符号表）"></a>.symtab节（符号表）</h4><p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p><h4 id="strtab节（字符串表）"><a href="#strtab节（字符串表）" class="headerlink" title=".strtab节（字符串表）"></a>.strtab节（字符串表）</h4><p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p><h4 id="ctors节和-dtors节"><a href="#ctors节和-dtors节" class="headerlink" title=".ctors节和.dtors节"></a>.ctors节和.dtors节</h4><p><code>.ctors</code>（<strong>构造器</strong>）节和<code>.dtors</code>（<strong>析构器</strong>）节分别保存了指向构造函数和析构函数的函数指针，<strong>构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码</strong>。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p><p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p><p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。<strong><code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号</strong>。如全局变量，代码中定义的本地函数等。</p><p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p><p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p><p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。<strong><code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号</strong>。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-symtab-strtab.png" alt=""></p><p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">st_name</td><td style="text-align:left">符号名。该值为该符号名在字符串表中的偏移地址。</td></tr><tr><td style="text-align:left">st_value</td><td style="text-align:left">符号对应的值。存放符号的值（可能是地址或位置偏移量）。</td></tr><tr><td style="text-align:left">st_size</td><td style="text-align:left">符号的大小。</td></tr><tr><td style="text-align:left">st_other</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">st_shndx</td><td style="text-align:left">符号所在的节</td></tr><tr><td style="text-align:left">st_info</td><td style="text-align:left">符号类型及绑定属性</td></tr></tbody></table><p>使用readelf工具我们也能够看到符号表的相关信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s hello.o</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.symtab&apos; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br></pre></td></tr></table></figure></p><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p><p>ELF文件中所有字符表的结构基本一致，如上图所示。</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p><p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -r hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000005 R_X86_64_32       .rodata</span><br><span class="line">000000000000000a R_X86_64_PC32     puts-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p><p>重定位表是一个<code>Elf_Rel</code>类型的数组结构，每一项对应一个需要进行重定位的项。<br>其成员含义如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">r_offset</td><td style="text-align:left">重定位入口的偏移。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可重定位文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可执行文件或共享对象文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td></tr><tr><td style="text-align:left">r_info</td><td style="text-align:left">重定位入口的类型和符号</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可执行文件和共享目标文件</strong>来说，它们的重定位入口是动态链接类型的。</td></tr></tbody></table><p>重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Executable and Linkable Format (ELF)</li><li>《Linux 二进制分析》</li><li>《程序员的自我修养——链接、装载与库》</li><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li></ol><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://chuquan.me/2018/05/12/compiler-principle/#more&quot;&gt;前文&lt;/a&gt;结尾说到编译器编译源代码后生成的文件叫做&lt;strong&gt;目标文件&lt;/strong&gt;，而目标文件经过编译器链接之后得到的就是&lt;stron
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="ELF文件" scheme="http://chuquan.me/tags/ELF%E6%96%87%E4%BB%B6/"/>
    
      <category term="目标文件" scheme="http://chuquan.me/tags/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    
      <category term="可执行文件" scheme="http://chuquan.me/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(2)——程序构建及编译原理</title>
    <link href="http://chuquan.me/2018/05/12/compiler-principle/"/>
    <id>http://chuquan.me/2018/05/12/compiler-principle/</id>
    <published>2018-05-12T13:28:08.000Z</published>
    <updated>2018-06-04T13:21:27.318Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《程序员的自我修养——链接、装载与库》一书，这本书以前看过一部分，由于难啃，当时没有坚持下去。现在工作了，每天接触的都是业务开发，对底层的一些东西感觉越来越陌生。于是，又把此书翻了出来拜读。为了加深阅读的印象，打算对书中的一些有价值的内容进行整理，也方便后续回顾。</p><h1 id="程序构建流程"><a href="#程序构建流程" class="headerlink" title="程序构建流程"></a>程序构建流程</h1><p>下面以“Hello World”程序为例，来介绍程序的编译与链接过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux下，可以直接使用GCC来编译Hello World程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p><p>GCC编译命令隐藏了构建过程中的一些复杂的步骤，主要有4个步骤，如下图所示。</p><ul><li><strong>预处理（Propressing）</strong></li><li><strong>编译（Compilation）</strong></li><li><strong>汇编（Assembly）</strong></li><li><strong>链接（Linking）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/code-compile-process.png" alt=""></p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译步骤将源代码文件<code>hello.c</code>以及相关头文件，如：<code>stdio.h</code>等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。</p><p>预编译步骤相当于执行如下命令（选项-E表示只进行预编译）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></p><p><strong>预编译</strong>主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下：</p><ul><li>将所有的“#define”删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。</li><li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。</li><li>删除所有的注释“//”和“/<em> </em>/”。</li><li>添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。</li><li>保留所有的#pragma编译器指令，因为编译器须要试用他们。</li></ul><p>预编译生成的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>编译</strong>就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一。</p><p>编译步骤相当于执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></p><p>现在版本的GCC把预编译和编译两个步骤合并成了一个步骤，使用一个叫cc1的程序来完成。该程序位于“<code>/usr/lib/gcc/x86_64-linux-gnu/4.8/</code>”，我们可以直接调用cc1来完成它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c</span><br></pre></td></tr></table></figure></p><p>事实上，对于不同的语言，预编译与编译的程序是不同的，如下所示：</p><ul><li>C：<strong>cc1</strong></li><li>C++：<strong>cc1plus</strong></li><li>Objective-C：<strong>cc1obj</strong></li><li>Fortran：<strong>f771</strong></li><li>Java：<strong>jc1</strong></li></ul><p>GCC是对这些后台程序的封装，它会根据不同的参数来调用预编译程序cc1、汇编器as、链接器ld。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p><strong>汇编</strong>就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。</p><p>汇编步骤相当执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></p><p>GCC本质上是调用汇编器as来完成汇编步骤的，我们可以直接调用as来完成该步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>链接</strong>主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。</p><h1 id="编译器工作原理"><a href="#编译器工作原理" class="headerlink" title="编译器工作原理"></a>编译器工作原理</h1><p>编译过程可以分为6个步骤，如下图所示。</p><ul><li><strong>扫描（Scanning）</strong>（又称词法分析）</li><li><strong>语法分析（Syntax analysis）</strong></li><li><strong>语义分析（Semantic Analysis）</strong></li><li><strong>源代码优化（Source Code Optimization）</strong></li><li><strong>目标代码生成（Target Code Generation）</strong></li><li><strong>目标代码优化（Target Code Optimization）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-detail-process.png" alt=""></p><p>下面我们以一行简单的C语言代码为例，简单描述从<strong>源代码（Source Code）</strong>到<strong>最终目标代码</strong>的过程。代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)</span><br></pre></td></tr></table></figure></p><h2 id="扫描（词法分析）"><a href="#扫描（词法分析）" class="headerlink" title="扫描（词法分析）"></a>扫描（词法分析）</h2><p>首先源代码被输入到<strong>扫描器（Scanner）</strong>，扫描器的任务很简单，只是简单地进行词法分析，运用一种类似于<strong>有限状态机（Finite State Machine）</strong>的算法将源代码的字符序列分割成一系列的<strong>记号（Token）</strong>。</p><p>以上述代码为例，总共包含了28个非空字符，经过扫描后，产生了16个记号。</p><table><thead><tr><th style="text-align:left">记号</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">array</td><td style="text-align:left">标识符</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">左方括号</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">标识符</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">右方括号</td></tr><tr><td style="text-align:left">=</td><td style="text-align:left">赋值</td></tr><tr><td style="text-align:left">(</td><td style="text-align:left">左圆括号</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">标识符</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">数字</td></tr><tr><td style="text-align:left">)</td><td style="text-align:left">右圆括号</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘号</td></tr><tr><td style="text-align:left">(</td><td style="text-align:left">左圆括号</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">数字</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">数字</td></tr><tr><td style="text-align:left">)</td><td style="text-align:left">右圆括号</td></tr></tbody></table><p>词法分析产生的记号一般可以分为一下几类：<strong>关键字</strong>、<strong>字面量</strong>（包含数字、字符串等）和<strong>特殊符号</strong>（如加号、等号）。</p><p>在识别记号的同时，扫描器也完成了其他工作。如：将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p><p>有一个名为lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。正因为有这样一个程序存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p><strong>语法分析器（Grammar Parser）</strong>将对由扫描器产生的记号进行语法分析。从而产生<strong>语法树（Syntax Tree）</strong>。整个分析过程采用了<strong>上下文无关语法（Context-freeGrammar）</strong>的分析手段。简单地讲，由语法分析器生成的语法树是以<strong>表达式（Expression）</strong>为节点的树。</p><p>以上述代码为例，其中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句，下图所示为该语句经过语法分析器后生成的语法树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-syntax-tree.png" alt=""></p><p>在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如：乘法表达式的优先级比加法高，圆括号表达式的优先级比乘法高，等等。另外，有些符号具有多重含义，如“*”在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，因此语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。</p><p>有一个名为yacc（Yet Another Compiler Compiler）的工具可以实现语法分析。其根据用户给定的语法规则对输入的记号序列进行解析，从而构建出语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器编写一个语法分析器。因此，其也称为“编译器编译器（Compiler Compiler）”</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语法分析仅仅完成了对表达式的语法层面的分析，但它并不了解这个语句的真正含义，如：C语言里两个指针做乘法运算是没有意义的，但这个语句在语法上是合法的。编译器所能分析的语义是<strong>静态语义（Static Semantic）</strong>，所谓静态语义是指在编译期间可以确定的语义，与之对应的<strong>动态语义（Dynamic Semantic）</strong>就是只有在运行期才能确定的语义。</p><p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型的转换过程，语义分析过程中需要完成该步骤。比如讲一个浮点赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p><p>经过语义分析阶段之后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。下图所示为标记语义后的语法树。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-commented-syntax-tree.png" alt=""></p><h2 id="源代码优化（中间代码生成）"><a href="#源代码优化（中间代码生成）" class="headerlink" title="源代码优化（中间代码生成）"></a>源代码优化（中间代码生成）</h2><p>现代编译器有着很多层次的优化，<strong>源码优化器（Source Code Optimizer）</strong>则是在源代码级别进行优化。上述例子中，（2 + 6）这个表达式可以被优化掉。因为它的值在编译期就可以被确定。下图所示为优化后的语法树。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-optimized-syntax-tree.png" alt=""></p><p>事实上，直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong>，它是语法树的顺序表示，其实它已经非常接近目标代码了。但它一般与目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等。</p><p>中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：<strong>三地址码（Three-address Code）</strong>、<strong>P-代码（P-Code）</strong>。以三地址码为例，最基本的三地址码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br><span class="line"># 表示将变量y和z进行op操作后，赋值给x。</span><br></pre></td></tr></table></figure></p><p>因此，可以将上述例子的代码翻译成三地址码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = index + 4</span><br><span class="line">t3 = t2 * t1</span><br><span class="line">array[index] = t3</span><br></pre></td></tr></table></figure></p><p>为了使所有的操作符合三地址码形式，这里使用了几个临时变量：t1、t2和t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1 = 6。因此，进一步优化后可以得到如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 = index + 4</span><br><span class="line">t2 = t2 * 8</span><br><span class="line">array[index] = t2</span><br></pre></td></tr></table></figure></p><p>中间代码将编译器分为<strong>前端（Front End）</strong>和<strong>后端（Back End）</strong>。编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码。这样，对于一些可跨平台的编译器，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。比如clange就是一个前端工具，而LLVM则负责后端处理。GCC则是一个套装，包揽了前后端的所有任务。</p><hr><h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>目标代码生成主要由<strong>代码生成器（Code Generator）</strong>完成。代码生成器将中间代码转换成目标机器代码，该过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。</p><p>上述例子的中间代码，经过代码生成器的处理之后可能会生成如下所示的代码序列（以x86汇编为例，假设index的类型为int型，array的类型为int型数组）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl index, %ecx            ; value of index to ecx</span><br><span class="line">addl $4, %ecx               ; ecx = ecx + 4</span><br><span class="line">mull $8, %ecx               ; ecx = ecx * 8</span><br><span class="line">movl index, %eax            ; value of index to eax</span><br><span class="line">movl %ecx, array(,%eax,4)    ; array[index] = ecx</span><br></pre></td></tr></table></figure></p><h2 id="目标代码优化"><a href="#目标代码优化" class="headerlink" title="目标代码优化"></a>目标代码优化</h2><p>目标代码生成后，由<strong>目标代码优化器（Target Code Optimizer）</strong>来进行优化。比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p><p>上述例子中，乘法由一条相对复杂的<strong>基址比例变址寻址（Base Index Scale Addressing）</strong>的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。如下所示为优化后的目标代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(,%edx,8), %eax</span><br><span class="line">movl %eax, array(,%edx,4)</span><br></pre></td></tr></table></figure></p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>经过扫描、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化等一系列步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题：</p><blockquote><p>index和array的地址还没有确定</p></blockquote><p>如果我们把目标代码使用汇编器编译成真正能够在机器上运行的指令，那么index和array的地址来自哪里？<br>如果index和array定义在跟上面的源代码同一个编译单元里，那么编译器可以为index和array分配空间，确定地址；但如果是定义在其他的程序模块呢？</p><p>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由编译器最终将这些目标文件链接起来形成可执行文件。</p><p>后面，我们将继而探讨链接的原理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看《程序员的自我修养——链接、装载与库》一书，这本书以前看过一部分，由于难啃，当时没有坚持下去。现在工作了，每天接触的都是业务开发，对底层的一些东西感觉越来越陌生。于是，又把此书翻了出来拜读。为了加深阅读的印象，打算对书中的一些有价值的内容进行整理，也方便后续回顾。&lt;
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://chuquan.me/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一种简易的客户端存储架构设计</title>
    <link href="http://chuquan.me/2018/04/26/a-design-of-ios-storage-architecture/"/>
    <id>http://chuquan.me/2018/04/26/a-design-of-ios-storage-architecture/</id>
    <published>2018-04-25T16:43:18.000Z</published>
    <updated>2018-06-09T15:03:30.706Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了公司内部某三个APP项目的存储相关代码。总体来说，存储架构基本上是类似的。对此，我绘制了其存储架构的示意图，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/leo-local-storage.png" alt=""></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>项目使用自定义的数据库<code>KVDBStore</code>，该数据库实际上只是对开源数据库<code>FMDatabase</code>进行了封装，其包含如下两个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface KVDBStore()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) FMDatabaseQueue *dbQueue;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *dbPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>KVDBStore</code>存储于应用沙盒的<code>Data Container</code>中的<code>Documents</code>目录下（<a href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis">进一步了解应用沙盒结构</a>）。该目录可以通过如下方法获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];</span><br></pre></td></tr></table></figure></p><p><code>KVDBStore</code>数据库的存储条目具有几个特定的值，使用<code>DBItem</code>对象来表示，其属性包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface DBItem : NSObject</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString * itemId;</span><br><span class="line">@property (strong, nonatomic) id itemObject;</span><br><span class="line">@property (strong, nonatomic) NSDate * createdTime;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><code>KVDBStore</code>主要提供了构造方法、析构方法以及一些基本的操作方法，如：增删查改、Transaction操作等，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (id)initDBWithName:(NSString *)dbName;</span><br><span class="line"></span><br><span class="line">- (id)initWithDBWithPath:(NSString *)dbPath;</span><br><span class="line"></span><br><span class="line">- (BOOL)createTableWithName:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (BOOL)clearTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (void)close;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">///************************ Transaction methods *************************************</span><br><span class="line"></span><br><span class="line">- (BOOL)beginTransaction;</span><br><span class="line"></span><br><span class="line">- (BOOL)rollbackTransaction;</span><br><span class="line"></span><br><span class="line">- (BOOL)commitTransaction;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">///************************ Put&amp;Get methods *****************************************</span><br><span class="line"></span><br><span class="line">- (BOOL)putObject:(id)object withId:(NSString *)objectId intoTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (id)getObjectById:(NSString *)objectId fromTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (BOOL)deleteObjectById:(NSString *)objectId fromTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><code>KVDBStore</code>是在数据库层面实现的一个类，一个数据库通常是由多个表组成的，在实际开发中，表间的联结操作相对比较少，主要还是对特定表进行增删查改的操作。对此，项目实现了表级类<code>BaseTable</code>以便于进行操作，其包含以下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface BaseTable ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *databaseName;</span><br><span class="line">@property (nonatomic, strong) NSString *tableName;</span><br><span class="line">@property (nonatomic, strong) KVDBStore *databaseStore; </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a>存储架构</h1><p>项目只实例化了一个数据库，所有的表均建立在该数据库中，并且所有的表都继承自<code>BaseTable</code>，而这些表则定义了与该表相关的数据库操作。以<code>AccountTable</code>为例，其应该定义类似以下的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getAccount;</span><br><span class="line">- (void)setAccount:(NSString *)account;</span><br><span class="line"></span><br><span class="line">- (UserInfo *)userInfo;</span><br><span class="line">- (void)setUserInfo:(UserInfo *)userInfo;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在实际开发中，我们经常会面临同时从（向）一个表（或多个表）读取（写入）数据。对此，项目中实现了各种代理单例来完成这些操作，如：使用<code>AccountAgent</code>定义登录和退出的方法，其内部需要对<code>AccountTable</code>进行很多复杂的操作，。当然，在涉及到表间联结操作时，也应该通过代理来进行实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// AccountAgent</span><br><span class="line"></span><br><span class="line">- (void)login;</span><br><span class="line">- (void)logout;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后续，希望能够阅读以下<code>FMDatabase</code>的源码，以对iOS底层的存储原理有进一步的理解。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看了公司内部某三个APP项目的存储相关代码。总体来说，存储架构基本上是类似的。对此，我绘制了其存储架构的示意图，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.c
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="存储" scheme="http://chuquan.me/tags/%E5%AD%98%E5%82%A8/"/>
    
      <category term="架构" scheme="http://chuquan.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MVC、MVP、MVVM的演化</title>
    <link href="http://chuquan.me/2018/04/11/mvc-mvp-mvvm/"/>
    <id>http://chuquan.me/2018/04/11/mvc-mvp-mvvm/</id>
    <published>2018-04-10T16:23:49.000Z</published>
    <updated>2018-07-01T12:52:34.396Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="基本MVC模式"><a href="#基本MVC模式" class="headerlink" title="基本MVC模式"></a>基本MVC模式</h2><p>如下图所示为基本的MVC（Model-View-Controller）模式结构图，可分为三部分：模型（Model）、视图（View）、控制器（Controller）。其在MVC模式中所扮演的角色分别为：</p><ol><li>Model：模型管理应用程序的数据，响应有关其状态信息（通常来自View）的请求，并响应指令以更改状态（通常来自Controller）。</li><li>View：视图管理数据的展示。</li><li>Controller：控制器解释用户的输入，并通知模型、视图进行状态更新。</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/basic-MVC.png" alt=""></p><p>其中，View和Controller依赖于Model，而Model并不依赖于View和Controller。这种设计模式的优点在于允许Model不受View的影响，从而能够进行独立的构建和测试。</p><p>此外，根据Model的具体实现还可以进一步分为：<strong>主动型Model</strong>、<strong>被动型Model</strong>。</p><h3 id="被动型Model-MVC模式"><a href="#被动型Model-MVC模式" class="headerlink" title="被动型Model MVC模式"></a>被动型Model MVC模式</h3><p>当只有一个Controller操控着Model时可以采用<strong>被动型Model</strong>。Controller定义Model，并在Model发生改变时通知View，后者再进行更新。在这种场景下，Model完全独立于View和Controller。实际上，被动型Model MVC模式就是基本的MVC模式。</p><h3 id="主动型Model-MVC模式"><a href="#主动型Model-MVC模式" class="headerlink" title="主动型Model MVC模式"></a>主动型Model MVC模式</h3><p>当Model的状态未受Controller干扰的情况下发生变化时，使用<strong>主动型Model</strong>。当其他来源正在更改数据并且必须立刻反应到View中时，可能会发生这种情况。</p><p>为了实现主动型Model，通常使用Observer模式来提供了一种机制来提醒其他对象的状态变化，避免引入依赖关系。各个View实现Observer接口并向Model注册。当Model发生变化时，Model会遍历所有注册的观察者并通知他们相关的变化。这种方法通常被称为“发布 - 订阅”。Model从不需要关于任何View的任何信息。事实上，在Controller需要被告知Model变化的情况下（例如，启用或禁用菜单选项），所有Controller必须通过实现Observer接口并订阅Model的变化。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/active-model-MVC.png" alt=""></p><h2 id="传统版MVC"><a href="#传统版MVC" class="headerlink" title="传统版MVC"></a>传统版MVC</h2><p>上述主动型Model MVC模式通过加入Observer模式进行了改良。事实上，随着业务需求的变化，MVC模式通过不断加入一些更基本的设计模式采演化成现在经典的MVC模式。这些基本模式协同工作，定义了MVC应用程序特有的功能分离和通信路径。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/traditional-MVC.png" alt=""></p><p>上图所示为传统MVC设计模式，其通过Composition、Strategy、Observer等基本设计模式协同工作以实现。用户操作在复合结构的某个层次上操作View，生成一个事件。Controller接收事件，并进行解释。这个过程使用Strategy模式实现，可以是通过消息请求一个Model对象来更新其状态或请求一个View对象来更新其行为或外观。Model对象则在其状态改变时通知所有已注册为观察者的对象。如果观察者是对象，则可以相应更新其外观。</p><h2 id="苹果版MVC"><a href="#苹果版MVC" class="headerlink" title="苹果版MVC"></a>苹果版MVC</h2><p>苹果认为传统的MVC模式中，View通过Observer模式直接观察Model对象以获取相关的通知，而这样的设计会导致View和Model对象不能被广泛复用，因为View与其观察的Model之间存在耦合关系。因此，苹果版MVC与传统MVC基本一致，只是隔离了View和Model。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/apple-MVC.png" alt=""></p><p>在iOS中，UIViewController和UIView是一一对应的。随着业务的深入，MVC最终一点点变成了<strong>Massive-View-Controller</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVC.png" alt=""></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>MVP（Modell-View-Presenter）模式就是为了解决MVC中Controller越来越臃肿的问题，进一步明确代码分工。MVP与苹果版MVC非常相似，但是它们的从属关系有所不同（实线表示持有）。如下图所示，MVP模式中View持有Presenter，Presenter持有Model，View不能直接访问Model；而MVC模式中Controller持有View和Model。</p><p>通过修改从属关系，可以真正意义上实现将UI逻辑和数据逻辑隔离，而隔离之后就可以方便地对数据逻辑部分进行单元测试。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVP.png" alt=""></p><p>在iOS中，MVP的实现一般如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVP.png" alt=""></p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>MVVM（Model View View-Model）就是为了解决MVP中Presenter过于臃肿的问题。MVVM的思想是将Controller中UI控制逻辑与业务逻辑进行分离，并抽离出一个View-Model来完成UI控制的逻辑。而Controller只需要负责业务逻辑即可。如下图便是MVVM的结构图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVVM.png" alt=""></p><p>通常，View-Model可以调用Model定义的方法，从Model中获取数据以用于View，并对数据进行预处理，使View可以直接使用。View又可以向View-Model发出用户的操作命令，从而更改Model。MVVM实现了一种双向绑定机制。</p><p>在iOS中，MVVM的实现一般如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVVM.png" alt=""></p><p>MVVM的优点在于：降低了View和Model之间的耦合；分离了业务逻辑和视图逻辑。缺点在于：View和Model双向绑定导致bug难以定位，两者中的任何一方出现问题，另一方也会出现问题；增加了胶水代码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://msdn.microsoft.com/en-us/library/ff649643.aspx" target="_blank" rel="noopener">Model-View-Controller</a></li><li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html" target="_blank" rel="noopener">Concepts in Objective-C Programming</a></li><li><a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" target="_blank" rel="noopener">The MVVM Pattern</a></li><li><a href="https://www.jianshu.com/p/caaa173071f3" target="_blank" rel="noopener">iOS 关于MVC和MVVM设计模式的那些事</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC, MVP和MVVM</a></li><li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="noopener">被误解的MVC和被神化的MVVM</a></li><li><a href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html" target="_blank" rel="noopener">iOS使用RAC实现MVVM的正经姿势</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。&lt;/p&gt;
&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="设计模式" scheme="http://chuquan.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="MVC" scheme="http://chuquan.me/tags/MVC/"/>
    
      <category term="MVP" scheme="http://chuquan.me/tags/MVP/"/>
    
      <category term="MVVM" scheme="http://chuquan.me/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>基于树的iOS页面路径转换设计</title>
    <link href="http://chuquan.me/2018/04/01/ios-tree-based-path-conversion-design/"/>
    <id>http://chuquan.me/2018/04/01/ios-tree-based-path-conversion-design/</id>
    <published>2018-04-01T06:32:18.000Z</published>
    <updated>2018-06-03T03:06:53.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h1><p>在iOS客户端采集用户操作页面的完整路径，如：”首页” -&gt; “搜题历史页” -&gt; “题目详情页1” -&gt; “名师大招”。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ol><li>易用性</li><li>可靠性</li></ol><h1 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h1><p>考虑到上述两个设计原则，路径转换在每个页面中的使用都不应该受限于其相对于其他页面的位置或关系。简而言之，即具备独立性和通用性。以view controller为例，路径转换在特定的生命周期阶段使用，就是符合设计原则的。</p><p>以下有两种方案：基于栈的设计、基于多叉树的设计。下面依次进行分析。</p><h2 id="基于栈的设计"><a href="#基于栈的设计" class="headerlink" title="基于栈的设计"></a>基于栈的设计</h2><p>下图所示为两个View Controller切换时，各个VC的生命周期的切换顺序，其中A为父VC，B为子VC。为遵循上述设计原则，我们希望能够在特定生命周期进行push/pop操作。合法的push/pop组合应该遵循如下的调用顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A push -&gt; B push -&gt; B pop -&gt; A pop</span><br></pre></td></tr></table></figure></p><p>然而，我们在下图中找不到一个合法的push/pop组合，除了【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种情况。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vcs-switch-lifecycle.png" alt=""></p><p>那么，在【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】是不是真能应对所有场景呢？</p><p>试想如下图所示这样一种场景，当一个VC包含多个VC对象时，其中一个VC再调用子VC。这时候，我们期望得到的路径应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p><p>然而在很多情况下，A会在<code>init</code>/<code>viewDidLoad</code>阶段初始化多有VC对象。这时候如果使用的是【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种组合，在E中得到的路径会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/multi-subview-hierarchy.png" alt=""></p><p>综合上述，使用栈结构很难实现一种易用、可靠的设计方案。</p><h2 id="基于树的设计"><a href="#基于树的设计" class="headerlink" title="基于树的设计"></a>基于树的设计</h2><p>于是，我们使用多叉树实现了一个易用、可靠的路径转换方案。如下左图所示，为一个app经常会面临的vc结构。我们使用多叉树来描述app的vc结构。在任何时候，页面总是能够返回到根页面（tab页），所以树节点不会形成环，即可以使用树结构来进行描述，如右图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/tree-based%20path%20conversion%20design.png" alt=""></p><p>其中，树节点包括四个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface TreeNode : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger parentId;   // 记录创建本节点的父节点ID</span><br><span class="line">@property (nonatomic, assign) NSInteger nodeId;     // 本节点ID</span><br><span class="line">@property (nonatomic, strong) NSString *keyfrom;      // 节点信息</span><br><span class="line">@property (nonatomic, strong, nullable) NSMutableArray&lt;TreeNode *&gt; *subNodes;   // 子节点指针</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>使用单例来保存一个全局的根节点（<code>root</code>）以及一个动态变更的全局父节点ID（<code>parentId</code>）。</p><p>使用的方法是：</p><ol><li>在<code>viewDidLoad</code>阶段，创建节点，将其<code>parentId</code>属性设置为全局父节点ID（<code>parentId</code>）的值，与vc绑定。</li><li>在<code>viewWillAppear/viewDidAppear</code>阶段或者在进入新页面之前，将全局父节点ID（<code>parentId</code>）设置为当前vc节点的<code>nodeId</code>。</li><li>在<code>dealloc</code>阶段，将全局父节点ID（<code>parentId</code>）设置为本节点<code>parentId</code>属性的值，并从树中删除本节点。</li></ol><p>提供的接口如下所示：</p><pre><code>// 创建根节点- (void)createKeyfromRootNode;// 设置全局父节点ID（parentID）- (void)setParentNodeWithNodeId:(NSInteger)nodeId;// 向树中添加子节点（keyfromType，param用于描述节点信息）- (TreeNode *)addKeyfromNodeWithKeyfromType:(KeyfromType)keyfromType                                       param:(nullable NSString *)param;// 从树中删除子节点- (void)removeKeyfromNodeWithNodeId:(NSInteger)nodeId;// 更新指定节点的节点信息- (void)updateKeyfromNodeWithNodeId:(NSInteger)nodeId                        keyfromType:(KeyfromType)keyfromType                              param:(nullable NSString *)param;// 获取从根节点到指定节点的路径- (NSString *)keyfromPathWithNodeId:(NSInteger)nodeId;// 获取从根节点到当前节点的路径- (NSString *)keyfromPath;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实践证明，这种设计方案还能够非常简单地应用到一下这些场景之中。</p><ol><li>view Controller、View混合路径；</li><li>统跳；</li><li>view Controller多处复用、节点信息不同；</li><li>忽略路径中特定节点</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需求场景&quot;&gt;&lt;a href=&quot;#需求场景&quot; class=&quot;headerlink&quot; title=&quot;需求场景&quot;&gt;&lt;/a&gt;需求场景&lt;/h1&gt;&lt;p&gt;在iOS客户端采集用户操作页面的完整路径，如：”首页” -&amp;gt; “搜题历史页” -&amp;gt; “题目详情页1” -&amp;gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="路径转化" scheme="http://chuquan.me/tags/%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8C%96/"/>
    
      <category term="设计" scheme="http://chuquan.me/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《徐彬说投资》笔记</title>
    <link href="http://chuquan.me/2018/02/23/xubing-investment/"/>
    <id>http://chuquan.me/2018/02/23/xubing-investment/</id>
    <published>2018-02-23T14:58:22.000Z</published>
    <updated>2018-02-23T15:01:44.211Z</updated>
    
    <content type="html"><![CDATA[<p>几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记<a href="https://note.youdao.com/share/?id=ce6a0c26ad775e2ac31665738ebfc131&amp;type=note#/" target="_blank" rel="noopener">在这里</a></p><h1 id="如何计算自己有多少钱可以用于理财？"><a href="#如何计算自己有多少钱可以用于理财？" class="headerlink" title="如何计算自己有多少钱可以用于理财？"></a>如何计算自己有多少钱可以用于理财？</h1><p>对于我们普通人来说，每个月能够剩余下来的钱（<strong>自由现金流</strong>）均可以用于理财。自由现金流计算公式如下：</p><blockquote><p><strong>自由现金流 = 收入 - 支出</strong><br><strong>收入</strong> = 劳动收入（工资）<br><strong>支出</strong> = 必需支出（房租、房贷、生活费等） + 可选支出（娱乐费用）  </p></blockquote><p>因此，要想有多余的钱理财，必须保证自由现金流为正。如何保证自由现金流为正？两个方法：</p><ul><li><strong>开源</strong>：增加收入</li><li><strong>节流</strong>：减少支出</li></ul><p>很明显，自己容易控制的便是减少支出，其中<strong>可选支出</strong>可控程度是比较大的。</p><p>生活处处有风险，常见有两种风险可能会导致自由现金流为负：<strong>重大疾病</strong>、<strong>失业</strong>。为应对这两种风险，一般我们的措施是：</p><ul><li><strong>重大疾病</strong>：购买重疾险</li><li><strong>失业</strong>：预存应急资金。假设失业以后6个月后必能找到工作。可以将6个月的总支出定为应急资金。应急资金需要充分利用，应该放在货币基金，风险相对较小。</li></ul><p>一般而言，理财收入不能算入收入，各种奖金也不应该算入收入。通过上述公式便可计算出自己有多少钱可用于理财。</p><h1 id="理财的基本概念"><a href="#理财的基本概念" class="headerlink" title="理财的基本概念"></a>理财的基本概念</h1><p>在理财前，投资者需要了解一下这些概念：</p><ol><li><p>任何理财产品都是具有风险的，而风险的本质便是<strong>波动</strong>。比如：股票价格的涨跌波动。</p></li><li><p><strong>风险与收益成正比</strong>。另外还需要有充分的<strong>时间</strong>进行保障。</p></li><li><p><strong>可投资标的</strong>：哪些资产可以在自己的投资期限内进行投资。</p></li><li><p><strong>风险承受能力</strong>：评估可投资标的在投资期限内的最大投资亏损。很多投资亏损就是由于投资前没有评估好自己的风险承受能力，心态受到市场情绪影响导致的。</p></li></ol><h1 id="股票与债券"><a href="#股票与债券" class="headerlink" title="股票与债券"></a>股票与债券</h1><p>我们都知道股票和债券，那么这两者是什么？有什么区别呢？</p><p>一切要从<strong>价值分配模型</strong>说起，价值分配模型包含两部分，分别是<strong>劳动价值</strong>、<strong>剩余价值</strong>。</p><p>一般来说，一个公司的资本分为两类：<strong>债券</strong>、<strong>股票</strong>。相应的投资人也分为两类：<strong>债券投资人</strong>、<strong>股票投资人</strong>（股东）。公司将其运营产生的<strong>剩余价值</strong>通过债券、股票分配给投资人。</p><blockquote><p>假设公司不用交税，一年挣了3千万（即剩余价值）。假设去年发行了一个亿3年期，每年利息10%的债券。那么公司的3千万，债券投资人拿走1千万（1亿 x 10%）。其他全部分给股票投资人。</p><p>如果一年收益1亿，债券投资人只能拿1千万，而股票投资人则可以拿9千万。</p></blockquote><p>相比而言，债券投资人获取收益的优先级更高，收益比股票投资人更明确。即无论有多少剩余价值，都优先分给债券投资人。在上述例子中，债券的收益是每年10%。而股票的风险比较大，对应的收益也可能更高。</p><p>通常，大企业的优势是收益稳定，劣势是发展空间有限；中小企业的优势是发展潜力，劣势是收益。因此，大企业的债券比较可靠，股票的增值空间相对较小；中小企业的债券短期内不一定有收益，长期来看其股票增值空间相对较大。</p><p>关于股票，公司分配给股票投资者的价值有两种方式：</p><ol><li><strong>发放现金分红</strong></li><li><strong>股票价格上涨</strong>：如果公司在一段时间内的收益越高，希望投资的人越多，股票价格会变得越高。</li></ol><h1 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h1><p>如果投资期限为一年，最好的投资标的是<strong>货币基金</strong>，如余额宝。货币基金是<strong>公募基金</strong>的一种。货币基金有以下优点：</p><ul><li>货币基金的门槛很低，一块钱都可以</li><li>货币基金的各种费用很低</li><li>风险极低</li><li>每天都有收益，包括节假日</li><li>货币基金非常灵活，买入后立刻产生收益。</li><li>货币基金往往在其他投资标的表现不好时，收益会更好。</li></ul><p>货币基金主要有两个指标:</p><ul><li><strong>七日年化收益率</strong>：过去七天平均每天的收益如果持续一年可以产生的收益</li><li><strong>万份收益</strong>：货币基金会保持每份一元的净值水平。因此，货币基金的总资产等于货币基金的总份数。每一万份货币基金，在过去一天产生的收益。</li></ul><p>那么为什么货币基金风险很低？这是因为货币基金的投资标的是<strong>短期国债</strong>、<strong>中央银行票据</strong>、<strong>银行背书的商业汇票</strong>、<strong>银行承兑汇票</strong>、<strong>银行定存</strong>、<strong>大额可转让存单</strong>等。这些都是金融投资风险最低。另一方面，货币基金的管理要求非常高，如果基金经理的货币基金做亏了，基本职业生涯完了。所以，货币基金的风险非常低。</p><p>货币基金适合投资期限小于一年，随取随存的场景，对于应急资金和工资来说非常适合。我们平时所用的余额宝、活期宝便是货币基金。相对其它投资标的，货币基金收益也较低，一年的收益率大概为4%左右。</p><h2 id="货币基金的4个投资技巧"><a href="#货币基金的4个投资技巧" class="headerlink" title="货币基金的4个投资技巧"></a>货币基金的4个投资技巧</h2><ul><li>季度末，半年末，年末，货币基金的收益率比较高。</li><li>关注央行的行为。其会影响金融市场的流动性。央行加息，提高存款准备金率，会造成市场的钱变少，从而提高货币基金的收益率。</li><li>当股市、债市表现不好时候，往往货币基金表现较好（目前市场共有616支货币基金）。</li><li>平时买规模大（5亿元以上）的基金，收益比较稳定。在季度末、年底买规模较小（2亿~5亿）的基金博取高收益。</li></ul><h1 id="银行理财与货币基金"><a href="#银行理财与货币基金" class="headerlink" title="银行理财与货币基金"></a>银行理财与货币基金</h1><p>根据如下2017年的数据显示，理财产品的期限越长，予以的收益也越多。</p><ul><li>银行活期存款利息：一年0.35%</li><li>一年期定期存款：一年1.5%</li><li>三年期定期存款：每年2.75%</li></ul><p>通常，银行理财都是定期，且5万元起购，这与货币基金的差距较大。另一方面，货币基金的监管比银行理财更严格。网上也经常爆出银行理财的一些骗局，我们可以通过网上银行来进行真伪辨认。</p><h1 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h1><p>国债逆回购，本质就是一种短期贷款。也就是说，个人通过国债回购市场把自己的资金借出去，获得固定的利息收益；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p><p>投资者通过股票账户即可投资国债逆回购，国债逆回购具有以下几个基本特点：</p><ul><li><strong>国债逆回购的门槛</strong>：上证交易所，金额必须是10万的整数倍；深证交易所，金额必须是1000的整数倍。</li><li><strong>国债逆回购的价格</strong>：任何股票软件都可查询。</li><li><strong>国债逆回购的收益</strong>：价格、实际占款天数（1、2、3、7）。</li><li><strong>国债逆回购价格的规律</strong>：季度末、年末的利率较高。一般上午高于下午。</li></ul><h1 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h1><p>根据2006至2016的数据显示，债券基金平均每年的收益大约为7%。债券的本质是发行债券的机构向投资者借钱，债券基金的收益主要包含两部分：</p><ul><li>利息</li><li>债券的价格波动</li></ul><p>目前市场中的债券基金一共有1000多只。通常而言，债券基金和股票基金呈跷跷板效应，两者的表现是相反的。</p><p><strong>通常不建议自选债券基金进行投资</strong>，其知识门槛较高。此外，债券基金进行为期1~2年的投资。长期投资债券基金必然是赚钱的。</p><h2 id="债券涨跌原理"><a href="#债券涨跌原理" class="headerlink" title="债券涨跌原理"></a>债券涨跌原理</h2><p>在金融体系中钱多（收紧或加速流动性）的时候，债券就会上涨；反之，则下跌。</p><p>金融体系受两方面影响：</p><ul><li><strong>中央银行（中国人民银行，简称央行）货币政策</strong>：如加息降息</li><li><strong>影响金融机构买债的监管政策</strong></li></ul><p>央行主要有两个职能：控制物价（通货膨胀CPI）、维持经济增长（GDP增长率）。如果发生矛盾，以第一项为准。当CPI突破3%，表示通货膨胀过快，需要注意；GDP增长率较低时是投资债券的好时机。</p><h2 id="债券基金投资方法"><a href="#债券基金投资方法" class="headerlink" title="债券基金投资方法"></a>债券基金投资方法</h2><p>债券基金有一个指标——<strong>到期收益率</strong>，表示如果债券没有出现违约，每年的收益率。债券收益率越高，则债券的估值越低。如果在三年期AA+企业债到期收益率超过5%时，投资债券基金，则未来三年，每年收益率大约为8%~10%。</p><p>相关数据表明，长期投资债券基金，亏钱的概率极低。对于债券基金的投资有两个建议：</p><ul><li>债券基金的到期收益率越高，投资债券基金赚得越多</li><li>债券基金应该越跌越买</li></ul><h1 id="什么决定了股票的价格"><a href="#什么决定了股票的价格" class="headerlink" title="什么决定了股票的价格"></a>什么决定了股票的价格</h1><p>前面说到股票投资者的收益主要有两部分：<strong>分红</strong>、 <strong>股票价格的变化</strong>。那么股票的价格是由什么决定的呢？股票的价格可以通过如下公式进行计算：</p><blockquote><p><strong>股票的价格</strong> = <strong>盈利</strong>（每股的盈利） <em>  <em>*市盈率</em></em>（每股市价与每股盈利的比率）</p></blockquote><p>比如，某公司一年盈利1000万元，该公司有一亿股股票，则平均每股的盈利为0.1元。如果市盈率是10倍，即每1元的盈利能力是10元。通过公式计算得出，股票的价格为1元。</p><blockquote><p>1元（股票价格） = 0.1（每股的盈利）* 10（市盈率）</p></blockquote><p>因此，市盈率是衡量股票价格高低的重要指标。<strong>市盈率是由股票市场中所有的股票投资者决定的</strong>。在绝大多数情况下，投资者的情绪比较稳定，市盈率也比较稳定。在某些情况下，投资者的情绪会出现集体波动，在投资者投资情绪乐观时，市盈率偏高；投资情绪悲观时，市盈率偏低。</p><h2 id="如何投资股票"><a href="#如何投资股票" class="headerlink" title="如何投资股票"></a>如何投资股票</h2><p>首先需要评估市场的情绪，乐观、平稳还是悲观？因为投资者的情绪决定了市盈率。有两种评估方法：</p><ul><li><strong>定量分析</strong>：分析历史数据进行总结，对于沪深300指数，市盈率为12-14倍是合理的；对于中证500指数，市盈率为30-35倍是合理的。高于则是乐观，低于则是悲观。</li><li><strong>定性分析</strong>：观察财经媒体和大众市场的情绪。情绪乐观时会多买入，情绪悲观时会多卖出。比如：当很多不懂市场的投资者也在争相买入，则是非常乐观。</li></ul><p>在了解市场情绪之后，只需要做到三点：</p><ul><li>在市场情绪平稳时进行投资，但是不要把所有的前都投进去</li><li>在市场情绪悲观时，不仅自己不能恐慌，而应该鼓起勇气追加投资</li><li>在市场情绪乐观时，不应该追加投资，应该准备卖出</li></ul><h2 id="股票选择"><a href="#股票选择" class="headerlink" title="股票选择"></a>股票选择</h2><p>一般而言，优质、稳定的投资标的应该会产生持续、稳定的<strong>内生收益</strong>。公司的盈利、收益是内生收益的来源。股票投资最重要的收益来源就是内生收益。持续、稳定的内生收益会让投资标的有不断上涨的动力。但是在单只股票中寻找能够产生持续、稳定内生收益的股票非常难。</p><p>投资者可以通过市场表现来挑选股票，比如每半年对A股上市公司进行市值排名，只投资排名前300的公司。A股市场最常用的两个指数是：<strong>沪深300指数</strong>、<strong>中证500指数</strong>。前者包含A股中市值最大的前300家公司；后者包含市值排名第301至800的500家公司。一般排名靠前的大公司，内生收益比较低，稳定性较高，长期收益低。 相对而言，中证500指数包含的公司内生收益相对较高，稳定性一般。</p><h2 id="50AH优选"><a href="#50AH优选" class="headerlink" title="50AH优选"></a>50AH优选</h2><p><strong>上证50指数</strong>：表示上海证券交易所上市的市值最大的50家公司。<br><strong>50AH优选指数</strong>：看上证50指数中哪些公司在大陆和香港同时上市，挑选价格便宜的进行投资。</p><p>根据2015至2017年数据显示，50AH优选指数跑赢了上证50指数8个百分数。因此，投资者也可以根据50AH优选指数来进行股票选择</p><h1 id="基金的选择"><a href="#基金的选择" class="headerlink" title="基金的选择"></a>基金的选择</h1><p>目前市场中共有3485只基金，其从投资标的上来分可分为三种：</p><ul><li><strong>货币基金</strong></li><li><strong>债券基金</strong></li><li><strong>股票基金</strong>：变数最大，主要是对比业绩基准。</li></ul><p>根据管理方式来分类，基金可以分为两类：</p><ul><li><strong>被动管理型基金</strong>（指数基金）：其跟随沪深300指数。管理费较低，每年0.7%。 </li><li><strong>主动管理型基金</strong>：想尽一切办法打败业绩基准。研究员使用数据模型定量分析，管理费相对较高，每年1.5%。</li></ul><p>国外一个惊人的理论：绝大多数主动管理型基金很难跑过大盘指数。然而，在中国则截然相反，这是因为美国绝大部分的投资者是投资机构。中国股市有大量的散户，投资机构很容易跑赢散户。在中国，主动型管理基金更好。港股和美股则相反。在中国，股票基金平均收益率约为20%，沪深300每年约为10%。</p><h1 id="如何选择基金"><a href="#如何选择基金" class="headerlink" title="如何选择基金"></a>如何选择基金</h1><p>股票基金的收益有两个来源：</p><ul><li>对标的股票指数的股票收益</li><li>股票基金跑赢股票指数的跑赢收益，即<strong>跑赢收益</strong>。跑赢收益是真正衡量基金经理能力的指标。</li></ul><p>选择基金的完整流程：</p><ul><li>第一步，选择未来会上涨的股票指数。只要股票指数的市盈率处于合理或偏低的水平，都可以选择。</li><li>第二步，在所有以这个股票指数为业绩基准，即对标的股票指数的股票基金里，选择跑赢收益比较高，且稳定性比较好的股票基金。量化基金的跑赢收益更低，稳定性更好。传统基金的跑赢收益更好，稳定性更差。</li><li>第三步，研究基金的策略，判断基金收益是否可持续。比如：通过基金经理访谈。</li></ul><h1 id="股票基金收益来源的“终极”公式"><a href="#股票基金收益来源的“终极”公式" class="headerlink" title="股票基金收益来源的“终极”公式"></a>股票基金收益来源的“终极”公式</h1><blockquote><p><strong>股票基金的收益</strong> = <strong>对标股票指数的收益</strong> + <strong>跑赢收益</strong></p></blockquote><p><strong>股票指数</strong>是由若干股票组成，可以用于分析股票。每只股票都是一个公司的代表，绝大部分长期来说，其价值在不断提升。通常使用<strong>内生收益</strong>表示股票价值提升带来的收益。但是有内生收益不一定会带来投资收益。</p><p>股票价格的终极计算公式为，其中内生收益代表盈利的上升速度，长期来说内生收益都是正的。</p><blockquote><p><strong>股票价格</strong> = <strong>盈利</strong> <em> <em>*市盈率</em></em> </p></blockquote><p>那么应该如何确定内生收益？沪深300指数的内生收益和名义GDP增速差不多，稍微高一点。名义GDP和统计局公布的GDP不是一回事，后者是实际GDP增速，前者在实际GDP增速的基础上加上物价增速（即CPI）。名义GDP更多的体现实际的经济发展，更适合描述企业收入和盈利的增长速度。中国的GDP大概维持在6-7%，CPI大概在2%，所以名义GDP大概维持在8-9%。因此，沪深300指数的内生收益大约8-9%（非客观）。</p><p>另一方面，市盈率会围绕着合理水平波动。投资者给出的价格水平，乐观时比较高，悲观时比较低。当市盈率回归到合理水平的过程中，产生的收益叫<strong>储备收益</strong>。因此，可以得到股票指数的收益的公式。</p><blockquote><p><strong>股票指数的收益</strong> = <strong>内生收益</strong> + <strong>储备收益</strong></p></blockquote><p>进一步得出股票基金的收益公式：</p><blockquote><p><strong>股票基金的收益</strong> = <strong>内生收益</strong>（经济发展） + <strong>储备收益</strong>（投资者心理波动） + 跑赢收益（基金经理的能力）</p></blockquote><h1 id="定投"><a href="#定投" class="headerlink" title="定投"></a>定投</h1><p>定投：表示定期、定额地投资某一个理财产品的投资方式。这是一种兼顾省心、高收益的投资方式。其适用于长期投资。例如：每个月买1000元的公募基金。</p><p>定投为何会赚钱？这是定投可以大幅降低投资风险，只要坚持就能赚钱。定投期间如果基金曲线呈现微笑曲线，则必然是赚钱的，即<strong>定投第一定理</strong>。</p><p>定投是一种守株待兔的方式，经济是由周期的，只要耐心定投，就肯定能赚钱。</p><h2 id="定投开始时机"><a href="#定投开始时机" class="headerlink" title="定投开始时机"></a>定投开始时机</h2><p>在低于市盈率合理值时投资。在沪深300市盈率14倍或中证500市盈率35倍以下可以投。</p><h2 id="定投结束时机"><a href="#定投结束时机" class="headerlink" title="定投结束时机"></a>定投结束时机</h2><p>3个原则：</p><ul><li>定投还没开始赚钱，永远不要考虑结束</li><li>只要股市估值还没有达到正常水平以上，就不要考虑退出。</li><li>当股市估值回到正常水平以上，应该跟随市场不断变化、计划卖出的点位，即止盈点。比如，当这轮行情市盈率跌倒最高点10%以下，止盈。</li></ul><h2 id="一个真实的定投案例"><a href="#一个真实的定投案例" class="headerlink" title="一个真实的定投案例"></a>一个真实的定投案例</h2><p>3-5年长期的准备，定投。<br>2011年开始，定投沪深300指数4年，总收益80%，平均每年收益15.2%。 分为七个阶段</p><ul><li>2011年4月开始定投到A点，截止2011年12月27日累计亏损19%。从2011年4月开始，中国经济增长率从每年10%下调至8%。同时CPI很高，在2011年年终，达到了6%以上。央行通过加息来降低CPI。沪深300指数从2011年4月的3400点一路跌到年底的2300点，跌幅达到32%。</li><li>A点到B点，截止2012年5月累计盈利0.1%。从2011年底到2012年5月，沪深300指数从2300点反弹到2700点，赚0.1%。</li><li>B点到C点，截止2012年12月累计亏损17.5%。从2012年5月到2012年12月，沪深300指数开启长达8个月的下跌。从2700点跌至2100点，跌幅达到22%。创出了3年新低。</li><li>C点到D点，两年累计盈利8.7%。2012年12月5日的大涨，开启了一波小牛市。沪深300指数用了两个月一口气从2100点涨到了2800点附近，涨幅达到33%。</li><li>D点到E点，累计亏8.5%。2013年2月之后，沪深300指数开始调整，2013年6月开始从2600到2300，跌幅达到22%。2014年7月底，市盈率只有8.2倍，储备收益高达70%。</li><li>F点到完美结局，累计大赚80%。2014年7月到2015年6月，沪深300指数从2200点一路上涨到5380点，上涨幅度达到145%。</li></ul><p>定投总共4年2个月中，有3年3个月是处于亏损状态。是否掌握一定的定投知识将决定成败。经济每五年一个周期，对应到股市就是每5年一个大牛市。定投就是抓住这5年一次的牛市。定投很有可能三年不开张，开张顶三年！</p><h1 id="如何做投资决策"><a href="#如何做投资决策" class="headerlink" title="如何做投资决策"></a>如何做投资决策</h1><p>做投资决策前需要做到以下几点：</p><ul><li>分析一笔钱可能出现的结果有哪几类？</li><li>对每一种结果评估概率</li><li>对每一种结果给出一种应对措施<ul><li>如果赚钱了是否止盈，什么时候止盈</li><li>如果亏钱了是否止损，什么时候止损</li><li>如果赚钱了是否追加投资，什么时候</li><li>如果亏钱了是否追加投资，什么时候</li></ul></li></ul><p>在投资前思考风险可以让我们在投资过程中保持良好的心态。另外，还需要评估好投资周期、盈亏幅度。</p><p>关于如何控制风险？这里也有两种参考方式：</p><ul><li>选择一条移动平均线，一旦大盘跌破这条线就止损。根据历史数据显示，60天移动平均线是最优化的选择。</li><li>设定一个自己愿意接受的亏损比例，如10%。每天记录总资产额。当某天的总资产额比最高总资产额低10%时，可以止损了。</li></ul><h1 id="关于投资笔记"><a href="#关于投资笔记" class="headerlink" title="关于投资笔记"></a>关于投资笔记</h1><p>投资笔记是执行投资、学习投资过程中一个非常重要且有意义的方式。投资笔记有以下优点：</p><ul><li>投资笔记可以帮我们指定投资决策，包括分析过程，思考逻辑，决策分析。投资是不能随机应变的。这是因为，一方面，投资相对比较复杂，需要实现做好预案。另一方面，投资是逆直觉，逆决策的。</li><li>投资笔记可以更好地帮助我们复盘。比如在投资过程中哪些地方做对了，结果及其原因又是什么。通过投资笔记，可以对每一个节点的行为逻辑和心态，复盘结果，更重要的是原因。</li><li>投资笔记可以帮助我们获得更多的知识。</li></ul><h1 id="投资时需要掌握的重要数据"><a href="#投资时需要掌握的重要数据" class="headerlink" title="投资时需要掌握的重要数据"></a>投资时需要掌握的重要数据</h1><p>投资标的一定是不停生长出价值的投资标的。</p><ul><li><strong>经济增长率</strong>：经济增长率分为两种：<strong>季度增长率</strong>、<strong>年度增长率</strong>。GDP同比前一年同期增长多少。绝对值。增长率。实现国家经济调控的部门是央行，其主要有两个职责：<strong>控制物价</strong>、<strong>促进经济增长</strong>。当两者冲突时，往往以第一个为主。物价增长率（CPI），中文学名：通货膨胀率。和GDP不同，CPI是每个月都公布的。<strong>如何解读CPI数据：在中国如果CPI达到3%以上，说明物价增长过快了。这时候央行会通过加息，提高存款准备金率等方法来收紧货币。如果CPI跌倒了1%以下，说明物价增长过慢，意味着经济比较低迷，这时候央行会通过降息、降低存款金率等手段来刺激经济。如果CPI处于1~3%为健康状态，央行一般不会进行干涉</strong>。<strong>GDP在6.5%是合适的；CPI在1-3%是合适的。经济增长率的数据由国家统计局公布，www.stats.gov.cn</strong>。GDP和CPI能够勾勒出四个不同的经济周期，见下文。</li></ul><p>股票、债券方面的数据。</p><p>关于股票，A股共有3000多支股票，关注股票指数就够了，包括：<strong>上证50</strong>（超大规模）、<strong>沪深300</strong>（大规模）、<strong>中证500</strong>（中小规模）。平时需要关注着三个指数的盈利增长率和估值水平</p><ul><li><strong>估值水平</strong>：对于估值水平的描述一般用市盈率这个指标，<strong>对于上证50（10-12倍是合理的），对于沪深300（12-15倍是合理的），对于中证500（30-35倍是合理的）</strong>。如果低于，越跌越买；如果处理合理区间，继续持有；如果高于，原则上是不能追加，应该持有+设置好止盈条件等策略。</li><li><strong>盈利增长率</strong>：必须等每个季度上司公司的财报都公布了以后才知道。与GDP类似，盈利增长的趋势比绝对值更加重要。如果盈利增长在减速，股市的增长水平（市盈率水平）就会下降。如果盈利增长在加速，市盈率就会上升。由于关注的是指数的盈利增长，而这些指数包含的公司都是整个经济体系中的中流砥柱，因此可以用GDP的增长趋势来估计指数盈利增长的趋势。</li></ul><blockquote><p>估值水平：每周六公众号公布；盈利增长率：可以用GDP估算。</p></blockquote><p>债券</p><ul><li><strong>到期收益率</strong>：如果持有债券到期，并且借钱的机构没有耍赖不还钱的情况，投资者平均每年能赚百分之多少。不同期限，不同评级的债券的到期收益率都不一样。一般来说，关注三年期，AA+的企业债券的到期收益率就够了。只要这个数据高于5%，投资债券基金都是比较安全的，未来1-2年的收益也是比较可观的。</li></ul><h1 id="美林团队判断经济周期转折点的重点理论"><a href="#美林团队判断经济周期转折点的重点理论" class="headerlink" title="美林团队判断经济周期转折点的重点理论"></a>美林团队判断经济周期转折点的重点理论</h1><p><strong>美林时钟理论</strong>：只用经济增长率（GDP增速）和通货膨胀率（CPI增速）两个宏观经济指标来描述复杂的经济周期。</p><p>运用美林时钟理论，在2006年至2016年，通过资产配置获得11.5倍的收益。全国房价平均每年的年化收益率只有8%。北京的房价平均每年的年化收益率15%。之所以房子赚钱，是因为房价稳定，愿意长期持，复利使得房子显得很赚钱。数据显示，资产配置如果做好了，可以比投资房产更赚钱。</p><p>美林时钟理论用到两个宏观经济指标：<strong>GDP增长率</strong>（描述经济增长速度），<strong>CPI增长率</strong>（描述通货膨胀速度）</p><ul><li><strong>GDP增长率高、CPI增长率低：复苏期</strong></li><li><strong>GDP增长率高、CPI增长率高：过热期</strong></li><li><strong>GDP增长率低、CPI增长率高：滞障期</strong></li><li><strong>GDP增长率低、CPI增长率低：衰退期</strong></li></ul><p><strong>1 -&gt; 2 -&gt; 3 -&gt; 4：美林时钟</strong></p><blockquote><p>复苏期：重仓股票基金（下一周期GDP仍高）。债券的表现不会差（一时半会不会加息，持有债券去赚利息），应该紧盯通胀，高通货膨胀来了应该减仓。</p><p>过热期：中国股市会快速、甚至疯狂上涨。股票继续持有。不应该持有债券基金。关注熊市出现。</p><p>滞涨期：股票基金表现不会，不应该持有。债券不太好。这个时期的目标是不亏钱。应该投资货币基金。</p><p>衰退期：其末期是特别好的抄底机会。重仓持有债券基金。密切关注股票基金。关注股票基金减仓机会。</p></blockquote><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记&lt;a href=&quot;https://no
      
    
    </summary>
    
      <category term="投资理财" scheme="http://chuquan.me/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="投资" scheme="http://chuquan.me/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="理财" scheme="http://chuquan.me/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Logos基础语法</title>
    <link href="http://chuquan.me/2018/02/22/logos-syntax/"/>
    <id>http://chuquan.me/2018/02/22/logos-syntax/</id>
    <published>2018-02-22T05:48:39.000Z</published>
    <updated>2018-02-22T06:54:56.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hook"><a href="#hook" class="headerlink" title="%hook"></a><code>%hook</code></h1><blockquote><p>该指令指定需要hook的class，必须以<code>%end</code>结尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down &#123;</span><br><span class="line">    NSLog(@&quot;Home Button Pressed&quot;);</span><br><span class="line">    %orig;     // call the original _menuButtonDown:</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="log"><a href="#log" class="headerlink" title="%log"></a><code>%log</code></h1><blockquote><p>该指令在%hook内部使用，将函数的类名、参数等信息写入syslog，可以以<code>%log([(&lt;type&gt;)&lt;expr&gt;, ...])</code>的格式追加其他打印信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">- (void)_menuButtonDown:(id)down &#123;</span><br><span class="line">    %log((NSString *)@&quot;iOSRE&quot;, (NSString *)@&quot;Debug&quot;);</span><br><span class="line">    %orig;      // call the original _menuButtonDown:</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="orig"><a href="#orig" class="headerlink" title="%orig"></a><code>%orig</code></h1><blockquote><p>该指令在<code>%hook</code>内部使用，执行被hook的函数的原始代码。此外，还可以利用<code>%orig</code>更改原始函数的参数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%hook SBLockScreenDateViewController</span><br><span class="line">- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2 &#123;</span><br><span class="line">    %orig(@&quot;iOS 8 App Reverse Engineering&quot;, arg2);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="group"><a href="#group" class="headerlink" title="%group"></a><code>%group</code></h1><blockquote><p>该指令用户将<code>%hook</code>分组，便于代码管理及按条件初始化分组，必须以<code>%end</code>结尾。一个<code>%group</code>可以包含多个<code>%hook</code>，所有不属于某个自定义group的<code>%hook</code>都会被隐式归类到<code>%group_ungrouped</code>中。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%group iOS7Hook </span><br><span class="line">%hook iOS7Class </span><br><span class="line">- (id)iOS7Method &#123;</span><br><span class="line">    id result = %orig;</span><br><span class="line">    NSLog(@&quot;This class &amp; method only exist in iOS 7.&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS7Hook </span><br><span class="line"></span><br><span class="line">%group iOS8Hook </span><br><span class="line">%hook iOS8Class </span><br><span class="line">- (id)iOS8Method &#123;</span><br><span class="line">    id result = %orig;</span><br><span class="line">    NSLog(@&quot;This class &amp; method only exist in iOS 8.&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line">%end // iOS8Hook </span><br><span class="line"></span><br><span class="line">%hook SpringBoard </span><br><span class="line">-(void)powerDown &#123;</span><br><span class="line">    %orig; </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="init"><a href="#init" class="headerlink" title="%init"></a><code>%init</code></h1><blockquote><p>该指令用于初始化某个<code>%group</code>，必须在<code>%hook</code>或<code>%ctor</code>内调用；如果带参数，则初始化指定的group；如果不带参数，则初始化_ungroupded。<strong>只有调用了<code>%init</code>，对应的<code>%group</code>才能起作用</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 </span><br><span class="line">#endif</span><br><span class="line">%hook SpringBoard</span><br><span class="line">- (void)applicationDidFinishLaunching:(id)application &#123;</span><br><span class="line">    %orig;</span><br><span class="line">    %init; // Equals to %init(_ungrouped) </span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp;</span><br><span class="line">        kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS7Hook);</span><br><span class="line">        </span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS8Hook); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="ctor"><a href="#ctor" class="headerlink" title="%ctor"></a><code>%ctor</code></h1><blockquote><p>tweak的constructor，完成初始化工作；如果不显示定义，Theos会自动生成一个<code>%ctor</code>，并在其中调用<code>%init(_ungrouped)</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard </span><br><span class="line">- (void)reboot &#123;</span><br><span class="line">    NSLog(@&quot;If rebooting doesn&apos;t work then I&apos;m screwed.&quot;);</span><br><span class="line">    %orig; </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><p>上述实例可以成功生效，是因为Theos隐式定义了如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%ctor </span><br><span class="line">&#123;</span><br><span class="line">    %init(_ungrouped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>%ctor</code>一般可以用来初始化<code>%group</code>，以及进行<code>MSHookFunction</code>等操作。<code>%ctor</code>不需要以<code>%end</code>结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#ifndef kCFCoreFoundationVersionNumber_iOS_8_0</span><br><span class="line">#define kCFCoreFoundationVersionNumber_iOS_8_0 1140.10 </span><br><span class="line">#endif</span><br><span class="line">%ctor</span><br><span class="line">&#123;</span><br><span class="line">    %init;</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0 &amp;&amp; </span><br><span class="line">        kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS7Hook);</span><br><span class="line">    if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_8_0) </span><br><span class="line">        %init(iOS8Hook); </span><br><span class="line">    </span><br><span class="line">    MSHookFunction((void *)&amp;AudioServicesPlaySystemSound, </span><br><span class="line">                   (void *)&amp;replaced_AudioServicesPlaySystemSound, </span><br><span class="line">                   (void **)&amp;original_AudioServicesPlaySystemSound); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="new"><a href="#new" class="headerlink" title="%new"></a><code>%new</code></h1><blockquote><p>在<code>%hook</code>内部使用，给一个现有class添加一个新函数，功能与<code>class_addMethod</code>相同。<strong>注意，Objective-C的Category语法也可以给现有的class添加新函数。但区别在于category是静态的，<code>class_addMethod</code>是动态的</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%hook SpringBoard</span><br><span class="line">%new</span><br><span class="line">- (void)namespaceNewMethod &#123;</span><br><span class="line">    NSLog(@&quot;We&apos;ve added a new method to SpringBoard.&quot;); </span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure><h1 id="c"><a href="#c" class="headerlink" title="%c"></a><code>%c</code></h1><p>该指令的作用等同于<code>objc_getClass</code>或<code>NSClassFromString</code>，即动态获取一个类的定义，在<code>%hook</code>或<code>%ctor</code>内使用。</p><p>(完)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《iOS应用逆向工程（第2版）》</li><li><a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="noopener">Logos</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hook&quot;&gt;&lt;a href=&quot;#hook&quot; class=&quot;headerlink&quot; title=&quot;%hook&quot;&gt;&lt;/a&gt;&lt;code&gt;%hook&lt;/code&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该指令指定需要hook的class，必须以&lt;code&gt;%end&lt;/c
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Logos语法" scheme="http://chuquan.me/tags/Logos%E8%AF%AD%E6%B3%95/"/>
    
      <category term="Theos" scheme="http://chuquan.me/tags/Theos/"/>
    
  </entry>
  
  <entry>
    <title>iOS逆向工程——基础篇</title>
    <link href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/"/>
    <id>http://chuquan.me/2018/02/06/ios-reverse-engineering-basis/</id>
    <published>2018-02-06T14:03:03.000Z</published>
    <updated>2018-05-25T16:45:28.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS文件系统"><a href="#iOS文件系统" class="headerlink" title="iOS文件系统"></a>iOS文件系统</h1><p>iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有一套标准的文件系统——<a href="https://wylmer.gitbooks.io/filesystem-hierarchy-standard/content/" target="_blank" rel="noopener">Filesystem Hierarchy Standard（FHS）</a>，其常用目录结构如下所示：</p><ul><li><code>/</code>：根目录</li><li><code>/bin</code>：binary，存放用户级基础功能的二进制文件，如<code>ls</code>、<code>ps</code>等</li><li><code>/boot</code>：存放能使系统成功启动的所有文件。<strong>iOS中此目录为空</strong></li><li><code>/dev</code>：device，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备。块设备以块为单位传输数据，如硬盘；字符设备以字符为单位传输数据，如调制解调器</li><li><code>/sbin</code>：system binaries，存放提供系统级基础功的二进制文件，如<code>netstat</code>、<code>reboot</code>等</li><li><code>/etc</code>：法语Et Cetera（and so on的意思），存放系统脚本及配置文件，如<code>passwd</code>、<code>hosts</code>。iOS中，<code>/etc</code>是一个符号链接，实际指向<code>/private/etc</code></li><li><code>/lib</code>：存放系统库文件、内核模块及设备驱动等。<strong>iOS中此目录为空</strong></li><li><code>/mnt</code>：mount，存放临时的文件系统挂载点。<strong>iOS中此目录为空</strong></li><li><code>/private</code>：存放两个目录，分别是<code>/private/etc</code>和<code>/private/var</code></li><li><code>/tmp</code>：临时目录。iOS中，<code>/tmp</code>是一个符号链接，实际指向<code>/private/var/tmp</code></li><li><code>/usr</code>：包含大多数用户和程序。<ul><li><code>/usr/bin</code>：包含那些<code>/bin</code>和<code>/sbin</code>中未出现的基础功能，如<code>nm</code>、<code>killall</code>等</li><li><code>/usr/include</code>：包含所有的标准C头文件</li><li><code>/usr/lib</code>：存放库文件</li></ul></li><li><code>/var</code>：variable，存放一些经常更改的文件，如日志、用户数据、临时文件等。<ul><li><code>/var/mobile</code>：存放了mobile用户的文件。<strong>逆向工程重点关注目录</strong></li><li><code>/var/root</code>：存放了root用户的文件</li></ul></li></ul><h2 id="iOS独有目录"><a href="#iOS独有目录" class="headerlink" title="iOS独有目录"></a>iOS独有目录</h2><p>下图所示分别是OSX和iOS的根目录结构，与FHS还是有一定的区别。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs001.png" alt=""></div><p>对于iOS，其独有的目录如下思维导图所示：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs002.png?x-oss-process=image/resize,w_500" alt=""></div><ul><li><code>/Applications</code>：存放所有的<strong>系统App</strong>和<strong>来自于Cydia的App</strong>，不包括StoreApp</li><li><code>/Developer</code>：如果一台设备连接Xcode后被指定为调试机，Xcode就会在iOS中生成该目录<ul><li><code>/Developer/Applications</code></li><li><code>/Developer/Library</code></li><li><code>/Developer/Tools</code></li><li><code>/Developer/usr</code></li></ul></li><li><code>/Library</code>：存放一些提供系统支持的数据<ul><li><code>/Library/MobileSubstrate/DynamicLibraries</code>：<strong>存放Cydia安装程序的<code>.plist</code>和<code>.dylib</code>文件</strong></li></ul></li><li><code>/System/Library</code>：iOS文件系统中最重要的目录之一，存放大量系统组件<ul><li><code>/System/Library/Frameworks</code>：<strong>存放iOS中各种日常使用的framework</strong></li><li><code>/System/Library/PrivateFrameworks</code>：<strong>存放iOS中未公开的私有framework</strong></li><li><code>/System/Library/CoreServices/SpringBoard.app</code>：iOS桌面管理器</li></ul></li><li><code>/User</code>：用户目录（<code>mobile</code>用户的<code>home</code>目录），实际指向<code>/var/mobile</code>，存放大量用户数据<ul><li><code>/var/mobile/Media/DCIM</code>：存放照片</li><li><code>/var/mobile/Media/Recording</code>：存放录音文件</li><li><code>/var/mobile/Library/SMS</code>：存放短信数据库</li><li><code>/var/mobile/Library/Mail</code>：存放邮件数据</li><li><code>/var/mobile/Containers</code>：<strong>存放StoreApp</strong>。<ul><li><code>/var/mobile/Containers/Bundle</code>：<strong>存放所有StoreApp的可执行文件和相关资源</strong></li><li><code>/var/mobile/Containers/Data</code>：<strong>存放所有StoreApp的数据，沙盒目录的真实目录</strong></li></ul></li></ul></li></ul><h2 id="iOS应用（StoreApp）沙盒"><a href="#iOS应用（StoreApp）沙盒" class="headerlink" title="iOS应用（StoreApp）沙盒"></a>iOS应用（StoreApp）沙盒</h2><p>出于安全考虑，iOS系统把每个应用（StoreApp）以及数据都放到一个沙盒（sandbox）里面，应用只能访问自己沙盒目录里面的文件、网络资源等（也有例外，比如系统通讯录、照相机、照片等能在用户授权的情况下被第三方应用访问）。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-reverse-fhs004.png?x-oss-process=image/resize,w_500" alt=""></div><p>上图所示为沙盒结构，沙盒在逻辑上包含两个部分：<code>Bundle Container</code>和<code>Data Container</code>，两者在iOS文件系统中的位置是平行的，分别是<code>/var/mobile/Containers/Bundle</code>和<code>/var/mobile/Containers/Data</code>。实际开发中，通过<code>NSHomeDirectory()</code>方法获取到沙盒根目录对应的是<code>Data Container</code>的路径。</p><h3 id="Bundle-Container"><a href="#Bundle-Container" class="headerlink" title="Bundle Container"></a>Bundle Container</h3><p>bundle的概念源自于NeXTSTEP，它是一个按某种标准结构来组织的目录，其中包含了二进制文件及运行所需的资源。正向开发中常见的App和framework都是以bundle的形式存在。在越狱iOS中常见的PreferenceBundle是一种依附于Settings的App，结构与App类似，本质也是bundle。Framework也是bundle，但framework的bundle中存放的是一个dylib（动态库），而非可执行文件。</p><p>在正向开发时，我们上传至App Store的ipa（iPhone Application）包，解压后会有一个<code>Payload</code>目录，其内部又包含一个<code>.app</code>目录，这个目录就是一个App的目录结构，也是一个bundle。</p><p><code>Bundle Container</code>位于<code>/var/mobile/Containers/Bundle/Application/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX/</code>主要用于存放静态资源，主要包含以下目录和文件：</p><ul><li><p><strong><code>MyApp.app</code></strong><br>  存放可执行文件和资源文件，包括：打包时的资源文件、本地文件、可执行文件、<code>.plist</code>文件。这个目录不会被iTunes同步。</p></li><li><p><strong><code>iTunesArtWork</code></strong></p></li><li><strong><code>iTunesMetadata.plist</code></strong></li></ul><h3 id="Data-Container"><a href="#Data-Container" class="headerlink" title="Data Container"></a>Data Container</h3><p><code>Data Container</code>位于<code>/var/mobile/Containers/Data/Application/YYYYYYYY-YYYY-YYYY-YYYYYYYYYYYY/</code>，主要用于存放App运行时产生的动态数据，其主要包含以下目录和文件：</p><ul><li><strong><code>Documents</code></strong><br>  存放应用运行时生成的并且需要保存的不可再生数据。注：iTunes或iCloud同步设备时会备份该目录</li><li><strong><code>Library</code></strong> <ul><li><strong><code>Library/Caches</code></strong><br>  存放应用运行时生成且需要保存的可再生数据，比如网络请求，用户需要负责删除对应文件。iTunes或iCloud不同步。</li><li><strong><code>Library/Preferences</code></strong><br>  存放偏好设置。使用<code>NSUserDefaults</code>写的设置数据都会保存在该目录下的一个<code>plist</code>文件中。iTunes或iCloud同步设备时备份该目录。</li></ul></li><li><strong><code>tmp</code></strong><br>  存放应用下次启动不再需要的临时文件。当应用不再需要这些文件的时候，需要主动将其删除。（当应用不再运行的时候，系统可能会将此目录清空。）这个目录不会被iTunes同步。</li></ul><p>在正向开发时，沙盒目录路径均有相应的获取方式，具体如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 沙盒目录</span><br><span class="line">NSLog(@&quot;%@&quot;,NSHomeDirectory());</span><br><span class="line">  </span><br><span class="line">// MyApp.app</span><br><span class="line">NSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]);</span><br><span class="line">  </span><br><span class="line">// Documents</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *docPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,docPath);</span><br><span class="line">  </span><br><span class="line">// Library</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libPath = [paths objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;%@&quot;,libPath);</span><br><span class="line">  </span><br><span class="line">// tmp</span><br><span class="line">NSLog(@&quot;%@&quot;,NSTemporaryDirectory());</span><br></pre></td></tr></table></figure></p><p>在逆向工程中，可以通过以下方式获取相关的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取App的Bundle路径</span><br><span class="line">iphone: root# ps -e | grep appname</span><br><span class="line">  </span><br><span class="line">// 获取App的Data路径</span><br><span class="line">iphone: root# cycript -p appname</span><br><span class="line">cy# directory = NSHomeDirectory()</span><br></pre></td></tr></table></figure></p><h1 id="iOS二进制文件类型"><a href="#iOS二进制文件类型" class="headerlink" title="iOS二进制文件类型"></a>iOS二进制文件类型</h1><p>iOS逆向的目标主要包含三类二进制文件：<code>Application</code>、<code>Dynamic Library</code>、<code>Daemon</code>。</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application，即我们最熟悉的App。App的Bundle目录有以下三个部分比较重要：</p><ul><li><p><code>Info.plist</code><br>  Info.plist记录了App的基本信息，如：<strong><code>bundle identifier</code></strong>、<strong>可执行文件名</strong>、<strong>图标文件名</strong>等。</p></li><li><p>可执行文件<br>  查看Info.plist，即可定位可执行文件</p></li><li><p>lproj目录<br>  lproj目录下存放的是各种本地化的字符串。</p></li></ul><h3 id="系统App-VS-StoreApp"><a href="#系统App-VS-StoreApp" class="headerlink" title="系统App VS. StoreApp"></a>系统App VS. StoreApp</h3><p><code>/Applications/</code>目录下存放<strong>系统App</strong>（包括CydiaApp）；<code>/var/mobile/Containers/</code>目录下存放<strong>StoreApp</strong>。其区别在于：</p><ul><li><p>目录结构<br>  两种App的Bundle目录区别不大，都含有Info.plist、可执行文件、lproj目录等。只是Data目录的位置不同：StoreApp的数据目录在<code>/var/mobile/Containers/Data/</code>下，以mobile权限运行的系统App的数据目录在<code>/var/mobile/</code>下，以root权限运行的系统App的数据目录在<code>/var/root/</code>下。</p></li><li><p>安装格式和权限<br>  Cydia App的安装格式一般是deb，StoreApp的安装格式一般是ipa。前者的属主用户和属主组一般是root和admin，能够以root权限运行；后者的属主用户和属主组都是mobile，只能以mobile权限运行。</p></li></ul><h2 id="Dynamic-Library"><a href="#Dynamic-Library" class="headerlink" title="Dynamic Library"></a>Dynamic Library</h2><p>Dynamic Library简称dylib，即动态链接库。在正向开发中，在Xcode工程中导入的各种framework，链接的各种lib，其本质都是dylib。</p><p>在iOS中，lib分为static和dynamic两种，其中static lib在编译阶段成为App可执行文件的一部分，会增加可执行文件的大小。dylib则不会改变可执行文件的大小，只有当App运行时调用到dylib时，iOS才会把它加载进内存，成为App进程的一部分。</p><p><strong>dylib是逆向工程的重要目标类型</strong>，但其本身并不是可执行文件，不能独立运行，只能为别的进程服务，而且它们寄生在别的进程里，成为这个进程的一部分。因此，dylib的权限是由它寄生的那个App决定的，同一个dylib寄生在系统App和StoreApp里时的权限是不同的。</p><p>越狱iOS中，Cydia里的各种tweak无一不是以dylib的形式工作的。</p><h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>iOS的daemon主要由一个可执行文件和一个plist文件构成。iOS的根进程是launchd，其会在开机时检查<code>/System/Library/LaunchDaemons</code>和<code>/Library/LaunchDaemons</code>下所有格式符合规定的plist文件，然后启动对应的daemon。这里的plist文件与App中的<code>Info.plist</code>文件作用类似，即记录Daemon的基本信息。</p><p>(完)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《iOS应用逆向工程（第2版）》</li><li><a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html" target="_blank" rel="noopener">File System Programming Guide</a></li><li><a href="http://www.cnblogs.com/wujy/archive/2016/02/13/5188302.html" target="_blank" rel="noopener">iOS底层基础知识-文件目录结构</a></li><li><a href="https://www.jianshu.com/p/9cc4f0975d1d" target="_blank" rel="noopener">iOS APP沙盒目录</a></li><li><a href="https://bbs.feng.com/read-htm-tid-249.html" target="_blank" rel="noopener">Mac OS X 术语表</a></li><li><a href="http://www.cocoachina.com/mac/20150122/10988.html" target="_blank" rel="noopener">了解iOS上的可执行文件和Mach-O格式</a></li><li><a href="http://oncenote.com/2015/06/01/How-App-Launch/" target="_blank" rel="noopener">由App的启动说起</a></li><li><a href="https://objccn.io/issue-6-3/" target="_blank" rel="noopener">Mach-O 可执行文件</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS文件系统&quot;&gt;&lt;a href=&quot;#iOS文件系统&quot; class=&quot;headerlink&quot; title=&quot;iOS文件系统&quot;&gt;&lt;/a&gt;iOS文件系统&lt;/h1&gt;&lt;p&gt;iOS由OSX演化而来，而OSX又是基于UNIX的，它们都是类UNIX操作系统。类UNIX操作系统有
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="逆向工程" scheme="http://chuquan.me/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="沙盒原理" scheme="http://chuquan.me/tags/%E6%B2%99%E7%9B%92%E5%8E%9F%E7%90%86/"/>
    
      <category term="文件系统" scheme="http://chuquan.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>现代浏览器工作原理（一）</title>
    <link href="http://chuquan.me/2018/01/21/browser-architecture-overview/"/>
    <id>http://chuquan.me/2018/01/21/browser-architecture-overview/</id>
    <published>2018-01-20T16:01:06.000Z</published>
    <updated>2018-04-27T17:53:21.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了…框架？不是针对特定需求的框架，介绍起来感觉也没有太大的意义…</p><p>恍惚间，想起之前@展哥在调高考真题Hybrid页面时，似乎在前端代码方面遇到一些麻烦。于是，我就想到了UIWebView。就此进行思维发散，感觉可以介绍一下浏览器的工作原理。毕竟，iOS和前端同属于大客户端。对于iOS的同学，也算是对知识面的扩展吧。</p><p>于是，我查阅了一些与浏览器原理相关的资料。在这个过程中，找到很多优秀的资料。但是，大多数资料的组织结构，不是特别清晰。因此，我想借此机会，结合参考资料，来重新梳理一下浏览器的原理。由于浏览器的结构非常复杂，一篇文章想介绍清楚，真的太难。本文将使用总-分-总的形式，使用一系列文章来进行介绍。如有纰漏，欢迎纠正。</p><h1 id="浏览器历史"><a href="#浏览器历史" class="headerlink" title="浏览器历史"></a>浏览器历史</h1><p>1990年，<a href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E" target="_blank" rel="noopener">蒂姆·伯纳斯·李</a>开发了第一个网页浏览器<a href="https://zh.wikipedia.org/wiki/WorldWideWeb" target="_blank" rel="noopener">WorldWideWeb</a>，后改名为<strong>Nexus</strong>。WorldWideWeb浏览器支持早期的HTML标记语言，功能比较简单，只能支持文本、简单的样式表、电影、声音、图片等资源的显示。</p><p>1993年，<a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%85%8B%C2%B7%E5%AE%89%E5%BE%B7%E6%A3%AE" target="_blank" rel="noopener">马克·安德森</a>领导的团开发了一个真正有影响力的浏览器<a href="https://zh.wikipedia.org/wiki/Mosaic" target="_blank" rel="noopener">Mosaic</a>，这就是后来世界上最流行的浏览器<a href="https://zh.wikipedia.org/wiki/Netscape_Navigator" target="_blank" rel="noopener">Netscape Navigator</a>。</p><p>1995年，微软推出了闻名于世的浏览器<a href="https://zh.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="noopener">Internet Explorer</a>。</p><p>1998年，Netscape公司开放Netscape Navigator源代码，成立了Mozilla基金会。</p><p>2003年，苹果公司发布了Safari浏览器。</p><p>2004年，Netscape公司发布了著名的开源浏览器<a href="https://zh.wikipedia.org/wiki/Firefox" target="_blank" rel="noopener">Mozilla Firefox</a></p><p>2005年，苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目WebKit（Safari浏览器的内核）。</p><p>2008年， Google公司已WebKit为内核，创建了一个新的浏览器项目<a href="https://zh.wikipedia.org/zh-hant/Chromium" target="_blank" rel="noopener">Chromium</a>。以Chromium为基础，谷歌发布了<a href="https://zh.wikipedia.org/wiki/Google_Chrome" target="_blank" rel="noopener">Chrome</a>浏览器。至于这两者的关系，可以简单地理解为：Chromium为实验版，具有众多新特性；Chrome为稳定版。</p><h1 id="浏览器特性"><a href="#浏览器特性" class="headerlink" title="浏览器特性"></a>浏览器特性</h1><p>现代浏览器的特性主要包含如下几部分：</p><ul><li><strong>网络</strong><br>  浏览器通过网络模块下载各种资源，如：HTML文档、JavaScript代码、样式表、图片、音频视频文件等。 网络模块是浏览器最重要的模块之一。</li><li><strong>资源管理</strong><br>  浏览器通过高效的管理机制来管理网络资源和本地资源。比如如何避免重复下载资源、缓存资源等。</li><li><strong>网页浏览</strong><br>  浏览器最核心的功能。浏览器通过网络下载资源，并从资源管理器获得资源，然后将其转化为可视化结果。</li><li><strong>多页面管理</strong><br>  浏览器支持多页面浏览，因此支持多页面同时加载。浏览器需要多页面管理机制来解决例如多页面的相互影响和安全等问题。</li><li><strong>插件和扩展</strong><br>  现代浏览器的重要特征。插件可以用来显示网页特定内容；扩展则是增加浏览器新功能的软件或压缩包。</li><li><strong>账户和同步</strong><br>  现代软件的普遍特性。浏览器将用户的浏览信息，例如历史记录、书签等信息同步到服务器，提供多系统下的统一体验。</li><li><strong>安全机制</strong><br>  现代软件的重要特性。浏览器的安全机制需要提供一个安全的浏览环境，例如：避免用户信息被窃取或破坏、防止浏览器被恶意代码攻破等。</li><li><strong>开发者工具</strong><br>  开发者工具是浏览器提供给网页开发者的工具，可以帮助审查HTML元素、调试JavaScript代码、改善网页性能等。</li></ul><h1 id="浏览器结构"><a href="#浏览器结构" class="headerlink" title="浏览器结构"></a>浏览器结构</h1><p>目前，常用的浏览器主要有：Chrome、IE（Edge）、Safari、Firefox等。不同的浏览器在结构方面虽然有所差异，但是整体的设计理念是相似的。因此，可以抽象得到如下图所示的参考结构：</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/browser-architecture001.png" alt=""></div><p>浏览器的抽象分层结构图中将浏览器分成了以下8个子系统：</p><ul><li><strong>用户界面（User Interface）</strong><br>  用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。<br>  用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。</li><li><strong>浏览器引擎（Browser Engine）</strong><br>  浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。<br>  浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。<br>  浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。<br>  浏览器引擎还允许查询/修改渲染引擎设置。</li><li><strong>渲染引擎（Rendering Engine）</strong><br>  渲染引擎为指定的URI生成可视化的表示。<br>  渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。<br>  渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。<br>  渲染引擎内部包含HTML解析器。</li><li><strong>网络（Networking）</strong><br>  网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。</li><li><strong>JavaScript解释器（JavaScript Interpreter）</strong><br>  JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。  为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。</li><li><strong>XML解析器（XML Parser）</strong><br>  XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。</li><li><strong>显示后端（Display Backend）</strong><br>  显示后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。</li><li><strong>数据持久层（Data Persistence）</strong><br>  数据持久层将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</li></ul><p>这里可能会产生一个疑问：功能相似的HTML解析器和XML解析器为什么前者划分在渲染引擎中，后者作为独立的系统？<br>原因：XML解析器对于系统来说，其功能并不是关键性的，但是从复用角度来说，XML解析器是一个通用的，可重用的组件，具有标准的，定义明确的接口。相比之下，HTML解析器通常与渲染引擎紧耦合。</p><h1 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h1><p>浏览器的组成模块众多，而渲染引擎则是浏览器中最重要的模块（渲染引擎有时候也被称为“浏览器内核”，这种说法并不严谨，不推荐使用）。目前，常见的渲染引擎有Trident、Gecko、WebKit等。下表所示为几种渲染引擎在不同浏览器中的应用：</p><table><thead><tr><th style="text-align:left">渲染引擎</th><th style="text-align:left">浏览器</th></tr></thead><tbody><tr><td style="text-align:left">Trident</td><td style="text-align:left">IE、Edge</td></tr><tr><td style="text-align:left">Gecko</td><td style="text-align:left">Firefox</td></tr><tr><td style="text-align:left">WebKit</td><td style="text-align:left">Safari、Chromium/Chrome</td></tr></tbody></table><h2 id="渲染引擎工作流程"><a href="#渲染引擎工作流程" class="headerlink" title="渲染引擎工作流程"></a>渲染引擎工作流程</h2><p>如下图所示为渲染引擎的渲染流程示意图，其以HTML/JavaScript/CSS等文件作为输入，以可视化内容作为输出。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/browser-architecture002.png" alt=""></div><ol><li><p><strong>Parsing HTML to Construct DOM Tree</strong><br>渲染引擎使用HTML解析器（调用XML解析器）解析HTML（XML）文档，将各个HTML（XML）元素逐个转化成DOM节点，从而生成DOM树。<br>同时，渲染引擎使用CSS解析器解析外部CSS文件以及HTML（XML）元素中的样式规则。元素中带有视觉指令的样式规则将用于下一步，以创建另一个树结构：渲染树。  </p></li><li><p><strong>Render Tree construction</strong><br>渲染引擎使用第1步CSS解析器解析得到的样式规则，将其附着到DOM树上，从而构成渲染树。<br>渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p></li><li><p><strong>Layout of Render Tree</strong><br>渲染树构建完毕之后，进入本阶段进行“布局”，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</p></li><li><p><strong>Painting Render Tree</strong><br>渲染引擎将遍历渲染树，并调用显示后端将每个节点绘制出来。</p></li></ol><h2 id="渲染引擎组成模块"><a href="#渲染引擎组成模块" class="headerlink" title="渲染引擎组成模块"></a>渲染引擎组成模块</h2><p>下图所示为渲染引擎工作流程中各个步骤所对应的模块，其中第1步和第2步涉及到多个模块，并且耦合程度较高。这样的设计会为了达到更好的用户体验，渲染引擎尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就可以开始渲染树构建和布局设置。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/browser-architecture003.png" alt=""></div><p>从图中可以看出，渲染引擎主要包含（或调用）的模块有：</p><ul><li><strong>HTML（XML）解析器</strong><br>  解析HTML（XML）文档，主要作用是将HTML（XML）文档转换成DOM树。</li><li><strong>CSS解析器</strong><br>  将DOM中的各个元素对象进行计算，获取样式信息，用于渲染树的构建。</li><li><strong>JavaScript解释器</strong><br>  使用JavaScript可以修改网页的内容、CSS规则等。JavaScript解释器能够解释JavaScript代码，并通过DOM接口和CSSOM接口来修改网页内容、样式规则，从而改变渲染结果。</li><li><strong>布局</strong><br>  DOM创建之后，渲染引擎将其中的元素对象与样式规则进行结合，可以得到渲染树。布局则是针对渲染树，计算其各个元素的大小、位置等布局信息。</li><li><strong>绘图</strong><br>  使用图形库将布局计算后的渲染树绘制成可视化的图像结果。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了浏览器的主要特性以及抽象结构，并选择其中最为核心的渲染引擎进行了介绍。渲染引擎是浏览器中最为复杂的部件，后续将对渲染引擎中的各个模块依次进行介绍。</p><p>（完）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">Web Browser-Wikipedia</a></li><li>Adam Barth, Collin Jackson, Charles Reis, Google Chrome Team. The Security Architecture of the Chromium Browser.</li><li>Andre Campos, Bryan Lane, Neal Clark, Sunpreet Jassal, Stephen Hitchner. Conceptual Architecture of Firefox.</li><li>Alan Grosskurth and Michael Godfrey. A case study in architectural analysis: The evolution of the modern web browser.</li><li><a href="http://web.jobbole.com/84826/" target="_blank" rel="noopener">主流浏览器内核介绍（前端开发值得了解的浏览器内核历史）</a></li><li>朱永盛. 《WebKit技术内幕》.</li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li><li>Alan Grosskurth, Michael W.Godfrey. A Reference Architecture for Web Browsers.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;p&gt;这些天在考虑选择什么主题在即将来临的公司技术分享会上进行分享。思来想去，也没找到什么比较好的主题。逆向？已经有人分享过了…框架？不是针对特定需求的框
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="浏览器原理" scheme="http://chuquan.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    
      <category term="渲染引擎" scheme="http://chuquan.me/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>2017年总结</title>
    <link href="http://chuquan.me/2018/01/02/2017-summary/"/>
    <id>http://chuquan.me/2018/01/02/2017-summary/</id>
    <published>2018-01-01T16:21:20.000Z</published>
    <updated>2018-02-08T07:21:18.552Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/maimai-2017-summary.png?x-oss-process=image/resize,w_400" alt=""></div><a id="more"></a><p>这几天，脉脉上有一个年度总结的活动。2017年，我对自己的总结便是一个字——<strong>变</strong>。</p><h1 id="关于论文毕设"><a href="#关于论文毕设" class="headerlink" title="关于论文毕设"></a>关于论文毕设</h1><p>2017的上半年是我硕士生涯，也是我学生生涯的最后一个学期。这半年真的是一直处于焦虑中，毕业总是令人如鲠在喉。有人可能会问硕士毕业有这么难吗？如果我说我们是在毕业答辩前两个月才开的题你信吗？</p><p>关于毕业论文，我是经历过换题的。研二期间，一直在做碳纳米管计算机项目。然而，到了毕业选题的时候，才发现这个项目根本没有可深入研究的、与计算机体系结构相关的东西。不得已，只能换题。此时，恰逢2016年的10月，校招还在如火如荼地进行。而我已经没有心情继续找工作了。</p><p>2017年年初，@易老师给了我一个毕业选题的大方向——RISC-V &amp; TLB &amp; 安全。参考往年类似的毕业选题（如：@天一师兄、@翁东旭师兄的毕业论文），我大致规划出了毕业论文的框架。然而，往年论文的相关实验都是基于完整的项目平台，研究及评测环境相对来说都是比较完备的。我的毕业选题采用的实验平台则是基于RISC-V的开源处理器生成器——Rocket Chip Generator，该平台是2014年由UCB推出的，其研究及评测环境都还不完善，不足以提供标准且完整的论述、验证、评估的能力。</p><p>为了让论文能有更多的干货，我还去探索了TLB/MMU在安全方面研究的可能性。不过，这个想法在后来的预开题中被否决了。好在，预开题时，@佟老师给了我很多的建设性的意见，比如：研究Generator自动化生成硬件的原理、Chisel原理等。我能够在6月份顺利毕业，真的要感谢我的导师@佟老师、@易老师，在毕设期间予以我的帮助和建议。</p><h1 id="关于科研项目"><a href="#关于科研项目" class="headerlink" title="关于科研项目"></a>关于科研项目</h1><p>2月底春季的开学阶段，我提前了一周回了学校。因为，在做毕业的同时，我还要和物理电子所的同学对接碳纳米管项目。为了能让项目顺利结题，春节前后和@海涛师兄、@司佳师姐、@东维师弟一起忙活了一段时间。项目最后顺利结题，也算是了却了一桩心事。在4月份左右，@彭老师、@程老大又来了一次巨头会议，要在北大120周年献礼。也就是说，碳纳米管项目继续进行。当然，我知道自己不能继续跟进，便把工作交接了@李宁师妹和@东维师弟了。希望明年的五四，能给大家带来一个惊喜。</p><h1 id="关于毕业答辩"><a href="#关于毕业答辩" class="headerlink" title="关于毕业答辩"></a>关于毕业答辩</h1><p>3月底，实验室进行了开题答辩会。这个开题时间放眼整个北大，也算是晚的了。不知道@老大作何感想，可能真的是日理万机吧。不过，从开题答辩会上老大的表述，能看出@老大对于我们这一届还是抱有歉意，希望我们都能顺利毕业。</p><p>6月2日，毕业答辩会如期进行。答辩会上有校外专家，当我们有遇到答不上的问题或被专家刁难的时候，@老大能够及时救场，果然护犊子！手动点赞！结果是显而易见的，所有人都顺利毕业。</p><p>答辩过后，和@小威威、@大帅、@赵璐、@昊泽去了南门翅客吃了烧烤，果然是前所未有的轻松。</p><h1 id="关于毕业旅行"><a href="#关于毕业旅行" class="headerlink" title="关于毕业旅行"></a>关于毕业旅行</h1><p>6月3日是我们的发出时间，一个月前订机票时也是非常忐忑，毕竟答辩时间是6月2日，就怕答辩时间更改。关于毕业旅行的详细内容，可以看<a href="http://chuquan.me/2017/06/16/tailand/">这里</a>。</p><h1 id="关于毕业典礼"><a href="#关于毕业典礼" class="headerlink" title="关于毕业典礼"></a>关于毕业典礼</h1><p>毕业旅行回来，能感受到浓厚的离别气息。拍毕业照、毕业典礼、谢师宴…从今往后，同窗同门都要各奔东西。</p><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><p>校招时，我投递的岗位是前端开发工程师，后来HR跟我沟通有没有转岗iOS开发工程师的意愿。在考虑了几天后，我选择了转岗。我当时的想法是这样的：</p><ul><li>前端的门槛比较低，从业人员比较很多，想真正脱颖而出还是比较困难的，感觉硕士毕业从事前端的优势并不大。</li><li>前端的技术更新迭代速度太快，没有一个统一的行业标准，不同的公司可能采用完全不同的技术栈。所以，前端岗需要不断地学习，一旦松懈，可能就会被淘汰，压力比较大。</li><li>程序员都知道所谓的“程序员鄙视链”，前端是处于“鄙视链”的下游的。虽然前端已经今非昔比了，但是总的来说，职业天花板比较低。</li></ul><p>出于这些考虑，我选择了转岗。</p><p>7月初，办完了毕业手续，我和@撸神便搬家到了我们的整租房。在学校呆了20年，离开时真的很不习惯。</p><p>7月10日，在紧张和期待中办理了入职手续。期间，遇到了校友@家骏、@仲雪。中午，我的mentor@展哥接待了我，然后便组织大家在云海肴来了一波TB。</p><p>@展哥已经有7年的工作经验了，作为小猿搜题iOS端负责人，他的技术能力的确是很强的。作为mentor，他也是尽心尽力，真的非常nice。相比于我在某度的mentor，真是不知道高到哪里去了，无论是技术能力，还是个人修养。然而，没想到@展哥年后要离职，真的有点不舍啊。</p><p>我工位的右边是@展哥，左边是@琳洁——一位iOS程序媛。她虽然话不多，但是只要有问题，她都能悉心指导我。而且做事特别细致，从code review就能看出来。</p><p>我的leader@邱瑞，也是我的校友师兄。为人非常nice，说话语气很平和，平时分配任务、交谈时完全没有一种上下级的感觉。对于产品需求的评估、事务的处理都是非常到位。</p><p>有人说：想要在职场上快速成长，可以尝试学习你领导的做事方式。我个人非常赞同这种观点，希望新的一年，我能够像@展哥、@邱瑞、@琳洁他们一样做人做事。</p><h1 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h1><p>上半年写的代码基本都是服务于毕业设计，都是与硬件相关。下半年学的都是工程相关：</p><ul><li>在编程语言方面，学习了两门新的语言：Objective-C、Swift。</li><li>在版本管理方面，能够熟练使用git的各种常用命令。</li><li>在项目管理方面，了解了公司的项目管理流程以及敏捷开发模式，自己还搭建了Gerrit代码审核服务器。</li></ul><h1 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h1><p>2017年1月1日，我计划开始记录自己的阅读轨迹，其实主要原因是希望能够督促自己保持阅读（阅读轨迹<a href="http://chuquan.me/2017/01/05/read-books/">在这里</a>）。2017年总共阅读了不到10本书。希望新的一年，在阅读时能够有更多的自我思考，尽可能产出一些读书笔记。虽然，我读书的时候喜欢使用有道云来做笔记，但是缺少整理、总结和发布。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>对于公司来说，都会有年度目标，这样公司才能够健康成长。对于个人也是一样，给自己定一个目标，希望能够激励自己成长。2018年伊始，我也想给自己定一些小目标。</p><ul><li>至少看完两个iOS开源框架源代码（向大神靠拢）</li><li>至少看12本书，非工具类的书，需要有读书笔记（向@巧叔学习）</li><li>在技术方面，能够hold住产品经理提出来的所有需求（向@琳洁@展哥学习</li><li>在业务方面，了解小猿搜题的所有业务代码（向@邱瑞@琳洁@展哥学习）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/maimai-2017-summary.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://chuquan.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SSH 协议实践</title>
    <link href="http://chuquan.me/2017/12/27/ssh-protocol-practice/"/>
    <id>http://chuquan.me/2017/12/27/ssh-protocol-practice/</id>
    <published>2017-12-26T17:09:02.000Z</published>
    <updated>2018-02-09T03:30:34.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH概述"><a href="#SSH概述" class="headerlink" title="SSH概述"></a>SSH概述</h1><p>类似于HTTP，SSH（Secure Shell）是一种加密的网络传输协议，常用于加密远程登录。</p><p>1995年，芬兰赫尔辛基理工大学的塔图·于勒宁因为发现自己学校存在嗅探密码的网络攻击，设计了一套保护信息传输的程序，即Secure Shell（简称SSH），其目标是取代先前的<code>rlogin</code>、<code>Telnet</code>、<code>FTP</code>、<code>rsh</code>等安全性不足的协议。如今，最为广泛使用的<code>OpenSSH</code>便是SSH协议的一种免费开源实现。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>SSH使用非对称加密算法实现身份验证，即采用<strong>公钥-私钥对</strong>来进行加密网络连接。私钥由用户（本地主机）自行保管，公钥由远程主机（如：服务器）保管。</p><h1 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h1><p>下面使用<code>OpenSSH</code>进行具体实践。</p><h2 id="SSH协议语法格式"><a href="#SSH协议语法格式" class="headerlink" title="SSH协议语法格式"></a>SSH协议语法格式</h2><p>SSH主要用于远程登录，如下所示为SSH协议的语法格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [&lt;username&gt;@]&lt;server&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure></p><h2 id="关于SSH公钥认证"><a href="#关于SSH公钥认证" class="headerlink" title="关于SSH公钥认证"></a>关于SSH公钥认证</h2><p>为实现公钥认证，作为认证的客户端一方需要拥有两个文件，即<strong>公钥-私钥对</strong>。一般公钥-私钥对文件创建在用户的主目录下的<code>.ssh</code>目录中。如果用户主目录下不存在<code>.ssh</code>目录，说明SSH公钥-私钥对尚未创建。</p><h3 id="创建公钥-私钥对"><a href="#创建公钥-私钥对" class="headerlink" title="创建公钥-私钥对"></a>创建公钥-私钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure><p>该命令会在用户主目录下创建<code>.ssh</code>目录，并在其中创建两个文件：</p><ul><li><code>id_rsa</code>：私钥文件。是基于RSA算法创建的。</li><li><code>id_rsa.pub</code>：公钥文件。</li></ul><h3 id="分发公钥"><a href="#分发公钥" class="headerlink" title="分发公钥"></a>分发公钥</h3><p>创建了公钥-私钥对后，需要将公钥交给远程主机保管，这样才能在之后的登录实现无口令登录。如下命令，会将<code>.ssh</code>目录下指定的公钥文件拷贝至远程服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/id_rsa.pub &lt;user&gt;@&lt;server&gt;</span><br></pre></td></tr></table></figure></p><ul><li>该命令会提示输入用户user在server上的SSH登录口令  </li><li>此命令执行成功后，再以user用户用ssh命令登录server远程主机时，不必输入口令可直接登录</li><li>该命令实际上是<code>.ssh/id_rsa.pub</code>公钥文件拷贝到远程主机server的user主目录下的<code>.ssh/authorized_keys</code>文件中，内容类似如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHJu4oVxIbLS2LBH5wI7htvDxuIMZ5IFUaZjbWI8z...M4yGEWcr7OVPdQa4DIEbrrl8MzsAZ baochuquan@baochuquandeMacBoo    k-Pro.local</span><br></pre></td></tr></table></figure></li></ul><h2 id="关于SSH主机别名"><a href="#关于SSH主机别名" class="headerlink" title="关于SSH主机别名"></a>关于SSH主机别名</h2><p>在实际应用中，有时需要使用多套公钥/私钥对。然而，上述创建公钥-私钥对的命令只会生成默认名为<code>id_rsa</code>的密钥对。</p><h3 id="创建公钥-私钥对-1"><a href="#创建公钥-私钥对-1" class="headerlink" title="创建公钥-私钥对"></a>创建公钥-私钥对</h3><p>为了创建不同的公钥/私钥对，在使用<code>ssh-keygen</code>命令时就需要通过<code>-f</code>参数指定不同的私钥名称。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -f ~/.ssh/&lt;filename&gt;</span><br></pre></td></tr></table></figure></p><p>命令会在<code>.ssh/</code>目录下创建指定的公钥/私钥对：文件<code>&lt;filename&gt;</code>是私钥，文件<code>&lt;filename&gt;.pub</code>是公钥。</p><h3 id="分发公钥-1"><a href="#分发公钥-1" class="headerlink" title="分发公钥"></a>分发公钥</h3><p>将新生成的公钥添加到远程主机登录用户主目录下的<code>.ssh/authorized_keys</code>文件中，就可以使用新创建的公钥建立到远程主机<server>的<user>账户的无口令登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i .ssh/&lt;filename&gt;.pub &lt;user&gt;@&lt;server&gt;</span><br></pre></td></tr></table></figure></user></server></p><p>在有多个公钥/私钥对时，默认使用<code>~/.ssh/id_rsa.pub</code>。那么如何使用新建的公钥连接server呢？</p><h3 id="管理本地私钥"><a href="#管理本地私钥" class="headerlink" title="管理本地私钥"></a>管理本地私钥</h3><p>SSH的客户端配置文件<code>~/.ssh/config</code>可以通过创建主机别名，连接主机时选择用指定的私钥。例如<code>/.ssh/config</code>文件中的下列配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认的id_rsa私钥</span></span><br><span class="line">Host gerrit.zhenguanyu.com</span><br><span class="line">    Hostname gerrit.zhenguanyu.com</span><br><span class="line">    Port 29418</span><br><span class="line">    User baocq</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用指定的chuquan01私钥</span></span><br><span class="line">Host chuquan</span><br><span class="line">  user root</span><br><span class="line">  hostname 115.28.167.128</span><br><span class="line">  port 22</span><br><span class="line">  identityfile ~/.ssh/chuquan01</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 使用指定的gerrit01私钥</span></span><br><span class="line">Host gerrit</span><br><span class="line">  user gerrit</span><br><span class="line">  hostname 115.28.167.128</span><br><span class="line">  port 22</span><br><span class="line">  identityfile ~/.ssh/gerrit01</span><br></pre></td></tr></table></figure></p><h3 id="无口令远程登录"><a href="#无口令远程登录" class="headerlink" title="无口令远程登录"></a>无口令远程登录</h3><p>执行下面的SSH登录命令，即可登录Host为<code>chuquan</code>的主机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh chuquan</span><br></pre></td></tr></table></figure></p><p>（完）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">Secure Shell</a>  </li><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用（一）：远程登录</a>  </li><li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html" target="_blank" rel="noopener">SSH原理与运用（二）：远程操作与端口转发</a>  </li><li>《Git权威指南》，蒋鑫</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SSH概述&quot;&gt;&lt;a href=&quot;#SSH概述&quot; class=&quot;headerlink&quot; title=&quot;SSH概述&quot;&gt;&lt;/a&gt;SSH概述&lt;/h1&gt;&lt;p&gt;类似于HTTP，SSH（Secure Shell）是一种加密的网络传输协议，常用于加密远程登录。&lt;/p&gt;
&lt;p&gt;19
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="SSH" scheme="http://chuquan.me/tags/SSH/"/>
    
      <category term="公钥/私钥" scheme="http://chuquan.me/tags/%E5%85%AC%E9%92%A5-%E7%A7%81%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu + Gerrit + Apache 搭建代码审核服务器</title>
    <link href="http://chuquan.me/2017/12/12/ubuntu-gerrit-apache/"/>
    <id>http://chuquan.me/2017/12/12/ubuntu-gerrit-apache/</id>
    <published>2017-12-12T15:23:33.000Z</published>
    <updated>2018-04-27T16:48:34.717Z</updated>
    
    <content type="html"><![CDATA[<p>我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容…</p><h1 id="一、Gerrit介绍"><a href="#一、Gerrit介绍" class="headerlink" title="一、Gerrit介绍"></a>一、Gerrit介绍</h1><p>Gerrit的目的是提供一个轻量级的框架来review每一个commit，review通过之后，commit会被合入代码库。</p><p>Gerrit是一个中间区域，可以看到提交至Gerrit上的代码相对于服务器代码仓库中代码的差异，从而便于检查代码的改动。Gerrit也是整个代码review的推动者。</p><p>任何拥有多个成员的团队都应该有一个中央代码仓库。 Git在理论上可以在没有这样的中心位置的情况下工作，但实际上通常有一个中央仓库库作为项目实际内容的权威副本。 开发者从该中央仓库fetch和push</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gerrit-central-source-repository.png?x-oss-process=image/resize,w_570" alt=""></div><p>Gerrit被部署在上图的中央仓库的位置，并增加一个新的概念：<strong>a store of pending changes（未决的修改）</strong>。每个人仍然可以从中央仓库fetch，但是push操作则有所变化，push操作会直接push到中央仓库，而是push到了<strong>pending changes location</strong>，以供review。只有在commit通过了review之后，才会被submit到中央仓库。如下图所示。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gerrit-in-place-of-central-repository.png?x-oss-process=image/resize,w_570" alt=""></div><p>Gerrit具有强大的访问控制模型。用户可以被授予访问权限，绕过review，直接推送到中央仓库。Gerrit甚至可以在没有代码review的情况下使用，只用于托管仓库和访问控制。</p><h1 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h1><p>在安装gerrit之前，我使用<code>node</code>在服务器上部署了一个站点，也就是本博客，其占用了<code>80</code>端口。</p><p>在安装gerrit之后，我的服务器又将多出一个站点，用户该如何访问？我又该如何部署呢？这时候，我们就需要了解一下<code>反向代理</code>和<code>端口转发</code>了。</p><h2 id="1-正向代理与反向代理"><a href="#1-正向代理与反向代理" class="headerlink" title="1. 正向代理与反向代理"></a>1. 正向代理与反向代理</h2><p>如下所示为正向代理和反向代理的示意图。一般来说，我们会把正向代理是与客户端划为一体，把反向代理和服务器划为一体。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/proxy-both.png" alt=""></div><p>此时，重新思考一下我们的应用场景：博客是一个web服务器，gerrit是一个web服务器，apache作为反向代理，这样就可以满足我们的需求了。</p><p>那么反向代理到底是如何做到的呢？答案就是<code>端口转发</code>。</p><p>我们知道在浏览器输入网址后，它会在解析后的IP地址之后加上一个默认的端口号<code>80</code>。所以，我们访问<code>chuquan.me</code>时就不需要输入完整的地址<code>chuquan.me:80</code>了。正因为如此，绝大多数服务器软件（包括apache）的默认监听端口也是<code>80</code>。</p><p>在安装了apache之后，<code>80</code>端口被apache占用了。因此，gerrit和博客都不能使用<code>80</code>端口了。这时候，我们需要给这两个站点配置使用其他的端口号，如：gerrit的HTTP协议使用<code>8081</code>端口，博客使用<code>8082</code>端口。它们与apache之间使用<code>端口转发</code>来实现<code>反向代理</code>。</p><div align="center"><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/apache-gerrit-blog.png" alt=""></div><h1 id="三、开发环境"><a href="#三、开发环境" class="headerlink" title="三、开发环境"></a>三、开发环境</h1><ul><li>Ubuntu 14.04.5 LTS</li><li>Java 1.8.0_151</li><li>Git 1.9.1</li><li>Apache/2.4.7 </li></ul><h1 id="四、安装Gerrit"><a href="#四、安装Gerrit" class="headerlink" title="四、安装Gerrit"></a>四、安装Gerrit</h1><h2 id="1-新建专用用户"><a href="#1-新建专用用户" class="headerlink" title="1. 新建专用用户"></a>1. 新建专用用户</h2><p>新建一个用户来专门管理Gerrit相关内容。在root用户下新建一个gerrit用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ adduser gerrit</span><br><span class="line">$ su gerrit</span><br></pre></td></tr></table></figure></p><h2 id="2-下载Gerrit安装包"><a href="#2-下载Gerrit安装包" class="headerlink" title="2. 下载Gerrit安装包"></a>2. 下载Gerrit安装包</h2><p>Gerrit下载地址：<a href="https://www.gerritcodereview.com/releases/2.14.md" target="_blank" rel="noopener">https://www.gerritcodereview.com/releases/2.14.md</a></p><p>我安装的Gerrit版本是2.14.6。在Linux环境下使用<code>wget</code>进行下载，最终得到一个<code>war</code>包，位于<code>/home/gerrit/</code>目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://gerrit-releases.storage.googleapis.com/gerrit-2.14.6.war</span><br></pre></td></tr></table></figure></p><h2 id="3-安装Gerrit"><a href="#3-安装Gerrit" class="headerlink" title="3. 安装Gerrit"></a>3. 安装Gerrit</h2><p>在<code>/home/gerrit/</code>目录下，进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar gerrit-2.14.6.war init -d review_site</span><br></pre></td></tr></table></figure></p><p>上述命令会在当前目录下创建一个<code>review_site</code>目录。接下来就开始进行对话式安装，我们可以直接回车，表示采用默认安装选项。之后还可以通过配置文件进行详细配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">*** Gerrit Code Review 2.14.6</span><br><span class="line">***</span><br><span class="line">*** Git Repositories  </span><br><span class="line">***  </span><br><span class="line">Location of Git repositories   [git]:   </span><br><span class="line">*** SQL Database  </span><br><span class="line">***  </span><br><span class="line">Database server type           [h2]:   </span><br><span class="line">*** User Authentication  </span><br><span class="line">***  </span><br><span class="line">Authentication method          [OPENID/?]: http  </span><br><span class="line">Get username from custom HTTP header [y/N]?  </span><br><span class="line">SSO logout URL                 :  </span><br><span class="line">*** Email Delivery  </span><br><span class="line">***  </span><br><span class="line">SMTP server hostname           [localhost]:  </span><br><span class="line">SMTP server port               [(default)]:  </span><br><span class="line">SMTP encryption                [NONE/?]:  </span><br><span class="line">SMTP username                  :  </span><br><span class="line">*** Container Process  </span><br><span class="line">***  </span><br><span class="line">Run as                         [gerrit]:  </span><br><span class="line">Java runtime                   [/usr/lib/jvm/java-7-openjdk-amd64/jre]:  </span><br><span class="line">Copy gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war [Y/n]?  </span><br><span class="line">Copying gerrit-2.13.4.war to /home/gerrit/review/bin/gerrit.war  </span><br><span class="line">*** SSH Daemon  </span><br><span class="line">***  </span><br><span class="line">Listen on address              [*]:  </span><br><span class="line">Listen on port                 [29418]:  </span><br><span class="line">*** HTTP Daemon  </span><br><span class="line">***  </span><br><span class="line">Behind reverse proxy           [y/N]?   </span><br><span class="line">Proxy uses SSL (https://)      [y/N]?  </span><br><span class="line">Subdirectory on proxy server   [/]:  </span><br><span class="line">Listen on address              [*]:  </span><br><span class="line">Listen on port                 [8080]:</span><br><span class="line">*** Plugins  </span><br><span class="line">***  </span><br><span class="line">Installing plugins.  </span><br><span class="line">Install plugin download-commands version v2.11 [y/N]?  </span><br><span class="line">Install plugin reviewnotes version v2.11 [y/N]?  </span><br><span class="line">Install plugin singleusergroup version v2.11 [y/N]?  </span><br><span class="line">Install plugin replication version v2.11 [y/N]?  </span><br><span class="line">Install plugin commit-message-length-validator version v2.11 [y/N]?  </span><br><span class="line">Initializing plugins.  </span><br><span class="line">No plugins found with init steps.  </span><br><span class="line">Initialized /home/gerrit/review_site</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>安装完毕，Gerrit会自动启动，不过我们大概率会启动失败，因为默认的配置并不一定与你当前的环境相匹配。不过，没关系，我们可以根据系统环境对gerrit进行配置。</p><h2 id="4-Gerrit配置"><a href="#4-Gerrit配置" class="headerlink" title="4. Gerrit配置"></a>4. Gerrit配置</h2><p>Gerrit安装完成后，会在<code>review_site</code>目录下生成多个目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ll review_site</span><br><span class="line">./</span><br><span class="line">../</span><br><span class="line">bin/</span><br><span class="line">cache/</span><br><span class="line">data/</span><br><span class="line">db/</span><br><span class="line">etc/</span><br><span class="line">git/</span><br><span class="line">index/</span><br><span class="line">lib/</span><br><span class="line">logs/</span><br><span class="line">plugins/</span><br><span class="line">static/</span><br><span class="line">tmp/</span><br></pre></td></tr></table></figure></p><p>其中<code>etc/</code>目录下存放着gerrit的配置文件<code>gerrit.config</code>，其中已有的内容是根据安装时的选择生成的。我们可以编辑<code>gerrit.config</code>来进行配置更改。其中<code>115.28.168.118</code>是服务器的公网IP地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[gerrit]</span><br><span class="line">        basePath = git</span><br><span class="line">        serverId = 084efaf9-3bf6-401c-a4b1-8778c998bde2</span><br><span class="line">        canonicalWebUrl = http://115.28.168.118 # 指定web访问Gerrit的网址或IP地址</span><br><span class="line">[database]</span><br><span class="line">        type = h2</span><br><span class="line">        database = /home/gerrit/review_site/db/ReviewDB</span><br><span class="line">[index]</span><br><span class="line">        type = LUCENE</span><br><span class="line">[auth]</span><br><span class="line">        type = HTTP # 默认是OPENID，改成HTTP后，才能通过浏览器进行访问</span><br><span class="line">[receive]</span><br><span class="line">        enableSignedPush = true</span><br><span class="line">[sendemail]</span><br><span class="line">        smtpServer = localhost</span><br><span class="line">[container]</span><br><span class="line">        user = gerrit</span><br><span class="line">        javaHome = /usr/lib/jvm/java-8-oracle/jre</span><br><span class="line">[sshd]</span><br><span class="line">        listenAddress = *:29418</span><br><span class="line">[httpd]</span><br><span class="line">        listenUrl = proxy-http://115.28.168.118:8081/ # HTTP代理地址及端口，这里我们配置成8081</span><br><span class="line">[cache]</span><br><span class="line">        directory = cache</span><br></pre></td></tr></table></figure></p><h1 id="四、配置Apache"><a href="#四、配置Apache" class="headerlink" title="四、配置Apache"></a>四、配置Apache</h1><p>不同系统以及不同版本的Apache的配置文件可能会不一样，无外乎两种：<code>httpd.conf</code>、<code>apache2.conf</code>。本环境的配置文件是<code>apache2.conf</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/apache2/</span><br><span class="line">$ vim apache2.conf</span><br></pre></td></tr></table></figure></p><p>在配置文件的末尾添加apache的端口转发配置。如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># Blog相关配置</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName www.chuquan.me       # 用于Apache过滤检测的域名</span><br><span class="line">ServerAlias chuquan.me</span><br><span class="line">    ProxyPass / http://115.28.168.118:8082/     # Blog正向代理转发的端口</span><br><span class="line">    ProxyPassReverse / http://localhost:8082/   # Blog反向代理转发的端口</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"># Gerrit相关配置</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName gerrit.chuquan.me    # 用户Apache过滤检测的域名    </span><br><span class="line">    ProxyRequests Off</span><br><span class="line">    ProxyVia Off</span><br><span class="line">    ProxyPreserveHost On</span><br><span class="line">    &lt;Proxy *&gt;</span><br><span class="line">          Order deny,allow</span><br><span class="line">          Allow from all</span><br><span class="line">    &lt;/Proxy&gt;</span><br><span class="line">    &lt;Location /login/&gt;</span><br><span class="line">        AuthType Basic</span><br><span class="line">        AuthName &quot;Gerrit Code Review&quot;</span><br><span class="line">        Require valid-user</span><br><span class="line">        AuthBasicProvider file</span><br><span class="line">        AuthUserFile /home/gerrit/review_site/etc/passwords</span><br><span class="line">    &lt;/Location&gt;</span><br><span class="line">    AllowEncodedSlashes On</span><br><span class="line">    ProxyPass / http://115.28.168.118:8081/         # Gerrit正向代理转发的端口</span><br><span class="line">    ProxyPassReverse / http://115.28.168.118:8081/  # Gerrit反向代理转发端口，应该与ProxyPass一致</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p><h1 id="五、服务重启"><a href="#五、服务重启" class="headerlink" title="五、服务重启"></a>五、服务重启</h1><p>Apache和Gerrit配置（当然也包括blog的端口）完之后，我们需要重启服务，包括apache、gerrit，其重启命令分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/gerrit/</span><br><span class="line">$ ./bin/gerrit.sh restart</span><br></pre></td></tr></table></figure><h2 id="1-Gerrit启动失败"><a href="#1-Gerrit启动失败" class="headerlink" title="1. Gerrit启动失败"></a>1. Gerrit启动失败</h2><p>在执行重启Gerrit的命令后，shell很可能会出现如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Starting Gerrit Code Review: FAILED</span><br></pre></td></tr></table></figure></p><p>我在安装过程中页出现了这个问题，于是，我通过在<code>./bin/gerrit.sh</code>脚本中的首行添加了一个<code>-x</code>选项，以打印脚本执行的相关信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -x</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>然后再执行该脚本，发现打印信息是一组循环信息。其中，当<code>TIMEOUT</code>的值递减至0时，启动失败。  </p><p>经过调研发现：  </p><blockquote><p>Gerrit启动慢是因为java程序启动慢，导致Gerrit启动非常慢，大概需要10分钟左右，而默认的超时时间（TIMEOUT）是90秒，导致一直提示“Starting Gerrit Code Review: FAILEDStarting Gerrit Code Review: FAILED”。对此有如下两种解决方案。</p></blockquote><p>第一种解决方案是：修改java的<code>java.security</code>文件。首先，根据<code>gerrit.config</code>中配置<code>javaHome = /user/lib/jvm/java-8-oracle/jre</code>，找到并进入该目录，然后再进入<code>lib/security/</code>目录，修改<code>java.security</code>文件。将<code>securerandom.source=file:/dev/random</code>改为<code>securerandom.source=file:/dev/urandom</code>。由此，解决gerrit启动慢的问题。</p><p>第二种解决方案是：在gerrit.conf文件中的<code>[container]</code>字段下增加`startupTimeout = 900。</p><h2 id="2-反向代理异常"><a href="#2-反向代理异常" class="headerlink" title="2. 反向代理异常"></a>2. 反向代理异常</h2><p>当我们配置结束并重启之后，在浏览器中访问很有可能会得到如下的页面：<br><img src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/gerrit-configure-error.png" alt=""></p><p>这个页面在安装过程中，出现次数不下于10次。主要是两种情况，一种是Gerrit配置文件和Apache配置文件可能配置有误。另一种情况是配置没有生效，需要多试试重启。</p><h2 id="3-创建第一个Gerrit账户"><a href="#3-创建第一个Gerrit账户" class="headerlink" title="3. 创建第一个Gerrit账户"></a>3. 创建第一个Gerrit账户</h2><p>当所有问题解决完之后，通过浏览器访问Gerrit，将不会出现上面的Error界面，而是会弹出输入对话框，需要你填写账户和密码。</p><p>这时候，我们需要为Gerrit创建一个账户，默认第一个创建的账户是管理员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ touch /home/gerrit/review_site/etc/passwords</span><br><span class="line">$ htpasswd /home/gerrit/review_site/etc/passwords &quot;admin&quot;</span><br><span class="line">New password:</span><br><span class="line">Re-type new password:</span><br><span class="line">Adding password for user root</span><br></pre></td></tr></table></figure></p><p>重启服务后，再用浏览器打开，登录后就出现久违的界面了！</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们公司采用Gerrit作为代码审核服务器并结合JIRA、Jenkins等开源工具，组成了一个完整项目管理平台。某天，我兴致来了，也想在自己的服务器上搭建一个Gerrit。于是，便有了以下内容…&lt;/p&gt;
&lt;h1 id=&quot;一、Gerrit介绍&quot;&gt;&lt;a href=&quot;#一、Ger
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Gerrit" scheme="http://chuquan.me/tags/Gerrit/"/>
    
  </entry>
  
</feed>
