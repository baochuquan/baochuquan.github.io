<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="http://chuquan.me/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2024-05-11T14:19:09.384Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何找到最合适的代码审查者？</title>
    <link href="http://chuquan.me/2024/05/11/git-reviewer/"/>
    <id>http://chuquan.me/2024/05/11/git-reviewer/</id>
    <published>2024-05-11T14:02:51.000Z</published>
    <updated>2024-05-11T14:19:09.384Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-01.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>我的日常工作中有相当一部分时间会用于审查团队成员所提交的代码，即 CodeReview。然而，由我来审查所有代码并不合适，毕竟很多时候我并不了解代码改动的上下文。如果让我重新熟悉别人写的原始逻辑，然后再审查代码改动，很显然是一件费时费力的事情。对此，最好的办法是，针对一次代码提交，合理地找出其最合适的代码审查者。</p><p>为了解决这个问题，我开发了一个 Git 插件——<ahref="https://github.com/baochuquan/git-reviewer">Git Reviewer</a>。</p><h1 id="功能">功能</h1><h2 id="核心功能">核心功能</h2><p>我们知道 Git使用新增和删除两种操作来表示代码改动。事实上，我们还可以从新增和删除两种操作的排列关系中得出第三种操作——编辑。当删除操作和新增操作相互紧邻，那么我们可以将其归为编辑操作。如下所示的代码差异中包含了新增、编辑、删除三种操作。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-03.png?x-oss-process=image/resize,w_800" /></p><p>Git Reviewer 正是基于这三种操作进行了分析：</p><ul><li><p>对于删除类型，Git Reviewer认为删除行的原始作者应该作为每一行的审查者。</p></li><li><p>对于编辑类型，Git Reviewer认为此部分中的新增内容应该全部由紧邻的最后删除行的原始作者作为审查者。注意，为什么是最后删除行？因为Git 所采用的 Myers差分算法默认差分内容优先展示删除操作，其次才是新增操作。因此，从最后的删除行开始，展示的是新增的内容。</p></li><li><p>对于新增类型，Git Reviewer 的策略是基于<code>.gitreviewer.yml</code>配置文件进行分析。<code>.gitreviewer.yml</code> 文件定义了项目所有者<code>project owner</code>、目录所有者<code>folder owner</code>、文件所有者 <code>file owner</code>。此时，GitReviewer 会对新增行的文件与 <code>.gitreviewer.yml</code>所定义的内容进行匹配。</p><ul><li>如果该文件匹配到了文件所有者，那么相关新增类型优先由文件所有者审查。</li><li>如果该文件匹配到了目录所有者，那么相关新增类型其次由目录所有者审查。</li><li>如果前两者均没有匹配该文件，那么将由项目所有者来进行审查。</li></ul></li></ul><p>基于对上述三种操作类型进行分析，Git Reviewer最终将生成一个分析表格，其中罗列了审查者、文件数量、文件占比、代码行数量、代码行占比等信息。GitReviewer 建议以代码行占比为依据，对审查者进行排序。</p><p>如下所示，为核心功能的分析结果示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|                 Suggested reviewers <span class="keyword">for</span> code changes                   |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| Suggested Reviewer | File Count | File Ratio | Line Count | Line Ratio |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerA         | 5          | 50.0%      | 1000       | 50.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerB         | 3          | 30.0%      | 500        | 25.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerC         | 2          | 20.0%      | 500        | 25.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><h2 id="附加功能">附加功能</h2><p>Git Reviewer还提供了分析代码改动的所涉及的作者分布的功能。此功能相对简单，其分析了所有删除行的原始作者和新增行的现有作者，并同样以表格的形式呈现，罗列作者、文件数量、文件占比、代码行数量、代码行占比等信息，以供用户进行评估和参考。</p><p>如下所示，为附加功能的分析结果示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|             Relevant authors involved <span class="keyword">in</span> code changes              |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| Related Author | File Count | File Ratio | Line Count | Line Ratio |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerA     | 5          | 50.0%      | 2000       | 66.6%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerB     | 3          | 30.0%      | 500        | 16.7%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerC     | 2          | 30.0%      | 500        | 16.7%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><h1 id="安装">安装</h1><p>Git Reviewer 支持通过 Homebrew进行安装，命令如下所示。当然，这也是建议的安装方式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install baochuquan/tap/git-reviewer</span><br></pre></td></tr></table></figure><p>或者，也可以通过 Ruby Gem 进行安装，命令如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install git-reviewer</span><br></pre></td></tr></table></figure><h1 id="使用">使用</h1><p>对于任意 Git 项目，在使用 Git Reviewer之前应该先在根目录下执行初始化命令，如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --init</span><br></pre></td></tr></table></figure><p>该命令会自动创建一个 <code>.gitreviewer.yml</code> 文件，内部定义了<code>project_owner</code>，<code>folder_owner</code>，<code>file_owner</code>等字段，其中后两者是数组类型，我们可以定义多个<code>path</code>、<code>owner</code>字段，从而对项目进行更精准的划分。</p><p>此外，<code>.gitreviewer.yml</code> 文件还包含<code>ignore_folders</code>、<code>ignore_files</code>字段，它们可以定义一系列目录或文件，以避免加入分析，从而影响分析结果。</p><p>如下所示，是一个 <code>.gitreviewer.yml</code>的示例，我们可以编辑相关字段，从而实现更精准的分析。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">project_owner: admin,</span><br><span class="line">folder_owner:</span><br><span class="line">- owner: developerA,</span><br><span class="line">  path: /path/to/folderA</span><br><span class="line">- owner: developerB</span><br><span class="line">  path: /path/to/folderB</span><br><span class="line"> </span><br><span class="line">file_owner:</span><br><span class="line">- owner: developerC</span><br><span class="line">  path: /path/to/fileC</span><br><span class="line">- owner: developerD</span><br><span class="line">  path: /path/to/fileD</span><br><span class="line"> </span><br><span class="line">ignore_files:</span><br><span class="line">- path/to/file1</span><br><span class="line">- path/to/file2</span><br><span class="line"> </span><br><span class="line">ignore_review_folders:</span><br><span class="line">- path/to/folder1</span><br><span class="line">- path/to/folder2</span><br></pre></td></tr></table></figure><h2 id="分析">分析</h2><p>Git Reviewer 基于两个 Git 分支进行分析，分别是源分支和目标分支。</p><p>源分支，即代码修改所在的分支。默认情况下，Git Reviewer自动获取当前所在分支作为源分支。当然，也可以使用选项来指定源分支<code>--source=&lt;source-branch&gt;</code>。除了分支名，Git Reviewer也支持 Commit ID。</p><p>目标分支，即准备合入的目标分支。对此，Git Reviewer 提供了相关选项<code>--target=&lt;target-branch&gt;</code>。</p><p>如下所示是使用 Git Reviewer 进行分析的命令示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --target=main</span><br></pre></td></tr></table></figure><p>默认情况下，Git Reviewer会同时展示核心功能和附加功能的分析结果。如果我们只希望查看核心功能的结果，可以指定选项<code>--reviewer</code>；如果我们只希望查看附加功能的结果，可以指定选项<code>--author</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --target=main --reviewer</span><br><span class="line"></span><br><span class="line">$ git reviewer --target=main --author</span><br></pre></td></tr></table></figure><p>为了查看更多分析信息，我们可以加上 --verbose 选项。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --target=main --verbose</span><br></pre></td></tr></table></figure><h1 id="后续">后续</h1><p>目前，Git Reviewer仅仅经历了我自己的自测，未来我会在项目上进行实践。如果遇到问题也会逐步进行修复。当然，在使用过程中还会遇到不足之处或者新的痛点，因此会逐步进行完善和迭代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-01.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="作品集" scheme="http://chuquan.me/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="Myers" scheme="http://chuquan.me/tags/Myers/"/>
    
    <category term="git-reviewer" scheme="http://chuquan.me/tags/git-reviewer/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（8）——光线追踪</title>
    <link href="http://chuquan.me/2024/04/27/foundation-of-computer-graphic-08/"/>
    <id>http://chuquan.me/2024/04/27/foundation-of-computer-graphic-08/</id>
    <published>2024-04-27T03:13:09.000Z</published>
    <updated>2024-04-27T03:17:47.121Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍了在游戏领域中广泛使用的实时渲染技术——光栅化，本文我们来介绍一下在特效领域中广泛使用的离线渲染技术——光线追踪。</p><span id="more"></span><h1 id="概述">概述</h1><p>那么有了光栅化渲染技术，为什么还要用光线追踪呢？根本原因在于光栅化的着色局部性，使得它无法解决很多全局效果，比如：</p><ul><li><strong>软阴影</strong>（Soft shadows）</li><li><strong>光泽反射</strong>（Glossy reflection）</li><li><strong>间接光照</strong>（Indirect illumination）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-01.png?x-oss-process=image/resize,w_800" /></p><p>软阴影的产生是由于光源的大小和距离。一个面积较大的光源照射一个物体，可以从多个角度投射光线到物体上。当光线从不同角度照射时，阴影边缘的重叠区域会因光线部分遮挡而出现阴影的渐变效果。</p><p>光泽反射是一种既不完全镜面反射也不完全漫反射的光反射现象。光泽度高、粗糙度低的表面产生的反射相对清晰，接近镜面反射；而光泽度低、粗糙度高的表面，反射图像就会更加模糊，趋向漫反射。</p><p>间接光照是一个场景中光线经过一次或多次反射后照射到物体表面的光照效果。在真实世界中，一个房间只通过一扇窗投过光照，但是房间里没有一个地方是完全黑色的，这就是光的多次反射造成的。</p><h1 id="底层依据">底层依据</h1><p>光线追踪依赖以下几个基本的底层依据，分别是：</p><ul><li><strong>光线沿直线传播</strong>：在微观角度，光是沿着波形传播；在宏观角度，光是沿着直线传播。</li><li><strong>光线相互不碰撞</strong>：当光线的传播路径发生交叠时，我们认为光线的传播互不干扰。</li><li><strong>光线具有可逆性</strong>：真实世界中，视觉成像是因为物体发射或反射光线，进入视网膜；在图形学中，屏幕成像是因为从相机向像素建立了反向的光线传播路径，采集路径上的所有着色信息。</li></ul><h1 id="基本原理">基本原理</h1><p>光线追踪的基本原理非常简单，其采用了<strong>针孔相机模型</strong>（Pinhole Camera Model），分为<strong>视线生成</strong> 和 <strong>像素着色</strong> 两个阶段。</p><p>对于视线生成，以相机为起点，以像素为锚点，利用光的可逆性，建立一条视觉射线，如下所示。此时，我们需要找到视线与空间中的物体所产生的最近的交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-02.png?x-oss-process=image/resize,w_800" /></p><p>对于像素着色，当我们找到视线与物体之间的最近交点时，随即建立交点与光源的连线，判断交点是否在阴影之中，并根据结果来计算着色，写回像素结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-03.png?x-oss-process=image/resize,w_800" /></p><h1 id="光线追踪">光线追踪</h1><p>上述基本原理只考虑了光源的直接影响，没有考虑间接影响。在实际情况中，光线会经过空间中物体的多次弹射，汇聚至交点上，从而对着色产生间接影响。</p><p>对此，<strong>经典光线追踪</strong>，也称<strong>惠特式光线追踪</strong>（Whitted-Style Ray Tracing）或<strong>递归光线追踪</strong>（Recursive RayTracing），引入了间接光照的处理。</p><p>在视线生成之后，我们找到最近的交点，然后根据光线的可逆性，找到反射光线（ReflectedRay）与折射光线（Refracted Ray）所产生的交点，依次类推，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-08.png?x-oss-process=image/resize,w_800" /></p><p>之后，我们将所有交点分别与光源进行连线，判断这些交点是否在阴影之中，并根据结果计算着色，写回像素结果。当然，在反射和折射过程中会存在能量折损，因此，在计算着色时也会考虑光线折损的影响。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-09.png?x-oss-process=image/resize,w_800" /></p><h1 id="技术细节">技术细节</h1><p>光线追踪的整体原理非常简单，下面，我们来考虑其中所涉及到的一些技术细节。</p><h2 id="交点判定原理">交点判定原理</h2><p>光线追踪中最重要的技术是交点判定，其中包含光线表示和几何表示两部分。</p><p>对于光线表示，我们只需要使用原点、方向向量即可进行表示，如下所示。</p><span class="math display">\[\begin{aligned}\vec{r}(t) = \vec{o} + t\vec{d}\end{aligned}\]</span><p>对于几何表示，在 <ahref="http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/">《计算机图形学基础（6）——几何》</a>中，我们提到隐式几何表示和显式几何表示两种。</p><h3 id="隐式几何的交点">隐式几何的交点</h3><p>隐式几何使用数学关系式表示，因此我们可以结合光线表示来求解方程组，即可计算得到交点，如下所示。其中，<spanclass="math inline">\(f\)</span>为隐式几何的数学关系式，将光线表示作为参数代入，求解 <spanclass="math inline">\(t\)</span> 即可得到交点。</p><span class="math display">\[\begin{aligned}f(\vec{o} + t\vec{d}) = 0\end{aligned}\]</span><h3 id="显式几何的交点">显式几何的交点</h3><p>显式几何直接或间接（通过参数映射的方式）定义点、线、面等元素集合，基本上最终都会转换成多边形网格来表示。这里，我们介绍平面和三角形两种情况下的交点判定技术。</p><h4 id="平面交点判定">平面交点判定</h4><p>对于任意一个平面，我们可以使用一个向量和一个点来定义。其中，向量是法向量，平面上任意一个点与<span class="math inline">\(\vec{p&#39;}\)</span>所构成的向量都与法向量垂直，两者的点积为0，因此得到如下所示的平面定义。</p><span class="math display">\[\begin{aligned}(\vec{p} - \vec{p&#39;}) \cdot \vec{N} = 0\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-10.png?x-oss-process=image/resize,w_800" /></p><p>此时，我们再结合平面定义和光线表示得到如下所示的方程组，进而解得<span class="math inline">\(t\)</span> 的值，即交点。</p><span class="math display">\[\begin{aligned}(\vec{o} + t \vec{d} - \vec{p&#39;}) \cdot \vec{N} = 0\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-11.png?x-oss-process=image/resize,w_800" /></p><h4 id="三角形交点判定">三角形交点判定</h4><p>对于三角形交点，我们可以通过 Moller Trumbore Algorithm快速求解。算法利用重心坐标定义三角形内的一个点，以此得到如下关系式。</p><span class="math display">\[\begin{aligned}\vec{o} + t \vec{d} = (1 - b_1 - b_2)\vec{P_0} + b_1\vec{P_1} +b_2\vec{P_2}\end{aligned}\]</span><p>根据重心坐标的特性，当 <span class="math inline">\(1- b_1 - b_2 =0\)</span> 时，点在三角形内，因此关系式中存在三个变量 <spanclass="math inline">\(t\)</span>、<spanclass="math inline">\(b_1\)</span>、<spanclass="math inline">\(b_2\)</span>。由于关系式中的向量都是三维空间中的向量，因此每个向量都由三个坐标值构成，可以进一步得到三个线性方程组，从而求解各个变量。</p><h2 id="交点判定加速">交点判定加速</h2><p>在实际应用中，三维空间可能包含非常多的物体，每个物体可能包含非常多的三角形。假如，我们要判断光线与一个物体的交点，那么需要遍历物体的每一个三角形，如下所示。很显然，这是一个非常耗时的操作，尤其是场景中物体非常多的情况下。对此，图形学中也有一些针对交点判定加速的优化方法。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-12.png?x-oss-process=image/resize,w_800" /></p><h3 id="包围盒">包围盒</h3><p><strong>包围盒</strong>（BoundingBox）的原理是使用一个简单的几何体包围一个复杂的物体，如果光线与包围盒没有交点，那么必然与内部物体没有交点，从而达到交点判定加速的目的。</p><h4 id="轴对齐包围盒">轴对齐包围盒</h4><p>包围盒通常是长方体。对于长方体，我们将它理解成<strong>三对不同的平行面形成的交集</strong>，在实际应用中，我们会使用一种特殊的长方体，即三对面各自与坐标系的轴对齐，因此称为<strong>轴对齐包围盒</strong>（Axis-Aligned Bounding Box，AABB）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-13.png?x-oss-process=image/resize,w_800" /></p><h4 id="交点判定">交点判定</h4><p>很显然，接下来的问题就是如何判断光线是否与轴对齐包围盒相交。这里，我们首先考虑2D 情况下的交点判定，然后进一步延伸至 3D 情况下的交点判定。</p><p>对于 2D 的情况，如下所示，分为三个步骤：</p><ul><li>考虑光线与 <span class="math inline">\(x_0\)</span>、<spanclass="math inline">\(x_1\)</span>两个面的交点，根据方程组可以计算出一组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>。</li><li>考虑光线与 <span class="math inline">\(y_0\)</span>、<spanclass="math inline">\(y_1\)</span>两个面的交点，根据方程组又可以计算出一组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>。</li><li>对于两组 <span class="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>，我们必须保证 <spanclass="math inline">\(t_{min}\)</span> 大于0，否则表示交点在光源的背后，没有实际意义。两组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>各自构成一个线段，我们只需要计算两者的交集，即可得到光线在长方形内的传播路径，而传播路径的两个端点正是光线与长方形的两个交点。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-14.png?x-oss-process=image/resize,w_800" /></p><p>对于 3D 的情况，我们只需要额外延伸一步即可。</p><ul><li>考虑光线与 <span class="math inline">\(z_0\)</span>、<spanclass="math inline">\(z_1\)</span>两个面的交点，根据方程组又可以计算出一组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>。</li><li>求解三组 <span class="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>各自构成的线段，求线段的交集即可得到光线在包围盒内的传播路径，传播路径的两个端点正是光线与包围盒的两个交点。</li></ul><p>最终求解得到的 <span class="math inline">\(t_{enter}\)</span> 和<span class="math inline">\(t_{exit}\)</span>的值可能存在一下几种情况：</p><ul><li>当 <span class="math inline">\(t_{exit}\)</span> &lt; 0时，表示包围盒在光源的背后，没有交点。</li><li>当 <span class="math inline">\(t_{enter}\)</span> &lt; 0 且 <spanclass="math inline">\(t_{exit}\)</span> &gt;= 0时，表示光线在包围盒的内部。</li><li>当且仅当 <span class="math inline">\(t_{enter}\)</span> &lt; <spanclass="math inline">\(t_{exit}\)</span>，<spanclass="math inline">\(t_{exit}\)</span> &gt;= 0时，光线和包围盒存在交点。</li></ul><h3 id="统一网格">统一网格</h3><p>统一网格（Uniformgrids）是包围盒技术的延伸，它对包围盒内部的空间进行预处理。</p><ul><li>将包围盒拆分成统一的立体网格</li><li>将与物体发生重叠的网格进行标识</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-15.png?x-oss-process=image/resize,w_800" /></p><p>在判断光线与包围盒内部物体的交点时，会先遍历所有网格。当网格与光线有交点时，会继续判断网格内的物体是否与光线有交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-16.png?x-oss-process=image/resize,w_800" /></p><p>关于网格的划分，不同的划分方法，加速效果存在差异。</p><ul><li>当只有一个网格时，没有加速效果。</li><li>当网格划分非常密集时，计算交点时遍历网格的开销会增大，甚至会出现性能降低的情况。</li></ul><p>相对而言，一个加速效果良好的网格划分经验是：网格的数量等于物体的数量乘以一个常数（经验值是27）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-17.png?x-oss-process=image/resize,w_800" /></p><p>然而，统一网格划分并不是万能的，它只适用于一些物体分布均匀的场景。如下所示的场景中，在餐桌上方存在大量没有物体的空间，此时使用统一网格划分的效果并不好。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-18.png?x-oss-process=image/resize,w_800" /></p><h3 id="空间划分">空间划分</h3><p>空间划分（Spatialpartitions）主要是为了解决空间中物体分布不均匀的问题，其主要有<strong>Oct-Tree</strong>、<strong>KD-Tree</strong>、<strong>BSP-Tree</strong>等几种技术。</p><p>Oct-Tree，又称八叉树，其基本原理是把立方体分割成八等份，递归进行分割，直到格子为空或者物体足够少。</p><p>KD-Tree，与 Oct-Tree类似，区别在于每次只将格子一分为二，总是沿着有个轴进行分割。相比于Oct-Tree，其节点数量的复杂度不会随着维度而指数型增长。</p><p>BSP-Tree，对空间一分为二，每次选择一个方向进行分割。相比于KD-Tree，其切割的方向并不一定与轴平行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-19.png?x-oss-process=image/resize,w_800" /></p><h4 id="kd-tree">KD-Tree</h4><p>这里我们着重介绍一下 KD-Tree 的工作原理。</p><p>首先，KD-Tree会对包围盒空间进行预处理，对包围盒空间进行二分，同时构建二叉树，如下所示。其中，非叶子节点表示二分之前的整体空间，它不会存储物体；叶子节点表示存储物体的真实空间。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-20.png?x-oss-process=image/resize,w_800" /></p><p>在进行交点判定时，本质上就是对二叉树进行先序遍历。对于上图中的例子，我们判定光线是否与整体的空间A 有交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-22.png?x-oss-process=image/resize,w_800" /></p><p>显然，上述例子中光线与空间 A 存在交点，那么它会节点 A 的两个叶子节点1 和 B分别进行交点判定，如下所示。如果交点存在则进一步判断内部物体是否与光线有交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-23.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-28.png?x-oss-process=image/resize,w_800" /></p><p>下图所示，当与空间 B 存在交点时，则进一步遍历空间 B 的子节点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-24.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-25.png?x-oss-process=image/resize,w_800" /></p><p>以此类推，空间 C与光线仍然存在交点，则继续遍历二叉树，直到判定光线与物体之间存在交点或不存在交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-26.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-27.png?x-oss-process=image/resize,w_800" /></p><p>直观而言，KD-Tree 确实能够有效加速交点判定。但是 KD-Tree也存在一些无法解决的问题，比如：</p><ul><li>存在无法判定的例子，比如：三角形反包围了包围盒。</li><li>同一物体被划分在多个包围盒中，会有重复判断的问题。</li></ul><h3 id="物体划分">物体划分</h3><p>针对空间划分无法解决的问题，图形学采用物体划分来解决。下面，我们来介绍物体划分的典型技术——BVH。</p><h4 id="bvh">BVH</h4><p>BVH（Bounding Volume Hierarchy）的整体原理与 KD-Tree类似，唯一的区别在于对于空间划分的方式不同。KD-Tree是对空间进行划分，BVH 是对物体进行划分。</p><p>如下所示，空间中的物体彼此之间非常靠近。如果我们采用 KD-Tree的划分方式，那么一个物体可能会包含在多个空间中，进而存在重复判定的情况。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-29.png?x-oss-process=image/resize,w_800" /></p><p>对此，BVH对物体进行划分，并重新计算包围盒，形成根节点的子节点。以此类推，最终在所有叶子节点存储物体列表。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-30.png?x-oss-process=image/resize,w_800" /></p><h2 id="交点渲染原理">交点渲染原理</h2><p>当我们获取到光线直射、反射至物体表面的交点之后，我们可以进一步计算这些交点的着色，从而完成渲染。</p><h3 id="光线追踪的问题">光线追踪的问题</h3><p>关于经典光线追踪，即 Whitted-Style RayTracing，对光线作出了如下假设。</p><ul><li><strong>光线只进行镜面反射和折射</strong></li><li><strong>光线在漫反射面停止弹射</strong></li></ul><p>对于第一种情况，经典光线追踪只能渲染镜面反射，无法渲染磨砂反射，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-33.png?x-oss-process=image/resize,w_800" /></p><p>对于第二种情况，对于漫反射物体，光线转播至表面时会停止弹射，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-34.png?x-oss-process=image/resize,w_800" /></p><p>既然经典光线追踪是存在问题的，那么我们该如何对交点进行渲染呢？答案是渲染方程。</p><h3 id="渲染方程定义">渲染方程定义</h3><p>关于渲染，我们在 <ahref="http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/">上一篇文章</a>中介绍了辐射度量学，文中我们提到了渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_r(p, {\omega}_r) = L_e(p, {\omega}_r) + \int_{H^2}L_i(p, {\omega}_i)f_r(p, {\omega}_i, {\omega}_r) (n \cdot {\omega}_i) d{\omega}_i\end{aligned}\]</span><h3 id="渲染方程展开">渲染方程展开</h3><p>渲染方程经过一系列变换可以简化成如下表达式。</p><span class="math display">\[\begin{aligned}l(u) = e(u) + \int l(v) K(u, v) dv\end{aligned}\]</span><p>我们将 <span class="math inline">\(K\)</span>作为反射操作符，可以进一步将简化为如下表达式，<spanclass="math inline">\(L\)</span> 是一个递归项。</p><span class="math display">\[\begin{aligned}L = E + KL\end{aligned}\]</span><p>我们的目的是求解 <span class="math inline">\(L\)</span>，前面说 <spanclass="math inline">\(K\)</span>是一个反射操作符，其实我们也可以将其理解为反射次数，反射次数越多，展开项越多，比如：<spanclass="math inline">\(K^2\)</span> 表示光在空间中弹射两次。</p><span class="math display">\[\begin{aligned}L = &amp; E + KL\\IL - KL = &amp; E\\(I - K)L = &amp; E\\L = &amp; (I - K)^{-1}E\\L = &amp; (I + K + K^2 + K^3 + ...)E\\L = &amp; E + KE + K^{2}E + K^{3}E + ...\\\end{aligned}\]</span><p>我们可以非常容易地理解展开后的渲染方程中的各个项，如下所示。全局光照由<strong>光源</strong>、<strong>直接光照</strong>、<strong>间接光照</strong>组合而成，其中光栅化只包含了光源和直接光照两部分，难以实现间接光照；光线追踪则包含了全局光照。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-31.png?x-oss-process=image/resize,w_800" /></p><p>下图所示，展示了全局光照包含不同数量的光照项的渲染对比效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-32.png?x-oss-process=image/resize,w_800" /></p><h3 id="求解理论基础">求解理论基础</h3><p>关于如何求解渲染方程，我们首先介绍两部分与之相关的内容。</p><ul><li>概率论基础</li><li>蒙特卡洛积分</li></ul><h4 id="概率论基础">概率论基础</h4><p>这里我们主要介绍概率、概率分布函数、期望等几个概念。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-35.png?x-oss-process=image/resize,w_800" /></p><p>上图所示是一个的连续的概率分布曲线 <span class="math inline">\(X \simp(x)\)</span>，横坐标表示目标值 <spanclass="math inline">\(x\)</span>，纵坐标表示目标值为 <spanclass="math inline">\(x\)</span> 的概率 <spanclass="math inline">\(p(x)\)</span>，即<strong>概率分布函数</strong>（Probability DistributionFunction，PDF），那么我们可以得到如下两个关系式：</p><ul><li>所有取值的概率之和为 <span class="math inline">\(1\)</span></li><li>期望为概率与目标值乘积的积分 <spanclass="math inline">\(E[X]\)</span></li></ul><span class="math display">\[\begin{aligned}\int p(x) dx = &amp; 1; &amp;&amp;  p(x) \geq 0\\E[X] = &amp; \int x p(x) dx\end{aligned}\]</span><h4 id="蒙特卡洛积分">蒙特卡洛积分</h4><p>假设我们希望求解如下所示的不定积分，那么该如何求解？答案是蒙特卡洛积分。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-36.png?x-oss-process=image/resize,w_800" /></p><p>蒙特卡洛积分（Monte CarloIntegration）的基本思想是：在积分域内不断采样 <spanclass="math inline">\(f(x)\)</span>，不断地与 <spanclass="math inline">\(ab\)</span>构成一个个长方形，然后对所有的长方形的面积之和求平均值。由此我们可以得到离散形式的蒙特卡洛方程，如下所示。</p><span class="math display">\[\begin{aligned}F_N = \frac{1}{N} \sum^{1}_{i=1} \frac{f(x_i)}{p(x_i)}\end{aligned}\]</span><p>我们将其进一步表示为更加通用的连续形式的蒙特卡洛方程，如下所示。</p><span class="math display">\[\begin{aligned}\int_{a}^{b} f(x) dx = \frac{1}{N} \sum_{i=1}^{N} \frac{f(x_i)}{p(x_i)}\end{aligned}\]</span><p>对于蒙特卡洛积分，当 <span class="math inline">\(N\)</span>越大，求解的结果越精准。</p><h3 id="渲染方程求解">渲染方程求解</h3><p>在了解了概率论基础和蒙特卡洛积分之后，我们来正式求解渲染方程。</p><h4 id="求解过程分析">求解过程分析</h4><p>假设，我们只考虑一个像素点的着色过程，如下图所示。其中，<spanclass="math inline">\({\omega}_o\)</span>为观测方向，即从着色点到观测点的方向；<spanclass="math inline">\({\omega}_i\)</span>为光线入射方向，即从光源到着色点的方向。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-37.png?x-oss-process=image/resize,w_800" /></p><p>同时，我们先忽略着色点本身的发光项，那么可以得到一个简化的渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_o(p, {\omega}_o) = \int_{H^2} L_i(p, {\omega}_i) f_r(p, {\omega}_i,{\omega}_o) (n \cdot {\omega}_i) d{\omega}_i\end{aligned}\]</span><p>我们将渲染等价为在半球面上进行采样。因此，任意一点的采样概率 <spanclass="math inline">\(p({\omega}_i)\)</span> 为 <spanclass="math inline">\(1/2\pi\)</span>，即概率分布函数（PDF）。对应，采样值<span class="math inline">\(f({\omega}_i)\)</span> 为 <spanclass="math inline">\(L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o)(n \cdot{\omega}_i)\)</span>。由此可以用蒙特卡洛积分来求解渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_o(p, {\omega}_o) = &amp;\int_{H^2}L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o) (n \cdot{\omega}_i) d{\omega}_i\\\approx &amp;\frac{1}{N} \sum_{i=1}^{N} \frac{f({\omega}_i)}{p({\omega}_i)}\\\approx &amp;\frac{1}{N} \sum_{i=1}^{N} \frac{L_i(p, {\omega}_i) f_r(p, {\omega}_i,{\omega}_o) (n \cdot {\omega}_i) }{p({\omega}_i)}\end{aligned}\]</span><p>根据上述的渲染方程的求解关系式，我们可以实现对应的伪代码，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-38.png?x-oss-process=image/resize,w_800" /></p><p>上述，我们只处理了光的一次弹射，而全局光照还包括二次弹射、三次弹射...我们该如何处理呢？</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-39.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，我们希望计算 Q 点反射到 P点的光线。对此，我们可以转换一下思路：Q 点反射到 P 点的光线，不就等于从P 点观测 Q 点，Q点的着色吗？于是全局光照就转换成了一个递归着色的过程。如下所示，我们加入了处理全局光照的递归着色。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-40.png?x-oss-process=image/resize,w_800" /></p><p>至此，着色算法的整体框架已经实现了，但是还存在两个问题：</p><ul><li>分治爆炸问题</li><li>无限递归问题</li></ul><h4 id="分治爆炸问题">分治爆炸问题</h4><p>在上述算法实现中，对于每一个点的着色，我们都会采样各个方向，而每一个方向所经过的反射点又会采样各个方向。如果我们对于每个点采样100 个方向，那么在下一次递归中将会采样 10000个方向，依次类推，产生分治爆炸问题。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-41.png?x-oss-process=image/resize,w_800" /></p><p>那么如何解决这个问题？很显然，只有当采样数量为 1时，递归时才不会出现分治爆炸问题。在计算机图形学中，对于每个着色点，只通过一条射线进行光线追踪的方式被称为<strong>路径追踪</strong>（Path Tracing）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-42.png?x-oss-process=image/resize,w_800" /></p><p>如下所示，为解决了分支爆炸问题的着色算法。我们不再采样各个方向，而是随机采样一个方向，进而计算着色。然而，我们知道在蒙特卡洛积分中，采样数越小，准确性越低。算法中将采样数降至1，很显然，会出现很大的噪声。那么这又该如何解决呢？</p><p>对此，有一种方法另辟蹊径：<strong>每个像素生成多条光线，进行多次路径追踪，并求解平均值</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-43.png?x-oss-process=image/resize,w_800" /></p><p>如下所示，我们定义了一个 <code>ray_generation</code>方法，它以相机位置和像素点作为参数，内部对这个像素点进行多次路径追踪，即调用<code>shade</code> 方法，最终求解平均值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-44.png?x-oss-process=image/resize,w_800" /></p><h4 id="无限递归问题">无限递归问题</h4><p>对于无限递归问题，很显然，我们必须要找到一个停止递归的策略。对此，图形学借鉴了<strong>俄罗斯轮盘赌</strong>（Russion Roulette，RR）的思想。</p><p>俄罗斯轮盘赌的基本原理是设定一个概率值 <span class="math inline">\(0&lt; P &lt; 1\)</span>。</p><ul><li>射出光线的概率为 <spanclass="math inline">\(P\)</span>，由此返回的着色结果为 <spanclass="math inline">\(L_0/P\)</span></li><li>不射出光线的概率为 <spanclass="math inline">\(1-P\)</span>，由此返回的着色结果为 <spanclass="math inline">\(0\)</span></li></ul><p>使用这种方式，我们仍然可以期望得到 <spanclass="math inline">\(L_0\)</span>，如下所示为俄罗斯轮盘赌的期望公式.</p><span class="math display">\[\begin{aligned}E = P * (L_0 / P) + (1 - P) * 0 = L_0\end{aligned}\]</span><p>于是，我们可以进一步优化着色算法，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-45.png?x-oss-process=image/resize,w_800" /></p><h4 id="光源采样问题">光源采样问题</h4><p>经过上述改进，着色算法是正确了，但是它并不高效。如下所示，像素采样必须达到一定阈值才能得到相对高质量的结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-46.png?x-oss-process=image/resize,w_800" /></p><p>这里的根本原因在于均匀采样，其中只有极少数方向能够打到光源，大多数方向则浪费掉了。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-47.png?x-oss-process=image/resize,w_800" /></p><p>对此，我们可以考虑直接对光源进行采样。考虑到我们在求解蒙特卡洛积分时是在立体角进行采样，因此我们将空间中的面光源投影到球面上，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-48.png?x-oss-process=image/resize,w_800" /></p><p>我们得到立体角和光源微分面积的关系如下所示。</p><span class="math display">\[\begin{aligned}d\omega = \frac{dA cos{\theta}&#39;}{||x&#39; - x||^2}\end{aligned}\]</span><p>然后，我们微分立体角代入渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_o(p, {\omega}_o) = &amp;\int_{H^2}L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o) cos\thetad{\omega}_i\\= &amp;\int_{H^2} L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o)\frac{cos\theta cos{\theta}&#39;}{||x&#39; - x||^2} dA\end{aligned}\]</span><p>现在，我们认为着色结果来源于两部分：</p><ul><li>光源的直接作用：直接采样光源，无需俄罗斯轮盘赌</li><li>光源的间接作用：反射、漫反射，需要俄罗斯轮盘赌</li></ul><p>由此，我们结合两部分得到如下所示的优化算法。当然，对于光源的直接作用，我们需要判断光源与着色点之间是否存在遮挡，这一点一定要注意。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-49.png?x-oss-process=image/resize,w_800" /></p><h1 id="总结">总结</h1><p>本文我们主要介绍了光线追踪的原理。首先，我们我们介绍了光线追踪的基本原理，其主要包括：视线生成和像素着色两个阶段。</p><p>然后，我们介绍了经典光线追踪技术，也称为 Whitted-Style光线追踪，其引入了间接光照的处理。</p><p>在光线追踪中，主要设计两个关键技术，分别是交点判定和交点渲染。对于交点判定，我们介绍了包围盒原理、统一网格、空间划分、物体划分等技术；对于交点渲染，我们在经典光线追踪的基础上引入了漫反射的处理，整体围绕渲染方程进行展开，使用蒙特卡洛积分进行求解。</p><p>在实现渲染方程算法的过程中，我们遇到了分治爆炸、无限递归、光源采样等问题，对此我们也依次进行了处理。最终实现了一个完整的着色算法。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们介绍了在游戏领域中广泛使用的实时渲染技术——光栅化，本文我们来介绍一下在特效领域中广泛使用的离线渲染技术——光线追踪。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Whitted-Stype Ray Tracing" scheme="http://chuquan.me/tags/Whitted-Stype-Ray-Tracing/"/>
    
    <category term="交点判定" scheme="http://chuquan.me/tags/%E4%BA%A4%E7%82%B9%E5%88%A4%E5%AE%9A/"/>
    
    <category term="交点渲染" scheme="http://chuquan.me/tags/%E4%BA%A4%E7%82%B9%E6%B8%B2%E6%9F%93/"/>
    
    <category term="包围盒" scheme="http://chuquan.me/tags/%E5%8C%85%E5%9B%B4%E7%9B%92/"/>
    
    <category term="轴对齐包围盒" scheme="http://chuquan.me/tags/%E8%BD%B4%E5%AF%B9%E9%BD%90%E5%8C%85%E5%9B%B4%E7%9B%92/"/>
    
    <category term="KD-Tree" scheme="http://chuquan.me/tags/KD-Tree/"/>
    
    <category term="BVH" scheme="http://chuquan.me/tags/BVH/"/>
    
    <category term="蒙特卡洛积分" scheme="http://chuquan.me/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86/"/>
    
    <category term="路径追踪" scheme="http://chuquan.me/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"/>
    
    <category term="光线追踪" scheme="http://chuquan.me/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
    <category term="俄罗斯轮盘赌" scheme="http://chuquan.me/tags/%E4%BF%84%E7%BD%97%E6%96%AF%E8%BD%AE%E7%9B%98%E8%B5%8C/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（7）——辐射度量学</title>
    <link href="http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/"/>
    <id>http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/</id>
    <published>2024-04-20T14:11:09.000Z</published>
    <updated>2024-04-20T14:13:37.201Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍光线追踪之前，我们先来学习一下其所涉及的重要内容——辐射度量学。由于该内容相对独立，这里单开一篇文章来进行介绍。</p><span id="more"></span><h1 id="概述">概述</h1><p>本质上，辐射度量学是在物理层面准确定义光照的方法。在 <ahref="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">《计算机图形学基础（5）——着色》</a>一文中我们提到了光照强度，我们将半径为 <spanclass="math inline">\(r\)</span> 时，对应的球面的一个点的光照强度为<spanclass="math inline">\(I\)</span>，那么具体它的单位是什么呢？在了解辐射度量学之后，这个疑问就能得到解答。</p><p>在辐射度量学中涉及了很多相关术语，这里我将它们分为两部分进行介绍。</p><h1 id="几何">几何</h1><p>首先我们来看几何的相关术语，主要包含以下几个：</p><ul><li><strong>角（Angles）</strong></li><li><strong>立体角（Solid Angles）</strong></li><li><strong>微分立体角（Differential Solid Angles）</strong></li></ul><h2 id="角">角</h2><p>在平面几何中，角的定义是弧长与半径的比值，其中 <spanclass="math inline">\(\theta\)</span> 表示角，<spanclass="math inline">\(l\)</span> 表示弧长，<spanclass="math inline">\(r\)</span> 表示圆的半径，如下所示。圆自身的角度为<span class="math inline">\(2\pi\)</span>。</p><span class="math display">\[\begin{aligned}\theta = \frac{l}{r}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-01.png?x-oss-process=image/resize,w_800" /></p><h2 id="立体角">立体角</h2><p>在立体几何中，立体角的定义则是弧面积与半径平方的比值，其中 <spanclass="math inline">\(\Omega\)</span> 表示立体角，<spanclass="math inline">\(A\)</span> 表示弧面积，<spanclass="math inline">\(r\)</span>表示球的半径，如下所示。球自身的立体角为 <spanclass="math inline">\(4\pi\)</span>。立体角主要用于描述空间中的一个锥体的张开角度。</p><span class="math display">\[\begin{aligned}\Omega = \frac{A}{r^2}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-02.png?x-oss-process=image/resize,w_800" /></p><h2 id="微分立体角">微分立体角</h2><p>微分立体角通过两个角度来定义球面上的一个唯一的方向，如下所示。其中，两个角度分别是：</p><ul><li>与 <span class="math inline">\(z\)</span> 轴形成的夹角 <spanclass="math inline">\(\theta\)</span></li><li>绕 <span class="math inline">\(z\)</span> 轴形成的夹角 <spanclass="math inline">\(\phi\)</span></li></ul><p>计算微分立体角，我们首先两个角度在球面所形成方向所占据的单位面积<spanclass="math inline">\(dA\)</span>。按照微分的思想，我们认为该面积等同于矩形的面积，因此我们要计算它的长和宽，分别为<span class="math inline">\(rsin{\theta}d\phi\)</span> 和 <spanclass="math inline">\(rd\theta\)</span>，由此可以计算该单位面积。从而进一步求解微分立体角<span class="math inline">\(d\omega\)</span>，如下所示。</p><span class="math display">\[\begin{aligned}dA = &amp;(r d\theta)(r sin{\theta} d\phi) = r^2 sin\theta d\theta d\phi\\d\omega = &amp;\frac{dA}{r^2} = sin\theta d\theta d\phi\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-03.png?x-oss-process=image/resize,w_800" /></p><p>在辐射度量学中，我们通常用 <spanclass="math inline">\(\omega\)</span>来表示三维空间中的一个方向。我们可以使用 <spanclass="math inline">\(\theta\)</span> 和 <spanclass="math inline">\(\phi\)</span> 来确定其方向，并且还可以结合 <spanclass="math inline">\(d\theta\)</span> 和 <spanclass="math inline">\(d\phi\)</span> 来计算其微分立体角。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-04.png?x-oss-process=image/resize,w_800" /></p><h1 id="光学物理">光学物理</h1><p>在辐射度量学中，主要涉及以下几个光学物理相关术语。</p><ul><li><strong>辐射能量（Radiant Energy）</strong></li><li><strong>辐射通量（Radiant Flux）</strong></li><li><strong>辐射强度（Radiant Intensity）</strong></li><li><strong>辐射照度（Irradiance）</strong></li><li><strong>辐射亮度（Radiance）</strong></li></ul><h2 id="辐射能量">辐射能量</h2><p>辐射能量（Radiant Energy）表示电磁辐射的能量，用符号 <spanclass="math inline">\(Q\)</span> 表示，以 <strong>焦耳</strong>（J =Joule）为单位。</p><span class="math display">\[\begin{aligned}Q\\unit: [J = Joule]\end{aligned}\]</span><h2 id="辐射通量">辐射通量</h2><p>辐射通量（RadiantFlux）表示单位时间内流通（发射、反射、传输、接收）的能量，用符号 <spanclass="math inline">\(\Phi\)</span> 表示，以 <strong>瓦特</strong>（W =Watt）或 <strong>流明</strong>（lm =lumen）为单位。<strong>在实际应用中，我们经常将辐射通量称为能量，本质上是因为辐射通量可以结合时间快速计算出辐射能量</strong>。</p><span class="math display">\[\begin{aligned}\Phi = \frac{dQ}{dt}\\unit: [W = Watt]/[lm = lumen]\end{aligned}\]</span><p>在光学物理中，我们也将辐射通量定义为<strong>单位时间辐射出光子的数量</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-05.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射强度">辐射强度</h2><p>辐射强度（Radiant Intensity）表示<strong>单位立体角的辐射通量</strong>。其中 <spanclass="math inline">\(\Phi\)</span> 表示辐射通量，<spanclass="math inline">\(\omega\)</span>表示立体角。我们可以用辐射强度描述一束光线，即形成一个锥体角度的光线，在单位时间内流通的能量。</p><span class="math display">\[\begin{aligned}I(\omega) = \frac{d\Phi}{d\omega}\\unit:[\frac{W}{sr}][\frac{lm}{sr} = cd = candela]\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-06.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射照度">辐射照度</h2><p>辐射照度（Irradiance）表示<strong>单位（正交）面积的辐射通量</strong>。注意，这里计算的辐射通量必须与面垂直，如果光照不垂直于面，则计算其垂直分量。其中<span class="math inline">\(\Phi\)</span> 表示辐射通量，<spanclass="math inline">\(A\)</span> 表示正交面积，$$ 表示位置。</p><span class="math display">\[\begin{aligned}E(p) = \frac{d\Phi(p)}{dA}\\unit: [\frac{W}{m^2}][\frac{lm}{m^2} = lux]\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-07.png?x-oss-process=image/resize,w_800" /></p><p>此时，我们回顾 <ahref="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">《计算机图形学基础（5）——着色》</a>文中的兰伯特余弦定理，可以计算辐射照度，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-08.png?x-oss-process=image/resize,w_800" /></p><p>同样，我们还可以计算空间中一个点光源在空间中辐射的衰减到底是什么？如下所示，其实我们可以发现辐射照度随着半径增加而指数级衰减，辐射强度并没有发生变化。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-09.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射亮度">辐射亮度</h2><p>辐射亮度（Radiance）表示<strong>单位立体角、单位（正交）面积的辐射通量</strong>。辐射亮度一般用于描述光线在传输过程中的属性。我们可以用辐射亮度来描述某个面光源在某个（锥形）方向的辐射通量。</p><p>从定义上看，辐射亮度在立体角、正交面积两个维度做了两次微分。其中，<spanclass="math inline">\(cos\theta\)</span>表示光线在单位面积垂直方向上的角度分量，<spanclass="math inline">\(p\)</span> 表示位置，<spanclass="math inline">\(\omega\)</span> 表示立体角。</p><span class="math display">\[\begin{aligned}L(p, \omega) = \frac{d^2\Phi(p, \omega)}{d{\omega}dA cos\theta}\\unit: [\frac{W}{sr m^2}][\frac{cd}{m^2} = \frac{lm}{sr m^2} = nit]\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-10.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们回顾一下辐射强度和辐射照度的定义。</p><ul><li>辐射强度：单位立体角的辐射通量。</li><li>辐射照度：单位（正交）面积的辐射通量</li></ul><p>结合辐射强度和辐射照度的定义，我们可以将辐射亮度的定义进行转换，<strong>单位立体角的辐射照度</strong>或<strong>单位（正交）面积的辐射强度</strong>。这两种定义正好可以应用到两种不同方向的辐射亮度，分别是<strong>入射辐射亮度</strong> 和 <strong>出射辐射亮度</strong>。</p><h3 id="入射辐射亮度">入射辐射亮度</h3><p>入射辐射亮度（IncidentRadiance）即单位立体角的辐射照度。我们可以理解从某个方向向一个面进行辐射，该面所接收的辐射照度，如下图所示。如果我们进一步考虑来自四面八方的辐射，比如环境光，那么可以计算得到这个面所接收的全部辐射照度。</p><span class="math display">\[\begin{aligned}L(p, \omega) = \frac{dE{p}}{d{\omega} cos\theta}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-11.png?x-oss-process=image/resize,w_800" /></p><h3 id="出射辐射亮度">出射辐射亮度</h3><p>出射辐射亮度（ExitingRadiance）即单位（正交）面积的辐射强度。我们可以理解一个面向某个方向进行辐射，该方向所发射的辐射强度，如下所示。如果我们进一步考虑一个面向四面八方的辐射，那么可以计算得到这个面所发射的全部辐射强度。</p><span class="math display">\[\begin{aligned}L(p, \omega) = \frac{dI(p, \omega)}{dA cos\theta}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-10.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射照度-vs.-辐射亮度">辐射照度 vs. 辐射亮度</h2><p>在图形学中，辐射照度（Irradiance）和辐射亮度（Radiance）用的非常多。在下图所示的场景中，辐射照度表示<span class="math inline">\(dA\)</span> 接收的所有能量；辐射亮度表示<span class="math inline">\(dA\)</span>从某个方向接收的能量。相比而言，辐射亮度是一个更细粒度的分析属性。这样，我们就把辐射照度和辐射亮度联系起来了。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-12.png?x-oss-process=image/resize,w_800" /></p><p>对于上图所示的场景，我们可以计算得到某个位置的辐射照度，如下所示，其中<span class="math inline">\(H^2\)</span> 表示单位半球面积。</p><span class="math display">\[\begin{aligned}dE(p, \omega) = &amp;L_{i}(p, \omega) cos\theta d\omega\\E(p) = &amp;\int_{H^2} L_{i}(p, \omega) cos\theta d{\omega}\end{aligned}\]</span><h1 id="应用">应用</h1><h2 id="双反射分布函数">双反射分布函数</h2><p>已知入射光线的能量和角度，当辐射到物体表面后，光线会向各个角度反射，且各个角度反射的能量是不同的。双反射分布函数（BidirectionalReflectance DistributionFunction，BRDF）就是用于计算这种场景下各个角度的反射能量。</p><p>如下所示，是一个入射和反射的场景，我们从辐射度量学的角度分别进行分析。</p><ul><li>入射阶段：当入射光线从 <spanclass="math inline">\({\omega}_i\)</span>角度辐射到物体表面的一个位置时，可以认为该位置吸收了所有的光线能量，用辐射照度来表示，即<span class="math inline">\(dE({\omega}_i)\)</span>。</li><li>反射阶段：可以认为该位置将光线能量向各个方向进行辐射。对于方向 <spanclass="math inline">\({\omega}_i\)</span>的光线能量，用辐射亮度来表示，即 <span class="math inline">\(dL_r(x,{\omega}_r)\)</span>。</li></ul><span class="math display">\[\begin{aligned}dE({\omega}_i) = &amp;L({\omega}_i) cos{\theta}_i d{\omega}_i\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-13.png?x-oss-process=image/resize,w_800" /></p><p>本质上，BRDF 就是表示由入射方向 <spanclass="math inline">\({\omega}_i\)</span> 向反射方向 <spanclass="math inline">\({\omega}_r\)</span> 辐射能量的比例函数 <spanclass="math inline">\(fr({\omega}_i \rightarrow{\omega}_r)\)</span>，其定义如下所示。</p><span class="math display">\[\begin{aligned}BRDF: f_r({\omega}_i \rightarrow {\omega}_r) =\frac{dL_r({\omega}_r)}{dE_i({\omega}_i)} =\frac{dL_r({\omega}_r)}{L_i({\omega}_i) cos{\theta}_i d{\omega}_i}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-14.png?x-oss-process=image/resize,w_800" /></p><p>在实际应用中，对于镜面反射，BRDF定义反射方向包含所有能量，其他方向均为 0；对于漫反射，BRDF定义所有方向的能量分布相同。事实上，BRDF就是描述了光线和物体表面的作用，也就是决定了物体的材质。</p><h2 id="反射方程">反射方程</h2><p>基于 BRDF，我们可以进一步推导出 <strong>反射方程</strong>（TheReflection Equation）。</p><p>由于 BRDF 定义了一个入射方向 <spanclass="math inline">\({\omega}_i\)</span> 向一个反射方向 <spanclass="math inline">\({\omega}_r\)</span>反射时的能量比例。那么，我们可以通过积分计算所有方向对一个反射方向 <spanclass="math inline">\({\omega}_r\)</span>的能量聚合。因此，我们可以推导得出如下所示的反射方程。</p><span class="math display">\[\begin{aligned}L_r(p, {\omega}_r) = \int_{H^2}f_r(p, {\omega}_i \rightarrow {\omega}_r)L_i(p, {\omega}_i) cos{\theta}_i d{\omega}_i\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-14.png?x-oss-process=image/resize,w_800" /></p><h2 id="渲染方程">渲染方程</h2><p>基于反射方程，我们还可以进一步推导出 <strong>渲染方程</strong>（TheRendering Equation）。</p><p>这里我们只需要额外考虑物体本身会发光的情况，于是增加一个发光项即可得到渲染方程，如下所示。其中，<spanclass="math inline">\(cos{\theta}_i\)</span>转换成了法向量和入射方向的点积 <span class="math inline">\(n \cdot{\omega}_i\)</span>。现代图形学中，所有基于表面反射的渲染都是基于该渲染方程实现的。</p><span class="math display">\[\begin{aligned}L_r(p, {\omega}_r) = L_e(p, {\omega}_r) + \int_{H^2} L_i(p, {\omega}_i)f_r(p, {\omega}_i, {\omega}_r)(n \cdot {\omega}_i) d{\omega}_i\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文我们主要介绍了辐射度量学中的几个概念：辐射能量、辐射通量、辐射强度、辐射照度、辐射亮度等。基于这些概念，我们引入了BRDF 的定义。然后依次推导出反射方程和渲染方程。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在介绍光线追踪之前，我们先来学习一下其所涉及的重要内容——辐射度量学。由于该内容相对独立，这里单开一篇文章来进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Radiance" scheme="http://chuquan.me/tags/Radiance/"/>
    
    <category term="Irradiance" scheme="http://chuquan.me/tags/Irradiance/"/>
    
    <category term="Intensity" scheme="http://chuquan.me/tags/Intensity/"/>
    
    <category term="立体角" scheme="http://chuquan.me/tags/%E7%AB%8B%E4%BD%93%E8%A7%92/"/>
    
    <category term="微分立体角" scheme="http://chuquan.me/tags/%E5%BE%AE%E5%88%86%E7%AB%8B%E4%BD%93%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（6）——几何</title>
    <link href="http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/"/>
    <id>http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/</id>
    <published>2024-04-10T15:10:24.000Z</published>
    <updated>2024-04-11T01:02:20.747Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们介绍了观测变换、光栅化、着色等几个图形学中比较复杂的主题，本文我们稍微放松一下，介绍一个相对比较简单的主题——几何。</p><span id="more"></span><h1 id="几何表示">几何表示</h1><p>通过图形学建模表示现实生活中的各种物体，要解决的第一个问题就是如何定义物体形状，而这就涉及到了几何。</p><p>物体的形状非常多，那么如何通过几何方法表示物体呢？对此，图形学中定义了两种几何表示方法：</p><ul><li><strong>隐式几何表示</strong>（Implicit Representations ofGeometry）</li><li><strong>显示几何表示</strong>（Explicit Representations ofGeometry）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-01.png?x-oss-process=image/resize,w_800" /></p><h2 id="隐式几何表示">隐式几何表示</h2><p>隐式几何表示是一种 <strong>使用数学关系式来描述几何形状</strong>的方法，而不是直接描述其顶点和边界等元素。在隐式几何表示法中，几何形状被定义为方程的解集，即满足某些条件的一组点的集合。比如，下面的关系式定义了一个圆环结构。</p><span class="math display">\[\begin{aligned}f(x, y, z) = (2 - \sqrt{x^2 + y^2})^2 + z^2 - 1\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-02.png?x-oss-process=image/resize,w_800" /></p><p>隐式几何表示的常用技术有以下这些：</p><ul><li><strong>代数曲面</strong>（Algebraic Surface）</li><li><strong>构造实体几何</strong>（Constructive Solid Geometry）</li><li><strong>距离函数</strong>（Distance Function）</li><li><strong>水平集</strong>（Level Set）</li><li><strong>分形</strong>（Fractals）</li></ul><p>下面，我们来介绍一下这些常用的隐式几何表示技术。</p><h3 id="代数曲面">代数曲面</h3><p>代数曲面是通过一组参数方程定义的曲线和表面。它适用于一些简单的，可以使用数学关系式表示的几何体。下图所示，这些几何体就比较适合使用代数曲面来表示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-04.png?x-oss-process=image/resize,w_800" /></p><h3 id="构造实体几何">构造实体几何</h3><p>构造实体几何是通过布尔运算来组合不同的几何体。下图所示，一些复杂的几何体可以通过简单的几何体来组合构造。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-05.png?x-oss-process=image/resize,w_800" /></p><h3 id="距离函数">距离函数</h3><p>距离函数描述空间中任何一个点到几何体表面的最小距离。一种特殊的距离函数，符号距离函数（SignedDistanceFunction），其以空间中任意一个点作为输入，根据距离函数的返回值，可以进行判断：</p><ul><li>当距离函数的值大于 0，表示点在几何体外部</li><li>当距离函数的值小于 0，表示点在几何体内部</li><li>当距离函数的值等于 0，表示点在几何体表面</li></ul><h3 id="水平集">水平集</h3><p>对于表面规则的几何体，我们可以使用距离函数来表示；对于表面复杂的几何体，距离函数难以适用，此时，我们可以使用水平集来表示。</p><p>水平集的核心思想与距离函数一样，区别在于：距离函数使用通过输入空间点来计算该点到几何体表面的距离，水平集则存储了一系列距离值，我们可以通过插值法找到距离为0 的位置，拟合出一条曲面用于表示几何体的表面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-06.png?x-oss-process=image/resize,w_800" /></p><h3 id="分形">分形</h3><p>分形，类似于递归，即局部和整体的形状相似，如下图所示。分形通过迭代函数系统（IFS）来生成。IFS是一种迭代的过程，该过程将函数反复应用于某个起始点或起始数据。这些函数通常是缩放、旋转、平移等操作，同时保持自相似性。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-07.png?x-oss-process=image/resize,w_800" /></p><!--缺点：难以判断哪些点属于关系式--><!--优点：容易判断点是否在几何的表面--><h2 id="显示几何表示">显示几何表示</h2><p>显式几何表示是一种<strong>直接或间接（通过参数映射的方式）定义点、线、面等元素集合</strong>的方法。在显式几何表示中，各元素的位置通常由坐标值直接给出，各元素之间的关系通常由数据结构来表示。比如，下面的关系式通过参数映射的方式间接定义了点的集合。</p><span class="math display">\[\begin{aligned}f: R^2 \rightarrow &amp;R^3\\(u, v) \rightarrow &amp;(x, y, z)\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-03.png?x-oss-process=image/resize,w_800" /></p><p>显式几何表示的常用技术有以下这些：</p><ul><li><strong>点云</strong>（Point Cloud）</li><li><strong>网格模型</strong>（Polygon Mesh）</li></ul><p>下面，我们来介绍一下这两种显式几何表示技术。</p><!--缺点：难以判断是否在内部或外部--><h3 id="点云">点云</h3><p>点云是显式几何表示中最简单的技术，其核心思想是使用大量的点来表示几何体的表面。点的密度越高，几何体的精度越高。由于点云的缺点很明显，内存占用大，因此一般会被再次转换成多边形网格。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-08.png?x-oss-process=image/resize,w_800" /></p><h3 id="多边形网格">多边形网格</h3><p>多边形网格是图形学中最常用的几何表示方法，它存储点和多边形（一般是三角形或四边形），这种形式非常容易处理、模拟、采样。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-09.png?x-oss-process=image/resize,w_800" /></p><p>在 3D 建模中，我们经常会用到 <code>.obj</code>格式的模型文件，其本质上是一个文本文件，记录了顶点、法线、纹理坐标、连接关系，由此构成几何体的形状。如下所示，是一个立方体结构的表示。</p><ul><li><code>v</code> 表示顶点</li><li><code>vn</code> 表示法线（多了两条是因为建模误差）</li><li><code>vt</code> 表示纹理坐标</li><li><code>f</code> 表示面，比如 <code>f 5/1/1 1/2/1 4/3/1</code>表示三角形面是由第 5、1、4 个顶点组成，三个点的纹理坐标是第 1、2、3对应的纹理坐标，面的法线是第 1 条法线。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-10.png?x-oss-process=image/resize,w_800" /></p><h1 id="曲线">曲线</h1><p>曲线（Curves）在图形学中应用非常广泛，比如：相机的拍摄路径、物体的移动路径、动画曲线、矢量字体等。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="贝塞尔曲线">贝塞尔曲线</h2><p>贝塞尔曲线是通过一系列控制点进行定义的曲线。如下图所示，4个控制点定义了一条贝塞尔曲线，起始方向沿着 <spanclass="math inline">\(p_0p_1\)</span>，结束方向沿着 <spanclass="math inline">\(p_2p_3\)</span>，曲线不必经过所有控制点，但必须经过起始点和结束点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-12.png?x-oss-process=image/resize,w_800" /></p><!--特性：--><!--- 必须过起点和终点--><!--- 仿射不变性--><!--- 凸包性质--><h3 id="绘制算法">绘制算法</h3><p>那么控制点是如何影响曲线的呢？贝塞尔曲线绘制算法的原理是什么呢？</p><p>贝塞尔曲线的绘制算法是 <strong>De Casteljau'sAlgorithm</strong>，算法的基本思想是利用线性插值的原理，将高阶贝塞尔曲线转化为一阶贝塞尔曲线的组合。对于一个N阶贝塞尔曲线，首先构建一系列的二维点，然后在这些点上构建线段，以此类推，直到计算出贝塞尔曲线上的一个点。重复这个过程就可以得到贝塞尔曲线上的所有点，从而绘制出完整的贝塞尔曲线。</p><p>下面，我们以 3 个控制点绘制贝塞尔曲线的例子来进行介绍。</p><p>N 个控制点绘制的贝塞尔曲线，称为 <strong>N-1阶贝塞尔曲线</strong>。如下所示，我们定义了 3个控制点，由此绘制的贝塞尔曲线称之为<strong>二阶贝塞尔曲线</strong>（Quadratic Bezier）。对于这 3个控制点，我们首先对相邻控制点进行连线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-13.png?x-oss-process=image/resize,w_800" /></p><p>我们定义一个变量 <code>t</code>，其值的范围为<code>[0, 1]</code>，作为算法的输入值。当 <code>t = 0</code>时，表示贝塞尔曲线起始点的输入值，当 <code>t = 1</code>时，表示贝塞尔曲线结束点的输入值。随后，我们在控制点所构成的各个连线上定义一个点，这个点的位置取决于<code>t</code> 的值，即一个比例值。比如：<spanclass="math inline">\(b_0b_1\)</span> 连线上定义点 <spanclass="math inline">\(b_{0}^{1}\)</span>，<spanclass="math inline">\(b_1b_2\)</span> 连线上定义点 <spanclass="math inline">\(b_{1}^{1}\)</span>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-14.png?x-oss-process=image/resize,w_800" /></p><p>然后，我们继续对 <span class="math inline">\(b_{0}^{1}\)</span> 和<span class="math inline">\(b_{1}^{1}\)</span>进行连线，并按照上述规则，在 <spanclass="math inline">\(b_{0}^{1}b_{1}^{1}\)</span> 连线上定义点 <spanclass="math inline">\(b_{0}^{2}\)</span>，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-15.png?x-oss-process=image/resize,w_800" /></p><p>当新定义的点只有一个时，我们可以将 <code>t</code> 的值逐步从<code>0</code> 变到 <code>1</code>。在这个过程中，<spanclass="math inline">\(b_{0}^{1}\)</span>、<spanclass="math inline">\(b_{0}^{2}\)</span>、<spanclass="math inline">\(b_{1}^{1}\)</span> 的位置都会随着 <code>t</code>的变化而变化。对于最终的贝塞尔曲线，我们只需要关注最后定义的点 <spanclass="math inline">\(b_{0}^{2}\)</span> 的路径即可，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-16.png?x-oss-process=image/resize,w_800" /></p><p>当我们扩展至更多控制点时，比如 4个控制点时，我们仍然按照上述规则来处理，将高阶贝塞尔曲线转化为一阶贝塞尔曲线的组合，最终绘制曲线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-17.png?x-oss-process=image/resize,w_800" /></p><h3 id="代数公式">代数公式</h3><p>对于上述通过 3个控制点绘制贝塞尔曲线，我们可以用代数的方式来表示，如下所示。</p><span class="math display">\[\begin{aligned}b_{0}^{1}(t) = &amp;(1 - t)b_0 + tb_1\\b_{1}^{1}(t) = &amp;(1 - t)b_1 + tb_2\\b_{0}^{2}(t) = &amp;(1 - t)b_{0}^{1} + tb_{1}^{1}\\b_{0}^{2}(t) = &amp;(1 - t)^2b_0 + 2t(1 - t)b_1 + t^2b_2\end{aligned}\]</span><p>由此，我们可以推导出 N 阶贝塞尔曲线的代数公式，如下所示。其中，<spanclass="math inline">\(n\)</span> 表示 N 阶贝塞尔曲线，<spanclass="math inline">\(b_j\)</span> 表示控制点，<spanclass="math inline">\(B_i^n(t)\)</span> 为伯恩斯坦多项式（BernsteinPolynomials）。</p><span class="math display">\[\begin{aligned}b^n(t) = &amp;b_{0}^{n}(t) = \sum_{j=0}^{n}b_jB_{j}^{n}(t)\\B_i^n(t) = &amp;\left(\begin{matrix}n \\i \\\end{matrix}\right)t^i(1-t)^{n-i}\end{aligned}\]</span><h3 id="曲线性质">曲线性质</h3><p>贝塞尔曲线具有以下几个特性：</p><ul><li>一定过起点和终点。</li><li>不受仿射变换影响，受投影变换影响。</li><li>凸包（Convex Hull）性质：贝塞尔曲线在所有控制点的凸包范围内。</li></ul><h2 id="分段贝塞尔曲线">分段贝塞尔曲线</h2><p>根据贝塞尔曲线绘制算法，我们可以知道，改变任意一个控制点的位置都会影响整个贝塞尔曲线。因此，当控制点比较多时，我们很难进行精准的控制和调整。于是就有了分段贝塞尔曲线，即采用多条贝塞尔曲线进行串联。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-18.png?x-oss-process=image/resize,w_800" /></p><h1 id="曲面">曲面</h1><p>曲面（Surface）在图形学中应用同样非常广泛，可以用它来表示各种三维物体。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-19.png?x-oss-process=image/resize,w_800" /></p><h2 id="贝塞尔曲面">贝塞尔曲面</h2><p>贝塞尔曲线控制点都是在同一平面内，由此进行扩展，贝塞尔曲面的控制点则是分部在三维空间中。下图所示，展示了空间中4 x 4 个控制点所构成的贝塞尔曲面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-20.png?x-oss-process=image/resize,w_800" /></p><h3 id="绘制算法-1">绘制算法</h3><p>贝塞尔曲面的绘制算法本质上还是基于 De Casteljau's Algorithm进行多次绘制。以下图为例，首先基于预设的所有控制点（比如：4 x 4的控制点），绘制 4条贝塞尔曲线。然后在与曲线垂直的平面中开始绘制曲线，按照固定间距，以 4条贝塞尔曲线上的点作为控制点，绘制贝塞尔曲线。以此类推，最终得到一个贝塞尔曲面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-21.png?x-oss-process=image/resize,w_800" /></p><h2 id="曲面处理">曲面处理</h2><p>根据上述绘制算法，我们可以得到基于多边形网格的曲面。在实际应用中，我们会对曲面进行进一步的处理。常见的曲面处理操作有以下两种：</p><ul><li><strong>网格细分</strong>（Mesh Subdivision）</li><li><strong>网格简化</strong>（Mesh Simplification）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-22.png?x-oss-process=image/resize,w_800" /></p><h3 id="网格细分">网格细分</h3><p>网格细分就是把一个多边形拆分成多个多边形。这里我们介绍两种细分算法：Loop细分和 Catmull-Clark 细分。</p><h4 id="loop-细分">Loop 细分</h4><p>Loop 细分只适用于三角形面的细分，具体可以分为两步：</p><ul><li>将一个三角形拆分成四个三角形</li><li>更新新顶点和旧顶点的位置，使模型变得更加光滑</li></ul><p>三角形的拆分非常简单，连接每条边的中点，即可将拆分成四个三角形，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-23.png?x-oss-process=image/resize,w_800" /></p><p>对于新顶点的更新，它会基于周围四个旧顶点求加权平均，离它近的顶点权重大，设为3/8，离它远的顶点权重小，设为 1/8，如下所示，白点为待更新的新顶点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-24.png?x-oss-process=image/resize,w_800" /></p><p>对于旧顶点的更新，它会基于周围几个旧顶点求加权平均，其中各个点的权重值与待更新点的度（Degree）有关，最终可以得到如下所示的更新方法。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-25.png?x-oss-process=image/resize,w_800" /></p><p>Loop 细分只针对三角形面进行细分，整体效果如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-29.png?x-oss-process=image/resize,w_800" /></p><h4 id="catmull-clark-细分">Catmull-Clark 细分</h4><p>相比对 Loop 细分，Catmull-Clark细分是一种更加通用的细分方法，适用于各种多边形网格曲面。Catmull-Clark细分涉及到一个概念 <strong>奇异点</strong>（ExtraordinaryVertex），即度不为 4 的点。</p><p>Catmull-Clark 细分的第一步同样是拆分多边形，主要包含以下几点：</p><ul><li>对于边，取其中点；对于面，也取其一个点（比如：重心）</li><li>连接边的中点和面的中点</li></ul><p>我们可以发现，当对非四边形进行一次细分后，所有的非四边形都消失了。不过，一次细分后，会引入两个新的奇异点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-26.png?x-oss-process=image/resize,w_800" /></p><p>对于新顶点的更新，可以分为两种情况，分别边上的点和面中的点，其规则如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-27.png?x-oss-process=image/resize,w_800" /></p><p>对于旧顶点的更新，其更新规则如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-28.png?x-oss-process=image/resize,w_800" /></p><p>Catmull-Clark 适用于任何多边形网格面，整体效果如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-30.png?x-oss-process=image/resize,w_800" /></p><h3 id="网格简化">网格简化</h3><p>网格简化与网格细分正好相反，其目的是为了减少三角形数量，从而提升性能。对于近的物体三角形多，远的物体三角形少。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-31.png?x-oss-process=image/resize,w_800" /></p><p>网格简化是通过 <strong>边坍缩</strong>（EdgeCollapse）实现的，它会减少边的数量，并更新相关顶点的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-32.png?x-oss-process=image/resize,w_800" /></p><p>那么边坍缩的底层依据是什么呢？这里涉及到<strong>二次度量误差</strong>（Quadirc ErrorMetrics）的概念。二次度量误差用来表示网格简化带来的误差大小，其计算方法是新顶点与它关联的面的垂直距离的平方和，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-33.png?x-oss-process=image/resize,w_800" /></p><p>当删除一条边时，我们会引入一个新的顶点，当新顶点调整至二次度量误差最小时，我们将其设置为边坍缩后的新顶点。利用这种贪心思想，就能实现网格简化。</p><h1 id="总结">总结</h1><p>本文我们主要介绍了计算机图形学中的几何相关部分。首先，我们介绍了几何的几种表示方法：隐式几何表示和显式集合表示，两者各自又有着很多实现方法。</p><p>然后，我们介绍了曲线，特别是贝塞尔曲线，详细介绍了其绘制算法 DeCasteljau's Algorithm。由此延伸值曲面的绘制，特别是贝塞尔曲面。</p><p>最后，我们介绍了曲面的两种常见的处理方式：网格细分和网格简化。</p><p>至此，几何相关的内容均已介绍完毕。后续，我们将探讨光线追踪渲染器的相关内容。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面我们介绍了观测变换、光栅化、着色等几个图形学中比较复杂的主题，本文我们稍微放松一下，介绍一个相对比较简单的主题——几何。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="几何" scheme="http://chuquan.me/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="Loop Subdivision" scheme="http://chuquan.me/tags/Loop-Subdivision/"/>
    
    <category term="Catmull-Clark Subdivision" scheme="http://chuquan.me/tags/Catmull-Clark-Subdivision/"/>
    
    <category term="贝塞尔曲线" scheme="http://chuquan.me/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    
    <category term="De Casteljau&#39;s Algorithm" scheme="http://chuquan.me/tags/De-Casteljau-s-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（5）——着色</title>
    <link href="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/"/>
    <id>http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/</id>
    <published>2024-04-05T07:52:33.000Z</published>
    <updated>2024-04-06T03:22:26.023Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <ahref="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">文章</a>我们介绍了光栅化所涉及的基本内容。通过光栅化，我们可以实现将 3D空间模型的投影绘制到 2D屏幕。然而，仅仅实现光栅化，还不足以让渲染结果具有真实感，如下图左部所示。我们希望能够模拟光线所带来的的明暗效果，如下图右部所示。</p><span id="more"></span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-01.png?x-oss-process=image/resize,w_800" /></p><p>在计算机图形学中，<strong>着色</strong>（Shading）就是通过计算来决定三维模型表面每个像素的颜色和亮度的过程。本质而言，着色就是<strong>对不同物体应用不同材质</strong>。</p><h1 id="着色模型">着色模型</h1><h2 id="着色局部性">着色局部性</h2><p>具体分析着色时，我们会分析光线照射到物体表面的每一个点，也称<strong>着色点</strong>（ShadingPoint）。对于每个着色点，我们将其视为一个微平面（或称单位平面），由此我们可以构建法线。整体而言，着色的最终结果受以下几种输入影响，分别是：</p><ul><li>观测方向 <span class="math inline">\(v\)</span></li><li>表面法向 <span class="math inline">\(n\)</span></li><li>光线方向 <span class="math inline">\(l\)</span></li><li>表面参数，如：颜色、材质。</li></ul><blockquote><p>注意：对于着色过程，我们只考虑光照对于物体表面的影响，而不考虑其他物体的阴影对本物体产生的影响。</p></blockquote><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-03.png?x-oss-process=image/resize,w_800" /></p><h2 id="布林-冯反射模型">布林-冯反射模型</h2><p>关于光线与物体表面的作用，根据我们的认知，其实可以分为三种类型：</p><ul><li><strong>漫反射</strong>（Diffuse）</li><li><strong>高光</strong>（Specular）</li><li><strong>环境光</strong>（Ambient）</li></ul><p>在计算机图形学中，有一种广泛使用的光照和颜色计算模型——<strong>布林-冯反射模型</strong>（Blinn-PhongRelectanceModel），其考虑了上述三种光照的叠加效果对物体表面颜色的影响。</p><p>下面，我们分别来介绍这三种光照类型。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-02.png?x-oss-process=image/resize,w_800" /></p><h3 id="漫反射">漫反射</h3><p>当光线照射到一个点时，光线会向各个方向发生反射，这种现象称为<strong>漫反射</strong>。漫反射的反射光强主要受到光照角度、光照强度、漫反射系数等因素的影响。</p><h4 id="光照角度">光照角度</h4><p>在图形学中，<strong>兰伯特余弦定理</strong>（Lambert's cosinelaw）详细描述了光照角度对于表面接收光照照射量的影响。下图所示，列举了三种光照角度。</p><ul><li>情况一，入射角度为 <spanclass="math inline">\(90^{\circ}\)</span>，单位平面会接收全部光照。</li><li>情况二，入射角度为 <spanclass="math inline">\(30^{\circ}\)</span>，单位平面只会接收到一半光照。</li><li>情况三，入射角度为 <spanclass="math inline">\(90^{\circ}-\theta\)</span>，单位平面接收到的光照占全部光照的比例为<span class="math inline">\(cos{\theta} = \hat{l} \cdot\hat{n}\)</span>。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-04.png?x-oss-process=image/resize,w_800" /></p><p>基于兰伯特余弦定理，我们可以推导出一个函数表示单位平面接收的光照照射量占全部光照的比例，如下所示。由于<span class="math inline">\(cos\theta\)</span>可能会负数，但这没有意义，所以我们使用 <spanclass="math inline">\(max(0, cos\theta)\)</span> 来保证其值大于等于0。</p><span class="math display">\[\begin{aligned}f(\theta) = max(0, cos\theta) = max(0, \hat{l} \cdot \hat{n})\end{aligned}\]</span><h4 id="光照强度">光照强度</h4><p>对于光照强度，我们考虑如下所示 3D空间中的一个点光源。根据能量守恒定理，以光源为球心，任意距离为半径的球体，球面所覆盖的光线强度是相等的。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-34.png?x-oss-process=image/resize,w_800" /></p><p>由此，我们可以推导光照强度与光源距离之间的关系。假设半径 <spanclass="math inline">\(r\)</span> 为 <code>1</code>时，球面一个点的光照强度为 <spanclass="math inline">\(I\)</span>。那么当半径为任意值 <spanclass="math inline">\(r\)</span> 时，我们可以根据能量守恒定理得到：</p><span class="math display">\[\begin{aligned}单位球面光照强度：&amp;4{\pi}I\\任意球面光照强度：&amp;4{\pi}r^2I_r\\根据能量守恒定理：&amp;4{\pi}r^2I_r = 4{\pi}I\\任意点的光照强度：&amp;I_r=I/r^2\end{aligned}\]</span><h4 id="漫反射系数">漫反射系数</h4><p>不同的材质具有不同的漫反射系数，我们将漫反射系数定义为 <spanclass="math inline">\(k_d\)</span>。如下所示，<spanclass="math inline">\(k_d\)</span>越大，反射的光线强度越大，看到的物体越亮。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-05.png?x-oss-process=image/resize,w_800" /></p><h4 id="漫反射公式">漫反射公式</h4><p>漫反射光线的计算公式其实就是由上述三部分组成，如下所示。</p><span class="math display">\[\begin{aligned}L_d = k_d(I/r^2)max(0, \hat{l} \cdot \hat{n})\end{aligned}\]</span><h3 id="高光">高光</h3><p>高光反射，当观测向量趋近于光线的反射向量时，我们可以看到镜面反射所产生的高光，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-06.png?x-oss-process=image/resize,w_800" /></p><h4 id="高光区域">高光区域</h4><p>那么如何判断高光区域呢？我们可以通过计算光照方向向量和观测方向向量之间的<strong>半程向量</strong>（HalfVector）。然后再计算半程向量与平面法线之间的夹角，判断两者是否接近。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-07.png?x-oss-process=image/resize,w_800" /></p><p>如下所示为半程向量的计算公式，有了半程向量之后，我们可以计算法向量与半程向量之间的夹角。</p><span class="math display">\[\begin{aligned}\hat{h} = bisector(\hat{v}, \hat{l}) = \frac{\hat{v} + \hat{l}}{|\hat{v}+ \hat{l}|}\end{aligned}\]</span><h4 id="高光突变">高光突变</h4><p>根据日常经验，我们可以发现当法向量与半程向量之间的夹角大于某个阈值之后，高光效应会发生突变。如果我们使用<span class="math inline">\(cos\theta\)</span>来描述这种突变，显示是不合适的。在布林-冯模型中，我们对 <spanclass="math inline">\(cos^p\theta\)</span> 来描述高光突变，其中 <spanclass="math inline">\(p\)</span> 是一个经验值。下图所示，展示了不同<span class="math inline">\(p\)</span> 值随角度变化的曲线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-08.png?x-oss-process=image/resize,w_800" /></p><h4 id="高光系数">高光系数</h4><p>类似于漫反射系数，对于高光，这里也有一个高光系数，使用 <spanclass="math inline">\(k_s\)</span> 表示。下图所示为不同 <spanclass="math inline">\(k_s\)</span> 和不同 <spanclass="math inline">\(p\)</span>的情况下，高光效果的对比。可以看出，高光系数越大，观测的效果越明亮。高光突变的<span class="math inline">\(p\)</span> 值越大，高光区域则越小。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-09.png?x-oss-process=image/resize,w_800" /></p><h4 id="高光公式">高光公式</h4><p>高光的计算公式其实也是由三部分组成：高光系数、光线强度、高光突变，具体公式如下所示。</p><span class="math display">\[\begin{aligned}L_s = k_s(I/r^2)max(0, \hat{n} \cdot \hat{h})^p\end{aligned}\]</span><h3 id="环境光">环境光</h3><p>在现实世界中，我们知道即使没有光源直接照射物体，物体也并不是完全是黑色的。对此，布林-冯着色模型也近似处理了这种情况，即环境光。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-10.png?x-oss-process=image/resize,w_800" /></p><h4 id="环境光公式">环境光公式</h4><p>环境光的计算公式非常简单，由环境光系数和环境光强度组成，具体公式如下所示。</p><span class="math display">\[\begin{aligned}L_a = k_aI_a\end{aligned}\]</span><h3 id="光线反射公式">光线反射公式</h3><p>布林-冯反射模型定义了一个光线反射公式，该公式由上述三种光照反射类型的计算公式组合，具体公式如下所示。</p><span class="math display">\[\begin{aligned}L = L_a + L_d + L_s = k_aI_a + k_d(I/r^2)max(0, \hat{n} \cdot \hat{l}) +k_s(I/r^2)max(0, \hat{n} \cdot \hat{h})^p\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-11.png?x-oss-process=image/resize,w_800" /></p><h1 id="着色频率">着色频率</h1><p>在布林-冯反射模型中，我们以着色点（单位平面）为单位介绍三种光照反射类型。那么在真实着色过程中，以什么为单位进行着色呢？考虑到着色性能的开销，实际上可以分为三种类型，分别是：</p><ul><li><strong>平面着色</strong>（Flat Shading）</li><li><strong>顶点着色</strong>（Gouraud Shading）</li><li><strong>像素着色</strong>（冯-着色，Phong Shading）</li></ul><h2 id="平面着色">平面着色</h2><p>平面着色会对每一个平面做一次着色。相对而言，着色频率低，性能开销小，但是着色效果不够丝滑，会有明显的棱边效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-12.png?x-oss-process=image/resize,w_800" /></p><p>在布林-冯反射模型中，着色点的法向量是计算着色的关键变量。对于平面着色而言，我们可以通过三角形的任意两条边所构成的向量，计算叉积，即可得到法向量。</p><h2 id="顶点着色">顶点着色</h2><p>顶点着色会对三角形的三个顶点进行着色。对于三角形内部的点，则基于三个顶点的颜色，使用速度更快的插值法进行计算。相比平面着色，着色频率略高，性能开销略大，但是着色效果会好一点，会有细微的棱边效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-13.png?x-oss-process=image/resize,w_800" /></p><p>对于顶点着色，我们需要计算三个顶点各自的法向量。通常有两种选择：</p><ul><li>当平面属于一个规则几何体的局部表面时，可以通过规则几何体的整体出发，计算对应平面的法向量。</li><li>其他情况时，可以基于周围平面的法向量，求解平均值，计算对应平面的法向量。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-15.png?x-oss-process=image/resize,w_800" /></p><h2 id="像素着色">像素着色</h2><p>像素着色，也称冯-着色，它会对每一个像素进行着色。这种方式着色频率很高，性能开销很大，但是着色效果非常丝滑。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-14.png?x-oss-process=image/resize,w_800" /></p><p>对于像素着色，我们首先以上述方式计算三角形顶点的法向量，对于三角形内部的点，则通过<strong>重心插值法</strong>（BarycentricInterpolation）来计算。关于重心插值法，我们稍后进行介绍。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-16.png?x-oss-process=image/resize,w_800" /></p><h1 id="实时渲染管线">实时渲染管线</h1><p>实时渲染管线（Real-time Rendering），也称图形管线（GraphicsPipeline），其描述了 3D 场景转换成 2D 图像的完整流程，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-17.png?x-oss-process=image/resize,w_800" /></p><p>实时渲染管线可以分为五个阶段，分别是：</p><ul><li><strong>顶点处理</strong>（Vertex Processing）</li><li><strong>三角形处理</strong>（Triangle Processing）</li><li><strong>光栅化</strong>（Rasterization）</li><li><strong>片段处理</strong>（Fragment Processing）</li><li><strong>帧缓冲操作</strong>（Framebuffer Operations）</li></ul><h2 id="顶点处理">顶点处理</h2><p>顶点处理的输入是 3D 空间中的顶点。为什么是顶点而不是 3D模型？这是因为 3D空间的所有模型都是以三角形为基本单元进行表示的，而三角形则可以通过顶点和连线来描述，3D模型的本质就是大量顶点和连线的定义。</p><p>在顶点处理阶段，我们会对顶点进行观测变换，即 <ahref="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">《计算机图形学基础（3）——观测变换》</a>中所介绍的 MVP 变换。最终输出经过观测变换的顶点。</p><h2 id="三角形处理">三角形处理</h2><p>在某些文章中，会将这个阶段定义成 <strong>图元处理</strong>（PrimitiveProcessing），三角形处理只是其中的一个子集，它还会处理点和线。这里我们为了突出重点，将其称为三角形处理。</p><p>由于顶点处理阶段只对顶点进行变换，而 3D模型还包括连线的定义，三角形处理阶段就是根据连线的定义，将顶点装配成三角形（也称图元）。</p><h2 id="光栅化">光栅化</h2><p>当顶点处理和三角形处理完成之后，我们得到了经过观测变换后的三角形。此时三角形仍然处于3D 空间中，不过我们可以通过正交投影快速获取它们在 2D 空间中的投影。</p><p>光栅化则是将连续的 2D 投影进行采样，转换成离散的 2D投影，这是因为屏幕由一个离散的二维像素矩阵所构成。关于光栅化具体要做的事情以及可能遇到的问题，我们在<ahref="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">《计算机图形学（4）——光栅化》</a>中进行了详细的介绍。</p><p>在实际的 GPU设计中，为了支持可编程、并行计算，实时渲染管线中的光栅化的主要任务是对连续的图形进行采样，使其离散化。</p><h2 id="片段处理">片段处理</h2><p>片段处理，也称像素处理，它会对每个片段的颜色、纹理坐标、深度值等进行计算，期间会大量应用插值法进行计算。严格意义上说，片段处理也属于光栅化的一部分。</p><h2 id="帧缓冲操作">帧缓冲操作</h2><p>帧缓冲操作包含了颜色混合、模板测试、深度测试、透明度检查等一系列操作，最终结果会保存在帧缓冲区，显示器会定时读取帧缓冲区，并将内容呈现在屏幕上。</p><h2 id="关于着色">关于着色</h2><p>整体而言，实时渲染管线包含观测变换、光栅化、着色三大部分。</p><p>然而，着色其实在顶点处理和片段处理阶段都可以存在，这取决于着色频率。如果我们采用顶点着色，那么着色可以发生在顶点处理阶段；如果我们采用像素着色，那么着色可以发生在片段处理阶段。</p><p>在现代 GPU中，实时渲染管线的部分阶段是支持可编程的，比如顶点处理阶段和片段处理阶段。在这些可编程阶段中，我们可以编写着色器（Shader）程序，从而生成自定义的着色结果。</p><h3 id="着色器">着色器</h3><p>在实时渲染领域，大部分从业者做的事情就是在写各种各样的着色器。如下所示，是OpenGL 中的一个片段着色器程序，其采用 GLSL着色语言编写。着色器程序最终由 GPU调用，对于每个像素都会执行并生成着色结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D myTexture;    <span class="comment">// program parameter</span></span><br><span class="line">uniform vec3 lightDir;          <span class="comment">// program parameter</span></span><br><span class="line">varying vec2 uv;                <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line">varying vec3 norm;              <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">diffuseShader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec3 kd;                                </span><br><span class="line">    kd = <span class="built_in">texture2d</span>(myTexture, uv);                  <span class="comment">// material color from texture</span></span><br><span class="line">    kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);    <span class="comment">// Lambertian shading model</span></span><br><span class="line">    gl_FragColor = <span class="built_in">vec4</span>(kd, <span class="number">1.0</span>);                   <span class="comment">// output fragment color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纹理">纹理</h1><p>在介绍着色模型中，我们提到着色点的材质会影响最终的着色结果，比如各种反射系数<span class="math inline">\(k_d\)</span>、<spanclass="math inline">\(k_s\)</span>、<spanclass="math inline">\(k_a\)</span>等。除此之外，着色点的原始颜色、法线等属性也都会影响着色结果。</p><p>为了能够为着色点定义属性，提出了<strong>纹理</strong>（Texture）的概念，使用纹理来记录每个着色点的各种属性。通常情况下，我们会把纹理等同于贴图（图片），这是因为大多数情况下会使用纹理来定义颜色。不过从严格意义上说，贴图只是纹理的一种而已。</p><h2 id="纹理映射">纹理映射</h2><p>纹理映射的本质就是将纹理定义的属性映射到 3D 模型的各个着色点。</p><p>如下图所示，我们定义了一个模型和一个纹理，中间的模型经过纹理映射后渲染得到了我们期望的效果。在建模时，我们会将模型分割成一个个三角形。与模型所绑定的纹理，我们也会将其分割成一个个三角形。两者之间的三角形会一一对应。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-18.png?x-oss-process=image/resize,w_800" /></p><p>为了方便映射，我们会建立 <strong>纹理坐标系</strong>（TextureCoordinate），横坐标用 <span class="math inline">\(u\)</span>表示，纵坐标用 <span class="math inline">\(v\)</span> 表示。<spanclass="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 的值都在 <code>[0, 1]</code>之间，这是一个约定俗成的规定。模型中的每个顶点都会设定一个纹理坐标，通过这种方式可以实现纹理映射。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-19.png?x-oss-process=image/resize,w_800" /></p><h2 id="重心坐标">重心坐标</h2><p>虽然模型和纹理是绑定的，但是绑定是基于顶点实现的。因此在纹理映射中，对于模型三角形的顶点，我们可以直接使用绑定的纹理坐标找到纹理中对应坐标的属性。但是模型三角形内部的点该如何获取纹理属性呢？为了解决这个问题，提出了<strong>重心坐标</strong>（Barycentric Coordinate）的概念。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-20.png?x-oss-process=image/resize,w_800" /></p><p>以上图中的三角形为例，重心坐标定义了三角形内部任意一个点 <spanclass="math inline">\((x, y)\)</span> 具有以下几个特性。</p><span class="math display">\[\begin{aligned}\begin{cases}(x, y) = {\alpha}A + {\beta}B + {\gamma}C\\\alpha + \beta + \gamma = 1\\\alpha &gt;= 0;\beta &gt;= 0;\gamma &gt;= 0;\end{cases}\end{aligned}\]</span><p>最终，我们可以计算得到三角形内任意一个点的重心坐标 <spanclass="math inline">\((\alpha, \beta,\gamma)\)</span>。此时，我们可以使用重心坐标，结合顶点属性，计算得到该点的属性。这里的属性可以是位置、纹理坐标、颜色、法线、深度、材质等各种属性。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-21.png?x-oss-process=image/resize,w_800" /></p><p>需要注意的是，在投影时三角形的形状会发生变化，所以在着色时应该基于三维空间的坐标计算重心坐标，然后再做插值。</p><h2 id="纹理查询">纹理查询</h2><p>上面我们介绍了使用重心坐标表示三角形中的任意点。那么具体该如何应用重心坐标来查找对应的纹理属性呢？如下所示，我们使用伪代码描述了这个查找过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each rasterized screen <span class="title">sample</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    (u, v) = evaluate texture coordinate <span class="built_in">at</span> (x, y)</span><br><span class="line">    texcolor = texture.<span class="built_in">sample</span>(u, v)</span><br><span class="line">    set sample<span class="number">&#x27;</span>s color to texcolor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先说明一个前提：在光栅化阶段，即当三角形被转换为屏幕上的像素时，每个像素的纹理坐标会通过插值方式在三角形的顶点之间计算出来。此时，我们得到的是每个像素的屏幕坐标以及对应的纹理坐标。</p><p>上述伪代码所描述的流程是：</p><ul><li>遍历光栅化得到的屏幕采样点，比如一个三角形 <spanclass="math inline">\(ABC\)</span> 的区域内的某个像素点 <spanclass="math inline">\((x, y)\)</span>。</li><li>基于上述前提，有了像素的屏幕坐标 <span class="math inline">\((x,y)\)</span>，我们可以直接获取对应的纹理坐标。</li><li>当得到像素点的纹理坐标后，我们就可以在纹理中查找对应的属性，伪代码中查找的是颜色属性。</li><li>最后我们用纹理颜色来给像素着色。</li></ul><p>本质上，这是一个纹理采样过程。一旦涉及采样，就可能会出现走样问题。下面，我们来分情况讨论。</p><h3 id="纹理太小问题">纹理太小问题</h3><p>对于纹理太小的情况，那么会出现多个像素映射到一个<strong>纹素</strong>（Texel），即纹理中的一个点或像素。此时，就会出现锯齿问题。</p><p>为了解决锯齿问题，我们可以通过求均值的方式来解决。如下所示，为最近采样、双线性插值、双三次插值的对比结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-22.png?x-oss-process=image/resize,w_800" /></p><p>双线性插值的原理非常简单，就是去临近的 4个像素，通过三次插值计算得到一个颜色平均值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-23.png?x-oss-process=image/resize,w_800" /></p><p>双三次插值的原理与双线性插值类似，区别在于前者使用周围的 16个像素求插值，后者使用周围的 4 个像素求插值。</p><h3 id="纹理太大问题">纹理太大问题</h3><p>对于纹理太大的情况，会出现摩尔纹、锯齿等情况。本质上是采样频率低于信号频率，我们在<ahref="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">计算机图形学基础（4）——光栅化</a>中介绍过两种解决思路，一种是超采样，一种是过滤高频信号。</p><p>这两种思路，在这种场景下都存在开销过大的问题。于是，在图形学中提出了范围查询的方法，即<strong>Mipmap</strong>，从而避开了采样所带来的问题。</p><h4 id="点查询-范围查询">点查询 &amp; 范围查询</h4><p>本质上，采样就是点查询。当纹理太大时，屏幕上一个点对应到纹理上可能是一个很大的区域。然而，从这个区域中取一个点来代表整个区域的颜色，这显然是不合适的。对比而言，范围查询相当于提前计算出一个合适的值来代表这个区域。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-24.png?x-oss-process=image/resize,w_800" /></p><h4 id="mipmap">Mipmap</h4><p>Mipmap正是范围查询的一种实现方案，它会为一张纹理生成多个不同层级的纹理，如下图所示。Mipmap虽然生成了多个不同层级的纹理，但是整体的存储量只增加了不到 1/3。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-25.png?x-oss-process=image/resize,w_800" /></p><p>既然 Mipmap生成了多个不同层级的纹理，那么在纹理查询时，我们应该查询哪个层级的纹理呢？</p><p>如下图所示，对于屏幕上的一个像素点，考虑其相邻的两个点，获取它们的纹理坐标。根据纹理坐标计算相邻的距离，由此近似得到像素对应的矩形区域。我们获取矩形区域较大的边长<span class="math inline">\(L\)</span>。然后对 <spanclass="math inline">\(L\)</span>求对数，即可计算得出要查询的纹理的层级。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-26.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}L = &amp;max(\sqrt{(\frac{du}{dx})^2 + (\frac{du}{dx})^2},\sqrt{(\frac{du}{dy})^2 + (\frac{du}{dy})^2})\\D = &amp;log_2L\end{aligned}\]</span><h4 id="各向异性过滤">各向异性过滤</h4><p>事实上，Mipmap也并不是万能的。在有些场景下，也会出现过度模糊的问题，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-27.png?x-oss-process=image/resize,w_800" /></p><p>根本原因是，Mipmap的范围查询所覆盖的区域是正方形。如果屏幕像素点代表了纹理中的一个长方形区域，那么范围查询就无法准确代表长方形区域内的值，因此会出现走样，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-28.png?x-oss-process=image/resize,w_800" /></p><p>那么如何解决呢？方法是各项异性过滤（AnisotropicFiltering）。具体的技术是：除了生成针对正方形区域的范围查询的纹理外，还要生成其他形状（比如长方形）的范围查询的纹理。通过这种方式，纹理的存储量会增加3 倍，不过能够降低着色走样的概率。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-29.png?x-oss-process=image/resize,w_800" /></p><h2 id="纹理应用">纹理应用</h2><p>至此，我们基本了解了纹理及其工作原理，本质而言，纹理 = 内存存储 +范围查询。上述内容我们主要介绍了通过纹理记录颜色，事实上纹理还能记录其他很多属性，比如：环境光、微几何、法向量、高度偏移等等。</p><p>下面，我们来介绍纹理的其他几种应用。</p><h3 id="环境贴图">环境贴图</h3><p>纹理应用最多的就是 <strong>环境贴图</strong>（EnvironmentMap），这里又有非常多的类型。</p><p><strong>立方体环境贴图</strong>（Cube EnvironmentMap），它是将环境映射到一个立方体的六个面上，可以用于实现镜面反射和环境光照。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-30.png?x-oss-process=image/resize,w_800" /></p><p><strong>光照环境贴图</strong>（Light EnvironmentMap），它在渲染过程中预先计算和存储环境光照信息，以提高实时渲染效率和质量的技术</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-31.png?x-oss-process=image/resize,w_800" /></p><p>除此之外，还有很多环境贴图，比如：球谐环境贴图、镜面反射环境贴图、辐射度环境贴图、天空盒环境贴图等等。</p><h3 id="凹凸贴图">凹凸贴图</h3><p>假如我们希望渲染一个表面凹凸不同的球状体，如果使用三角形来表示，那么需要大量三角形，而且结构非常复杂。对于这种情况，我们可以凹凸贴图（BumpMap），它可以定义点的相对高度，从而改变法线，进而影响着色结果，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-32.png?x-oss-process=image/resize,w_800" /></p><h3 id="位移贴图">位移贴图</h3><p>凹凸贴图改变了着色时所使用的法向量，但并没有真正改变模型的形状。一种更现代化的<strong>位移贴图</strong>（DisplacementMapping），则定义了顶点高度的偏移量，使得真真正改变了模型的形状，从而实现更加逼真的效果。下图所示，为凹凸贴图和位移贴图的对比效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-33.png?x-oss-process=image/resize,w_800" /></p><h1 id="总结">总结</h1><p>本文我们主要介绍了着色相关的内容。</p><p>首先，我们介绍了着色模型，具体介绍了经典的布林-冯反射模型，其由漫反射、高光、环境光三部分组成。</p><p>其次，我们介绍了几种着色频率，包括平面着色、顶点着色、像素着色，简单对比了它们之间的差异。</p><p>然后，我们简单介绍了实时渲染管线的 5个阶段，包括顶点处理、三角形处理、光栅化、片段处理、帧缓冲操作等。</p><p>最后，我们详细介绍了着色中最重要的一部分——纹理。纹理查询是是如何通过重心坐标、纹理坐标查找对应的纹理属性。当然，纹理查询也属于采样，其中也会遇到走样的问题。于是，我们引入了线性插值、Mipmap、各向异性过滤等解决方案。除此之外，我们还介绍了纹理的几种应用，包括：环境贴图、凹凸贴图、位移贴图等。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li><a href="http://shadertop.com">Shadertoy</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇 &lt;a
href=&quot;http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/&quot;&gt;文章&lt;/a&gt;
我们介绍了光栅化所涉及的基本内容。通过光栅化，我们可以实现将 3D
空间模型的投影绘制到 2D
屏幕。然而，仅仅实现光栅化，还不足以让渲染结果具有真实感，如下图左部所示。我们希望能够模拟光线所带来的的明暗效果，如下图右部所示。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Mipmap" scheme="http://chuquan.me/tags/Mipmap/"/>
    
    <category term="各向异性过滤" scheme="http://chuquan.me/tags/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4/"/>
    
    <category term="纹理" scheme="http://chuquan.me/tags/%E7%BA%B9%E7%90%86/"/>
    
    <category term="重心坐标" scheme="http://chuquan.me/tags/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"/>
    
    <category term="纹理坐标" scheme="http://chuquan.me/tags/%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87/"/>
    
    <category term="布林-冯模型" scheme="http://chuquan.me/tags/%E5%B8%83%E6%9E%97-%E5%86%AF%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（4）——光栅化</title>
    <link href="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/"/>
    <id>http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/</id>
    <published>2024-03-30T01:20:55.000Z</published>
    <updated>2024-03-30T01:39:10.562Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <ahref="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">文章</a>我们介绍了矩阵变换在计算机图形学中的应用，包括：视图变换、模型变换、投影变换。此外，我们还详细介绍了投影变换中的正交投影和透视投影，以及屏幕映射过程中的视口变换。</p><span id="more"></span><p>本文，我们来介绍一下计算机图形学中最重要的内容之一——光栅化。</p><h1 id="栅格显示">栅格显示</h1><p>光栅化（Rasterization）中光栅（Raster）一词来源于德语，表示栅格的意思。我们现在用的显示设备基本上都是由像素点阵构成的栅格显示设备。因此，我们很容易理解光栅化的含义，即在栅格显示设备上绘制图形。</p><p>这里我们先介绍一下常见的栅格显示设备。</p><p>旧式的阴极射线管（Cathode Ray Tube，CRT）电视，它的基本原理是<strong>通过射线管将电子射到屏幕进行逐行扫描</strong>，如下图所示。在实际应用中，会借助视觉暂留效应，对屏幕进行<strong>隔行扫描</strong>，从而降低扫描的计算量。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-01.png?x-oss-process=image/resize,w_800" /></p><p>现代平板显示器（Flat Panel Displays）中最常用的是液晶显示器（LiquidCrystal Display，LCD），它的基本原理是<strong>通过扭转偏振来阻挡或传输光线</strong>，如下图所示。在实际应用中，会使用<strong>帧缓冲</strong>（FrameBuffer）来提前缓存画面的帧数据，从而提高显示流畅度。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-02.png?x-oss-process=image/resize,w_800" /></p><h1 id="光栅化">光栅化</h1><h2 id="基本单元">基本单元</h2><p>光栅化的基本单元是三角形，采用三角形作为基本单元的原因是：</p><ul><li>三角形是最基本的多边形。</li><li>三角形具有平面性。</li><li>三角形可以明确定义内部和外部。我们可以通过向量叉积来判断，详见 <ahref="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">计算机图形学基础（1）——线性代数</a>。</li><li>任意多边形可以拆分成 N 个三角形。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-07.png?x-oss-process=image/resize,w_800" /></p><h2 id="采样绘制">采样绘制</h2><p>2D屏幕是一个离散的像素阵列，空间中的三角形则是一个连续的函数。采样绘制的本质则是对一个函数进行离散化。具体的做法是：</p><ul><li>遍历像素阵列，判断每一个像素阵列是否位于三角形的投射区域内</li><li>如果是，进行绘制像素；否则，不绘制。</li></ul><p>如下所示为采样绘制的伪代码和示意图。注意，像素本身是一个矩形区域，因此判断像素是否在三角形内部时，采用的是像素点的中心作为参照。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inside</span><span class="params">(t, x, y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">point</span><span class="params">(x, y)</span> in <span class="title">triangle</span><span class="params">(t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y) &#123;</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x + <span class="number">0.5</span>, y + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-03.png?x-oss-process=image/resize,w_800" /></p><p>在绘制三角形时，一般不会对整个屏幕的像素点进行扫描，而是仅仅对三角形的<strong>包围盒</strong>（BoundingBox）区域内的像素进行扫描和绘制，从而有效降低算法复杂度。对于一些窄长三角形，甚至可以进一步优化算法，如下图右侧所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-04.png?x-oss-process=image/resize,w_800" /></p><h2 id="核心问题">核心问题</h2><p>我们观察上述这种简单的采样绘制方式，可以发现一个很明显的问题——<strong>锯齿</strong>（Jaggies）。这个问题根本上是采样导致的，对于这种现象我们称之为<strong>走样</strong>（Aliasing）。走样会带来很多奇怪的现象，比如：锯齿、摩尔纹（MoirePatterns）、车轮效应等，如下图所示。</p><p>光栅化要解决的核心问题就是走样问题，即<strong>反走样</strong>（Antialiasing）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-05.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-06.png?x-oss-process=image/resize,w_800" /></p><h2 id="解决方法">解决方法</h2><p>计算机图形学中解决走样问题的最常用方法是：<strong>先模糊，后采样</strong>。模糊，从字面上理解就是将图片虚化，从数学上理解则是<strong>滤波</strong>，关于滤波，我们将在下一节中进行介绍。</p><p>下图所示，为「直接采样」和「先模糊，后采样」的流程对比图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-08.png?x-oss-process=image/resize,w_800" /></p><p>在具体实践中，通过这种方式能够有效解决光栅化中的锯齿问题，如下所示为反走样前后的效果对比图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-09.png?x-oss-process=image/resize,w_800" /></p><p>这里，我们可能会产生疑问：</p><ul><li>出现走样的根本原因是什么？</li><li>为什么先模糊（滤波）后采样能够实现反走样？</li></ul><p>要讲明白这些内容，我们必须要介绍一下采样理论。</p><h1 id="采样理论">采样理论</h1><p>采样理论是信号系统中非常重要的一个理论，它在数字信号处理、数字通信、图像处理等众多领域都有着广泛的应用。</p><p>在实际应用中，我们通过一定的采样率把连续信号转换为离散信号，然后再对离散信号进行处理。处理完后，我们又可以通过一定的重构方法把离散信号转换回连续信号，以便在实际系统中使用。</p><h2 id="傅里叶级数">傅里叶级数</h2><p>那么如何表示任意一种信号呢？法国数学家傅里叶认为，任何周期函数（信号）都可以用正弦函数和余弦函数构成的无穷级数来表示，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-10.png?x-oss-process=image/resize,w_800" /></p><p>对于上图中的信号，使用傅里叶级数展开的表示如下所示。其中，这里 <spanclass="math inline">\(t\)</span> 表示时间，<spanclass="math inline">\(A\)</span> 表示振幅，<spanclass="math inline">\(w\)</span> 表示角频率。</p><span class="math display">\[\begin{aligned}f(x) = \frac{2Acos(tw)}{\pi} - \frac{2Acos(3tw)}{3\pi} +\frac{2Acos(5tw)}{5\pi} - \frac{2Acos(7tw)}{7\pi} + ...\end{aligned}\]</span><h2 id="时域与频域">时域与频域</h2><p>基于傅里叶级数，我们可以对信号的时域（以时间为横坐标）和频域（以频率为横坐标）进行相互转换：</p><ul><li>时域转换成频域：采用 <strong>傅里叶变换</strong>（FourierTransform）</li><li>频域转换成时域：采用 <strong>逆傅里叶变换</strong>（Inverse FourierTransform）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="走样原理">走样原理</h2><p>了解了信号的时域和频域之后，我们再来介绍走样的原理。</p><p>理想情况下，对一个连续信号进行采样后得到的离散信号，应该能够近似重构原始信号。然而，当采样频率低于原始信号的频率时，就会很容易出现走样的问题。换句话说，就是采样得到的离散信号无法近似重构原始信号。</p><p>下图所示，我们列举了几种信号，信号频率依次从高到低，我们使用相同的频率对这些信号进行采样。很显然，我们对低频信号进行采样时，由于采样频率大于信号频率，得到的离散信号可以近似重构原始信号；但是，我们对高频信号采样时，由于采样频率小于信号频率，得到的离散信号则无法近似重构原始信号。</p><p>因此走样的根本原因就是 <strong>采样频率小于信号频率</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-12.png?x-oss-process=image/resize,w_800" /></p><h1 id="滤波">滤波</h1><p>由于滤波在反走样中起到了重要作用，因此我们简单介绍一下图像处理中滤波。</p><p>如下图所示，通过傅里叶变换将左侧的像素空间（空间域）变为右侧的频谱（频域）。对于二维信号，其频谱的表示如下：</p><ul><li>高频部分代表细节、边缘、噪声</li><li>低频占据绝大多数能量，其中直流分量（零频）能量占比最大</li><li>频率分部具有中心对称性</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-13.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们来介绍一下几种常见的滤波。</p><h2 id="高通滤波">高通滤波</h2><p>高通滤波（High-passfilter），保留高频信号。在图像中，轮廓的边缘会发生剧烈变化，属于高频信号。经过高通滤波后，图像只会保留一些轮廓信息，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-14.png?x-oss-process=image/resize,w_800" /></p><h2 id="低通滤波">低通滤波</h2><p>低通滤波（Low-passfilter），保留低频信号。在图像中，颜色变化平缓的区域属于低频信号。经过低通滤波后，图像会抹去轮廓信息，如下图所示。模糊处理基于低通滤波实现的。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-15.png?x-oss-process=image/resize,w_800" /></p><h2 id="带通滤波">带通滤波</h2><p>带通滤波（Band-passfilter），顾名思义，只保留一部分频率范围内的信号。对图像滤波后的效果取决于带通滤波所选择的频率范围。下图所示，为两种不同频率范围的带通滤波。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-16.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-17.png?x-oss-process=image/resize,w_800" /></p><h2 id="卷积">卷积</h2><p>那么如何实现滤波呢？卷积（Convolution）就是实现滤波的主要数学工具和底层原理。滤波器的基本原理是<strong>响应函数与输入信号进行卷积运算</strong>，因此滤波器也可以称为<strong>卷积核</strong>。</p><p>如下所示，是卷积的数学定义，两个函数的 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 卷积 <span class="math inline">\(f *g(n)\)</span>。</p><span class="math display">\[\begin{aligned}连续形式：&amp;(f * g)(n) = \int_{-\infty}^{\infty}f(\tau)g(n-\tau)d\tau\\离散形式：&amp;(f * g)(n) = \sum_{-\infty}^{\infty}f(\tau)g(n-\tau)\end{aligned}\]</span><p>观察 <span class="math inline">\(f(\tau)\)</span> 和 <spanclass="math inline">\(g(n-\tau)\)</span> 的关系，可以发现是对<code>g</code> 函数进行了「翻转」，这就是「卷」的来源。同时，对两个函数<code>f</code> 和 <code>g</code> 进行积分，这就是「积」的来源。</p><p>卷积本身是一个很难解释的数学定义，如果你想深入理解卷积，这里推荐一篇知乎高赞回答——<ahref="https://www.zhihu.com/question/22298352/answer/228543288">传送门</a>。简而言之，<strong>两个函数的卷积，会先将一个函数翻转，然后进行滑动叠加</strong>。本质上可以将卷积理解成加权平均。</p><p>下图所示，是对图像进行滤波（卷积）的过程，实现模糊处理。基于傅里叶变换，我们可以实现时域（空间域）与频域之间的相互转换。<strong>时域（空间域）上对两个信号进行卷积，等同于频域上对两个信号的频率进行乘积</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-18.png?x-oss-process=image/resize,w_800" /></p><h1 id="反走样原理">反走样原理</h1><p>在「走样原理」一节中，我们提到了走样的根本原因是<strong>采样频率小于信号频率</strong>。在不提高采样频率的前提下，通过<strong>先滤波，后采样</strong>的方式可以实现反走样，这里的底层逻辑又是什么呢？</p><p>简单的理解就是，<strong>滤波（低通滤波，即模糊处理）会过滤掉信号中大于采样频率的信号分量</strong>。滤波后，剩余的信号分量的频率满足<strong>采样频率 &gt;= 信号频率</strong> 的条件，因此实现了反走样。</p><p>实现反走样的方法主要就是围绕两个角度来实现：</p><ul><li>提高采样频率。如：超采样技术（Supersampling）、多重采样抗锯齿（MSAA）、超分辨率</li><li>过滤高频信号。如：先模糊后采样（Pre-Filter）</li></ul><h1 id="遮挡与可见">遮挡与可见</h1><p>上述内容介绍了光栅化一个三角形的场景，以及其会遇到的问题——走样。下面，我们来介绍光栅化多个三角形会遇到的问题——遮挡与可见问题。</p><p>在 3D空间中，三角形之间存在着前后遮挡关系，那么三角形绘制的先后顺序应该是什么样的呢？</p><h2 id="画家算法">画家算法</h2><p>对此，我们先介绍一个经常被提到的算法：<strong>画家算法</strong>（Painter'sAlgorithm）。</p><p>画家算法，顾名思义，按照画家绘画时的先后顺序来执行，远的物体先绘制，进的物体后绘制，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-22.png?x-oss-process=image/resize,w_800" /></p><p>虽然画家算法适用于绝大多数场景，但是在某些场景下它仍然无法解决可见性问题。如下图所示，三个相互嵌套的三角形，使用画家算法则无法对三角形进行排序，因此无法准确实现光栅化。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-23.png?x-oss-process=image/resize,w_800" /></p><h2 id="深度缓冲算法">深度缓冲算法</h2><p>那么上述问题该如何解决呢？于是出现了<strong>深度缓冲算法</strong>（Z-Buffer Algorithm），其基本原理是：</p><ul><li>光栅化采用两个缓冲区<ul><li>原有的 <strong>帧缓冲区</strong>（FrameBuffer）存储每个像素颜色值</li><li>附加的<strong>深度缓冲区</strong>（Z-Buffer）存储每个像素深度值</li></ul></li><li>深度缓冲区存储每个像素当前的<strong>最小深度值</strong>（Z-Value）</li></ul><p>如下所示，为深度缓冲算法的伪代码实现。注意：我们会初始化深度值为无穷大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (each triangle T) &#123;</span><br><span class="line">    <span class="keyword">for</span> (each <span class="built_in">sample</span> (x, y, z) in T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z &lt; zbuffer[x, y]) &#123;            <span class="comment">// 处理深度更小的采样点</span></span><br><span class="line">            framebuffer[x, y] = rgb;        <span class="comment">// 更新颜色值</span></span><br><span class="line">            zbuffer[x, y] = z;              <span class="comment">// 更新深度值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示，使用深度缓冲算法光栅化两个三角形的示意图。当光栅化红色三角形时，我们遍历红色三角形的每一个像素的深度值，并与当前深度值进行比较。由于当前深度值均为无穷大，所以红色三角形的每一个像素都可以绘制。当光栅化蓝色三角形时，同样会遍历蓝色三角形每一个像素的深度值，并与当前深度值变换，深度值大于当前深度值，则不绘制；否则，绘制并更新当前深度值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-24.png?x-oss-process=image/resize,w_800" /></p><p>注意，这里的深度值比较取决于坐标系是如何建立的。按照我们之前的介绍，相机是沿着-Z 轴方向观测，因此深度越大，则 Z 值越小。</p><h1 id="总结">总结</h1><p>本文，我们主要介绍了光栅化技术。首先介绍了光栅化的含义以及栅格设备。其次，我们介绍了光栅化的基本单元——三角形。</p><p>在绘制单个三角形时，我们会遇到走样问题。对此我们介绍了反走样的两种方法：提高采样频率、过滤信号频率。我们着重介绍了后者，先滤波（模糊）后采样，并介绍了其中涉及的原理。</p><p>在绘制多个三角形时，我们会遇到遮挡问题。对此我们介绍了两种算法：画家算法、深度缓冲算法。</p><p>后续，我们还会继续介绍计算机图形学的其他内容，敬请期待吧~</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li><ahref="https://www.zhihu.com/question/22298352/answer/228543288">如何通俗易懂地解释卷积</a></li><li><ahref="https://www.zhihu.com/tardis/zm/art/54946461?source_id=1003">傅里叶变换与图像的频域处理</a></li><li><ahref="https://dezeming.top/wp-content/uploads/2022/04/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86.pdf">采样定理</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇 &lt;a
href=&quot;http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/&quot;&gt;文章&lt;/a&gt;
我们介绍了矩阵变换在计算机图形学中的应用，包括：视图变换、模型变换、投影变换。此外，我们还详细介绍了投影变换中的正交投影和透视投影，以及屏幕映射过程中的视口变换。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="画家算法" scheme="http://chuquan.me/tags/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    
    <category term="深度缓冲算法" scheme="http://chuquan.me/tags/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95/"/>
    
    <category term="采样" scheme="http://chuquan.me/tags/%E9%87%87%E6%A0%B7/"/>
    
    <category term="走样" scheme="http://chuquan.me/tags/%E8%B5%B0%E6%A0%B7/"/>
    
    <category term="滤波" scheme="http://chuquan.me/tags/%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="傅里叶级数" scheme="http://chuquan.me/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/"/>
    
    <category term="卷积" scheme="http://chuquan.me/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（3）——观测变换</title>
    <link href="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/"/>
    <id>http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/</id>
    <published>2024-03-23T09:29:30.000Z</published>
    <updated>2024-04-07T14:31:53.927Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们介绍了计算机图形学中的数学基础，包括：2D 变换、3D变换、齐次坐标等。本文，我们则来介绍将三维模型投影到二维屏幕的数学原理。</p><span id="more"></span><h1 id="观测变换">观测变换</h1><p>我们将三维模型投影到二维屏幕的过程称之为<strong>观测变换</strong>（Viewing Transformation）。</p><p>事实上，观测变换和我们平时拍照一样，总体可以分成三个步骤：</p><ul><li>摆放物体。在图形学中称为 <strong>模型变换</strong>（ModelTransformation）</li><li>摆放相机。在图形学中称为 <strong>视图变换</strong>（ViewTransformation）</li><li>拍照。在图形学中称为 <strong>投影变换</strong>（ProjectTransformation）</li></ul><p>根据这三个步骤的英文缩写，观测变换也可以称为 <strong>MVP变换</strong>。不过在图形学中，并不是严格按照这个顺序来执行的，而是先进行视图变换，再进行模型变换。至于为什么，我们稍后再解释。</p><p>下面，我们来分别介绍这三种变换。</p><h1 id="视图变换">视图变换</h1><p>视图变换也称为相机变换（CameraTransformation），视图的内容本质上是由相机的位置决定的，因此这里我们真正要做的是相机变换。</p><p>首先，我们使用如下三个向量来描述相机的<strong>原始位置</strong>，从而唯一确定其位置、观测方向、画面方向。</p><ul><li>位置：<span class="math inline">\(\vec{e}\)</span></li><li>观测方向：<span class="math inline">\(\hat{g}\)</span></li><li>向上方向：<span class="math inline">\(\hat{t}\)</span></li></ul><p>为了方便后续的计算，我们将相机放置到空间坐标系的原点，具体如下：</p><ul><li>位置：原点坐标</li><li>观测方向：<code>-Z</code></li><li>向上方向：<code>Y</code></li></ul><p>这里我们将变换后的观测方向设置为<code>-Z</code>，而在有些渲染引擎中观测方向为<code>Z</code>。这主要取决于空间坐标系的定义，本文我们使用的是右手坐标系。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-01.png?x-oss-process=image/resize,w_800" /></p><h2 id="如何变换">如何变换？</h2><p>那么具体我们该如何进行变换呢？一种非常直观的方法，按照四个步骤进行变换：</p><ul><li>将 <span class="math inline">\(\vec{e}\)</span> 平移变换至原点</li><li>将 <span class="math inline">\(\hat{g}\)</span> 旋转变换至<code>-Z</code></li><li>将 <span class="math inline">\(\hat{t}\)</span> 旋转变换至<code>Y</code></li><li>将 <span class="math inline">\(\hat{g} \times \hat{t}\)</span>旋转变换至 <code>X</code></li></ul><p>很显然，变换矩阵为平移变换和旋转变换的组合，即 <spanclass="math inline">\(M_{view} =R_{view}T_{view}\)</span>。其中，我们很容易就能求解平移变换的变换矩阵，如下。</p><span class="math display">\[\begin{aligned}T_{view}=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; -x_e \\0 &amp; 1 &amp; 0 &amp; -y_e \\0 &amp; 0 &amp; 1 &amp; -z_e \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><p>这里的难点在于求解几个旋转变换的变换矩阵 <spanclass="math inline">\(R_{view}\)</span>。那么，该如何求解呢？这里我们转换一下思路，考虑将位于原点的目标位置逆向转换至原始位置。通过这种方式我们可以得到<span class="math inline">\(R_{view}\)</span> 的逆矩阵 <spanclass="math inline">\(R_{view}^{-1}\)</span>。具体求解过程如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 \\0 \\0 \\0 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x_{\hat{g} \times \hat{t}} \\y_{\hat{g} \times \hat{t}} \\z_{\hat{g} \times \hat{t}} \\0 \\\end{matrix}\right)\\\\\left(\begin{matrix}? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}0 \\1 \\0 \\0 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x_{t} \\y_{t} \\z_{t} \\0 \\\end{matrix}\right)\\\\\left(\begin{matrix}? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}0 \\0 \\1 \\0 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x_{-g} \\y_{-g} \\z_{-g} \\0 \\\end{matrix}\right)\\\\解得：R_{view}^{-1}= &amp;\left(\begin{matrix}x_{\hat{g} \times \hat{t}} &amp; x_{t} &amp; x_{-g} &amp; 0 \\y_{\hat{g} \times \hat{t}} &amp; y_{t} &amp; y_{-g} &amp; 0 \\z_{\hat{g} \times \hat{t}} &amp; z_{t} &amp; z_{-g} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><p>由于旋转矩阵是正交矩阵，所以旋转矩阵的逆矩阵就是它的转置矩阵。由此得到：</p><span class="math display">\[\begin{aligned}R_{view}=\left(\begin{matrix}x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp;z_{\hat{g} \times \hat{t}} &amp; 0 \\x_{t} &amp; y_{t} &amp; z_{t} &amp; 0 \\x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="模型变换">模型变换</h1><p>根据相对性原理，相机完成了特定的变换后，我们也需要对模型进行同样的变换，这样通过相机投影得到的画面才会相对不变。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-02.png?x-oss-process=image/resize,w_800" /></p><p>根据上述的相机变换，我们得到了对应的变换矩阵。根据此变换矩阵，我们再对空间中的所有模型进行变换，即完成了模型变换。之后，我们即可进行投影变换。</p><p>由模型和相机要进行相同的变换，因此也将模型变换和视图变换统称为<strong>模型视图变换</strong>（ModelView Transformation）。</p><h1 id="投影变换">投影变换</h1><p>投影变换本质上就是将 3D 模型投影到 2D画布的过程，具体可以分为两种：</p><ul><li>正交投影（OrthographicProjection）：一般用于工程制图软件，不具有近大远小的透视效果。</li><li>透视投影（PerspectiveProjection）：一般用于游戏引擎、渲染引擎，模拟真实的效果。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-03.png?x-oss-process=image/resize,w_800" /></p><p>事实上，正交投影可以认为是一种特殊的透视投影，即相机位于无限远的位置，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-04.png?x-oss-process=image/resize,w_800" /></p><h2 id="正交投影">正交投影</h2><p>下面，我们先来介绍一下正交投影的两种方法。</p><h3 id="方法一">方法一</h3><p>方法一非常直观，即丢弃 Z 坐标，直接转换成二维坐标系，然后再将其缩放至<span class="math inline">\([-1, 1]^2\)</span>的矩形区域，如下所示。为什么要缩放至 <span class="math inline">\([-1,1]^2\)</span>的矩形区域？事实上，这也是为了方便后续计算，是一种约定俗成的做法。当然，这种方式也存在一个问题，无法直接判断模型之间的远近关系，这个我们后续再讨论。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-05.png?x-oss-process=image/resize,w_800" /></p><h3 id="方法二">方法二</h3><p>不过，更普遍的做法是方法二，包括后续的透视投影也采用了这种方法。</p><p>方法二提出了一个 <strong>观测空间</strong>（ViewVolumne）的概念，这一点非常重要。对于正交投影，它的观测空间是一个无限长的长方体，其中以2D 画布为近面，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-09.png?x-oss-process=image/resize,w_800" /></p><p>由于 2D画布可能是任意比例的矩形，为了方便计算，我们将这个长方体的观测空间转换成成一个规范立方体（CanonicalCube），即 <span class="math inline">\([-1, 1]^3\)</span> 的空间。</p><p>在将观测空间转换成规范立方体的过程中，我们会组合平移、缩放等变换，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-06.png?x-oss-process=image/resize,w_800" /></p><p>很显然，要将模型转换成标准立方体，我们必须计算出变换矩阵 <spanclass="math inline">\(M_{ortho}\)</span>。由于投影变换不涉及旋转，因此变换矩阵相对而言比较容易求解，如下所示。</p><span class="math display">\[\begin{aligned}M_{ortho}=S_{ortho}T_{ortho}=\left(\begin{matrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1  &amp; -\frac{n+f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><p>在将观测空间转换成规范立方体的过程中，我们计算得到了变换矩阵 <spanclass="math inline">\(M_{ortho}\)</span>。根据相对不变性原理，我们要使用<span class="math inline">\(M_{ortho}\)</span>对空间中所有物体进行同样的变换。这个过程，这里我们不再赘述。</p><h2 id="透视投影">透视投影</h2><p>透视投影则借鉴了正交投影的做法，只不过相对而言，它多了一步压缩过程，也就是说，透视投影= 压缩 + 正交投影。</p><p>下面，我们重点介绍一下压缩。</p><h3 id="压缩">压缩</h3><p>透视投影不同于正交投影，它的观测空间是一个无限长的纺锤体，其中以 2D画布为近面，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-10.png?x-oss-process=image/resize,w_800" /></p><p>压缩的本质就是将透视投影的观测空间压缩成正交投影的观测空间，即将纺锥体转换成长方体。然后，透视投影就换转化成了正交投影了。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-11.png?x-oss-process=image/resize,w_800" /></p><!--模型压缩本质上并不是真正对模型进行压缩，而是一种透视压缩。如下图所示，透视投影将空间中的一个点投影到一个 2D 的画布上，坐标点 `(x, y, z)` 中 `x` 和 `y` 的值会产生压缩效应，变成 `x'` 和 `y'`。--><!--![](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-07.png?x-oss-process=image/resize,w_800)--><!--因此，我们可以想像画布上的投影点和空间点构成一个纺椎体，然后对这个纺椎体进行压缩，如下图所示。`(x, y, z)` 经过压缩后会变成 `(x', y', z)`，再经过正交投影后会得到 `(x', y', z')`。--><p>那么，我们该如何求解压缩变换的变换矩阵 <spanclass="math inline">\(M_{persp-&gt;ortho}\)</span> 呢？</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-07.png?x-oss-process=image/resize,w_800" /></p><p>首先，由相似三角形定理，如上图所示，我们可以得出：</p><span class="math display">\[\begin{aligned}y^{&#39;}=\frac{n}{z}y;x^{&#39;}=\frac{n}{z}x\end{aligned}\]</span><p>然后，我们基于齐次坐标，结合三角形定理，计算得出投影点的坐标：</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x^{&#39;} \\y^{&#39;} \\z^{&#39;} \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx/z \\ny/z \\? \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx \\ny \\? \\z \\\end{matrix}\right)\end{aligned}\]</span><p>接下来，我们准备求解变换矩阵 <spanclass="math inline">\(M_{persp-&gt;ortho}^{4 \times4}\)</span>，得出一下关系式：</p><span class="math display">\[\begin{aligned}M_{persp-&gt;ortho}\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)= &amp;\left(\begin{matrix}nx \\ny \\? \\z \\\end{matrix}\right)\\解得：M_{persp-&gt;ortho}= &amp;\left(\begin{matrix}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\? &amp; ? &amp; ? &amp; ? \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{matrix}\right)\end{aligned}\]</span><p>最后，我们来求解第三行的值。我们基于两个以下两个依据：</p><ul><li>近平面上的点的值不会变化，即 2D 画布上的值不变。</li><li>远平面上的在 Z 轴上的点不会变化。</li></ul><p>根据第一个依据，我们可以得出以下关系式。即将 <code>z</code> 替换成<code>n</code>。</p><span class="math display">\[\begin{aligned}M_{persp-&gt;ortho}\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)=M_{persp-&gt;ortho}\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx \\ny \\n^2 \\n \\\end{matrix}\right)\\推导：\left(\begin{matrix}? &amp; ? &amp; ? &amp; ? \\\end{matrix}\right)\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)= &amp;n^2\\解得：\left(\begin{matrix}? &amp; ? &amp; ? &amp; ? \\\end{matrix}\right)= &amp;\left(\begin{matrix}0 &amp; 0 &amp; ? &amp; ? \\\end{matrix}\right)\end{aligned}\]</span><p>我们使用 <code>(0, 0, A, B)</code> 抽象表示<code>(0, 0, ?, ?)</code>。根据两条依据，我们可以得到一个二元一次方程组，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}0 &amp; 0 &amp; A &amp; B \\\end{matrix}\right)\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)= &amp;n^2=&gt; &amp;An + B = n^2\\\left(\begin{matrix}0 &amp; 0 &amp; A &amp; B \\\end{matrix}\right)\left(\begin{matrix}0 \\0 \\f \\1 \\\end{matrix}\right)= &amp;\left(\begin{matrix}0 \\0 \\f^2 \\f \\\end{matrix}\right)=&gt; &amp;Af + B = f^2\\解得：A= &amp;n + f\\B= &amp;-nf\end{aligned}\]</span><p>综上述，求解得出压缩变换的变换矩阵如下所示，其中 f是一个动态值，即空间点 <code>(x, y, z)</code> 的 <code>z</code> 值。</p><span class="math display">\[\begin{aligned}M_{persp-&gt;ortho}=\left(\begin{matrix}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{matrix}\right)\end{aligned}\]</span><p>对于透视投影，我们首先求解观测空间的压缩变换的变换矩阵 <spanclass="math inline">\(M_{persp-&gt;ortho}\)</span>，然后再利用在将转换后的长方体观测空间转换成规范立方体，即上文正交投影中求解的<span class="math inline">\(M_{ortho}\)</span>。</p><p>当然，根据相对不变性原理，我们还要将这两个变换矩阵应用到空间中所有的物体上，对它们进行变换。</p><h1 id="屏幕映射">屏幕映射</h1><p>当 MVP 变换完成之后，我们则要开始将投影内容绘制到 2D画布中，其中包含了裁剪和视口变换两个步骤。</p><h2 id="裁剪">裁剪</h2><p>无论是正交投影还是透视投影，我们都将观测空间转换成了一个规范立方体，同时将转换矩阵应用到空间中的所有物体中。</p><p>之后，我们就可以通过规范立方体对空间进行裁剪，只保留规范立方体内的物体，如下所示。很显然，只有在规范立方体中的部分才是我们可以看见的部分。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-12.png?x-oss-process=image/resize,w_800" /></p><h2 id="视口变换">视口变换</h2><p>视口（Viewport）本质上就是我们所说的 2D画布，即屏幕。我们知道屏幕有各种各样的分辨率，宽高比。为了处理这种情况，我们将2D 画布抽象成一个 <span class="math inline">\([-1, 1]^2\)</span>的规范平面。然后通过视口变换将它映射到真正的视口中。</p><p>假设真实视口的宽度是 <spanclass="math inline">\(width\)</span>，高度是 <spanclass="math inline">\(height\)</span>，那么视口变换就是将 <spanclass="math inline">\([-1, 1]^2\)</span> 的平面转换成 <spanclass="math inline">\([0, width] \times [0, height]\)</span>的平面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-13.png?x-oss-process=image/resize,w_800" /></p><p>对此，我们很容易求解变换矩阵，如下所示。</p><span class="math display">\[\begin{aligned}M_{viewport}=\left(\begin{matrix}\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文，我们主要介绍了观测变换的几个重点内容，包括视图变换、投影变换。其中，我们重点介绍了投影变换中的两种：正交投影和透视投影。</p><p>投影变换中提到了一个重要概念——观测空间。我们会将观测空间转换成一个规范立方体，根据相对不变性原理，对空间中所有物体做同样的变换。其中透视投影稍有复杂一点，我们会将纺锤体的观测空间转换成长方体的观测空间。</p><p>最后，我们将规范立方体以外的内容进行裁剪，并采用视口变换将内容映射到具体的屏幕上。</p><p>后面，我们将基于本章的内容继续介绍计算机图形学的相关基础。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li>Image Processing and Computer Graphics——Rendering Pipeline, MatthiasTeschner.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章我们介绍了计算机图形学中的数学基础，包括：2D 变换、3D
变换、齐次坐标等。本文，我们则来介绍将三维模型投影到二维屏幕的数学原理。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="观测变换" scheme="http://chuquan.me/tags/%E8%A7%82%E6%B5%8B%E5%8F%98%E6%8D%A2/"/>
    
    <category term="投影变换" scheme="http://chuquan.me/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"/>
    
    <category term="正交投影" scheme="http://chuquan.me/tags/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1/"/>
    
    <category term="透视投影" scheme="http://chuquan.me/tags/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>我的独立产品集</title>
    <link href="http://chuquan.me/2024/01/18/my-indie-hacker-products/"/>
    <id>http://chuquan.me/2024/01/18/my-indie-hacker-products/</id>
    <published>2024-01-18T15:09:42.000Z</published>
    <updated>2024-04-01T15:03:03.353Z</updated>
    
    <content type="html"><![CDATA[<p>本文罗列了一些我业余时间开发的独立产品，如果我写的博客对你有些许帮助，那我也诚邀你下载体验一下我开发的独立产品。当然，如果能够针对产品提出一些建议或给个好评，那真的不胜感激！这也会是我继续完善产品的动力！</p><span id="more"></span><h1 id="macos-应用">MacOS 应用</h1><h2 id="莫负休息">莫负休息</h2><p>莫负休息（Morph Rest）是一款 MacOS休息提醒应用程序。通过定时休息，可以预防视力疲劳、腰间盘突出、颈椎疼痛等职业病，当然也可以辅助提醒喝水，避免尿酸过高，引发肾结石、痛风等疾病。</p><p>莫负休息的主要特性：</p><ul><li>最低支持 MacOS 10.15 系统</li><li>支持浅色模式、深色模式</li><li>支持简体中文、繁体中文、英语、日语、韩语等多种语言</li><li>支持用户自定义工作、休息间隔</li><li>提供多种主题用于在休息期间展示</li></ul><p>下载地址——<ahref="https://apps.apple.com/cn/app/%E8%8E%AB%E8%B4%9F%E4%BC%91%E6%81%AF-%E4%BC%91%E6%81%AF%E6%8F%90%E9%86%92/id6474056217?mt=12">传送门</a></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-rest/0.9.0-common-market.png?x-oss-process=image/resize,w_800" /></p><h2 id="莫负时钟">莫负时钟</h2><p>莫负时钟（Morph Clock）是一款 MacOS屏幕保护程序。它采用了一种你从未见过的动态时钟效果，让你的 Mac成为办公室中最靓的仔~</p><p>莫负时钟的主要特性：</p><ul><li>最低支持 MacOS 10.14 系统。</li><li>动态渐变背景色，无时无刻都在变换颜色。</li></ul><p>下载地址——<ahref="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-clock/MorphClock.saver.zip">传送门</a></p><div data-align="center"><video src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-clock/MorphClock.mov" type="video/mp4" controls="controls" width="60%" height="60%"></video></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文罗列了一些我业余时间开发的独立产品，如果我写的博客对你有些许帮助，那我也诚邀你下载体验一下我开发的独立产品。当然，如果能够针对产品提出一些建议或给个好评，那真的不胜感激！这也会是我继续完善产品的动力！&lt;/p&gt;</summary>
    
    
    
    <category term="作品集" scheme="http://chuquan.me/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="Indie Hacker" scheme="http://chuquan.me/tags/Indie-Hacker/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（2）——变换</title>
    <link href="http://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/"/>
    <id>http://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/</id>
    <published>2024-01-18T13:29:31.000Z</published>
    <updated>2024-03-18T01:46:47.645Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<ahref="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">文章</a>我们介绍了计算机图形学中的线性代数基础，包括：点、向量、矩阵等。本文，我们将介绍向量和矩阵的进一步应用——变换。</p><span id="more"></span><h1 id="概述">概述</h1><p>计算机图形学中，我们可能会对图形进行各种变换（Transform），如：</p><ul><li>缩放（Scale）</li><li>平移（Transation）</li><li>旋转（Rotation）</li><li>切变（Shear）</li></ul><h1 id="d-变换">2D 变换</h1><p>首先，我们来介绍一下 2D变换，以便了解变换是如何通过矩阵变换来实现的。</p><h2 id="缩放变换">缩放变换</h2><p>对于缩放变换，它主要包含两种：等比例缩放、非等比缩放。</p><h3 id="等比例缩放">等比例缩放</h3><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-01.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为等比例缩放的示意图。根据等比例缩放的规则，我们可以根据缩放前<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; sx \\y&#39; =&amp; sy \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出缩放矩阵及关系式，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39;\end{matrix}\right)=\left(\begin{matrix}s &amp; 0 \\0 &amp; s \\\end{matrix}\right)\left(\begin{matrix}x \\y\end{matrix}\right)\end{aligned}\]</span><h3 id="非等比缩放">非等比缩放</h3><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-02.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为非等比缩放的示意图。根据非比缩放的规则，我们可以根据缩放前<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到另一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; s_xx \\y&#39; =&amp; s_yy \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出缩放矩阵及关系式，如下所示。对比一下，非等比缩放与等比例缩放的关系式非常相似。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}s_x &amp; 0 \\0 &amp; s_y \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)\end{aligned}\]</span><h2 id="镜像变换">镜像变换</h2><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-03.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为镜像变换的示意图。我们可以根据原始的 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; -x \\y&#39; =&amp; y \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出镜像矩阵及关系式，如下所示。本质上，镜像变换是一种特殊的缩放变换。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}-1 &amp; 0 \\0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y\end{matrix}\right)\end{aligned}\]</span><h2 id="切变变换">切变变换</h2><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-04.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为切变变换的示意图。切变变换相对复杂一点，其 <spanclass="math inline">\(y\)</span> 坐标值与 <spanclass="math inline">\(x\)</span>坐标值成一个比例关系。不过，我们仍然可以根据原始的 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; x + ay \\y&#39; =&amp; y \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出镜像矩阵及关系式，如下所示。本质上，镜像变换是一种特殊的缩放变换。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}1 &amp; a \\0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)\end{aligned}\]</span><h2 id="旋转变换">旋转变换</h2><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-05.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为旋转变换的示意图。旋转变换的坐标推导需要借助三角函数，最终可得到如下一组关系式。</p><span class="math display">\[\begin{aligned}x&#39; = cos{\theta}x - sin{\theta}y \\y&#39; = sin{\theta}x + cos{\theta}y \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出旋转矩阵及关系式，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)\end{aligned}\]</span><h2 id="平移变换">平移变换</h2><p>截止目前位置，所有的的变换都可以通过推导得出一个变换矩阵，以此矩阵乘以任意点（以矩阵表示），都可以得到转换后的点（以矩阵表示），符合线性变换。</p><p>下面，我们来看一下比较特殊的平移变换。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-06.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为平移变换的示意图，同样，我们也可以可得到如下一组关系式。</p><span class="math display">\[\begin{aligned}x&#39; = x + t_x \\y&#39; = y + t_y \\\end{aligned}\]</span><p>但是，我们进一步推导，得到的关系式与之前的变换不同，它有额外的偏移量，不符合线性变换，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}1 &amp; 0 \\0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)+\left(\begin{matrix}t_x \\t_y \\\end{matrix}\right)\end{aligned}\]</span><p>我们总是希望能使用一个统一的关系式来描述各种变换，然而，平移变换打破了我们的美好预期。那么该如何解决呢？为此，我们引入了齐次坐标。</p><h1 id="齐次坐标">齐次坐标</h1><p>为了能够统一表示所有变换，我们引入了<strong>齐次坐标</strong>（HomogenousCoordinates）。这里的核心思想是为每一个点或向量添加一个额外的 <spanclass="math inline">\(w\)</span> 坐标。</p><span class="math display">\[\begin{aligned}2D 点的齐次坐标表示：\left(\begin{matrix}x \\y \\1\end{matrix}\right)\\\\2D 向量的齐次坐标表示：\left(\begin{matrix}x \\y \\0 \\\end{matrix}\right)\end{aligned}\]</span><p>此时，我们再来尝试推导平移变换矩阵以及其关系式，可以得到如下所示内容。很显然，原来关系式中的偏移量没有了。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\w&#39; \\\end{matrix}\right)=\left(\begin{matrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\1 \\\end{matrix}\right)=\left(\begin{matrix}x+t_x \\y+t_y \\1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="仿射变换与线性变换">仿射变换与线性变换</h2><p>我们将线性变换和平移变换的组合，称为<strong>仿射变换</strong>（AffineTransform），如下所示。在未引入齐次坐标之前，我们推导出来的平移变换就是一种仿射变换。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}a &amp; b \\c &amp; d \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)+\left(\begin{matrix}t_x \\t_y \\\end{matrix}\right)\end{aligned}\]</span><p>当引入齐次坐标之后，所有的变换都可以统一使用线性变换来表示，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\1 \\\end{matrix}\right)=\left(\begin{matrix}a &amp; b &amp; t_x \\c &amp; d &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\1 \\\end{matrix}\right)\end{aligned}\]</span><p>如下所示，是引入齐次坐标后，缩放变换，旋转变换，平移变换所对应的变换矩阵。</p><span class="math display">\[\begin{aligned}缩放变换：&amp;S(s_x, s_y) =\left(\begin{matrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\旋转变换：&amp;R(\alpha) =\left(\begin{matrix}cos\alpha &amp; -sin\alpha &amp; 0 \\sin\alpha &amp; cos\alpha &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\平移变换：&amp;T(t_x, t_y) =\left(\begin{matrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="逆变换">逆变换</h1><p>我们将所有的反向变换都称为 <strong>逆变换</strong>（InverseTransform），比如：我们将从 A 平移到 B 称为平移变换，那么从 B 平移到 A则可称为逆变换，其他的缩放变换、旋转变换同样如此。</p><p>上一节，我们引入了齐次坐标后，所有的变换都可以转换成线性变换，其中以<span class="math inline">\(M\)</span>为变换矩阵。而这些变换的逆变换，同样可以使用线性变换来表示，并以 <spanclass="math inline">\(M\)</span> 的逆矩阵 <spanclass="math inline">\(M^{-1}\)</span> 为变换矩阵。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-07.png?x-oss-process=image/resize,w_800" /></p><h1 id="组合变换">组合变换</h1><p>在真实情况下，我们遇到的变换大多数都是组合变换，也就是同时包含了缩放、旋转、平移等多种变换。</p><p>多种变换组合时，变换的顺序其实是非常重要的，我们以如下一个例子来进行介绍。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-08.png?x-oss-process=image/resize,w_800" /></p><p>对于上面这种变换，如果我们先平移，再旋转，那么最终会变成如下所示的。这里的根本原因在于旋转变换时，仍然是以坐标原点为锚点进行旋转。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-09.png?x-oss-process=image/resize,w_800" /></p><p>对此，正确的顺序应该是先旋转，后平移，这样才能达到预期的效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-10.png?x-oss-process=image/resize,w_800" /></p><p>不同的顺序，矩阵变换的结果完全不同。前一篇文章我们提到过矩阵乘法不符合交换律，从这一点其实也能够解释这个现象。</p><p>在实际开发中，遇到这种类似的情况，我们一般都会先将目标平移至原点，然后进行各种其他变换，然后再通过逆变换平移回去。</p><h1 id="d-变换-1">3D 变换</h1><p>关于 3D 变换，本质上与 2D变换一样，只不过在矩阵表示上多了一个维度而已。</p><p>当我们引入齐次坐标之后，3D 的点和向量可以采用如下方式表示。</p><span class="math display">\[\begin{aligned}3D点的齐次坐标表示：&amp;\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)\\\\3D向量的齐次坐标表示：&amp;\left(\begin{matrix}x \\y \\z \\0 \\\end{matrix}\right)\end{aligned}\]</span><p>与此对应，3D 变换的矩阵变换关系式为如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\z&#39; \\1 \\\end{matrix}\right)=\left(\begin{matrix}a &amp; b &amp; c &amp; t_x \\d &amp; e &amp; f &amp; t_y \\g &amp; h &amp; i &amp; t_z \\0 &amp; 0 &amp; 0 &amp;1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="缩放变换-1">缩放变换</h2><p>如下所示，为 3D 空间中的缩放变换的变换矩阵的定义。</p><span class="math display">\[\begin{aligned}S(s_x, s_y, s_z)=\left(\begin{matrix}s_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; s_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="平移变换-1">平移变换</h2><p>如下所示，为 3D 空间中的平移变换的变换矩阵的定义。</p><span class="math display">\[\begin{aligned}T(t_x, t_y, t_z)=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; 0 &amp; t_y \\0 &amp; 0 &amp; 1 &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="旋转变换-1">旋转变换</h2><p>如下所示，为 3D空间中的旋转变换的变换矩阵的定义，沿着不同的轴旋转，变换矩阵的定义也有所不同。</p><span class="math display">\[\begin{aligned}R_x(\alpha)=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; cos\alpha &amp; -sin\alpha &amp; 0 \\0 &amp; sin\alpha &amp; cos\alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\R_y(\alpha)=\left(\begin{matrix}cos\alpha &amp; 0 &amp; sin\alpha &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-sin\alpha &amp; 0 &amp; cos\alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\R_z(\alpha)=\left(\begin{matrix}cos\alpha &amp; -sin\alpha &amp; 0 &amp; 0 \\sin\alpha &amp; cos\alpha &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文我们简单梳理了一下缩放、旋转、平移几种变换对应的矩阵关系式。其中，平移变换比较特殊，为了能够统一关系式，我们引入了齐次坐标，在点、向量的矩阵表示中增加了一个维度。然后，我们介绍了一下在组合变换中变换顺序的重要性。最后，我们简单总结了3D 变换的矩阵关系式。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li>《计算机图形学入门：3D渲染指南》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a
href=&quot;http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/&quot;&gt;文章&lt;/a&gt;我们介绍了计算机图形学中的线性代数基础，包括：点、向量、矩阵等。本文，我们将介绍向量和矩阵的进一步应用——变换。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="缩放变换" scheme="http://chuquan.me/tags/%E7%BC%A9%E6%94%BE%E5%8F%98%E6%8D%A2/"/>
    
    <category term="平移变换" scheme="http://chuquan.me/tags/%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2/"/>
    
    <category term="旋转变换" scheme="http://chuquan.me/tags/%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2/"/>
    
    <category term="切变变换" scheme="http://chuquan.me/tags/%E5%88%87%E5%8F%98%E5%8F%98%E6%8D%A2/"/>
    
    <category term="仿射变换" scheme="http://chuquan.me/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（1）——线性代数</title>
    <link href="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/"/>
    <id>http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/</id>
    <published>2024-01-15T12:09:48.000Z</published>
    <updated>2024-03-18T01:23:03.865Z</updated>
    
    <content type="html"><![CDATA[<p>最近对计算机图形学比较感兴趣，刷了一遍《计算机图形学入门：3D渲染指南》，看了一遍《GAMES101》。本文对计算机图形学的线性代数相关基础进行了梳理和总结，以便后续进行复习和回顾。</p><span id="more"></span><h1 id="点">点</h1><p><strong>点</strong>（Point）表示坐标系中的一个特定位置，其具体表示和抽象表示分别如下。</p><ul><li>使用 <strong>大写字母</strong> 的方式来抽象表示一个点，如：<spanclass="math inline">\(P\)</span>。</li><li>使用 <strong>圆括号 + 数字序列</strong>的方式来具体表示一个点，如：<span class="math inline">\((4,3)\)</span>。</li></ul><p>在具体表示中，数字序列的顺序很重要。按照惯例，在 2D 平面中依次表示<span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span> 轴的值；在 3D 空间中依次表示 <spanclass="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>、<span class="math inline">\(z\)</span>轴的值。对此，我们也可以结合两种方式来表示一个抽象的点，比如：<spanclass="math inline">\((P_x, P_y)\)</span>。</p><h1 id="向量">向量</h1><p><strong>向量</strong>（Vector）表示两个点所构成线段的长度和方向，其具体表示和抽象表示分别如下。</p><ul><li>向量的抽象表示一般有三种，分别是：<ul><li>使用 <strong>小写字母 + 箭头上标</strong> 的方式，如：<spanclass="math inline">\(\vec{a}\)</span>。</li><li>使用 <strong>加粗小写字母</strong> 的方式，如：<spanclass="math inline">\(\textbf{a}\)</span>。</li><li>使用 <strong>两个点 + 箭头上标</strong> 的方式，如：<spanclass="math inline">\(\overrightarrow{AB} = B -A\)</span>。注：大写字母表示点。</li></ul></li><li>向量的具体表示中，默认以坐标原点作为起点，因此只需要描述终点即可。向量一般使用矩阵来表示，包含两种方式，分别是：</li></ul><span class="math display">\[\begin{aligned}列向量表示法：&amp;\left(\begin{matrix}x \\y\end{matrix}\right)\\行向量表示法：&amp;\left(\begin{matrix}x &amp; y\end{matrix}\right)\end{aligned}\]</span><p>在定义中我们提到向量包含了两个点之间的长度和方向两种信息。对此，我们可以各自使用一种方式来表示这两种信息。</p><ul><li>使用 <strong>小写字母 + <code>^</code> 上标</strong> 的方式表示<strong>单位向量</strong>（Unit Vector），即长度等于 1 的向量，如：<spanclass="math inline">\(\widehat{a}\)</span>。一般用来表示方向。</li><li>使用 <strong>向量 + 双竖线</strong> 的方式表示<strong>向量长度</strong>（Vector Length），如：<spanclass="math inline">\(|\vec{a}|\)</span>。</li></ul><p>单位向量可以通过向量除以向量长度的方式计算得到，如下所示。</p><span class="math display">\[\begin{aligned}\widehat{a} = \vec{a} / |\vec{a}|\end{aligned}\]</span><p>在计算机图形学中，单位向量的应用非常多，比如：法线向量。在计算光线的折射和反射时，法线必不可少。</p><h2 id="向量的加减运算">向量的加减运算</h2><p>向量的加减运算可以使用 <strong>平行四边形法则</strong> 或<strong>三角形法则</strong> 进行计算，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-01.png?x-oss-process=image/resize,w_800" /></p><p>向量的加减运算非常简单，只需要把两个向量的对应坐标的值进行加减运算即可，如下所示。</p><span class="math display">\[\begin{aligned}\vec{a} + \vec{b}=\left(\begin{matrix}a_x &amp; a_y\end{matrix}\right)+\left(\begin{matrix}b_x &amp; b_y\end{matrix}\right)=\left(\begin{matrix}a_x + b_x &amp; a_y + b_y\end{matrix}\right)\\\vec{a} - \vec{b}=\left(\begin{matrix}a_x &amp; a_y\end{matrix}\right)-\left(\begin{matrix}b_x &amp; b_y\end{matrix}\right)=\left(\begin{matrix}a_x - b_x &amp; a_y - b_y\end{matrix}\right)\end{aligned}\]</span><h2 id="向量的乘法运算">向量的乘法运算</h2><p>向量的乘法运算比较特殊，它有两种乘法运算，分别是：</p><ul><li><strong>点积</strong>（Dot Product），或称<strong>点乘</strong></li><li><strong>叉积</strong>（Cross Product），或称<strong>叉乘</strong></li></ul><h3 id="点积">点积</h3><p>两个向量之间的点积是一个数值，一般使用 <strong>点运算符</strong>表示。</p><p>点积的运算非常简单，只要将每个向量对应的坐标值相乘并求和即可，如下所示为一个点积的示例。</p><span class="math display">\[\begin{aligned}\vec{a} \cdot \vec{b}=\left(\begin{matrix}a_x &amp; a_y &amp; a_z\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)=a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z\end{aligned}\]</span><p>向量点积的特性</p><ul><li>符合交换律，即 <span class="math inline">\(\vec{a} \cdot \vec{b} =\vec{b} \cdot \vec{a}\)</span></li><li>符合分配律，即 <span class="math inline">\(\vec{a} \cdot (\vec{b} +\vec{c}) = \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}\)</span></li><li>不符合结合律。点乘的结果是一个标量，不是向量，因此无法与另一个向量继续进行点乘运算。</li></ul><p>在计算机图形学中，点积的应用非常广泛，主要包括：</p><ul><li><strong>计算两个向量之间的夹角</strong></li><li><strong>计算一个向量在另一个向量上的投影</strong></li><li><strong>计算一个向量正交分解后的两个向量</strong></li><li><strong>判断一个向量相对于另一个向量是正向还是反向</strong></li></ul><p>下面，我们来看一下这几种应用是如果通过计算实现的。</p><p>首先，如何计算两个向量之间的夹角？在几何上，两个向量的点积与它们的长度以及它们之间的夹角<span class="math inline">\(a\)</span>有关，确切的公式巧妙地将线性代数和三角函数联系在了一起，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-02.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}\vec{a} \cdot \vec{b} =&amp; |\vec{a}| \cdot |\vec{b}| \cdot cos\theta\\cos\theta =&amp; \frac{\vec{a} \cdot \vec{b}}{|\vec{a}| \cdot |\vec{b}|}\\cos\theta =&amp; \widehat{a} \cdot \widehat{b}\end{aligned}\]</span><p>其次，如何计算一个向量在另一个向量上的投影？如下所示，求向量 <spanclass="math inline">\(\vec{b}\)</span> 在向量 <spanclass="math inline">\(\vec{a}\)</span> 上的投影 <spanclass="math inline">\(\vec{b}_\bot\)</span>，很显然，<spanclass="math inline">\(\vec{b}_\bot\)</span> 与 <spanclass="math inline">\(\vec{a}\)</span>的方向是一致的，只是长度可能不同。因此，我们可以通过前面提到的方式计算两者之间的夹角，然后计算投影长度，并使用该长度乘以单位向量<span class="math inline">\(\widehat{a}\)</span> 即可。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-03.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}\vec{b}_\bot =&amp; k \cdot \widehat{a}\\k =&amp; |\vec{b_\bot}| = |\vec{b}| \cdot cos\theta = |\vec{b}| \cdot\widehat{a} \cdot \widehat{b}\\\end{aligned}\]</span><p>接着，如何计算一个向量正交分解后的两个向量？上面我们在计算一个向量在另一个向量上的投影时，已经计算得到了一个方向的分解向量，另一个方向的分解向量我们只需通过向量减法即可得到，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-04.png?x-oss-process=image/resize,w_800" /></p><p>最后，如何判断一个向量相对于另一个向量是正向还是反向？判断两个向量的方向关系，本质上是看两者之间的夹角，如果是锐角，则认为是正向，如果是钝角，则认为是反向，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-05.png?x-oss-process=image/resize,w_800" /></p><h3 id="叉积">叉积</h3><p>两个向量之间的叉积是一个向量，一般使用 <strong>叉乘符号</strong>表示。</p><p>叉积是一个垂直于两个向量的向量，其方向可以通过<strong>右手螺旋定则</strong> 确定。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-06.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}\vec{c}= &amp;\vec{a} \times \vec{b}\\= &amp;\left(\begin{matrix}a_x &amp; a_y &amp; a_z\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)\\= &amp;\left(\begin{matrix}a_y \cdot b_z - a_z \cdot b_y \\a_z \cdot b_x - a_x \cdot b_z \\a_x \cdot b_y - a_y \cdot b_x \\\end{matrix}\right)\\即：\\c_x =&amp; a_y \cdot b_z - a_z \cdot b_y\\c_y =&amp; a_z \cdot b_x - a_x \cdot b_z\\c_z =&amp; a_x \cdot b_y - a_y \cdot b_x\end{aligned}\]</span><p>向量叉积的特性</p><ul><li>符合分配律，即 <span class="math inline">\(\vec{a} \times (\vec{b} +\vec{c}) = \vec{a} \times \vec{b} + \vec{a} \times \vec{c}\)</span></li><li>不符合结合律，即 <span class="math inline">\((\vec{a} \times\vec{b}) \times \vec{c} \neq \vec{a} \times (\vec{b} \times\vec{c})\)</span></li><li>不符合交换律，即 <span class="math inline">\(\vec{a} \times \vec{b}\neq \vec{b} \times \vec{a}\)</span></li></ul><p>在计算机图形学中，乘积的应用主要包括一下这些：</p><ul><li><strong>判断一个向量相对于另一个向量的左右关系</strong></li><li><strong>判断一个向量相对于一个三角形的内外关系</strong></li></ul><p>那么，如何判断一个向量相对于另一个向量的左右关系？可以直接判断两个向量叉积的正负值。如下所示，在一个3D 坐标中，<span class="math inline">\(\vec{a}\)</span> 和 <spanclass="math inline">\(\vec{b}\)</span>的叉乘符合右手螺旋定则的方向（图中与 Y 轴方向相同），则表示 <spanclass="math inline">\(\vec{A}\)</span> 在 <spanclass="math inline">\(\vec{B}\)</span> 的右边，反之则表示 <spanclass="math inline">\(\vec{A}\)</span> 在 <spanclass="math inline">\(\vec{B}\)</span> 的左边。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-07.png?x-oss-process=image/resize,w_800" /></p><p>以及，如何判断一个向量相对于一个三角形的内外关系？事实上，我们可以利用上面这种左右关系判断的方法来组合判断。如下所示，我们可以分别判断<span class="math inline">\(\overrightarrow{AP}\)</span> 和 <spanclass="math inline">\(\overrightarrow{AB}\)</span> 的左右关系，<spanclass="math inline">\(\overrightarrow{BP}\)</span> 和 <spanclass="math inline">\(\overrightarrow{BC}\)</span> 的左右关系，<spanclass="math inline">\(\overrightarrow{CP}\)</span> 和 <spanclass="math inline">\(\overrightarrow{CA}\)</span>的左右关系，如果前者都在后者的一边（左边或右边），那么 <spanclass="math inline">\(P\)</span> 就在三角形内；否则，在三角形外。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-08.png?x-oss-process=image/resize,w_800" /></p><h1 id="矩阵">矩阵</h1><p>矩阵是一个 <span class="math inline">\(m\)</span> 行 <spanclass="math inline">\(n\)</span> 列的数字阵列，通常我们使用一个<strong>加粗的大写字母</strong>抽象表示一个矩阵。在计算机图形学中，它被广泛应用于各种变换计算中，比如：平移、旋转、缩放等。</p><h2 id="矩阵的乘法运算">矩阵的乘法运算</h2><p>矩阵的乘法必须满足一个前提：矩阵 <spanclass="math inline">\(A\)</span> 的列数等于矩阵 <spanclass="math inline">\(B\)</span> 的行数，即<code>(M x N)(N x P) = (M x P)</code>。</p><p>矩阵 <span class="math inline">\(A\)</span> 乘以矩阵 <spanclass="math inline">\(B\)</span> 得到矩阵 <spanclass="math inline">\(C\)</span>，其中矩阵 <spanclass="math inline">\(C\)</span> 中的任意元素 <code>(i, j)</code>的值等于 <span class="math inline">\(A\)</span> 中第 <code>i</code> 行与<span class="math inline">\(B\)</span> 中第 <code>j</code>列的点积，如下所示是一个矩阵乘法的示例。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}1 &amp; 3 \\5 &amp; 2 \\0 &amp; 4 \\\end{matrix}\right)\left(\begin{matrix}3 &amp; 6 &amp; 9 &amp; 4 \\2 &amp; 7 &amp; 8 &amp; 3 \\\end{matrix}\right)=\left(\begin{matrix}9 &amp; 27 &amp; 33 &amp; 13 \\19 &amp; 44 &amp; 61 &amp; 26 \\8 &amp; 28 &amp; 32 &amp; 12 \\\end{matrix}\right)\end{aligned}\]</span><p>矩阵乘法的特性</p><ul><li>不符合交换律，即 <span class="math inline">\(AB \neqBA\)</span></li><li>符合分配律，即 <span class="math inline">\(A(B + C) = AB +BA\)</span></li><li>符合结合律，即 <span class="math inline">\((AB)C =A(BC)\)</span></li></ul><p>在计算机图形学中，向量也会使用矩阵（行矩阵或列矩阵）来表示，向量之间的乘法以及向量与矩阵的乘法都符合矩阵乘法的基本规则。</p><h2 id="矩阵的转置运算">矩阵的转置运算</h2><p>矩阵的转置本质上就是沿着主对角线（从左上角至右下角）的对角线将 i x j的矩阵翻转成 j x i 的矩阵。一般我们使用一个 <strong>上标 T</strong>表示一个矩阵的转置，如：<span class="math inline">\(A^T\)</span>。</p><p>如下所示，是一个矩阵转置运算的示例。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}1 &amp; 2 \\3 &amp; 4 \\5 &amp; 6 \\\end{matrix}\right)^T=\left(\begin{matrix}1 &amp; 3 &amp; 5 \\2 &amp; 4 &amp; 6 \\\end{matrix}\right)\end{aligned}\]</span><p>矩阵转置的特性</p><ul><li><span class="math inline">\((AB)^T = B^TA^T\)</span></li></ul><h2 id="矩阵的类型">矩阵的类型</h2><p>下面，我们来介绍各种不同类型的矩阵。</p><h3 id="对角矩阵">对角矩阵</h3><p>对角矩阵，其主对角线（从左上角到右下角）上的元素都是非0，其他元素都为 0。</p><h3 id="单位矩阵">单位矩阵</h3><p>单位矩阵，其主对角线（从左上角到右下角）上的元素都为 1，其余元素都为0，一般使用大写字母 <span class="math inline">\(I\)</span>来表示。单位矩阵是一个特殊的对角矩阵。如下所示，是一个单位矩阵实例。</p><span class="math display">\[\begin{aligned}I_{3 \times 3}=\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h3 id="逆矩阵">逆矩阵</h3><p>给定一个矩阵 <spanclass="math inline">\(A\)</span>，如果存在一个与之维度相同的矩阵，使得这两个矩阵相乘的结果是一个单位矩阵，那么我们称这个矩阵为矩阵<span class="math inline">\(A\)</span> 的逆矩阵，使用 <spanclass="math inline">\(A^{-1}\)</span>表示。如下所示，为逆矩阵的示例。</p><span class="math display">\[\begin{aligned}A A^{-1} =&amp; A^{-1}A = I\\(AB)^{-1} =&amp; B^{-1}A^{-1}\end{aligned}\]</span><h2 id="矩阵的应用">矩阵的应用</h2><p>上述我们介绍的向量的两种运算，其实完全可以使用矩阵的乘法来实现。</p><p>关于向量的点积，我们可以使用如下矩阵乘法来表示。</p><span class="math display">\[\begin{aligned}\vec{a} \cdot \vec{b}=\vec{a}^T \cdot \vec{b}=\left(\begin{matrix}a_x &amp; a_y &amp; a_z\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)=a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z\end{aligned}\]</span><p>关于向量的叉积，我们可以使用如下矩阵乘法来表示，如下所示。其中 <spanclass="math inline">\(A^*\)</span> 为矩阵 <spanclass="math inline">\(A\)</span> 的对偶矩阵。</p><span class="math display">\[\begin{aligned}\vec{a} \times \vec{b}=A^* b=\left(\begin{matrix}0    &amp; -a_z &amp; a_y \\a_z  &amp; 0    &amp; -a_x \\-a_y &amp; a_x  &amp; 0 \\\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)=\left(\begin{matrix}a_y \cdot b_z - a_z \cdot b_y \\a_z \cdot b_x - a_x \cdot b_z \\a_x \cdot b_y - a_y \cdot b_x \\\end{matrix}\right)\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文介绍了点、向量、矩阵的基本定义和运算方法。向量的乘法包含两种：点积和叉积，两者被广泛应用在了在计算机图形学中。</p><p>点积和叉积的具体运算可以通过矩阵运算来实现，这也是为什么我们常说计算机图形学中包含了大量矩阵运算。</p><p>下文，我们将探讨矩阵在图形的变换中的应用，敬请期待吧~</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li>《计算机图形学入门：3D渲染指南》</li><li><ahref="https://blog.csdn.net/weixin_42782150/article/details/104878759">史上最全Markdown公式、符号总结</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近对计算机图形学比较感兴趣，刷了一遍《计算机图形学入门：3D渲染指南》，看了一遍《GAMES
101》。本文对计算机图形学的线性代数相关基础进行了梳理和总结，以便后续进行复习和回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="向量" scheme="http://chuquan.me/tags/%E5%90%91%E9%87%8F/"/>
    
    <category term="矩阵" scheme="http://chuquan.me/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="点积" scheme="http://chuquan.me/tags/%E7%82%B9%E7%A7%AF/"/>
    
    <category term="叉积" scheme="http://chuquan.me/tags/%E5%8F%89%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>2023，31岁客三消从业者的年度回顾</title>
    <link href="http://chuquan.me/2024/01/05/2023-summary/"/>
    <id>http://chuquan.me/2024/01/05/2023-summary/</id>
    <published>2024-01-05T14:55:30.000Z</published>
    <updated>2024-01-05T15:19:59.154Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-01.jpg?x-oss-process=image/resize,w_600" /></p><span id="more"></span><p>每年总是要例行回顾一下过去一年，看看自己做了什么，收获了什么。</p><h1 id="角色适应">角色适应</h1><p>今年是作为移动客户端负责人的第 2年，自己基本已经适应了这个角色。一开始，我和团队中很多成员都是一线的研发，后面被提拔到这个位置。那时候，在技术决策、任务分配、会议沟通时，经常会想自己的决策和做法是否被认可？是否被信服？团队成员是否认可自己？总之，心理负担一直都是有的。</p><p>在业务的迭代和发展过程中，我会回顾自己做的决策。从结果看来，整体都是符合预期的，比如：</p><ul><li><strong>关于兄弟团队借人的决策</strong>。部门内有两条业务线，另一条业务线今年年初在快速发展，缺iOS 开发，于是经过部门老大的同意向我们借人，希望能够支援 3个月。，最终我决定让组内的几个同学轮流支援，每人支援一个月。一方面，可以避免外派同学产生边缘心理；另一方面，也可以避免借人还人的情况。</li><li><strong>关于提测质量竞赛的决策</strong>。年初在与测试同学的沟通中了解到：在服务端、前端、客户端的测试过程中，测试体验最差的往往都是客户端。当然，这里面是存在客观原因的。关于服务端，其主要是开发业务逻辑，不包含UI 逻辑，一旦联调完毕，在测试阶段 BUG其实是很少的；关于前端，其与客户端非常相似，区别在于前端在测试阶段可以热修复BUG，前一分钟还存在的BUG，后一分钟可能就解决了。关于客户端，相比服务端多了 UIBUG，相比前端修复周期比较长（修复、编译、验证、打包、提测）。最终产生客户端测试体验差的感觉。为了提高提测质量，提出了提测质量竞赛的机制，对于同一个需求，Android/iOSBUG 数量出现大于等于 5 的情况时，BUG数量少的一方和对应的测试同学将获得一杯喜茶，并记录在 Score Board中。一年下来，组内成员的自测意识确实提高了不少，产生的 BUG基本上都是测试用例之外的 BUG。</li></ul><p>正确的决策会带来正向的激励，从而产生正反馈效应。于是，之前心理负担开始慢慢的消失，自己对于这个角色也开始逐步适应，慢慢开始变得得心应手起来。</p><h1 id="工作产出">工作产出</h1><p>在工作产出方面，今年主要做了一些工程能力和技术调研等工作，比如：</p><ul><li>构建客户端 NodeJS 服务，支持 Sentry 崩溃告警、GitLab CodeReview、包体积分析等能力。</li><li>Cocos引擎定制的工程化，解决底层引擎替换问题，增加引擎日志，独立引擎打包等。</li><li>推进并落地 Cocos 资源代码隔离能力，从而让 App 内的 Cocos互动题具备全局的热修复能力。</li><li>直播自建、局部录屏、恢复购买、家庭共享、Deferred Deep Link等技术方案调研。</li></ul><p>今年，在 iOS同学外派支援期间，我做了一些业务需求，其他时间基本都没有参与复杂业务和模块的具体开发。因为团队内Android 和 iOS的研发人员数量对等，所以不需要我来承担额外的开发任务。只有当出现临时需求或者排期时没有分配的需求时，为了不打乱既定的排期，一般会由我来兜底做这些需求，一个人同时写Android 和 iOS。</p><p>整体而言，今年开始逐步退居二线，做一些技术决策和工程能力等相关工作。不过，在日常中我仍然坚持写代码，因为我始终觉得一旦自己脱离一线太久，很容易会作出一些不符合现实的决策和排期。</p><h1 id="身体是革命的本钱">身体是革命的本钱</h1><h2 id="眼睛疲劳">眼睛疲劳</h2><p>从 2021 年下半年到 2022年上半年，我一直有着眼睛疲劳的症状，具体表现就是<strong>眼睛无法准确对焦</strong>。当我在观察 3米以外的物体时，大脑中呈现的视觉效果是有两个物体（两个眼镜各自成像的物体），两个物体无法合成到一个画面中，需要非常努力的弄眉挤眼才能对焦上，但是过不了多久又会失焦。</p><p>这个问题我一直都没有发现，因为在工作生活中，眼睛对焦基本都在 3米以内。最后是在电影院观影时才发现的，画面有重影，观影感极差。从那时起，我才开始重视视力问题。</p><p>在 4月份，我预约了同仁医院的眼科挂号。在医院里，我看到了各种饱受眼科疾病困扰的患者，青光眼、视网膜脱落、近视手术后遗症等等，这让我视力恢复之前都非常焦虑。在经历一系列眼科诊断之后，医生得出的结论是眼睛疲劳+近视度数上涨。于是，在同仁医院配了一副眼镜，自己额外配了一副隔蓝光的镜片，配合着服用叶黄素，进行修养。总体来说，是有效果的，但是效果还是有点慢。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-02.jpg?x-oss-process=image/resize,w_600" /></p><p>在 5月份，五一长假休假在家，我尝试尽量不使用电脑和手机。即使使用电脑，也是投屏到电视上，然后坐在沙发上观看电视屏幕，尽量保持远距离观看。经过一个多星期的调养。眼睛疲劳改善非常明显。假期结束后，我期望着眼睛能完全恢复，可惜大概一个月作用的时间，眼睛又开始疲劳。特别是中午遇到强光时，症状会更加严重。</p><p>在 8月份，我开始意识到眼睛疲劳可能是因为睡前和醒后躺在床上刷手机导致的。每次睡觉前我都会不由自主地刷一个多小时的手机，早上醒来也是躺在床上刷一个多小时手机，加上姿势不正确，导致视力疲劳。于是，我开始强制自己在床上玩手机不超过20 分钟。坚持了半年了，现在视力明显恢复了。</p><p>在视力恢复之前，我一度非常焦虑，经常思考程序员的职业给我带来了什么？如果视力无法治疗该怎么办？...好在现在恢复了，这次经历让我明白了身体健康的重要性。一定要注意身体，不要让打工挣的钱成为身体的医疗费！从而言之，身体是革命的本钱。</p><h2 id="运动健身">运动健身</h2><h3 id="健身">健身</h3><p>8 月份，在 <span class="citation" data-cites="昱总">@昱总</span>的安利下，我办了天奥的健身卡，怕自己坚持不下来，先办了一年的年卡。由于 8月份期间参加各种篮球赛，所以真正开始规律健身应该是从 9月份开始，周一练背，周四练肩，周五练手臂，偶尔练练卧推。目前卧推能 60KG做组，左右手力量也均衡了很多。除此之外，双十一配了肌酸和蛋白粉，喝的不算多，佛系健身。于我而言，健身的目的是为了自己变得壮一点，而不是看起来像细狗，仅此而已，什么健体、健美并不是我的目标。</p><h3 id="篮球">篮球</h3><p>今年算是工作以来打篮球最多的一年了，首先是固定每周二中午打 2小时篮球。另外就是篮球赛，8 月参加了 CBD 篮球联赛，9 月参加了 CYBA篮球联赛，这两个月周末总有一天是在打篮球。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-03.jpg?x-oss-process=image/resize,w_600" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-04.jpg?x-oss-process=image/resize,w_600" /></p><h3 id="跑步">跑步</h3><p>2022年终总结时给自己定了一个目标——<strong>参加一次半程马拉松</strong>。因此，我计划参加4月份的北京半程马拉松。结果，等到报名时发现要求必须三年内参加过其他马拉松，并提供相关证明。没办法，没有资格参加，只能选择参加奥森马拉松。</p><p>我从 2.25 开始备战，从 5 公里开始，每周跑一次，每次比上一次增加 2.5公里左右，最终达到 21 公里。练了一次 21公里后，参加比赛。最终成绩还不错，用时 <code>2:01:52</code>。定一个 2024年的小目标——<strong>半马破 2 小时</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-05.jpg?x-oss-process=image/resize,w_320" /></p><p>参加半马之后，我开始坚持每周末都跑一次 10公里，偶尔还会参加一下线上马拉松，收集了不少奖牌。最终坚持到了 10月底，11 月份室外跑步属实太冷了，打算 2 月份重新开始。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-06.jpg?x-oss-process=image/resize,w_800" /></p><h3 id="作息">作息</h3><p>正是办了健身卡之后，我和媳妇开始调整生活作息，拒绝熬夜，晚上 11:20之前睡觉。早上差不多能 6、7点起床，起来后去四得公园，媳妇跑步，我则散步。在公园大概 40分钟，期间能呼吸一下新鲜空气，放空一下大脑。当然在一个人散步的时候会思考很多，比如：职业规划、业余项目、技术问题等。散步结束回来大概8 点左右，还能有两个小时看会儿书或写会儿代码。</p><p>调整作息之后，感觉自己的精神状态好了很多，下班时间的使用效率也变得更高了。当然，周末也不再是没有上午的周末，时间也变得更加充足。作息调整是今年个人转变的最大成就，为了健康和效率，未来一直要继续保持下去。</p><h1 id="学习收获">学习收获</h1><p>上半年因为眼睛问题，有意减少电脑使用时间，下半年业余时间主要在项目，因此整体而言，2023年在学习上投入的时间并不是很多。关于学习方面的成就主要有以下几部分。</p><h2 id="书籍">书籍</h2><p>因为尽量不过度用眼，今年看的书并不多，只有以下几本：</p><ul><li>《第一行代码——Android（第3版）》</li><li>《架构师的自我修炼》</li><li>《程序员修炼之道》</li><li>《On Java 基础版》</li><li>《重构》</li><li>《程序员的自我修养》三刷</li><li>《计算机图形学入门：3D渲染指南》</li></ul><h2 id="博客">博客</h2><p>今年写的博客也不多，年初的时候产出了几篇编程语言相关的博客：<ahref="http://chuquan.me/2023/01/15/actor/">《浅谈 Actor 模型》</a>、<ahref="http://chuquan.me/2023/03/11/structured-concurrency/">《结构化并发》</a>、<ahref="http://chuquan.me/2023/04/22/prototype-based-inheritance/">《基于原型的继承模式》</a>。</p><p>年中的时候研究 Homebrew 和 fishhook 产出了两篇原理分析博客：<ahref="http://chuquan.me/2023/06/24/understand-fishhook-design/">《如何从链接原理的角度理解fishhook 的设计思想？》</a>、<ahref="http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/">《Homebrew的设计哲学》</a>。</p><p>最后就是十一那会儿写了两篇关于差分算法的博客：<ahref="http://chuquan.me/2023/09/13/myers-difference-algorithm/">《Myers差分算法 》</a>、<ahref="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/">《PaulHeckel 差分算法》</a>。</p><h2 id="项目">项目</h2><p>今年业余时间总共做了三个半项目，相比之前几年，产出高出了不少，希望明年继续保持。</p><p>第一个项目是 <ahref="https://github.com/baochuquan/taskloop">Taskloop</a>。这是一款基于crontab的定时任务管理器，支持语义化的配置规则，并且支持环境变量导入、日持查询等功能。具体介绍详见<ahref="http://chuquan.me/2023/07/30/introduction-to-taskloop/">《如何优雅地管理你的定时任务？》</a>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800" /></p><p>第二个项目是 Morph Clock（中文名：莫负时钟）屏幕保护程序。这是一款MacOS 屏幕保护程序，采用一种数字变形的艺术效果实现。</p><p>第三个项目是 <ahref="https://apps.apple.com/us/app/morph-rest-break-reminder/id6474056217">MorphRest</a>（中文名：莫负休息）。这是一款 MacOS休息提醒应用程序，预防眼睛疲劳、腰间盘突出、劲椎疼痛等职业病，也可辅助提醒喝水，避免尿酸过高，引发痛风等疾病。为什么做这个项目？主要有两方面原因：一方面，我经历了眼睛疲劳，迫切需要一款软件能够经常提醒我站起来活动活动，让视线远离屏幕，顺带提醒自己多喝水。另一方面，我希望打造一款独立产品，尝试利用业务时间成为一位IndieHacker。于是，差不多花了一个半月的业余时间，完成了项目，并最终上架。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-07.png?x-oss-process=image/resize,w_800" /></p><p>Morph Clock 和 Morph Rest 则是面向普通 Mac用户的独立产品。项目代码并没有开源，因为我希望能够通过它们创造收入，这里定一个小目标：<strong>在未来2024 年内通过独立产品创造 99美元的收入，回收的开通苹果开发者账号的成本</strong>。如果有用户支持，欢迎下载使用。</p><h2 id="其他">其他</h2><p>其他方面的学习收获也是有的，首先是 Android开发，春节假期期间，在家学习了一下 Android 开发，重写了海豚 AI学中的一个 Flutter 页面，算是入门了 Android。鉴于此，下半年能够做一些Android 小需求。但是没有深入研究 Android开发，也没有做过一些复杂业务开发，这一方面希望 2024 年能够有所改善。</p><p>其次，在下半年做独立产品期间，系统性地学习了 Sketch相关技巧和理论。Morph Rest 和 Morph Clock 相关的 UI设计和切图也都是自己完成的，算是额外掌握了一个 Indie Hacker必备的技能吧。</p><p>最后，系统性地学习了一下 MacOS 开发，它与 iOS开发在整体上一致的，在一些实现细节上有所不同。如果按照自己所认知的 iOS原理来开发 MacOS 应用会遇到很多奇怪的 BUG。在系统性学习之后，再来开发MacOS 应用会简单很多，这一点我深有体会。</p><h1 id="生活不只有工作">生活不只有工作</h1><p>今年是工作以来第一个没有债务的年份，因此不再考虑紧巴巴地生活了，该吃吃，该喝喝，该玩玩。不过因为疫情三年养成了一种「宅」感，所以还需要继续调整和适应。</p><h2 id="假期">假期</h2><h3 id="合肥">合肥</h3><p>五一假期回合肥休假，为了调养眼睛疲劳，没怎么学习，主打的就是休假。期间主要在滨湖转悠，骑上共享电驴，环游了一些景点和公园，渡江战役纪念馆、岸上草原、安徽名人馆、塘西河公园、金斗公园等。比较可惜的是，没约上安徽美术馆，不过以后有的是机会。</p><p>在家期间，用闲置的 Mac Mini配上电视，效果很不错，也很护眼。用这一套装置在家看完了《漫长的季节》！《漫长的季节》成为了我心中国产剧的No.1，墙裂推荐！</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-09.jpg?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-10.jpg?x-oss-process=image/resize,w_800" /></p><h3 id="廊坊">廊坊</h3><p>7月份，我在朋友圈看到有同事去了廊坊的只有红楼梦·梦幻戏剧城，感觉很不错，加上自己很喜欢《红楼梦》，所以抽了一个周末去了一趟廊坊。园区非常大，网上的评价大多是一天的游玩时间不够，于是我们就订了2 日通票。不得不说，里面的建筑和剧场都非常惊艳！绝对值得去玩一次！</p><p>不过很可惜，我们去的那个周末天气不太好。周六阴天，周日暴雨。因为暴雨园区闭园，给我们退了一半的票，算下来也就是玩了一天时间，差不多玩了大半个园区吧，只不过话剧和情景剧没看够。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-08.jpg?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-11.jpg?x-oss-process=image/resize,w_800" /></p><h3 id="哈尔滨">哈尔滨</h3><p>今年 10月份原本打算去哈尔滨，结果跟我弟了解了一下情况后，决定等到冰雪大世界开放之后再去。最终在元旦前请了几天假提前出发，主要是为了避开假期旅游高峰。好巧不巧，哈尔滨旅游今年出圈了，游客非常多，几个热门项目排队时间都超长，几乎每个都要排队3个小时起步，比如：大滑梯、摩天轮、哈冰秀。我们在冰雪大世界整一天就是佛系游玩，毕竟在零下十度的室外排队几个小时的体验可不是那么好。不过有一说一，冰雪大世界里的冰雕、雪雕确实都非常精美、壮观，绝对值得去参观一次！</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-12.jpg?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-13.jpg?x-oss-process=image/resize,w_600" /></p><h2 id="搬家">搬家</h2><p>今年 10 月份搬了一次家，离开了住了 6年的高家园。高家园附近环境其实很不错，小区门口很多街边商店，很繁华；马路对面就是丽都，是一个相对比较高端的街区；500米远处是四得公园，疫情期间翻修了一次，环境非常不错。因为生活很方便，所以在这里住了6年。搬家期间，特别是对面的室友搬走的时候，内心非常感慨：岁月匆匆，人生匆匆，北漂生活何时终了？</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-14.jpg?x-oss-process=image/resize,w_600" /></p><h1 id="思维转变">思维转变</h1><p>2023 年，我感觉自己最大的变化是思维的转换，主要是两点：</p><ul><li>身体是最重要的，其他的一切都是身外之物。</li><li>打工是没有出来的，提前计划自己的未来。</li></ul><p>第一点不用多说，是眼睛疲劳期间非常焦虑，那会儿才真正体会和理解这一点。第二点是因为今年8月开始早起散步，散步期间开始思考未来的打算。这两年各种裁员消息层出不穷，即使你学历再好，技术再厉害，当公司不需要你时，无外乎其他任何因素，随时都可能裁你。一旦失业，你再就业的难度会与你的年龄正比，这是非常现实的问题。</p><p>于是，我开始逛一下独立开发者相关的网站，比如：Indie Hacker，ProductHunt，w2solo。在这些论坛中，我看到了很多独立开发者的成功案例，这也激励了我尝试使用业余时间来走这条道路。11月份，我开始着手做一款 iOSApp，期间自己做产品调研，画设计稿，代码实现。期间感觉自己对于产品的最终效果还是有点不确定，而且担心战线太长，所以果断暂停了项目，转而开发形态更加确定的一款MacOS App——<ahref="https://apps.apple.com/cn/app/morph-rest-break-reminder/id6474056217?mt=12">MorphRest</a>。期间，还写了一个MacOS 屏幕保护程序——MorphClock。这些产品未来不一定能成功，但是我不迈出这一步，那么永远都不会成功。</p><h1 id="新年愿景">新年愿景</h1><p>未来一年，我应该还会继续尝试做一些独立产品，努力成为 IndieHacker。当然，技术博客也会被不定期更新，毕竟这是热爱，而不是生活。</p><p>最后，祝新年快乐~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-01.jpg?x-oss-process=image/resize,w_600&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="年度总结" scheme="http://chuquan.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Sketch Cheat Sheet</title>
    <link href="http://chuquan.me/2023/10/21/sketch-cheat-sheet/"/>
    <id>http://chuquan.me/2023/10/21/sketch-cheat-sheet/</id>
    <published>2023-10-21T14:01:50.000Z</published>
    <updated>2023-10-21T14:05:47.410Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/sketch-exercise01.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>我的博客文章配图基本上都是使用 Sketch绘制的，但是绘制方法仅限我的自我认知而已。由于没有系统性地学习过Sketch，因此在遇到一些复杂场景时，绘制的效率非常低。于是最近业余时间在 B站上学习了一套 Sketch 教程——<ahref="https://www.bilibili.com/video/BV1hd4y1z7pZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=247f8a5d677ea1cff0161b9afe62e41f">《Sketch零基础速学教程（矢量绘图设计工具）》</a>。</p><p>这里记录一下教程中提到的快捷键技巧，便于后续参考。经过实测，这些技巧确实能够提升效率，文章封面图就是学完教程结合技巧绘制的图标。</p><h1 id="快捷键">快捷键</h1><h2 id="基础快捷键">基础快捷键</h2><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">新建画板（New Artboard）</td><td style="text-align: left;">A</td></tr><tr class="even"><td style="text-align: left;">插入矩形（Rectangle）</td><td style="text-align: left;">R</td></tr><tr class="odd"><td style="text-align: left;">插入原型（Oval）</td><td style="text-align: left;">O</td></tr><tr class="even"><td style="text-align: left;">插入文本（Text）</td><td style="text-align: left;">T</td></tr><tr class="odd"><td style="text-align: left;">钢笔工具（Vector Point）</td><td style="text-align: left;">V</td></tr><tr class="even"><td style="text-align: left;">放大（Zoom</td><td style="text-align: left;">按住 Z，然后框选想放大的区域</td></tr><tr class="odd"><td style="text-align: left;">查看间距（Guides）</td><td style="text-align: left;">Alt（选中一个图层，按住Alt，鼠标移动移动到另一个图层，可查看选中图层到指向图层的间距）</td></tr><tr class="even"><td style="text-align: left;">创建分组（Group）</td><td style="text-align: left;">⌘ G</td></tr><tr class="odd"><td style="text-align: left;">取消分组（Ungroup）</td><td style="text-align: left;">⌘ ⇧ G</td></tr><tr class="even"><td style="text-align: left;">复制上一步操作（Duplicate</td><td style="text-align: left;">⌘ D</td></tr><tr class="odd"><td style="text-align: left;">编辑（Edit）</td><td style="text-align: left;">Enter</td></tr></tbody></table><h2 id="吸管工具">吸管工具</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">吸取颜色（Color Picker）</td><td style="text-align: left;">⌃ C</td></tr></tbody></table><h2 id="复制样式">复制样式</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">复制图层样式（Copy Style）</td><td style="text-align: left;">⌘ ⌥ C</td></tr><tr class="even"><td style="text-align: left;">粘贴图层样式（Paste Style）</td><td style="text-align: left;">⌘ ⌥ V</td></tr></tbody></table><h2 id="视图模式">视图模式</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">演示模式（Presentation Mode）</td><td style="text-align: left;">⌘ .</td></tr><tr class="even"><td style="text-align: left;">以画布为中心放大（Center Canvas）</td><td style="text-align: left;">⌘ 1</td></tr><tr class="odd"><td style="text-align: left;">以选择的图层为中心放大（ZoomSelection）</td><td style="text-align: left;">⌘ 2</td></tr><tr class="even"><td style="text-align: left;">视图放大</td><td style="text-align: left;">⌘ +</td></tr><tr class="odd"><td style="text-align: left;">视图缩小</td><td style="text-align: left;">⌘ -</td></tr><tr class="even"><td style="text-align: left;">恢复到画布实际大小</td><td style="text-align: left;">⌘ 0</td></tr></tbody></table><h2 id="图层">图层</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">在图层面板从上往下选择图层（SelectingLayer Below）</td><td style="text-align: left;">tab</td></tr><tr class="even"><td style="text-align: left;">在图层面板从下往上选择图层（SelectingLayer Below）</td><td style="text-align: left;">⇧ tab</td></tr><tr class="odd"><td style="text-align: left;">上移图层（Bring Forward）</td><td style="text-align: left;">⌘ ]</td></tr><tr class="even"><td style="text-align: left;">下移图层（Bring Backward）</td><td style="text-align: left;">⌘ [</td></tr><tr class="odd"><td style="text-align: left;">置顶图层（Bring to Front）</td><td style="text-align: left;">⌘ ⌥ ]</td></tr><tr class="even"><td style="text-align: left;">置底图层（Bring to End）</td><td style="text-align: left;">⌘ ⌥ [</td></tr></tbody></table><h2 id="相关补充">相关补充</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">隐藏图层</td><td style="text-align: left;">⌘ ⇧ H</td></tr><tr class="even"><td style="text-align: left;">锁定图层</td><td style="text-align: left;">⌘ ⇧ L</td></tr><tr class="odd"><td style="text-align: left;">查找图层</td><td style="text-align: left;">⌘ F</td></tr><tr class="even"><td style="text-align: left;">变换工具</td><td style="text-align: left;">⌘ ⇧ T</td></tr><tr class="odd"><td style="text-align: left;">旋转工具</td><td style="text-align: left;">⌘ ⇧ R</td></tr><tr class="even"><td style="text-align: left;">将字体转换成轮廓</td><td style="text-align: left;">⌘ ⌥ O</td></tr><tr class="odd"><td style="text-align: left;">显示/取消填充</td><td style="text-align: left;">F</td></tr><tr class="even"><td style="text-align: left;">显示/取消描边</td><td style="text-align: left;">B</td></tr><tr class="odd"><td style="text-align: left;">将当前图层用作蒙版</td><td style="text-align: left;">⌘ ⌃ M</td></tr><tr class="even"><td style="text-align: left;">改变形状尺寸</td><td style="text-align: left;">⌘ 键盘上/下/左/右</td></tr><tr class="odd"><td style="text-align: left;">切换不同的 Sketch 文件</td><td style="text-align: left;">⌘ ~</td></tr></tbody></table><h2 id="设置">设置</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">打开设置</td><td style="text-align: left;">⌘ ,</td></tr></tbody></table><h1 id="屏幕分辨率尺寸">屏幕分辨率尺寸</h1><table><thead><tr class="header"><th style="text-align: left;">设备</th><th style="text-align: left;">屏幕尺寸</th><th style="text-align: left;">屏幕分辨率（px）</th><th style="text-align: left;">逻辑分辨率（pt）</th><th style="text-align: left;">PPI</th><th style="text-align: left;">倍率</th><th style="text-align: left;">换算</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">iPhone14</td><td style="text-align: left;">6.1寸</td><td style="text-align: left;">1170x2532</td><td style="text-align: left;">390x844</td><td style="text-align: left;">460</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone12 Pro Max</td><td style="text-align: left;">6.7寸</td><td style="text-align: left;">1284x2778</td><td style="text-align: left;">428x926</td><td style="text-align: left;">458</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="odd"><td style="text-align: left;">iPhone12 Pro</td><td style="text-align: left;">6.1寸</td><td style="text-align: left;">1170x2532</td><td style="text-align: left;">390x844</td><td style="text-align: left;">460</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone11 Pro Max</td><td style="text-align: left;">6.5寸</td><td style="text-align: left;">1242x2688</td><td style="text-align: left;">414x896</td><td style="text-align: left;">458</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="odd"><td style="text-align: left;">iPhone11 Pro</td><td style="text-align: left;">6.1寸</td><td style="text-align: left;">1125x2436</td><td style="text-align: left;">375x812</td><td style="text-align: left;">458</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone11</td><td style="text-align: left;">5.8寸</td><td style="text-align: left;">828x1792</td><td style="text-align: left;">414x896</td><td style="text-align: left;">326</td><td style="text-align: left;"><span class="citation"data-cites="2x">@2x</span></td><td style="text-align: left;">1pt=2px</td></tr><tr class="odd"><td style="text-align: left;">iPhone8 Plus</td><td style="text-align: left;">5.5寸</td><td style="text-align: left;">1242x2208</td><td style="text-align: left;">414x736</td><td style="text-align: left;">401</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone8</td><td style="text-align: left;">4.7寸</td><td style="text-align: left;">750x1334</td><td style="text-align: left;">375x667</td><td style="text-align: left;">326</td><td style="text-align: left;"><span class="citation"data-cites="2x">@2x</span></td><td style="text-align: left;">1pt=2px</td></tr><tr class="odd"><td style="text-align: left;">iPhoneSE</td><td style="text-align: left;">4.0寸</td><td style="text-align: left;">640x1136</td><td style="text-align: left;">320x568</td><td style="text-align: left;">326</td><td style="text-align: left;"><span class="citation"data-cites="2x">@2x</span></td><td style="text-align: left;">1pt=2px</td></tr><tr class="even"><td style="text-align: left;">iPhone3GS</td><td style="text-align: left;">3.5寸</td><td style="text-align: left;">320x480</td><td style="text-align: left;">320x480</td><td style="text-align: left;">163</td><td style="text-align: left;"><span class="citation"data-cites="1x">@1x</span></td><td style="text-align: left;">1pt=1px</td></tr></tbody></table><p>UI 设计一般以 390x844 或 375x812 为尺寸进行绘制。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/sketch-exercise01.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计" scheme="http://chuquan.me/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Sketch" scheme="http://chuquan.me/tags/Sketch/"/>
    
  </entry>
  
  <entry>
    <title>Paul Heckel 差分算法</title>
    <link href="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/"/>
    <id>http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/</id>
    <published>2023-10-06T14:01:00.000Z</published>
    <updated>2023-10-07T00:13:19.803Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇 <ahref="http://chuquan.me/2023/09/13/myers-difference-algorithm/">文章</a>我们介绍了 Myers差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——PaulHeckel 差分算法。</p><span id="more"></span><h1 id="解决什么问题">解决什么问题？</h1><p>通过前一篇文章，我们知道 Myers 差分算法主要用于<strong>解决特定设定下的最小编辑距离问题</strong>，即：当编辑操作只支持<strong>插入</strong> 和 <strong>删除</strong> 时，计算一个文件从<code>A</code> 状态转换成 <code>B</code>状态所需的最少编辑次数（或编辑方式）。算法特别适用于对编辑次数敏感，但是对速度和内存不敏感的系统，比如版本控制系统。</p><p>对比而言，Paul Heckel 差分算法则主要用于<strong>解决最小化差异问题</strong>，即：当一个文件从 <code>A</code>状态转换成 <code>B</code>状态时，两种状态之间的数据差异。算法会为每一项差异定义一个对应的类型（操作），比如：删除、插入、移动等，其侧重点在于最小化差异，而不是最小化编辑。PaulHeckel 差分算法特别适合对计算速度敏感，但是对于<strong>差异不敏感</strong> 的系统，比如实时数据分析系统，UI框架数据差分。</p><h1 id="算法原理">算法原理</h1><h2 id="核心思想">核心思想</h2><p>Paul Heckel算法使用三种类型来表示两个文件之间的差异结果，分别是：<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。基于此，算法的核心思路其实非常简单，分别是：</p><ul><li><strong>确定旧文件中待删除的行</strong></li><li><strong>确定新文件中待插入的行</strong></li><li><strong>确定旧文件至新文件中待移动的行，并记录行号关系（旧文件行号、新文件行号）</strong></li></ul><h2 id="数据结构">数据结构</h2><p>很显然，根据算法的核心思想，新旧两个文件中的所有行最终都将被分类为三种类型（如果行的内容和位置都没有变化，则分类为移动类型，只不过移动的行号保持不变而已）。</p><p>Paul Heckel 差分算法使用两个数组 <code>NA</code>（New Array）和<code>OA</code>（OldArray）分别记录新旧两个文件的每一行的信息。数组元素分为两种类型：<strong>指针</strong>或<strong>行号</strong>。通过这种方式，我们可以对新旧两个文件中的所有行进行分类：</p><ul><li>当旧文件中某一行在 <code>OA</code>中对应的元素为指针时，表示这一行是待删除的。</li><li>当新文件中某一行在 <code>NA</code>中对应的元素为指针时，表示这一行是待插入的。</li><li>当新文件（旧文件）中某一行在<code>NA</code>（<code>OA</code>）中对应的元素为行号时，表示这一行是待移动的。行号记录了它在旧文件（新文件）的位置。两两配对。</li></ul><p>这里提到了数组元素可能是指针类型，那么它到底指向什么类型的数据呢？事实上，这是Paul Heckel 算法预定义的一种数据类型，这里我们称之为 entry 类型。entry的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">entry</span> &#123;</span><br><span class="line">    <span class="type">int</span> oc;         <span class="comment">// old count. 记录该行在旧文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> nc;         <span class="comment">// new count. 记录该行在新文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> olno;       <span class="comment">// old line number. 记录该行在旧文件中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为了方便快速查找某一行所对应的entry，这里还定义了一个哈希表，算法中称为 <strong>符号表（SymbolTable）</strong>，其中 Key 为行内容，Value 为 entry。</p><p>如下所示，为算法所定义的相关数据结构。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-01.png?x-oss-process=image/resize,w_800" /></p><h1 id="算法实现">算法实现</h1><p>算法的实现主要分为三个部分，分别是：</p><ul><li>构建阶段</li><li>移动类型筛选</li><li>分析输出</li></ul><p>下面依次进行介绍。</p><h2 id="构建阶段">构建阶段</h2><p>在构建阶段，将遍历新文件和旧文件的每一行，同时构建数组、符号表表项（Key为行内容，Value 为 Entry）。</p><ul><li>对于新文件，在构建 Entry 时，对 <code>nc</code> 字段加 1。</li><li>对于旧文件，在构建 Entry 时，对 <code>oc</code> 字段加 1，并设置<code>olno</code> 为当前的行号。</li></ul><p>在构建数组（ <code>NA</code> 和 <code>OA</code>）时，其元素均为指针类型，指向当前行对应在符号表中的 entry。</p><p>很显然，构建阶段需要进行两次遍历，其对应在论文中分别是 Pass 1 和 Pass2。</p><h2 id="移动类型筛选">移动类型筛选</h2><p>在构建阶段完成后，数组 <code>NA</code> 和 <code>OA</code>中的所有元素都是指针类型，指向符号表中的某个entry。接下来，只要我们把属于 <strong>移动</strong>类型的行筛选出来，也就是把数组中的某些元素修改为行号，即可完成对三种类型的分类。</p><p>在继续介绍之前，我们先说明一种常见的情况：<strong>一个文件中行内容可能是唯一项，也可能是重复项</strong>。比如，在下图所示的两个文件中，<code>THE</code>在新旧两个文件中都重复出现了两次，<code>A</code>、<code>MASS</code>、<code>OF</code>等内容在各自的文件中都是唯一项。对此，算法的处理方式也有所不同。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-03.png?x-oss-process=image/resize,w_800" /></p><h3 id="唯一项筛选">唯一项筛选</h3><p>对于唯一项，很显然，如果符合移动类型的话，行所对应的 entry 中的<code>oc</code> 和 <code>nc</code> 的值均为1，表示它们在新旧文件中各自只出现了一次。</p><p>由于移动类型是对等的，所以我们只需要遍历 <code>NA</code>数组就可以找到所有唯一项的移动类型。具体的做法是：</p><ul><li>遍历 <code>NA</code> 数组，根据元素（指针类型）找到对应的entry。</li><li>判断 entry 的 <code>oc</code> 和 <code>nc</code> 字段是否均为 1。<ul><li>如果符合条件，则将 <code>NA</code>对应的位置的元素设置成行号类型，值为<code>olno</code>（即该行对应在旧文件中的位置）；同时将 <code>OA</code>的 <code>olno</code> 位置的元素设置成行号类型，值为<code>i</code>（即当前遍历到的行号）。此时，两者实现了移动匹配（各自记录了彼此的位置）。</li><li>如果不符合条件，则将继续遍历 <code>NA</code>。</li></ul></li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-04.png?x-oss-process=image/resize,w_800" /></p><p>在遍历完成后，数组 <code>NA</code> 和 <code>OA</code>中均可能有一部分元素变成了行号类型，值为对方的某个行号。本轮遍历对应在论文中是Pass 3。</p><h3 id="重复项筛选">重复项筛选</h3><p>对于重复项，算法采用了一种模糊处理的方式。这里主要遵循了下面这个设定：</p><blockquote><p>If a line has been found to be unaltered, and the lines immediatelyadjacent to it in both files are identical, then these lines must be thesame line. This information can be used to find blocks of unchangedlines.</p><p>译：如果某一行没有发生改变，并且在新旧两个文件中与它紧邻的行都是相同的，那么这些行必须是相同的行。这个信息可以用来找到未改变的行块。</p></blockquote><p>上述设定需要寻找某一行前后邻近的行，很显然，需要进行两次遍历，分别是正向遍历和反向遍历。同样，这里只需要遍历<code>NA</code> 即可。</p><p>对于正向遍历，会进行以下处理：</p><ul><li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示<code>NA[i]</code> 指向 <code>OA[j]</code>）<ul><li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>类型的行，那么继续判断 <code>NA[i+1]</code> 是否与 <code>OA[j+1]</code>指向同一个 entry。<ul><li>如果是，则将 <code>NA[i+1]</code> 的元素设置成行号类型，值为<code>j+1</code>；将 <code>OA[j+1]</code> 的元素设置成行号类型，值为<code>i+1</code>。</li></ul></li></ul></li><li>此外其他情况均继续遍历 <code>NA</code>。</li></ul><p>对于反向遍历，其处理与正向遍历类似，只不过方向相反：</p><ul><li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示<code>NA[i]</code> 指向 <code>OA[j]</code>）<ul><li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>类型的行，那么继续判断 <code>NA[i-1]</code> 是否与 <code>OA[j-1]</code>指向同一个 entry。<ul><li>如果是，则将 <code>NA[i-1]</code> 的元素设置成行号类型，值为<code>j-1</code>；将 <code>OA[j-1]</code> 的元素设置成行号类型，值为<code>i-1</code>。</li></ul></li></ul></li><li>此外其他情况均继续遍历 <code>NA</code>。</li></ul><p>经过这一番操作后，算法会处理筛选出重复项，下图所示红色标识。这些重复项的<strong>移动</strong> 类型，可以与某些唯一项连成<strong>移动块</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-02.png?x-oss-process=image/resize,w_800" /></p><p>重复项的筛选，经历了两次遍历，分别对应论文中的 Pass 4 和 Pass 5。</p><h2 id="分析输出">分析输出</h2><p>经过上述一系列处理之后，数组 <code>NA</code> 和 <code>OA</code>将所有行分成了三种类型，分别是<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。根据这些信息，我们可以遍历<code>NA</code> 和<code>OA</code>，输出差异的分析结果。这一步，对应在论文中则是 Pass6。</p><h1 id="算法缺陷">算法缺陷</h1><p>至此，仔细的同学可能会发现，在重复项筛选的过程中，算法会遗漏一部分属于<strong>移动</strong> 类型的行，而将它们误判为 <strong>删除</strong> 或<strong>插入</strong> 类型。</p><p>如下所示为算法误判的一个例子。我们将新文件中的第一个 <code>THE</code>前后相邻的两个行改成两个唯一项 <code>UNIQUE1</code> 和<code>UNIQUE2</code>。由于旧文件中不存在 <code>UNIQUE1</code> 和<code>UNIQUE2</code>，所以它们是属于插入类型的项。此时，我们再看上述Pass 4 和 Pass 5 的执行逻辑，可以看出新文件中的第一个 <code>THE</code>并不会并筛选为移动类型，而是被错误地认为是插入类型。所以说，Paul Heckel算法对于重复项的处理采用了一种模糊处理的方式。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-05.png?x-oss-process=image/resize,w_800" /></p><p>事实上，这也是 Paul Heckel差分算法的特点，它牺牲了一部分差异精准度，换来了更快的分析速度。这也是为什么我们在「解决了什么问题」这一节中说Paul Heckel 算法适合速度敏感、差异不敏感的系统。</p><h1 id="算法应用">算法应用</h1><p>基于 Paul Heckel 算法变种的差分算法应用其实非常多，在 iOS开发中就有很多相关的框架，比如：IGListKit、DifferenceKit、RxDataSources、FlexibleDiff、DeepDiff等。下面，我们来看看 IGListKit 是如何应用并优化 Paul Heckel差分算法的。</p><h2 id="类型扩展">类型扩展</h2><p>由于绝大多数应用都对 Paul Heckel算法进行了一定程度的优化，因此，我们必须要先了解它们到底优化了什么。</p><p>事实上，原始的 Paul Heckel 算法只对 <strong>位置</strong> 和<strong>内容</strong> 两个维度进行差分检测（符号表的 Key和数据判等都是基于 <strong>内容</strong>），从而产生 3种分类，如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">位置</th><th style="text-align: left;">内容</th><th style="text-align: left;">分类</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move（起始位置不变）</td></tr><tr class="even"><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr><tr class="odd"><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move</td></tr><tr class="even"><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr></tbody></table><p>但是在实际应用中，为了支持更加复杂多变的场景，一般会额外支持<strong>标识</strong> 或 <strong>ID</strong> 的维度。此时，算法将基于<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong>三个维度进行差分检测（符号表的 Key 基于<strong>标识</strong>，数据判等基于 <strong>内容</strong>），对此将产生4 种分类，如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">标识（ID）</th><th style="text-align: left;">位置</th><th style="text-align: left;">内容</th><th style="text-align: left;">分类</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move（起始位置不变）</td></tr><tr class="even"><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">update</td></tr><tr class="odd"><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move</td></tr><tr class="even"><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">update &amp; move</td></tr><tr class="odd"><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">insert/delete</td></tr><tr class="even"><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr><tr class="odd"><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">insert/delete</td></tr><tr class="even"><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr></tbody></table><h2 id="iglistdiff">IGListDiff</h2><h3 id="数据结构-1">数据结构</h3><p>在数据结构定义上，IGListDiff与原始算法类似，也定义了一个符号表和两个数组，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-06.png?x-oss-process=image/resize,w_800" /></p><p>对于符号表，IGListDiff 使用数据的标识（ID）作为 Key，以<code>IGListEntry</code> 作为 Value。<code>IGListEntry</code>的定义如下所示，很显然，它与原始算法中的 <code>entry</code>结构非常类似：</p><ul><li><code>oldCounter</code> 和 <code>newCounter</code> 对应的是<code>oc</code> 和 <code>nc</code> 字段。</li><li><code>oldIndex</code> 对应<code>olno</code>，但是它支持记录多个位置信息，支持处理重复项。<code>olno</code>只能记录一个位置。</li><li><code>IGListEntry</code> 额外还有一个 <code>updated</code>字段，用于标记扩展的 <strong>更新</strong>（update）类型。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Used to track data stats while diffing.</span></span><br><span class="line"><span class="keyword">struct</span> IGListEntry &#123;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the old array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> oldCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the new array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The indexes of the data in the old array</span></span><br><span class="line">    stack&lt;<span class="built_in">NSInteger</span>&gt; oldIndexes;</span><br><span class="line">    <span class="comment">/// Flag marking if the data has been updated between arrays by checking the isEqual: method</span></span><br><span class="line">    <span class="type">BOOL</span> updated = <span class="literal">NO</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于两个数组，IGListDiff同样具备，区别在于元素的表示形式。在原始算法中，<code>NA</code> 和<code>OA</code> 数组存储的元素可能是指针或行号，而 IGListDiff 则使用<code>IGListRecord</code>类型来记录两种信息，其定义如下所示。其中，<code>entry</code>用于存储指针，<code>index</code> 用于存储行号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Track both the entry and algorithm index. Default the index to NSNotFound</span></span><br><span class="line"><span class="keyword">struct</span> IGListRecord &#123;</span><br><span class="line">    IGListEntry *entry;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">NSInteger</span> index;</span><br><span class="line"></span><br><span class="line">    IGListRecord() &#123;</span><br><span class="line">        entry = <span class="literal">NULL</span>;</span><br><span class="line">        index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，IGListDiff 定义一个 <code>IGListDiffable</code>协议，所有希望调用 IGListDiff 差分算法的数据都必须支持该协议。如下所示为<code>IGListDiffable</code> 的定义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListDiffable)</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListDiffable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a key that uniquely identifies the object.</span></span><br><span class="line"><span class="comment"> @return A key that can be used to uniquely identify the object.</span></span><br><span class="line"><span class="comment"> @note Two objects may share the same identifier, but are not equal. A common pattern is to use the `NSObject` category for automatic conformance. However this means that objects will be identified on their pointer value so finding updates becomes impossible.</span></span><br><span class="line"><span class="comment"> @warning This value should never be mutated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;)diffIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns whether the receiver and a given object are equal.</span></span><br><span class="line"><span class="comment"> @param object The object to be compared to the receiver.</span></span><br><span class="line"><span class="comment"> @return `YES` if the receiver and object are equal, otherwise `NO`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToDiffableObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;IGListDiffable&gt;)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>算法会使用数据的 <code>diffIdentifier</code>作为标识（ID），符号表也将以此为 Key 记录对应的 entry。另一个协议方法<code>isEqualToDiffableObject:</code> 则用于进行内容判等。</p><p>关于输出，原始算法并没有做相关说明。对此，IGListDiff自定义了两种输出结构，分别是 <code>IGListIndexSetResult</code> 和<code>IGListIndexPathResult</code>，如下所示。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexPathResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexPathResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The index paths inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *inserts;</span><br><span class="line"><span class="comment">// The index paths deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *deletes;</span><br><span class="line"><span class="comment">// The index paths in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *updates;</span><br><span class="line"><span class="comment">// The moves from an index path in the old collection to an index path in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndexPath *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexSetResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexSetResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The indexes inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *inserts;</span><br><span class="line"><span class="comment">// The indexes deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *deletes;</span><br><span class="line"><span class="comment">// The indexes in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *updates;</span><br><span class="line"><span class="comment">// The moves from an index in the old collection to an index in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndex *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>两者均携带了所有差异数据的位置信息，包括：插入、删除、更新、移动。区别则在于<code>IGListIndexPathResult</code> 用于表示位置信息的类型是<code>NSIndexPath</code> 类型，适用于 iOS中的列表数据，<code>IGListIndexSetResult</code> 用于表示位置信息的类型是<code>NSInteger</code> 类型，更适合通用的数组数据。</p><h3 id="核心逻辑">核心逻辑</h3><p>IGListDiff 中 <code>IGListDiff.m</code> 文件的<code>IGListDiffing</code>方法实现了差分算法的核心逻辑，大概可分为三个步骤：</p><ul><li><strong>构建阶段</strong></li><li><strong>标记移动类型和更新类型</strong></li><li><strong>格式化输出</strong></li></ul><h4 id="构建阶段-1">构建阶段</h4><p>在构建阶段，IGListDiff分别正向遍历新数据和反向遍历旧数据，从而构建数组元素<code>NA</code>、<code>OA</code>、符号表，这一点与原始算法类似。这里反向遍历旧数据是因为这里使用栈来记录所有的<code>olno</code>，以便后续正向地出栈旧数据的位置信息。具体代码如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;, IGListEntry, IGListHashID, IGListEqualID&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 1</span></span><br><span class="line"><span class="comment">// create an entry for every item in the new array</span></span><br><span class="line"><span class="comment">// increment its new count for each occurence</span></span><br><span class="line">vector&lt;IGListRecord&gt; newResultsArray(newCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(newArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.newCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add NSNotFound for each occurence of the item in the new array</span></span><br><span class="line">    entry.oldIndexes.push(<span class="built_in">NSNotFound</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    newResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 2</span></span><br><span class="line"><span class="comment">// update or create an entry for every item in the old array</span></span><br><span class="line"><span class="comment">// increment its old count for each occurence</span></span><br><span class="line"><span class="comment">// record the original index of the item in the old array</span></span><br><span class="line"><span class="comment">// MUST be done in descending order to respect the oldIndexes stack construction</span></span><br><span class="line">vector&lt;IGListRecord&gt; oldResultsArray(oldCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(oldArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.oldCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the original indices where the item occurred onto the index stack</span></span><br><span class="line">    entry.oldIndexes.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    oldResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标记移动类型和更新类型">标记移动类型和更新类型</h4><p>构建完成之后，开始对移动类型和更新类型进行标记，具体如下代码所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass 3</span></span><br><span class="line"><span class="comment">// handle data that occurs in both arrays</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    IGListEntry *entry = newResultsArray[i].entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grab and pop the top original index. if the item was inserted this will be NSNotFound</span></span><br><span class="line">    <span class="built_in">NSCAssert</span>(!entry-&gt;oldIndexes.empty(), <span class="string">@&quot;Old indexes is empty while iterating new item %li. Should have NSNotFound&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> originalIndex = entry-&gt;oldIndexes.top();</span><br><span class="line">    entry-&gt;oldIndexes.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// originalIndex 存在表示「标识相同」。这里判断 originalIndex &lt; oldCount 应该是为了做越界保护。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex &lt; oldCount) &#123;</span><br><span class="line">        <span class="comment">// 对于「内容不同」的项，将其标记为更新类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; n = newArray[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; o = oldArray[originalIndex];</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffPointerPersonality:</span><br><span class="line">                <span class="comment">// 基于指针判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffEquality:</span><br><span class="line">                <span class="comment">// 基于指针 + 内容判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o &amp;&amp; ![n isEqualToDiffableObject:o]) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，并且内容不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0 表示新旧数据均存在</span></span><br><span class="line">    <span class="comment">// originalIndex != NSNotFound 的是为了让新旧数据两两匹配，因为 oldIndexes 随着遍历的迭代，始终在出栈。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex != <span class="built_in">NSNotFound</span></span><br><span class="line">        &amp;&amp; entry-&gt;newCounter &gt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; entry-&gt;oldCounter &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 对于「内容相同」的项，交换记录其在对方数组中的位置，表示移动类型</span></span><br><span class="line">        newResultsArray[i].index = originalIndex;</span><br><span class="line">        oldResultsArray[originalIndex].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，每次迭代会从根据 <code>NA</code> 数组元素<code>IGListRecord</code> 的 <code>entry</code> 字段索引到符号表中对应的<code>IGListEntry</code>。然后从 <code>IGListEntry</code> 的<code>oldIndexes</code> 字段出栈一个旧文件中存在的位置。</p><p>如果 <code>originalIndex</code> 存在，则表示 <code>NA</code> 和<code>OA</code> 均存在，此时进一步判断内容，如果内容发生了变化则标记<code>updated</code> 字段为<code>YES</code>。判断内容变化的方式有两种，用户可以选择配置：</p><ul><li><strong>基于指针判断</strong>：如果指针不同，则表示数据发生了变化</li><li><strong>基于指针+内容判断</strong>：如果指针不同，并且内容不同，则表示数据发生了变化</li></ul><p>在遍历过程中，还会记录移动类型的位置信息。它的前提条件包含两部分：</p><ul><li><code>newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0</code>：表示新旧数据均存在</li><li><code>originalIndex != NSNotFound</code>：表示新旧数据可以进行移动类型的匹配，每一次匹配，<code>oldIndexes</code>都会出栈一次，消耗一次对等的匹配。举个例子：<ul><li>如果 <code>newCounter = 3</code>，<code>oldCounter = 2</code>时，<code>NA</code>中第三个数据会被归为插入类型，前两个数据会被归为移动类型。</li><li>如果 <code>newCounter = 2</code>，<code>oldCounter = 3</code>时，<code>OA</code>中的第三个数据会被归为删除类型，前两个数据会被归为移动类型。</li></ul></li></ul><h4 id="格式化输出">格式化输出</h4><p>首先，遍历 <code>OA</code>数组，确定删除类型，具体代码如下所示。数组元素的 <code>index</code>类型为 <code>NSNotFound</code> 类似于原始算法中 <code>OA</code>元素的类型为指针。当符合这个条件时，表示数据类型为删除类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterate old array records checking for deletes</span></span><br><span class="line"><span class="comment">// incremement offset for each delete</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">    deleteOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = oldResultsArray[i];</span><br><span class="line">    <span class="comment">// if the record index in the new array doesn&#x27;t exist, its a delete</span></span><br><span class="line">    <span class="comment">// 对 OA 中的删除项进行分类</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，遍历 <code>NA</code>数组，确定插入、更新、移动等类型，具体代码如下所示。数组元素的<code>index</code> 类型为 <code>NSNotFound</code> 类似于原始算法中<code>NA</code>元素的类型为指针。当符合这个条件时，表示数据类型为插入类型。否则，均属于移动类型。</p><p>这里由于 IGListDiff 额外扩展了一个 <code>updated</code>字段，所以有一部分元素为同时标记为更新类型。这一点其实很容易理解，当新旧数据中有一个数据标识相同，但是位置不同，且内容不同，我们可以认为它做了一次移动操作修改了位置，又做了一次更新操作修改了内容。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    insertOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = newResultsArray[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> oldIndex = record.index;</span><br><span class="line">    <span class="comment">// add to inserts if the opposing index is NSNotFound</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定插入类型</span></span><br><span class="line">        addIndexToCollection(returnIndexPaths, mInserts, toSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// note that an entry can be updated /and/ moved</span></span><br><span class="line">        <span class="keyword">if</span> (record.entry-&gt;updated) &#123;</span><br><span class="line">            <span class="comment">// 确定更新类型</span></span><br><span class="line">            addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate the offset and determine if there was a move</span></span><br><span class="line">        <span class="comment">// if the indexes match, ignore the index</span></span><br><span class="line">        <span class="comment">// 确定移动类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> insertOffset = insertOffsets[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> deleteOffset = deleteOffsets[oldIndex];</span><br><span class="line">        <span class="keyword">if</span> ((oldIndex - deleteOffset + insertOffset) != i) &#123;</span><br><span class="line">            <span class="type">id</span> move;</span><br><span class="line">            <span class="keyword">if</span> (returnIndexPaths) &#123;</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *from = [<span class="built_in">NSIndexPath</span> indexPathForItem:oldIndex inSection:fromSection];</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *to = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:toSection];</span><br><span class="line">                move = [[IGListMoveIndexPath alloc] initWithFrom:from to:to];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                move = [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i];</span><br><span class="line">            &#125;</span><br><span class="line">            [mMoves addObject:move];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, toSection, i, newArray[i], newMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化小结">优化小结</h3><p>整体而言，IGListDiff 在 Paul Heckel差分算法的基础上扩展了差分类型，从原来的<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong> 3种类型扩展成<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong>、<strong>更新</strong>4 种类型。类型的扩展本质上是通过增加检测维度实现的，Paul Heckel差分算法只支持 <strong>位置</strong>、<strong>内容</strong> 2个维度进行检测，而 IGListDiff 则支持<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong> 3个维度进行检测。</p><p>此外，IGListDiff 实现了精准检测，而 Paul Heckel算法实现的是模糊处理，会存在移动类型误判为插入或删除等情况。这种精准检测的能力，适用于对差异敏感的系统，使得算法的应用场景进一步扩大。</p><h1 id="总结">总结</h1><p>本文首先介绍了原始的 Paul Heckel 差分算法的实现原理。原始的 PaulHeckel 差分算法基于位置、内容 2个维度进行差分检测，支持检测插入、删除、移动等 3种类型。但是，其实现的是一种模糊处理的差分检测，会存在将移动类型归为插入或删除的情况。</p><p>其次，我们介绍了 IGListKit 中的 IGListDiff 模块，其在 Paul Heckel差分算法的基础上进行了优化，基于标识、位置、内容 3个维度进行差分检测，支持检测插入、删除、移动、更新等 4种类型。IGListDiff 实现了一种精确分析的差分算法，这更符合我们在 UI框架中对于数据差异精准检测的需求。</p><p>通过上文的介绍，我们可以举一反三猜想地其他应用是如何实现数据差分检测的。对此，如果你感兴趣的话，可以研究一个其他的框架，来印证一下你的猜想，甚至可以考虑自己实现差分算法。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://dl.acm.org/doi/pdf/10.1145/359460.359467">ATechnique for Isolating Differences Between Files</a>. Paul Heckel.</li><li><a href="https://gist.github.com/ndarville/3166060">IsolatingDifferences Between Files</a></li><li><a href="https://github.com/Instagram/IGListKit">IGListKit</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;前一篇 &lt;a
href=&quot;http://chuquan.me/2023/09/13/myers-difference-algorithm/&quot;&gt;文章&lt;/a&gt;
我们介绍了 Myers
差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit
等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——Paul
Heckel 差分算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://chuquan.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="差分算法" scheme="http://chuquan.me/tags/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="Paul Heckel" scheme="http://chuquan.me/tags/Paul-Heckel/"/>
    
    <category term="IGListKit" scheme="http://chuquan.me/tags/IGListKit/"/>
    
    <category term="IGListDiff" scheme="http://chuquan.me/tags/IGListDiff/"/>
    
  </entry>
  
  <entry>
    <title>关于本次博客升级</title>
    <link href="http://chuquan.me/2023/09/16/about-blog-upgrade/"/>
    <id>http://chuquan.me/2023/09/16/about-blog-upgrade/</id>
    <published>2023-09-16T08:56:52.000Z</published>
    <updated>2024-01-19T00:50:26.829Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一篇文章 <ahref="http://chuquan.me/2023/09/13/myers-difference-algorithm/">《Myers差分算法》</a>，发布之后发现 NexT默认使用的公式渲染器的效果不太好，于是...搞了几晚，整体升级了 Hexo系统和 NexT 主题。</p><span id="more"></span><p>升级后的博客支持了以下这些特性：</p><ul><li>黑暗模式：自动识别系统当前的模式，自动切换，并提供按钮支持手动切换。</li><li>公式渲染：使用 pandoc 渲染公式，支持独立和内嵌两种渲染方式。</li><li>评论系统：摒弃了原先的 LiveRe评论系统（不稳定，经常加载不出来），使用了 Waline评论系统，支持评论通知。</li><li>独立留言区：<ahref="https://vercel.chuquan.me">vercel.chuquan.me</a></li></ul><p>在升级过程中，我在 LiveRe后台看到了博客里的很多评论，还是蛮开心的，承蒙大家的喜欢和支持[手动抱拳]。之前评论系统非常不稳定，导致我一直都不太关注评论，因为我也经常加载不出来（除非挂代理）[手动狗头]。而且我也没有看过评论后台，加上评论系统也不支持评论通知，所以很多留言和问题都没有及时回复，感到十分抱歉。</p><p>为了能有更好的交流体验，这次我换了个评论系统，并将历史评论导入了进来，可惜的是历史评论时间无法修改。同时，我也支持了评论通知功能。如果有评论，我会立即收到微信通知；如果我回复了，你也会收到邮件。所以留言时，请正确填写你的邮箱。</p><p>后续，我会持续关注博客中的留言，并及时予以回复（毕竟支持了评论通知能力）。Waline评论系统支持匿名评论和登录评论，如果后续会有回复，我强烈建议你点击登录按钮注册一个账号。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/comment-example.jpg?x-oss-process=image/resize,w_800" /></p><p>当然，除了在指定文章下面留言，这里还提供了一个独立的留言区 <ahref="https://vercel.chuquan.me/">vercel.chuquan.me</a>。如果你有一些与具体文章无关的想法，欢迎在这里留言，比如：关于文章主题的建议（因为有时候我也不知道要写什么主题的文章）、关于开源项目或自主创业的想法、关于人生的思考、关于职场的吐槽...</p><p>最后，再解答一个重复度比较高的问题：</p><p>Q：文章中的图是用什么画的？<br />A：绝大部分的彩色配图都是使用 Sketch 画的，少部分类图使用 draw.io画的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在写一篇文章 &lt;a
href=&quot;http://chuquan.me/2023/09/13/myers-difference-algorithm/&quot;&gt;《Myers
差分算法》&lt;/a&gt;，发布之后发现 NexT
默认使用的公式渲染器的效果不太好，于是...搞了几晚，整体升级了 Hexo
系统和 NexT 主题。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Waline" scheme="http://chuquan.me/tags/Waline/"/>
    
    <category term="Vercel" scheme="http://chuquan.me/tags/Vercel/"/>
    
  </entry>
  
  <entry>
    <title>Myers 差分算法</title>
    <link href="http://chuquan.me/2023/09/13/myers-difference-algorithm/"/>
    <id>http://chuquan.me/2023/09/13/myers-difference-algorithm/</id>
    <published>2023-09-13T05:24:31.000Z</published>
    <updated>2024-04-26T00:16:26.482Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-01.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>差分算法（DifferenceAlgorithm）是一种数值计算方法，其主要用于解决两个数据集之间的差异问题，通过计算两个数据集之间的差异，取代对整个数据集的处理。</p><p>差分算法的应用非常广泛，主要有以下这些应用领域：</p><ul><li><strong>数据压缩</strong>：差分算法可以用来检测和删除冗余数据，从而实现数据的压缩。比如，对于一段音频数据，如果相邻的数据点之间的值几乎没有变化，那么就可以用差分值来代替原始数据，从而大大减小数据的大小。</li><li><strong>版本控制</strong>：差分算法可以用来比较不同版本的源代码，以便开发者能够知道哪些部分被修改了。比如：git、svn等版本控制工具。</li><li><strong>UI框架</strong>：差分算法可以用来比较两个状态的界面树，并找到最少的更新操作，从而高性能刷新界面。比如：SwiftUI、IGList、React、Flutter等 UI 框架。</li></ul><p>本文，我们将深入探讨广泛应用在各种版本控制工具中的差分算法——Myers差分算法。</p><h1 id="最长公共子序列">最长公共子序列</h1><p>在介绍 Myers 算法之前，我们先来了解一下著名的<strong>最长公共子序列（Longest Common Subsequence，LCS）</strong>问题。我们引用一下 LeetCode 中的问题描述，如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 text1 和 text2，返回这两个字符串的最长「公共子序列」的长度。如果不存在「公共子序列」，则返回 0 。</span><br><span class="line"> </span><br><span class="line">一个字符串的「子序列」是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span><br><span class="line"></span><br><span class="line">例如，<span class="string">&quot;ace&quot;</span> 是 <span class="string">&quot;abcde&quot;</span> 的子序列，但 <span class="string">&quot;aec&quot;</span> 不是 <span class="string">&quot;abcde&quot;</span> 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">&gt; 输入：text1 = <span class="string">&quot;CBABAC&quot;</span>, text2 = <span class="string">&quot;ABCABBA&quot;</span> </span><br><span class="line">&gt; 输出：4  </span><br><span class="line">&gt; 解释：最长公共子序列是 <span class="string">&quot;BABA&quot;</span> 或 <span class="string">&quot;CABA&quot;</span> 或 <span class="string">&quot;CBBA&quot;</span> ，它的长度为 4 。</span><br></pre></td></tr></table></figure><p>对于 LCS 问题，经典思路是使用动态规划来解决。动态规划的核心思想是<strong>将一个大问题拆分成多个子问题，分别求解各个子问题，基于各个子问题的解推断出大问题的解</strong>。与分治、递归相比，动态规划会记录各个子问题的解，避免重复运算，以空间换时间，从而实现对时间复杂度的优化。下面，我们来介绍一下LCS 的动态规划解法。</p><p>假设字符串 <span class="math inline">\(text1\)</span> 和<code>text2</code> 的长度分别为 <code>m</code> 和<code>n</code>，对此创建一个 <code>m+1</code> 行 <code>n+1</code>列的二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示<code>text1[0:i]</code> 和 <code>text2[0:j]</code>的最长公共子序列的长度。</p><blockquote><p>上述表示中，<code>text1[0:i]</code> 表示 <code>text1</code> 的长度为<code>i</code> 的前缀，<code>text2[0:j]</code> 表示 <code>text2</code>的长度为 <code>j</code> 的前缀。</p></blockquote><p>考虑动态规划的边界情况：</p><ul><li>当 <code>i = 0</code> 时，<code>text1[0:i]</code>为空，空字符串和任何字符串的最长公共子序列的长度都是<code>0</code>，因此对任意 <code>0 ≤ j ≤ n</code>，有<code>dp[0][j] = 0</code>；</li><li>当 <code>j = 0</code> 时，<code>text2[0:j]</code>为空，同理可得，对任意 <code>0 ≤ i ≤ m</code>，有<code>dp[i][0] = 0</code>。</li></ul><p>因此动态规划的边界情况是：当 <code>i = 0</code> 或 <code>j = 0</code>时，<code>dp[i][j] = 0</code>。</p><p>当 <code>i &gt; 0</code> 且 <code>j &gt; 0</code> 时，考虑<code>dp[i][j]</code> 的计算：</p><ul><li>当 <code>text1[i-1] = text2[j-1]</code>时，将这两个相同的字符称为公共字符，考虑 <code>text1[0:i-1]</code> 和<code>text2[0:j-1]</code> 的最长公共子序列，再增加一个公共字符即可得到<code>text1[0:i]</code> 和 <code>text2[0:j]</code>的最长公共子序列，因此 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li><li>当 <code>text1[i-1] != text2[j-1]</code> 时，考虑一下两种情况：<ul><li>情况一：<code>text1[0:i-1]</code> 和 <code>text2[0:j]</code>的最长公共子序列</li><li>情况二：<code>text1[0:i]</code> 和 <code>text2[0:j-1]</code>的最长公共子序列</li><li>对此，计算 <code>text1[0:i]</code> 和 <code>text2[0:j]</code>的最长公共子序列，应取两项中长度较大的一项，因此<code>dp[i][j] = max(dp[i-1]][j], dp[i][j-1])</code>。</li></ul></li></ul><p>最终得到如下所示的状态转移方程：</p><p><span class="math display">\[dp[i][j] =\begin{cases}dp[i-1][j-1] + 1, &amp; \text{text1[i-1] = text2[j-1]}  \\max(dp[i-1][j], dp[i][j-1]), &amp; \text{text1[i-1]$\neq$text2[j-1]}\end{cases}\]</span></p><p>根据状态转移方程，我们可以得到如下代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示为二维数组 <code>dp[i][j]</code>的存储内容，大问题的解由子问题的解推导而出，数组整体从左到右，从上到下推导构建。我们在图中使用黄色标识了<code>text1[i-1] == text2[j-1]</code>的情况。此时将从左上角相邻的位置取值并加1；否则，取左边或上边的相邻值中的最大值。整个二维数组中保存的最大值就是LCS 问题的解。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-02.png?x-oss-process=image/resize,w_800" /></p><p>至此我们计算得到了最长公共子序列的长度，然而在实际情况中，我们倾向于得到最长公共子序列本身。此时，可以借助我们构建的二维数组进行回溯。</p><p>回溯的方法是：从二维数组的右下角向左上角遍历，当<code>i = m+1</code>，<code>j = n+1</code> 时可能会遇到三种情况：</p><ul><li>如果 <code>text1[i] = text2[j]</code>，那么向左上角遍历。</li><li>如果 <code>text1[i] != text2[j]</code>，判断 <code>dp[i][j]</code>和 <code>dp[i-1][j]</code> 的值。<ul><li>如果 <code>dp[i][j] = dp[i-1][j]</code>，则向上遍历；</li><li>否则，向左遍历。</li></ul></li></ul><p>由此，我们可以得到如下的遍历路径。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-03.png?x-oss-process=image/resize,w_800" /></p><p>在回溯得到遍历路径之后，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列<code>CABA</code>，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-05.png?x-oss-process=image/resize,w_800" /></p><p>当然，细心的同学可能会对上述的回溯方法产生疑问：为什么<code>dp[i][j] = dp[i-1][j]</code>时向上遍历，而非向左遍历？事实上，如果我们也可以修改回溯方法，得到如下的遍历路径。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-04.png?x-oss-process=image/resize,w_800" /></p><p>同样，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列<code>BABA</code>，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-06.png?x-oss-process=image/resize,w_800" /></p><h1 id="最小编辑距离">最小编辑距离</h1><p>事实上，在特定设定下，最长公共子序列问题可以等价为<strong>最小编辑距离（Minimum Edit Distance，也称 Levenshtein）</strong>问题。</p><p>具体设定为：在最小编辑距离问题中，如果编辑操作只有<strong>删除</strong> 和 <strong>插入</strong>，没有<strong>替换</strong> 操作，且每个操作的代价是 1，那么从字符串 A转换成字符串 B 的最小编辑距离就可以转换成如下公式。</p><p><span class="math display">\[med(A, B) = length(A) + length(B) - 2 * lcs(A, B)\]</span></p><p>以上述 <code>text1 = CBABAC</code>，<code>text2 = ABCABBA</code>为例，寻找最长公共子序列问题，我们可以视为将 <code>text2</code> 转换成<code>text1</code> 的最小编辑距离问题。</p><p>此时，我们可以将向左遍历的起始位置染成红色，将向上遍历的起始位置染成绿色，如下所示是分别对<code>CABA</code> 和 <code>BABA</code> 遍历路径的染色图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-07.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-08.png?x-oss-process=image/resize,w_800" /></p><p>这里，我们对已经染色的路径进行编辑规则的定义，如下：</p><ul><li>被染成红色的位置，表示在路径中删除原始字符串对应的字符</li><li>被染成绿色的位置，表示在路径中插入目标字符串对应的字符</li><li>被染成黄色的位置，表示不进行任何编辑编辑操作</li></ul><p>此时，我们就可以得到最小编辑距离的实际操作步骤，即<strong>最短编辑脚本（Shortest EditScript，SES）</strong>，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-09.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-10.png?x-oss-process=image/resize,w_800" /></p><p>上面两图的右半部分是两个符合预期的最短编辑脚本。然而，在实际过程中，对某一个原始文本进行编辑得到另一个目标文本，可能会存在非常多的最短编辑脚本。此时我们该如何选择？<strong>根据实际经验，我们认为先删除旧内容，后插入新内容，具有更直观的体验</strong>。比如：CodeReview的差异比较也都是按照先删除后插入的方式进行展示，如下所示。因此，上述第一种最短编辑脚本更加直观，符合预期。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-11.png?x-oss-process=image/resize,w_800" /></p><h1 id="myers-差分算法">Myers 差分算法</h1><p>1986 年 Eugene W.Myers 发表了一篇论文《An O(ND) Difference Algorithmand ItsVariations》，提出一种基于广度优先搜索和贪心策略的算法，优化了最短编辑路径问题。该算法在求解大规模字符串编辑距离问题时比传统的动态规划更加有效。</p><p>下面，我们以 <code>source = ABCABBA</code>为原始字符串，<code>target = CBAABAC</code> 为目标字符串，基于 Myers差分算法来查找最短编辑距离和最小编辑脚本。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-12.png?x-oss-process=image/resize,w_800" /></p><h2 id="基本定义">基本定义</h2><p>与上述算法类似，Myers差分算法的基本思想仍然是查找一条从左上角至右下角的路径。在路径遍历时，这里有几个基本定义：</p><ul><li><strong>遍历的方向</strong>：仅支持三个方向，分别是<strong>向右</strong>、<strong>向下</strong>、<strong>右下</strong>。</li><li><strong>遍历的步长</strong>：对于向右和向下，步长为1。一次只能移动一格；对于右下，一次可以移动任意长度，前提是移动过程中所有坐标的x、y值对应在原始字符串和目标字符串中的对应位置的字符必须相同。下图所示，黄色箭头表示可以允许移动的起始位置和终点位置。</li><li><strong>遍历的深度</strong>：对于向右和向下，每移动一步，深度加1；对于右下，无论移动步长为多少，深度始终加 0。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-13.png?x-oss-process=image/resize,w_800" /></p><h2 id="k-d-坐标系">K-D 坐标系</h2><p>除了对比原始字符串和目标字符串所建立的 X-Y 坐标系外，Myers还建立了一个 K-D 坐标系，如下图所示。</p><p>K 来源于 X 与 Y 的关系式 <code>y = x - k</code>，即偏移量。根据 X 和K 的值，我们可以计算得到 Y 的值。</p><p>D 表示遍历的深度。由于向右或向下移动一步，深度加1；右下移动一步，深度加 0。因此，D 轴并不是完全垂直于 K轴，而是类似于等高线，向多方向增长，相同 D值所连成的线可能是折线，而不一定是直线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-21.png?x-oss-process=image/resize,w_800" /></p><h2 id="最佳位置">最佳位置</h2><p>Myers 差分算法是基于贪心策略实现的，对此它定义了一个<strong>最佳位置</strong> 的概念，作为贪心的基准值。在 K-D坐标系中，同一条 K 线上，X 值越大的位置（根据 K 的值可以计算得到 Y值），则越靠近右下角的终点。</p><p>那么如何记录最佳位置？很显然，每一个 K值需要单独记录各自的最佳位置，因此，需要有一个 Map 来进行存储，其中 Key是 K 值，Value 则是 X 值。根据 K 和 X，我们可以计算出 Y 值。</p><h2 id="算法原理">算法原理</h2><p>在了解了算法的基本定义、K-D坐标系以及最佳位置等概念之后，我们来看一下算法具体原理。</p><p>算法整体包含两层循环：</p><ul><li>外层循环：迭代遍历的深度。在最坏的情况下（删除全部原始字符，掺入全部目标字符），遍历的深度为两个字符的长度之和，因此深度的范围为<code>[0, M+N)</code>。</li><li>内层循环：迭代必要的 K 值。对于每一条 K线，从其上的最佳位置出发，移动深度加 1 后的位置只能在其相邻的两条 K线上。因此，相同深度的最佳位置所在的 K 线，相邻之间的 K 值差为2。对应地，内层循环的步长也为 2，并且每一轮遍历，深度加 1，K的范围也会外扩 2。</li></ul><p>下面，我们来图解一下算法的运行过程，以下每张图表示一次完整的内层循环。</p><p>首先，为 <code>k(0)</code> 查找所有深度为 <code>d0</code>的最佳位置，很显然，只有起点符合，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-22.png?x-oss-process=image/resize,w_800" /></p><p>其次，为 <code>k(-1)</code> 和 <code>k(1)</code> 查找所有深度为<code>d1</code> 的最佳位置。由于 <code>d1</code> 是基于 <code>d0</code>宽度优先搜索查找的，而 <code>d0</code>只有一个，所以由此向两个方向搜索的 K 线只有 <code>k(-1)</code> 和<code>k(1)</code>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-23.png?x-oss-process=image/resize,w_800" /></p><p>然后，我们继续基于 <code>d1</code> 的各个最佳位置进行宽度优先搜索，为<code>(k-2)</code>、<code>k(0)</code>、<code>k(2)</code> 查找<code>d2</code> 的各个最佳位置。由于每一轮内层循环的 K 线数量都会外扩1，因此，首尾的两条 K 线，只能基于内侧 K线的上一轮循环最佳位置来查找本轮最佳位置；对于中间的 K 线，它两侧的 K线都有上一轮的最佳位置，它可以从中选择更优的最佳位置（即 X值更大的最佳位置）来查找本轮的最佳位置。如下图所示，<code>k(-2)</code>的最佳位置 <code>d2</code> 只能基于 <code>k(-1)</code> 的最佳位置<code>d1</code> 来查找得到；<code>k(2)</code> 的最佳位置 <code>d2</code>只能基于 <code>k(1)</code> 的最佳位置 <code>d1</code>来查找得到。对于中间的 K 线，这里只有<code>k(0)</code>，它会在左右两边的 K 线中选择一个最佳位置，显然<code>k(1)</code> 上的 <code>d1</code> 的 X值更大，因此选择它作为搜索的起点。</p><p>从图中，我们还可以看到，当到达深度加 1的位置后，算法还会进一步判断是否可以向右下移动，因为右下移动时，深度不会增加。此时，我们发现这几个位置都能沿着黄色的线移动，于是<code>d2</code> 就到达了图中所示的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-24.png?x-oss-process=image/resize,w_800" /></p><p>接着，为<code>k(-3)</code>、<code>k(-1)</code>、<code>k(1)</code>、<code>k(3)</code>查找 <code>d3</code> 的各个最佳位置。注意，这里我们看一下<code>k(-1)</code> 的处理，此时它两侧 <code>k(-2)</code> 和<code>k(0)</code> 的最佳位置的 X 值相同。此时，我们选择基于<code>k(-2)</code> 右移，很明显，这样必然会比基于 <code>k(0)</code>下移能找到 X 值更大的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-25.png?x-oss-process=image/resize,w_800" /></p><p>然后，为<code>k(-4)</code>、<code>k(-2)</code>、<code>k(0)</code>、<code>k(2)</code>、<code>k(4)</code>查找 <code>d4</code> 的各个最佳位置。注意，此时会存在部分 K线的最佳位置不包含 X-Y 坐标系中真实存在的位置，比如 <code>k(-4)</code>的最佳位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-26.png?x-oss-process=image/resize,w_800" /></p><p>最后，我们在为<code>k(-5)</code>、<code>k(-3)</code>、<code>k(-1)</code>、<code>k(1)</code>、<code>k(3)</code>、<code>k(5)</code>查找最佳位置时，发现其中一条 K线的最佳位置已经到达终点，那么此时我们已经找到了最短编辑距离，那么可以结束遍历。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-27.png?x-oss-process=image/resize,w_800" /></p><p>在上述过程中，Myers 算法使用一个 Map 记录每条 K 线的最佳位置，其中Key 为 K 值，Value 为最佳位置。当对同一条 K 线多次更新最佳位置时，Map只会记录最新的最佳位置。为了便于复现完整的编辑路径，Myers 算法还使用一个Map 用于记录每个深度的所有最佳位置，其中 Key 为深度值 D，Value 是一个子Map，记录了该深度时各个 K 线的最佳位置。通过回溯这个包含全部最佳位置的Map，我们可以重建遍历路径，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-28.png?x-oss-process=image/resize,w_800" /></p><h2 id="算法实现">算法实现</h2><p>下面，我们使用代码来实现一下 Myers 算法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ruby </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myers</span>(<span class="params">stra, strb</span>)</span><br><span class="line">  <span class="comment"># 字符串 a 和 b 的长度，分别为 n 和 m</span></span><br><span class="line">  m = stra.length</span><br><span class="line">  n = strb.length</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于存储每条 K 线上最佳位置的 Map</span></span><br><span class="line">  v = &#123; <span class="number">1</span> =&gt; <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment"># 用于存储所有深度的所有最佳位置的 Map，用于回溯编辑路径</span></span><br><span class="line">  vs = &#123; <span class="number">0</span> =&gt; &#123; <span class="number">1</span> =&gt; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">  loop <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 外层循环，遍历深度</span></span><br><span class="line">    (<span class="number">0</span>..m + n).each <span class="keyword">do</span> |<span class="params">d</span>|</span><br><span class="line">      tmp = &#123;&#125;</span><br><span class="line">      <span class="comment"># 内层循环，宽度优先搜索，遍历 K 线</span></span><br><span class="line">      (-d..d).step(<span class="number">2</span>) <span class="keyword">do</span> |<span class="params">k</span>|</span><br><span class="line">        down = ((k == -d) |<span class="params"></span>| ((k != d) &amp;&amp; v[k + <span class="number">1</span>] &gt; v[k - <span class="number">1</span>]))</span><br><span class="line">        kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 获取移动的起点位置</span></span><br><span class="line">        xStart = v[kPrev]</span><br><span class="line">        yStart = xStart - kPrev</span><br><span class="line">        <span class="comment"># 获取移动一步的中间位置，向右或向下</span></span><br><span class="line">        xMid = down ? xStart : xStart + <span class="number">1</span></span><br><span class="line">        yMid = xMid - k</span><br><span class="line">        <span class="comment"># 获取移动的终点位置，后续可能会向右下移动。</span></span><br><span class="line">        xEnd = xMid</span><br><span class="line">        yEnd = yMid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向右下移动，深度始终不变</span></span><br><span class="line">        <span class="keyword">while</span>(xEnd &lt; m &amp;&amp; yEnd &lt; n &amp;&amp; stra[xEnd] == strb[yEnd]) <span class="keyword">do</span></span><br><span class="line">          xEnd += <span class="number">1</span></span><br><span class="line">          yEnd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录对应 K 线所能达到的最佳位置</span></span><br><span class="line">        v[k] = xEnd</span><br><span class="line"></span><br><span class="line">        tmp[k] = xEnd</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果两个字符串均到达末端，表示找到了终点，可以结束查找</span></span><br><span class="line">        <span class="keyword">if</span> xEnd == m &amp;&amp; yEnd == n</span><br><span class="line">          vs[d] = tmp</span><br><span class="line">          <span class="comment"># 生成最短编辑路径</span></span><br><span class="line">          snakes = solution(vs, m, n, d)</span><br><span class="line">          <span class="comment"># 打印最短编辑路径</span></span><br><span class="line">          printDiff(snakes, stra, strb)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 记录深度为 D 的所有 K 线的最佳位置</span></span><br><span class="line">      vs[d] = tmp</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">vs, m, n, d</span>)</span><br><span class="line">  snakes = []</span><br><span class="line">  <span class="comment"># 定义位置结构</span></span><br><span class="line">  p = &#123; <span class="symbol">x:</span> m, <span class="symbol">y:</span> n &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 回溯最短编辑路径</span></span><br><span class="line">  <span class="keyword">while</span> d &gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">    v = vs[d]</span><br><span class="line">    vPrev = vs[d-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    k = p[<span class="symbol">:x</span>] - p[<span class="symbol">:y</span>]</span><br><span class="line">    <span class="comment"># 判断之前位置到当前位置最开始移动的方式，向下或向右</span></span><br><span class="line">    down = ((k == -d) |<span class="params"></span>| ((k != d) &amp;&amp; (vPrev[k + <span class="number">1</span>] &gt; vPrev[k - <span class="number">1</span>])))</span><br><span class="line">    kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前位置</span></span><br><span class="line">    xEnd = v[k]</span><br><span class="line">    yEnd = xEnd - k</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 之前位置</span></span><br><span class="line">    xStart = vPrev[kPrev]</span><br><span class="line">    yStart = xStart - kPrev</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中间走斜线时的起始位置</span></span><br><span class="line">    xMid = down ? xStart : xStart + <span class="number">1</span></span><br><span class="line">    yMid = xMid - k</span><br><span class="line"></span><br><span class="line">    snakes.unshift([xStart, xMid, xEnd])</span><br><span class="line"></span><br><span class="line">    p[<span class="symbol">:x</span>] = xStart</span><br><span class="line">    p[<span class="symbol">:y</span>] = yStart</span><br><span class="line"></span><br><span class="line">    d -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> snakes</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printDiff</span>(<span class="params">snakes, stra, strb</span>)</span><br><span class="line">  diffresult = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  yOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  snakes.each_with_index <span class="keyword">do</span> |<span class="params">snake, index</span>|</span><br><span class="line">    s = snake[<span class="number">0</span>]</span><br><span class="line">    m = snake[<span class="number">1</span>]</span><br><span class="line">    e = snake[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是第一个差异，并且差异的开始点不是字符串头（即两字符串在开始部分有相同子字符串）</span></span><br><span class="line">    <span class="keyword">if</span> index === <span class="number">0</span> &amp;&amp; s != <span class="number">0</span></span><br><span class="line">      <span class="comment"># 打印所有相同字符，直到s</span></span><br><span class="line">      (<span class="number">0</span>..s-<span class="number">1</span>).each <span class="keyword">do</span> |<span class="params">j</span>|</span><br><span class="line">        diffresult += <span class="string">&quot;  <span class="subst">#&#123;stra[j]&#125;</span>\n&quot;</span></span><br><span class="line">        yOffset += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> m - s == <span class="number">1</span></span><br><span class="line">      <span class="comment"># 用红色打印删除的字符</span></span><br><span class="line">      diffresult += <span class="string">&quot;\033[0;31m- <span class="subst">#&#123;stra[s]&#125;</span>\033[0m\n&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 用绿色打印插入的字符</span></span><br><span class="line">      diffresult += <span class="string">&quot;\033[0;32m+ <span class="subst">#&#123;strb[yOffset]&#125;</span>\033[0m\n&quot;</span></span><br><span class="line">      yOffset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 打印相同的字符</span></span><br><span class="line">    (<span class="number">0</span>..e-m-<span class="number">1</span>).each <span class="keyword">do</span> |<span class="params">i</span>|</span><br><span class="line">      diffresult += <span class="string">&quot;  <span class="subst">#&#123;stra[m+i]&#125;</span>\n&quot;</span></span><br><span class="line">      yOffset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  puts diffresult</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;ABCABBA&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;CBABAC&#x27;</span></span><br><span class="line">myers(s1, s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>传统动态规划的时间复杂度为 <code>O(mn)</code>，空间复杂度为<code>O(mn)</code>，其中 <code>m</code> 和 <code>n</code>分别是两个字符串的长度；Myers 算法的时间复杂度为<code>O((m+n)D)</code>，<code>D</code>是最小编辑距离，当最短编辑距离相对较小时，Myers算法的时间效率是优于传统动态规划的，Myers 算法的空间复杂度为<code>O(m+n)</code>。因此，当面对大规模且较为相似的字符串比较任务时，Myers算法相比动态规划更具优势。</p><p>后续，我们将阅读一些开源软件或框架，来学习一下 Myers差分算法在其中的应用。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://www.nathaniel.ai/myers-diff/">VisualizingDiffs</a></li><li><ahref="https://chenshinan.github.io/2019/05/02/git%E7%94%9F%E6%88%90diff%E5%8E%9F%E7%90%86%EF%BC%9AMyers%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/">git生成diff原理：Myers差分算法</a></li><li><ahref="https://mcll.top/2019/05/23/diff%E7%AE%97%E6%B3%95/">一种diff算法：Myers</a></li><li><ahref="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">TheMyers diff algorithm: part 1</a></li><li><ahref="https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/">TheMyers diff algorithm: part 2</a></li><li><ahref="https://blog.jcoglan.com/2017/02/17/the-myers-diff-algorithm-part-3/">TheMyers diff algorithm: part 3</a></li><li><ahref="https://blog.jcoglan.com/2017/03/22/myers-diff-in-linear-space-theory/">Myersdiff in linear space: theory</a></li><li><ahref="https://blog.jcoglan.com/2017/04/25/myers-diff-in-linear-space-implementation/">Myersdiff in linear space: implementation</a></li><li>An O(ND) Difference Algorithm and Its Variations. EugeneW.Myers.</li><li><a href="https://zhuanlan.zhihu.com/p/35256233">Diff应用：从LCS到UICollectionView</a></li><li><ahref="https://www.cnblogs.com/oto-G/p/16357245.html">Myers差分算法的理解、实现、可视化</a></li><li><ahref="https://juejin.cn/post/6887367495021330445#heading-8">Myers‘Diff之贪婪算法</a></li><li><a href="https://github.com/pkg/diff">pkg diff</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-01.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://chuquan.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Myers" scheme="http://chuquan.me/tags/Myers/"/>
    
    <category term="最长公共子序列" scheme="http://chuquan.me/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
    <category term="最短编辑距离" scheme="http://chuquan.me/tags/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
    <category term="最短编辑脚本" scheme="http://chuquan.me/tags/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew 的设计哲学</title>
    <link href="http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/"/>
    <id>http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/</id>
    <published>2023-08-27T02:30:08.000Z</published>
    <updated>2023-09-16T09:08:13.053Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-00.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>如果你是一位 MacOS 用户，那么你一定知道 Homebrew。Homebrew 是 MacOS下的包管理工具，类似 apt-get/apt 之于 Linux，yum 之于CentOS。如果一款软件发布时支持了 homebrew 安装渠道，那么我们就可以通过homebrew 一键安装，省时省力省心。</p><p>本文，我们将来探索一下 homebrew 的底层工作原理。</p><p>通过学习其工作原理，我们可以举一反三，推测并理解其他平台的包管理工具的设计思想。此外，我们还能借此理解开源软件的设计范式，从而为软件设计提供思路和指导。当然，最直接的收益则是加深对于homebrew 的理解，可以基于其原理来解决日常工作中的相关问题。</p><h1 id="酿酒术语">酿酒术语</h1><p>Homebrew 的作者 Max Howell借用了西方的酿酒文化，为软件定义了一系列的术语。因此，想要捋清楚各个术语及其之间的关系，我们有必要先简单了解一下酿酒文化中的相关术语。</p><p>对于工厂而言，酒一般会以 <strong>木桶（Cask）</strong>的形式存放在规模较大的厂房中，即<strong>酒桶房（Caskroom）</strong>。通常，木桶可以直接安装<strong>酒龙头（Tap）</strong> 来打酒或装罐。具体如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-01.png?x-oss-process=image/resize,w_800" /></p><p>对于家庭而言，酒一般会以 <strong>瓶装酒（Bottle）</strong> 或<strong>罐装酒（Keg）</strong> 的形式存放在规模较小的屋子里，即<strong>酒窖（Cellar）</strong>。由于瓶装酒和罐装酒体积较小，同时为了便于分类和存取，一般会摆放在<strong>酒架（Rack）</strong> 上。具体如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-02.png?x-oss-process=image/resize,w_800" /></p><h1 id="软件术语">软件术语</h1><p>Homebrew将软件比喻成酒，对于不同类型的软件，其管理（保存）方式有所不同：</p><ul><li><strong>对于原生应用，将其比作桶装酒，以 Cask 作为容器，保存在Caskroom 中。</strong></li><li><strong>对于非原生应用，将其比作瓶装酒或罐装酒，以 Bottle 或 Keg作为容器，保存在 Cellar 的 Rack 中。</strong></li></ul><blockquote><p>什么是 MacOS 原生应用？ MacOS 原生应用是指为 MacOS操作系统专门设计和开发的应用程序。通常使用 Apple 提供的软件开发工具（如Xcode）和编程语言（Swift 或Objective-C）进行开发，直接调用操作系统提供的 API 进行各种操作。 每个MacOS 原生应用都会有一个唯一的BundleIdentifier，系统以此标识符来管理和区分不同应用。</p></blockquote><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-04.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为 MacOS 系统中 homebrew对于软件管理的层级结构。这里有一个细节，我们发现 Caskroom 和 Casks构建了一个两层关系，而 Cellar、Racks、Kegs/Bottles则构建了一个三层关系。对此，我的理解是：</p><ul><li><strong>对于非原生应用，其索引方式是通过软链接实现的，因此同一台机器中可以存储同一应用的不同版本，通过修改软链接的指向来使用不同的版本。</strong></li><li><strong>对于原生应用，系统以应用的 Bundle Identifier作为唯一标识，同一应用的不同版本的 Bundle Identifier是相同的，因此同一台机器中只能覆盖安装，不同版本无法共存。</strong></li></ul><p>综合上述原因，非原生应用需要三层结构进行管理，而原生应用只需两层结构进行管理。从这个角度来看，正好与Cellar 和 Caskroom 的层级结构相匹配。</p><p>从图中，我们还可以看到 Cellar 的管理下包含了两种类型的软件，分别使用<strong>罐装酒（Keg）</strong> 和 <strong>瓶装酒（Bottle）</strong>来描述，它们是存在一些细微的区别的：</p><ul><li><strong>对于 Keg，表示的是 homebrew通过使用源码进行编译构建的软件。</strong></li><li><strong>对于 Bottle，表示的是 homebrew直接下载预编译的二进制的软件。</strong></li></ul><p>既然 homebrew将软件比喻成酒，那么很显然，软件的安装过程则对等比喻成酿酒。对此，homebrew使用 <strong>木桶（Cask）</strong> 和 <strong>配方（Formula）</strong>作为软件安装的两个基本元素，它们分别作为原生应用的包定义和非原生应用的包定义。为了便于管理，homebrew统一将它们放在 <strong>酒龙头（Tap）</strong> 下进行管理，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-05.png?x-oss-process=image/resize,w_800" /></p><p>对于 homebrew 这样设计 Tap 和 Formula、Cask之间的关系，我个人认为，从语义上来说属实有点牵强，因为它们在任何维度上都不是包含关系。这里，我们只要知道它们之间存在着包含关系即可，无需深究。</p><h1 id="存储结构">存储结构</h1><p>通过上文，我们大致了解了 homebrew中术语的含义与关系。下面，我们来看一下它们具体在文件系统中的存储结构。</p><p>对于 MacOS 系统，homebrew 在 ARM 架构（Apple Silicon）和 X86架构（Intel）中的存储位置所有不同，但是术语之间相对关系是一致的。作出这种区分的主要原因是，当从X86 架构迁移至 ARM 架构时，支持在 Rosetta 模式下继续运行在 X86架构下安装的软件应用。</p><p>对于 X86 架构，Caskroom 的路径是<code>/usr/local/Caskroom</code>，Cellar 的路径是<code>/usr/local/Cellar</code>，Taps 的路径是<code>/usr/local/Homebrew/Library/Taps</code>。</p><p>对于 ARM 架构，Caskroom 的路径是<code>/opt/homebrew/Caskroom</code>，Cellar 的路径是<code>/opt/homebrew/Cellar</code>，Taps 的路径是<code>/opt/homebrew/Library/Taps</code>。</p><h2 id="caskroom">Caskroom</h2><p>Caskroom主要负责管理原生应用，由于原生应用无法同时维护多个版本，所以在 Caskroom下对应只会存在一个版本目录。如下所示，以 <code>aerial</code>为例，在两次安装时，后一次会覆盖前一次的版本数据。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-03.jpg?x-oss-process=image/resize,w_800" /></p><h2 id="cellar">Cellar</h2><p>Cellar 主要负责管理非原生应用，由于是通过软链接进行版本管理，所以在Cellar 下对应会存在多个版本目录。如下所示，以 <code>git</code>为例，它会保存多个版本的数据。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-06.jpg?x-oss-process=image/resize,w_800" /></p><p>对于非原生应用，我们还可以在<code>/usr/local/bin</code>（Intel）目录下看到 homebrew为命令行应用创建的所有软链接，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-07.jpg?x-oss-process=image/resize,w_800" /></p><p>由于 <code>PATH</code> 环境变量包含了<code>/usr/local/bin</code>，所以系统能查找 homebrew所安装的软件的软链接，进而找到真正的可执行文件。不过在某些情况下，我们可能需要让homebrew安装的软件对于用户不可见，比如：避免版本冲突、仅用于依赖构建等。这时候，homebrew不会为这些软件创建软链接，对于这种类型的软件，homebrew 称之为<strong>keg-only</strong>，比如：<code>openjdk</code>。</p><h2 id="taps">Taps</h2><p>Taps 主要负责管理 <strong>包定义</strong> 和<strong>外部命令</strong>。</p><ul><li>包定义：一个包定义对应一款软件，主要用于指导对应软件的安装。</li><li>外部命令：支持用户对 homebrew 进行扩展，提供更多的命令和功能。</li></ul><p>Taps 目录维护了多个 Git 仓库（Tap仓库å），包括开发者自建的仓库，以及官方维护的仓库，比如：<code>homebrew/homebrew-core</code>和 <code>homebrew/homebrew-cask</code> 等。</p><p>如下所示，这些仓库大多数都维护了一个 <code>Formula</code> 或<code>Casks</code> 目录，其中存放了软件的包定义。这些包定义本质上是一个Ruby 类定义，图中的 <code>muesli/homebrew-tap</code> 中虽然没有定义<code>Formula</code> 或 <code>Casks</code> 目录，但其保存的 Ruby文件都是包定义。</p><p>除此之外，部分仓库维护了一个 <code>cmd</code>目录，其中存放了一些外部命令的定义，我们可以以文件名作为子命令进行调用，比如：<code>cmd</code>目录中有一个 <code>check-ci-status.rb</code> 文件，我们可以通过<code>brew check-ci-status</code>命令来调用执行。通过这种方式，我们可以对 homebrew 的命令进行扩展。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-08.jpg?x-oss-process=image/resize,w_800" /></p><h1 id="包定义">包定义</h1><p>作为一个软件包管理工具，homebrew 中最核心的设计便是包定义（PackageDefinition）。通过包定义，homebrew 才能够正确地安装对应的软件。</p><p>在上文 Taps 一节中，我们知道 homebrew支持两种管理方式，具体而言分别是：</p><ul><li><strong>官方仓库管理</strong>，我们可以实现自己的包定义，并向<code>homebrew/homebrew-core</code>（用于 Formula）或<code>homebrew/homebrew-cask</code>（用于 Cask）提交 PullRequest。这种方式会对包定义有着严格的规范和约束。</li><li><strong>自建仓库管理</strong>，我们在自定义的仓库中实现包定义，并自行维护。在安装软件时，我们将该仓库加入至Taps 目录进行管理。</li></ul><p>对于自建仓库，我们可以使用<code>brew tap-new &lt;user&gt;/&lt;repo&gt;</code>命令来创建一个模板仓库。如下所示，我们使用<code>brew tap-new baochuquan/homebrew-nox</code> 创建了一个 Tap仓库。命令会在 Taps 目录下创建一个仓库，并默认创建一个 Formula目录用于存放 Formula 包定义。如果希望存放 Cask包定义，我们可以再手动创建一个 Casks 目录。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-10.jpg?x-oss-process=image/resize,w_800" /></p><p>Homebrew 中的包定义有两种：Formula 和 Cask。</p><h2 id="formula">Formula</h2><p>Formula 是非原生应用的包定义，如下所示是 CocoaPods 的 Formula包定义。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cocoapods</span> &lt; <span class="title class_ inherited__">Formula</span></span><br><span class="line">  desc <span class="string">&quot;Dependency manager for Cocoa projects&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://cocoapods.org/&quot;</span></span><br><span class="line">  url <span class="string">&quot;https://github.com/CocoaPods/CocoaPods/archive/1.12.1.tar.gz&quot;</span></span><br><span class="line">  sha256 <span class="string">&quot;da018fc61694753ecb7ac33b21215fd6fb2ba660bd7d6c56245891de1a5f061c&quot;</span></span><br><span class="line">  license <span class="string">&quot;MIT&quot;</span></span><br><span class="line"></span><br><span class="line">  bottle <span class="keyword">do</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_ventura:</span>  <span class="string">&quot;6f1fca1cb0df79912e10743a80522e666fe605a1eaa2aac1094c501608fb7ee4&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_monterey:</span> <span class="string">&quot;8f7eff899cc1807286374e29e634c1008e286c3360df6cbcb90e27b0fe5567a9&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_big_sur:</span>  <span class="string">&quot;346833fef239df933ddb67341c55c9c4a7e547fc03afdc332861ac2ae8ba3372&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">ventura:</span>        <span class="string">&quot;b114ec0a11a2e472026f0f7337d17558bead2ac1122d9c2bb9278fc6b31fd744&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">monterey:</span>       <span class="string">&quot;946f0282afe0000ba9e23f30ce2175bc4b1f0c6d7e27145f01be4665b9786f8a&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">big_sur:</span>        <span class="string">&quot;1fe6f0c45e0c13e122aa1d8bf1f9bd9496fa3bb00fe7bc19286425e029e5c278&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any_skip_relocation</span>, <span class="symbol">x86_64_linux:</span>   <span class="string">&quot;e297731632b715118c13688acff976ce56c49df705ba2ae616445fb68cb49152&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  depends_on <span class="string">&quot;pkg-config&quot;</span> =&gt; <span class="symbol">:build</span></span><br><span class="line">  depends_on <span class="string">&quot;ruby&quot;</span></span><br><span class="line">  uses_from_macos <span class="string">&quot;libffi&quot;</span>, <span class="symbol">since:</span> <span class="symbol">:catalina</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">install</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Mac</span>OS.version &gt;= <span class="symbol">:mojave</span> &amp;&amp; <span class="title class_">Mac</span>OS::<span class="variable constant_">CLT</span>.installed?</span><br><span class="line">      <span class="variable constant_">ENV</span>[<span class="string">&quot;SDKROOT&quot;</span>] = <span class="variable constant_">ENV</span>[<span class="string">&quot;HOMEBREW_SDKROOT&quot;</span>] = <span class="title class_">Mac</span>OS::<span class="variable constant_">CLT</span>.sdk_path(<span class="title class_">Mac</span>OS.version)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="variable constant_">ENV</span>[<span class="string">&quot;GEM_HOME&quot;</span>] = libexec</span><br><span class="line">    system <span class="string">&quot;gem&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;cocoapods.gemspec&quot;</span></span><br><span class="line">    system <span class="string">&quot;gem&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;cocoapods-<span class="subst">#&#123;version&#125;</span>.gem&quot;</span></span><br><span class="line">    <span class="comment"># Other executables don&#x27;t work currently.</span></span><br><span class="line">    bin.install libexec/<span class="string">&quot;bin/pod&quot;</span>, libexec/<span class="string">&quot;bin/xcodeproj&quot;</span></span><br><span class="line">    bin.env_script_all_files(libexec/<span class="string">&quot;bin&quot;</span>, <span class="variable constant_">GEM_HOME</span>: <span class="variable constant_">ENV</span>[<span class="string">&quot;GEM_HOME&quot;</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  test <span class="keyword">do</span></span><br><span class="line">    system <span class="string">&quot;<span class="subst">#&#123;bin&#125;</span>/pod&quot;</span>, <span class="string">&quot;list&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Formula 包定义本质上是定义一个 <code>Formula</code>的子类，将子类的名称转换成小写，以 <code>-</code> 代替驼峰命名，即可得到homebrew 对应的应用名称，比如：<code>brew install cocoapods</code>。</p><p>Formula包含一些必须的属性设置，比如：<code>desc</code>、<code>homepage</code>、<code>url</code>、<code>sha256</code>、<code>license</code>等，用于描述应用的基本信息，源码下载地址，完整性校验值等。</p><p>此外，它支持了非常多的属性和方法，通过配置这些属性和方法，我们可以自定义应用的安装方式。比如：<code>bottle</code>可以指定预编译二进制（针对不同系统）的相关配置；<code>depends_on</code>可以指定应用安装所需的依赖；<code>install</code>方法可以指定安装的具体操作，等等。关于 Formula定义的更多细节，我们可以参考 <code>homebrew/homebrew-core</code>中的其他示例，或者参考官方文档 <ahref="https://docs.brew.sh/Formula-Cookbook">Formula Cookbook</a>。</p><p>总而言之，对于非原生应用，homebrew 会根据对应的 Formula包定义，去下载对应的二进制或源码，然后在本地进行构建、安装。</p><h2 id="cask">Cask</h2><p>Cask 是原生应用的包定义，如下所示是 SourceTree 的 Cask 定义。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">cask <span class="string">&quot;sourcetree&quot;</span> <span class="keyword">do</span></span><br><span class="line">  on_sierra <span class="symbol">:or_older</span> <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;2.7.6a&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;d60614e9ab603e0ed158b6473c36e7944b2908d9943e332c505eba03dc1d829e&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://downloads.atlassian.com/software/sourcetree/Sourcetree_<span class="subst">#&#123;version&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;downloads.atlassian.com/software/sourcetree/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_high_sierra <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;3.2.1,225&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;4bd82affa3402814c3d07ff613fbc8f45da8b0cda294d498ffbb0667bf729c9f&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_mojave <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;4.2.1,248&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;3dac6ab514c7debe960339e2aee99f018342a41baf743dbb59524728b373561f&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_catalina <span class="symbol">:or_newer</span> <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;4.2.4,254&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;62dfaeedd63ac491ba3e49a5129d338c60886cb935e3654622147369023daf77&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/Appcast/SparkleAppcast.xml&quot;</span></span><br><span class="line">      strategy <span class="symbol">:sparkle</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  name <span class="string">&quot;Atlassian SourceTree&quot;</span></span><br><span class="line">  desc <span class="string">&quot;Graphical client for Git version control&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://www.sourcetreeapp.com/&quot;</span></span><br><span class="line"></span><br><span class="line">  auto_updates <span class="literal">true</span></span><br><span class="line">  depends_on <span class="symbol">macos:</span> <span class="string">&quot;&gt;= :el_capitan&quot;</span></span><br><span class="line"></span><br><span class="line">  app <span class="string">&quot;Sourcetree.app&quot;</span></span><br><span class="line">  binary <span class="string">&quot;<span class="subst">#&#123;appdir&#125;</span>/Sourcetree.app/Contents/Resources/stree&quot;</span></span><br><span class="line"></span><br><span class="line">  uninstall <span class="symbol">launchctl:</span> <span class="string">&quot;com.atlassian.SourceTreePrivilegedHelper2&quot;</span>,</span><br><span class="line">            <span class="symbol">quit:</span>      <span class="string">&quot;com.torusknot.SourceTreeNotMAS&quot;</span></span><br><span class="line"></span><br><span class="line">  zap <span class="symbol">trash:</span> [</span><br><span class="line">    <span class="string">&quot;~/Library/Application Support/com.apple.sharedfilelist/com.apple.LSSharedFileList.ApplicationRecentDocuments/com.torusknot.sourcetreenotmas.sfl2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Application Support/SourceTree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Caches/com.torusknot.SourceTreeNotMAS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Logs/Sourcetree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Preferences/com.torusknot.SourceTreeNotMAS.LSSharedFileList.plist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Preferences/com.torusknot.SourceTreeNotMAS.plist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Saved Application State/com.torusknot.SourceTreeNotMAS.savedState&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Cask 包定义本质上是初始化一个 cask实例。它同样包含了一系列基本属性，如：<code>token</code>、<code>name</code>、<code>desc</code>、<code>homepage</code>、<code>app</code>、<code>url</code>、<code>sha256</code>等。</p><p>Cask 的安装逻辑基上和 Formula 是类似的。示例中，SourceTree针对不同平台提供了不同的下载地址和 sha256 校验值，如：sierra、highsierra、mojave、catalina 等。</p><p>除此之外，Cask 也包含了大量的属性和方法，关于 Cask的更多细节，我们可以参考 <code>homebrew/homebrew-cask</code>中的其它示例，或者参考官方文档 <ahref="https://docs.brew.sh/Cask-Cookbook">Cask Cookbook</a>。</p><h1 id="外部命令">外部命令</h1><p>类似于 git，homebrew 也支持外部命令，通过这种方式可以允许用户对 brew进行定制和扩展，其运行方式如下所示，<code>extcmd</code>可以替换成任意自定义的子命令。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew extcmd --option1 --option2 &lt;formula&gt;</span><br></pre></td></tr></table></figure></p><p>Homebrew支持外部命令，从编程语言实现角度而言，可以分两种，分别是：Ruby和其他语言。从本质上而言，它们都是可执行的（chmod+ x）脚本，存放在<code>PAHT</code> 环境变量的路径中，支持系统索引。</p><p>由于 homebrew 是使用 Ruby 实现的，因此基于 Ruby的外部命令会比较特殊。只要我们将脚本命名为<code>brew-extcmd.rb</code>（<code>extcmd</code>可替换成任意自定义的子命令），homebrew 通过 <code>require</code>加载后，<code>brew-extcmd.rb</code> 会进入 homebrew的执行环境，因此可以访问 homebrew定义的所有环境变量和功能模块，开发者可使用的工具和模块会非常多。</p><p>对于其他语言实现的脚本，脚本实现中必须使用 <code>#!</code>来指定脚本的解释器，因此可支持 Python、Bash、Perl 等各种脚本语言。不同于Ruby 脚本，对于其他语言的脚本，homebrew要求脚本的名称不能有后缀，比如：<code>brew-extcmd.sh</code>脚本必须命名为 <code>brew-extcmd</code>。在运行时，homebrew会导入脚本参数和一部分环境变量。相比 Ruby 脚本而言，homebrew对于其他语言的脚本，在功能上支持会相对弱一些。</p><p>上述两种方式都是在本地扩展外部命令，如果我们希望外部命令能给其他用户使用，那应该怎么办？对此，我们仍然可以通过Taps 来实现。 类似于 Formula 使用 <code>Formula</code> 目录管理，Cask使用 <code>Casks</code> 目录管理，对于外部命令，我们使用<code>cmd</code>管理外部命令的实现脚本。当然，外部命令的维护也分为官方仓库和自建仓库，只是官方仓库的要求和规范会更加严格。</p><p>关于外部命令的具体细节，我们可以参考<code>homebrew/homebrew-core/cmd</code> 中的例子，也可以参考官方文档 <ahref="https://docs.brew.sh/External-Commands">ExternalCommands</a>。</p><h1 id="工作原理">工作原理</h1><p>整体而言，homebrew 的设计架构是比较清晰的。下面，我们来介绍 homebrew中的一些重要设计的工作原理，主要包括：</p><ul><li>命令分发</li><li>软件搜索</li><li>软件安装</li></ul><h2 id="命令分发">命令分发</h2><p>命令分发是所有命令行工具的核心功能之一，绝大部分的设计思路是：<strong>通过入口脚本对命令进行解析，一个子命令匹配一个脚本，最终由对应的脚本来解析参数、选项，并执行</strong>。</p><p>Homebrew 也不例外，我们执行的 <code>brew</code> 命令本质上是一个指向<code>Homebrew/bin/brew</code>脚本的软链接，子命令、参数、选项都会作为脚本的输入进行解析。</p><p><code>Homebrew/bin/brew</code> 脚本的核心作用是<strong>初始化一系列环境变量，并将导入 homebrew的执行环境</strong>。它并没有对命令的参数和选项进行解析，而是直接转发给了<code>Homebrew/brew.sh</code> 脚本。</p><p><code>Homebrew/brew.sh</code>脚本的职责相对而言更多，主要包括以下几分部：</p><ul><li>初始化并导入一系列环境变量。</li><li>定义了一部分工具方法，主要包括：不同等级的打印方法、自动更新方法等。</li><li>处理根命令选项和特定子命令，直接派发至 <code>Homebrew/cmd/</code>目录下对应的 Shell脚本，比如：<code>shellenv.sh</code>、<code>--cellar.sh</code> 等。</li><li>设置执行环境，包括 CA 证书、语言设置、常用工具（git、curl）等。</li><li>处理命令缩写，比如：<code>brew ls</code> 识别为<code>brew list</code>。</li><li>根据子命令加载 <code>Homebrew/cmd/</code> 目录下对应的 Shell脚本，如果加载成功，则执行匹配的方法；否则将转发至<code>Homebrew/brew.rb</code> 脚本继续解析。</li></ul><p><code>Homebrew/brew.rb</code> 脚本的职责相对简单，主要是负责处理<code>Homebrew/brew.sh</code> 未识别的命令、选项、参数。上文，我们提到brew 支持外部命令。因此，这里 <code>Homebrew/brew.rb</code>处理了一部分的逻辑：</p><ul><li>查找内部的 <code>cmd</code> 和 <code>dev-cmd</code>目录下对应的脚本，如果有则执行，否则进入下一步。</li><li>查找 <code>PATH</code> 路径和 Taps 路径下查找的符合<code>brew-&lt;cmd&gt;.rb</code> 或 <code>brew-&lt;cmd&gt;</code>模式的脚本，如果有则执行，否则报错。</li></ul><p>命令分发的整体流程如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="软件搜索">软件搜索</h2><p>当我们希望安装某个应用时，我们会使用<code>brew search &lt;formula&gt;</code> 或<code>brew search &lt;cask&gt; --cask</code> 来搜索一下 homebrew是否支持安装该应用。</p><p>通过上述的介绍，我们很容易猜到软件搜索的逻辑，其核心原理就是借助 Taps进行搜索和查找，包括官方的 <code>homebrew/homebrew-core</code> 和<code>homebrew/homebrew-cask</code>，以及其他自定义的 Tap仓库，从中查找各种 Formula 和 Cask的定义，从而显示精确匹配或模糊匹配的应用。</p><h2 id="软件安装">软件安装</h2><p>上文提到包定义是用于辅助完成软件安装，在安装过程中，homebrew会使用包定义中指定的 url 下载对应的源码或预编译二进制，并根据对应的<code>sha256</code> 值校验其完整性，防止被替换或篡改。</p><p>如果包定义中指定了安装过程所需要的依赖，那么 homebrew会先下载并安装对应的依赖。</p><p>然后，执行 <code>install</code>方法进行安装，对于源码则需要编译、构建，对于预编译二进制则可以执行安装。</p><p>最后，为应用创建软链接，软链接的存储路径加入了 <code>PATH</code>环境变量，因此可以被系统索引。</p><h1 id="总结">总结</h1><p>本文，我们首先介绍了 homebrew中酿酒术语与软件术语的对应关系，从而理清了术语之间的关系，建立对homebrew 的基本认知。然后介绍了 homebrew安装的软件在文件系统中的存储结构、两种包定义的基本概念，以及外部命令的实现方式。最后介绍了homebrew中几个关键设计的工作原理，包括：命令分发、软件搜索、软件安装等。</p><p>这里我们没有深入探讨 homebrew中的各种实现细节，而是着重介绍了整体的实现结构和理念。如果你有兴趣的话，可以自行探索其中的各种实现细节，相信也能获益不少。</p><p>通过学习开源软件的设计，我们能学到很多学习系统设计的方法，包括：如何规划软件的各个部分，比如，在什么地方存储日志，什么地方存储文件，软件的更新策略，软件的调度方式等。当然也能学到很多编程技巧，比如homebrew 中对于 Shell的使用，这些技巧简洁高效，能体现出作者深厚的编程功力。</p><p>后面，我还会继续学习各种开源软件的设计，总结并分享我的看法和理解~</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://github.com/Homebrew/brew">brew</a></li><li><a href="https://docs.brew.sh/">Homebrew Documentation</a></li><li><a href="https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap">Howto Create and Maintain a Tap</a></li><li><a href="https://docs.brew.sh/Formula-Cookbook">FormulaCookbook</a></li><li><a href="https://docs.brew.sh/Cask-Cookbook">Cask Cookbook</a></li><li><a href="https://docs.brew.sh/External-Commands">ExternalCommands</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-00.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开源软件" scheme="http://chuquan.me/categories/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Homebrew" scheme="http://chuquan.me/tags/Homebrew/"/>
    
    <category term="Formula" scheme="http://chuquan.me/tags/Formula/"/>
    
    <category term="Cask" scheme="http://chuquan.me/tags/Cask/"/>
    
    <category term="Cellar" scheme="http://chuquan.me/tags/Cellar/"/>
    
    <category term="Bottle" scheme="http://chuquan.me/tags/Bottle/"/>
    
    <category term="Keg" scheme="http://chuquan.me/tags/Keg/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地管理你的定时任务？</title>
    <link href="http://chuquan.me/2023/07/30/introduction-to-taskloop/"/>
    <id>http://chuquan.me/2023/07/30/introduction-to-taskloop/</id>
    <published>2023-07-30T14:28:05.000Z</published>
    <updated>2023-09-16T09:10:09.973Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>在日常开发中，我们经常会使用一些定时任务来辅助完成某些事情。对此，绝大多数人都会选择使用crontab 来配置定时任务。</p><p>不可否认，crontab的确是管理定时任务的经典利器，但是你是否和我一样，踩过不少 crontab的坑呢？</p><p>下面，我将介绍一下个人认为 crontab的一些痛点和坑。最终，给出另一种优化的解决方案。</p><h1 id="crontab">crontab</h1><p>提到 crontab，这里必须要介绍一下它的配置规则，如下所示。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.---------------- 分 (0 - 59)</span><br><span class="line">|  .------------- 时 (0 - 23)</span><br><span class="line">|  |  .---------- 日 (1 - 31) </span><br><span class="line">|  |  |  .------- 月 (1 - 12) </span><br><span class="line">|  |  |  |  .---- 星期 (0 - 6) (星期日可为0或7) </span><br><span class="line">|  |  |  |  | </span><br><span class="line">*  *  *  *  * 执行的命令</span><br></pre></td></tr></table></figure> crontab 的配置规则可以分为 5 列，其作用分别是：</p><ul><li>第一列单位为分，表示每时第几分钟，范围为 0-59</li><li>第二列单位为时，表示每天第几小时，范围为 0-23</li><li>第三列单位为日，表示每月第几天，范围为 1-31</li><li>第四列单位为月，表示每年第几月，范围为 1-12</li><li>第五列单位为星期，表示每星期第几天，范围 0-7，0 与 7表示星期日，其他分别为星期 1-6</li></ul><p>整体而言，crontab对于不同的单位（除了星期），均支持了三种配置规则：</p><ul><li>指定时间</li><li>指定范围</li><li>指定步长</li></ul><p>通过组合这些配置规则，crontab 可以实现非常多的定时配置。</p><p>在使用 crontab 很长时间之后，我发现 crontab还是存在着一些使用痛点的，主要有以下几点，下面分别进行介绍。</p><h2 id="输出重定向">输出重定向</h2><p>默认为情况下，crontab会将任务输出默认写入到执行用户的邮件中。如果任务有大量输出，则会大量占用磁盘资源，甚至导致系统宕机。</p><p>如下所示，我们配置一个输出当前日志的定时任务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span></span><br></pre></td></tr></table></figure><p>我们可以查看当前用户的邮件，如下所示。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /var/mail/<span class="variable">$USER</span></span><br><span class="line">...</span><br><span class="line">Tue Aug  1 22:11:22 CST 2023</span><br></pre></td></tr></table></figure></p><p>关于这个问题，实践经验都是建议采用如下的方式对任务的输出进行重定向。很显然，这对于新手是非常不友好的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span> &gt;&gt; /dev/null/ 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="环境变量">环境变量</h2><p>在实践中，我们可以发现 crontab的环境变量与控制台的环境变量是存在差异的。因此，经常会出现这样的情景：在控制台中调试完成的任务，在cron中执行时，其结果会与预期不相符。事实上，产生这种差异的根本原因就是环境变量。</p><p>此外，crontab中环境变量不会全局共享。因此，当我们配置多个任务时，可能需要为每个任务单独配置环境变量。很显然，这是一个重复而又繁琐的问题。</p><h2 id="规则语法">规则语法</h2><p>关于 crontab的规则语法，这是个仁者见仁智者见智的问题。对于老手来说，可能比较简单；对于新人来说，在使用时得去查询各个位置的单位以及不同规则的写法。我觉得crontab的规则语法不容易理解的根本原因是缺少语义。如果能优化其规则语法的语义，那就更好不过了。</p><p>另一方面，对于某些极客来说，crontab的规则可能还不够完备。比如：预期一个定时任务从某个时刻开始或停止执行，或者，预期一个任务循环执行n 次后结束。对于这种规则，crontab无法一次性满足，只能通过配置多个任务来辅助完成。</p><h2 id="运行日志">运行日志</h2><p>在实际应用中，我们经常需要借助任务的运行日志来排查问题。此时，我们就需要修改crontab，将任务的输出重定向至某个文件，从而方便后续进行查看。当任务非常多的时候，我们很难记住每个任务对应的日志文件是哪个。这也是crontab 的一个痛点。</p><h1 id="taskloop">taskloop</h1><p>为了解决 crontab的诸多痛点，我在业余时间开发了一款优化版的定时任务管理器——<ahref="https://github.com/baochuquan/taskloop">taskloop</a>。</p><p>taskloop 底层运行在 cron 守护进程之上，基于 crontab配置了最小粒度的调度规则，实现了一个中间层，从而解决了 crontab的诸多痛点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p><h2 id="命令">命令</h2><p>taskloop提供了一系列的命令，实现了一个相对完整（如有缺失，补充实现）的工作流，其主要包含以下这些特性。</p><h3 id="环境变量-1">环境变量</h3><p><code>taskloop env</code>命令提供了查看、导入、删除环境变量的功能。</p><p>如下所示，为环境变量查看的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> </span><br><span class="line"></span><br><span class="line">PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5/bin:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global/bin:/Users/baochuquan/.rvm/rubies/ruby-2.6.5/bin:/usr/local/texlive/2023basic/bin/universal-darwin:/Users/baochuquan/.nvm/versions/node/v18.16.0/bin:/usr/local/opt/sqlite/bin:/usr/local/sbin:/usr/local/opt/gettext/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Users/baochuquan/.rvm/bin:/Users/baochuquan/Flutter/bin:/Users/baochuquan/Library/Android/sdk/tools</span><br><span class="line">RUBY_VERSION=ruby-2.6.5</span><br><span class="line">GEM_PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global</span><br><span class="line">GEM_HOME=/Users/baochuquan/.rvm/gems/ruby-2.6.5</span><br><span class="line">IRBRC=/Users/baochuquan/.rvm/rubies/ruby-2.6.5/.irbrc</span><br><span class="line">NOX_ROOT=/Users/baochuquan/Develop/nox</span><br><span class="line">NOX_NAME=nox</span><br><span class="line">NOX_COMMON=/Users/baochuquan/Develop/nox/common</span><br><span class="line">NOX_CONFIG=/Users/baochuquan/Develop/nox/config</span><br><span class="line">NOX_SCRIPTS=/Users/baochuquan/Develop/nox/scripts</span><br></pre></td></tr></table></figure></p><p>如下所示，为环境变量导入的使用示例。示例中，我导入了两个环境变量<code>JAVA_HOME</code> 和 <code>GROOVY_HOME</code>。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --import=JAVA_HOME,GROOVY_HOME</span><br><span class="line"></span><br><span class="line">importing JAVA_HOME ...</span><br><span class="line">    JAVA_HOME=/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">importing GROOVY_HOME ...</span><br><span class="line">    GROOVY_HOME=/usr/local/opt/groovy/libexec</span><br><span class="line"></span><br><span class="line">import global environment variables complete.</span><br></pre></td></tr></table></figure></p><p>如下所示，为环境变量删除的使用示例。示例中，我删除了<code>GROOVY_HOME</code> 环境变量。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --remove=GROOVY_HOME</span><br><span class="line"></span><br><span class="line">remove global environment variables complete.</span><br></pre></td></tr></table></figure></p><p>经过一系列导入、删除操作之后，我们可以通过 <code>taskloop env</code>命令来查看导入结果是否正确。</p><h3 id="启动关闭">启动/关闭</h3><p>taskloop 具有一个全局的开关，即启动和关闭的能力。前面我们提到taskloop 底层是运行在 cron 守护进程之上，对此，启动功能的本质就是将taskloop 注册至 crontab；关闭功能的本质就是将 taskloop 从 crontab注销。</p><p>如下所示，为启动 taskloop 的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$  taskloop launch</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has launched successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>如下所示，为关闭 taskloop 的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop shutdown</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has shutdown successfully.</span><br><span class="line"></span><br><span class="line">    byeeeeeeeeeeeeeeeee !</span><br></pre></td></tr></table></figure></p><h3 id="初始化">初始化</h3><p>taskloop 通过读取注册的 Taskfile 来执行所有的任务，Taskfile中可以定义一系列用户自定义的任务。为了便于使用，taskloop提供了一个初始化命令，可以自动创建一个 Taskfile模板，从而供用户进行修改和定制。</p><p>如下所示，为初始化的使用示例。<code>taskloop init</code>方法创建了一个 Taskfile模板，并定义了所有支持的属性，我们可以自定义任务，包括任务的路径、名称、执行规则等。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop init</span><br><span class="line">$ <span class="built_in">cat</span> Taskfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># env to set environment variables which are shared by all tasks defined in the Taskfile. &lt;Optional&gt;</span></span><br><span class="line"><span class="comment"># env &quot;ENV_NAME&quot;, &quot;ENV_VALUE&quot;</span></span><br><span class="line"></span><br><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="发布撤销">发布/撤销</h3><p>当我们完成了对 Taskfile的定义之后，可以进行发布。发布过程中，taskloop 会检查 Taskfile中的语法规则，如果不符合将抛出异常，并提示错误；如果符合规则，则完成发布。Taskfile将正式生效，后续的任务执行将以此为准。</p><p>如下所示，为发布的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop deploy</span><br><span class="line"></span><br><span class="line">                       (@&amp;/////%@@@@@@@@@@@@@<span class="comment">#</span></span><br><span class="line">                          @@&amp;@&amp;////////////////(@@<span class="comment">#</span></span><br><span class="line">                         /@(///////////////////////%@/</span><br><span class="line">                       *@////////////////////////////<span class="comment">#@,</span></span><br><span class="line">                      @&amp;///////////////////////////////@%</span><br><span class="line">                     @&amp;//////////////(@////@&amp;<span class="comment">#/////////(@</span></span><br><span class="line">                     @////////////@@  @////@    ,.@////@@</span><br><span class="line">                    /@//////////&amp;@  ,@@////@@@&amp;.  *///@@</span><br><span class="line">                    ,@/////////(@@@   @///&amp;@     /@@///@@</span><br><span class="line">                     @%////////@@     @@@&amp;           @@/@<span class="comment">#</span></span><br><span class="line">                      @<span class="comment">#///////@           ,</span></span><br><span class="line">                       @@//////@&amp;      @(//@</span><br><span class="line">                         @@/////%@    @////@</span><br><span class="line">                            @@/////<span class="comment">#@@@////@</span></span><br><span class="line">                                &amp;@@@&amp;<span class="comment">#((&amp;@@</span></span><br><span class="line">                          /&amp;<span class="comment">#         @///@@</span></span><br><span class="line">                       ,///,*.        @////@</span><br><span class="line">                   &amp;<span class="comment">#  %/,@           @@///@</span></span><br><span class="line">                 (, .*/&amp;*%/*%///&amp;       (@@@         ,*/////*.</span><br><span class="line">           %/<span class="comment">#@, ////&amp;  @  % .&amp;  /@%/(/    /#/#@(                 #@#/&amp;</span></span><br><span class="line">        (/&amp;               .           .////,                           &amp;//</span><br><span class="line">       &amp;(//@                         &amp;//////&amp;                         @///@</span><br><span class="line">         (@%//////<span class="comment">#&amp;@@@@@@@@@@%///////@@  @@///////%@@@@@@@@@@&amp;#//////#@#</span></span><br><span class="line">                %@@@@&amp;@@@@@&amp;&amp;@@@@/              /@@@@&amp;&amp;@@@@@&amp;@@@@&amp;</span><br><span class="line"></span><br><span class="line">                              Taskfile deploy success!</span><br></pre></td></tr></table></figure></p><p>当然，在某些情况下，我们需要撤销已经发布的Taskfile。此时，我们可以执行如下命令进行撤销。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop undeploy</span><br><span class="line"></span><br><span class="line">Taskfile <span class="keyword">in</span> &lt;/Users/baochuquan/Github/taskloop&gt; has been undeployed successfully.</span><br></pre></td></tr></table></figure><h3 id="任务查看">任务查看</h3><p>为了便于查看当前已发布的任务，taskloop提供了一个命令方便用户进行查询。如下所示，为任务查看的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop list</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Tasks above are defined <span class="keyword">in</span> Taskfile of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">  &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt;</span><br><span class="line">    t.name        = haha</span><br><span class="line">    t.path        = ./test/Test01.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; specific: Aug</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; scope: between 25, 30</span><br><span class="line">    t.loop        = unit: loop; default rule</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br><span class="line">  &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt;</span><br><span class="line">    t.name        = baocq</span><br><span class="line">    t.path        = ./test/Test02.rb</span><br><span class="line">    t.year        = unit: year; default rule</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; interval: 1</span><br><span class="line">    t.loop        = unit: loop; loop: 3</span><br><span class="line">    t.start_point = unit: full; boundary: start from 2023-7-31 22:31:00</span><br><span class="line">    t.end_point   = unit: full; boundary: end to 2023-7-31 22:35:00</span><br><span class="line">  &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt;</span><br><span class="line">    t.name        = chuquan</span><br><span class="line">    t.path        = ./test/Test03.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; scope: after 22</span><br><span class="line">    t.minute      = unit: minute; interval: 10</span><br><span class="line">    t.loop        = unit: loop; loop: 1</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br></pre></td></tr></table></figure><h3 id="日志查看">日志查看</h3><p>为了解决 crontab 的日志查询问题，taskloop同样提供了一个命令支持查询不同维度的日志，包括：系统日志（即 taskloop运行日志）、任务日志。</p><p>如下所示，为查看系统日志的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --cron</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Log of cron:</span><br><span class="line"></span><br><span class="line">Trigger Time: &lt;2023-08-03 08:24:00 +0800&gt;</span><br><span class="line">Checking: &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><p>如下所示，为查看任务日志的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --task-name=baocq</span><br><span class="line">=============================</span><br><span class="line">Project of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">Log of &lt;Task.name: haha&gt; above:</span><br><span class="line">&lt;Trigger Time: 2023-08-03 08:27:16 +0800&gt;</span><br><span class="line">Test0101</span><br><span class="line"></span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><h2 id="语法规则">语法规则</h2><p><code>taskloop init</code> 命令会创建一个 Taskfile 文件，我们可以在Taskfile 文件中自定义不同的任务与规则。这里，taskloop定义了一套语法规则，我们将基于如下所示的 Taskfile 模板进行介绍。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>模板中列出了任务支持的所有属性，首先有两个必要属性 <code>name</code>和 <code>path</code>。</p><ul><li><code>name</code>：用于指出任务的名称，同一个 Taskfile中不能有同名的任务，主要用于日志查询时指定名称。</li><li><code>path</code> 用于指出任务的路径，taskloop会根据此路径加载并执行任务脚本。</li></ul><p>模板中的其他属性均为非必要属性，用于描述执行规则。关于执行规则，taskloop中主要定义如下几种规则。</p><ul><li><strong>指定时间规则（Specific Rule）</strong><ul><li>指定时间规则用于指定特定的时间值，对应的语法是<code>at</code>。</li><li>支持指定时间规则的属性有<code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>，其中<code>week</code>、<code>month</code>、<code>day</code>属性需要使用预定义的符号，其余属性可以直接使用数值。<ul><li>对于<code>week</code>，需要使用星期符号，如：<code>:Sun</code>、<code>:Mon</code>等。</li><li>对于<code>month</code>，需要使用月份符号，如：<code>:Jan</code>、<code>:Feb</code>等。</li><li>对于<code>day</code>，需要使用表示月份中第几天的符号，如：<code>:day1</code>，<code>:day2</code>等。</li></ul></li><li>示例<ul><li><code>t.week = at :Mon, :Sub, :Tue</code></li><li><code>t.month = at :Feb, :Aug</code></li><li><code>t.day = at :day2, :day8, :day30, day:31</code></li><li><code>t.year = at 2023, 2024</code></li><li><code>t.hour = at 10, 11</code></li><li><code>t.minute = at 59</code></li></ul></li></ul></li><li><strong>时间范围规则（Scope Rule）</strong><ul><li>时间范围规则包含三种子规则，对应的语法分别是：<code>before</code>、<code>between</code>、<code>after</code>。<ul><li><code>before</code> 语法表示在小于等于某个值时执行。</li><li><code>between</code>语法表示在大于等于某个值，且小于等于另一个值时执行。</li><li><code>after</code> 语法表示在大于等于某个值时执行。</li></ul></li><li>支持时间范围规则的属性有<code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li><li>示例<ul><li><code>t.year = before 2026</code></li><li><code>t.week = between :Mon, :Fri</code></li><li><code>t.hour = after 12</code></li></ul></li></ul></li><li><strong>时间间隔规则（Interval Rule）</strong><ul><li>时间间隔规则用于指定两次任务之间的时间间隔，对应的语法是<code>interval</code>。</li><li>支持时间间隔规则的属性有<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li><li>示例<ul><li><code>t.minute = interval 5</code></li><li><code>t.day = interval 1</code></li></ul></li></ul></li><li><strong>循环次数规则（Loop Rule）</strong><ul><li>循环次数规则用于指定任务循环的次数，对应的语法是<code>loop</code>。</li><li>支持循环次数规则的属性只有 <code>loop</code>。</li><li>示例<ul><li><code>t.loop = loop 10</code></li></ul></li></ul></li><li><strong>时间列表规则（Time List Rule）</strong><ul><li>时间列表规则用于指定任务执行的时间列表，对应的语法是<code>time</code>。其与 <code>hour</code>、<code>minute</code>属性冲突，不能同时使用。</li><li>支持时间列表规则的属性只有 <code>time</code>。</li><li>示例<ul><li><code>t.time = time "10:00:00", "7:00:00"</code></li></ul></li></ul></li><li><strong>日期列表规则（Date List Rule）</strong><ul><li>日期列表规则用于指定执行任务的日期列表，对应的语法是<code>date</code>。其与<code>year</code>、<code>month</code>、<code>day</code>属性冲突，不能同时使用。</li><li>支持日期列表规则的属性只有 <code>date</code>。</li><li>示例<ul><li><code>t.date = date "2023-10-1, "2023-5-1</code></li></ul></li></ul></li><li><strong>执行边界规则（Boundary Rule）</strong><ul><li>执行边界规则包含两种子规则，对应的语法分别是 <code>from</code> 和<code>to</code>。<ul><li><code>from</code> 语法表示任务从某一个时刻开始执行，支持的属性只有<code>start_point</code>。</li><li><code>to</code> 语法表示任务在某一时刻之后不在执行，支持的属性只有<code>end_point</code>。</li></ul></li><li>示例<ul><li><code>t.start_point = "2023-10-1 10:00:00"</code></li><li><code>t.end_point = "2023-10-30 23:59:00</code></li></ul></li></ul></li></ul><h2 id="工作流程">工作流程</h2><p>taskloop 的工作流程可以分为三个步骤：</p><ul><li><strong>启动/关闭</strong></li><li><strong>初始化</strong></li><li><strong>发布/撤销</strong></li></ul><p>启动/关闭步骤是一个全局开关，对应分别有两个命令，如上所述。关于启动，一般只在最开始使用taskloop的时候使用启动命令。如果希望停止所有已注册任务的执行，则可以执行关闭命令。</p><p>taskloop建议用户能够使用一个目录统一管理所有的定时任务，当希望为这些定时任务创建定时规则时，可以在目录下执行初始化命令，从而生成一个Taskfile文件。之后，即可自定义定时规则。如果用户本地维护了多个目录管理定时任务，则需要在不同的目录下分别执行一次初始化命令，从而完成任务规则自定义。</p><p>发布/撤销步骤相对而言会比较频繁，当初始化并自定义 Taskfile之后，我们就可以执行发布命令，使得 Taskfile 真正在 taskloop中生效。当然，有时候我们会在发布后发现一些错误，我们可以修改后重新发布，或者为了避免产生副作用，可以执行撤销命令。注意，发布/撤销命令必须在Taskfile 的同级目录下执行。</p><h1 id="总结">总结</h1><p>本文简单介绍了一下我最近业余时间写的一个定时任务管理工具——taskloop。同时，解释了为什么做这个工具的原因（即解决crontab 的痛点）。</p><p>关于软件logo，我花了两晚设计了这样一个形象。两个圈组成一个莫比乌斯环，象征着循环。任务执行抽象为海豚跳圈，海豚在两个圈中循环穿越则象征着taskloop 在永不停止地运行任务。</p><p>忘了说，其实写这篇文章的另一个重要目的是为了推广一下我的作品，也希望有兴趣的朋友能够给一些意见，甚至可以一起参与软件的开发和完善。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://github.com/baochuquan/taskloop">taskloop</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby" scheme="http://chuquan.me/categories/Ruby/"/>
    
    
    <category term="taskloop" scheme="http://chuquan.me/tags/taskloop/"/>
    
    <category term="cron" scheme="http://chuquan.me/tags/cron/"/>
    
    <category term="crontab" scheme="http://chuquan.me/tags/crontab/"/>
    
    <category term="定时任务" scheme="http://chuquan.me/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何从链接原理的角度理解 fishhook 的设计思想？</title>
    <link href="http://chuquan.me/2023/06/24/understand-fishhook-design/"/>
    <id>http://chuquan.me/2023/06/24/understand-fishhook-design/</id>
    <published>2023-06-24T14:29:35.000Z</published>
    <updated>2023-09-13T15:06:12.457Z</updated>
    
    <content type="html"><![CDATA[<p>最近在三刷《程序员的自我修养：链接、装载与库》，为了加深对于相关知识的理解，我又阅读了fishhook 的源码。本文希望从程序的链接原理出发，详细介绍 fishhook的设计原理，学习其中的设计思想。</p><span id="more"></span><h1 id="概述">概述</h1><p>Fishhook 是 Facebook 开源的一款面向 iOS/macOS 平台的<strong>符号动态重绑定</strong> 工具，允许开发者在运行时修改 Mach-O中的符号（函数），从而实现 <strong>动态库</strong> 的函数 hook能力。</p><p>Fishhook 提供了两个用于符号重绑定的接口，分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], <span class="type">size_t</span> rebindings_nel)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols_image</span><span class="params">(<span class="type">void</span> *header,</span></span><br><span class="line"><span class="params">                         <span class="type">intptr_t</span> slide,</span></span><br><span class="line"><span class="params">                         <span class="keyword">struct</span> rebinding rebindings[],</span></span><br><span class="line"><span class="params">                         <span class="type">size_t</span> rebindings_nel)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>rebind_symbols</code>可以在所有动态库范围内进行符号重绑定，而<code>rebind_symbols_image</code>则限制了动态库的范围，只能指定某一个动态库。</p><p>这里，我们先预设几个问题，后面会逐步进行解答：</p><ul><li>问题一：fishhook 是在什么时候完成函数 hook 的？</li><li>问题二：fishhook 为什么只支持 hook 动态库函数？</li></ul><p>为了能介绍清楚 fishhook的实现原理，本文我将重点介绍程序的链接原理，包括：静态链接、动态链接。其中，涉及到的术语和概念主要是基于ELF 可执行文件（或目标文件），在真正介绍 fishhook 的原理时，我会将Mach-O 中的术语与 ELF 进行比较和映射，从而达到一个举一反三的效果。</p><h1 id="可执行文件格式">可执行文件格式</h1><p>在介绍链接原理之前，我们有必要先了解一下可执行文件（目标文件）的基本格式，不同的平台有着不同的格式，分别是：</p><ul><li>对于 Windows 平台，其采用的是 <strong>PE（PortableExecutable）</strong> 格式</li><li>对于 Linux 平台，其采用的是 <strong>ELF（Executable LinkableFormat）</strong> 格式</li><li>对于 iOS/macOS 平台，其采用的是 <strong>Mach-O（MachObject）</strong> 格式</li></ul><p>尽管不同平台的可执行文件格式不同，但是它们的组织结构和规则是基本类似的。如下图所示，不同格式的可执行文件基本都包含如下几个部分：</p><ul><li>文件头</li><li>segment 表</li><li>section 表</li><li>section 数据</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-01.png?x-oss-process=image/resize,w_800" /></p><p>文件头用于描述可执行文件的元信息，包括：文件类型、系统版本、segment表的位置和大小、section 表的位置和大小等等。Section表本质上是一个索引表，其存储了每一个 section 的元信息，比如对应 section在文件中的位置和大小。至于 section，它是可执行文件的基本组成单元，常见section有：<code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.symtab</code>、<code>.strtab</code>等。</p><p>那么 segment 表的作用又是什么呢？</p><h2 id="section-与-segment">section 与 segment</h2><p>事实上，两者的区别主要在于：section用于描述可执行文件的静态存储布局，segment用于描述可执行文件的装载内存布局。</p><p>我们知道可执行文件是以 section 为基本单元存储的，section的类型非常多，如：<code>.data</code>、<code>.text</code>、<code>.rodata</code>等。假如，我们的可执行文件中有两个 section，分别是 <code>.init</code> 和<code>.text</code>，两者的大小分别是 3500B 和4100B。假设系统的页面大小为 4KB，我们来分别看一下基于 section 装载和基于segment 装载的内存占用情况。</p><p>下图右部所示为基于 section 装载的内存占用情况，其中<code>.init</code> 单独占用一个页，且页没有全部使用；<code>.text</code>会单独占用两个页，且第二页绝大多数内存空间没有使用，总共浪费内存 3 x 4KB- 3500B - 4100B = 4688B。</p><p>下图左部所示为基于 segment 装载的内存占用情况，<code>.text</code>占用了两个页，且与 <code>.init</code> 共享了一个页，总共浪费内存 2 x 4KB- 3500B - 4100B = 592B。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-02.png?x-oss-process=image/resize,w_800" /></p><p>很显然，相比于基于 section 装载，基于 segment装载对于内存占用的优化非常明显，内存碎片更少。在实际中，程序在装载时会将相同权限的section 合并在一个 segment 中，比如：<code>.init</code> 和<code>.text</code> 都合并成为可读可执行权限的segment，作为代码段；可读可写的 section 合并在为一个segment，作为数据段。</p><h1 id="程序的链接原理">程序的链接原理</h1><p><strong>链接（Linking）</strong>的本质是把多个目标文件相互拼接到一起，使得函数调用、变量访问等指令能够找到正确的内存地址。然而，这一切都是围绕着<strong>符号（Symbol）</strong> 完成的。</p><p>那么到底什么是符号？举个例子，目标文件 B 调用了目标文件 A 中的函数<code>foo</code>。对此，我们认为目标文件 A 定义了函数<code>foo</code>，目标文件 B 引用了函数<code>foo</code>。在链接过程中，我们将函数和变量统称为<strong>符号（Symbol）</strong>，函数名和和变量名统称为<strong>符号名（Symbol Name）</strong>。因此，我们也可以认为目标文件 A包含了函数 <code>foo</code> 的 <strong>符号定义（SymbolDefinition）</strong>，目标文件 B 包含了函数 <code>foo</code> 的<strong>符号引用（Symbol Reference）</strong>。</p><p>这时候问题来了，链接过程是如何基于符号完成对二进制指令中内存地址的修正呢？对此，我们可以先来了解一下静态链接。</p><h2 id="静态链接">静态链接</h2><p>静态链接会在编译期将多个目标文件合并为一个可执行文件。因此，里面包含了所有的符号、重定位项、字符串等。</p><p>在编译过程中，编译器会为每一个变量或函数生成一个符号项，符号项包含的信息主要有：</p><ul><li><strong>符号名</strong>：即一个指向字符串表的索引，比如：字符串<code>foo</code> 在字符串表中的偏移量。</li><li><strong>符号类型</strong>：类型有很多，比如：全局符号、局部符号、未定义符号等。</li><li><strong>符号值</strong>：<strong>符号定义</strong>的内存地址，用于修正二进制指令中的内存地址。这个地址修正的过程被称为<strong>重定位</strong>。</li></ul><p>此外，编译器还会为每个变量引用或函数引用生成一个重定位项。由于每一个重定位项记录了每一次对于符号的引用，因此，我们可以将其称为符号引用项。这样也就构成了符号定义和符号引用的一对多关系，毕竟，我们可以在不同的地方引用同一个变量或函数。</p><p>基于如下示意图，静态链接的整体工作原理大概可以分为以下三个步骤：</p><ul><li>根据重定位项中的符号索引，去符号表找到对应的符号项，并获取到对应符号的符号值，即内存地址。</li><li>根据重定位项中的重定位地址，找到代码段中对应的字节地址，将其修正为步骤一获取到的内存地址。</li><li>遍历重定位表中的所有重定位项，重复步骤一和步骤二。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/static-linking-01.png?x-oss-process=image/resize,w_800" /></p><p>由于静态链接时，程序所依赖的所有目标文件都已经合并在了一个可执行文件中，因此几乎不存在符号项中的符号值（内存地址）不确定的情况，对此，静态链接器只需要基于重定位表进行重定位即可。这其实就是大家常说『静态链接的重点是重定位』的原因。</p><h2 id="动态链接">动态链接</h2><p>动态链接的基本思想是<strong>将程序按照模块拆分成各个独立的部分，在运行时将它们链接在一起形成一个完整的程序</strong>，而不是像静态链接一样在编译时把所有的模块都链接成一个独立的可执行文件。因此，动态链接可以有效解决静态链接存在的<strong>内存空间浪费</strong> 和 <strong>程序更新困难</strong>的问题。</p><p>那么对于动态链接，我们是否可以直接采用静态链接的做法呢？这种方案理论上可以，但却不是最优解，因为静态链接会修改代码段，我们很难让共享对象在被多次重定位之后也能继续安全稳定的运行。</p><p>举一个例子，如下所示，一个动态共享对象 <code>X</code>内部会引用外部的一个变量 <code>a</code>。当程序 <code>A</code>与动态共享对象 <code>X</code> 完成重定位后，<code>X</code>代码段中的某个指令的访存地址可能是一个值；当程序 <code>B</code>与动态共享对象 <code>X</code> 完成重定位后，<code>X</code>代码段中同位置的访存地址可能会被修改成另一个值。这时候，必然会出现其他程序无法正常执行的情况。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-01.png?x-oss-process=image/resize,w_800" /></p><p>关于如何解决多进程之间的重定位冲突问题，我们可以引用下图所示的经典名言来描述动态链接的解决方案。当然，在具体的实现中，动态链接根据链接的时机，还可以分为<strong>装载时链接（Load-Time Linking）</strong> 和<strong>延迟链接（LazyLinking）</strong>。两者的实现思路只有略微的差异，下面我们将分别进行介绍。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p><h3 id="装载时链接">装载时链接</h3><p>下图所示为装载时链接的工作原理示意图。对于共享对象而言，其代码段会被多个进程所共享，因此不能直接在代码段中进行重定位，修改内存地址。考虑到多进程共享对象时，共享对象会为每个进程拷贝一份数据段，支持修改。因此，一种称为<strong>地址无关代码（PIC，Position-Independent Code）</strong>的技术诞生了，其基本思想是：在编译时配置 PIC编译选项，将指令部分中需要被修改的部分分离出来，跟数据部分放在一起。这样指令部分可以保持不变，而数据部分可以在每个进程中有一个独立的副本。</p><p>对于 PIC技术，代码运行性能会比静态链接要差一点。因为指令在访问外部变量或外部函数时，必须先通过指针去数据段找到对应的位置，再从中取出真实的内存地址，很显然多了一次间接操作，损耗了性能。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-02.png?x-oss-process=image/resize,w_800" /></p><p>在装载前，共享对象 <code>X</code> 的符号表中的外部符号<code>bar</code> 的内存地址是未定义的。但是，程序 <code>A</code>的符号表中的符号 <code>bar</code> 的内存地址是确定的（因为符号<code>bar</code> 的符号定义位于程序 <code>A</code>中）。因此，在装载时我们就可以决议出共享对象 <code>X</code> 的外部符号<code>bar</code> 的地址。这个过程，我们称之为<strong>装载时绑定（Load-Time Binding）</strong> 或<strong>装载时符号绑定（Load-Time Symbol Binding）</strong>。</p><p>当外部符号 <code>bar</code>的内存地址绑定完成后，我们就可以进行后续的重定位了。其步骤和静态链接的重定位类似，主要包括以下几步：</p><ul><li>根据动态重定位项中的符号索引，去动态符号表中找到对应的符号项，并获取对应符号的符号值，即装载时绑定的内存地址。</li><li>根据动态重定位项中的重定位地址，找到 <strong>数据段</strong>中对应的字节地址，将其修正为步骤一获取到的内存地址。</li><li>遍历动态重定位表中的所有重定位项，重复步骤一和步骤二。</li></ul><p>在 PIC技术中，编译器会在数据段中为每一个符号存储一个占位桩（stub），用于存储符号的真实内存地址。这些占位桩组成了一个表，我们称之为<strong>全局偏移表（GOT，Global Offset Table）</strong>。</p><p>综上述可以看出，装载时链接包含了两个重要的步骤，分别是装载时绑定和重定位。虽然中间多了一步间接索引内存地址，损耗了一些性能，但是程序的灵活性和复用性提高了很多。</p><h3 id="延迟链接">延迟链接</h3><p>考虑到程序运行的局部性，实际上在进程生命周期中很多变量或函数并不会被调用。于是，诞生了延迟链接技术，可以支持进程只在第一次调用符号时才进行链接。</p><p>下图所示为延迟链接的工作原理示意图，本质上与装载时链接差不多，主要区别在于：装载时链接在数据段中使用了GOT 存储符号地址，延迟链接则在数据段中使用了<strong>过程链接表（PLT，Procedure Linkage Table）</strong>存储符号地址。当 PLT 表项中符号的内存地址未决议时，PLT表项中的占位桩（stub）存储的是一段代码的地址。当这段代码完成符号绑定和重定位后，会将符号的真实内存地址回填到占位桩中，覆盖默认的代码地址，从而实现仅在第一次调用符号时才进行链接。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-03.png?x-oss-process=image/resize,w_800" /></p><p>延迟链接的关键是如何实现在第一次调用符号时进行链接，这个过程包含了<strong>延迟绑定（Lazy Binding）</strong> 和重定位。关于 PLT的存储，很多目标文件会将其存储在命名为 <code>got.plt</code> 的 section中，Mach-O 和 ELF 都是如此，这一点需要注意。</p><h1 id="fishhook-实现原理">Fishhook 实现原理</h1><h2 id="核心思想">核心思想</h2><p>上述介绍了程序的链接原理，尤其是在理解了动态链接之后，如果你细想思考一下，很容易就能想到fishhook 的设计思想。</p><p>下图展示了 fishhook 的设计思想，非常简单巧妙，核心思想就是<strong>将目标符号（函数）对应的 GOT 表项或 PLT表项中存储的符号值（内存地址），替换成 hook函数的内存地址</strong>。通过这种方式，无论是装载时链接还是延迟链接，我们都可以实现对动态共享库函数的hook。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-04.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们来介绍一下 fishhook 实现细节中与 Mach-O 的相关概念。</p><h2 id="non-lazy-symbol-pointer-lazy-symbol-pointer">Non-lazy SymbolPointer &amp; Lazy Symbol Pointer</h2><p>如下所示为《Mach-O Programming Topics》中对两者的解释：</p><blockquote><p>Non-lazy symbol references are resolved (bound to their definitions)by the dynamic linker when a module is loaded.A non-lazy symbolreference is essentially a symbol pointer—a pointer-sized piece of data.The compiler generates non-lazy symbol references for data symbols orfunction addresses.</p><p>Lazy symbol references are resolved by the dynamic linker the firsttime they are used (not at load time). Subsequent calls to thereferenced symbol jump directly to the symbol’s definition.Lazy symbolreferences are made up of a symbol pointer and a symbol stub, a smallamount of code that directly dereferences and jumps through the symbolpointer. The compiler generates lazy symbol references when itencounters a call to a function defined in another file.</p></blockquote><p>Non-lazy Symbol Pointer 存储的是指向符号定义的指针，它与 GOT中的表项定义非常类似。由 Non-lazy Symbol Pointer 组成的表，在 Mach-O中我们称为 Non-lazy Symbol Pointer Table。</p><p>Lazy Symbol Pointer包含一个指向符号定义的指针、一个占位桩以及一段代码（可用于延迟绑定和重定位），它与PLT 中的表项定义非常类似。由 Lazy Symbol Pointer 组成的表，在 Mach-O中我们称之为 Lazy Symbol Pointer Table。</p><h2 id="indirect-symbol-table">Indirect Symbol Table</h2><p>上述的 Non-lazy Symbol Pointer 和 Lazy Symbol Pointer并没有包含符号名相关的信息，然而在实际的符号查找、绑定的过程是需要用到的。因此，对于Non-lazy Symbol Pointer Table 和 Lazy Symbol Pointer Table各自有一个同步的间接符号表，可以用于配合完成链接工作。Fishhook 也是借助Indirect Symbol Table间接获取符号名，然后与目标符号进行判等比较，从而最终完成 hook 工作。</p><p>Indirect Symbol Table 与 Symbol Pointer Table的表项是一一对应的，比如：Indirect Symbol Table 中第 1601 项存储的就是Symbol Pointer Table 中第 1601 项的符号索引，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-05.png?x-oss-process=image/resize,w_800" /></p><h2 id="symbol-pointer-目标符号地址替换">Symbol Pointer目标符号地址替换</h2><p>Fishhook 的核心是 <strong>完成 Symbol Pointer的地址替换</strong>，无论是 Non-lazy Symbol Pointer 还是 Lazy SymbolPointer。其实现的关键步骤主要包括以下几步：</p><ul><li>查找数据段，即 <code>SEG_DATA</code> 或<code>SEG_DATA_CONST</code></li><li>在数据段中查找 <code>LAZY_SYMNBOL_POINTERS</code> 和<code>NON_LAZY_SYMBOL_POINTERS</code> 类型的 section</li><li>分别对 <code>LAZY_SYMBOL_POINTERS</code> 和<code>NON_LAZY_SYMBOL_POINTERS</code> section 进行 Symbol Pointer目标符号地址替换</li></ul><p>Symbol Pointer 目标符号地址替换的过程主要有以下几步：</p><ul><li>根据 <code>LAZY_SYMBOL_POINTERS</code> 或<code>NON_LAZY_SYMBOL_POINTERS</code> section 获取其对应的 IndirectSymbol Table</li><li>遍历 section，同步遍历 Indirect Symbol Table，获取对应的符号名</li><li>遍历过程中，判断符号名是否与目标符号名匹配。如果匹配，则将 SymbolPointer 的符号地址替换成 hook函数的地址；否则，继续遍历，直到结束。</li></ul><p>这里涉及到了 fishhook 中的两个函数实现，分别是<code>rebind_symbols_for_image</code> 函数和<code>perform_rebinding_with_section</code>函数，有兴趣的朋友可以自行阅读，本文就不粘贴代码了。</p><h1 id="总结">总结</h1><p>至此，我们从链接原理的角度介绍了 fishhook的设计思路。通过这种自顶向下的方法来分析，我们很快就可以联想到如何去实现一个针对ELF 格式的 hook 工具。</p><p>最后，我们再来回顾一下本文开头预留的几个问题。</p><p>问题一：fishhook 是在什么时候完成函数 hook 的？fishhook 会在调用<code>rebind_symbols</code> 或 <code>rebind_symbols_image</code>方法时去遍历镜像，从而完成对目标符号的地址替换。</p><p>问题二：fishhook 为什么只支持 hook 动态库函数？动态库的 PIC技术支持在数据段进行重定位，因此允许我们进行目标地址修改。而 fishhook的整个机制就是建立在动态链接原理的基础上，因此仅支持 hook动态库函数。</p><h1 id="参考">参考</h1><ol type="1"><li>《程序员的自我修养：装载、链接与库》</li><li><a href="https://studfile.net/preview/2082911/">OS X ABI Mach-O FileFormat Reference</a></li><li>Mach-O Programming Topics</li><li><a href="https://github.com/facebook/fishhook">fishhook</a></li><li><ahref="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">BSDLibrary Functions Manual——dyld(3)</a></li><li><ahref="https://man7.org/linux/man-pages/man3/dladdr.3.html">dladdr(3) —Linux manual page</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在三刷《程序员的自我修养：链接、装载与库》，为了加深对于相关知识的理解，我又阅读了
fishhook 的源码。本文希望从程序的链接原理出发，详细介绍 fishhook
的设计原理，学习其中的设计思想。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
    <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
    <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
    <category term="fishhook" scheme="http://chuquan.me/tags/fishhook/"/>
    
    <category term="PIC" scheme="http://chuquan.me/tags/PIC/"/>
    
    <category term="GOT" scheme="http://chuquan.me/tags/GOT/"/>
    
    <category term="PLT" scheme="http://chuquan.me/tags/PLT/"/>
    
    <category term="延迟绑定" scheme="http://chuquan.me/tags/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基于原型的继承模式</title>
    <link href="http://chuquan.me/2023/04/22/prototype-based-inheritance/"/>
    <id>http://chuquan.me/2023/04/22/prototype-based-inheritance/</id>
    <published>2023-04-22T14:16:49.000Z</published>
    <updated>2024-05-08T08:47:09.944Z</updated>
    
    <content type="html"><![CDATA[<p><strong>继承</strong>（Inheritance）是<strong>面向对象编程</strong>（Object Oriented Programming,OOP）的三大特性之一，其他两大特性是<strong>封装</strong>（Encapsulation）和<strong>多态</strong>（Polymorphism）。在编程语言中，继承的主流实现方式有两种，分别是：</p><span id="more"></span><ul><li><strong>基于类的继承</strong>（Class-basedInheritance）：绝大多数面向对象编程语言都使用了基于类的继承，比如：C++、Java、Swift、Kotlin等。</li><li><strong>基于原型的继承</strong>（Prototype-basedInheritance）：少数面向对象编程语言使用基于原型的继承，一般都是解释型编程语言，即脚本语言，比如：JavaScript、Lua、Io、Self、NewtonScript等。</li></ul><p>除此之外，有一些辅助继承的实现方式，比如：<strong>接口继承</strong>和<strong>类型混入</strong>，一般用于实现多类型复用，可以达到类似多继承的效果。</p><p>本文，我们来简单介绍一下其中基于原型的继承模式。</p><h1 id="基于类的继承-vs-基于原型的继承">基于类的继承 vs基于原型的继承</h1><p>在基于类继承的语言中，对象是类的实例，类可以从另一个类继承。从本质上而言，类相当于模板，对象则通过这些模板来进行创建。</p><p>下图所示，为基于类的继承实现示意图。每个类都有一个类似<code>superclass</code> 的指针指向其父类。每个对象都有一个类似<code>isa</code> 的指针指向其所属的类。</p><p>此外，每个类都存储了一系列方法，可用于其实例进行查找和共享。关于方法存储方式，不同语言的实现有所不同。</p><ul><li>对于 C++等语言，每个类会保存所有祖先类的方法地址。因此，在方法查找时，无需沿着继承链进行查找</li><li>对于 Ruby、Objective-C等语言，每个类只会保存其所定义的方法地址，而不保存祖先类的方法地址。因此，在方法查找时，会沿着继承链进行查找，这种模式也被称为<strong>消息传递</strong>（Message Passing）。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-03.png?x-oss-process=image/resize,w_800" /></p><p>在基于原型继承的语言中，没有类的概念，对象可以直接从另一对象继承。中间省略了通过模板创建对象的过程。</p><p>下图所示，为基于原型的继承实现示意图。每个对象都有一个类似<code>prototype</code> 的指针指向其原型对象。</p><p>每个对象存储了一系列方法，基于原型链，对象之间可以实现方法共享，当然也可以共享属性。方法和属性的查找过程，类似于上述的消息传递，会沿着原型链进行查找。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-04.png?x-oss-process=image/resize,w_800" /></p><h1 id="原型继承的优缺点">原型继承的优缺点</h1><p>前面，我们简单对比了两种继承模式的实现原理。下面，我们来讨论一下原型继承的优缺点。</p><p>对比而言，原型继承的优点主要有一下这些：</p><ul><li><strong>避免大量的初始化工作</strong>。通过克隆一个现有对象来创建一个新对象，并具有相同的内部状态。</li><li><strong>具有非常强大的动态性</strong>。通过修改原型链，可以将原型指针指向任意对象，使得当前对象可以继承其他对象的能力。</li><li><strong>有效降低程序的代码量</strong>。由于原型继承没有类的概念，因此在代码实现中无需进行类的定义。</li></ul><p>当然，凡事都具有两面性，以下罗列了一些原型继承的缺点：</p><ul><li><strong>性能开销相对较大</strong>。当我们访问属性或方法时，运行时会通过原型链进行查找，中间存在一个遍历的过程。</li><li><strong>原型共享的副作用</strong>。由于多个对象可以共享同一个原型对象，一旦某个对象修改原型对象的状态，将会对其他对象产生副作用。</li><li><strong>面向对象异类设计</strong>。绝大多数面向对象语言及教程都是基于类的实现而设计的，这对于习惯于基于类的OOM 的开发者很容易产生困惑。</li></ul><h1 id="不同语言的原型继承实现">不同语言的原型继承实现</h1><p>下面，我们来看看不同编程语言中，基于原型的继承模式的实现细节。</p><h2 id="javascript">JavaScript</h2><p>JavaScript原型实现存在着很多矛盾，它使用了一些复杂的语法，使其看上去类似于基于类的语言，这些语法掩盖了其内在的原型机制。JavaScript不直接让对象继承其他对象，而是提供了一个中间层——<strong>构造函数</strong>，完成对象的创建和原型的串联，从而间接完成对象继承。由于构造函数的定义类似于类定义，但又不是真正意义的类，因此我们可以称之为<strong>伪类</strong>（Pseudo Class）。</p><p>默认情况下，伪类包含一个 <code>prototype</code>指针指向原型，对象包含一个 <code>constructor</code>指针指向伪类（构造函数），两者之间的关系如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-01.png?x-oss-process=image/resize,w_800" /></p><p>为了实现新的对象继承其他对象，一般会先修改伪类中<code>prototype</code>的指针，然后再调用伪类进行对象构造和原型绑定。如下所示，为一段代码实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AType</span>.<span class="property">propertytype</span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 AType。即修改伪类 BType 的 prototype 指针，使其指向父对象。</span></span><br><span class="line"><span class="title class_">BType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">AType</span>();</span><br><span class="line"><span class="title class_">BType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">BType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其中 <code>BType.prototype = new AType()</code> 修改了<code>BType</code> 伪类的 <code>prototype</code> 指针，使其指向<code>AType</code> 对象。当我们调用 <code>BType</code>构造函数时，所构造的对象自动继承 <code>AType</code>对象。如下所示，为基于原型的继承关系示意图，其中每个伪类的<code>prototype</code>指针都发生了变化，指向了其所继承的父对象。最终，生成的对象中会包含一个<code>__proto__</code> 指针指向父对象。根据 <code>__proto__</code>指针我们可以构建一个完整的原型链。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-02.png?x-oss-process=image/resize,w_800" /></p><p>当然，在原型继承模式中，原型链中的父对象可能会被多个子对象所共享，因此子对象之间的状态同步问题需要格外注意。一旦，某个子对象修改了父对象的状态，那么会同时影响其他子对象。关于如何解决这个问题，JavaScript中有很多解决方法，具体细节可以阅读相关书籍和博客，这里不作详细赘述。</p><h2 id="lua">Lua</h2><p>Lua 中的 <strong>表（table）</strong>是一种非常强大且常用的数据结构，它类似于其他编程语言中的字典或哈希表，可以以键值对的方式存储数据，包括方法定义。通常会使用table来解决模块（module）、包（package）、对象（object）等相关实现。</p><p>与此同时，Lua 还提供了 <strong>元表（metatable）</strong>的概念，其本质上仍然是一个表结构。但是元表可以对表进行关联和扩展，允许我们改变表的行为。</p><p>元表中最常用的键是 <code>__index</code>元方法。当我们通过键来访问表时，如果对应的键没有定义值，那么 Lua会查找表的元表中的 <code>__index</code> 键。如果 <code>__index</code>指向一个表，那么 Lua 会在这个表中查找对应的键。</p><p>如下所示，我们为表 <code>a</code> 设置一个元表，其中定义元表的。<code>__index</code> 键为表 <code>b</code>。当查找表 <code>a</code>时，对应的键没有定义，那么会去查找元表。判断元表是否定义了<code>__index</code> 键，这里定义为另一个表 <code>b</code>。于是，会在表<code>b</code> 中查找对应的键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(a, &#123; <span class="built_in">__index</span> = b &#125;)</span><br></pre></td></tr></table></figure><p>Lua 中的继承模式正是基于元表和 <code>__index</code>元方法而实现的。如下所示，分别是 Lua中继承模式的实现示意图，以及对应的代码实现。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-06.png?x-oss-process=image/resize,w_800" /></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RootType = &#123; rootproperty = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RootType:new</span> <span class="params">(o)</span></span> </span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">SuperType = RootType:new(&#123; superproperty = <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">SubType = SuperType:new(&#123; subproperty = <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure><p><code>RootType</code> 是一个对象，其实现了一个 <code>new</code>方法用于完成几项工作：</p><ul><li>构造对象，其本质上是一个表。</li><li>将 <code>RootType</code> 对象设置为新对象的元表。</li><li>将 <code>RootType</code> 对象的 <code>__index</code> 指向<code>RootType</code> 对象自身。</li></ul><p>最终形成图中所示的对象继承关系。由于 Lua中的继承实现没有类的概念，而只有对象的概念。因此也被归类成基于原型的继承模式。当<code>SubType</code> 对象中没有找到对应的键时，会根据<code>metatable</code> 指针找到对应的元表，并根据元表的<code>__index</code> 指针找到进一步查找的表对象<code>SuperType</code>。如果 <code>SuperType</code>中仍然没有，那么继续根据 <code>metatable</code> 和 <code>__index</code>指针进行查找。</p><h2 id="io">Io</h2><p>Io 的继承模式也是基于原型实现的，它的实现相对而言更加简单、直观。</p><p>在 Io中，一切都是对象（包括闭包、命名空间等），所有行为都是消息（包括赋值操作）。这种消息传递机制其实与Objective-C、Ruby 是一样的机制。在 Io中，对象的组成非常关键，其主要包含两个部分：</p><ul><li><strong>槽</strong>（slots）：一系列键值对，可以存储方法或属性。</li><li><strong>原型</strong>（protos）：一个内部的对象数组，记录该对象所继承的原型。</li></ul><p>Io 使用克隆的方式创建对象，对应提供了一个 <code>clone</code>方法。当对父对象进行克隆时，新对象的 <code>protos</code>数组中会加入对父对象的引用，从而建立继承关系。如下所示，为 Io中继承模式的实现示意图，以及对应的代码实现。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-07.png?x-oss-process=image/resize,w_800" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RootType := Object clone</span><br><span class="line">RootType rootproperty := 0</span><br><span class="line"></span><br><span class="line">SuperType := RootType clone</span><br><span class="line">SuperType superproperty := 0</span><br><span class="line"></span><br><span class="line">SubType := SuperType clone</span><br><span class="line">SubType subproperty := 0</span><br></pre></td></tr></table></figure><p>相比于 JavaScript 和 Lua 的链表式单继承模式，Io是支持多继承的，其采用了多叉树的模式来实现的，其中最关键的就是<code>protos</code> 数组。很显然，<code>protos</code>数组可以存储多个原型对象。因此，可以实现多继承。如下所示，是 Io中多继承模式的实现示意图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-08.png?x-oss-process=image/resize,w_800" /></p><p>因此，Io 中方法和属性的查找方式也有所不同，其基于 <code>protos</code>数组，使用深度优先搜索的方式来进行查找。在这种模式下，如果一个对象继承的对象越多，那么方法和属性的查找效率也会越低。</p><h1 id="总结">总结</h1><p>本文，我们首先简单对比了基于类的继承模式与基于原型的继承模式，其核心区别在于是否基于类来进行构建继承关系。对于后者，没有类的概念，即使有，那也是一种语法糖，为了与基于类的语言靠拢降低开发者的学习成本和理解成本。</p><p>其次，我们简单介绍了基于原型继承的优缺点。当我们对编程语言进行技术选型时，也可以从这方面进行考虑和权衡，判断是否适用于特定的场景。</p><p>最后，我们介绍了三种编程语言中基于原型的继承实现，分别是：JavaScript、Lua、Io。三种语言各有其实现特点，但核心思想基本是一致的，即直接在对象之间建立引用关系，从而便于进行方法和属性的查找。</p><h1 id="参考">参考</h1><ol type="1"><li>《深入设计模式》</li><li>《JavaScript 高级程序设计》</li><li>《JavaScript 语言精粹》</li><li>《七周七语言：理解多种编程范式》</li><li><a href="http://siffiejoe.github.io/lua-prototype/">prototype ——Prototype Based OO Programming For Lua</a></li><li><ahref="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a></li><li><ahref="https://en.wikipedia.org/wiki/Prototype-based_programming">Prototype-basedprogramming</a></li><li><ahref="https://developer-interview.com/p/oop-ood/how-prototype-based-oop-is-different-from-class-based-13">Differencefrom class-based inheritance</a></li><li><ahref="https://developer-interview.com/p/oop-ood/what-are-advantages-and-disadvantages-of-prototypal-oop-12">Whatare advantanges and disadvantages of prototypal OOP</a></li><li><ahref="https://developer-interview.com/p/oop-ood/what-is-prototype-based-oop-how-it-is-different-from-class-based-4">Whatis prototype-based OOP?</a></li><li><ahref="https://exploringjs.com/impatient-js/ch_proto-chains-classes.html">Prototypechains and classes</a></li><li><a href="https://github.com/nusov/lua-object">lua-object</a></li><li><ahref="https://juejin.cn/post/6975694337698955295">01.原型(prototype)和原型链(prototypechain)</a></li><li><ahref="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">对象原型</a></li><li><ahref="http://kenneth-kin-lum.blogspot.com/2012/10/javascripts-pseudo-classical.html">JavaScript'sPseudo Classical Inheritance diagram</a></li><li><a href="https://www.lua.org/pil/contents.html">Programming inLua</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;（Inheritance）是
&lt;strong&gt;面向对象编程&lt;/strong&gt;（Object Oriented Programming,
OOP）的三大特性之一，其他两大特性是
&lt;strong&gt;封装&lt;/strong&gt;（Encapsulation）和
&lt;strong&gt;多态&lt;/strong&gt;（Polymorphism）。在编程语言中，继承的主流实现方式有两种，分别是：&lt;/p&gt;</summary>
    
    
    
    <category term="编程范式" scheme="http://chuquan.me/categories/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
    
    <category term="继承" scheme="http://chuquan.me/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="原型继承" scheme="http://chuquan.me/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
    <category term="类继承" scheme="http://chuquan.me/tags/%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
    
    <category term="原型链" scheme="http://chuquan.me/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    <category term="元表" scheme="http://chuquan.me/tags/%E5%85%83%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>结构化并发</title>
    <link href="http://chuquan.me/2023/03/11/structured-concurrency/"/>
    <id>http://chuquan.me/2023/03/11/structured-concurrency/</id>
    <published>2023-03-11T14:03:51.000Z</published>
    <updated>2023-09-16T09:24:59.391Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/structured-concurrency-logo.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>对于异步与并发，一直以来，业界都有着非常广泛的研究，针对特定场景提出了很多相关的技术，如：Future/Promise、Actor、CSP、异步函数等等。本文，我们来介绍一个近些年才出现的一个概念——<strong>结构化并发（StructuredConcurrency）</strong>。</p><p>2016 年，ZeroMQ 的作者 Martin Sústrik 于在其 C 语言结构化并发库libdill中首次提出了“结构化并发”的概念。事实上，这个概念其实是受到了更早期Dijkstra 所提出的 <strong>结构化编程（Structured Programming）</strong>的启发。</p><p>为了引出结构化并发，我们首先来介绍一下什么是结构化编程，这一切要从GOTO 有害论说起。</p><h1 id="goto-有害论">GOTO 有害论</h1><p>计算机发展的早期，程序员使用汇编语言进行编程，在之后的一段时期，诞生了比汇编略微高级的编程语言，如FORTRAN、FLOW-MATIC等。这些语言虽然在一定程度上提高了可读性，但是仍然存在很大的局限性。如下所示就是一段FLOW-MATIC 代码。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-01.png?x-oss-process=image/resize,w_800" /></p><p>由于当时块语法还没有发明，因此 FLOW-MATIC 不支持 <code>if</code>块、循环块、函数调用、块修饰符等现代语言必备的基础特性。整段代码就是一系列按顺序排列并打平的命令。关于控制流，程序支持两种方式，分别是：</p><ul><li><strong>顺序执行</strong></li><li><strong>跳转执行</strong>，即 GOTO 语句。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-03.png?x-oss-process=image/resize,w_800" /></p><p>顺序执行的逻辑非常简单，它总是能够找到执行入口与出口。与之相反，跳转执行则充满了不确定性。如果程序中存在GOTO 语句，那么它可以在<strong>任何时候跳转至任何指令位置</strong>。一旦程序大量使用了 GOTO语句，那么最终将变成 <strong>面条式代码（Spaghetti code）</strong>。</p><p>如下所示，我们对 FLOW-MATIC代码的控制流使用箭头进行变标记，可以发现整个逻辑变成了一团糟，如同面条一般。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-02.png?x-oss-process=image/resize,w_800" /></p><h1 id="结构化编程">结构化编程</h1><p>在发表 <ahref="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">《GotoStatement Considered Harmful》</a> 之后，Dijkstra 又发表了 <ahref="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF">《Notes onStructured Programming》</a> 表达了其理想的编程范式，提出了<strong>结构化编程</strong> 的概念。</p><p>结构化编程在现在看来是理所当然的，但是在当时并不是。结构化编程的核心是<strong>基于块语句，实现代码逻辑的抽象与封装，从而保证控制流具有单一入口和单一出口</strong>。现代编程语言中的条件语句、循环语句、函数定义与调用都是结构化编程的体现。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-01.png?x-oss-process=image/resize,w_800" /></p><p>相比 GOTO语句，基于块的控制流有一个显著的特征：控制流从程序入口进入，中途可能会经历条件、循环、函数调用等控制流转换，但是最终控制流都会从程序出口退出。这种编程范式使得代码结构变得更加结构化，思维模型变得更加简单，也为编译器在低层级提供了优化的可能。</p><p>因此，完全禁用 GOTO语句已经成为了大部分现代编程语言的选择。虽然，少部分编程语言仍然支持GOTO，但是它们大都支持高德纳（Donald ErvinKnuth）所提出的前进分支和后退分支不得交叉的理论。类似<code>break</code>、<code>continue</code>等控制流命令，依然遵循结构化的基本原则：<strong>控制流拥有单一的入口与出口</strong>。</p><p>如今，我们基于现代编程语言所编写的程序，绝大部分都是结构化的，结构化编程范式早已深入人心。</p><h1 id="并发编程">并发编程</h1><p>在单线程编程模型中，编程语言<strong>通过代码块避免控制流随意跳转</strong>，从而实现程序的结构化。但是，在多线程编程（并发编程）模型中，线程之间控制和归属关系仍然存在很多问题，其面临的问题与GOTO 的问题非常相似，这也是结构化并发所要解决的问题。</p><p>下面，我们先来看一下非结构化并发的问题。</p><h2 id="非结构化并发">非结构化并发</h2><p>我们首先来看一个使用 Swift 编写的非结构化并发的例子，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        foo(completion: &#123; <span class="built_in">print</span>(<span class="string">&quot;main get <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">foo</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        bar(completion: &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;foo get <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">            completion(<span class="variable">$0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">bar</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">Int</span>(arc4random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bar get <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">    completion(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程执行</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>上述代码中，主线程执行 <code>main</code> 方法是一个结构化的过程。而<code>main</code> 和 <code>foo</code>内部则以非阻塞的方式执行并发任务，并通过 <code>completion</code>获取结果。<code>bar</code> 内部则以阻塞的方式执行计算任务，并调用<code>completion</code> 返回结果。</p><p>进一步分析这段代码中各个方法，可以发现 <code>main</code> 和<code>foo</code> 中的并发任务派发其实是一种函数间的无条件 “跳转”行为。虽然，<code>main</code> 和 <code>foo</code>都会立即将控制流返回至调用者，但是它们各自生成了新的并发任务。这些并发任务并不知道自己从哪里来，它们的初始调用不存在于其所属线程的调用栈中，其生命周期也与调用者的作用域完全无关。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-02.png?x-oss-process=image/resize,w_800" /></p><p>这样的非结构化并发不仅使得代码的控制流变得非常复杂，而且还会带来了一个致命的后果：<strong>由于和调用者具有不同的调用栈，因此无法得知原始的调用者，进而无法以抛出的方式向上传递错误</strong>。</p><p>在非结构化并发的编程范式下，我们在调用任意一个方法，我们都会存在很多担忧：</p><ul><li>方法是否会产生一个后台任务？</li><li>方法虽然返回了，它所产生的后台任务是否仍然在运行？什么时候完成？其又会产生什么行为？</li><li>作为调用者，应该在哪里处理回调？如何处理回调？</li><li>是否保持这个方法用到的资源？后台任务是否会自动持有这些资源？还是要手动释放资源？</li><li>后台任务是否可以被管理？如果取消这些后台任务？</li><li>后台任务时候会产生其他后台任务？这些任务是否可以被正确管理？当任务取消时，二次派发的任务是否也会被取消？</li></ul><p>这些问题都是非结构化并发可能存在的问题，而结构化并发正是为了解决这些问题而提出的。</p><h2 id="结构化并发">结构化并发</h2><p>那么，到底什么是结构化并发呢？结构化并发的核心是<strong>在并发模型下，也要保证控制流的单一入口和单一出口</strong>。程序可以产生多个控制流来实现并发，但是所有并发控制流在出口时都应该处于完成或取消状态，控制流最终在出口处完成合并。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-03.png?x-oss-process=image/resize,w_800" /></p><p>在结构化并发的编程范式下，<code>foo</code>方法将所产生的并发控制流最终都会收束至 <code>foo</code>方法中，<code>main</code>方法也是如此，实现了真正的自包含。此时，我们调用黑盒方法，能够确信即使方法会产生额外的并发任务，控制流最终也会回归到方法调用的位置，一切尽在掌握之中！</p><h1 id="通用实现模式">通用实现模式</h1><h2 id="整体技术栈">整体技术栈</h2><p>大多数情况下，结构化并发的实现技术栈如下图所示。从上层到底层可以分为五个部分，分别是：</p><ul><li>作用域（Scope）</li><li>异步函数（Async function）</li><li>协程（Coroutine）</li><li>计算续体（Continuation）</li><li>内核态线程（Kernel Thread）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-08.png?x-oss-process=image/resize,w_800" /></p><h2 id="作用域">作用域</h2><p>结构化编程是以 <strong>代码块（Code Block）</strong>为基本要素进行组织的，而结构化并发则是以<strong>作用域（Scope）</strong>为基本要素进行组织的。在不同的编程语言或技术框架中，对于作用域的命名所有不同，如：Kotlin称为 <code>Scope</code>，Swift 称为 <code>Task</code>，Python trio 称为<code>nursery</code>，C libdll 称为 <code>bundle</code>。</p><p>类似于块语法用于标注结构化编程中的代码逻辑块，作用域则用于标注并发操作的执行范围。下图所示，为作用域标识并发操作作用域的示意图。另外，作用域之间的关系只有包含和并列关系，而没有部分重叠关系，这一点与块语法规则相同。这使得作用域之间的关系变得非常清晰，而易于管理。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-04.png?x-oss-process=image/resize,w_800" /></p><p>在基于作用域的实现模式下，很多并发问题变得简单很多，比如：</p><ul><li>对于数据交换：以作用域为中心进行数据交互和传递，避免多线程数据操作导致问题。</li><li>对于返回值/异常传递：以作用域构成的关系链进行传递，类似于 UI事件传递。</li><li>对于异步取消：以作用域为粒度，取消其所包含的异步任务以及子作用域，从而递归取消所有异步任务。</li></ul><h2 id="异步函数">异步函数</h2><p>很多编程语言都支持了异步函数，为了与同步函数进行区分，基本都提供了特定的关键词来进行声明或调用，比如：<code>async</code>/<code>await</code>，<code>suspend</code>、<code>yield</code>/<code>resume</code>等。通过异步函数，我们可以通过同步调用的方式来编写代码，从而避免出现低于回调，进而提高代码的可读性。</p><p>如果编程语言只提供了异步函数，而不支持作用域，事实上也能够避免内部异步任务生命周期超出外部调用方法声明周期，因为异步函数的调用是通过以阻塞式的方式执行的。</p><p>相比而言，作用域的作用则在于管理多任务并发执行，解决多任务取消，值/异常传递等问题，这些是异步函数所无法解决的。</p><h2 id="协程">协程</h2><p>对于并发任务本身，其运算调度则由线程来支持。但是在高并发的场景下，基于传统意义上的线程池可能会面临性能瓶颈，如：线程爆炸、线程切换等。</p><p>为了解决性能和效率问题，大部分支持结构化并发的编程语言都以<strong>协程（Coroutine）</strong>作为运算调度的最小单元。那么到底什么是协程？协程本质上就是<strong>用户态线程</strong>，关于协程的进一步介绍可以阅读我之前写过的一篇博客——<ahref="http://chuquan.me/2021/05/05/getting-to-know-coroutine/">《初识协程》</a>。</p><p>我们知道操作系统线程模型主要有 3种，如下图所示。其中，纯用户态线程模型是早期单核 CPU的产物，纯内核态线程模式是多核 CPU下相对高效的模型。现代操作系统普遍采用的是组合式线程模型，支持提供远超CPU核心数量的用户态线程池。用户态线程的切换不涉及线程资源（包括寄存器、栈指针、栈内存等）切换，因此性能开销相对较小。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-user-kernel-thread.png?x-oss-process=image/resize,w_800" /></p><p>在传统的同步编程模式下，我们始终维护一个线性的调用栈，而在基于作用域和协程实现的并发编程模式下，我们可以维护一个树形的调用栈，如下图所示。基于树形调用栈，我们可以有效记录父子并发任务之间的调用关系，便于问题定位与追踪。注意，协程可以根据是否基于调用栈实现，分为有栈协程和无栈协程，这里我们以有栈协程为例，介绍结构化并发的优势。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-05.png?x-oss-process=image/resize,w_800" /></p><h2 id="计算续体">计算续体</h2><p>在代码层面，异步函数之后的代码是怎么实现等待异步函数执行完成之后再执行的呢？试想一下如下这段伪代码，为什么<code>print result</code> 会等待异步函数 <code>asyncOperation</code>完成之后才会执行的呢？怎么做到的？</p><pre><code>val result = await asyncOperation()print result</code></pre><p>事实上，这样要归功于<strong>计算续体（Continuation）</strong>。知道回调函数的人很多，但是知道计算续体的人并不多。<strong>当一个计算过程在中间被打断，其剩余部分可以使用一个对象进行表示</strong>，这个对象就是计算续体。当然，操作系统暂停一个线程时保存的那些数据快照，也可以看成是一个计算续体。基于计算续体，我们就能实现从上次中断的地方继续执行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-06.png?x-oss-process=image/resize,w_800" /></p><p>既然可以利用续体来等待异步操作执行完成，那么执行过程中运行时系统是如何选择哪些部分作为续体呢？对此，大多数编程语言会提供相关的关键词进行修饰，最常见的就是<code>async</code> 和 <code>await</code>。一般 <code>async</code>用于声明一个异步函数，<code>await</code>用于挂起（执行）一个异步函数。事实上，计算续体就是异步函数的底层实现技术。</p><p>当使用 <code>await</code> 调用一个异步函数时，那么编译器会<strong>将后续部分的代码转换成续体，当异步任务执行完毕之后，再将值传递至续体中继续执行，有点类似于方法回调</strong>。</p><p>在不同的编程语言中，计算续体的表示也有所不同。Kotlin 和 Swift 使用<code>Continuation</code> 表示，Lua 使用 <code>Coroutine Object</code>表示，JavaScript 使用 <code>Generator</code> 表示，Dart 使用<code>Async Generator</code> 表示。</p><h3 id="续体与栈帧">续体与栈帧</h3><p>事实上，计算续体与函数栈帧有着非常紧密的关系，前者是保存和恢复栈帧的一种机制。</p><p>在函数调用时，每个函数都会创建一个栈帧，其包含函数的局部变量、参数以及返回地址等信息。栈帧被存放在进程空间的栈区，当函数返回时，对应的栈帧会从栈中弹出，程序恢复到调用该函数的地方。</p><p>计算续体则是将 <strong>当前栈帧</strong> 以及<strong>程序计算器</strong>等信息保存至一个对象中，然后将该对象传递给一个续体函数。续体函数可以在需要时将保存的状态恢复，从而继续执行程序。</p><p>因此，从运行时层面看，计算续体就是当前函数的栈帧与现场状态；从代码层面看，计算续体就是等待异步操作完成的后续代码。</p><h3 id="cps-变换">CPS 变换</h3><p>提到计算续体，我们就不得不提一下 <strong>CPS变换（Continuation-Passing-Style Transformation）</strong>。</p><p>CPS 变换本质上就是<strong>将等待执行的代码转换成一个函数，计算续体作为函数的参数，参数名通常命名成<code>Continuation</code></strong>。</p><p>下面，我们以 Swift 为例进行介绍。假如，我们有一个旧版<code>oldLoad</code>方法，通过闭包进行异步回调。此时，我们希望设计基于异步函数的新版<code>newLoad</code> 方法，但是内部仍然使用旧版 <code>oldLoad</code>方法进行复用。在这种场景下，我们就可以利用 CPS 变换来实现预期目标。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 旧版方法</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">oldLoad</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ([<span class="type">String</span>]<span class="operator">?</span>, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"># 新版方法</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">newLoad</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withUnsafeThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        oldLoad &#123; values, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> values <span class="operator">=</span> values &#123;</span><br><span class="line">                continuation.resume(returing: values)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                continuation.resume(throwing: error)   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assertFailure(<span class="string">&quot;both parameters are nil&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示，当我们使用新版 <code>newLoad</code>方法时，等待异步执行的代码被封装成了一个函数，函数的参数是一个<code>Continuation</code>。我们可以根据不同的情况向<code>Continuation</code>传递值或错误，从而让等待异步执行的代码继续执行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-07.png?x-oss-process=image/resize,w_800" /></p><p>事实上，Kotlin 协程就是通过 CPS转换实现的，其在编译期间对调用挂起函数的上下文进行拆分，完成 CPS转换。这也是为什么 Kotlin 可以不用修改 VM 或 OS就能够支持协程的原因。</p><h1 id="并发调度模型">并发调度模型</h1><p>通过上一节我们知道了结构化并发所涉及的各种技术。下面，我们来通过一段Swift 代码，介绍一下并发任务的调度模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">save</span>(<span class="keyword">_</span> <span class="params">contents</span>: [<span class="type">Contents</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">ID</span>] &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handle</span>(<span class="keyword">_</span> <span class="params">contents</span>: [<span class="type">Content</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ids <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> save(contents)</span><br><span class="line">    <span class="keyword">for</span> (id, content) <span class="keyword">in</span> <span class="built_in">zip</span>(ids, contents) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(id)</span>: <span class="subst">\(content)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设一个线程调用了一个 <code>handle</code>方法。在这个阶段，最近的堆栈将是 <code>handle</code>。当<code>handle</code> 遇到内部的 <code>await</code>关键词修饰的异步操作时，运行时会将 <code>handle</code>方法的计算续体存储至堆中，从而等待异步操作完成。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-09.png?x-oss-process=image/resize,w_800" /></p><p>当运行时发现存在空闲的线程时，则将异步操作 <code>save</code>加入对应线程的栈中并开始执行。但是 <code>save</code> 方法内部又存在异步I/O 操作，因此 <code>save</code>方法的计算续体又会被存储至堆中，从而等待 I/O 操作完成。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-10.png?x-oss-process=image/resize,w_800" /></p><p>在等待 I/O操作的过程中，线程会被让出，从而允许其他任务进行复用。下图中，运行时会将<code>otherWork1</code> 方法加入线程并执行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-11.png?x-oss-process=image/resize,w_800" /></p><p>当 <code>save</code> 所等待的 I/O操作完成之后，运行时会寻找空闲的线程，并将 <code>save</code>的计算续体加入栈中并执行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-12.png?x-oss-process=image/resize,w_800" /></p><p>当 <code>save</code> 执行完毕，运行时会将与 <code>save</code>计算续体关联等待的 <code>handle</code>续体取出，选择一个空闲的线程来执行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-13.png?x-oss-process=image/resize,w_800" /></p><p>在 <code>handle</code> 计算续体执行过程中，会调用同步方法如<code>zip</code>，那么栈上将会正常加入 <code>zip</code> 的栈帧。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-14.png?x-oss-process=image/resize,w_800" /></p><p><code>zip</code> 执行完毕之后，对应的栈帧出栈，继续执行<code>hanle</code> 计算续体。由于这里是一个 <code>for</code>循环，<code>zip</code>栈帧的入栈和出栈会循环往复多次。最终，<code>handle</code>计算续体也执行完毕。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-15.png?x-oss-process=image/resize,w_800" /></p><!--# 应用--><!--最后，我们来举一个例子看看不同编程语言是如何使用结构化并发来解决并发问题的。假如，我们需要一张图片来显示头像，图片有两个备选分别是 imageA 和imageB，其中 imageA 被分割成了两部分：imageA-1 和imageA-2。当 imageA-1 和 imageA-2 同时下载完成后才能使用。此时，我们需要构造三个下载任务，只要有一个完整的图片下载成功，就取消其他下载任务。--><!--下面，我们来分别看一下 Kotlin 和 Swift 可以如何使用结构化合并解决这个问题的。--><!--## Kotlin 结构化并发--><!--```kotlin--><!--import kotlinx.coroutines.*--><!--fun downloadImage(imageName: String): String {--><!--    // 模拟下载过程，打印下载状态以及返回图片名称--><!--    println("开始下载 $imageName")--><!--    Thread.sleep(1000)--><!--    println("完成下载 $imageName")--><!--    return imageName--><!--}--><!--suspend fun downloadImageA(): String {--><!--    val imageA1 = async { downloadImage("imageA-1") }--><!--    val imageA2 = async { downloadImage("imageA-2") }--><!--    return "${imageA1.await()},${imageA2.await()}"--><!--}--><!--suspend fun downloadImageB(): String {--><!--    return async { downloadImage("imageB") }.await()--><!--}--><!--fun main() = runBlocking<Unit> {--><!--    // 创建一个父级 CoroutineScope--><!--    coroutineScope {--><!--        // 在父级 CoroutineScope 内创建一个新的 CoroutineScope，并将 downloadImageA 协程放在其中，启动 imageA 任务。--><!--        val scopeForImageA = CoroutineScope(coroutineContext)--><!--        val imageAJob = scopeForImageA.launch { downloadImageA() }--><!--        // 在父级 CoroutineScope 内启动 imageB 任务--><!--        val imageBJob = launch { downloadImage("imageB") }--><!--        // 等待 imageA 和 imageB 中有一个完成--><!--        val downloadedImage = select<String> {--><!--            imageAJob.onJoin {--><!--                imageBJob.cancel()--><!--            }--><!--            imageBJob.onJoin {--><!--                scopeForImageA.cancel()--><!--            }--><!--        }--><!--        // 输出完成的图片--><!--        println("成功下载：$downloadedImage")--><!--    }--><!--}--><!--```--><h1 id="总结">总结</h1><p>本文通过 GOTO有害论引出编程历史中结构化编程的演化。以结构化编程作为类比，介绍了结构化并发的核心观点，以及结构化并发的设计理念。结构化并发主要包括作用域、异步函数、计算续体、协程等技术，此外还需要运行时系统的调度，才能最终实现理想的结构化并发。</p><p>关于高级编程语言中结构化并发的实践，后续我们将继续在其他文章中进行讨论。目前原生支持结构化并发的编程语言并不多，幸运的是移动端开发的编程语言Kotlin、Swift是支持的，后面我们会研究一下这两者对于结构化并发的实现。另外，有时间的话，我们也会介绍一些结构化并发的辅助框架，比如：trio、libdll等，进而加深对于结构化并发的理解。</p><h1 id="参考">参考</h1><ol type="1"><li><ahref="https://en.wikipedia.org/wiki/Continuation">Continuation</a></li><li><ahref="https://en.wikipedia.org/wiki/Structured_concurrency">Structuredconcurrency</a></li><li><ahref="https://en.wikipedia.org/wiki/Structured_programming">Structuredprogramming</a></li><li><a href="https://pic.plover.com/knuth-GOTO.pdf">StructuredProgramming with go to Statements</a></li><li><a href="http://jacques.rouillard.org/A_l_epoch/goto.pdf">Go ToStatement Considered Harmful</a></li><li><a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD249.PDF">Notes onstructured programming</a></li><li><ahref="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Noteson structured concurrency, or: Go statement considered harmful</a></li><li><a href="https://250bpm.com/blog:71/index.html">StructuredConcurrency</a></li><li><a href="https://250bpm.com/blog:124/index.html">StructuredConcurrency in High-level Languages</a></li><li><ahref="https://archive.fosdem.org/2019/schedule/event/structured_concurrency/">StructuredConcurrency Finding our way out of callback hell</a></li><li><ahref="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">Somethoughts on asynchronous API design in a post-async/await world</a></li><li><ahref="https://trio.discourse.group/t/structured-concurrency-resources/21">Structuredconcurrency resources</a></li><li><ahref="https://trio.discourse.group/t/structured-concurrency-kickoff/55">StructuredConcurrency Kickoff</a></li><li><ahref="https://elizarov.medium.com/structured-concurrency-722d765aa952">Structuredconcurrency</a></li><li><a href="https://www.youtube.com/watch?v=_hfBv0a09Jc">KotlinConf2017 - Introduction to Coroutines by Roman Elizarov</a></li><li><ahref="https://gist.github.com/belm0/4c6d11f47ccd31a231cde04616d6bb22">Structuredconcurrency and Lua(part1)</a></li><li><ahref="https://gist.github.com/belm0/abbe9acb832eafa10dcbfd2b26eb74fc">Structuredconcurrency and Lua(part2)</a></li><li><ahref="https://gist.github.com/belm0/20bc069ca676fcfc591f29930069f788">Structuredconcurrency and Lua(part2)</a></li><li><ahref="https://developer.apple.com/videos/play/wwdc2021/10134/">Explorestructured concurrency in Swift</a></li><li><ahref="https://developer.apple.com/videos/play/wwdc2021/10254/">Swiftconcurrency: Behind the scenes</a></li><li>《swift 异步与并发》</li><li><ahref="https://aisia.moe/2018/02/08/kotlin-coroutine-kepa/">Kotlin协程 -先入个门吧</a></li><li><ahref="https://www.kotlincn.net/docs/reference/coroutines/basics.html">Kotlin协程</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/structured-concurrency-logo.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="异步与并发" scheme="http://chuquan.me/categories/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="协程" scheme="http://chuquan.me/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="作用域" scheme="http://chuquan.me/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    <category term="计算续体" scheme="http://chuquan.me/tags/%E8%AE%A1%E7%AE%97%E7%BB%AD%E4%BD%93/"/>
    
    <category term="异步函数" scheme="http://chuquan.me/tags/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    
    <category term="async/await" scheme="http://chuquan.me/tags/async-await/"/>
    
  </entry>
  
</feed>
