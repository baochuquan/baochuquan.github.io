<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2019-08-21T15:54:17.812Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 网络——NSURLSession</title>
    <link href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/"/>
    <id>http://chuquan.me/2019/07/21/ios-network-nsurlsession/</id>
    <published>2019-07-21T15:45:17.000Z</published>
    <updated>2019-08-21T15:54:17.812Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司针对刚入职的应届毕业生开展了一个的“新牛计划”，目的是让他们能够在一个月的时间内从零基础成长为 iOS 开发新手。</p><p>在这个过程中，我们需要承担讲师的角色。因此，我们对 iOS 开发的知识体系进行了划分，而我则负责讲解其中的 GCD 和网络相关部分。为此，我也算是学习了一下 iOS<br>开发所涉及到的一些网络知识，也学习了一些开源框架，包括：AFNetworking、YTKNetwork、CocoaAsyncSocket。这里，我首先对 NSURLSession 做一些相关总结。后续，将陆续贴出相关开源框架的学习心得。</p><h1 id="NSURLSession-概述"><a href="#NSURLSession-概述" class="headerlink" title="NSURLSession 概述"></a>NSURLSession 概述</h1><p>WWDC 2013，苹果对基于 <code>NSURLConnection</code> 的 Foundation URL 加载系统进行了重构，推出了新一代基于 <code>NSURLSession</code> 的 Foundation URL 加载系统，并将其首先应用在了 iOS 7 和 Mac OS X 10.9 Mavericks 系统之中。</p><h1 id="NSURLSession-架构"><a href="#NSURLSession-架构" class="headerlink" title="NSURLSession 架构"></a>NSURLSession 架构</h1><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsession-overview.png?x-oss-process=image/resize,w_600" alt=""></div><p><code>NSURLSession</code> 这个名字，实际上是指代 Foundation 框架的 URL 加载系统中一些列相关的类和协议。上图所示为 <code>NSURLSession</code> 的系统架构图，主要由三个类构成：</p><ul><li><strong><code>NSURLSession</code></strong><ul><li>负责请求/响应的关键对象，使用 <code>NSURLSessionConfiguration</code> 配置对象进行创建。</li><li>在请求/响应的执行过程中调用 <code>NSURLSessionTaskDelegate</code> 所定义的各种代理方法。</li></ul></li><li><strong><code>NSURLSessionConfiguration</code></strong><ul><li>用于对 <code>NSURLSession</code> 对象进行初始化，可以配置 <strong>可用网络</strong>、<strong>Cookie</strong>、<strong>安全性</strong>、<strong>缓存策略</strong>、<strong>自定义协议</strong>、<strong>启动事件</strong> 等选项，以及用于移动设备优化的相关选项。</li><li>几乎可以配置任何选项。</li></ul></li><li><strong><code>NSURLSessionTask</code></strong><ul><li>一个抽象类，其子类可以创建不同类型的任务（Task），如：下载、上传、获取数据（如：JSON 或 XML）。</li><li>在特定 URL Session 中执行。</li></ul></li></ul><p>结合上述系统结构图，我们可以将 <code>NSURLSession</code> 中的类分为以下 6 种（如下图所示）：</p><ul><li><strong>URL 加载</strong>（URL Loading）</li><li><strong>配置管理</strong>（Configuration Management）</li><li><strong>缓存管理</strong>（Cache Policy）</li><li><strong>Cookie 存储</strong>（Cookie Storage）</li><li><strong>认证和证书</strong>（Authentication and Credentials）</li><li><strong>协议支持</strong>（Protocol Support）</li></ul><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/url-loading-system-classes.png?x-oss-process=image/resize,w_600" alt=""></div><p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据 <strong>缓存策略（Cache Policy）</strong> 以及 <strong>可用性（availability）</strong> 的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应，以便将来的请求可以使用。</p><p>在一个请求被发送到服务器过程中，服务器可能会发出 <strong>鉴权查询（Authorization Challenge）</strong>，这可以由共享的 Cookie 或 <strong>证书存储（Credential Storage）</strong> 来自动响应，或者由被委托对象来响应。此外，发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要时改变其加载行为。</p><p>下面我们依次来详细介绍 URL 加载系统中的 3 个主要类： <code>NSURLSessionTask</code>、<code>NSURLSession</code>、<code>NSURLSessonConfiguration</code>。在 <code>NSURLSessionConfiguration</code> 中，我们将对缓存策略、Cookie 存储、自定义协议等内容稍作介绍。</p><h2 id="NSURLSessionTask"><a href="#NSURLSessionTask" class="headerlink" title="NSURLSessionTask"></a>NSURLSessionTask</h2><p><code>NSURLSessionTask</code> 是一个抽象类，其包含如下 3 个实体子类。这 3 个子类封装了 3 个最基本的网络任务：<strong>获取数据</strong>（如：JSON 或 XML）、<strong>上传文件</strong>、<strong>下载文件</strong>。</p><ul><li><code>NSURLSessionDataTask</code></li><li><code>NSURLSessionUploadTask</code></li><li><code>NSURLSessionDownloadTask</code></li></ul><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-class.png?x-oss-process=image/resize,w_600" alt=""></div><p>上图所示为这些类之间的继承关系。对于 <code>NSURLSessionDataTask</code>，服务器会有响应数据；而对于上传请求，服务器也会有响应数据，所以 <code>NSURLSessionUploadTask</code> 继承自 <code>NSURLSessionDataTask</code>。<code>NSURLSessionDownloadTask</code> 完成时，会带回已下载文件的一个临时的文件路径。</p><p>关于 <code>NSURLSessionTask</code> 的数据返回方式，主要有两种方式：</p><ul><li><strong><code>completionHandler</code> 回调</strong></li><li><strong><code>NSURLSessionDelegate</code> 代理</strong></li></ul><p>通过 <code>completionHandler</code> 回调将会创建一个隐式的代理（delegate），从而替代该 Task 原来的代理 —— Session。</p><p>对于需要 override 原有 Session Task 的代理的默认行为的情况，我们需要使用不带 <code>completionHandler</code> 版本。</p><p>需要注意的是，<code>NSURLSessionTask</code> 及其子类都有着各自的代理协议，它们之间也存在着如下图所示的继承关系。</p><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-delegate.png?x-oss-process=image/resize,w_600" alt=""></div><ul><li><code>NSURLSessionDelegate</code>：定义了网络请求最基础的代理方法。作为所有代理的基类。</li><li><code>NSURLSessionTaskDelegate</code>：定义了网络请求任务相关的代理方法。</li><li><code>NSURLSessionDownloadDelegate</code>：定义了下载任务相关的代理方法，如：下载进度等</li><li><code>NSURLSessionDataDelegate</code>：定义了普通数据任务和上传任务相关的代理方法。</li></ul><p>下面简要介绍一下这三个子类。</p><h3 id="NSURLSessionDataTask"><a href="#NSURLSessionDataTask" class="headerlink" title="NSURLSessionDataTask"></a>NSURLSessionDataTask</h3><p><code>NSURLSessionDataTask</code> 主要用于 <strong>读取服务端的简单数据</strong>，如：JSON、XML 数据。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSURL 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure></p><p><strong>CompletionHandler</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p><h3 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h3><p><code>NSURLSessionUploadTask</code> 主要用于 <strong>向服务器发送文件类型的数据</strong>。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建，上传时指定文件源</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建，上传时指定数据源   </span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure></p><p><strong>CompletionHandler</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p><h3 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h3><p><code>NSURLSessionDownloadTask</code> 主要用于 <strong>文件下载</strong>，它针对大文件的网络请求做了更多的处理，如：下载进度、断点续传等。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 NSURL 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url;    </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用之前已经下载的数据来创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData;</span><br></pre></td></tr></table></figure></p><p><strong>CompletionHandler</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p><h2 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h2><p><code>NSURLSession</code> 是负责请求/响应的关键对象，使用 <code>NSURLSessionConfiguration</code> 配置对象进行创建。</p><p><code>NSURLSession</code> 本身并不会进行请求，而是通过创建 Task 的形式来进行网络请求。同一个 <code>NSURLSession</code> 可以创建多个 Task，并且这些 Task 之间的 Cache 和 Cookie 是共享的。</p><p><code>NSURLSession</code> 在管理请求/响应的过程中会调用相关的代理方法。这些代理方法主要分两类：</p><ul><li><strong>Session 的委托对象实现的代理方法（<code>NSURLSessionDelegate</code> 定义的方法）</strong><ul><li>主要用于处理连接层问题，如：服务器信任、客户端证书认证、NTLM 和 Kerberos 协议等问题</li></ul></li><li><strong>Task 的委托对象实现的代理方法（<code>NSURLSessionTaskDelegate</code> 及其子协议定义的方法）</strong><ul><li>主要用于处理以网络请求为基础的问题，如：Basic，Digest，<strong>代理身份验证（Proxy Authentication）</strong> 等。</li></ul></li></ul><h2 id="NSURLSessionConfiguration"><a href="#NSURLSessionConfiguration" class="headerlink" title="NSURLSessionConfiguration"></a>NSURLSessionConfiguration</h2><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 进行初始化。</p><p><code>NSURLSessionConfiguration</code> 对以前 <code>NSMutableURLRequest</code> 所提供的网络请求层的设置选项进行了扩充，提供给开发者相当大的灵活性和控制权。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，可以发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何想要进行配置的选项。</p><p><code>NSURLSession</code> 在初始化时会把配置它的 <code>NSURLSessionConfiguration</code> 对象进行一次深拷贝，并保存到自己的 <code>configuration</code> 属性中，而且这个属性是只读的。也就是说，<code>configuration</code> 只在初始化时被读取一次，之后都是不会变化的。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>NSURLSessionConfiguration</code> 有三个类工厂方法：</p><ul><li><strong><code>+ defaultSessionConfiguration</code></strong><ul><li>返回一个标准的配置，具有共享 <code>NSHTTPCookieStorage</code>、共享 <code>NSURLCache</code>、共享 <code>NSURLCredentialStorage</code>。</li></ul></li><li><strong><code>+ ephemeralSessionConfiguration</code></strong><ul><li>返回一个预设的配置，该配置中不会对缓存、Cookie和证书进行持久性存储。这对于实现类似秘密浏览这种功能来说是很理想的。</li></ul></li><li><strong><code>+ backgroundSessionConfiguration:(NSString *)identifier</code></strong><ul><li>创建一个后台 Session。后台 Session 不同于普通 Session，后台 Session 可以在应用程序挂起、退出或崩溃的情况下进行上传/下载任务。初始化时指定的标识符，可用于向任何可能在进程外恢复后台传输的 <strong>守护进程（daemon）</strong> 提供上下文。</li></ul></li></ul><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p><code>NSURLSessionConfiguration</code> 拥有数十个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。</p><h4 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *HTTPAdditionalHeaders</span><br></pre></td></tr></table></figure><p><code>HTTPAdditionalHeaders</code> 为基于 configuration 的 Session 生成的所有 Task 中的 <code>NSRULRequest</code> 对象添加额外的请求头部字段。默认为空。</p><p><code>NSURLSession</code> 默认为 <code>NSURLRequest</code> 对象添加了如下请求头部字段：</p><ul><li><code>Authorization</code></li><li><code>Connection</code></li><li><code>Host</code></li><li><code>Proxy-Authenticate</code></li><li><code>Proxy-Authorization</code></li><li><code>WWW-Authenticate</code></li></ul><p>如果在 <code>HTTPAdditionalHeaders</code> 自定义的头部字段与 <code>NSURLRequest</code> 对象重复了，则优先使用 <code>NSURLRequest</code> 对象中的请求头部字段。</p><p>利用 <code>HTTPAddtionalHeaders</code> 可以添加如下这些请求头部字段：</p><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>User-Agent</code></li><li>…</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType</span><br></pre></td></tr></table></figure><p>指定网络传输类型。可以让操作系统快速响应，提高传输质量，延长电池寿命等。大多数应用程序都不需要设置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> allowsCellularAccess</span><br></pre></td></tr></table></figure><p>是否使用蜂窝网络。默认是 <code>YES</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForRequest</span><br></pre></td></tr></table></figure><p>指定请求的超时间隔。默认为 60s。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForResource</span><br></pre></td></tr></table></figure><p>指定资源的超时间隔。默认是7天。</p><h4 id="Cookie-策略"><a href="#Cookie-策略" class="headerlink" title="Cookie 策略"></a>Cookie 策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSHTTPCookieStorage</span> *HTTPCookieStorage;</span><br></pre></td></tr></table></figure><p>存储了 Session 所使用的 Cookie。默认情况下会使用 <code>NSHTTPCookieStorage</code> 的 <code>+ sharedHTTPCookieStorage</code> 单例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> HTTPShouldSetCookies;</span><br></pre></td></tr></table></figure><p>指定了请求是否应该使用 Session 存储的 Cookie，即 <code>HTTPCookieStorage</code> 属性的值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSHTTPCookieAcceptPolicy</span> HTTPCookieAcceptPolicy;</span><br></pre></td></tr></table></figure><p>决定了什么情况下 Session 应该接受从服务器发出的 Cookie。</p><h4 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSURLCredentialStorage</span> *URLCredentialStorage;</span><br></pre></td></tr></table></figure><p>存储了 Session 所使用的证书。默认情况下会使用 <code>NSURLCredentialStorage</code> 的 <code>+ sharedCredentialStorage</code> 单例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMaximumSupportedProtocol;</span><br><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMinimumSupportedProtocol;</span><br></pre></td></tr></table></figure><p>两者确定 Session 是否支持 SSL 协议。</p><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSURLCache</span> *URLCache;</span><br></pre></td></tr></table></figure><p>Session 使用的缓存。默认情况下会使用 <code>NSURLCache</code> 的 <code>+ sharedURLCache</code> 单例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestCachePolicy</span> requestCachePolicy;</span><br></pre></td></tr></table></figure><p>指定了一个请求的缓存响应应该在什么时候返回。</p><h4 id="后台传输"><a href="#后台传输" class="headerlink" title="后台传输"></a>后台传输</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *identifier</span><br></pre></td></tr></table></figure><p>仅当使用 <code>backgroundSessionConfigurationWithIdentifier:</code> 方法创建配置对象时，才会设置此属性的值。<code>identifier</code> 唯一标识 <strong>后台会话</strong> 对象。</p><p>如果应用程序在后台任务进行传输时终止，可以使用 <code>identifier</code> 在应用程序重新启动时，重新创建 <code>configuration</code> 和 <code>session</code> 对象与 之前传输进行关联。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> sessionSendsLaunchEvents;</span><br></pre></td></tr></table></figure><p>设置传输结束时是否应该在后台恢复或启动应用程序。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">getter</span>=isDiscretionary) <span class="built_in">BOOL</span> discretionary;</span><br></pre></td></tr></table></figure><p>设置后台 Task 是否可以由系统进行调度，从而获得最佳性能。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldUseExtendedBackgroundIdleMode;</span><br></pre></td></tr></table></figure><p>设置应用程序切换至后台时是否保持打开 TCP 连接。</p><h4 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;Class&gt; *protocolClasses;</span><br></pre></td></tr></table></figure><p>用来配置特定某个 Session 所使用的自定义协议（该协议是 <code>NSURLProtocol</code> 的子类）的数组。</p><h4 id="多路径-TCP"><a href="#多路径-TCP" class="headerlink" title="多路径 TCP"></a>多路径 TCP</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLSessionMultipathServiceType</span> multipathServiceType;</span><br></pre></td></tr></table></figure><p>指定通过 Wi-Fi 和 蜂窝网络传输数据的多路径 TCP 的连接策略。</p><h4 id="HTTP-策略与代理"><a href="#HTTP-策略与代理" class="headerlink" title="HTTP 策略与代理"></a>HTTP 策略与代理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> HTTPMaximumConnectionsPerHost;</span><br></pre></td></tr></table></figure><p>用于限制连接到特定主机的数量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> HTTPShouldUsePipelining;</span><br></pre></td></tr></table></figure><p>用于开启 HTTP 流水线（HTTP pipelining），可以显着减少请求的加载时间，但是由于没有被服务器广泛支持，默认是 <code>NO</code> 的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *connectionProxyDictionary;</span><br></pre></td></tr></table></figure><p>指定了 Session 连接中的代理服务器</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 <code>NSURLConnection</code> 进行深思熟虑后的一个自然而然的进化。尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 <code>NSURLSession</code> 仍然是实现更高级别网络功能的一个强大的基础框架。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc" target="_blank" rel="noopener">URL Loading System</a></li><li><a href="https://juejin.im/post/5a69f8366fb9a01cb42c90bc" target="_blank" rel="noopener">URL Loading System 概览</a></li><li><a href="https://juejin.im/entry/58aacabcac502e006973ce03" target="_blank" rel="noopener">iOS NSURLSession 详解</a></li><li><a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started" target="_blank" rel="noopener">URLSession Tutorial: Getting Started</a></li><li><a href="https://developer.apple.com/documentation/foundation/nsmutableurlrequest?language=objc" target="_blank" rel="noopener">NSMutableURLRequest</a></li><li><a href="https://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a></li><li><a href="https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/" target="_blank" rel="noopener">From NSURLConnection to NSURLSession</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司针对刚入职的应届毕业生开展了一个的“新牛计划”，目的是让他们能够在一个月的时间内从零基础成长为 iOS 开发新手。&lt;/p&gt;
&lt;p&gt;在这个过程中，我们需要承担讲师的角色。因此，我们对 iOS 开发的知识体系进行了划分，而我则负责讲解其中的 GCD 和网络相关部分。为此
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="NSURLSession" scheme="http://chuquan.me/tags/NSURLSession/"/>
    
  </entry>
  
  <entry>
    <title>澳洲自驾游</title>
    <link href="http://chuquan.me/2019/07/11/australia-from-sydeny-to-brisbane/"/>
    <id>http://chuquan.me/2019/07/11/australia-from-sydeny-to-brisbane/</id>
    <published>2019-07-11T13:21:36.000Z</published>
    <updated>2019-08-17T04:03:19.383Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight216.jpg?x-oss-process=image/resize,w_600" alt=""></div><a id="more"></a><p>今年的年度旅游，我们部门分成了多个团体自行安排旅游。我们 8 个人（@社会瑞哥、@海侠、@捧鹏、@拢龙、@佳欣、@底迪、@雪洁、@我）组成了一个澳洲团（自诩：卢瑟天团），来了一次自驾游：从悉尼到布里斯班。</p><p>这次行程基本都是 @佳欣 安排，我差不多全程属于放空状态，有时甚至连自己在哪里都不知道。8 人自驾游租了两辆 SUV，司机分别是 @社会瑞哥、@捧鹏。</p><p>出游前，我就计划这次旅行尝试一下做旅拍。为此，我刷了一些 YouTube 上的大神们的作品，如：KOLD。大神们的作品对我这种菜鸟新手来说难度太高，实际操作起来非常困难。于是我又刷了一些入门级拍摄技巧的视频教程，如：HeyDrones。为此，我还租了GoPro 7 Hero Black 运动相机和 Mavic Air 无人机。</p><p>关于 GoPro 和无人机的使用体验。我全程基本都是在用 GoPro 进行视频拍摄，性价比特别高。无人机使用相对就少了很多，首先续航时间短，只有20分钟，实际电池电量剩 20% 时就提示自动返航了。另外，再加上天气、限飞、周围环境等因素，体验并不是很好。不过，无人机拍出来的效果的确逼格提升了不少。所以，还是逃不出“真香”定理，不出意外，以后旅游我还会带上无人机。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>From 北京 to 深圳，From 深圳 to 悉尼。</p><p>在北京飞深圳的航班上，看到一团云挺好看，顺手拍了张照片。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight191.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>深圳机场的晚霞还是挺好看的。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight194.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>从深圳起飞，拍了张深圳上空照片（很难得的角度）。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight193.jpg?x-oss-process=image/resize,w_400" alt=""></p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>飞机上一觉醒来便是凌晨，转头便看到了日月同辉前的一幕美景。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight197.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>抵达悉尼机场，第一个任务便是租车。然后便是前往悉尼歌剧院。可能是大家很疲惫吧，只是在歌剧院脚下拍了些照片，没有人提出去对岸拍它的全景。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight199.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight200.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_3898.JPG?x-oss-process=image/resize,w_600" alt=""></p><p>然后就是逛了下歌剧院旁边的皇家植物园。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight202.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>汉堡王之后，就驱车两小时去山里找我们的爱彼迎民宿。刚进入别墅时，我们所有人都是刘姥姥进大观园的状态。别墅建在山坡上，一种后战争（Post War）风格的建筑，自带车库，露天大阳台（配有烧烤架），二层有小花园，三层有大花园。@地址：22 Bildera Place, Grays Point, 新南威尔士州 2232。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight207.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight206.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight209.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>旅行的开始总是兴奋的。是晚，便来了一次自制火锅。晚餐过后便是拍照时间，山寨了一次“我爱我家”的经典场景。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_4305.JPG?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>前一晚，玩桌游差不多到凌晨 2：00。这一天是预料中的晚起，下午出门去悉尼大学。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight219.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight217.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight214.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>差不多逛到一般吧，@拢龙 便叫我去打球。商场的车库后面，有一个街头篮球场。和当地人来了次比赛，5 VS 6，对方 3 男 3 女。比赛以一个女生膝盖受伤而告终。不过不得不感慨，澳洲人的身体素质是真好，这个场地就有两人能扣篮…</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_3951.JPG?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>这天开始挪地方，先是驱车去了猎人谷参观了当地历史最悠久的酒庄 Audery Wikinson。可惜季节不是很好，并没有看到满山的葡萄，不过惊喜的是，遇到了野生的袋鼠。</p><p>参观结束便是驱车前往预订的一个位于富人社区的爱彼迎民宿，自带泳池的那种。@地址：68 O’Shea Circuit，赛斯诺克，新南威尔士州 2325。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/FullSizeRender.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>按计划前往斯蒂芬斯港转了一圈。当晚入住一个平民民宿。@地址：1315 Lemon Tree Passage Road，Lemon。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight243.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight220.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight226.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>自驾 5 小时，抵达汽车旅馆。旅馆也有泳池，可惜天气太冷，有没尝试。@地址：阿曲亚吉汽车旅馆 49 Park Beach Road，科夫斯港，2450。</p><p>Check In 之后，我和 @拢龙 便按计划去找篮球场打球。可惜当地的篮球馆很早就关门了。我们好不容易找到一个室外场，装了下逼，拍了些照。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight224.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>驱车三小时去拜伦湾，原本打算跳伞，然而下雨了…于是乎前往下一个目的地——拜伦角灯塔。这天是阴雨天，灯塔附近的风浪非常大，我们摆拍了一些照片后就离开了。</p><p>在拜伦湾小镇吃了个午饭后，我们就去酒店办理入住。@地址：发现假日酒店 399 Ewingsdale Road，拜伦湾，2481。</p><p>这个公园酒店很大，就如其名字一样，是一个大公园，内部有很多房车式的独栋小房子，就是游客的住所。</p><p>行李整顿完毕之后，闲逛了下公园，遇到一群小孩，拍了短视频。</p><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Videoleap-216A7632-23B2-4CF2-A02C-8B5E675A75B1.MOV" type="video/mov" controls="controls" width="60%" height="60%"></video></div><p>之后，我们又是去找篮球馆。我们找到一个高级篮球馆。这个篮球馆每周工作日晚上都会举行比赛，周六下午才对外开放。据我们了解，拜伦湾当地有十二支业余球队，每支球队都由少年、青年、老年不同年龄段的人组成。篮球水平在业余中属于比较高的水平，有不少能扣篮的人。至此，我们算是了解到了澳洲民间篮球的真实水平了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight233.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight234.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><p>前往布里斯班，中途经过黄金海岸。季节不适，风浪很大，稍作逗留便离开了。</p><p>然后前往市中心，入住了当地一家酒店。@地址：Hotel Grand Chancellor</p><p>当天晚上就是代购，各种买买买。</p><h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><p>驱车去龙伯考拉动物园，看了些动物表演，包括：飞禽、牧羊犬。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight231.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight232.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight230.jpg?x-oss-process=image/resize,w_800" alt=""></p><h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><p>From 布里斯班 to 广州，From 广州 to 北京。</p><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Videoleap-3169FC88-2225-42CC-B360-4EC21496D948.MOV" type="video/mov" controls="controls" width="60%" height="60%"></video></div><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight216.jpg?x-oss-process=image/resize,w_600&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="澳大利亚" scheme="http://chuquan.me/tags/%E6%BE%B3%E5%A4%A7%E5%88%A9%E4%BA%9A/"/>
    
      <category term="悉尼" scheme="http://chuquan.me/tags/%E6%82%89%E5%B0%BC/"/>
    
      <category term="布里斯班" scheme="http://chuquan.me/tags/%E5%B8%83%E9%87%8C%E6%96%AF%E7%8F%AD/"/>
    
      <category term="自驾游" scheme="http://chuquan.me/tags/%E8%87%AA%E9%A9%BE%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控(2)——卡顿</title>
    <link href="http://chuquan.me/2019/06/17/ios-performance-monitor-caton/"/>
    <id>http://chuquan.me/2019/06/17/ios-performance-monitor-caton/</id>
    <published>2019-06-16T16:35:07.000Z</published>
    <updated>2019-06-17T03:12:00.674Z</updated>
    
    <content type="html"><![CDATA[<p>前文 <a href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">iOS 性能监控(1)——CPU、Memory、FPS</a> 探讨了 iOS 中进行线上监控 CPU、Memory、FPS 等指标的原理以及具体实现方法。本文则继续探讨如何在 iOS 中进行线上监控卡顿的原理及实现。</p><h1 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h1><h2 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h2><p>那么为什么会出现卡顿呢？为了解释这个问题首先需要了解一下屏幕图像的显示原理。首先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 <strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 <strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" alt=""></p><p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容（如：视图的创建、布局计算、图片解码、文本绘制）提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_500" alt=""></p><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。事实上，iPhone 使用的就是双缓冲机制。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png?x-oss-process=image/resize,w_800" alt=""></p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" alt=""></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。当 CPU 和 GPU 计算量比较大时，一旦它们的完成时间错过了下一次 C-Sync 的到来（通常是 1000/6=16.67ms），这样就会出现显示屏还是之前帧的内容，这就是界面卡顿的原因。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios_frame_drop.png?x-oss-process=image/resize,w_500" alt=""></p><h2 id="FPS-卡顿监控方案"><a href="#FPS-卡顿监控方案" class="headerlink" title="FPS 卡顿监控方案"></a>FPS 卡顿监控方案</h2><p>FPS 卡顿监控方案的原理是 <strong>通过一段连续的 FPS 计算丢帧率来衡量当前页面绘制的质量</strong>。</p><p>具体实现方式可以通过 <a href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">iOS 性能监控(1)——CPU、Memory、FPS</a> 一文中的 FPS 监控方法进行 FPS 数据采集，然后处理数据。这里不做多余的介绍。</p><h2 id="主线程卡顿监控方案"><a href="#主线程卡顿监控方案" class="headerlink" title="主线程卡顿监控方案"></a>主线程卡顿监控方案</h2><p>主线程卡顿监控方案的原理是 <strong>通过子线程监控主线程的 RunLoop，判断两个状态区域之间的耗时是否达到一定阈值</strong>。因为主线程绝大部分计算或绘制任务都是以 RunLoop 为单位发生。单次 RunLoop 如果时长超过 16ms，就会导致 UI 体验的卡顿。</p><p>美团的移动端性能监控方案 Hertz 采用的就是这种方式。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-performance-monitor-caton01.png?x-oss-process=image/resize,w_500" alt=""></p><p>首先我们需要了解一下 RunLoop 的原理。</p><h3 id="RunLoop-定义"><a href="#RunLoop-定义" class="headerlink" title="RunLoop 定义"></a>RunLoop 定义</h3><p>RunLoop 是 iOS 事件响应与任务处理最核心的机制。当有持续的异步任务需求时，我们会创建一个独立的生命周期可控的线程。<strong>RunLoop 就是控制线程生命周期并接收事件进行处理的机制</strong>。</p><h3 id="RunLoop-机制"><a href="#RunLoop-机制" class="headerlink" title="RunLoop 机制"></a>RunLoop 机制</h3><p><strong>主线程（有 RunLoop 的线程）几乎所有函数都从以下六个函数之一的函数调起：</strong></p><ol><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</code><ul><li>CFRunloop is calling out to an abserver callback function</li><li>用于向外部报告 RunLoop 当前状态的改变，框架中很多机制都由 RunLoopObserver 触发，如：CAAnimation</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</code><ul><li>CFRunloop is calling out to a block</li><li>消息通知、非延迟的 perform、dispatch 调用、block 回调、KVO</li></ul></li><li><code>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</code><ul><li>CFRunloop is servicing the main dispatch queue</li><li>执行主队列上的任务</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</code><ul><li>CFRunloop is calling out to a timer callback function</li><li>基于定时器的延迟的 perfrom，dispatch 调用</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</code><ul><li>CFRunloop is calling out to a source 0 perform function</li><li>处理 App 内部事件、App自己负责管理（触发），如：<code>UIEvent</code>、<code>CFSocket</code>。普通函数调用，系统调用</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</code><ul><li>CFRunloop is calling out to a source 1 perform function</li><li>由 RunLoop 和内核管理，Mach port 驱动，如：<code>CFMachPort</code>、<code>CFMessagePort</code></li></ul></li></ol><h3 id="RunLoop-运行时"><a href="#RunLoop-运行时" class="headerlink" title="RunLoop 运行时"></a>RunLoop 运行时</h3><p>如下所示为 <code>CFRunLoop</code> 源码中的核心方法 <code>CFRunLoopRun</code> 简化后的主要逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">int32_t __CFRunLoopRun() &#123;</span><br><span class="line">    // 1. 通知 Observers：即将进入 RunLoop</span><br><span class="line">    __CFRunLoopDoObservers(KCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        // 2. 通知Observers：即将要处理 timer</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</span><br><span class="line">        // 3. 通知Observers：即将要处理 source</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        // 处理非延迟的主线程调用</span><br><span class="line">        __CFRunLoopDoBlocks();</span><br><span class="line">        // 处理 UIEvent 事件</span><br><span class="line">        __CFRunLoopDoSource0();</span><br><span class="line">    </span><br><span class="line">        // GCD dispatch main queue</span><br><span class="line">        CheckIfExistMessagesInMainDispatchQueue();</span><br><span class="line">    </span><br><span class="line">        // 4. 通知 Observers：即将进入休眠等待</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        // 等待内核mach_msg事件</span><br><span class="line">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</span><br><span class="line">        </span><br><span class="line">        // mach_msg_trap</span><br><span class="line">        // 休眠中 Zzz...</span><br><span class="line">        // Received mach_msg, wake up</span><br><span class="line">        </span><br><span class="line">        // 5. 通知 Observers：从休眠等待中醒来</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        if (wakeUpPort == timerPort) &#123;</span><br><span class="line">            // 处理因timer的唤醒</span><br><span class="line">            __CFRunLoopDoTimers();</span><br><span class="line">        &#125; else if (wakeUpPort == mainDispatchQueuePort) &#123;</span><br><span class="line">            // 处理异步方法唤醒，如：dispatch_async</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // UI 刷新，动画显示</span><br><span class="line">            __CFRunLoopDoSource1();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 再次确保是否有同步的方法需要调用</span><br><span class="line">        __CFRunLoopDoBlocks()</span><br><span class="line">    &#125; while(!stop &amp;&amp; !timeout);</span><br><span class="line">    </span><br><span class="line">    // 6. 通知 Observers：即将退出runloop</span><br><span class="line">    __CFRunLoopDoObservers(CFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RunLoop 在运行时一直在向外部报告当前状态的更新，其状态定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry ,           // 进入 loop</span><br><span class="line">    kCFRunLoopBeforeTimers ,    // 触发 Timer 回调</span><br><span class="line">    kCFRunLoopBeforeSources ,   // 触发 Source0 回调</span><br><span class="line">    kCFRunLoopBeforeWaiting ,   // 等待 mach_port 消息</span><br><span class="line">    kCFRunLoopAfterWaiting ,    // 接收 mach_port 消息</span><br><span class="line">    kCFRunLoopExit ,            // 退出 loop</span><br><span class="line">    kCFRunLoopAllActivities     // loop 所有状态改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 RunLoop 运行逻辑中，不难发现 NSRunLoop 调用方法主要在于两个状态区间：</p><ul><li><code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopBeforeWaiting</code> 之间</li><li><code>kCFRunLoopAfterWaiting</code> 之后</li></ul><p><strong>如果这两个时间内耗时太久而无法进入下一步，可以线程受阻。如果这个线程时主线程，表现出来就是出现了卡顿。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以通过 <code>CFRunLoopObserverRef</code> 实时获取 <code>NSRunLoop</code> 的状态。具体使用方法如下：</p><p>首先创建一个 <code>CFRunLoopObserverContext</code> 观察者 <code>observer</code>。然后将观察者 <code>observer</code> 添加到主线程 RunLoop 的 <code>kCFRunLoopCommonModes</code> 模式下进行观察。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerObserver &#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。为了让计算更精确，需要让子线程更及时的获知主线程 RunLoop 状态变化，<code>dispatch_semaphore_t</code> 是一个不错的选择。另外，卡顿需要覆盖多次连续短时间卡顿和单次长时间卡顿两种情景，所以判定条件也需要做适当优化。优化后的代码实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerObserver &#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    // 创建信号</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES) &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">            if (st != 0) &#123;</span><br><span class="line">                if (activity == kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    if (++timeoutCount &lt; 5)</span><br><span class="line">                        continue;</span><br><span class="line">                    </span><br><span class="line">                    NSLog(@&quot;好像有点儿卡哦&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    </span><br><span class="line">    // 记录状态值</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">    </span><br><span class="line">    // 发送信号</span><br><span class="line">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检测到卡顿时应该立刻获取卡顿的方法堆栈信息，并推送至服务端共开发者分析，从而解决卡顿问题。</p><p>获取堆栈信息的一种方法是：<strong>直接调用系统函数</strong>。这种方法的优点是 <strong>性能消耗小</strong>。缺点是 <strong>它只能够获取简单的信息，无法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限</strong>。</p><p>直接调用系统函数的主要思路是：用 <code>signal</code> 进行错误信息获取。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static int s_fatal_signals[] = &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);</span><br><span class="line"></span><br><span class="line">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class="line">    NSArray *exceptionArray = [exception callStackSymbols];     // 得到当前调用栈信息</span><br><span class="line">    NSString *exceptionReason = [exception reason];             // 非常重要，就是崩溃的原因</span><br><span class="line">    NSString *exceptionName = [exception name];                 // 异常类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SignalHandler(int code) &#123;</span><br><span class="line">    NSLog(@&quot;signal handler = %d&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitCrashReport() &#123;</span><br><span class="line">    // 系统错误信号捕获</span><br><span class="line">    for (int i = 0; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //oc 未捕获异常的捕获</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取堆栈信息的另一种方法是：<strong>直接使用 PLCrashReporter 第三方开源库</strong>。这种方法的优点是 <strong>能够定位到问题代码的具体位置，而且性能消耗也不大</strong>。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD     </span><br><span class="line">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">PLCrashReporter *reporter = [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line"></span><br><span class="line">// 获取数据</span><br><span class="line">NSData *lagData = [reporter generateLiveReport];</span><br><span class="line"></span><br><span class="line">// 转换成 PLCrashReport 对象</span><br><span class="line">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line"></span><br><span class="line">// 进行字符串格式化处理</span><br><span class="line">NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"></span><br><span class="line">// 将字符串上传服务器</span><br><span class="line">NSLog(@&quot;lag happen, detail below: \n %@&quot;,lagReportString);</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">计算机那些事(8)——图形图像渲染原理</a></li><li><a href="http://chuquan.me/2018/10/06/understand-ios-runloop/">Run Loop 原理详解</a></li><li><a href="https://wereadteam.github.io/2016/05/03/WeRead-Performance/" target="_blank" rel="noopener">微信读书 iOS 性能优化总结</a></li><li><a href="http://www.tanhao.me/code/151113.html/" target="_blank" rel="noopener">iOS 实时卡顿监控</a></li><li><a href="https://opensource.apple.com/source/CF/CF-1152.14/CFRunLoop.c.auto.html" target="_blank" rel="noopener">CFRunLoop.c</a></li><li><a href="https://juejin.im/post/5a94e9185188257a780dde61" target="_blank" rel="noopener">RunLoop刨根问底</a></li><li><a href="https://www.cnblogs.com/zy1987/p/4582466.html" target="_blank" rel="noopener">RunLoop 原理和核心机制</a></li><li><a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前文 &lt;a href=&quot;http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/&quot;&gt;iOS 性能监控(1)——CPU、Memory、FPS&lt;/a&gt; 探讨了 iOS 中进行线上监控 CPU、Memory
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="卡顿" scheme="http://chuquan.me/tags/%E5%8D%A1%E9%A1%BF/"/>
    
      <category term="性能监控" scheme="http://chuquan.me/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控(1)——CPU、Memory、FPS</title>
    <link href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/"/>
    <id>http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/</id>
    <published>2019-06-09T16:07:17.000Z</published>
    <updated>2019-06-09T16:09:01.759Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，在公司的 App 中集成了一个性能监视器，效果如下所示。在这个过程中，扒了一些性能监测开源框架的源码，并学习了其中的原理。本文就对此做一些简要的总结。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-performance-monitor.gif?x-oss-process=image/resize,w_400" alt=""></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通常情况下，App 的性能问题并不会导致 App 不可用，但是会潜在地影响用户体验。比如：CPU 占用率过高会导致电量消耗过快，手机发热等问题。为了能够主动、高效地发现性能问题，避免 App 质量进入无人监控的状态，我们需要对 App 的性能进行监控。目前，对 App 的性能监控，主要分为 <strong>线下</strong> 和 <strong>线上</strong> 两种监控维度。</p><h1 id="线下性能监控"><a href="#线下性能监控" class="headerlink" title="线下性能监控"></a>线下性能监控</h1><p>关于线下性能监控，Xcode 内置提供了一个性能分析工具 Instruments。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/xcode-instruments-overview.jpeg?x-oss-process=image/resize,w_600" alt=""></p><p>Instruments 集成了非常多的性能检测工具，如：Leaks 可以用来监控内存泄露问题；Energy Log 可以用来监控耗电量。下图所示为 Instruments 中包含的各种性能检测工具。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/xcode-instruments-tools.jpeg?x-oss-process=image/resize,w_600" alt=""></p><p>通常，我们会在提审前使用 Instruments 对 App 进行线下的性能分析。</p><h1 id="线上性能监控"><a href="#线上性能监控" class="headerlink" title="线上性能监控"></a>线上性能监控</h1><p>线上监控一般需要遵循两个原则：</p><ol><li>监控代码与业务代码解耦</li><li>采用性能消耗最小的性能监控方案</li></ol><p>线上性能监控，主要集中在对 CPU 使用率、内存、FPS 帧率等方面的监控。下面分别介绍其各自的监控方法及原理。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 占用率的采集原理其实很简单：<strong>App 作为进程运行时会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU 使用率的总和，就是当前 App 对 CPU 的占用率</strong>。</p><h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，XNU（X is not UNIX） 是 Darwin 的内核，一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，如文件操作和设备访问，都是由 BSD 层实现。</p><p>事实上，Mach 并不能识别 UNIX 中的所有进程，而是采用一种稍微不同的方式，使用了比进程更轻量级的概念：<strong>任务（Task）</strong>。经典的 UNIX 采用了自上而下的方式：最基本的对象是进程，然后进一步划分为一个或多个线程；Mach 则采用了自底向上的方式：最基本的单元是线程，一个或多个线程包含在一个任务中。</p><p><strong>线程</strong></p><ul><li>线程定义了 Mach 中最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据，其从设计上提供了调度所需要的大量信息。</li></ul><p><strong>任务</strong></p><ul><li>任务是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此，资源的共享实际上相当于允许对对应端口进行访问。</li></ul><p>严格来说，Mach 的任务并不是hi操作系统中所谓的进程，因为 Mach 作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。在 BSD 模型中，这两个概念有一对一的简单映射，每个 BSD 进程（即 OS X 进程）都在底层关联了一个 Mach 任务对象。实现这种映射的方法是指定一个透明的指针 <code>bsd_info</code>，Mach 对 <code>bsd_info</code> 完全无知。Mach 将内核也用任务表示（全局范围称为 <code>kernel_task</code>），尽管该任务没有对应的 PID，但可以想象 PID 为 0。</p><p>下图所示为权威著作《OS X Internal: A System Approach》中提供的 Mach OS X 中进程子系统组成的概念图。与 Mac OS X 类似，iOS 的线程技术也是基于 Mach 线程技术实现的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/mach-task-thread-system.png?x-oss-process=image/resize,w_800" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>上述提到线程表示的是底层的机器寄存器状态以及各种给调度统计数据。再来看 Mach 层中的 <code>thread_basic_info</code> 结构体的定义，其成员信息也证实了这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct thread_basic_info &#123;</span><br><span class="line">        time_value_t    user_time;      // 用户运行时长</span><br><span class="line">        time_value_t    system_time;    // 系统运行时长</span><br><span class="line">        integer_t       cpu_usage;      // CPU 使用率</span><br><span class="line">        policy_t        policy;         // 调度策略</span><br><span class="line">        integer_t       run_state;      // 运行状态</span><br><span class="line">        integer_t       flags;          // 各种标记</span><br><span class="line">        integer_t       suspend_count;  // 暂停线程的计数</span><br><span class="line">        integer_t       sleep_time;     // 休眠时间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>每个线程都有这个结构体，所以我们只需要定时去遍历每个线程，累加每个线程的 <code>cpu_usage</code> 字段的值，就可以得到当前 App 所在进程的 CPU 使用率。</p><p>如下所示为 <strong>CPU 占用率</strong> 的代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 获取 CPU 使用率</span><br><span class="line">+ (CGFloat)cpuUsageForApp &#123;</span><br><span class="line">    kern_return_t           kr;</span><br><span class="line">    thread_array_t          thread_list;</span><br><span class="line">    mach_msg_type_number_t  thread_count;</span><br><span class="line">    thread_info_data_t      thinfo;</span><br><span class="line">    mach_msg_type_number_t  thread_info_count;</span><br><span class="line">    thread_basic_info_t     basic_info_th;</span><br><span class="line"></span><br><span class="line">    // 根据当前 task 获取所有线程</span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    if (kr != KERN_SUCCESS)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    float total_cpu_usage = 0;</span><br><span class="line">    // 遍历所有线程</span><br><span class="line">    for (int i = 0; i &lt; thread_count; i++) &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        // 获取每一个线程信息</span><br><span class="line">        kr = thread_info(thread_list[i], THREAD_BASIC_INFO, (thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">        if (kr != KERN_SUCCESS)</span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">        basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line">        if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            // cpu_usage : Scaled cpu usage percentage. The scale factor is TH_USAGE_SCALE.</span><br><span class="line">            // 宏定义 TH_USAGE_SCALE 返回 CPU 处理总频率：</span><br><span class="line">            total_cpu_usage += basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注意方法最后要调用 vm_deallocate，防止出现内存泄漏</span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">    return total_cpu_usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用 <code>task_threads</code> API 调用获取指定的 task 的线程列表。<code>task_threads</code> 将 <code>target_task</code> 任务中的所有线程保存在 <code>act_list</code> 数组中，数组包含 <code>act_listCnt</code> 个条目。上述源码中，在调用 <code>task_threads</code> API 时，<code>target_task</code> 参数传入的是 <code>mach_task_self()</code>，表示获取当前的 Mach task。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t task_threads</span><br><span class="line">(</span><br><span class="line">task_t target_task,</span><br><span class="line">thread_act_array_t *act_list,</span><br><span class="line">mach_msg_type_number_t *act_listCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>在获取到线程列表后，代码中使用 <code>thread_info</code> API 调用获取指定线程的线程信息。<code>thread_info</code> 查询 <code>flavor</code> 指定的线程信息，将信息返回到长度为 <code>thread_info_outCnt</code> 字节的 <code>thread_info_out</code> 缓存区中。上述源码，在调用 <code>thread_info</code> API 时，<code>flavor</code> 参数传入的是 <code>THREAD_BASIC_INFO</code>，使用这个类型会返回线程的基本信息，即 <code>thread_basic_info_t</code> 结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t thread_info</span><br><span class="line">(</span><br><span class="line">thread_act_t target_act,</span><br><span class="line">thread_flavor_t flavor,</span><br><span class="line">thread_info_t thread_info_out,</span><br><span class="line">mach_msg_type_number_t *thread_info_outCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>上述源码的最后，使用 <code>vm_deallocate</code> API 以防止出现内存泄露。</p><p>使用该方法采集到的 CPU 数据与腾讯的 GT、Instruments 数据接近。事实上，GT 也是采用这种方法采集 CPU 数据。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>通过上述 CPU 占用率监控原理，我们可以联想：内存使用情况是否也可以通过类似的方式获取到呢？答案是肯定的。</p><h3 id="相关系统原理-1"><a href="#相关系统原理-1" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>内存是有限且系统共享的资源，一个程序占用越多，系统和其他程序所能用的就越少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也会占用一定的内存资源。减少内存占用也能同时减少其对 CPU 时间维度上的消耗，从而使不仅使 App 以及整个系统也都能表现的更好。</p><p>MacOS 和 iOS 都采用了虚拟内存技术来突破物理内存的大小限制，每个进程都有一段由多个大小相同的页（Page）所构成的逻辑地址空间。处理器和内存管理单元（MMU，Memory Management Unit）维护着由逻辑地址到物理地址的 <strong>页面映射表</strong>（简称 <strong>页表</strong>），当程序访问逻辑内存地址时，由 MMU 根据页表将逻辑地址转换为真实的物理地址。在早期的苹果设备中，每个页的大小为 4KB；基于 A7 和 A8 处理器的系统为 64 位程序提供了 16KB 的虚拟内存分页和 4KB 的物理内存分页；在 A9 之后，虚拟内存和物理内存的分页大小都达到了 16KB。</p><p>虚拟内存分页（Virtual Page，VP）有两种类型：</p><ol><li>Clean：指能够被系统清理出内存且在需要时能重新加载的数据，包括：<ul><li>内存映射文件</li><li>Frameworks 中的 __DATA_CONST 部分</li><li>应用的二进制可执行文件</li></ul></li><li>Dirty：指不能被系统回收的内存占用，包括：<ul><li>所有堆上的对象</li><li>图片解码缓冲数据</li><li>Framework 中的 <strong>DATA 和 </strong>DATA_DIRTY 部分</li></ul></li></ol><p>由于内存容量和读写寿命的限制，iOS 上没有 Disk Swap 机制，取而代之使用 <strong>Compressed Memory</strong> 技术。 Disk Swap 是指在 macOS 以及一些其他桌面操作系统中，当内存可用资源紧张时，系统将内存中的内容写入磁盘中的backing store（Swapping out），并且在需要访问时从磁盘中再读入 RAM（Swapping in）。与大多数 UNIX 系统不同的是，macOS 没有预先分配磁盘中的一部分作为 backing store，而是利用引导分区所有可用的磁盘空间。</p><p>苹果最初只是公开了从 OS X Mavericks 开始使用 Compressed Memory 技术，但 iOS 系统也从 iOS 7 开始悄悄地使用。</p><p>Compressed Memory 技术在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，其特点可以归结为：</p><ul><li>减少了不活跃内存占用</li><li>改善电源效率，通过压缩减少磁盘 IO 带来的损耗</li><li>压缩/解压非常快，能够尽可能减少 CPU 的时间开销</li><li>支持多核操作</li></ul><p>本质上，Compressed Memory 也是 Dirty Memory。因此，<strong>memory footprint = dirty size + compressed size</strong>，这也是我们需要并且能够尝试去减少的内存占用。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>在 <code>/usr/include/mach/task_info.h</code> 中，我们可以看到 <code>mach_task_basic_info</code> 和 <code>task_basic_info</code> 结构体的定义，分别如下所示。事实上，苹果公司已经不建议再使用 <code>task_basic_info</code> 结构体了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */</span><br><span class="line">struct mach_task_basic_info &#123;</span><br><span class="line">        mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">        mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">        mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */</span><br><span class="line">        time_value_t    user_time;          /* total user run time for</span><br><span class="line">                                               terminated threads */</span><br><span class="line">        time_value_t    system_time;        /* total system run time for</span><br><span class="line">                                               terminated threads */</span><br><span class="line">        policy_t        policy;             /* default policy for new threads */</span><br><span class="line">        integer_t       suspend_count;      /* suspend count for task */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* localized structure - cannot be safely passed between tasks of differing sizes */</span><br><span class="line">/* Don&apos;t use this, use MACH_TASK_BASIC_INFO instead */</span><br><span class="line">struct task_basic_info &#123;</span><br><span class="line">        integer_t       suspend_count;  /* suspend count for task */</span><br><span class="line">        vm_size_t       virtual_size;   /* virtual memory size (bytes) */</span><br><span class="line">        vm_size_t       resident_size;  /* resident memory size (bytes) */</span><br><span class="line">        time_value_t    user_time;      /* total user run time for</span><br><span class="line">                                           terminated threads */</span><br><span class="line">        time_value_t    system_time;    /* total system run time for</span><br><span class="line">                                           terminated threads */</span><br><span class="line">policy_tpolicy;/* default policy for new threads */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mach_task_basic_info</code> 结构体存储了 Mach task 的内存使用信息，其中 <code>resident_size</code> 是 App 使用的驻留内存大小，<code>virtual_size</code> 是 App 使用的虚拟内存大小。</p><p>如下所示为内存使用情况的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 当前 app 内存使用量</span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    struct mach_task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t) &amp;info, &amp;count);</span><br><span class="line">if (kr == KERN_SUCCESS) &#123;</span><br><span class="line">return info.resident_size;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，我用 <strong>通过此方法获取到的内存信息与 Instruments 中的 Activity Monitor 采集到的内存信息进行比较，发现前者要多出将近 100MB</strong>。经过调研发现，苹果使用了上述的 Compressed Memory，我猜测：<code>resident_size</code> 可能是将 Compressed Memory 解压后所统计到的一个数值。<strong>真实的物理内存的值应该是 <code>task_vm_info</code> 结构体中的 <code>pyhs_footprint</code> 成员的值</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_VM_INFO            22</span><br><span class="line">#define TASK_VM_INFO_PURGEABLE  23</span><br><span class="line">struct task_vm_info &#123;</span><br><span class="line">mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">integer_t       region_count;       /* number of memory regions */</span><br><span class="line">integer_t       page_size;</span><br><span class="line">mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">mach_vm_size_t  resident_size_peak; /* peak resident size (bytes) */</span><br><span class="line"></span><br><span class="line">mach_vm_size_t  device;</span><br><span class="line">mach_vm_size_t  device_peak;</span><br><span class="line">mach_vm_size_t  internal;</span><br><span class="line">mach_vm_size_t  internal_peak;</span><br><span class="line">mach_vm_size_t  external;</span><br><span class="line">mach_vm_size_t  external_peak;</span><br><span class="line">mach_vm_size_t  reusable;</span><br><span class="line">mach_vm_size_t  reusable_peak;</span><br><span class="line">mach_vm_size_t  purgeable_volatile_pmap;</span><br><span class="line">mach_vm_size_t  purgeable_volatile_resident;</span><br><span class="line">mach_vm_size_t  purgeable_volatile_virtual;</span><br><span class="line">mach_vm_size_t  compressed;</span><br><span class="line">mach_vm_size_t  compressed_peak;</span><br><span class="line">mach_vm_size_t  compressed_lifetime;</span><br><span class="line"></span><br><span class="line">/* added for rev1 */</span><br><span class="line">mach_vm_size_t  phys_footprint;</span><br><span class="line"></span><br><span class="line">/* added for rev2 */</span><br><span class="line">mach_vm_address_t       min_address;</span><br><span class="line">mach_vm_address_t       max_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因此，正确的内存使用情况的代码实现应该如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 当前 app 内存使用量</span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    task_vm_info_data_t vmInfo;</span><br><span class="line">    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">    kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);</span><br><span class="line">    if (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">        int64_t memoryUsageInByte = (int64_t) vmInfo.phys_footprint;</span><br><span class="line">        return memoryUsageInByte / 1024 / 1024;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h2><p>FPS（Frames Per Second）是指画面每秒传输的帧数。每秒帧数越多，所显示的动画就越流畅，一般只要保持 FPS 在 50-60，App 就会有流畅的体验，反之会感觉到卡顿。</p><h3 id="相关系统原理-2"><a href="#相关系统原理-2" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p><code>CADisplayLink</code> 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。</p><p>一旦 <code>CADisplayLink</code> 以特定的模式注册到 <code>runloop</code> 之后，每当屏幕需要刷新时，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，此时 <code>target</code> 可以读取到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。如：一个视频应用使用时间戳来计算下一帧要显示的视频数据。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>现阶段，常用的 FPS 监控几乎都是基于 <code>CADisplayLink</code> 实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// swift</span><br><span class="line">final class FPSMonitor: NSObject &#123;</span><br><span class="line">    private var timer: Timer?</span><br><span class="line">    private var link: CADisplayLink?</span><br><span class="line">    private var count: UInt = 0</span><br><span class="line">    private var lastTime: TimeInterval = 0</span><br><span class="line"></span><br><span class="line">    func enableMonitor() &#123;</span><br><span class="line">        if link == nil &#123;</span><br><span class="line">            link = CADisplayLink(target: self, selector: #selector(fpsInfoCalculate(_:)))</span><br><span class="line">            link?.add(to: RunLoop.main, forMode: .common)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            link?.isPaused = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func disableMonitor() &#123;</span><br><span class="line">        if let link = link &#123;</span><br><span class="line">            link.isPaused = true</span><br><span class="line">            link.invalidate()</span><br><span class="line">            self.link = nil</span><br><span class="line">            lastTime = 0</span><br><span class="line">            count = 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc</span><br><span class="line">    func fpsInfoCalculate(_ link: CADisplayLink) &#123;</span><br><span class="line">        if lastTime == 0 &#123;</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        count += 1</span><br><span class="line">        let delta = link.timestamp - lastTime</span><br><span class="line">        if delta &gt;= 1 &#123;</span><br><span class="line">            // 间隔超过 1 秒</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            let fps = Double(count) / delta</span><br><span class="line">            count = 0</span><br><span class="line"></span><br><span class="line">            let intFps = Int(fps + 0.5)</span><br><span class="line">            print(&quot;帧率：\(intFps)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CADisplayLink</code> 实现的 FPS 在生产场景中只有指导意义，不能代表真实的 FPS。因为基于 <code>CADisplayLink</code> 实现的 FPS 无法完全检测出当前 <strong>Core Animation</strong> 的性能情况，只能检测出当前 <strong>RunLoop</strong> 的帧率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/aozhimin/iOS-Monitor-Platform" target="_blank" rel="noopener">iOS 性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a></li><li><a href="">深入解析Mac OS X 与 iOS 操作系统</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">WWDC 2018 Session 416 iOS Memory Deep Dive</a></li><li><a href="https://techblog.toutiao.com/2018/06/19/untitled-40/" target="_blank" rel="noopener">[ WWDC2018 ] - 深入解析iOS内存 iOS Memory Deep Dive</a></li><li><a href="https://github.com/WebKit/webkit/blob/52bc6f0a96a062cb0eb76e9a81497183dc87c268/Source/WTF/wtf/cocoa/MemoryFootprintCocoa.cpp" target="_blank" rel="noopener">WebKit MemoryFootprintCocoa</a></li><li><a href="http://newosxbook.com/articles/MemoryPressure.html" target="_blank" rel="noopener">Handling low memory conditions in iOS and Mavericks</a></li><li><a href="https://developer.apple.com/library/archive/technotes/tn2434/_index.html" target="_blank" rel="noopener">Minimizing your app’s Memory Footprint</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" target="_blank" rel="noopener">About the Virtual Memory System</a></li><li><a href="https://zhuanlan.zhihu.com/p/49829766" target="_blank" rel="noopener">iOS 内存管理研究</a></li><li><a href="https://juejin.im/entry/5bbda00ef265da0ac446c970" target="_blank" rel="noopener">iOS Memory Deep Dive</a></li><li><a href="https://zhuanlan.zhihu.com/p/34348398" target="_blank" rel="noopener">深入理解 CADisplayLink 和 NSTimer</a></li><li><a href="https://www.jianshu.com/p/c35a81c3b9eb" target="_blank" rel="noopener">CADisplayLink</a></li><li><a href="https://opensource.apple.com/source/CF/CF-1152.14/CFRunLoop.c.auto.html" target="_blank" rel="noopener">CFRunLoop.c</a></li><li><a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">计算机那些事(8)——图形图像渲染原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间，在公司的 App 中集成了一个性能监视器，效果如下所示。在这个过程中，扒了一些性能监测开源框架的源码，并学习了其中的原理。本文就对此做一些简要的总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-sha
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="性能监控" scheme="http://chuquan.me/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="iOS" scheme="http://chuquan.me/tags/iOS/"/>
    
      <category term="CPU" scheme="http://chuquan.me/tags/CPU/"/>
    
      <category term="Memory" scheme="http://chuquan.me/tags/Memory/"/>
    
      <category term="FPS" scheme="http://chuquan.me/tags/FPS/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(1)——硬盘</title>
    <link href="http://chuquan.me/2019/04/05/linux-disk-introduce/"/>
    <id>http://chuquan.me/2019/04/05/linux-disk-introduce/</id>
    <published>2019-04-05T08:42:00.000Z</published>
    <updated>2019-04-06T07:39:09.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬盘接口"><a href="#硬盘接口" class="headerlink" title="硬盘接口"></a>硬盘接口</h1><p>常见的硬盘接口有：<strong>IDE</strong> 、<strong>SATA</strong>、<strong>SAS</strong>、<strong>USB</strong>、<strong>SCSI</strong>，其中 SATA 是目前的主流接口，IDE 则几乎不再使用。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/disk-interfaces.png" alt=""></p><h1 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h1><p>计算机的各种硬件设备在 Linux 中都有对应的设备文件，甚至不同的接口也对应着不同的设备文件，从而使用不同的驱动程序来操作硬件设备。对于硬盘，实体设备的文件名一般是 <code>/dev/sd[a-]</code>；虚拟设备（虚拟机中的硬盘）的文件名一般是 <code>/dev/vd[a-]</code>。</p><p>有时，系统中会有 <code>/dev/sda</code>、<code>/dev/sdb</code>…等设备文件，它们之间又是什么关系呢？实际上，<code>/dev/sd[a-]</code> 是 SATA/USB/SAS 等硬盘接口对应的设备文件，这类接口都使用 SCSI 模块作为驱动程序。<code>a</code>、<code>b</code>、<code>c</code>…则是按系统检测到的顺序来排列的，与实际插槽顺序无关。</p><p>我们知道硬盘是可以被分区成多个分区（partition），如在 Windows 中可以将一块硬盘分区成 <code>C:</code>、<code>D:</code>、<code>E:</code> 盘。那么，不同的分区是否也有对应的设备文件呢？</p><h1 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h1><p>提到分区，我们需要先了解一下硬盘的结构。不同寻址方式的硬盘，其结构也不同。硬盘的寻址方式主要有两种：</p><ul><li><strong>CHS 寻址方式</strong>：由柱面数（Cylinders）、磁头数（Headers）、扇区数（Sectors）组成 3D 参数，简称 CHS 寻址方式，硬盘容量相对较小。如传统的机械硬盘（Hard Disk Drive，HDD）。</li><li><strong>LBA 寻址方式</strong>：线性寻址，以逻辑区块为单位进行寻址，全称为 Logic Block Address（即扇区的逻辑块地址），硬盘容量相对较大。如固态硬盘（Solid State Disk，SSD）</li></ul><h2 id="CHS-寻址方式"><a href="#CHS-寻址方式" class="headerlink" title="CHS 寻址方式"></a>CHS 寻址方式</h2><p>如下图所为 CHS 寻址方式的硬盘结构，硬盘主要由盘片、机械手臂、磁头、主轴马达组成。盘片是数据存储的媒介，圆形，通过机械手臂读写数据，盘片需要转动才能够让机械手臂读写。因此，可以将盘片同心圆分割成一个个的小区块，这些区块组成一个圆形，可以让机械手臂的磁头进行读写。这个小区块就是硬盘的最小物理存储单位，即 <strong>扇区（sector）</strong>。位于同一个同心圆上的扇区组成的圆环，即 <strong>磁道（track）</strong>。硬盘中可能包含多个盘片，在所有盘片上的同一个磁道组成了所谓的 <strong>柱面（cylinder）</strong>，柱面是文件系统的最小单位，也是分区的最小单位。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-structure.png?x-oss-process=image/resize,w_800" alt=""></p><h2 id="LBA-寻址方式"><a href="#LBA-寻址方式" class="headerlink" title="LBA 寻址方式"></a>LBA 寻址方式</h2><p>LBA 寻址方式的硬盘使用集成电路代替物理旋转磁盘，主要由主控与闪存芯片组成。数据的读写速度远远高于 CHS 寻址方式的硬盘。</p><h1 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h1><p>了解了硬盘结构，再来看硬盘分区。</p><p>关于硬盘分区，首先思考一个问题：为什么要分区？其实主要有两个原因：</p><ol><li>数据的安全性。由于每个分区的数据是独立的，使得数据更加安全。</li><li>访存的高效性。对于 CHS 寻址方式的硬盘，由于分区将数据集中在某个柱面的区段，如第一个分区位于柱面号 1~100。当需要对该分区进行访存时，硬盘只会在 1~100 柱面范围内进行操作，从而提升了数据的访存性能。</li></ol><p>既然硬盘能被分区，那么其分区信息是如何保存的呢？答案就是分区表。但是对于不同寻址方式的硬盘，其分区表的格式也不同，主要有两种：</p><ul><li><strong>MBR 分区表</strong>：多用于 CHS 寻址方式的硬盘</li><li><strong>GUID 分区表</strong>：多用于 LBA 寻址方式的硬盘</li></ul><p>分区表有存储在哪里呢？和绝大多数文件将自身的基本描述信息放在文件的开头类似，分区表作为硬盘的基本信息，同样保存在硬盘最前面的存储区域。</p><p>下面分别介绍 MBR 分区表和 GUID 分区表。</p><h2 id="MBR-分区表"><a href="#MBR-分区表" class="headerlink" title="MBR 分区表"></a><strong>MBR 分区表</strong></h2><p>MBR 分区表保存在硬盘的 <strong>第一个扇区</strong>，由于第一个扇区主要记录了两个重要信息，也称为 <strong>主引导记录区（Master Boot Record，MBR）</strong>。这两个信息分别是：</p><ul><li><strong>MBR 分区表</strong>：记录整个硬盘的分区信息，容量为 64 Bytes。</li><li><strong>引导程序（Boot Loader）</strong>：容量为 446 Bytes。</li></ul><h3 id="MBR-分区表-1"><a href="#MBR-分区表-1" class="headerlink" title="MBR 分区表"></a>MBR 分区表</h3><p>分区表占据了 MBR 64 Bytes 的空间，最多只能记录 4 组分区信息，每组分区信息记录了该分区的 <strong>起始与结束的柱面号</strong>，这 4 组分区信息称为 <strong>主要分区（primary partition）</strong> 或 <strong>延伸分区（extended partition）</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-partition-table.png?x-oss-process=image/resize,w_800" alt=""></p><p>假设上述硬盘的设备文件名为 <code>/dev/sda</code>，则这四个分区在 Linux 中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与分区在硬盘中的位置有关。</p><ul><li>P1：<code>/dev/sda1</code></li><li>P2：<code>/dev/sda2</code></li><li>P3：<code>/dev/sda3</code></li><li>P4：<code>/dev/sda4</code></li></ul><p>由于分区表只有 64 Bytes，最多只能记录 4 组分区信息，那么是否意味着一个硬盘最多只能分割成 4 个分区呢？当然不是！<strong>虽然第一个扇区的分区表只能记录 4 组分区信息，但是利用其中的延伸分区信息进一步索引到一个新的分区表，从而记录更多分区信息</strong>。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-partition-table-extend.png?x-oss-process=image/resize,w_800" alt=""></p><p>上图所示，硬盘第一个扇区中的四个分区记录仅仅使用了两个，P1 为 <strong>主要分区</strong>，P2 为 <strong>延伸分区</strong>。延伸分区的目的是使用额外的扇区来记录分区信息。通过延伸分区所指向的那个区块继续记录分区信息。上图延伸分区索引的分区表继续分出了 5 个分区，这 5 个有延伸分区分出来的分区，称为 <strong>逻辑分区（logical partition）</strong>。</p><p>同理，上图中的分区在 Linux 中的设备文件名如下所示。其中的 <code>/dev/sda3</code> 和 <code>/dev/sda4</code> 则保留给主要分区和延伸分区了，所以逻辑分区的设备文件名从 5 开始。</p><ul><li>P1：<code>/dev/sda1</code></li><li>P2：<code>/dev/sda2</code></li><li>L1：<code>/dev/sda5</code></li><li>L2：<code>/dev/sda6</code></li><li>L3：<code>/dev/sda7</code></li><li>L4：<code>/dev/sda8</code></li><li>L5：<code>/dev/sda9</code></li></ul><blockquote><p>MBR 主要分区、延伸分区、逻辑分区的特性</p><ul><li>主要分区与延伸分区最多可以有 4 个（硬盘的限制）</li><li>延伸分区最多只有一个（操作系统的限制）</li><li>逻辑分区是由延伸分区持续分割出来的分区</li><li>主要分区和逻辑分区可以被格式化；延伸分区不能被格式化</li><li>逻辑分区的数量上限由操作系统决定</li></ul></blockquote><h3 id="引导程序（Boot-Loader）"><a href="#引导程序（Boot-Loader）" class="headerlink" title="引导程序（Boot Loader）"></a>引导程序（Boot Loader）</h3><p>Boot loader 是操作系统安装在 MBR 中的一套软件，但 MRB 仅仅提供 446 Bytes 的空间给 boot loader，所以 boot loader 是极其精简的。其主要完成以下任务：</p><ol><li>提供菜单：用户可以选择不同的开机项目</li><li>载入核心文件：直接指向可开机的程序区段来启动操作系统</li><li>转交其他 loader：将开机管理功能转交给其他 loader 负责，主要用于多系统引导。</li></ol><p>对于第 3 项，表示计算机系统中可能具有两个以上的 boot loader。事实上，boot loader 不仅可以安装在 MBR 中，还可以安装在每个分区的 <strong>开机扇区（boot sector）</strong> 中。</p><p>假设 MBR 中安装的是可以识别 Windows/Linux 的 boot loader，那么整个流程如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-boot-loader.png?x-oss-process=image/resize,w_800" alt=""></p><p>由上图可知，MBR 的 boot loader 提供两个菜单选项：选项 1（M1）可以直接载入 Windows 的核心文件进行开机；选项二（M2）可以将开机管理任务交给第二个分区的开机扇区（boot sector）。如果用户选择选项 2，第二分区的开机扇区中的 boot loader 将会载入 Linux 的核心文件进行开机。</p><blockquote><p>关于多系统安装<br>Linux 安装时，可以将 boot loader 安装在 MBR 或其他分区的开机扇区，Linux 的 boot loader 可以手动设置菜单（即上图的 M1、M2），因此可在 Linux 的 boot loader 中加入 Windows 开机的选项<br>Windows 安装时，其安装程序会主动覆盖 MBR 以及自己所在分区的开机扇区，并且没有选择的机会，也没有让用户自己选择的菜单的功能<br>结论：安装多系统时应该先安装 Windows 系统</p></blockquote><h2 id="GUID-分区表"><a href="#GUID-分区表" class="headerlink" title="GUID 分区表"></a>GUID 分区表</h2><p>MBR 主要有以下限制：</p><ul><li>操作系统无法寻址容量超过 2.2TB 的磁盘</li><li>MBR 只有一个区块，若被破坏后，很难对数据进行恢复</li><li>MBR 的引导程序所能使用空间只有 446 Byte，无法容纳更多的代码</li></ul><p>GUID 则解决了 MBR 的这些问题。</p><p>下图所示为 GUID 的结构示意图。与 MBR 使用扇区作为寻址单位不同，GUID 使用 <strong>逻辑区块（Logical Block）</strong> 作为寻址单位，即采用 LBA（Logical Block Address）寻址方式。MRB 仅使用第一个扇区 512 Bytes 的空间记录分区信息，GUID 则使用 34 个 LBA 区块（每个区块容量默认为 512 Bytes）记录分区信息。MBR 仅有一个扇区保存分区信息，GUID 除了使用硬盘前 34 个 LBA，还是用最后 33 个 LBA 作为备份。</p><p>这里有个疑问：为何前面使用 34 个 LBA，后面使用 33 个 LBA。因为第一个 LBA（LBA0）是用来兼容 MBR 的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-guid-partition-table.png?x-oss-process=image/resize,w_800" alt=""></p><h3 id="LBA0（MBR-兼容区块）"><a href="#LBA0（MBR-兼容区块）" class="headerlink" title="LBA0（MBR 兼容区块）"></a>LBA0（MBR 兼容区块）</h3><p>LBA0 为了兼容 MBR，该区块也分为两个部分，分别用于存储 MBR 分区表和引导程序。因为LBA0 是针对 MBR 兼容模式，因此其分区表中仅仅存放一个特殊标志的分区表信息，用来标识此硬盘为 LBA 寻址方式。</p><h3 id="LBA1（GUID-分区表表头）"><a href="#LBA1（GUID-分区表表头）" class="headerlink" title="LBA1（GUID 分区表表头）"></a>LBA1（GUID 分区表表头）</h3><p>LBA1 记录了分区表本身的位置和大小，同时记录了备份分区表的位置（即最后 33 个 LBA）。此外还存放了分区表的校验码（CRC32），表示硬盘的完整性。</p><h3 id="LBA2-33（分区表表项）"><a href="#LBA2-33（分区表表项）" class="headerlink" title="LBA2~33（分区表表项）"></a>LBA2~33（分区表表项）</h3><p>从 LBA2 开始，每个 LBA 都可以记录 4 组分区信息。默认情况下，总共可以有 4 <em> 32 = 128 组分区信息。因为每个 LBA 有 512 Bytes，所以每组分区信息可使用 128 Bytes 的空间。这 128 Bytes 的分区信息中，分别提供了 64 Bits 用于记录分区对应的 <strong>起始/结束</strong> 区块号。因此，GUID 能够支持的硬盘的最大容量为 `2^64 </em> 512Byte = 233 TB` </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/petershina/article/details/8330171" target="_blank" rel="noopener">硬盘寻址方式</a></li><li><a href="https://blog.csdn.net/Lyon_yong/article/details/79178794" target="_blank" rel="noopener">SSD固态硬盘的结构和基本工作原理概述</a></li><li>《鸟哥的 Linux 私房菜——基础学习篇》</li><li>《Linux 系统架构和应用技巧》</li><li>《Linux 系统架构与目录解析》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;硬盘接口&quot;&gt;&lt;a href=&quot;#硬盘接口&quot; class=&quot;headerlink&quot; title=&quot;硬盘接口&quot;&gt;&lt;/a&gt;硬盘接口&lt;/h1&gt;&lt;p&gt;常见的硬盘接口有：&lt;strong&gt;IDE&lt;/strong&gt; 、&lt;strong&gt;SATA&lt;/strong&gt;、&lt;strong&gt;S
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="磁盘" scheme="http://chuquan.me/tags/%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>IP 协议相关技术</title>
    <link href="http://chuquan.me/2019/03/09/ip-protocols/"/>
    <id>http://chuquan.me/2019/03/09/ip-protocols/</id>
    <published>2019-03-09T11:16:51.000Z</published>
    <updated>2019-03-09T11:19:47.719Z</updated>
    
    <content type="html"><![CDATA[<p>IP（Internet Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP 是无法实现通信的，还必须具有解析主机名、MAC 地址以及数据包在发送过程中异常情况处理等功能。</p><p>下文将详细介绍 IP 的各种辅助技术，主要包括：</p><ul><li>DNS</li><li>ARP</li><li>DHCP</li><li>NAT</li><li>Mobile IP</li></ul><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>通常来说，我们在访问某个网站时不会直接使用 IP 地址，而是使用类似于 <code>www.chuquan.me</code> 这样的域名进行访问。为什么使用域名就能访问目标地址？因为有 DNS（Domain Name System）的支持，其可以将域名转换为具体的 IP 地址。</p><h2 id="DNS-的产生"><a href="#DNS-的产生" class="headerlink" title="DNS 的产生"></a>DNS 的产生</h2><p>在互联网的起源 ARPANET 中，起初由互联网信息中心（SRI-NIC）整体管理一份 hosts 文件，记录 ARPANET 网中所有计算机的 IP 地址。由于主机的 IP 地址可以变更，所以其他计算机也需要定期下载最新的 hosts 文件才能正常使用网络。</p><p>随着网络规模的扩大，这种集中管理方式的可行性及可靠性均逐渐下降。于是，诞生了一个可以有效管理主机名和 IP 地址之间对应关系的系统，即 DNS 系统。在 DNS 系统中，主机的管理机构维护了一个用来表示组织内部主机名和 IP 地址映射关系的数据库。当用户在应用（如浏览器）中输入主机名（域名）时，DNS 会自动检索数据库，并返回对应的 IP 地址。</p><h2 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h2><p>域名是为了标识主机名和组织机构名的一个具有分层结构的字符串。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pku.edu.cn</span><br></pre></td></tr></table></figure></p><p>其中，<code>pku</code> 表示北京大学（Peking University）固有的域名；<code>edu</code> 表示教育相关结构；<code>cn</code> 表示中国。</p><p>域名的分层如下图所示，各级分层构成一个树形结构，顶点 root 是树的根节点，根节点的下一层称为第 1 层域名，又称 <strong>顶级域名</strong>，如：<code>cn</code>、<code>jp</code> 等国别顶级域名，<code>com</code>、<code>org</code> 等特定领域域名。顶级域名的下一层称为第 2 层域名，如：<code>ac</code>、<code>co</code> 等表示不同组织结构的属性域名，<code>beijing</code> 等表示地域的通用域名。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-hierachy.png" alt=""></p><ul><li><strong>域名服务器</strong><br>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。其所管理的分层称为 <code>ZONE</code>。如图所示，每层都有一个域名服务器。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system.png" alt=""></p><p>DNS 分层结构的根节点设置的 DNS 称为 <strong>根域名服务器</strong>。根域名服务器中注册了 <strong>顶级域名服务器</strong> 的 IP 地址。顶级域名服务器中则注册了第 2 层域名服务器的 IP 地址，以此类推，构成一个分层系统。如果域名服务器宕机，则针对该域的 DNS 查询就会失败。因此为了提高容灾能力，一般会设置至少两个以上的域名服务器。一旦第一个域名服务器无法查询，就会自动转到第二个甚至第三个域名服务器上进行。</p><ul><li><strong>解析器</strong><br>进行 DNS 查询的主机和软件称为 <strong>DNS 解析器</strong>。用户所使用的工作站或个人电脑都属于解析器。<strong>一个解析器至少要注册一个以上域名服务器的 IP 地址</strong>。通常，至少包括组织内部的域名服务器的 IP 地址。</li></ul><h2 id="DNS-工作原理"><a href="#DNS-工作原理" class="headerlink" title="DNS 工作原理"></a>DNS 工作原理</h2><p>那么 DNS 的工作原理是什么呢？假设 <code>yuanfudao.com</code> 域中的主机 A 访问网站 <code>pku.edu.cn</code>，该过程的 DNS 查询流程如图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system-query.png" alt=""></p><p>解析器为了获取 IP 地址，向域名服务器进行查询。接收到查询请求的域名服务器首先在自己的数据库进行查找。如果有该域名对应的 IP 地址就返回。如果没有，则域名服务器再向上一层域名服务器进行查询，依次类推，直到根域名服务器。然后根节点遍历，直到找到指定的域名服务器，并由该域名服务器返回对应的 IP 地址。</p><p>解析器和域名服务器通过将查询结果进行缓存来提高查询性能。</p><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>通过 DNS 确定了目标域名的 IP 地址之后，就可以向该目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时有必要了解每个 IP 地址对应的 MAC 地址。</p><p>ARP（Address Resolution Protocol）是一种解决地址问题的协议。ARP 以目标 IP 地址为线索，确定下一个应该接收数据分包的网络设备的 MAC 地址。如果目标主机不在同一个链路上，可以通过 ARP 查找下一跳路由器的 MAC 地址。</p><blockquote><p>ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以使用 ICMPv6 替代 ARP 发送邻居探索消息。</p></blockquote><h2 id="ARP-工作原理"><a href="#ARP-工作原理" class="headerlink" title="ARP 工作原理"></a>ARP 工作原理</h2><p>ARP 是如果确定 MAC 地址的呢？事实上，ARP 主要通过 <strong>ARP 请求</strong> 与 <strong>ARP 响应</strong> 两种类型的包来确定 MAC 地址的。</p><p>如图所示，主机 A 向同一链路上的主机 B 发送 IP 包，主机 A 的 IP 地址为 <code>172.20.1.1</code>，主机 B 的 IP 地址为 <code>172.20.1.2</code>，它们互不知道对方的 MAC 地址。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/arp-protocol.png" alt=""></p><p>主机 A 为了确定主机 B 的 MAC 地址，先通过广播发送一个 ARP 请求包，请求包中包含了主机 B 的IP 地址 <code>172.20.1.2</code>。由于广播的包可以被同一个链路上的所有主机或路由器接收，因此 ARP 包的请求包也会被同一链路上所有的主机和路由器进行解析。如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，则该节点就将自己的 MAC 地址存入 ARP 响应包并返回给主机 A。</p><p>如果每发送一个 IP 数据报都要进行一次 ARP 请求以此确定 MAC 地址，那么将会产生大量不必要的网络流量。为此，通常会将 IP 与 MAC 地址的映射关系缓存在一个 <strong>ARP 缓存表</strong> 中。除了 ARP 请求发送端可以缓存发送端 MAC 地址，接收端也可以从 ARP 请求包获取发送端主机的 IP 地址及其 MAC 地址并将其进行缓存。</p><p>不过，MAC 地址的缓存是有一定的期限的。超出期限之后，缓存的内容将被清除。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>RARP（Reverse Address Resolution Protocol）是一种根据 MAC 地址定位 IP 地址的协议。例如：将打印机服务器等小型嵌入式设备接入到网络时就会用到。</p><p>通常，我们使用个人电脑设置 IP 地址时，可以通过 DHCP 自动分配获取 IP 地址。但是对于嵌入式设备，会遇到没有任何输入接口或无法通过 DHCP 动态获取 IP 地址的情况。在这种情况下，一般使用 RARP。为此，需要架设一台 RARP 服务器，然后再接入该设备到网络，启动设备时，设备会发送一条类似于“我的 MAC 地址是 xxx，我的 IP 地址是什么”的请求信息。RARP 服务器接收到请求消息之后，返回类似于“MAC 地址为 xxx 的设备，IP 地址为 xxx”的信息。设备根据该应答信息设置自己的 IP 地址。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rarp-protocol.png" alt=""></p><h2 id="代理-ARP"><a href="#代理-ARP" class="headerlink" title="代理 ARP"></a>代理 ARP</h2><p>通常 ARP 包会被路由器隔离，但是采用代理 ARP（Proxy ARP）的路由器可以将 ARP 请求转发给邻近的网段。因此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><p>在目前的 TCP/IP 网络中，一般情况下用路由器链接多个网络时，会在各个网段上定义各自的子网，从而进行路由控制。然而，对于那些不支持设定子网掩码的老设备，不适用代理 ARP，有时就无法更好地使用网络。</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>每一台主机在接入网络时都需要设置 IP 地址，尤其是对于移动设备，每移动到一个新的地方，都需要重新设置 IP 地址。</p><p>DHCP（Dynamic Host Configuration Protocol）就是一种可以实现自动设置 IP 地址、统一管理 IP 地址分配的协议。通过 DHCP，计算机只要连接到网络就可以进行 TCP/IP 通信。</p><h2 id="DHCP-工作原理"><a href="#DHCP-工作原理" class="headerlink" title="DHCP 工作原理"></a>DHCP 工作原理</h2><p>使用 DHCP 之前，需要先架设一台 DHCP 服务器。然后将 DHCP 所要分配的 IP 地址、子网掩码、路由控制信息、DNS 服务器地址等设置到服务器上。</p><p>从 DHCP 获取 IP 地址的过程主要分为两个步骤：</p><ul><li><strong>DHCP 请求</strong>：客户端广播发送 DHCP 发现包，请求设置 IP 地址和子网掩码。DHCP 服务器收到请求后返回 DHCP 提供包，通知可以使用的网络设置。</li><li><strong>DHCP 确认</strong>：客户端再次广播发送 DHCP 请求包，通知想要使用前一次 DHCP 提供包中的网络设置，以确保在 DHCP 服务器上重复设置也可以正常工作。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-protocol.png" alt=""></p><p>当 DHCP 服务器遇到故障时，将导致无法自动分配 IP 地址，从而导致网段内所有主机之间无法进行 TCP/IP 通信。为了提高网络的可靠性，通常会架设两台以上的 DHCP 服务器。由于每个 DHCP 服务器内部都记录着 IP 地址的分配信息，因此可能会导致不同 DHCP 服务器分配的 IP 地址产生冲突。</p><p>为了检查所要分配的 IP 地址以及已分配的 IP 地址是否可用，DHCP 服务器或 DHCP 客户端必须具有以下功能：</p><ul><li><strong>DHCP 服务器</strong>：在分配 IP 地址前发送 ICMP 回送请求包，确认没有返回应答。</li><li><strong>DHCP 客户端</strong>：针对从 DHCP 获取到的 IP 地址发送 ARP 请求包，确认没有返回应答。</li></ul><h2 id="DHCP-中继代理"><a href="#DHCP-中继代理" class="headerlink" title="DHCP 中继代理"></a>DHCP 中继代理</h2><p>家庭网络大多只有一个以太网（无线 LAN）的网段，与其连接的主机台数也不会很多。因此，只需要一台 DHCP 服务器就能应对 IP 地址分配的需求，而大多数情况下都由 <strong>宽带路由器</strong> 充当 DHCP 的角色。</p><p>相比之下，一个企业或学校的网络环境中，一般会有多个以太网（无线 LAN）的网段。在这种情况下，如果针对每个网段都设置 DHCP 服务器，则将是一个浩大的工程。即使路由器可以分担 DHCP 的功能，如果网络中有 100 个路由器，就要为 100 个路由器设置它们各自可分配 IP 地址的范围，并对这些范围进行后续的更新维护，这是极其难以管理的。</p><p>因此，在这类网络环境中，往往需要 DHCP 统一管理，具体方法可以使用 DHCP 中继代理实现。</p><p>这种方法需要在每个网段设置一个 DHCP 中继代理。它可以设置 DHCP 服务器的 IP 地址，从而可以在 DHCP 服务器上为每个网段注册 IP 地址的分配范围。</p><p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，DHCP 中继代理收到广播的请求包后，以单播的方式发给 DHCP 服务器。服务器收到包后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端。由此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理的 IP 地址。 </p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-agent-protocol.png" alt=""></p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时使用全局 IP 地址的技术。NAT 主要是为了应对 IPv4 日渐枯竭而开发的技术。</p><h2 id="NAT-工作原理"><a href="#NAT-工作原理" class="headerlink" title="NAT 工作原理"></a>NAT 工作原理</h2><p>如下图所示，以 <code>10.0.0.10</code> 的主机与 <code>163.221.120.9</code> 的主机进行通信为例。局域网中的主机发起请求时，NAT 路由器会将发送源地址从 <code>10.0.0.10</code> 转换为全局的 IP 地址 <code>202.244.174.37</code> 后再发送数据。反之，当数据从地址 <code>163.221.120.9</code> 发送过来时，目标地址 <code>202.244.174.37</code> 先被转换成私有 IP 地址 <code>10.0.0.10</code> 后再被转发。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nat-protocol.png" alt=""></p><p>NAT 路由器内部有一个自动生成的用来转换地址的表。当 <code>10.0.0.10</code> 向 <code>163.221.120.9</code> 发送第一个数据包时生成这张表，并按照表中的映射关系进行处理。</p><h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><p>NAPT（Network Address Port Translator）是 NAT 的升级版，不仅可以转换 IP 地址，还可以转换 TCP、UDP 端口号，可以实现用一个全局 IP 地址与多个主机的通信。</p><p>如下图所示，主机 <code>163.221.120.9</code> 的端口号是 <code>80</code>，LAN 中有两个客户端 <code>10.0.0.10</code> 和 <code>10.0.0.11</code> 同时进行通信，并且两个客户端的本地端口都是 <code>1025</code>。此时，仅仅将 IP 地址为路由器的全局地址 <code>202.244.174.37</code> 将无法区分两个客户端。因此，只要将 <code>10.0.0.11</code> 的端口号转换为 <code>1026</code> 就可以进行区分。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/napt-protocol.png" alt=""></p><p>类似于 NAT，NAPT 路由器也会生成自动一个转换表。如：在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包发出后就会生成转换表。断开 TCP 连接时的 FIN 包发出后就会被删除。</p><h1 id="Mobile-IP"><a href="#Mobile-IP" class="headerlink" title="Mobile IP"></a>Mobile IP</h1><p>在与移动设备进行通信时，所连接的子网一旦发生变化，则无法通过 TCP 继续通信。因为 TCP 是面向连接的协议，自始至终都需要发送端和接收端主机的 IP 地址保持不变。类似的，UDP 也无法继续通信。</p><p>Mobile IP 技术就是为了解决所连接的子网发生变化时继续保持通信的需求。</p><h2 id="Mobile-IP-工作原理"><a href="#Mobile-IP-工作原理" class="headerlink" title="Mobile IP 工作原理"></a>Mobile IP 工作原理</h2><p><strong>基本概念</strong></p><ul><li><strong>移动节点</strong>（MN，Mobile Node）：从一个网络切换到另一个网络的设备，如：手机从一个网络切换到另一个网络。</li><li><strong>对等节点</strong>（CN，Correspondent Node）：与移动节点通信的设备。</li><li><strong>归属地址</strong>（Permanent Address）：一个固定的 IP 地址，如同一个人的户籍，即使移动了也不会改变。</li><li><strong>转交地址</strong>（CoA：Care-of-Address）：设备移动当前所处网络予以分配的 IP 地址。</li><li><strong>归属代理</strong>（HA：Home Agent）：暂时认为是移动设备当前所处网络的路由器。</li><li><strong>外地代理</strong>（FA：Foreign Agent）：暂时认为是移动设备归属网络的路由器。</li></ul><p>如下图所示，为 Mobile IP 的工作原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/mobile-ip-protocol.png" alt=""></p><p>当移动节点接入切换至另一个网络时，首先请求外地代理为它服务，并向归属代理注册转交地址。</p><p>当对等节点向移动节点的归属地址发送分组数据时，归属代理能够截获该分组，并将该分组转发给移动节点最新注册的转交地址。外地代理收到分组数据后，转发给转交地址对应的设备，即移动节点。移动节点可以直接响应对等节点。</p><p>注意，归属代理和外地代理之间的通信是通过 IP 隧道实现的。因为归属代理会将对等节点的原始分组数据进行封装，再由外地代理进行拆封。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《图解 TCP/IP》</li><li>Mobile IP 基本知识, NC &amp; IS</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IP（Internet Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP 是无法实现通信的，还必须具有解析主机名、MAC 地址以及数据包在发送过程中异常情况处理等功能。&lt;/p&gt;
&lt;p&gt;下文将详细介绍 IP 的各种辅助技术，主要包括：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="网络" scheme="http://chuquan.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IP" scheme="http://chuquan.me/tags/IP/"/>
    
      <category term="DHCP" scheme="http://chuquan.me/tags/DHCP/"/>
    
      <category term="DNS" scheme="http://chuquan.me/tags/DNS/"/>
    
      <category term="ARP" scheme="http://chuquan.me/tags/ARP/"/>
    
      <category term="Mobile IP" scheme="http://chuquan.me/tags/Mobile-IP/"/>
    
      <category term="NAT" scheme="http://chuquan.me/tags/NAT/"/>
    
  </entry>
  
  <entry>
    <title>OSI 模型与 TCP-IP 协议详解</title>
    <link href="http://chuquan.me/2019/03/02/osi-tcp-ip-introduce/"/>
    <id>http://chuquan.me/2019/03/02/osi-tcp-ip-introduce/</id>
    <published>2019-03-02T07:03:12.000Z</published>
    <updated>2019-03-02T07:09:35.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p>在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着异构机型之间通信的需求不断增加，通信技术的标准化也随之展开。于是，ISO（International Organization for Standard）制定了一个国际标准 OSI（Open System Interconnection），即广为人知的 OSI 参考模型，作为标准化通信技术的设计准则。</p><p>OSI 参考模型将通信协议中必要的功能分层了 7 层。每个分层接收下一层提供的特定服务，并负责为上一层提供特定的服务。这些功能上相对独立的分层可以构造一个扩展性和灵活性都较强的系统。</p><p>下表所示为 OSI 参考模型及其各个分层的职责。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi.png?x-oss-process=image/resize,w_570" alt=""></p><ul><li><p><strong>应用层</strong>：主要负责为应用程序提供服务并规定应用程序中通信相关的细节。在该层实现的协议有：文件传输、电子邮件、远程登录等协议。</p></li><li><p><strong>表示层</strong>：主要负责数据格式的转换。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。</p></li><li><p><strong>会话层</strong>：主要负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p></li><li><p><strong>传输层</strong>：主要负责进行可靠传输。只在通信双方节点上进行处理，而无需在路由器上处理。</p></li><li><p><strong>网络层</strong>：主要负责寻址和路由选择，从而将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某个地址。</p></li><li><p><strong>数据链路层</strong>：主要负责物理层面上互连的、节点之间的通信传输。将 0、1 序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。如与 1 个以太网相连的 2 个节点之间的通信。</p></li><li><p><strong>物理层</strong>：主要负责 0、1 比特流（0、1 序列）与电压的高低、光的闪灭之间的互换。</p></li></ul><h1 id="OSI-参考模型通信示例"><a href="#OSI-参考模型通信示例" class="headerlink" title="OSI 参考模型通信示例"></a>OSI 参考模型通信示例</h1><p>下面举例说明 OSI 参考模型的功能。假设使用主机 A 的用户向使用主机 B 的用户发送一封邮件。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email01.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>用户 A 在主机 A 上新建一封邮件，指定收件人为 B，并输入邮件内容为 “早上好”。用户确认发送时，开始进入应用层协议的处理。该协议在传送数据的前端附加一个首部信息。主机 B 在收到主机 A 发送至的数据后，分析其数据首部与数据正文，并将邮件存入本地。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email02.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层会将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复成“该计算机特有的数据格式”，然后在进行相应的处理。</p><p>此例中，“早上好”这段文字根据编码格式被转换成了“统一的网络数据格式”。由于文字的编码格式非常多，如：UTF-8、UTF-16、Unicode 等，如果未能按照特定格式编码，那么在接收端收到的邮件可能就是乱码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email03.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>假如用户 A 新建了 5 封邮件准备发送给用户 B。这 5 封邮件的发送顺序可以有多种：</p><ul><li>每发一封邮件时建立一次连接，随后断开连接</li><li>一旦建立连接后，将 5 封邮件连续发送给对方</li><li>同时建立 5 个连接，将 5 封邮件同时发送给对方</li></ul><p>会话层的主要责任就是决定采用何种连接方式。</p><p>类似应用层、表示层，会话层在其收到的数据前端附加首部之后再转发给下一层。这些首部中 <strong>记录着数据传送顺序的信息</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email04.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>会话层只对何时建立连接、何时发送数据等问题进行管理，并不具备实际传输数据的功能。真正负责在网络上传输数据的是会话层以下的分层。</p><p>主机 A 确保与主机 B 之间的通信并准备发送数据。该过程称为“建立连接”。连接建立后即可使主机 A 发送的邮件到达主机 B。传输结束之后，有必要将连接断开。</p><p>上述两个主机之间创建逻辑上的通信连接是传输层的主要作用。此外，传输层为确保数据到达目标地址，会在通信两端的主机之间进行确认，如果数据没有到达，则负责进行重发。</p><p>示例中，如果主机 A 将“早上好”发送给主机 B，由于网络异常等原因导致只有部分数据到达目标地址。假设主机 B 只收到“早上”这部分数据，那么它会将没有收到“早上”之后那部分数据的事实告诉主机 A，主机 A 得知后会将“好”重新发送给主机 B，并再次确认对端是否收到。</p><p>因此，保证数据传输的可靠性是传输层的一个重要作用。为了确保可靠性，传输层也会对所要传输的数据附加首部以识别这一分层的数据。然而，实际上将数据传输给对端的处理是由网络层完成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email05.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的作用是在网络与网络互连的环境中，将数据从发送端主机发送到接收端主机。如图所示，两端主机之间虽然有众多数据链路，但是能够将数据从主机 A 发送到主机 B 也都是网络层的功劳。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email06.png?x-oss-process=image/resize,w_600" alt=""></p><p>网络层的数据发送通过目标地址选择对应的计算机，因此目标地址是网络中唯一指定的序号，类似于电话号码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email07.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="数据链路层、物理层"><a href="#数据链路层、物理层" class="headerlink" title="数据链路层、物理层"></a>数据链路层、物理层</h2><p>通信传输本质上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过介质互连的设备之间进行数据处理。</p><p>物理层则将数据的 0、1 转换为电压和脉冲光传输给物理的传输介质，而<strong>相互直连的设备之间使用地址实现传输</strong>。这种地址被称为 <strong>MAC</strong> 地址。<strong>采用 MAC 地址，目的是为了识别连接同一传输介质上的设备</strong>。物理层会将包含 MAC 地址的信息的首部附加到同网络层转发过来的数据上，并将其发送到网络中。</p><p>网络层与数据链路层都是基于目标地址将数据发送给接收端，其区别在于：</p><ul><li><strong>网络层负责将整个数据发送给最终的目标地址</strong></li><li><strong>数据链路层只负责发送一个分段内的数据</strong></li></ul><p>详见上图。</p><h1 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h1><h2 id="TCP-IP-的含义"><a href="#TCP-IP-的含义" class="headerlink" title="TCP/IP 的含义"></a>TCP/IP 的含义</h2><p>从字面上看，有人可能会认为 TCP/IP 是指 TCP 与 IP 两种协议。虽然实际中的确有这两种协议，但是在很多情况下，它泛指 IP、ICMP、TCP、UDP、TELNET、FTP、HTTP 等协议群，所以有时也称 TCP/IP 为 <strong>网际协议族</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-protocols.png" alt=""></p><h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p><strong>包、帧、数据报、段、消息</strong> 等五个术语都用来表述数据的单位，其区别在于：</p><ul><li>包：全能性术语</li><li>帧：表示数据链路层中包的单位</li><li>数据报：表示 IP 和 UDP 等网络层以上分层中包的单位</li><li>段：表示 TCP 数据流中的信息</li><li>消息：表示应用层中数据的单位</li></ul><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上层传来的数据。在数据包的首部，明确标明了协议应该如何读取数据。通过解析首部，能够了解该协议必要的信息以及要处理的内容。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-data-header.png" alt=""></p><h2 id="TCP-IP-与-OSI-参考模型"><a href="#TCP-IP-与-OSI-参考模型" class="headerlink" title="TCP/IP 与 OSI 参考模型"></a>TCP/IP 与 OSI 参考模型</h2><p>关于 TCP/IP 与 OSI 参考模型的关系，我们可以认为 TCP/IP 是对 OSI 参考模型的一种具体实现。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-ois-compare.png" alt=""></p><ul><li><p><strong>硬件（物理层）</strong></p><ul><li>TCP/IP 的最底层是负责数据传输的硬件，如以太网或电话线路等物理层的设备。物理层所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等都会有所不同。</li></ul></li><li><p><strong>网络接口层（数据链路层）</strong></p><ul><li>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层，可认为是让 NIC（网卡）正常工作的驱动程序。</li></ul></li><li><p><strong>互联网层（网络层）</strong></p><ul><li>互联网层使用 IP 协议，对应 OSI 模型中的第 3 层网络层。IP 协议基于 IP 地址转发分组数据包。</li><li>TCP/IP 分层中的互联网层与传输层的功能通常由操作系统实现。尤其是路由器，它必须实现通过互联网曾转发分组数据包的功能。连接互联网的所有主机和路由器都必须实现 IP 的功能。</li></ul></li></ul><blockquote><p><strong>为什么要分组？</strong><br>首先需要明确一个事实：一台计算机在收发数据时会独占其所在的整条通信线路。如果一条线路上连接了多台计算机，当计算机相互之间进行数据传输时，则需要等待线路中没有其他计算机占用时才能进行数据传输。如果某台计算机占用线路之后传输大量数据，则其他计算机始终保持等待状态。极端情况下根本无法进行通信。<br>采用分组（交换）技术，数据会被分成更小的单元，所有的计算机就可以并发收发数据，从而提高了通信线路的利用率。</p><p><strong>IP</strong><br>IP 是跨越网络传送数据包，使整个互联网都能收到数据的协议，这个过程中使用 IP 地址作为主机的标识。<br>IP 还隐含着数据链路的功能。通过 IP，相互通信的主机之间无论经过怎样的底层数据链路都能够实现通信。<br>IP 是分组交换的一种协议，但其并不具备重发机制。即使分组数据包未能达到对端主机也不会重发，属于非可靠传输协议。  </p><p><strong>ICMP</strong><br>IP 数据包在发送途中一旦出现异常导致无法到达对端目标地址时，需要向发送端发送一个异常通知。ICMP 就是为这一功能而定制的，常用于 <strong>诊断网络的健康状况</strong>。  </p><p><strong>ARP</strong><br>从分组数据包的 IP 地址中解析出物理地址（MAC 地址）的一种协议。</p></blockquote><ul><li><strong>传输层</strong><ul><li>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同时运行着多个程序。为了识</li><li>别哪些程序之间在进行通信，使用 <strong>端口号</strong> 进行区分。</li></ul></li></ul><blockquote><p><strong>TCP</strong><br>TCP 是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP 能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP 还能够有效利用带宽，缓解网络拥堵。<br> 为了建立和断开连接，TCP 需要进行 3 次握手，4 次挥手，从而会导致网络流量的浪费。</p><p><strong>UDP</strong><br>UDP 是一种面向无连接的传输层协议。UDP 不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。<br>UDP 常用语分组数据较少或多播、广播通信以及视频通信等多媒体领域。  </p></blockquote><ul><li><strong>应用层（会话层以上分层）</strong><ul><li>TCP/IP 协议分层模型将 OSI 参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。</li></ul></li></ul><h1 id="TCP-IP-协议分层模型通信示例"><a href="#TCP-IP-协议分层模型通信示例" class="headerlink" title="TCP/IP 协议分层模型通信示例"></a>TCP/IP 协议分层模型通信示例</h1><p>这里继续以上述电子邮件收发的示例来介绍 TCP/IP 协议分层模型的通信过程。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-example.png" alt=""></p><p>邮件收发过程可分为个主要步骤：</p><ul><li>发送数据包（发送端）</li><li>接收数据包（接收端）</li></ul><h2 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h2><h3 id="应用程序处理"><a href="#应用程序处理" class="headerlink" title="应用程序处理"></a>应用程序处理</h3><p>应用程序在发送邮件那一刻建立 TCP 连接，从而利用该 TCP 连接发送数据。该过程首先将应用层发来的数据发送至下一层的 TCP，再做实际的转发处理。</p><h3 id="TCP-模块处理"><a href="#TCP-模块处理" class="headerlink" title="TCP 模块处理"></a>TCP 模块处理</h3><p>TCP 根据应用程序的指示，负责建立连接、发送数据、断开连接。TCP 会在应用层数据前端附加一个 TCP 首部，其中包括：<strong>源端口号</strong> 和 <strong>目标端口号</strong>（用以识别发送主机和接收主机上的应用）、<strong>序号</strong>（用以标识发送包中哪部分是数据）、<strong>校验和</strong>（用以判断数据是否被损坏）。</p><h3 id="IP-模块处理"><a href="#IP-模块处理" class="headerlink" title="IP 模块处理"></a>IP 模块处理</h3><p>IP 将 TCP 传来的 TCP 首部和 TCP 数据合起来作为自己的数据，并在数据前端附加一个 IP 首部，其中包括：接收端 IP 地址和发送端 IP 地址。</p><p>IP 包生成后，根据路由控制表决定接收此 IP 包的路由器或主机。随后，IP 包将被发送给连接到这些路由器或主机网络接口的驱动程序，以实现真正发送数据。</p><p>如果尚且不知道接收端的 MAC 地址，可利用 ARP 查找。只要知道了对端的 MAC 地址，就可将 MAC 地址和 IP 地址交给以太网的驱动程序，实现数据传输。</p><h3 id="网络接口（以太网驱动）处理"><a href="#网络接口（以太网驱动）处理" class="headerlink" title="网络接口（以太网驱动）处理"></a>网络接口（以太网驱动）处理</h3><p>以太网驱动会将 IP 传来的 IP 包的前端附加上以太网首部并进行发送处理。以太网首部包含：接收端 MAC 地址、发送端 MAC 地址、标志以太网类型的以太网数据的协议。由此产生的以太网数据包将被发送至物理层传输给接收端。</p><h2 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h2><p>数据包的接收流程是发送流程的逆序过程。</p><h3 id="网络接口（以太网驱动）处理-1"><a href="#网络接口（以太网驱动）处理-1" class="headerlink" title="网络接口（以太网驱动）处理"></a>网络接口（以太网驱动）处理</h3><p><strong>主机收到以太网包后，先从以太网包首部找到 MAC 地址判断是否为发给自己的包。如果不是则丢弃。</strong></p><p>如果确认是发给自己的包，则查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。示例中数据的协议类型是 IP，因此将数据传送给处理 IP 的子程序（如果是 ARP，则把数据传给处理 ARP 的子程序）。如果无法识别协议类型，则丢弃数据。</p><h3 id="IP-模块处理-1"><a href="#IP-模块处理-1" class="headerlink" title="IP 模块处理"></a>IP 模块处理</h3><p>IP 模块收到 IP 包首部以数据部分后，也做类似处理。<strong>如果判断首部中的 IP 地址与自己的 IP 地址匹配，则接收数据并从中查找上一层的协议</strong>。如果上一层协议为 TCP，则传给 TCP 处理；如果上一层协议为 UDP，则传给 UDP 处理；<strong>对于路由器，接收端 IP 地址往往不是自己的 IP 地址，此时会根据路由控制表，查询应送达的主机或路由器以后再转发数据</strong>。</p><h3 id="TCP-模块处理-1"><a href="#TCP-模块处理-1" class="headerlink" title="TCP 模块处理"></a>TCP 模块处理</h3><p>TCP 模块会先计算校验和以确认数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。</p><p>数据接收完毕后，接收端则发送一个“确认回执”给发送端。如果回执消息未能达到发送端，发送端会认为接收端没有接收到数据而一直重复发送。</p><p>数据被完整接收后，会传给由端口号识别的应用程序。</p><h3 id="应用程序处理-1"><a href="#应用程序处理-1" class="headerlink" title="应用程序处理"></a>应用程序处理</h3><p>接收端应用程序通过解析数据可最终获取到邮件的具体内容。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI 模型-维基百科</a></li><li>《图解 TCP/IP》</li><li>《TCP/IP 详解》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OSI-参考模型&quot;&gt;&lt;a href=&quot;#OSI-参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 参考模型&quot;&gt;&lt;/a&gt;OSI 参考模型&lt;/h1&gt;&lt;p&gt;在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着
      
    
    </summary>
    
      <category term="网络" scheme="http://chuquan.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IP" scheme="http://chuquan.me/tags/IP/"/>
    
      <category term="OSI" scheme="http://chuquan.me/tags/OSI/"/>
    
      <category term="TCP" scheme="http://chuquan.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://chuquan.me/2018/12/31/2018-summary/"/>
    <id>http://chuquan.me/2018/12/31/2018-summary/</id>
    <published>2018-12-31T08:07:42.000Z</published>
    <updated>2018-12-31T08:13:31.940Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600" alt=""></div><a id="more"></a><p>又到了年末总结的时候了…回望年初立下的 Flag，不知道倒下了多少，扶都扶不起来。</p><p>简单总结一下这一年吧..</p><h2 id="关于运动"><a href="#关于运动" class="headerlink" title="关于运动"></a>关于运动</h2><p>从 7 月份至 10 月份，在这 4 个月期间，每周末去自学游泳。从旱鸭子状态开始，依次掌握了蛙泳，狗刨，自由泳，仰泳，蝶泳。目前，蝶泳还不是非常协调，有待进一步强化练习。毕竟，蝶泳是所用泳姿中门槛最高的一种，无论是在力量方面还是协调性方面。</p><p>当然，完全靠自己摸索来学习游泳是一个很漫长的过程。为了加快我的学习进入，在学游泳期间，我坚持观看 YouTube 上易梦觉教练的一些游泳教学视频，学习一些游泳的技巧。</p><p>年底的时候，开始教妹子学游泳，目前蛙泳差不多已经会了。</p><p>除了游泳，今年在周末的时间还有一部分给了篮球。自从 3 月份那会儿在高家园附近的社科院里发现了一个室外篮球场后，在 7 月份之前几乎每周末都会去打一次球。</p><p>总体来说，今年的运动量增加了不少，同时掌握了游泳这个新技能。</p><h2 id="关于旅行"><a href="#关于旅行" class="headerlink" title="关于旅行"></a>关于旅行</h2><p>今年 10 月底，随公司一起去俄罗斯玩了一周。<a href="http://chuquan.me/2018/11/03/st-petersburg/">游记传送门</a></p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>年初的时候，刚刚开始接手模块级的 iOS 开发任务，那时候还不是非常娴熟。经过这一年的锻炼，已经能够 carry 任何需求了。</p><p>这一年里，公司的工作节奏依然比较快的，毕竟走的是 Scrum 的项目管理模式，需求迭代很快，并且研发人员相对产品经理较少。为了解决研发人员不足的问题，从年初就开始不停地招人。到年底，我们整个研发组从原来的 15 人左右增至 30 多人。公司整体的人员也增涨了不少，去年入职时只有 500 人左右，此刻已经有了 2800 多人了。在全球经济如此不景气，各个公司都不断裁员的背景下，我司还在不断地扩招，不禁感慨教育行业的优越性[手动捂脸]。</p><p>6 月份，公司给我们调了一次薪水，发了期权，虽然不是很多，但符合预期。</p><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>今年来了几位有着丰富工作经验的同事，在他们的积极推动下，我们的搜题和口算的项目也开始引入了一些新的技术框架。口算目前基本已经在使用 Swift 进行开发了，并已经在使用函数响应式编程框架 RxSwift。搜题方面由于历史原因，虽然引入了 RxSwift，但还没有开始全面使用。</p><p>去年立下的关于阅读开源框架的 Flag，今年只是阅读了一些公司内部的框架，如：YTKFrog、YTKRouterManager、YTKResourceSync 等，关于阅读开源框架这个 Flag，希望明年能够重视。</p><h2 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h2><p>今年上半年，我又重新看了一遍《程序员的自我修养——装载、链接与库》，然后写了几篇博客。从中我发现了一种相比以前更加高效的吸收知识、提高阅读效率的方法——写博客。为什么呢？因为我们看完一本书时，其实有效的知识吸收程度并不高，写博客能够让我们加强对关心的主题的理解。写博客的过程中，需要我们不断地重新翻看书中的一些要点，甚至查阅其他书籍、博客，从而加强我们对它的理解。后来我写的几篇博客：<a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">《计算机那些事(7)——图形图像渲染原理》</a>、<a href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/">iOS 图像渲染原理</a> 都是按照同样的方式做的，受益匪浅。后一篇文章甚至被 CocoaChina 社区转载了，虽然没有稿费，但还是非常开心。</p><p>年末的时候，我开始对编程语言、编程范式起了兴趣。依次看了几本书：《七周七语言》、《函数式编程思维》、《函数式 Swift》。希望新的一年能够继续深入研究编程语言，能够产出几篇博文。</p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p>Flag 还是要立起来的，毕竟明年年底要是要给自己打打脸，清醒地认清自我。</p><ol><li>深入研究编程语言，包括编程范式、实现模式、DSL 等。先列一些书单：<ul><li>《类型和程序设计语言》</li><li>《自制编程语言》</li><li>《领域特定语言》</li><li>《编程语言实现模式》</li><li>…</li></ul></li><li>掌握一些其他的编程语言。</li><li>副业搞起来，通过专利代理人资格考试</li><li>横向发展，学习 Android 开发。</li><li>提升 Linux 基本技能</li><li>做一个全栈项目</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://chuquan.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>KVO 原理详解</title>
    <link href="http://chuquan.me/2018/12/12/kvo-principle/"/>
    <id>http://chuquan.me/2018/12/12/kvo-principle/</id>
    <published>2018-12-12T13:41:59.000Z</published>
    <updated>2019-07-29T14:18:49.498Z</updated>
    
    <content type="html"><![CDATA[<p>KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。<a href="https://github.com/baochuquan/BAOStudy" target="_blank" rel="noopener">源码地址</a></p><h1 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> setupSubviews];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = <span class="number">1</span>;</span><br><span class="line">    p1.age = <span class="number">2</span>;</span><br><span class="line">    p2.age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self 监听 p1 的 age 属性</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupSubviews &#123;</span><br><span class="line">    [<span class="keyword">self</span> setupHeaderView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupHeaderView &#123;</span><br><span class="line">    <span class="keyword">self</span>.headerView.title = <span class="string">@"KVO"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到 %@ 的 %@ 改变了 %@"</span>, object, keyPath,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例对 <code>p1</code> 进行了 KVO 监听，当 <code>p1</code> 发生改变，即调用 <code>observeValueForKeyPath</code> 方法，从而打印以下信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">监听到 &lt;BAOPerson: 0x600003750200&gt; 的 age 改变了 &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 10;</span><br><span class="line">    old = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="KVO-实现原理"><a href="#KVO-实现原理" class="headerlink" title="KVO 实现原理"></a>KVO 实现原理</h1><p>通过上述代码可以发现，一旦 <code>age</code> 属性的值发生改变，就会通知到监听者。我们知道赋值操作都是调用 <code>set</code> 方法，我们可以重写 <code>BAOPerson</code> 类中 <code>age</code> 的 <code>set</code> 方法，观察 KVO 是否是在 <code>set</code> 方法内部做了一些操作来通知监听者。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"override setAge"</span>);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现即使重写了 <code>set</code> 方法，<code>p1</code> 除了调用 <code>set</code> 方法之外还会执行监听者的 <code>observeValueForKeyPath</code> 方法。</p><p>根据上述实验推测：KVO 在运行时对 <code>p1</code> 对象进行了改动，使 <code>p1</code> 对象在调用 <code>setAge</code> 方法时做了一些额外的操作。所以问题出在对象身上，两个对象可能本质上并不一样。下面我们来探索一下 KVO 内部是如何实现的。</p><h1 id="KVO-实现分析"><a href="#KVO-实现分析" class="headerlink" title="KVO 实现分析"></a>KVO 实现分析</h1><p>首先分别在添加 KVO 前后打上断点，以观察添加 KVO 前后 <code>p1</code> 对象有何不同。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-before-after-add-observe.png?x-oss-process=image/resize,w_600" alt=""></p><p>通过打印对象的 <code>isa</code> 指针，我们发现，<code>p1</code> 对象的 <code>isa</code> 指针由之前的指向类对象 <code>BAOPerson</code> 变成了指向类对象 <code>NSKVONotifying_BAOPerson</code>。相应地，<code>p2</code> 对象没有改变。因此我们可以推测，<code>p1</code> 对象的 <code>isa</code> 发生改变后，其执行的 <code>setAge</code> 也发生了改变。</p><p>我们知道，<code>p2</code> 在调用 <code>setAge</code> 方法时，首先会通过 <code>p2</code> 对象的 <code>isa</code> 指针找到 <code>BAOPerson</code> 类对象，然后在类对象中找到 <code>setAge</code> 方法，最终找到方法对应的实现。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo001.png?x-oss-process=image/resize,w_600" alt=""></p><p>但是，<code>p1</code> 对象的 <code>isa</code> 在添加 KVO 之后已经指向了 <code>NSKVONotifying_BAOPerson</code> 类对象，<code>NSKVONotifying_BAOPerson</code> 则是 <code>BAOPerson</code> 的子类。<code>NSKVONotifying_BAOPerson</code> 是 runtime 在运行时生成的。因此，<code>p1</code> 对象在调用 <code>setAge</code> 方法时必然会根据 <code>p1</code> 的 <code>isa</code> 找到 <code>NSKVONotifying_BAOPerson</code>，并在 <code>NSKVONotifying_BAOPerson</code> 中找到 <code>setAge</code> 方法及其实现。</p><p>经查阅资料了解到，<code>NSKVONotifying_BAOPerson</code> 中的 <code>setAge</code> 方法中其实调用了 Foundation 框架中 C 语言函数 <code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code> 内部的操作大致是：首先调用 <code>willChangeValueForKey</code> 方法，然后调用父类的 <code>setAge</code> 方法对成员变量赋值，最后调用 <code>didChangeValueForKey</code> 方法。<code>didChangeValueForKey</code> 方法中会调用监听者的监听方法，最终调用监听者的 <code>observeValueForKeyPath</code> 方法。</p><h1 id="KVO-原理验证"><a href="#KVO-原理验证" class="headerlink" title="KVO 原理验证"></a>KVO 原理验证</h1><p>前面我们已经通过断点打印 <code>isa</code> 指针的方式验证了：<code>p1</code> 对象在添加 KVO 后，其 <code>isa</code> 指针会指向一个通过 runtime 创建的 <code>BAOPerson</code> 的子类 <code>NSKVONotifying_BAOPerson</code>。</p><p>下面我们可以通过打印方法实现的地址来看一下 <code>p1</code> 和 <code>p2</code> 的 <code>setAge</code> 方法实现的地址在添加 KVO 前后有什么变化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过methodForSelector找到方法实现的地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加 KVO 之前 - p1 = %p, p2 = %p"</span>, [p1 methodForSelector: <span class="keyword">@selector</span>(setAge:)], [p2 methodForSelector: <span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加 KVO 之后 - p1 = %p, p2 = %p"</span>, [p1 methodForSelector: <span class="keyword">@selector</span>(setAge:)], [p2 methodForSelector: <span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-name-before-after.png?x-oss-process=image/resize,w_800" alt=""></p><p>执行上述代码，可以发现：在添加 KVO 之前，<code>p1</code> 和 <code>p2</code> 的 <code>setAge</code> 方法实现的地址是相同的；在添加 KVO 之后， <code>p1</code> 的 <code>setAge</code> 方法实现的地址发生了改变。通过打印方法实现可以证明，<code>p1</code> 的 <code>setAge</code> 方法的实现由 <code>BAOPerson</code> 类方法中的 <code>setAge</code> 方法转换成了 Foundation 框架中的 C 函数 <code>_NSSetIntValueAndNotify</code>。</p><p>事实上，Foundation 框架中很多例如 <code>_NSSetBoolValueAndNotify</code>、<code>_NSSetCharValueAndNotify</code>、<code>_NSSetFloatValueAndNotify</code>、<code>_NSSetLongValueAndNotify</code> 等函数。</p><p>为了查看 Foundation 框架中的相关函数，我们找到 Foundation 文件，通过命令行查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-value-and-notify-methods.png?x-oss-process=image/resize,w_600" alt=""></p><h1 id="中间类内部结构"><a href="#中间类内部结构" class="headerlink" title="中间类内部结构"></a>中间类内部结构</h1><p><code>NSKVONotifying_BAOPerson</code> 作为 <code>BAOPerson</code> 的子类，其 <code>superclass</code> 指针指向 <code>BAOPerson</code> 类，其内部对 <code>setAge</code> 方法做了单独的实现，那么 <code>NSKVONotifying_BAOPerson</code> 同 <code>BAOPerson</code> 类的差别可能就在于其内存储的对象方法及实现不同。我们通过 runtime 分别打印 <code>BAOPerson</code> 类对象和 <code>NSKVONotifying_BAOPerson</code> 类对象内存储的对象方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = <span class="number">1</span>;</span><br><span class="line">    p1.age = <span class="number">2</span>;</span><br><span class="line">    p2.age = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p2)];</span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p1)];</span><br><span class="line">    </span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printMethods:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [methodNames appendFormat:<span class="string">@"%@ - "</span>, cls];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        <span class="built_in">NSString</span> *methodName  = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line"></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@" "</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的打印结果如下：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-in-middle-class.png?x-oss-process=image/resize,w_800" alt=""></p><p>可以发现，<code>NSKVONotifying_BAOPerson</code> 中有 4 个对象方法，分别是:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setAge:</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">dealloc</span><br><span class="line">_isKVOA</span><br></pre></td></tr></table></figure></p><p><code>NSKVONotifying_BAOPerson</code> 重写 <code>class</code> 方法是为了隐藏 <code>NSKVONotifying_BAOPerson</code> 不被外界看到。我们在 <code>p1</code> 添加 KVO 之后，分别打印 <code>p1</code> 和 <code>p2</code> 对象的 <code>class</code>，可以发现它们都返回 <code>BAOPerson</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, [p1 <span class="keyword">class</span>], [p2 <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// 打印结果 BAOPerson, BAOPerson</span></span><br></pre></td></tr></table></figure><p>综上，我们可以画出 <code>NSKVONotifying_BAOPerson</code> 的内部结构及方法调用顺序。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo002.png?x-oss-process=image/resize,w_600" alt=""></p><h1 id="验证-didChangeValueForKey-内部调用-observeValueForKeyPath-ofObject-change-context-方法"><a href="#验证-didChangeValueForKey-内部调用-observeValueForKeyPath-ofObject-change-context-方法" class="headerlink" title="验证 didChangeValueForKey: 内部调用 observeValueForKeyPath:ofObject:change:context: 方法"></a>验证 <code>didChangeValueForKey:</code> 内部调用 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法</h1><p>在 <code>BAOPerson</code> 类中重写 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，模拟它们的实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"override setAge"</span>);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey: - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey: - end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey: - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey: - end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行上述代码，可以确定是在 <code>didChangeValueForKey:</code> 方法内部调用了监听者的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-did-change-value-for-key.png?x-oss-process=image/resize,w_600" alt=""></p><p>根据上述原理，可以通过调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 来手动触发 KVO。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5adab70cf265da0b736d37a8" target="_blank" rel="noopener">iOS底层原理总结 - 探寻KVO本质</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。&lt;a href=&quot;https://github.com/baochuquan/BAOStudy&quot; target=&quot;_
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="KVO" scheme="http://chuquan.me/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>GCD 原理详解</title>
    <link href="http://chuquan.me/2018/12/01/gcd-introduce/"/>
    <id>http://chuquan.me/2018/12/01/gcd-introduce/</id>
    <published>2018-12-01T12:55:11.000Z</published>
    <updated>2018-12-01T14:07:37.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h1><p>GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。</p><h1 id="GCD-基本概念"><a href="#GCD-基本概念" class="headerlink" title="GCD 基本概念"></a>GCD 基本概念</h1><p>GCD 主要包含两个核心概念：<strong>任务</strong> 和 <strong>队列</strong>。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p><strong>任务</strong>：即要在线程中执行的那段代码。GCD 将任务定义在 block 中。</p><p>任务的执行主要有两种方式：<strong>同步执行（sync）</strong> 和 <strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列中的任务执行结束，是否具备开启新线程的能力</strong>。因此，根据任务的执行方式可以将任务分成两种类型：</p><p><strong>同步任务（sync）</strong></p><ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul><p><strong>异步任务（async）</strong></p><ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul><blockquote><p>注意： <strong>异步任务（async）</strong> 虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（Dispatch Queue）</strong>：即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic07.png" alt=""></p><p>在 GCD 中有两种队列：<strong>串行队列</strong> 和 <strong>并发队列</strong>。两者的主要区别是：<strong>执行顺序不同，开启线程数不同</strong>。</p><p><strong>串行队列</strong></p><ul><li>每次只有一个任务被执行。（只开启一个线程，一个任务执行完毕后，在执行下一个任务）<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic08.png" alt=""></li></ul><p><strong>并发队列</strong></p><ul><li>允许多个任务（同时）执行。（可以开启多个线程，并同时执行任务）<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic09.png" alt=""></li></ul><blockquote><p>注意：<strong>并发队列</strong> 的并发功能只有在异步（dispatch_async）函数下才有效。</p></blockquote><h1 id="GCD-使用方法"><a href="#GCD-使用方法" class="headerlink" title="GCD 使用方法"></a>GCD 使用方法</h1><p>GCD 的使用主要包含两个步骤：</p><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统会根据任务类型执行任务（同步执行或异步执行）</li></ol><h2 id="队列的创建-获取"><a href="#队列的创建-获取" class="headerlink" title="队列的创建/获取"></a>队列的创建/获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t</span><br><span class="line">dispatch_queue_create(const char *_Nullable label,</span><br><span class="line">dispatch_queue_attr_t _Nullable attr)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>label</code>：表示队列的唯一标识符，用于 DEBUG，可为空。</li><li><code>attr</code>：表示队列的类型。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列；<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><hr><p>对于串行队列，GCD 提供了一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。</p><ul><li><strong>所有放在主队列的任务，都会在主线程执行</strong>。</li><li>可使用 <code>dispatch_get_main_queue()</code> 获取主队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></li></ul><hr><p>对于并发队列，GCD 默认提供了 <strong>全局并发队列（Global Dispatch Queue）</strong>。</p><ul><li>可使用 <code>dispatch_get_global_queue</code> 获取全局并发队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure></li></ul><p>GCD 提供了 4 个 <strong>全局并发队列</strong>，分别对应不同的优先级。</p><ul><li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li><li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li><li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li><li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台队列</li></ul><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>GCD 提供了同步执行任务的创建方法 <code>dispatch_sync</code> 和异步执行任务创建方法 <code>dispatch_async</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="GCD-使用组合"><a href="#GCD-使用组合" class="headerlink" title="GCD 使用组合"></a>GCD 使用组合</h1><p>GCD 有两种队列（串行队列/并发队列），两种任务（同步任务/异步任务），可以得到 4 种不同的使用组合。</p><blockquote><ol><li>同步任务 + 并发队列</li><li>异步任务 + 并发队列</li><li>同步任务 + 串行队列</li><li>异步任务 + 串行队列</li></ol></blockquote><p>实际上，前文还提到两种特殊的队列：全局并发队列、主队列。全局并发队列可作为普通并发队列使用。但是主队列比较特殊，因此又得到 2 种组合：</p><blockquote><ol><li>同步任务 + 主队列</li><li>异步任务 + 主队列</li></ol></blockquote><h2 id="同步执行-并发队列"><a href="#同步执行-并发队列" class="headerlink" title="同步执行 + 并发队列"></a>同步执行 + 并发队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 并发队列</span><br><span class="line"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);          // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic01.png" alt=""></p><p>上图所示为 <code>同步任务 + 并发队列</code> 的工作原理。</p><ul><li><code>syncConcurrent</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至并行队列，并行队列允许多任务同时执行，但由于加入的队列是同步任务，不会开启新线程，在主线程执行。</li><li><code>syncConcurrent</code> 会被同步任务阻塞。</li></ul><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---begin</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---end</span><br></pre></td></tr></table></figure></p><h2 id="异步任务-并发队列"><a href="#异步任务-并发队列" class="headerlink" title="异步任务 + 并发队列"></a>异步任务 + 并发队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 并发队列</span><br><span class="line"> * 特点：可以开启多个线程，任务交替（同时）执行。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic02.png" alt=""></p><p>上图所示为 <code>异步任务 + 并行队列</code> 的工作原理。</p><ul><li><code>asyncConcurrent</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至并行队列，并行队列允许多任务同时执行，且异步任务可以开启新线程，因此每个异步任务都能启动一个独立的线程执行。</li><li><code>asyncConcurrent</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600003e6d580&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncConcurrent---begin</span><br><span class="line">asyncConcurrent---end</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步任务-串行队列"><a href="#同步任务-串行队列" class="headerlink" title="同步任务 + 串行队列"></a>同步任务 + 串行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 串行队列</span><br><span class="line"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic03.png" alt=""></p><p>上图所示为 <code>同步任务 + 串行队列</code> 的工作原理。</p><ul><li><code>syncSerial</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至串行队列，串行队列不允许多任务同时执行，因此同步任务在当前线程执行（主线程）。</li><li><code>syncSerial</code> 会被同步任务阻塞。</li></ul><h2 id="异步任务-串行队列"><a href="#异步任务-串行队列" class="headerlink" title="异步任务 + 串行队列"></a>异步任务 + 串行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 串行队列</span><br><span class="line"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic04.png" alt=""></p><p>上图所示为 <code>异步任务 + 串行队列</code> 的工作原理。</p><ul><li><code>asyncSerial</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至串行队列，异步任务能开启新线程，但是串行队列不允许多任务，所以只能开启一条新线程。</li><li><code>asyncSerial</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600001ef5d00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncSerial---begin</span><br><span class="line">asyncSerial---end</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步任务-主队列"><a href="#同步任务-主队列" class="headerlink" title="同步任务 + 主队列"></a>同步任务 + 主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 主队列</span><br><span class="line"> * 特点(主线程调用)：互等卡主不执行。</span><br><span class="line"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic05.png" alt=""></p><p>上图所示为 <code>同步任务 + 主队列</code> 的工作原理。</p><ul><li><code>syncMain</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至主队列，同步任务不会开启新线程，且主队列（属于串行队列）中的任务只能在主线程执行。</li><li><code>syncMain</code> 会被同步任务阻塞。但是需要注意的是 <code>syncMain</code> 和同步任务均在主队列中，同步任务需要等待 <code>syncMain</code> 执行完毕，因此产生死锁。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">崩溃</span><br></pre></td></tr></table></figure></p><p>对于这种情况，可以将 <code>syncMain</code> 放置新线程执行以避免产生死锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure></p><h2 id="异步任务-主队列"><a href="#异步任务-主队列" class="headerlink" title="异步任务 + 主队列"></a>异步任务 + 主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 主队列</span><br><span class="line"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic06.png" alt=""></p><p>上图所示为 <code>异步任务 + 主队列</code> 的工作原理。</p><ul><li><code>asyncMain</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至主队列，异步任务能开启新线程，但是主队列（属于串行队列）中的任务只能在主线程执行。</li><li><code>asyncMain</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncMain---begin</span><br><span class="line">asyncMain---end</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p><h1 id="GCD-应用"><a href="#GCD-应用" class="headerlink" title="GCD 应用"></a>GCD 应用</h1><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic10.png" alt=""></p><p>上图所示为线程间通信的工作原理。</p><ul><li><code>communication</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至全局队列（并行队列），异步任务能开启新线程，因此异步任务在新线程执行。</li><li><code>communication</code> 不会被异步任务阻塞。</li><li>当异步任务执行完成后，再将一个异步任务添加至主队列，主队列中的任务都在主线程执行，所以该异步任务在主线程执行。从而达到线程间通信的目的。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000022ddd00&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a></li><li><a href="https://www.jianshu.com/p/fbe6a654604c" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCD-简介&quot;&gt;&lt;a href=&quot;#GCD-简介&quot; class=&quot;headerlink&quot; title=&quot;GCD 简介&quot;&gt;&lt;/a&gt;GCD 简介&lt;/h1&gt;&lt;p&gt;GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="GCD" scheme="http://chuquan.me/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 关联对象与 Method Swizzling</title>
    <link href="http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/"/>
    <id>http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/</id>
    <published>2018-11-23T11:39:37.000Z</published>
    <updated>2018-11-23T11:44:54.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h1><p>关联对象，顾名思义，即通过唯一键（<code>key</code>）连接（关联）至某个类的实例上的对象。</p><p>那么什么时候会用到关联对象呢？</p><p>比如，我们需要对内置类 <code>NSArray</code> 添加一个属性（不使用继承）。如何解决？分类似乎只能添加方法。当我们了解关联对象后，就可以轻松实现。</p><h2 id="关联对象基础"><a href="#关联对象基础" class="headerlink" title="关联对象基础"></a>关联对象基础</h2><h3 id="设置关联对象"><a href="#设置关联对象" class="headerlink" title="设置关联对象"></a>设置关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是 <code>self</code></li><li><code>key</code>: 唯一键，在获取值时通过该键获取，通常是使用 <code>static const void *</code> 来声明</li><li><code>value</code>: 关联所设置的值</li><li><code>policy</code>: 内存管理策略</li></ul><h4 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,             // 表示弱引用关联，通常是基本数据类型</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,   // 表示强引用关联对象，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,     // 表示关联对象copy，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,         // 表示强引用关联对象，不是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403            // 表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象释放时，会根据设置关联对象时采用的策略来决定是否释放关联对象。当策略为 <code>RETAIN/COPY</code> 时，释放关联对象。当策略为 <code>ASSIGN</code> 时，不释放关联对象。</p><h3 id="获取关联对象"><a href="#获取关联对象" class="headerlink" title="获取关联对象"></a>获取关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是传 <code>self</code>，在设置关联时所指定的与哪个对象关联的那个对象</li><li><code>key</code>: 唯一键，在设置关联值所指定的键</li></ul><h3 id="取消关联对象"><a href="#取消关联对象" class="headerlink" title="取消关联对象"></a>取消关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure><p>取消对象的所有关联对象。如果要取消指定的关联对象，可使用 <code>setAssociatedObject</code> 设置为 <code>nil</code> 来实现。</p><h2 id="关联对象应用"><a href="#关联对象应用" class="headerlink" title="关联对象应用"></a>关联对象应用</h2><p>给 <code>UIViewController</code> 添加一个是否需要登录的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL needToLogin;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const char *ViewControllerNeedToLoginKey = &quot;ViewControllerNeedToLoginKey&quot;;</span><br><span class="line"></span><br><span class="line">- (void)setNeedToLogin:(BOOL)needToLogin &#123;</span><br><span class="line">    objc_setAssociatedObject(self, ViewControllerNeedToLoginKey, @(needToLogin), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)needToLogin &#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, ViewControllerNeedToLoginKey) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><p>Method Swizzling，顾名思义，就是将两个方法的实现交换。</p><p>那么什么时候会用到 Method Swizzling 呢？</p><p>比如，在开发中，我们可能会遇到系统提供的 API 不能满足实际需求。我们希望能够修改它以达到期望的效果。</p><h2 id="Method-Swizzling-原理"><a href="#Method-Swizzling-原理" class="headerlink" title="Method Swizzling 原理"></a>Method Swizzling 原理</h2><p>Method Swizzling 的实现充分利用了 <a href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C runtime 动态绑定机制</a>。</p><p>在 Objective-C 中调用方法，其实是向一个对象发送消息，而查找消息的唯一依据是方法名 <code>selector</code>。每个类都有一个方法列表 <code>objc_method_list</code>，存放着其所有的方法 <code>objc_method</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法 <code>objc_method</code> 保存了方法名（<code>SEL</code>）和方法实现（<code>IMP</code>）的映射关系。Method Swizzling 其实就是重置了 <code>SEL</code> 和 <code>IMP</code> 的映射关系。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-method-swizzling.png" alt=""></p><h2 id="Method-Swizzling-基础"><a href="#Method-Swizzling-基础" class="headerlink" title="Method Swizzling 基础"></a>Method Swizzling 基础</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 方法名</li></ul><h3 id="获取方法实现"><a href="#获取方法实现" class="headerlink" title="获取方法实现"></a>获取方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nonnull class_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 要添加方法的方法名</li><li><code>imp</code>: 要添加方法的方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nullable class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 目标方法的方法名</li><li><code>imp</code>: 方法的新方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="交换方法实现"><a href="#交换方法实现" class="headerlink" title="交换方法实现"></a>交换方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h3 id="获取方法的编码类型"><a href="#获取方法的编码类型" class="headerlink" title="获取方法的编码类型"></a>获取方法的编码类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * _Nullable method_getTypeEncoding(Method _Nonnull m)</span><br></pre></td></tr></table></figure><h2 id="Method-Swizzling-应用"><a href="#Method-Swizzling-应用" class="headerlink" title="Method Swizzling 应用"></a>Method Swizzling 应用</h2><p>通过分类允许 <code>NSObject</code> 对任意两个方法进行 Method Swizzling。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSEL);</span><br><span class="line">    if (originalMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(self, targetSEL);</span><br><span class="line">    if (targetMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_addMethod(self, originalSEL, class_getMethodImplementation(self, originalSEL), method_getTypeEncoding(originalMethod));</span><br><span class="line">    class_addMethod(self, targetSEL, class_getMethodImplementation(self, targetSEL), method_getTypeEncoding(targetMethod));</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod(self, originalSEL), class_getInstanceMethod(self, targetSEL));</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Class metaClass = object_getClass((id)self);</span><br><span class="line">    return [metaClass swizzleMethod:originalSEL withMethod:targetSEL error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/c68cc81ef763" target="_blank" rel="noopener">iOS runtime实战应用：关联对象</a></li><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h1&gt;&lt;p&gt;关联对象，顾名思义，即通过唯一键（&lt;code&gt;key&lt;/code&gt;）连接（关联）至某个类的实例上的对象。&lt;/p&gt;
&lt;p&gt;那么
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="关联对象" scheme="http://chuquan.me/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Method Swizzling" scheme="http://chuquan.me/tags/Method-Swizzling/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯·圣彼得堡之旅</title>
    <link href="http://chuquan.me/2018/11/03/st-petersburg/"/>
    <id>http://chuquan.me/2018/11/03/st-petersburg/</id>
    <published>2018-11-03T13:00:47.000Z</published>
    <updated>2018-11-20T14:18:45.563Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400" alt=""></div><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5261430&auto=1&height=66"></iframe><p>盼了一年，终于盼来了公司的年度旅行。经过两轮的投票角逐，圣彼得堡众望所归！旅行时间计划是 10 月 27 日~ 11 月1 日，总共 6 天。我们此次行程总共 29 人，走团签，使用公司的旅行基金，每个人额外补贴 1020 元。</p><p>出发前两天，我花了两个晚上做了一下圣彼得堡的旅行攻略。首先，定位各个推荐景点和餐厅的位置，做到心里有点逼数。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg003.png?x-oss-process=image/resize,w_800" alt=""></p><p>然后，综合日期、天气、距离、开/闭馆等情况（圣彼得堡有不少景点会周期性地选择闭馆），做了一个大致的行程计划。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg002.png?x-oss-process=image/resize,w_500" alt=""></p><h1 id="Day-1（周六）"><a href="#Day-1（周六）" class="headerlink" title="Day 1（周六）"></a>Day 1（周六）</h1><p>前一天周五，我们照常上班，部分人（包括我）选择在公司一直待到凌晨，然后一起打车去机场。服务器一帮人去附近的网吧开黑，客户端则在公司打升级，玩任天堂游戏。我在 B 站上看了几个关于圣彼得堡的纪录片。对我来说，旅行中很大一部分乐趣是源自于旅行前的准备工作。</p><p>北京时间凌晨五点，我们从 T3 航站楼启程飞往新西伯利亚。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg004.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg008.png?x-oss-process=image/resize,w_800" alt=""></p><p>经过四个半小时的飞行，飞越了数千公里的冰川，最终抵达新西伯利亚。降落前，从新西伯利亚上空俯瞰整个城市，第一感觉便是衰败。这与我的预期完全不符，心里难免有一些失落。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg005.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg006.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg007.png?x-oss-process=image/resize,w_500" alt=""></p><p>在新西伯利亚机场转机等待了近2个小时，我们踏上了飞往圣彼得堡的行程。经历四个半小时，飞机成功降落于圣彼得堡普尔科沃机场，机舱里响起来热烈的掌声。</p><p>导游和大巴早已在机场等候多时，安置好行李后，我们从机场出发。沿着机场高速，经过跨海大桥，最终抵达我们位于瓦西里岛上的 Park inn 酒店。安排完入住后已经差不多下午2点多了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg009.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg010.png" alt=""></p><p>在客房稍事休息，洗漱一下，我们（@大龙哥，@邱老师，@张成）便出门去逛附近的超市。买了烤鸡、黄瓜、香蕉、面包、啤酒、果汁，然后便是回酒店嗨。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg011.png" alt=""></p><p>来圣彼得堡之前，我听说酒店有游泳池。于是晚上一闲下来，便在酒店一楼大厅瞎转，找游泳池。大厅绕了一圈，一对青年毛子情侣看到了我，小哥立马过来跟我尬聊了起来。小哥用带卷舌的英语，我用蹩脚的 Chinglish。聊了二十分钟，我还是没明白他到底想表达什么。。。</p><h1 id="Day-2（周日）"><a href="#Day-2（周日）" class="headerlink" title="Day 2（周日）"></a>Day 2（周日）</h1><p>一大早起来，打开窗帘，外面已然是白茫茫一片。天气与预期一样，那么计划也是一样。今天行程是冬宫。</p><p>来圣彼得堡之前，我们便以在飞猪上购买了电子票。冬宫早上10点半开放，我们分了好几拨，早早便抵达了冬宫快速通道门口。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg012.png" alt=""></p><p>我们差不多画了5个小时的时间走马观花地逛了一遍冬宫。一楼是古埃及相关的展厅，我没怎么逛。二楼是沙俄以及西方中世纪的一些展品。三楼主要东方的一些展品。二楼的展品尤为绚烂，其中包括两幅达芬奇的真迹（世界仅存14副真迹）。果然不愧为世界四大博物馆，不禁感慨如果圆明园未毁，也许可以与其相媲美。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg013.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg016.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg017.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg015.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg014.png" alt=""></p><p>逛完冬宫差不多已经下午三点半了，早已饥渴难耐，我们打车去附近一家小餐厅Varvara。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg018.png" alt=""></p><p>简餐过后，我们沿着涅瓦大街闲逛，欣赏一下沿途的风景。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg019.png" alt=""></p><h1 id="Day3（周一）"><a href="#Day3（周一）" class="headerlink" title="Day3（周一）"></a>Day3（周一）</h1><p>今天计划的第一站是圣以撒大教堂。刚刚抵达圣以撒大教堂，便遇到一群当地的小孩，冲着我们喊“你好”。尴尬的是我们居然不知道“你好”用俄语怎么说，只能也挥手喊着“你好”予以回应。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg020.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg021.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg022.png" alt=""></p><p>圣以撒大教堂可以允许游客登顶观光，俯瞰整个圣彼得堡。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg023.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg026.png" alt=""></p><p>与圣以撒大教堂合完影之后，我们便步行向北前往十二月党人广场，广场的中央是彼得大帝青铜骑士像。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg024.png" alt=""></p><p>在广场逗留了一会儿，大家分头行动，我们（@邱老师，@大龙哥，@刘杨）决定去救世主滴血大教堂。抵达滴血大教堂，有一些一行，教堂的洋葱头正在维修，据说从去年至今一直在维修。不过教堂的内饰真的是美轮美奂，所有的壁画都是用指甲大小的马赛克拼接而成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg027.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg025.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg028.png?x-oss-process=image/resize,w_500" alt=""></p><p>救世主滴血大教堂参观完毕，我们（@吴迪，@海侠，@大龙哥，@邱老师，@刘杨）来到了涅瓦大街吃午餐。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg030.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg029.png" alt=""></p><p>吃完饭，我们在旁边的纪念品店里逛了一会儿，然后他们准备去商场购物。而我则打算去马路对面的喀山大教堂去拍照。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg032.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg031.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg034.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg033.png?x-oss-process=image/resize,w_500" alt=""></p><p>拍完照，我便独自向我们约定的商场步行而去，与大家汇合。</p><h1 id="Day4（周二）"><a href="#Day4（周二）" class="headerlink" title="Day4（周二）"></a>Day4（周二）</h1><p>雪后第一天尤其寒冷，今天的计划则是去彼得保罗要塞观光。彼得堡罗要塞其实就是一个小岛，岛上有监狱（曾关押过高尔基）、教堂（埋葬了历代沙皇）、博物馆，我们也是挨个儿参观了一遍。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg035.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg037.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg036.png" alt=""></p><p>差不多下午一点参观完各个景点，我们在一个小博物馆里逗留了一会儿，然后决定去岛上的一家推荐餐厅。餐厅位于小岛的西边，迎着涅瓦河。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg039.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg038.png" alt=""></p><p>餐后，大家决定一起去看阿芙乐尔号巡洋舰。在路上顶着寒风大概走了半个小时终于到了阿芙乐尔号巡洋舰的地址。参观的总体感觉是比较坑，门票大约70元人民币，比冬宫还贵。里面只有一个小小的博物馆而已。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg040.png" alt=""></p><h1 id="Day5（周三）"><a href="#Day5（周三）" class="headerlink" title="Day5（周三）"></a>Day5（周三）</h1><p>昨天在去往阿芙乐尔号的路上简直被吹成了傻逼，对于今天去叶卡捷琳娜宫的计划我有些犹豫。“既然都来了，就去看看吧”这样的念头促成我又做了一次傻逼的决定。叶卡捷琳娜宫只在下午一点后对散客开放，并且每15分钟放入20来人。我们上午到叶宫，在前面的花园里逛了一圈。差不多下午一点，到叶宫入口排队。寒风中吹了近两个小时才进入叶宫。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg041.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg042.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg043.png" alt=""></p><p>说实话，叶宫真心无法与冬宫相比，除了琥珀宫，里面基本都是些宴会大厅。另外，加上这几天的行程，基本已经属于审美疲劳状态。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg044.png" alt=""></p><h1 id="Day5（周四）"><a href="#Day5（周四）" class="headerlink" title="Day5（周四）"></a>Day5（周四）</h1><p>早上10:20在酒店大厅集合去机场。第一次来俄罗斯，并且是有如此浓厚艺术气息的圣彼得堡，虽然旅程很短暂，但是内心很满足。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="游记" scheme="http://chuquan.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="自由行" scheme="http://chuquan.me/tags/%E8%87%AA%E7%94%B1%E8%A1%8C/"/>
    
      <category term="俄罗斯" scheme="http://chuquan.me/tags/%E4%BF%84%E7%BD%97%E6%96%AF/"/>
    
      <category term="圣彼得堡" scheme="http://chuquan.me/tags/%E5%9C%A3%E5%BD%BC%E5%BE%97%E5%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 消息传递与转发</title>
    <link href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/"/>
    <id>http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/</id>
    <published>2018-10-20T09:15:32.000Z</published>
    <updated>2018-11-27T13:04:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，在 C 语言的基础上实现了面向对象的功能。在 runtime 中，对象用结构体表示，方法用函数表示。</p><p>C 语言是一门静态语言，其在编译时决定调用哪个函数。而 Objective-C 则是一门动态语言，其在编译时不能决定最终执行时调用哪个函数（Objective-C 中函数调用称为消息传递）。Objective-C 的这种动态绑定机制正是通过 runtime 这样一个中间层实现的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-runtime-hierachry.png?x-oss-process=image/resize,w_300" alt=""></p><p>为了分析 runtime 是如何进行动态绑定，我们首先需要了解一下 Objective-C 中类与对象等基本结构在 C 语言层面是如何实现的。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Objective-C-类"><a href="#Objective-C-类" class="headerlink" title="Objective-C 类"></a>Objective-C 类</h2><p>Objective-C 类是由 <code>Class</code> 类型表示的，它本质上是一个指向 <code>objc_class</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line"></span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure></p><h2 id="Objective-C-对象"><a href="#Objective-C-对象" class="headerlink" title="Objective-C 对象"></a>Objective-C 对象</h2><p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向 <code>objc_object</code> 结构体的指针。如下所示为 <code>objc/objc.h</code> 中关于对象的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>objc_object</code> 结构体中只有一个成员，即指向其类的 <code>isa</code> 指针。<strong>当向一个 Objective-C 对象发送消息时，runtime 会根据实例对象的 <code>isa</code> 指针找到其所属的类。Runtime 会在类的方法列表以及父类的方法列表中去寻找与消息对应的 <code>selector</code> 指向的方法，找到后即运行该方法。</strong></p><h2 id="Objective-C-元类（meta-class）"><a href="#Objective-C-元类（meta-class）" class="headerlink" title="Objective-C 元类（meta class）"></a>Objective-C 元类（meta class）</h2><p><code>meta-class</code> 是一个<strong>类对象的类</strong>。在 Objective-C 中，所有的类本身也是一个对象。事实上，在很多原型编程语言也采用这种“万物皆对象”的设计思想，如：Io。</p><p>通过向该对象发送消息，即可实现对类方法的调用。前提是类的 <code>isa</code> 指针必须指向一个包含这些类方法的 <code>objc_class</code> 结构体。<code>meta-class</code> 中存储着一个类的所有类方法。所以，类对象的 <code>isa</code> 指针指向的就是 <code>meta-class</code>。</p><ul><li><strong>当向一个对象发送消息时，runtime 会在这个对象所属的类的方法列表中查找方法。</strong></li><li><strong>当向一个类发送消息时，runtime 会在这个类的 meta-class 的方法列表中查找。</strong></li></ul><p>思考一下，<code>meta-class</code> 也是一个类，也可以向它发送一个消息，那么它的 <code>isa</code> 又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C 的设计者让所有的 <code>meta-class</code> 的 <code>isa</code> 指向基类的 <code>meta-class</code>，以此作为它们的所属类。</p><p>下图所示，为 Objective-C 对象在内存中的引用关系图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-time-message-send.png" alt=""></p><h2 id="Objective-C-方法"><a href="#Objective-C-方法" class="headerlink" title="Objective-C 方法"></a>Objective-C 方法</h2><p>方法实际上是一个指向 <code>objc_method</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体中包含成员 <code>SEL</code> 和 <code>IMP</code>，两者将方法的名字与实现进行了绑定。通过 <code>SEL</code>，可以找到对应的 <code>IMP</code>，从而调用方法的具体实现。</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>SEL</code> 又称选择器，是一个指向 <code>objc_selector</code> 结构体的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>方法的 <code>selector</code> 用于表示运行时方法的名字。<strong>Objective-C 在编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ <code>Int</code> 类型的地址），即 <code>SEL</code>。</strong></p><p>由于一个类的方法列表中不能存在两个相同的 <code>SEL</code>，所以 Objective-C 不支持重载。但是不同类之间可以存在相同的 <code>SEL</code>，因为不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中去根据 <code>selector</code> 去寻找自己对应的 <code>IMP</code>。</p><p>通过下面三种方法可以获取 <code>SEL</code>：</p><ul><li><code>sel_registerName</code> 函数</li><li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li><li><code>NSSeletorFromString()</code> 方法</li></ul><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code> 本质上就是一个函数指针，指向方法实现的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL,...);</span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><code>id</code>：指向 <code>self</code> 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）</li><li><code>SEL</code>：方法选择器</li><li><code>...</code>：方法的参数列表</li></ul><p><code>SEL</code> 与 <code>IMP</code> 的关系类似于哈希表中 <code>key</code> 与 <code>value</code> 的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p><h1 id="消息传递（方法调用）"><a href="#消息传递（方法调用）" class="headerlink" title="消息传递（方法调用）"></a>消息传递（方法调用）</h1><p>在 Objective-C 中，<strong>消息直到运行时才绑定到方法实现上</strong>。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息函数的调用，即 <code>objc_msgSend</code>。这个函数将消息接收者和方法名作为主要参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)                    // 不带参数</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)    // 带参数</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 通过以下几个步骤实现了动态绑定机制。</p><ul><li>首先，获取 <code>selector</code> 指向的方法实现。由于相同的方法可能在不同的类中有着不同的实现，因此根据 <code>receiver</code> 所属的类进行判断。</li><li>其次，传递 <code>receiver</code> 对象、方法指定的参数来调用方法实现。</li><li>最后，返回方法实现的返回值。</li></ul><p>消息传递的关键在于前文讨论过的 <code>objc_class</code> 结构体，其有两个关键的字段：</p><ul><li><code>isa</code>：指向父类的指针</li><li><code>methodLists</code>: 类的方法分发表（<code>dispatch table</code>）</li></ul><p>当创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 <code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承链。</p><p>下图所示为消息传递过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-messaging-framework.png" alt=""></p><ul><li>当消息传递给一个对象时，首先从运行时系统缓存 <code>objc_cache</code> 中进行查找。如果找到，则执行。否则，继续执行下面步骤。</li><li><code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法分发表 <code>methodLists</code> 中查找方法的 <code>selector</code>。如果未找到，将沿着类的 <code>isa</code> 找到其父类，并在父类的分发表 <code>methodLists</code> 中继续查找。</li><li>以此类推，一直沿着类的继承链追溯至 <code>NSObject</code> 类。一旦找到 <code>selector</code>，传入相应的参数来执行方法的具体实现，并将该方法加入缓存 <code>objc_cache</code> 。如果最后仍然没有找到 <code>selector</code>，则会进入<strong>消息转发</strong>流程（下文将进行介绍）。</li></ul><h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>当一个对象能接收一个消息时，会走正常的消息传递流程。当一个对象无法接收某一消息时，会发生什么呢？默认情况下，如果以 <code>[object message]</code> 的形式调用方法，如果 <code>object</code> 无法响应 <code>message</code> 消息时，编译器会报错。如果是以 <code>performSeletor:</code> 的形式调用方法，则需要等到运行时才能确定 <code>object</code> 是否能接收 <code>message</code> 消息。如果不能，则程序崩溃。</p><p>对于后者，当不确定一个对象是否能接收某个消息时，可以调用 <code>respondsToSelector:</code> 来进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，当一个对象无法接收某一消息时，就会启动所谓“消息转发（message forwarding）”机制。通过消息转发机制，我们可以告诉对象如何处理未知的消息。</p><p>消息转发机制大致可分为三个步骤：</p><ul><li>动态方法解析（Dynamic Method Resolution）</li><li>备用接收者</li><li>完整消息转发</li></ul><p>下图所示为消息转发过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/ios-message-forwarding.png" alt=""></p><h2 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h2><p>对象在接收到未知的消息时，首先会调用所属类的类方法 <code>+resolveClassMethod:</code> 或实例方法 <code>+resolveInstanceMethod:</code>。</p><p>在这两个方法中，我们可以为未知消息新增一个“处理方法”，通过运行时 <code>class_addMethod</code> 函数动态添加到类中。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // 方法实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方案更多的是为了实现@dynamic属性。</p><h2 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h2><p>如果在上一步无法处理消息，则 runtime 会继续调用 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p><p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是 <code>self</code>） 的对象，则这个对象会称为消息的新接收者，消息会被分发到这个对象。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([selString isEqualToString:@&quot;walk&quot;]) &#123;</span><br><span class="line">        return self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><h2 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h2><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>这步调用 <code>methodSignatureForSelector</code> 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 <code>nil</code>，则说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;  </span><br><span class="line">    return [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回 <code>methodSignature</code>，则进入 <code>forwardInvocation</code>。对象会创建一个表示消息的 <code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在 <code>anInvocation</code> 中，包括 <code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以利用备用接受者和完整消息转发实现对接受消息对象的转移，可以实现“多重继承”的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">Objective-C Runtime · 笔试面试知识整理</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li><li><a href="https://www.jianshu.com/p/f493bc6a949e" target="_blank" rel="noopener">iOS内功篇：runtime</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://chuquan.me/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Run Loop 原理详解</title>
    <link href="http://chuquan.me/2018/10/06/understand-ios-runloop/"/>
    <id>http://chuquan.me/2018/10/06/understand-ios-runloop/</id>
    <published>2018-10-06T12:08:25.000Z</published>
    <updated>2019-06-16T12:39:13.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或框架中，需要实现一种这样机制：线程能够随时处理事件或消息，并且不会在执行完成后退出。这种机制称为 Event Loop，其一般逻辑吐下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function main</span><br><span class="line">    initialize()</span><br><span class="line">    while message != quit</span><br><span class="line">        message := get_next_message()</span><br><span class="line">        process_message(message)</span><br><span class="line">    end while</span><br><span class="line">end function</span><br></pre></td></tr></table></figure><p>Event Loop 在很多系统或框架中都有对应的实现，如 Node.js 的事件处理，Windows 程序的消息循环，OSX/iOS 中的 RunLoop。实现这种机制的关键在于：如何管理事件/消息，如何让线程在没有处理任务时休眠以避免资源占用，如何在事件/消息到来时唤醒。</p><h1 id="Run-Loop"><a href="#Run-Loop" class="headerlink" title="Run Loop"></a>Run Loop</h1><p>Run Loop 是 OSX/iOS 平台下对 Event Loop 机制的一种实现。当没有事件/消息时，Run Loop 进入休眠状态。当有事件/消息时，Run Loop 调用对应的 Handler 进行处理。如下图所示为 Run Loop 的工作模式示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop.png" alt=""></p><p>由上图可知，Run Loop 从 <strong>Input sources</strong> 和 <strong>Timer sources</strong> 接收事件，然后在线程中处理。</p><p>Run Loop 本质上就是一个对象，其管理需要处理的事件/消息，并提供一个入口函数来执行上面 Event Loop 的逻辑。线程执行该函数后，会一直处于其内部的“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环中，直到循环结束（比如传入 <code>quit</code> 的消息），函数返回。</p><p>OSX/iOS 中提供了两种 Run Loop 的实现：</p><ul><li><code>CFRunLoopRef</code>：CoreFoundation 框架对于 Run Loop 的实现，其提供纯 C 函数的 API（线程安全）。</li><li><code>NSRunLoop</code>：基于 <code>CFRunLoopRef</code> 的封装，其提供面向对象的 API（非线程安全）。</li></ul><h1 id="Run-Loop-与线程"><a href="#Run-Loop-与线程" class="headerlink" title="Run Loop 与线程"></a>Run Loop 与线程</h1><p>Run Loop 和线程是一一对应的。每个线程（包括主线程）都有一个对应的 Run Loop 对象。Run Loop 对象的创建发生在第一次获取时（如果不主动获取，它一直都不会被创建）；Run Loop 对象的销毁发生在线程结束时。</p><p>用户无法创建 Run Loop 对象，但可以获取系统提供的 Run Loop 对象。注意：<strong>只能在一个线程的内部获取其 Run Loop 对象，主线程不受限制</strong>。</p><p>关于 Run Loop 的启动，主线程的 Run Loop 在应用启动时自动启动，其他线程的 Run Loop 默认不会自动启动，需手动启动。</p><h1 id="Run-Loop-Source"><a href="#Run-Loop-Source" class="headerlink" title="Run Loop Source"></a>Run Loop Source</h1><p>从上面 Run Loop 工作模式示意图中可知，Run Loop 有两种接收事件的渠道：Input Source、Timer Source。</p><h2 id="Input-Source"><a href="#Input-Source" class="headerlink" title="Input Source"></a>Input Source</h2><p>Input Source 可分为两类：</p><ul><li><code>Custom Input Sources</code>（<code>Source0</code>）：用户自定义的事件，不会主动触发事件，也不会主动唤醒 Run Loop 的线程。如：<code>UIEvent</code>、<code>CFSocket</code>、普通函数调用、系统调用等。</li><li><code>Port-Based Sources</code>（<code>Source1</code>）：系统底层的 Port 事件（Mac Port），如 <code>CFMachPort</code>，<code>CFMessagePort</code>。一般用于通过内核和其他线程相互发送消息，应用层很少使用。这种 Source 可以主动唤醒 Run Loop 的线程。</li></ul><h2 id="Timer-Source"><a href="#Timer-Source" class="headerlink" title="Timer Source"></a>Timer Source</h2><p>Timer Source 即定时器事件。本质上仍然属于 <code>Port-Based Source</code>，所有的 Timer 都共用一个端口“Mode Timer Port”。</p><h1 id="Run-Loop-Observer"><a href="#Run-Loop-Observer" class="headerlink" title="Run Loop Observer"></a>Run Loop Observer</h1><p>Run Loop 通过监控 Source 来决定是否执行处理程序。而 Runloop Observer 则监控 Runloop 本身的状态。 Runloop Observer 可监控的 runloop 事件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0),   // 即将进入 Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1),   // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6),   // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7),   // 即将退出 Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Run-Loop-Mode"><a href="#Run-Loop-Mode" class="headerlink" title="Run Loop Mode"></a>Run Loop Mode</h1><p>Run Loop Mode 即 Run Loop 工作模式。苹果文档中定义了 5 种 Mode：</p><ul><li><code>NSDefaultRunLoopMode</code></li><li><code>NSConnectionReplyMode</code></li><li><code>NSModalPanelRunLoopMode</code></li><li><code>NSEventTrackingRunLoopMode</code></li><li><code>NSRunLoopCommonModes</code></li></ul><p>iOS 中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和 <code>NSRunLoopCommonModes</code>。 <code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-mode.png" alt=""></p><p>一个 Run Loop 可以包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。Run Loop 在某个时刻只能工作在一个 Mode 下，处理该 Mode 中的 Source/Timer/Observer。如果需要切换 Mode，只能退出 Run Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，使其互不影响。</p><p>如下所示为 Run Loop Mode 和 Run Loop 的部分源码定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">  </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Source/Timer/Observer 被统称为 <code>Mode Item</code>，一个 Item 可以被同时加入多个 Mode。但一个 Item 被重复加入同一个 Mode 时是不会有效果的。如果一个 Mode 中一个 Item 都没有，则 Run Loop 会直接退出，不进入“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环。</p><h2 id="Common-Mode"><a href="#Common-Mode" class="headerlink" title="Common Mode"></a>Common Mode</h2><p>一个 Mode 可以将自己标记为 <code>Common</code>（通过将其 Mode Name 添加到 Run Loop 的 <code>_commonModes</code> 中）。<strong>每当 Run Loop 内容发生变化，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode 里</strong>。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>主线程的 Run Loop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为 <code>Common</code>。<code>kCFRunLoopDefaultMode</code> 是 App 平时所处的状态，<code>UITrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当创建一个 Timer 并加到 <code>kCFRunLoopDefaultMode</code> 时，Timer 会得到重复回调，但此时滑动 TableView 时，Run Loop 会将 Mode 切换为 <code>UITrackingRunLoopMode</code>。这是系统为了保持滑动流畅而做出的 Mode 切换。但这会导致 Timer 不被回调。</p><p>为了让 Timer 能在这两种 Mode 下都能得到回调，有 3 种解决方案：</p><ol><li>将 Timer 分别加入两种 Mode</li><li>将 Timer 加入 Run Loop 的 <code>_commonModeItems</code> 中。因为，Run Loop 发生变化时，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode 里。</li><li>在另一个线程执行和处理 Timer 事件，然后在主线程更新 UI。</li></ol><h1 id="Run-Loop-工作流程"><a href="#Run-Loop-工作流程" class="headerlink" title="Run Loop 工作流程"></a>Run Loop 工作流程</h1><p>下图所示为 Run Loop 工作流程示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-internal-logic.png" alt=""></p><p>如下所示为 Run Loop 工作流程的核心代码整理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">     </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">     </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">  </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// ? 一个基于 port 的Source 的事件。</span><br><span class="line">            /// ? 一个 Timer 到时间了</span><br><span class="line">            /// ? RunLoop 自身的超时时间到了</span><br><span class="line">            /// ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">             </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其内部是一个 do-while 循环。当调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于-Run-Loop-的系统功能"><a href="#基于-Run-Loop-的系统功能" class="headerlink" title="基于 Run Loop 的系统功能"></a>基于 Run Loop 的系统功能</h1><p>如下所示为 App 启动后 Run Loop 的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>modes</code> 成员的状态可知，系统默认注册了 5 个 Mode：</p><ul><li><code>kCFRunLoopDefaultMode</code>：App 的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li><code>UITrackingRunLoopMode</code>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li><code>UIInitializationRunLoopMode</code>：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。</li><li><code>GSEventReceiveRunLoopMode</code>：接收系统事件的内部 Mode，通常用不到。</li><li><code>kCFRunLoopCommonModes</code>：占位的 Mode，无实际作用。</li></ul><h2 id="AutoReleasePool"><a href="#AutoReleasePool" class="headerlink" title="AutoReleasePool"></a>AutoReleasePool</h2><p>App 启动后，系统在主线程 Run Loop 中注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p><p>第一个 Observer 监听了一个事件：</p><ul><li><strong>kCFRunLoopEntry</strong>（即将进入 Loop）：调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，优先级最高，保证在其他所有回调之前创建。</li></ul><p>第二个 Observer 监听了两个事件： </p><ul><li><strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）：调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧池并创建新池。</li><li><strong>kCFRunLoopExit</strong>（即将退出 Loop）：调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。其 order 是 2147483647，优先级最低，保证在其他所有回调之后释放。</li></ul><p>事件回调、Timer 回调一般在主线程执行。这些回调会被 Run Loop 创建的 AutoreleasePool 所环绕，所以不会出现内存泄漏，开发者也不必显式创建自动释放池。</p><h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个 Source1（Mach Port）用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键（锁屏/静音等）、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括：识别 UIGesture、处理屏幕旋转、发送给 UIWindow 等。在此回调中完成的事件包括：UIButton 点击、touchesBegin/Move/End/Cancel 事件等。</p><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）事件，这个 Observer 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p><p>当有 UIGestureRecognizer 的变化（创建/销毁/状态改变）时，这个回调都会进行相应处理。</p><h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠） 和 <strong>kCFRunLoopExit</strong>（即将退出 Loop），回调执行的函数会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 Run Loop 后，Run Loop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20 这几个时间点。Run Loop为了节省资源，并不会在非常准确的时间点回调 Timer。Timer 有个属性叫做 Tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p><h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">Run Loops</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html" target="_blank" rel="noopener">RunLoop</a></li><li><a href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/" target="_blank" rel="noopener">@autoreleasepool-内存的分配与释放</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop&quot;&gt;&lt;/a&gt;Event Loop&lt;/h1&gt;&lt;p&gt;通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Run Loop" scheme="http://chuquan.me/tags/Run-Loop/"/>
    
  </entry>
  
  <entry>
    <title>iOS 图像渲染原理</title>
    <link href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/"/>
    <id>http://chuquan.me/2018/09/25/ios-graphics-render-principle/</id>
    <published>2018-09-24T16:24:50.000Z</published>
    <updated>2018-09-24T16:27:15.787Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a> 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。</p><h1 id="图形渲染技术栈"><a href="#图形渲染技术栈" class="headerlink" title="图形渲染技术栈"></a>图形渲染技术栈</h1><p>下图所示为 iOS App 的图形渲染技术栈，App 使用 <code>Core Graphics</code>、<code>Core Animation</code>、<code>Core Image</code> 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系。这些框架都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-rendering-framework-relationship.png" alt=""></p><h2 id="iOS-渲染框架"><a href="#iOS-渲染框架" class="headerlink" title="iOS 渲染框架"></a>iOS 渲染框架</h2><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a><code>UIKit</code></h3><p><code>UIKit</code> 是 iOS 开发者最常用的框架，可以通过设置 <code>UIKit</code> 组件的布局以及相关属性来绘制界面。</p><p>事实上， <code>UIKit</code> 自身并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（<code>UIView</code> 继承自 <code>UIResponder</code>），事件响应的传递大体是经过逐层的 <strong>视图树</strong> 遍历实现的。</p><h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a><code>Core Animation</code></h3><p><code>Core Animation</code> 源自于 <code>Layer Kit</code>，动画只是 <code>Core Animation</code> 特性的冰山一角。</p><p><code>Core Animation</code> 是一个复合引擎，其职责是 <strong>尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即 CALayer），这些图层会被存储在一个叫做图层树的体系之中</strong>。从本质上而言，<code>CALayer</code> 是用户所能在屏幕上看见的一切的基础。</p><h3 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a><code>Core Graphics</code></h3><p><code>Core Graphics</code> 基于 Quartz 高级绘图引擎，主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。</p><p>当开发者需要在 <strong>运行时创建图像</strong> 时，可以使用 <code>Core Graphics</code> 去绘制。与之相对的是 <strong>运行前创建图像</strong>，例如用 Photoshop 提前做好图片素材直接导入应用。相比之下，我们更需要 <code>Core Graphics</code> 去在运行时实时计算、绘制一系列图像帧来实现动画。</p><h3 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a><code>Core Image</code></h3><p><code>Core Image</code> 与 <code>Core Graphics</code> 恰恰相反，<code>Core Graphics</code> 用于在 <strong>运行时创建图像</strong>，而 <code>Core Image</code> 是用来处理 <strong>运行前创建的图像</strong> 的。<code>Core Image</code> 框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。</p><p>大部分情况下，<code>Core Image</code> 会在 GPU 中完成工作，但如果 GPU 忙，会使用 CPU 进行处理。</p><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a><code>OpenGL ES</code></h3><p><code>OpenGL ES</code>（OpenGL for Embedded Systems，简称 GLES），是 OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL 是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。</p><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a><code>Metal</code></h3><p><code>Metal</code> 类似于 <code>OpenGL ES</code>，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过 <code>Metal</code>，但其实所有开发者都在间接地使用 <code>Metal</code>。<code>Core Animation</code>、<code>Core Image</code>、<code>SceneKit</code>、<code>SpriteKit</code> 等等渲染框架都是构建于 <code>Metal</code> 之上的。</p><p>当在真机上调试 OpenGL 程序时，控制台会打印出启用 <code>Metal</code> 的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL 命令无缝桥接到 <code>Metal</code> 上，由 <code>Metal</code> 担任真正于硬件交互的工作。</p><h1 id="UIView-与-CALayer-的关系"><a href="#UIView-与-CALayer-的关系" class="headerlink" title="UIView 与 CALayer 的关系"></a>UIView 与 CALayer 的关系</h1><p>在前面的 <code>Core Animation</code> 简介中提到 <code>CALayer</code> 事实上是用户所能在屏幕上看见的一切的基础。为什么 <code>UIKit</code> 中的视图能够呈现可视化内容？就是因为 <code>UIKit</code> 中的每一个 UI 视图控件其实内部都有一个关联的 <code>CALayer</code>，即 <code>backing layer</code>。</p><p>由于这种一一对应的关系，视图层级拥有 <strong>视图树</strong> 的树形结构，对应 <code>CALayer</code> 层级也拥有 <strong>图层树</strong> 的树形结构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-viewtree-layertree.png?x-oss-process=image/resize,w_500" alt=""></p><p>其中，视图的职责是 <strong>创建并管理</strong> 图层，以确保当子视图在层级关系中 <strong>添加或被移除</strong> 时，<strong>其关联的图层在图层树中也有相同的操作</strong>，即保证视图树和图层树在结构上的一致性。</p><blockquote><p>那么为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？</p></blockquote><p>其原因在于要做 <strong>职责分离</strong>，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 <code>UIKit</code> 和 <code>UIView</code>，对应 Mac OS X 有 <code>AppKit</code> 和 <code>NSView</code> 的原因。它们在功能上很相似，但是在实现上有着显著的区别。</p><blockquote><p>实际上，这里并不是两个层级关系，而是四个。每一个都扮演着不同的角色。除了 <strong>视图树</strong> 和 <strong>图层树</strong>，还有 <strong>呈现树</strong> 和 <strong>渲染树</strong>。</p></blockquote><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a><code>CALayer</code></h2><p>那么为什么 <code>CALayer</code> 可以呈现可视化内容呢？因为 <code>CALayer</code> 基本等同于一个 <strong>纹理</strong>。纹理是 GPU 进行图像渲染的重要依据。</p><p>在 <a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a> 中提到纹理本质上就是一张图片，因此 <code>CALayer</code> 也包含一个 <code>contents</code> 属性指向一块缓存区，称为 <code>backing store</code>，可以存放位图（Bitmap）。iOS 中将该缓存区保存的图片称为 <strong>寄宿图</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-contents.png?x-oss-process=image/resize,w_500" alt=""></p><p>图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成纹理），也支持直接使用纹理（图片）进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 <strong>手动绘制</strong>；另一种是 <strong>使用图片</strong>。</p><p>对此，iOS 中也有两种相应的实现方式：</p><ul><li>使用图片：<strong>contents image</strong></li><li>手动绘制：<strong>custom drawing</strong></li></ul><h3 id="Contents-Image"><a href="#Contents-Image" class="headerlink" title="Contents Image"></a>Contents Image</h3><p> Contents Image 是指通过 <code>CALayer</code> 的 <code>contents</code> 属性来配置图片。然而，<code>contents</code> 属性的类型为 <code>id</code>。在这种情况下，可以给 <code>contents</code> 属性赋予任何值，app 仍可以编译通过。但是在实践中，如果 <code>content</code> 的值不是 <code>CGImage</code> ，得到的图层将是空白的。</p><p> 既然如此，为什么要将 <code>contents</code> 的属性类型定义为 <code>id</code> 而非 <code>CGImage</code>。这是因为在 Mac OS 系统中，该属性对 <code>CGImage</code> 和 <code>NSImage</code> 类型的值都起作用，而在 iOS 系统中，该属性只对 <code>CGImage</code> 起作用。</p><p> 本质上，<code>contents</code> 属性指向的一块缓存区域，称为 <code>backing store</code>，可以存放 bitmap 数据。</p><h3 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h3><p>Custom Drawing 是指使用 <code>Core Graphics</code> 直接绘制寄宿图。实际开发中，一般通过继承 <code>UIView</code> 并实现 <code>-drawRect:</code> 方法来自定义绘制。</p><p>虽然 <code>-drawRect:</code> 是一个 <code>UIView</code> 方法，但事实上都是底层的 <code>CALayer</code> 完成了重绘工作并保存了产生的图片。下图所示为 <code>-drawRect:</code> 绘制定义寄宿图的基本原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-bitmap-custom-drawing.png?x-oss-process=image/resize,w_500" alt=""></p><ul><li><code>UIView</code> 有一个关联图层，即 <code>CALayer</code>。</li><li><code>CALayer</code> 有一个可选的 <code>delegate</code> 属性，实现了 <code>CALayerDelegate</code> 协议。<code>UIView</code> 作为 <code>CALayer</code> 的代理实现了 <code>CALayerDelegae</code> 协议。</li><li>当需要重绘时，即调用 <code>-drawRect:</code>，<code>CALayer</code> 请求其代理给予一个寄宿图来显示。</li><li><p><code>CALayer</code> 首先会尝试调用 <code>-displayLayer:</code> 方法，此时代理可以直接设置 <code>contents</code> 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)layer;</span><br></pre></td></tr></table></figure></li><li><p>如果代理没有实现 <code>-displayLayer:</code> 方法，<code>CALayer</code> 则会尝试调用 <code>-drawLayer:inContext:</code> 方法。在调用该方法前，<code>CALayer</code> 会创建一个空的寄宿图（尺寸由 <code>bounds</code> 和 <code>contentScale</code> 决定）和一个 <code>Core Graphics</code> 的绘制上下文，为绘制寄宿图做准备，作为 <code>ctx</code> 参数传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</span><br></pre></td></tr></table></figure></li><li><p>最后，由 <code>Core Graphics</code> 绘制生成的寄宿图会存入 <code>backing store</code>。</p></li></ul><h1 id="Core-Animation-流水线"><a href="#Core-Animation-流水线" class="headerlink" title="Core Animation 流水线"></a>Core Animation 流水线</h1><p>通过前面的介绍，我们知道了 <code>CALayer</code> 的本质，那么它是如何调用 GPU 并显示可视化内容的呢？下面我们就需要介绍一下 Core Animation 流水线的工作原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-steps.png" alt=""></p><p>事实上，app 本身并不负责渲染，渲染则是由一个独立的进程负责，即 <code>Render Server</code> 进程。</p><p>App 通过 IPC 将渲染任务及相关数据提交给 <code>Render Server</code>。<code>Render Server</code> 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。</p><p>Core Animation 流水线的详细过程如下：</p><ul><li>首先，由 app 处理事件（Handle Events），如：用户的点击操作，在此过程中 app 可能需要更新 <strong>视图树</strong>，相应地，<strong>图层树</strong> 也会被更新。</li><li>其次，app 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 <code>Render Server</code>，即完成了一次 <code>Commit Transaction</code> 操作。</li><li><code>Render Server</code> 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU</li><li>GPU 则在物理层上完成了对图像的渲染。</li><li>最终，GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上。</li></ul><p>对上述步骤进行串联，它们执行所消耗的时间远远超过 16.67 ms，因此为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式进行并行执行，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-workflow.png" alt=""></p><h2 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h2><p>在 Core Animation 流水线中，app 调用 <code>Render Server</code> 前的最后一步 Commit Transaction 其实可以细分为 4 个步骤：</p><ul><li><code>Layout</code></li><li><code>Display</code></li><li><code>Prepare</code></li><li><code>Commit</code></li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><code>Layout</code> 阶段主要进行视图构建，包括：<code>LayoutSubviews</code> 方法的重载，<code>addSubview:</code> 方法填充子视图等。</p><h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p><code>Display</code> 阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的 <code>drawRect:</code> 方法可以自定义 <code>UIView</code> 的显示，其原理是在 <code>drawRect:</code> 方法内部绘制寄宿图，该过程使用 CPU 和内存。</p><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p><code>Prepare</code> 阶段属于附加步骤，一般处理图像的解码和转换等操作。</p><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p><code>Commit</code> 阶段主要将图层进行打包，并将它们发送至 <code>Render Server</code>。该过程会递归执行，因为图层和视图都是以树形结构存在。</p><h1 id="动画渲染原理"><a href="#动画渲染原理" class="headerlink" title="动画渲染原理"></a>动画渲染原理</h1><p>iOS 动画的渲染也是基于上述 Core Animation 流水线完成的。这里我们重点关注 app 与 <code>Render Server</code> 的执行流程。</p><p>日常开发中，如果不是特别复杂的动画，一般使用 <code>UIView</code> Animation 实现，iOS 将其处理过程分为如下三部阶段：</p><ul><li>Step 1：调用 <code>animationWithDuration:animations:</code> 方法</li><li>Step 2：在 Animation Block 中进行 <code>Layout</code>，<code>Display</code>，<code>Prepare</code>，<code>Commit</code> 等步骤。</li><li>Step 3：<code>Render Server</code> 根据 Animation 逐帧进行渲染。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-animation-three-stage-process.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/" target="_blank" rel="noopener">Getting Pixels onto the Screen</a>，<a href="https://segmentfault.com/a/1190000000390012" target="_blank" rel="noopener">中文版（iOS 开发：绘制像素到屏幕）</a></li><li><a href="https://lision.me/ios-rendering-process/" target="_blank" rel="noopener">深入理解 iOS Rendering Process</a></li><li><a href="https://zsisme.gitbooks.io/ios-/content/" target="_blank" rel="noopener">iOS Core Animation: Advanced Techniques中文译本</a></li><li><a href="https://www.jianshu.com/p/c49833c04362" target="_blank" rel="noopener">关于drawRect</a></li><li>iOS 绘图与动画原理剖析</li><li>WWDC 2014 Session 419: Advanced Graphics and Animations for iOS Apps</li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a></li><li><a href="https://github.com/seedante/iOS-Note/wiki/Mastering-Offscreen-Render" target="_blank" rel="noopener">Mastering Offscreen Render</a></li><li><a href="https://download.developer.apple.com/wwdc_2012/wwdc_2012_session_pdfs/session_506__optimizing_2d_graphics_and_animation_performance.pdf" target="_blank" rel="noopener">Optimizing 2D Graphics and Animation Performance</a></li><li><a href="http://docs.huihoo.com/apple/wwdc/2012/session_240__polishing_your_interface_rotations.pdf" target="_blank" rel="noopener">Polishing Your Interface Rotation Animations</a></li><li><a href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/421_core_animation_essentials.pdf" target="_blank" rel="noopener">Core Animation Essentials</a></li><li><a href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/121_understanding_uikit_rendering.pdf" target="_blank" rel="noopener">Understanding UIKit Rendering</a></li><li><a href="http://www.lukeparham.com/blog/2016/5/25/ios-rendering-the-ui" target="_blank" rel="noopener">iOS: Rendering the UI</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a></li><li><a href="https://www.jianshu.com/p/d05d19f70bac" target="_blank" rel="noopener">iOS 动画篇：核心动画</a></li><li><a href="https://developer.samsung.com/game/gpu-framebuffer" target="_blank" rel="noopener">GPU Framebuffer Memory: Understanding Tiling</a></li><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li><li><a href="https://www.jianshu.com/p/456c961164d9" target="_blank" rel="noopener">OpenGL ES 框架详细解析（八） —— OpenGL ES 设计指南</a></li><li><a href="https://www.jianshu.com/p/748f9abafff8" target="_blank" rel="noopener">iOS 开发-视图渲染与性能优化</a></li><li><a href="https://segmentfault.com/a/1190000004164291#articleHeader5" target="_blank" rel="noopener">iOS 视图、动画渲染机制探究</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a></li><li><a href="https://www.zybuluo.com/qidiandasheng/note/494700" target="_blank" rel="noopener">iOS界面渲染流程</a></li><li><a href="http://blog.handy.wang/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/" target="_blank" rel="noopener">界面渲染的整体流程</a></li><li><a href="https://www.cnblogs.com/feng9exe/p/6723398.html" target="_blank" rel="noopener">iOS图像处理之Core Graphics和OpenGL ES初见</a></li><li>WWDC 2012 Session 506: Optimizing 2D Graphics and Animations Performances</li><li>WWDC 2011 Session 421: Core Animation Essentials</li><li>WWDC 2011 Session 129: Practical Drawing for iOS Developers</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过 &lt;a href=&quot;http://chuquan.me/2018/08/26/graphics-rending-principle-gpu&quot;&gt;图形渲染原理&lt;/a&gt; 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Core Animation Pipeline" scheme="http://chuquan.me/tags/Core-Animation-Pipeline/"/>
    
      <category term="Render Server" scheme="http://chuquan.me/tags/Render-Server/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(8)——图形图像渲染原理</title>
    <link href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/"/>
    <id>http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/</id>
    <published>2018-08-26T10:07:41.000Z</published>
    <updated>2019-04-05T14:12:45.166Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。</p><p>本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识储备。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为程序员，我们或多或少知道可视化应用程序都是由 CPU 和 GPU 协作执行的。那么我们就先来了解一下两者的基本概念：</p><ul><li><strong>CPU（Central Processing Unit）</strong>：现代计算机的三大核心部分之一，作为整个系统的运算和控制单元。CPU 内部的流水线结构使其拥有一定程度的并行计算能力。</li><li><strong>GPU（Graphics Processing Unit）</strong>：一种可进行绘图运算工作的专用微处理器。GPU 能够生成 2D/3D 的图形图像和视频，从而能够支持基于窗口的操作系统、图形用户界面、视频游戏、可视化图像应用和视频播放。GPU 具有非常强的并行计算能力。</li></ul><p>这时候可能会产生一个问题：CPU 难道不能代替 GPU 来进行图形渲染吗？答案当然是肯定的，不过在看了下面这个视频就明白为什么要用 GPU 来进行图形渲染了。</p><p><a href="http://ugcydzd.qq.com/uwMRJfz-r5jAYaQXGdGnC2_ppdhgmrDlPaRvaV7F2Ic/a0310ca26r9.m701.mp4?vkey=40961BB7F3520A37C85D4E4B4130DD91374BFB11499862930CE40B3E09D41D06125BC9EFC73A98DDDE2E5A64EAEB896492064C775F5C82ECD1D72D91D30C53F874EF2C404B480B719C6B8FAA1FA012CEF8743749150271333535195D599FE9F4E8E5FADC8C1A4FBEE74E1C81AA4206F408DE82EE359B3193&amp;br=29&amp;platform=2&amp;fmt=auto&amp;level=0&amp;sdtfrom=v1010&amp;guid=f401ea7eb4e13983f11cfe58f689e34d" target="_blank" rel="noopener">GPU CPU 模拟绘图视频</a></p><p>使用 GPU 渲染图形的根本原因就是：速度。GPU 的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。</p><p>那么像素是如何绘制在屏幕上的？计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为 <strong>渲染</strong>。渲染过程中最常用的技术就是 <strong>光栅化</strong>。</p><p>关于光栅化的概念，以下图为例，假如有一道绿光与存储在内存中的一堆三角形中的某一个在三维空间坐标中存在相交的关系。那么这些处于相交位置的像素都会被绘制到屏幕上。当然这些三角形在三维空间中的前后关系也会以遮挡或部分遮挡的形式在屏幕上呈现出来。一句话总结：光栅化就是将数据转化成可见像素的过程。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-rasterization-basic-concept.png?x-oss-process=image/resize,w_300" alt=""></p><p>GPU 则是执行转换过程的硬件部件。由于这个过程涉及到屏幕上的每一个像素，所以 GPU 被设计成了一个高度并行化的硬件部件。</p><p>下面，我们来简单了解一下 GPU 的历史。</p><h1 id="GPU-历史"><a href="#GPU-历史" class="headerlink" title="GPU 历史"></a>GPU 历史</h1><p>GPU 还未出现前，PC 上的图形操作是由 <strong>视频图形阵列（VGA，Video Graphics Array）</strong> 控制器完成。VGA 控制器由连接到一定容量的DRAM上的存储控制器和显示产生器构成。</p><p>1997 年，VGA 控制器开始具备一些 3D 加速功能，包括用于 <strong>三角形生成</strong>、<strong>光栅化</strong>、<strong>纹理贴图</strong> 和 <strong>阴影</strong>。</p><p>2000 年，一个单片处图形处理器继承了传统高端工作站图形流水线的几乎每一个细节。因此诞生了一个新的术语 GPU 用来表示图形设备已经变成了一个处理器。</p><p>随着时间的推移，GPU 的可编程能力愈发强大，其作为可编程处理器取代了固定功能的专用逻辑，同时保持了基本的 3D 图形流水线组织。</p><p>近年来，GPU 增加了处理器指令和存储器硬件，以支持通用编程语言，并创立了一种编程环境，从而允许使用熟悉的语言（包括 C/C++）对 GPU 进行编程。</p><p>如今，GPU 及其相关驱动实现了图形处理中的 <code>OpenGL</code> 和 <code>DirectX</code> 模型，从而允许开发者能够轻易地操作硬件。<code>OpenGL</code> 严格来说并不是常规意义上的 API，而是一个第三方标准（由 khronos 组织制定并维护），其严格定义了每个函数该如何执行，以及它们的输出值。至于每个函数内部具体是如何实现的，则由 OpenGL 库的开发者自行决定。实际 OpenGL 库的开发者通常是显卡的生产商。<code>DirectX</code> 则是由 Microsoft 提供一套第三方标准。</p><h1 id="GPU-图形渲染流水线"><a href="#GPU-图形渲染流水线" class="headerlink" title="GPU 图形渲染流水线"></a>GPU 图形渲染流水线</h1><p>GPU 图形渲染流水线的主要工作可以被划分为两个部分：</p><ul><li>把 3D 坐标转换为 2D 坐标</li><li>把 2D 坐标转变为实际的有颜色的像素</li></ul><p>GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示。</p><ul><li><strong>顶点着色器（Vertex Shader）</strong></li><li><strong>形状装配（Shape Assembly）</strong>，又称 <strong>图元装配</strong></li><li><strong>几何着色器（Geometry Shader）</strong></li><li><strong>光栅化（Rasterization）</strong></li><li><strong>片段着色器（Fragment Shader）</strong></li><li><strong>测试与混合（Tests and Blending）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/opengl-graphics-pipeline.png" alt=""></p><p>第一阶段，顶点着色器。该阶段的输入是 <strong>顶点数据（Vertex Data）</strong> 数据，比如以数组的形式传递 3 个 3D 坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器可以对顶点属性进行一些基本处理。</p><p>第二阶段，形状（图元）装配。该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图中则是一个三角形。<strong>图元（Primitive）</strong> 用于表示如何渲染顶点数据，如：点、线、三角形。</p><p>第三阶段，几何着色器。该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p><p>第四阶段，光栅化。该阶段会把图元映射为最终屏幕上相应的像素，生成片段。<strong>片段（Fragment）</strong> 是渲染一个像素所需要的所有数据。</p><p>第五阶段，片段着色器。该阶段首先会对输入的片段进行 <strong>裁切（Clipping）</strong>。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。</p><p>第六阶段，测试与混合。该阶段会检测片段的对应的深度值（<code>z</code> 坐标），判断这个像素位于其它物体的前面还是后面，决定是否应该丢弃。此外，该阶段还会检查 <code>alpha</code> 值（ <code>alpha</code> 值定义了一个物体的透明度），从而对物体进行混合。因此，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>关于混合，GPU 采用如下公式进行计算，并得出最后的颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = S + D * (1 - Sa)</span><br></pre></td></tr></table></figure><p>关于公式的含义，假设有两个像素 S(source) 和 D(destination)，S 在 <code>z</code> 轴方向相对靠前（在上面），D 在 <code>z</code> 轴方向相对靠后（在下面），那么最终的颜色值就是 <strong>S（上面像素） 的颜色 + D（下面像素） 的颜色 * （1 - S（上面像素） 颜色的透明度）</strong>。</p><p>上述流水线以绘制一个三角形为进行介绍，可以为每个顶点添加颜色来增加图形的细节，从而创建图像。但是，如果让图形看上去更加真实，需要足够多的顶点和颜色，相应也会产生更大的开销。为了提高生产效率和执行效率，开发者经常会使用 <strong>纹理（Texture）</strong> 来表现细节。<strong>纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理）</strong>。<strong>纹理一般可以直接作为图形渲染流水线的第五阶段的输入</strong>。</p><p>最后，我们还需要知道上述阶段中的着色器事实上是一些程序，它们运行在 GPU 中成千上万的小处理器核中。这些着色器允许开发者进行配置，从而可以高效地控制图形渲染流水线中的特定部分。由于它们运行在 GPU 中，因此可以降低 CPU 的负荷。着色器可以使用多种语言编写，OpenGL 提供了 GLSL（OpenGL Shading Language） 着色器语言。</p><h1 id="GPU-存储系统"><a href="#GPU-存储系统" class="headerlink" title="GPU 存储系统"></a>GPU 存储系统</h1><p>早期的 GPU，不同的着色器对应有着不同的硬件单元。如今，GPU 流水线则使用一个统一的硬件来运行所有的着色器。此外，nVidia 还提出了 <strong>CUDA（Compute Unified Device Architecture）</strong> 编程模型，可以允许开发者通过编写 C 代码来访问 GPU 中所有的处理器核，从而深度挖掘 GPU 的并行计算能力。</p><p>下图所示为 GPU 内部的层级结构。最底层是计算机的系统内存，其次是 GPU 的内部存储，然后依次是两级 cache：L2 和 L1，每个 L1 cache 连接至一个 <strong>流处理器（SM，stream processor）</strong>。</p><ul><li>SM L1 Cache 的存储容量大约为 16 至 64KB。</li><li>GPU L2 Cache 的存储容量大约为几百 KB。</li><li>GPU 的内存最大为 12GB。</li></ul><p>GPU 上的各级存储系统与对应层级的计算机存储系统相比要小不少。</p><p>此外，GPU 内存并不具有一致性，也就意味着并不支持并发读取和并发写入。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-hierarchy.png?x-oss-process=image/resize,w_400" alt=""></p><h1 id="GPU-流处理器"><a href="#GPU-流处理器" class="headerlink" title="GPU 流处理器"></a>GPU 流处理器</h1><p>下图所示为 GPU 中每个流处理器的内部结构示意图。每个流处理器集成了一个 L1 Cache。顶部是处理器核共享的寄存器堆。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-stream-processor.png?x-oss-process=image/resize,w_400" alt=""></p><h1 id="CPU-GPU-异构系统"><a href="#CPU-GPU-异构系统" class="headerlink" title="CPU-GPU 异构系统"></a>CPU-GPU 异构系统</h1><p>至此，我们大致了解了 GPU 的工作原理和内部结构，那么实际应用中 CPU 和 GPU 又是如何协同工作的呢？</p><p>下图所示为两种常见的 CPU-GPU 异构架构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cpu-gpu-architecture.png" alt=""></p><p>左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e 总线进行连接。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p><p>右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p><p>注意，目前很多 SoC 都是集成了CPU 和 GPU，事实上这仅仅是在物理上进行了集成，并不意味着它们使用的就是耦合式结构，大多数采用的还是分离式结构。耦合式结构是在系统上进行了集成。</p><p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 GPU 共享系统内存，由 MMU 进行存储管理。</p><p>图形应用程序调用 <code>OpenGL</code> 或 <code>Direct3D</code> API 功能，将 GPU 作为协处理器使用。API 通过面向特殊 GPU 优化的图形设备驱动向 GPU 发送命令、程序、数据。</p><h1 id="GPU-资源管理模型"><a href="#GPU-资源管理模型" class="headerlink" title="GPU 资源管理模型"></a>GPU 资源管理模型</h1><p>下图所示为分离式异构系统中 GPU 的资源管理模型示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-management-model.png" alt=""></p><ol><li><strong>MMIO（Memory-Mapped I/O）</strong></li></ol><ul><li>CPU 通过 MMIO 访问 GPU 的寄存器状态。</li><li>通过 MMIO 传送数据块传输命令，支持 DMA 的硬件可以实现块数据传输。</li></ul><ol><li><strong>GPU Context</strong></li></ol><ul><li>上下文表示 GPU 的计算状态，在 GPU 中占据部分虚拟地址空间。多个活跃态下的上下文可以在 GPU 中并存。</li></ul><ol><li><strong>CPU Channel</strong></li></ol><ul><li>来自 CPU 操作 GPU 的命令存储在内存中，并提交至 GPU channel 硬件单元。</li><li>每个 GPU 上下文可拥有多个 GPU Channel。每个 GPU 上下文都包含 GPU channel 描述符（GPU 内存中的内存对象）。</li><li>每个 GPU Channel 描述符存储了channel 的配置，如：其所在的页表。</li><li>每个 GPU Channel 都有一个专用的命令缓冲区，该缓冲区分配在 GPU 内存中，通过 MMIO 对 CPU 可见。</li></ul><ol><li><strong>GPU 页表</strong></li></ol><ul><li>GPU 上下文使用 GPU 页表进行分配，该表将虚拟地址空间与其他地址空间隔离开来。</li><li>GPU 页表与 CPU 页表分离，其驻留在 GPU 内存中，物理地址位于 GPU 通道描述符中。<br>通过 GPU channel 提交的所有命令和程序都在对应的 GPU 虚拟地址空间中执行。</li><li>GPU 页表将 GPU 虚拟地址不仅转换为 GPU 设备物理地址，还转换为主机物理地址。这使得 GPU 页面表能够将 GPU 存储器和主存储器统一到统一的 GPU 虚拟地址空间中，从而构成一个完成的虚拟地址空间。</li></ul><ol><li><strong>PFIFO Engine</strong></li></ol><ul><li>PFIFO 是一个提交 GPU 命令的特殊引擎。</li><li>PFIFO 维护多个独立的命令队列，即 channel。</li><li>命令队列是带有 put 和 get 指针的环形缓冲器。</li><li>PFIFO 引擎会拦截多有对通道控制区域的访问以供执行。</li><li>GPU 驱动使用一个通道描述符来存储关联通道的设置。</li></ul><ol><li><strong>BO</strong></li></ol><ul><li>缓冲对象（Buffer Object）。一块内存，可以用来存储纹理，渲染对象，着色器代码等等。</li></ul><h1 id="CPU-GPU-工作流"><a href="#CPU-GPU-工作流" class="headerlink" title="CPU-GPU 工作流"></a>CPU-GPU 工作流</h1><p>下图所示为 CPU-GPU 异构系统的工作流，当 CPU 遇到图像处理的需求时，会调用 GPU 进行处理，主要流程可以分为以下四步：</p><ol><li>将主存的处理数据复制到显存中</li><li>CPU 指令驱动 GPU</li><li>GPU 中的每个运算单元并行处理</li><li>GPU 将显存结果传回主存</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/cuda_processing_flow.png" alt=""></p><h1 id="屏幕图像显示原理"><a href="#屏幕图像显示原理" class="headerlink" title="屏幕图像显示原理"></a>屏幕图像显示原理</h1><p>介绍屏幕图像显示的原理，需要先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 <strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 <strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" alt=""></p><p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 <code>VSync</code> 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_500" alt=""></p><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png" alt=""></p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" alt=""></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cs.utah.edu/~jeffp/teaching/MCMD/S20-GPU.pdf" target="_blank" rel="noopener">GPU Architecture and Models</a></li><li>计算机组成与设计：硬件、软件接口</li><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">欢迎来到OpenGL的世界</a></li><li><a href="https://pdfs.semanticscholar.org/presentation/52d1/963f6a3409aff1f8d73ba1819a187f39f6e1.pdf" target="_blank" rel="noopener">AMD APU Series</a></li><li><a href="http://m.elecfans.com/article/713834.html" target="_blank" rel="noopener">一文详解GPU结构及工作原理</a></li><li><a href="https://www.slideshare.net/mohamedragabslideshare/p12-29046493" target="_blank" rel="noopener">Revisting Co-Processing for Hash Joins on the Coupled CPU-GPU Architecture</a></li><li><a href="https://insujang.github.io/2017-04-27/gpu-architecture-overview/" target="_blank" rel="noopener">GPU Architecture Overview</a></li><li><a href="https://zh.wikipedia.org/wiki/CUDA" target="_blank" rel="noopener">CUDA</a></li><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流程的技巧</a></li><li><a href="https://segmentfault.com/a/1190000000390012" target="_blank" rel="noopener">iOS 开发：绘制像素到屏幕</a></li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://slideplayer.com/slide/11059244/" target="_blank" rel="noopener">Rendering pipeline: The hardware side</a></li><li><a href="http://meseec.ce.rit.edu/551-projects/spring2015/3-2.pdf" target="_blank" rel="noopener">Graphics Processing Unit(GPU) Memory Hierarchy</a></li><li><a href="http://www.d.umn.edu/~data0003/Talks/gpuarch.pdf" target="_blank" rel="noopener">Graphics Processing Unit Architecture(GPU Arch) With a focus on NVIDIA GeForce 6800 GPU</a></li><li><a href="https://www.jianshu.com/p/d05d19f70bac" target="_blank" rel="noopener">iOS动画篇：核心动画</a></li><li><a href="https://www.anandtech.com/show/7335/the-iphone-5s-review/7" target="_blank" rel="noopener">The iPhone 5s Review</a></li><li><a href="https://www.realworldtech.com/apple-custom-gpu/" target="_blank" rel="noopener">A Look Inside Apple’s Custom GPU for the iPhone</a></li><li><a href="https://appleinsider.com/articles/17/04/17/one-apple-gpu-one-giant-leap-in-graphics-for-iphone-8" target="_blank" rel="noopener">One Apple GPU, one giant leap in graphics for iPhone 8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。&lt;/p&gt;
&lt;p&gt;本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="GPU" scheme="http://chuquan.me/tags/GPU/"/>
    
      <category term="渲染" scheme="http://chuquan.me/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(7)——线程</title>
    <link href="http://chuquan.me/2018/07/10/thread-introduce/"/>
    <id>http://chuquan.me/2018/07/10/thread-introduce/</id>
    <published>2018-07-09T16:15:39.000Z</published>
    <updated>2019-05-14T15:19:21.873Z</updated>
    
    <content type="html"><![CDATA[<p>现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p><strong>线程（Thread）</strong>，也称<strong>轻量级进程（Lightweight Process，LWP）</strong>，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合、堆栈组成。通常，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（如打开文件和信号）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-in-process.pngi?x-oss-process=image/resize,w_600" alt=""></p><p>同一进程中的多个线程可以互不干扰地并发执行，并且共享进程的全局变量和堆的数据。相对于单线程进程，使用多线程的原因有一下几点：</p><ul><li>某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待时间进行线程切换。如等待网络响应。</li><li>某个操作可能会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会被中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li><li>程序本身要求并发操作，如一个多端下载软件（如Bittorrent）。</li><li>多CPU或多核处理器，本身具备同时执行多个线程的能力，因此单线程程序无法全面发挥计算机的全部计算能力。</li><li>相对于多进程应用，多线程在数据共享方面效率更高。</li></ul><h2 id="线程访问权限"><a href="#线程访问权限" class="headerlink" title="线程访问权限"></a>线程访问权限</h2><p>线程可以访问进程内存中的所有的数据，包括如下几个方面：</p><ul><li><strong>全局变量</strong></li><li><strong>堆数据</strong></li><li><strong>函数里的静态变量</strong></li><li><strong>程序代码，任何线程都有权利读取并执行任何代码</strong></li><li><strong>打开的文件，A线程打开的文件可以由B线程读取</strong></li></ul><p>当然实际上线程也拥有自己的私有存储空间，包括如下几个方面：</p><ul><li><strong>栈</strong>：尽管并非完全无法被其他线程访问，但是一般情况下还是认为栈是私有数据。</li><li><strong>线程局部存储（Thread Local Storage，TLS）</strong>：线程局部存储是某些操作系统为线程单独提供的私有空间，容量有限。</li><li><strong>寄存器</strong>：寄存器是执行流的基本数据，为线程私有。</li></ul><h2 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h2><p>当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上。当线程数据大于处理器数量时，此时至少有一个处理器会运行多个线程。</p><p>在单处理器运行多线程情况下，并发是一种模拟出来的状态。操作系统会让这些多线程轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样每个线程“看起来”在同时执行。这样一个不断在处理器上切换不同的线程的行为称为 <strong>线程调度</strong>。</p><p>在线程调度中，线程通常拥有至少三种状态，分别是：</p><ul><li><strong>运行（Running）</strong>：此时线程正在执行。</li><li><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPI已被占用。</li><li><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。</li></ul><p>处于运行中的线程拥有一段可以执行的时间，这段时间称为 <strong>时间片（Time Slice）</strong>。当时间片用尽时，线程进入就绪状态。如果线程在时间片用尽前就开始等待某事件，则它将进入等待状态。当一个线程离开运行状态时，系统会选择一个处于就绪状态的线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。如下图所示为线程的状态转移图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-state-transition-diagram.png?x-oss-process=image/resize,w_600" alt=""></p><p>在线程调度中，主要有两种调度算法：</p><ul><li><strong>优先级调度（Priority Schedule）</strong>：线程拥有各自的 <strong>线程优先级（Thread Priority）</strong>，高优先级的线程会更早执行，低优先级的线程需要等待系统中没有高优先级的可执行线程存在时才能执行。</li><li><strong>轮转调度（Round Robin Schedule）</strong>：让各个线程轮流执行一段时间片。</li></ul><p>实际应用中，系统还会根据不同线程的表现自动调整优先级，提高线程调度效率。在系统中，一般把频繁等待的线程称为 <strong>IO密集型线程（IO Bound Thread）</strong>；把很少等待的线程称为 <strong>CPU密集型线程（CPU Bound Thread）</strong>。通常，IO 密集型线程比 CPU 密集型线程更容易得到优先级的提升。</p><p>在优先级调度中，存在一种 <strong>饿死（Starvation）</strong> 现象，即一个线程的优先级较低，在它执行之前，总是有较高优先级的线程在它之前执行。当一个CPU密集型的线程获得较高优先级时，许多低优先级的进程就可能饿死。当一个IO密集型的线程获得较高优先级时，由于大部分之间处于等待状态，因此相对不容易造成其他线程饿死。为了避免饿死现象，调度系统通常会逐步提升那些等待时间过长且未得到执行的线程的优先级。</p><h2 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h2><p>轮转调度中，线程在用尽时间片后会被强制剥夺继续执行的权利，而进入就绪状态，该过程称为 <strong>抢占（Preemption）</strong>。在早期的一些操作系统中，线程是不可抢占的。在这种调度模型下，线程必须主动进入就绪状态，而不是靠时间片用尽来被强制进入。如果线程始终拒绝进入就绪状态，并且不进行任何等待操作，其他线程将永远无法执行。</p><p>在不可抢占线程中，线程会在两种情况下主动放弃执行：</p><ul><li>当线程试图等待某些事件时（如I/O事件）。</li><li>线程主动放弃时间片。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多线程程序处于一个多变的环境中，可以访问的全局变量和堆数据随时都可能被其他的线程改变。因此，多线程程序在并发时数据的一致性非常重要。</p><h2 id="竞争与原子操作"><a href="#竞争与原子操作" class="headerlink" title="竞争与原子操作"></a>竞争与原子操作</h2><p>多线程同时访问一个共享数据，可能会造成严重的后果。以一个著名的例子为例，假设有两个线程分别执行如下所示的 C 代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 1</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line">--i;</span><br></pre></td></tr></table></figure></p><p>在很多体系结构中，++i 的实现方式一般如下：</p><ol><li><strong>读取 i 到某个寄存器 X</strong></li><li><strong>X++</strong></li><li><strong>将 X 的内容存储至 i</strong></li></ol><p>由于线程 1 和线程 2并发执行，因此两个线程的执行可能如下（注意，寄存器 X 的 内容在不同的线程中是不一样的，这里用 X[1] 和 X[2] 分别表示线程 1 和线程 2 中的 X），如下所示：</p><table><thead><tr><th style="text-align:left">执行序号</th><th style="text-align:left">执行指令</th><th style="text-align:left">语句执行后的变量值</th><th style="text-align:left">线程</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">i = 1</td><td style="text-align:left">i = 1, X[1] = 未知</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">X[1] = i</td><td style="text-align:left">i = 1, X[1] = 1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">X[2] = i</td><td style="text-align:left">i = 1, X[2] = 1</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">X[1]++</td><td style="text-align:left">i = 1, X[1] = 2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">X[2]–</td><td style="text-align:left">i = 1, X[2] = 0</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">i = X[1]</td><td style="text-align:left">i = 2, X[1] = 2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">i = X[2]</td><td style="text-align:left">i = 0, X[2] = 0</td><td style="text-align:left">2</td></tr></tbody></table><p>从程序逻辑上看，两个线程都执行完毕之后，i 的值应该是 1，但从表中的执行序列可以看到，i 的实际值是 0。实际上，这两个线程如果同时执行，i 的结果有可能是 0 或 1 或 2。</p><p>很明显，由于 i++ 操作在多线程环境下会出现错误是因为该操作被编译成汇编代码后不止一条指令，因此在执行时可能会被调度系统打断，去执行别的代码。通常，我们把单指令的操作称为 <strong>原子操作</strong>，因为单条指令的执行是不会被打断的。很多体系结构都提供了一些常用的原子指令，如 i386 就有一条 inc 指令可以直接增加一个内存单元值，可以避免上例的错误情况。</p><p>尽管原子操作指令非常方便，但是它们仅适用于比较简单特定的场合。在复杂的场合下，比如要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。这里需要更加通用的手段：锁。</p><h2 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h2><p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，需要将各个线程对同一个数据的访问进行 <strong>同步（Synchronization）</strong>。即在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。</p><p>同步最常见的方法是使用 <strong>锁（Lock）</strong>。锁是一种非强制机制，每个线程在访问数据或资源之前首先试图 <strong>获取（Acquire）</strong> 锁，并在访问结束之后 <strong>释放（Release）</strong> 锁。在锁已经被占用时试图获取锁时，线程会等待，直到锁重新可用。</p><h3 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h3><p><strong>二元信号量（Binary Semaphore）</strong> 是最简单的一种锁，只有两种状态：<strong>占用</strong>、<strong>非占用</strong>。二元信号量适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</p><h3 id="多元信号量"><a href="#多元信号量" class="headerlink" title="多元信号量"></a>多元信号量</h3><p>多元信号量是二元信号量的扩展，简称 <strong>信号量（Semaphore）</strong>。一个初始值为 N 的信号量允许 N 个线程并发访问。</p><p>当线程访问资源时，首先获取信号量，进行如下操作：</p><ul><li>将信号量减 1。</li><li>如果信号量的值小于 0，则进入等待状态，否则继续执行。</li></ul><p>当线程结束访问资源后，线程释放信号量，进行如下操作：</p><ul><li>将信号量的值加 1。</li><li>如果信号量的值小于 1，唤醒一个等待中的线程。</li></ul><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><strong>互斥量（Mutex）</strong> 和二元信号量很相似，资源仅同时允许一个线程访问，但和信号量不同的是：信号量在整个系统中可以被任意线程获取并释放，即同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><strong>临界区（Read-Write Lock）</strong> 是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于：互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的；临界区的作用范围仅限于本进程，其他的进程无法获取该锁。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>读写锁（Read-Write Lock）</strong> 致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对该数据进行修改，就必须使用同步手段来避免出错。对此，可以使用上述的信号量、互斥量或临界区中的任何一种来进行同步。虽然这样可以保证程序正确执行，但是对于读取频繁的程序，会显得非常低效。读写锁就是用来提高这种情况下的执行效率的。</p><p>读写锁有两种获取方式：<strong>共享的（Shared）</strong>、<strong>独占的（Exclusive）</strong>。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有线程释放。处于独占状态的锁将阻止任何其他线程获取该锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>条件变量（Condition Variable）</strong> 作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作：首先，线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时所有等待此条件变量的线程都会被唤醒并继续执行。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>线程的并发执行是由多处理器或操作系统调度来实现的。但实际情况要更为复杂：大多数操作系统，包括 Windows 和 Linux，都在内核里提供线程的支持，内核态线程由多处理器或调度来实现并发。然而用户实际使用的线程并不是内核态线程，而是用户态线程。用户态线程并不一定在操作系统内核里对应同等数量的内核态线程。它们之间的对应关系有三种类型。</p><h2 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h2><p>对于直接支持线程的系统，一对一模型始终是最简单的模型。对于一对一模型，一个用户态线程唯一对应一个内核态线程，但一个内核态线程并不一定存在相应的用户态线程。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-one-to-one.png?x-oss-process=image/resize,w_570" alt=""></p><p>一对一模型中，用户态线程具有和内核态线程一致的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程的执行不会受到影响。此外，一对一模型也可以让多线程程序在多处理器的系统上有更高的效率。</p><p>一对一线程模型也有两个缺点：</p><ul><li>由于许多操作系统限制了内核态线程的数量，因此一对一线程会让用户态线程的数量受到限制。</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ul><h2 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h2><p>多对一模型将多个用户态线程映射到一个内核态线程上，线程之间的切换由用户态的代码完成。因此相对于一对一模型，多对一模型的切换要快速许多。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-one.png?x-oss-process=image/resize,w_600" alt=""></p><p>多对一模型的问题在于：如果其中一个用户态线程阻塞，将导致所有线程都无法执行。另外，在多处理器系统中，处理器的增多对于多对一模型的线程性能也不会有明显的提升。多对一模型的优点在于高效的上下文切换和几乎无限制的线程数量。</p><h2 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h2><p>多对多模型结合了多对一模型和一对一模型的特点，将多个用户态线程映射到少数但不止一个内核态线程。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-many.png?x-oss-process=image/resize,w_600" alt=""></p><p>多对多模型中，一个用户态线程阻塞并不会导致所有的用户态线程阻塞，因为此时还有其他的线程可以被调度来执行。此外，多对多模型对用户线程的数量也没什么限制，在多处理器系统中，多对多模型的线程也能得到一定的性能提升，但是提升幅度步入一对一模型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。&lt;/p&gt;
&lt;h1 id=&quot;线程基础&quot;&gt;&lt;a href=&quot;#线程基础&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="线程" scheme="http://chuquan.me/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="信号量" scheme="http://chuquan.me/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="临界区" scheme="http://chuquan.me/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(6)——可执行文件的装载与运行</title>
    <link href="http://chuquan.me/2018/06/17/executable-file-load-and-execution/"/>
    <id>http://chuquan.me/2018/06/17/executable-file-load-and-execution/</id>
    <published>2018-06-17T15:33:16.000Z</published>
    <updated>2019-05-14T15:07:16.349Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello.out</span><br></pre></td></tr></table></figure></p><p>那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤：</p><ul><li>创建新进程</li><li>检查可执行文件类型</li><li>搜索匹配装载处理过程</li><li>装载执行可执行文件</li></ul><h1 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h1><p>首先在用户层面，bash 进程会调用 <code>fork()</code> 系统调用创建一个新的进程。其次，新的进程通过调用 <code>execve()</code> 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。</p><p><code>execve()</code> 系统调用被定义在 <code>unistd.h</code>，其原型如下所示。其中的三个参数分别对应被执行程序的 <strong>程序文件名</strong>、<strong>执行参数</strong>、<strong>环境变量</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure></p><h1 id="检查可执行文件类型"><a href="#检查可执行文件类型" class="headerlink" title="检查可执行文件类型"></a>检查可执行文件类型</h1><p>当进入 <code>execve()</code> 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，<code>execve()</code> 系统调用相应的入口是 <code>sys_execve()</code>。<code>sys_execve()</code> 进行一些参数的检查复制之后，调用 <code>do_execve()</code>。<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。</p><p>为什么要先读取文件的前 128 个字节？这是因为Linux支持的可执行文件不止 ELF 一种，还包括 <strong>a.out</strong>、<strong>Java 程序</strong>、<strong>以 <code>#!</code> 开头的脚本程序</strong>。<code>do_execve()</code>通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前4个字节，被称为 <strong>魔数（Magic Number）</strong>。比如：ELF的可执行文件格式的头 4 个字节为 <code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头 4 个字节为 <code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果是解释型语言的脚本，则第一行通常是 <code>#!/bin/sh</code> 或 <code>#!/user/bin/python</code>，其中 <code>#</code> 和 <code>!</code> 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p><h1 id="搜索匹配装载处理过程"><a href="#搜索匹配装载处理过程" class="headerlink" title="搜索匹配装载处理过程"></a>搜索匹配装载处理过程</h1><p>当 <code>do_execve()</code> 读取了128个字节的文件头部之后，调用 <code>search_binary_handle()</code> 去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux 中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，<code>search_binary_handler()</code> 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.</p><ul><li>ELF 可执行文件：<code>load_elf_binary()</code></li><li>a.out 可执行文件：<code>load_aout_binary()</code></li><li>可执行脚本程序：<code>load_script()</code></li></ul><h1 id="装载执行可执行文件"><a href="#装载执行可执行文件" class="headerlink" title="装载执行可执行文件"></a>装载执行可执行文件</h1><p>以 ELF 的装载处理过程 <code>load_elf_binary()</code> 为例，其所包含的步骤如下图所示：<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-load-process.png?x-oss-process=image/resize,w_600" alt=""></p><ol><li>操作系统读取可执行文件 ELF 的 <code>Header</code>，检查文件的有效性。</li><li>操作系统读取可执行文件 ELF的 <code>Program Header Table</code> 中读取每个 <code>Segment</code> 的虚拟地址、文件地址、属性等。</li><li>操作系统根据 <code>Program Header Table</code> 将可执行文件 ELF 映射至内存。</li><li>如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 <code>.interp</code> 节，找到 <strong>动态链接器（Dynamic Linker）</strong> 的位置，并启动动态链接器。在 Linux 下，动态链接器 <code>ld.so</code> 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。</li><li>动态链接器获得控制权后，开始执行一系列初始化操作。</li><li>动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。</li><li>控制权被转交到可执行文件的入口地址，程序开始正式执行。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="装载" scheme="http://chuquan.me/tags/%E8%A3%85%E8%BD%BD/"/>
    
      <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(5)——链接、静态链接、动态链接</title>
    <link href="http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/"/>
    <id>http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/</id>
    <published>2018-06-03T15:44:39.000Z</published>
    <updated>2019-05-14T15:06:42.969Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="http://chuquan.me/2018/05/21/elf-introduce/">前面</a>对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？一切都要从链接说起。</p><h1 id="链接概述"><a href="#链接概述" class="headerlink" title="链接概述"></a>链接概述</h1><p>模块化设计是软件开发中最常用的设计思想。<strong>链接（Linking）</strong> 本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。比如：</p><blockquote><p>我们在模块<code>main.c</code>中使用另一个模块<code>func.c</code>中的<code>foo()</code>函数。我们在<code>main.c</code>模块中每一处调用<code>foo</code>时都必须确切知道<code>foo</code>函数的地址。但由于每个模块都是单独编译的。编译器在编译<code>main.c</code>的时候并不知道<code>foo</code>函数的地址。所以编译器会暂时把这些调用<code>foo</code>的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。这就是静态链接最基本的过程和作用。</p></blockquote><p>如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和 <strong>库（Library）</strong> 一起链接形成最终的可执行文件。</p><p>其中，最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/linking-process.png?x-oss-process=image/resize,w_600" alt=""></p><p>链接过程主要包含了三个步骤：</p><ol><li><strong>地址与空间分配（Address and Storage Allocation）</strong></li><li><strong>符号解析（Symbol Resolution）</strong></li><li><strong>重定位（Relocation）</strong></li></ol><p>下面，我们以两个源代码文件<code>a.c</code>和<code>b.c</code>为例展开分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.c</span><br><span class="line">extern int shared;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 100;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// b.c</span><br><span class="line">int shared = 1;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>b.c</code>中定义了两个全局符号：变量<code>shared</code>、函数<code>swap</code>；<code>a.c</code>中定义了一个全局符号：<code>main</code>。<code>a.c</code>引用了<code>b.c</code>中的<code>swap</code>和<code>shared</code>。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件<code>ab</code>。</p><p>使用<code>gcc -c</code>命令我们可以分别编译得到<code>a.o</code>和<code>b.o</code>两个目标文件。</p><h2 id="地址与空间分配"><a href="#地址与空间分配" class="headerlink" title="地址与空间分配"></a>地址与空间分配</h2><p>在介绍ELF文件结构关于段与节的区别时，我们就提到过可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。</p><h3 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h3><p>一个最简单的方案就是将输入的文件按序叠加，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-simple-merge.png?x-oss-process=image/resize,w_600" alt=""></p><p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p><h3 id="合并相似节"><a href="#合并相似节" class="headerlink" title="合并相似节"></a>合并相似节</h3><p>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-similar-merge.png?x-oss-process=image/resize,w_600" alt=""></p><p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p><ol><li>在输出的可执行文件中的空间</li><li>在装载后的虚拟地址中的空间</li></ol><p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p><p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong> 的方法。即整个链接过程分为两步：</p><ul><li><strong>第一步 地址与空间分配</strong><br>  扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</li><li><strong>第二步 符号解析与重定位</strong><br>  使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/two-step-linking.png?x-oss-process=image/resize,w_600" alt=""></p><p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了<a href="http://chuquan.me/2018/05/21/elf-introduce/">ELF文件结构</a>一文中没有介绍的 <strong>程序头表（Program Header Table）</strong> 结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png?x-oss-process=image/resize,w_600" alt=""></p><p>我们使用ld或gcc将<code>a.o</code>和<code>b.o</code>链接起来，然后使用objdump工具来查看链接前后的地址分配情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h a.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h b.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004b  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h ab</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  ...</span><br><span class="line">  13 .text         00000202  0000000000400450  0000000000400450  00000450  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  ...</span><br><span class="line">  24 .data         00000014  0000000000601028  0000000000601028  00001028  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  25 .bss          00000004  000000000060103c  000000000060103c  0000103c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>可以发现，链接前目标文件中所有节的 <strong>VMA（Virtual Memory Address）</strong> 都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个节被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>0x0000000000400450</code>。</p><p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>0x0000000000400450</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>0x0000000000400450</code>。</p><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>在<strong>两步链接</strong>中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。</p><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p><p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p><p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p><h3 id="多重定义的全局符号解析"><a href="#多重定义的全局符号解析" class="headerlink" title="多重定义的全局符号解析"></a>多重定义的全局符号解析</h3><p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p><p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p><p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong>  </p><p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p><ul><li><strong>规则1：不允许有多个同名的强符号。</strong></li><li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li><li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li></ul><p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p><ul><li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li><li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li><li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li></ul><p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 <strong>COMMON块（Common Block<br>）</strong> 的机制来处理。其过程如下：</p><p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p><p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong> 专门用来保存这些与重定位相关的信息。</p><p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p><p>我们可以使用objdump工具来查看目标文件中的重定位表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000023 R_X86_64_32       share</span><br><span class="line">0000000000000030 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line">0000000000000049 R_X86_64_PC32     __stack_chk_fail-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p><p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation Entry）</strong>。利用数据结构成员包含的信息，即可完成重定位。</p><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>事实上，静态链接的过程就是上文所描述的过程。在Linux中，静态链接器（static linker）<code>ld</code>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。</p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等。在静态链接中，C语言静态库是很典型的浪费空间的例子。关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序。</p><p>解决空间浪费和更新困难最简单的方法便是将程序的模块相互分割开来，形成独立文件。简而言之，就是不对那些组成程序的目标文件进行链接，而是等到程序要运行时才进行链接。</p><h2 id="动态链接的基本实现"><a href="#动态链接的基本实现" class="headerlink" title="动态链接的基本实现"></a>动态链接的基本实现</h2><p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p><p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong>，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong>，一般以<code>.dll</code>为后缀。</p><p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p><h2 id="动态链接程序运行时地址空间分布"><a href="#动态链接程序运行时地址空间分布" class="headerlink" title="动态链接程序运行时地址空间分布"></a>动态链接程序运行时地址空间分布</h2><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p><p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p><ul><li><strong>静态共享库（Static Shared Library）</strong>（地址固定）</li><li><strong>动态共享库（Dynamic Shared Libary）</strong>（地址不固定）</li></ul><h3 id="静态共享库"><a href="#静态共享库" class="headerlink" title="静态共享库"></a>静态共享库</h3><p>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在<strong>某个特定的地址</strong>划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为<strong>静态</strong>。</p><p>但是静态共享库的目标地址会导致地址冲突、升级等问题。</p><h3 id="动态共享库"><a href="#动态共享库" class="headerlink" title="动态共享库"></a>动态共享库</h3><p>采用动态共享库的方式，也称为<strong>装载时重定位（Load Time Relocation）</strong>。其基本思路是：<strong>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。</strong></p><p>但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。</p><p>然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为<strong>地址无关代码</strong>的技术被提出以克服这个问题。</p><h4 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h4><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p><strong>地址无关代码（PIC，Position-independent Code）</strong> 技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型：</p><ul><li><strong>类型1：模块内部的函数调用。</strong></li><li><strong>类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。</strong></li><li><strong>类型3：模块外部的函数调用。</strong></li><li><strong>类型4：模块外部的数据访问，如其他模块中定义的全局变量。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">extern int b;</span><br><span class="line">extern void ext();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    a = 1;      // 类型2：模块内部数据访问</span><br><span class="line">    b = 2;      // 类型4：模块外部数据访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    bar();      // 类型1：模块内部函数调用</span><br><span class="line">    ext();      // 类型4：模块外部函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="类型1-模块内部函数调用"><a href="#类型1-模块内部函数调用" class="headerlink" title="类型1 模块内部函数调用"></a>类型1 模块内部函数调用</h5><p>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</p><h5 id="类型2-模块内部数据访问"><a href="#类型2-模块内部数据访问" class="headerlink" title="类型2 模块内部数据访问"></a>类型2 模块内部数据访问</h5><p>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p><h5 id="类型3-模块间数据访问"><a href="#类型3-模块间数据访问" class="headerlink" title="类型3 模块间数据访问"></a>类型3 模块间数据访问</h5><p>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个<strong>指向这些变量的指针数组</strong>，也称为<strong>全局偏移表（Global Offset Table，GOT）</strong>，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/inter-module-data-access.png?x-oss-process=image/resize,w_600" alt=""></p><p>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以<strong>在模块装载时被修改</strong>，并且每个进程都可以有独立的副本，相互不受影响。</p><h5 id="类型4-模块间函数调用"><a href="#类型4-模块间函数调用" class="headerlink" title="类型4 模块间函数调用"></a>类型4 模块间函数调用</h5><p>对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上文的描述，我们基本理清了链接的过程以及静态链接和动态链接的区别。事实上，链接的具体实现细节是非常复杂，本文只是对其进行了概述，更多细节以及优化实现还是需要我们自己进一步去探索。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Executable and Linkable Format (ELF)</li><li>《Linux 二进制分析》</li><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;http://chuquan.me/2018/05/21/elf-introduce/&quot;&gt;前面&lt;/a&gt;对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="链接" scheme="http://chuquan.me/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(4)——ELF文件结构</title>
    <link href="http://chuquan.me/2018/05/21/elf-introduce/"/>
    <id>http://chuquan.me/2018/05/21/elf-introduce/</id>
    <published>2018-05-21T14:45:18.000Z</published>
    <updated>2019-05-14T14:59:07.541Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://chuquan.me/2018/05/12/compiler-principle/#more">前文</a>结尾说到编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，而目标文件经过编译器链接之后得到的就是<strong>可执行文件</strong>。那么目标文件到底是什么？它和可执行文件又有什么区别？链接到底又做了什么呢？接下来，我们将探索一下目标文件的本质。</p><h1 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h1><p>目前，PC平台流行的 <strong>可执行文件格式（Executable）</strong> 主要包含如下两种，它们都是 <strong>COFF（Common File Format）</strong> 格式的变种。</p><ul><li>Windows下的 <strong>PE（Portable Executable）</strong> </li><li>Linux下的 <strong>ELF（Executable Linkable Format）</strong> </li></ul><p><strong>目标文件就是源代码经过编译后但未进行连接的那些中间文件（Windows的<code>.obj</code>和Linux的<code>.o</code>），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储</strong>。在Windows下采用<strong>PE-COFF</strong>文件格式；Linux下采用<strong>ELF</strong>文件格式。</p><p>事实上，除了<strong>可执行文件</strong>外，<strong>动态链接库（DDL，Dynamic Linking Library）</strong>、<strong>静态链接库（Static Linking Library）</strong> 均采用可执行文件格式存储。它们在Window下均按照PE-COFF格式存储；Linux下均按照ELF格式存储。只是文件名后缀不同而已。</p><ul><li>动态链接库：Windows的<code>.dll</code>、Linux的<code>.so</code></li><li>静态链接库：Windows的<code>.lib</code>、Linux的<code>.a</code></li></ul><p>下面，我们将以ELF文件为例进行介绍。</p><h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-file-format.png?x-oss-process=image/resize,w_600" alt=""></p><p><strong>注意：段（<code>Segment</code>）与节（<code>Section</code>）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</strong></p><p>如图所示，为ELF文件的基本结构，其主要由四部分组成：</p><ul><li>ELF Header</li><li>ELF Program Header Table (或称Program Headers、程序头)</li><li>ELF Section Header Table (或称Section Headers、节头表)</li><li>ELF Sections</li></ul><p>从图中，我们就能看出它们各自的数据结构以及相互之间的索引关系。下面我们依次进行介绍。</p><hr><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>我们可以使用readelf工具来查看ELF Header。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h hello.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          672 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure></p><p>ELF文件结构示意图中定义的<code>Elf_Ehdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">e_ident</td><td style="text-align:left">Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Class: ELF32</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Data:  2’s complement, little end</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Version: 1(current)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">OS/ABI: UNIX - System V</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ABI Version: 0</td></tr><tr><td style="text-align:left">e_type</td><td style="text-align:left">Type: REL (Relocatable file)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF文件类型</td></tr><tr><td style="text-align:left">e_machine</td><td style="text-align:left">Machine: Advanced Micro Devices X86-64</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF文件的CPI平台属性</td></tr><tr><td style="text-align:left">e_version</td><td style="text-align:left">Version: 0x1</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF版本号。一般为常数1</td></tr><tr><td style="text-align:left">e_entry</td><td style="text-align:left">Entry point address: 0x0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位指令一般没有入口地址，则该值为0</strong></td></tr><tr><td style="text-align:left">e_phoff</td><td style="text-align:left">Start of program headers: 0(bytes into file)</td></tr><tr><td style="text-align:left">e_shoff</td><td style="text-align:left">Start of section headers: 672 (bytes into file)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header Table 在文件中的偏移</td></tr><tr><td style="text-align:left">e_word</td><td style="text-align:left">Flags: 0x0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF标志位，用来标识一些ELF文件平台相关的属性。</td></tr><tr><td style="text-align:left">e_ehsize</td><td style="text-align:left">Size of this header: 64 (bytes)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF Header本身的大小</td></tr><tr><td style="text-align:left">e_phentsize</td><td style="text-align:left">Size of program headers: 0 (bytes)</td></tr><tr><td style="text-align:left">e_phnum</td><td style="text-align:left">Number of program headers: 0</td></tr><tr><td style="text-align:left">e_shentsize</td><td style="text-align:left">Size of section headers: 64 (bytes)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">单个Section Header大小</td></tr><tr><td style="text-align:left">e_shnum</td><td style="text-align:left">Number of section headers: 13</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header的数量</td></tr><tr><td style="text-align:left">e_shstrndx</td><td style="text-align:left">Section header string table index: 10</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header字符串表在Section Header Table中的索引</td></tr></tbody></table><h3 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h3><p>每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，通常被称为<strong>魔数（Magic Number）</strong>。通过对魔数的判断可以确定文件的格式和类型。如：ELF的可执行文件格式的头4个字节为<code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头4个字节为<code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是<code>#!/bin/sh</code>或<code>#!/usr/bin/perl</code>或<code>#!/usr/bin/python</code>，此时前两个字节<code>#</code>和<code>!</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。</p><h3 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h3><p>ELF文件主要有三种类型，可以通过ELF Header中的<code>e_type</code>成员进行区分。</p><ul><li><strong>可重定位文件（Relocatable File）</strong>：<code>ETL_REL</code>。一般为<code>.o</code>文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。</li><li><strong>可执行文件（Executable File）</strong>：<code>ET_EXEC</code>。可以直接执行的程序。</li><li><strong>共享目标文件（Shared Object File）</strong>：<code>ET_DYN</code>。一般为<code>.so</code>文件。有两种情况可以使用。<ul><li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li><li>动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像。</li></ul></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png?x-oss-process=image/resize,w_600" alt=""></p><hr><h2 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h2><p>ELF 节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</strong></p><p>我们可以使用readelf工具来查看节头表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S hello.o</span><br><span class="line"></span><br><span class="line">There are 13 section headers, starting at offset 0x2a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000001f0</span><br><span class="line">       0000000000000030  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  00000055</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  00000062</span><br><span class="line">       0000000000000035  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000097</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000098</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000220</span><br><span class="line">       0000000000000018  0000000000000018   I      11     8     8</span><br><span class="line">  [10] .shstrtab         STRTAB           0000000000000000  00000238</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  000000d0</span><br><span class="line">       0000000000000108  0000000000000018          12     9     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  000001d8</span><br><span class="line">       0000000000000013  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></p><p>ELF文件结构示意图中定义的<code>Elf_Shdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">sh_name</td><td style="text-align:left">节名</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">节名是一个字符串，保存在一个名为<code>.shstrtab</code>的字符串表（可通过Section Header索引到）。sh_name的值实际上是其节名字符串在<code>.shstrtab</code>中的偏移值</td></tr><tr><td style="text-align:left">sh_type</td><td style="text-align:left">节类型</td></tr><tr><td style="text-align:left">sh_flags</td><td style="text-align:left">节标志位</td></tr><tr><td style="text-align:left">sh_addr</td><td style="text-align:left">节地址：节的虚拟地址</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">如果该节可以被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td></tr><tr><td style="text-align:left">sh_offset</td><td style="text-align:left">节偏移</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>如果该节存在于文件中，则表示该节在文件中的偏移；否则无意义，如sh_offset对于BSS 节来说是没有意义的</strong></td></tr><tr><td style="text-align:left">sh_size</td><td style="text-align:left">节大小</td></tr><tr><td style="text-align:left">sh_link、sh_info</td><td style="text-align:left">节链接信息</td></tr><tr><td style="text-align:left">sh_addralign</td><td style="text-align:left">节地址对齐方式</td></tr><tr><td style="text-align:left">sh_entsize</td><td style="text-align:left">节项大小</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">有些节包含了一些固定大小的项，如符号表，其包含的每个符号所在的大小都一样的，对于这种节，sh_entsize表示每个项的大小。<strong>如果为0，则表示该节不包含固定大小的项。</strong></td></tr></tbody></table><h3 id="节类型（sh-type）"><a href="#节类型（sh-type）" class="headerlink" title="节类型（sh_type）"></a>节类型（sh_type）</h3><p>节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）。</p><p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。常见的节类型如下表所示：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHT_NULL</td><td style="text-align:left">0</td><td style="text-align:left">无效节</td></tr><tr><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:left">1</td><td style="text-align:left"><strong>程序节</strong>。代码节、数据节都是这种类型。</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:left">2</td><td style="text-align:left"><strong>符号表</strong></td></tr><tr><td style="text-align:left">SHT_STRTAB</td><td style="text-align:left">3</td><td style="text-align:left"><strong>字符串表</strong></td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:left">4</td><td style="text-align:left"><strong>重定位表</strong>。该节包含了重定位信息。</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">5</td><td style="text-align:left"><strong>符号表的哈希表</strong></td></tr><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">6</td><td style="text-align:left">动态链接信息</td></tr><tr><td style="text-align:left">SHT_NOTE</td><td style="text-align:left">7</td><td style="text-align:left">提示性信息</td></tr><tr><td style="text-align:left">SHT_NOBITS</td><td style="text-align:left">8</td><td style="text-align:left">表示该节在文件中没有内容。如<code>.bss</code>节</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:left">9</td><td style="text-align:left">该节包含了重定位信息</td></tr><tr><td style="text-align:left">SHT_SHLIB</td><td style="text-align:left">10</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">SHT_DNYSYM</td><td style="text-align:left">11</td><td style="text-align:left"><strong>动态链接的符号表</strong></td></tr></tbody></table><h3 id="节标志位（sh-flag）"><a href="#节标志位（sh-flag）" class="headerlink" title="节标志位（sh_flag）"></a>节标志位（sh_flag）</h3><p>节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以<code>SHF_</code>开头。常见的节标志位如下表所示：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHF_WRITE</td><td style="text-align:left">1</td><td style="text-align:left">表示该节在进程空间中可写</td></tr><tr><td style="text-align:left">SHF_ALLOC</td><td style="text-align:left">2</td><td style="text-align:left">表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td></tr><tr><td style="text-align:left">SHF_EXECINSTR</td><td style="text-align:left">4</td><td style="text-align:left">表示该节在进程空间中可以被执行</td></tr></tbody></table><h3 id="节链接信息（sh-link、sh-info）"><a href="#节链接信息（sh-link、sh-info）" class="headerlink" title="节链接信息（sh_link、sh_info）"></a>节链接信息（sh_link、sh_info）</h3><p>如果节的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的节，这两个成员没有意义。</p><table><thead><tr><th style="text-align:left">sh_type</th><th style="text-align:left">sh_link</th><th style="text-align:left">sh_info</th></tr></thead><tbody><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">该节所使用的<strong>字符串表</strong>在节头表中的下标</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">该节所使用的<strong>符号表</strong>在节头表中的下标</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td><td style="text-align:left">该重定位表所作用的节在节头表中的下标</td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td><td style="text-align:left">该重定位表所作用的节在节头表中的下标</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:left">操作系统相关</td><td style="text-align:left">操作系统相关</td></tr><tr><td style="text-align:left">SHT_DYNSYM</td><td style="text-align:left">操作系统相关</td><td style="text-align:left">操作系统相关</td></tr><tr><td style="text-align:left">other</td><td style="text-align:left">SHN_UNDEF</td><td style="text-align:left">0</td></tr></tbody></table><hr><h2 id="ELF-Sections"><a href="#ELF-Sections" class="headerlink" title="ELF Sections"></a>ELF Sections</h2><h3 id="节的分类"><a href="#节的分类" class="headerlink" title="节的分类"></a>节的分类</h3><p>上述ELF Section Header Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。</p><h4 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h4><p><code>.text</code>节是保存了程序代码指令的<strong>代码节</strong>。<strong>一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中</strong>。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h4><p><code>rodata</code>节保存了只读的数据，如一行C语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="plt节（过程链接表）"><a href="#plt节（过程链接表）" class="headerlink" title=".plt节（过程链接表）"></a>.plt节（过程链接表）</h4><p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，<strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码</strong>。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h4><p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h4><p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本省的空间。<strong><code>.bss</code>节保存了未进行初始化的全局数据</strong>。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p><h4 id="got-plt节（全局偏移表-过程链接表）"><a href="#got-plt节（全局偏移表-过程链接表）" class="headerlink" title=".got.plt节（全局偏移表-过程链接表）"></a>.got.plt节（全局偏移表-过程链接表）</h4><p><code>.got</code>节保存了<strong>全局偏移表</strong>。<strong><code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改</strong>。由于<code>.got.plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="dynsym节（动态链接符号表）"><a href="#dynsym节（动态链接符号表）" class="headerlink" title=".dynsym节（动态链接符号表）"></a>.dynsym节（动态链接符号表）</h4><p><code>.dynsym</code>节保存在<code>text</code>段中。<strong>其保存了从共享库导入的动态符号表</strong>。节类型为<code>SHT_DYNSYM</code>。</p><h4 id="dynstr节（动态链接字符串表）"><a href="#dynstr节（动态链接字符串表）" class="headerlink" title=".dynstr节（动态链接字符串表）"></a>.dynstr节（动态链接字符串表）</h4><p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p><h4 id="rel-节（重定位表）"><a href="#rel-节（重定位表）" class="headerlink" title=".rel.*节（重定位表）"></a>.rel.*节（重定位表）</h4><p>重定位表保存了重定位相关的信息，<strong>这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改</strong>。由于重定位表保存了重定位相关的数据，所以节类型为<code>SHT_REL</code>。</p><h4 id="hash节"><a href="#hash节" class="headerlink" title=".hash节"></a>.hash节</h4><p><code>.hash</code>节也称为<code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p><h4 id="symtab节（符号表）"><a href="#symtab节（符号表）" class="headerlink" title=".symtab节（符号表）"></a>.symtab节（符号表）</h4><p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p><h4 id="strtab节（字符串表）"><a href="#strtab节（字符串表）" class="headerlink" title=".strtab节（字符串表）"></a>.strtab节（字符串表）</h4><p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p><h4 id="ctors节和-dtors节"><a href="#ctors节和-dtors节" class="headerlink" title=".ctors节和.dtors节"></a>.ctors节和.dtors节</h4><p><code>.ctors</code>（<strong>构造器</strong>）节和<code>.dtors</code>（<strong>析构器</strong>）节分别保存了指向构造函数和析构函数的函数指针，<strong>构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码</strong>。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p><p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p><p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。<strong><code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号</strong>。如全局变量，代码中定义的本地函数等。</p><p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p><p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p><p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。<strong><code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号</strong>。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-symtab-strtab.png?x-oss-process=image/resize,w_600" alt=""></p><p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">st_name</td><td style="text-align:left">符号名。该值为该符号名在字符串表中的偏移地址。</td></tr><tr><td style="text-align:left">st_value</td><td style="text-align:left">符号对应的值。存放符号的值（可能是地址或位置偏移量）。</td></tr><tr><td style="text-align:left">st_size</td><td style="text-align:left">符号的大小。</td></tr><tr><td style="text-align:left">st_other</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">st_shndx</td><td style="text-align:left">符号所在的节</td></tr><tr><td style="text-align:left">st_info</td><td style="text-align:left">符号类型及绑定属性</td></tr></tbody></table><p>使用readelf工具我们也能够看到符号表的相关信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s hello.o</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.symtab&apos; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br></pre></td></tr></table></figure></p><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p><p>ELF文件中所有字符表的结构基本一致，如上图所示。</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p><p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -r hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000005 R_X86_64_32       .rodata</span><br><span class="line">000000000000000a R_X86_64_PC32     puts-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p><p>重定位表是一个<code>Elf_Rel</code>类型的数组结构，每一项对应一个需要进行重定位的项。<br>其成员含义如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">r_offset</td><td style="text-align:left">重定位入口的偏移。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可重定位文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可执行文件或共享对象文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td></tr><tr><td style="text-align:left">r_info</td><td style="text-align:left">重定位入口的类型和符号</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可执行文件和共享目标文件</strong>来说，它们的重定位入口是动态链接类型的。</td></tr></tbody></table><p>重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Executable and Linkable Format (ELF)</li><li>《Linux 二进制分析》</li><li>《程序员的自我修养——链接、装载与库》</li><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li></ol><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://chuquan.me/2018/05/12/compiler-principle/#more&quot;&gt;前文&lt;/a&gt;结尾说到编译器编译源代码后生成的文件叫做&lt;strong&gt;目标文件&lt;/strong&gt;，而目标文件经过编译器链接之后得到的就是&lt;stron
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="ELF文件" scheme="http://chuquan.me/tags/ELF%E6%96%87%E4%BB%B6/"/>
    
      <category term="目标文件" scheme="http://chuquan.me/tags/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    
      <category term="可执行文件" scheme="http://chuquan.me/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
</feed>
