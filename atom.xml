<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="http://chuquan.me/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2023-08-03T14:30:27.015Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优雅地管理你的定时任务？</title>
    <link href="http://chuquan.me/2023/07/30/introduction-to-taskloop/"/>
    <id>http://chuquan.me/2023/07/30/introduction-to-taskloop/</id>
    <published>2023-07-30T14:28:05.000Z</published>
    <updated>2023-08-03T14:30:27.015Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800"></p><span id="more"></span><p>在日常开发中，我们经常会使用一些定时任务来辅助完成某些事情。对此，绝大多数人都会选择使用 crontab 来配置定时任务。</p><p>不可否认，crontab 的确是管理定时任务的经典利器，但是你是否和我一样，踩过不少 crontab 的坑呢？</p><p>下面，我将介绍一下个人认为 crontab 的一些痛点和坑。最终，给出另一种优化的解决方案。</p><h1 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h1><p>提到 crontab，这里必须要介绍一下它的配置规则，如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.---------------- 分 (0 - 59)</span><br><span class="line">|  .------------- 时 (0 - 23)</span><br><span class="line">|  |  .---------- 日 (1 - 31) </span><br><span class="line">|  |  |  .------- 月 (1 - 12) </span><br><span class="line">|  |  |  |  .---- 星期 (0 - 6) (星期日可为0或7) </span><br><span class="line">|  |  |  |  | </span><br><span class="line">*  *  *  *  * 执行的命令</span><br></pre></td></tr></table></figure><p>crontab 的配置规则可以分为 5 列，其作用分别是：</p><ul><li>第一列单位为分，表示每时第几分钟，范围为 0-59</li><li>第二列单位为时，表示每天第几小时，范围为 0-23</li><li>第三列单位为日，表示每月第几天，范围为 1-31</li><li>第四列单位为月，表示每年第几月，范围为 1-12</li><li>第五列单位为星期，表示每星期第几天，范围 0-7，0 与 7 表示星期日，其他分别为星期 1-6</li></ul><p>整体而言，crontab 对于不同的单位（除了星期），均支持了三种配置规则：</p><ul><li>指定时间</li><li>指定范围</li><li>指定步长</li></ul><p>通过组合这些配置规则，crontab 可以实现非常多的定时配置。</p><p>在使用 crontab 很长时间之后，我发现 crontab 还是存在着一些使用痛点的，主要有以下几点，下面分别进行介绍。</p><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>默认为情况下，crontab 会将任务输出默认写入到执行用户的邮件中。如果任务有大量输出，则会大量占用磁盘资源，甚至导致系统宕机。</p><p>如下所示，我们配置一个输出当前日志的定时任务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span></span><br></pre></td></tr></table></figure><p>我们可以查看当前用户的邮件，如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /var/mail/<span class="variable">$USER</span></span><br><span class="line">...</span><br><span class="line">Tue Aug  1 22:11:22 CST 2023</span><br></pre></td></tr></table></figure><p>关于这个问题，实践经验都是建议采用如下的方式对任务的输出进行重定向。很显然，这对于新手是非常不友好的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span> &gt;&gt; /dev/null/ 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在实践中，我们可以发现 crontab 的环境变量与控制台的环境变量是存在差异的。因此，经常会出现这样的情景：在控制台中调试完成的任务，在 cron 中执行时，其结果会与预期不相符。事实上，产生这种差异的根本原因就是环境变量。</p><p>此外，crontab 中环境变量不会全局共享。因此，当我们配置多个任务时，可能需要为每个任务单独配置环境变量。很显然，这是一个重复而又繁琐的问题。</p><h2 id="规则语法"><a href="#规则语法" class="headerlink" title="规则语法"></a>规则语法</h2><p>关于 crontab 的规则语法，这是个仁者见仁智者见智的问题。对于老手来说，可能比较简单；对于新人来说，在使用时得去查询各个位置的单位以及不同规则的写法。我觉得 crontab 的规则语法不容易理解的根本原因是缺少语义。如果能优化其规则语法的语义，那就更好不过了。</p><p>另一方面，对于某些极客来说，crontab 的规则可能还不够完备。比如：预期一个定时任务从某个时刻开始或停止执行，或者，预期一个任务循环执行 n 次后结束。对于这种规则，crontab 无法一次性满足，只能通过配置多个任务来辅助完成。</p><h2 id="运行日志"><a href="#运行日志" class="headerlink" title="运行日志"></a>运行日志</h2><p>在实际应用中，我们经常需要借助任务的运行日志来排查问题。此时，我们就需要修改 crontab，将任务的输出重定向至某个文件，从而方便后续进行查看。当任务非常多的时候，我们很难记住每个任务对应的日志文件是哪个。这也是 crontab 的一个痛点。</p><h1 id="taskloop"><a href="#taskloop" class="headerlink" title="taskloop"></a>taskloop</h1><p>为了解决 crontab 的诸多痛点，我在业余时间开发了一款优化版的定时任务管理器——<a href="https://github.com/baochuquan/taskloop">taskloop</a>。</p><p>taskloop 底层运行在 cron 守护进程之上，基于 crontab 配置了最小粒度的调度规则，实现了一个中间层，从而解决了 crontab 的诸多痛点。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>taskloop 提供了一系列的命令，实现了一个相对完整（如有缺失，补充实现）的工作流，其主要包含以下这些特性。</p><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><p><code>taskloop env</code> 命令提供了查看、导入、删除环境变量的功能。</p><p>如下所示，为环境变量查看的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> </span><br><span class="line"></span><br><span class="line">PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5/bin:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global/bin:/Users/baochuquan/.rvm/rubies/ruby-2.6.5/bin:/usr/local/texlive/2023basic/bin/universal-darwin:/Users/baochuquan/.nvm/versions/node/v18.16.0/bin:/usr/local/opt/sqlite/bin:/usr/local/sbin:/usr/local/opt/gettext/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Users/baochuquan/.rvm/bin:/Users/baochuquan/Flutter/bin:/Users/baochuquan/Library/Android/sdk/tools</span><br><span class="line">RUBY_VERSION=ruby-2.6.5</span><br><span class="line">GEM_PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global</span><br><span class="line">GEM_HOME=/Users/baochuquan/.rvm/gems/ruby-2.6.5</span><br><span class="line">IRBRC=/Users/baochuquan/.rvm/rubies/ruby-2.6.5/.irbrc</span><br><span class="line">NOX_ROOT=/Users/baochuquan/Develop/nox</span><br><span class="line">NOX_NAME=nox</span><br><span class="line">NOX_COMMON=/Users/baochuquan/Develop/nox/common</span><br><span class="line">NOX_CONFIG=/Users/baochuquan/Develop/nox/config</span><br><span class="line">NOX_SCRIPTS=/Users/baochuquan/Develop/nox/scripts</span><br></pre></td></tr></table></figure><p>如下所示，为环境变量导入的使用示例。示例中，我导入了两个环境变量 <code>JAVA_HOME</code> 和 <code>GROOVY_HOME</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --import=JAVA_HOME,GROOVY_HOME</span><br><span class="line"></span><br><span class="line">importing JAVA_HOME ...</span><br><span class="line">    JAVA_HOME=/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">importing GROOVY_HOME ...</span><br><span class="line">    GROOVY_HOME=/usr/local/opt/groovy/libexec</span><br><span class="line"></span><br><span class="line">import global environment variables complete.</span><br></pre></td></tr></table></figure><p>如下所示，为环境变量删除的使用示例。示例中，我删除了 <code>GROOVY_HOME</code> 环境变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --remove=GROOVY_HOME</span><br><span class="line"></span><br><span class="line">remove global environment variables complete.</span><br></pre></td></tr></table></figure><p>经过一系列导入、删除操作之后，我们可以通过 <code>taskloop env</code> 命令来查看导入结果是否正确。</p><h3 id="启动-关闭"><a href="#启动-关闭" class="headerlink" title="启动&#x2F;关闭"></a>启动&#x2F;关闭</h3><p>taskloop 具有一个全局的开关，即启动和关闭的能力。前面我们提到 taskloop 底层是运行在 cron 守护进程之上，对此，启动功能的本质就是将 taskloop 注册至 crontab；关闭功能的本质就是将 taskloop 从 crontab 注销。</p><p>如下所示，为启动 taskloop 的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$  taskloop launch</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has launched successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如下所示，为关闭 taskloop 的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop shutdown</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has shutdown successfully.</span><br><span class="line"></span><br><span class="line">    byeeeeeeeeeeeeeeeee !</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>taskloop 通过读取注册的 Taskfile 来执行所有的任务，Taskfile 中可以定义一系列用户自定义的任务。为了便于使用，taskloop 提供了一个初始化命令，可以自动创建一个 Taskfile 模板，从而供用户进行修改和定制。</p><p>如下所示，为初始化的使用示例。<code>taskloop init</code> 方法创建了一个 Taskfile 模板，并定义了所有支持的属性，我们可以自定义任务，包括任务的路径、名称、执行规则等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop init</span><br><span class="line">$ <span class="built_in">cat</span> Taskfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># env to set environment variables which are shared by all tasks defined in the Taskfile. &lt;Optional&gt;</span></span><br><span class="line"><span class="comment"># env &quot;ENV_NAME&quot;, &quot;ENV_VALUE&quot;</span></span><br><span class="line"></span><br><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="发布-撤销"><a href="#发布-撤销" class="headerlink" title="发布&#x2F;撤销"></a>发布&#x2F;撤销</h3><p>当我们完成了对 Taskfile 的定义之后，可以进行发布。发布过程中，taskloop 会检查 Taskfile 中的语法规则，如果不符合将抛出异常，并提示错误；如果符合规则，则完成发布。Taskfile 将正式生效，后续的任务执行将以此为准。</p><p>如下所示，为发布的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop deploy</span><br><span class="line"></span><br><span class="line">                       (@&amp;/////%@@@@@@@@@@@@@<span class="comment">#</span></span><br><span class="line">                          @@&amp;@&amp;////////////////(@@<span class="comment">#</span></span><br><span class="line">                         /@(///////////////////////%@/</span><br><span class="line">                       *@////////////////////////////<span class="comment">#@,</span></span><br><span class="line">                      @&amp;///////////////////////////////@%</span><br><span class="line">                     @&amp;//////////////(@////@&amp;<span class="comment">#/////////(@</span></span><br><span class="line">                     @////////////@@  @////@    ,.@////@@</span><br><span class="line">                    /@//////////&amp;@  ,@@////@@@&amp;.  *///@@</span><br><span class="line">                    ,@/////////(@@@   @///&amp;@     /@@///@@</span><br><span class="line">                     @%////////@@     @@@&amp;           @@/@<span class="comment">#</span></span><br><span class="line">                      @<span class="comment">#///////@           ,</span></span><br><span class="line">                       @@//////@&amp;      @(//@</span><br><span class="line">                         @@/////%@    @////@</span><br><span class="line">                            @@/////<span class="comment">#@@@////@</span></span><br><span class="line">                                &amp;@@@&amp;<span class="comment">#((&amp;@@</span></span><br><span class="line">                          /&amp;<span class="comment">#         @///@@</span></span><br><span class="line">                       ,///,*.        @////@</span><br><span class="line">                   &amp;<span class="comment">#  %/,@           @@///@</span></span><br><span class="line">                 (, .*/&amp;*%/*%///&amp;       (@@@         ,*/////*.</span><br><span class="line">           %/<span class="comment">#@, ////&amp;  @  % .&amp;  /@%/(/    /#/#@(                 #@#/&amp;</span></span><br><span class="line">        (/&amp;               .           .////,                           &amp;//</span><br><span class="line">       &amp;(//@                         &amp;//////&amp;                         @///@</span><br><span class="line">         (@%//////<span class="comment">#&amp;@@@@@@@@@@%///////@@  @@///////%@@@@@@@@@@&amp;#//////#@#</span></span><br><span class="line">                %@@@@&amp;@@@@@&amp;&amp;@@@@/              /@@@@&amp;&amp;@@@@@&amp;@@@@&amp;</span><br><span class="line"></span><br><span class="line">                              Taskfile deploy success!</span><br></pre></td></tr></table></figure><p>当然，在某些情况下，我们需要撤销已经发布的 Taskfile。此时，我们可以执行如下命令进行撤销。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop undeploy</span><br><span class="line"></span><br><span class="line">Taskfile <span class="keyword">in</span> &lt;/Users/baochuquan/Github/taskloop&gt; has been undeployed successfully.</span><br></pre></td></tr></table></figure><h3 id="任务查看"><a href="#任务查看" class="headerlink" title="任务查看"></a>任务查看</h3><p>为了便于查看当前已发布的任务，taskloop 提供了一个命令方便用户进行查询。如下所示，为任务查看的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop list</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Tasks above are defined <span class="keyword">in</span> Taskfile of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">  &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt;</span><br><span class="line">    t.name        = haha</span><br><span class="line">    t.path        = ./test/Test01.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; specific: Aug</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; scope: between 25, 30</span><br><span class="line">    t.loop        = unit: loop; default rule</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br><span class="line">  &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt;</span><br><span class="line">    t.name        = baocq</span><br><span class="line">    t.path        = ./test/Test02.rb</span><br><span class="line">    t.year        = unit: year; default rule</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; interval: 1</span><br><span class="line">    t.loop        = unit: loop; loop: 3</span><br><span class="line">    t.start_point = unit: full; boundary: start from 2023-7-31 22:31:00</span><br><span class="line">    t.end_point   = unit: full; boundary: end to 2023-7-31 22:35:00</span><br><span class="line">  &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt;</span><br><span class="line">    t.name        = chuquan</span><br><span class="line">    t.path        = ./test/Test03.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; scope: after 22</span><br><span class="line">    t.minute      = unit: minute; interval: 10</span><br><span class="line">    t.loop        = unit: loop; loop: 1</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br></pre></td></tr></table></figure><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p>为了解决 crontab 的日志查询问题，taskloop 同样提供了一个命令支持查询不同维度的日志，包括：系统日志（即 taskloop 运行日志）、任务日志。</p><p>如下所示，为查看系统日志的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --cron</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Log of cron:</span><br><span class="line"></span><br><span class="line">Trigger Time: &lt;2023-08-03 08:24:00 +0800&gt;</span><br><span class="line">Checking: &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure><p>如下所示，为查看任务日志的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --task-name=baocq</span><br><span class="line">=============================</span><br><span class="line">Project of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">Log of &lt;Task.name: haha&gt; above:</span><br><span class="line">&lt;Trigger Time: 2023-08-03 08:27:16 +0800&gt;</span><br><span class="line">Test0101</span><br><span class="line"></span><br><span class="line">=============================</span><br></pre></td></tr></table></figure><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p><code>taskloop init</code> 命令会创建一个 Taskfile 文件，我们可以在 Taskfile 文件中自定义不同的任务与规则。这里，taskloop 定义了一套语法规则，我们将基于如下所示的 Taskfile 模板进行介绍。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>模板中列出了任务支持的所有属性，首先有两个必要属性 <code>name</code> 和 <code>path</code>。</p><ul><li><code>name</code>：用于指出任务的名称，同一个 Taskfile 中不能有同名的任务，主要用于日志查询时指定名称。</li><li><code>path</code> 用于指出任务的路径，taskloop 会根据此路径加载并执行任务脚本。</li></ul><p>模板中的其他属性均为非必要属性，用于描述执行规则。关于执行规则，taskloop 中主要定义如下几种规则。</p><ul><li><strong>指定时间规则（Specific Rule）</strong><ul><li>指定时间规则用于指定特定的时间值，对应的语法是 <code>at</code>。</li><li>支持指定时间规则的属性有 <code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>，其中 <code>week</code>、<code>month</code>、<code>day</code> 属性需要使用预定义的符号，其余属性可以直接使用数值。<ul><li>对于 <code>week</code>，需要使用星期符号，如：<code>:Sun</code>、<code>:Mon</code> 等。</li><li>对于 <code>month</code>，需要使用月份符号，如：<code>:Jan</code>、<code>:Feb</code> 等。</li><li>对于 <code>day</code>，需要使用表示月份中第几天的符号，如：<code>:day1</code>，<code>:day2</code> 等。</li></ul></li><li>示例<ul><li><code>t.week = at :Mon, :Sub, :Tue</code></li><li><code>t.month = at :Feb, :Aug</code></li><li><code>t.day = at :day2, :day8, :day30, day:31</code></li><li><code>t.year = at 2023, 2024</code></li><li><code>t.hour = at 10, 11</code></li><li><code>t.minute = at 59</code></li></ul></li></ul></li><li><strong>时间范围规则（Scope Rule）</strong><ul><li>时间范围规则包含三种子规则，对应的语法分别是：<code>before</code>、<code>between</code>、<code>after</code>。<ul><li><code>before</code> 语法表示在小于等于某个值时执行。</li><li><code>between</code> 语法表示在大于等于某个值，且小于等于另一个值时执行。</li><li><code>after</code> 语法表示在大于等于某个值时执行。</li></ul></li><li>支持时间范围规则的属性有 <code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li><li>示例<ul><li><code>t.year = before 2026</code></li><li><code>t.week = between :Mon, :Fri</code></li><li><code>t.hour = after 12</code></li></ul></li></ul></li><li><strong>时间间隔规则（Interval Rule）</strong><ul><li>时间间隔规则用于指定两次任务之间的时间间隔，对应的语法是 <code>interval</code>。</li><li>支持时间间隔规则的属性有 <code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li><li>示例<ul><li><code>t.minute = interval 5</code></li><li><code>t.day = interval 1</code></li></ul></li></ul></li><li><strong>循环次数规则（Loop Rule）</strong><ul><li>循环次数规则用于指定任务循环的次数，对应的语法是 <code>loop</code>。</li><li>支持循环次数规则的属性只有 <code>loop</code>。</li><li>示例<ul><li><code>t.loop = loop 10</code></li></ul></li></ul></li><li><strong>时间列表规则（Time List Rule）</strong><ul><li>时间列表规则用于指定任务执行的时间列表，对应的语法是 <code>time</code>。其与 <code>hour</code>、<code>minute</code> 属性冲突，不能同时使用。</li><li>支持时间列表规则的属性只有 <code>time</code>。</li><li>示例<ul><li><code>t.time = time &quot;10:00:00&quot;, &quot;7:00:00&quot;</code></li></ul></li></ul></li><li><strong>日期列表规则（Date List Rule）</strong><ul><li>日期列表规则用于指定执行任务的日期列表，对应的语法是 <code>date</code>。其与 <code>year</code>、<code>month</code>、<code>day</code> 属性冲突，不能同时使用。</li><li>支持日期列表规则的属性只有 <code>date</code>。</li><li>示例<ul><li><code>t.date = date &quot;2023-10-1, &quot;2023-5-1</code></li></ul></li></ul></li><li><strong>执行边界规则（Boundary Rule）</strong><ul><li>执行边界规则包含两种子规则，对应的语法分别是 <code>from</code> 和 <code>to</code>。<ul><li><code>from</code> 语法表示任务从某一个时刻开始执行，支持的属性只有 <code>start_point</code>。</li><li><code>to</code> 语法表示任务在某一时刻之后不在执行，支持的属性只有 <code>end_point</code>。</li></ul></li><li>示例<ul><li><code>t.start_point = &quot;2023-10-1 10:00:00&quot;</code></li><li><code>t.end_point = &quot;2023-10-30 23:59:00</code></li></ul></li></ul></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>taskloop 的工作流程可以分为三个步骤：</p><ul><li><strong>启动&#x2F;关闭</strong></li><li><strong>初始化</strong></li><li><strong>发布&#x2F;撤销</strong></li></ul><p>启动&#x2F;关闭步骤是一个全局开关，对应分别有两个命令，如上所述。关于启动，一般只在最开始使用 taskloop 的时候使用启动命令。如果希望停止所有已注册任务的执行，则可以执行关闭命令。</p><p>taskloop 建议用户能够使用一个目录统一管理所有的定时任务，当希望为这些定时任务创建定时规则时，可以在目录下执行初始化命令，从而生成一个 Taskfile 文件。之后，即可自定义定时规则。如果用户本地维护了多个目录管理定时任务，则需要在不同的目录下分别执行一次初始化命令，从而完成任务规则自定义。</p><p>发布&#x2F;撤销步骤相对而言会比较频繁，当初始化并自定义 Taskfile 之后，我们就可以执行发布命令，使得 Taskfile 真正在 taskloop 中生效。当然，有时候我们会在发布后发现一些错误，我们可以修改后重新发布，或者为了避免产生副作用，可以执行撤销命令。注意，发布&#x2F;撤销命令必须在 Taskfile 的同级目录下执行。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单介绍了一下我最近业余时间写的一个定时任务管理工具——taskloop。同时，解释了为什么做这个工具的原因（即解决 crontab 的痛点）。</p><p>关于软件 logo，我花了两晚设计了这样一个形象。两个圈组成一个莫比乌斯环，象征着循环。海豚跳圈作为任务执行的抽象，在两个圈中循环穿越，象征着 taskloop 永不停止地运行。</p><p>忘了说，其实写这篇文章的另一个重要目的是为了推广一下我的作品，也希望有兴趣的朋友能够给一些意见，甚至可以一起参与软件的开发和完善。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/baochuquan/taskloop">taskloop</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby" scheme="http://chuquan.me/categories/Ruby/"/>
    
    
    <category term="taskloop" scheme="http://chuquan.me/tags/taskloop/"/>
    
    <category term="cron" scheme="http://chuquan.me/tags/cron/"/>
    
    <category term="crontab" scheme="http://chuquan.me/tags/crontab/"/>
    
    <category term="定时任务" scheme="http://chuquan.me/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何从链接原理的角度理解 fishhook 的设计思想？</title>
    <link href="http://chuquan.me/2023/06/24/understand-fishhook-design/"/>
    <id>http://chuquan.me/2023/06/24/understand-fishhook-design/</id>
    <published>2023-06-24T14:29:35.000Z</published>
    <updated>2023-07-15T07:42:21.324Z</updated>
    
    <content type="html"><![CDATA[<p>最近在三刷《程序员的自我修养：链接、装载与库》，为了加深对于相关知识的理解，我又阅读了 fishhook 的源码。本文希望从程序的链接原理出发，详细介绍 fishhook 的设计原理，学习其中的设计思想。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Fishhook 是 Facebook 开源的一款面向 iOS&#x2F;macOS 平台的 <strong>符号动态重绑定</strong> 工具，允许开发者在运行时修改 Mach-O 中的符号（函数），从而实现 <strong>动态库</strong> 的函数 hook 能力。</p><p>Fishhook 提供了两个用于符号重绑定的接口，分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], <span class="type">size_t</span> rebindings_nel)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rebind_symbols_image</span><span class="params">(<span class="type">void</span> *header,</span></span><br><span class="line"><span class="params">                         <span class="type">intptr_t</span> slide,</span></span><br><span class="line"><span class="params">                         <span class="keyword">struct</span> rebinding rebindings[],</span></span><br><span class="line"><span class="params">                         <span class="type">size_t</span> rebindings_nel)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>rebind_symbols</code> 可以在所有动态库范围内进行符号重绑定，而 <code>rebind_symbols_image</code> 则限制了动态库的范围，只能指定某一个动态库。</p><p>这里，我们先预设几个问题，后面会逐步进行解答：</p><ul><li>问题一：fishhook 是在什么时候完成函数 hook 的？</li><li>问题二：fishhook 为什么只支持 hook 动态库函数？</li></ul><p>为了能介绍清楚 fishhook 的实现原理，本文我将重点介绍程序的链接原理，包括：静态链接、动态链接。其中，涉及到的术语和概念主要是基于 ELF 可执行文件（或目标文件），在真正介绍 fishhook 的原理时，我会将 Mach-O 中的术语与 ELF 进行比较和映射，从而达到一个举一反三的效果。</p><h1 id="可执行文件格式"><a href="#可执行文件格式" class="headerlink" title="可执行文件格式"></a>可执行文件格式</h1><p>在介绍链接原理之前，我们有必要先了解一下可执行文件（目标文件）的基本格式，不同的平台有着不同的格式，分别是：</p><ul><li>对于 Windows 平台，其采用的是 <strong>PE（Portable Executable）</strong> 格式</li><li>对于 Linux 平台，其采用的是 <strong>ELF（Executable Linkable Format）</strong> 格式</li><li>对于 iOS&#x2F;macOS 平台，其采用的是 <strong>Mach-O（Mach Object）</strong> 格式</li></ul><p>尽管不同平台的可执行文件格式不同，但是它们的组织结构和规则是基本类似的。如下图所示，不同格式的可执行文件基本都包含如下几个部分：</p><ul><li>文件头</li><li>segment 表</li><li>section 表</li><li>section 数据</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-01.png?x-oss-process=image/resize,w_800"></p><p>文件头用于描述可执行文件的元信息，包括：文件类型、系统版本、segment 表的位置和大小、section 表的位置和大小等等。Section 表本质上是一个索引表，其存储了每一个 section 的元信息，比如对应 section 在文件中的位置和大小。至于 section，它是可执行文件的基本组成单元，常见 section 有：<code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.symtab</code>、<code>.strtab</code> 等。</p><p>那么 segment 表的作用又是什么呢？</p><h2 id="section-与-segment"><a href="#section-与-segment" class="headerlink" title="section 与 segment"></a>section 与 segment</h2><p>事实上，两者的区别主要在于：section 用于描述可执行文件的静态存储布局，segment 用于描述可执行文件的装载内存布局。</p><p>我们知道可执行文件是以 section 为基本单元存储的，section 的类型非常多，如：<code>.data</code>、<code>.text</code>、<code>.rodata</code> 等。假如，我们的可执行文件中有两个 section，分别是 <code>.init</code> 和 <code>.text</code>，两者的大小分别是 3500B 和 4100B。假设系统的页面大小为 4KB，我们来分别看一下基于 section 装载和基于 segment 装载的内存占用情况。</p><p>下图右部所示为基于 section 装载的内存占用情况，其中 <code>.init</code> 单独占用一个页，且页没有全部使用；<code>.text</code> 会单独占用两个页，且第二页绝大多数内存空间没有使用，总共浪费内存 3 x 4KB - 3500B - 4100B &#x3D; 4688B。</p><p>下图左部所示为基于 segment 装载的内存占用情况，<code>.text</code> 占用了两个页，且与 <code>.init</code> 共享了一个页，总共浪费内存 2 x 4KB - 3500B - 4100B &#x3D; 592B。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-02.png?x-oss-process=image/resize,w_800"></p><p>很显然，相比于基于 section 装载，基于 segment 装载对于内存占用的优化非常明显，内存碎片更少。在实际中，程序在装载时会将相同权限的 section 合并在一个 segment 中，比如：<code>.init</code> 和 <code>.text</code> 都合并成为可读可执行权限的 segment，作为代码段；可读可写的 section 合并在为一个 segment，作为数据段。</p><h1 id="程序的链接原理"><a href="#程序的链接原理" class="headerlink" title="程序的链接原理"></a>程序的链接原理</h1><p><strong>链接（Linking）</strong> 的本质是把多个目标文件相互拼接到一起，使得函数调用、变量访问等指令能够找到正确的内存地址。然而，这一切都是围绕着 <strong>符号（Symbol）</strong> 完成的。</p><p>那么到底什么是符号？举个例子，目标文件 B 调用了目标文件 A 中的函数 <code>foo</code>。对此，我们认为目标文件 A 定义了函数 <code>foo</code>，目标文件 B 引用了函数 <code>foo</code>。在链接过程中，我们将函数和变量统称为 <strong>符号（Symbol）</strong>，函数名和和变量名统称为 <strong>符号名（Symbol Name）</strong>。因此，我们也可以认为目标文件 A 包含了函数 <code>foo</code> 的 <strong>符号定义（Symbol Definition）</strong>，目标文件 B 包含了函数 <code>foo</code> 的 <strong>符号引用（Symbol Reference）</strong>。</p><p>这时候问题来了，链接过程是如何基于符号完成对二进制指令中内存地址的修正呢？对此，我们可以先来了解一下静态链接。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接会在编译期将多个目标文件合并为一个可执行文件。因此，里面包含了所有的符号、重定位项、字符串等。</p><p>在编译过程中，编译器会为每一个变量或函数生成一个符号项，符号项包含的信息主要有：</p><ul><li><strong>符号名</strong>：即一个指向字符串表的索引，比如：字符串 <code>foo</code> 在字符串表中的偏移量。</li><li><strong>符号类型</strong>：类型有很多，比如：全局符号、局部符号、未定义符号等。</li><li><strong>符号值</strong>：<strong>符号定义</strong> 的内存地址，用于修正二进制指令中的内存地址。这个地址修正的过程被称为 <strong>重定位</strong>。</li></ul><p>此外，编译器还会为每个变量引用或函数引用生成一个重定位项。由于每一个重定位项记录了每一次对于符号的引用，因此，我们可以将其称为符号引用项。这样也就构成了符号定义和符号引用的一对多关系，毕竟，我们可以在不同的地方引用同一个变量或函数。</p><p>基于如下示意图，静态链接的整体工作原理大概可以分为以下三个步骤：</p><ul><li>根据重定位项中的符号索引，去符号表找到对应的符号项，并获取到对应符号的符号值，即内存地址。</li><li>根据重定位项中的重定位地址，找到代码段中对应的字节地址，将其修正为步骤一获取到的内存地址。</li><li>遍历重定位表中的所有重定位项，重复步骤一和步骤二。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/static-linking-01.png?x-oss-process=image/resize,w_800"></p><p>由于静态链接时，程序所依赖的所有目标文件都已经合并在了一个可执行文件中，因此几乎不存在符号项中的符号值（内存地址）不确定的情况，对此，静态链接器只需要基于重定位表进行重定位即可。这其实就是大家常说『静态链接的重点是重定位』的原因。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>动态链接的基本思想是 <strong>将程序按照模块拆分成各个独立的部分，在运行时将它们链接在一起形成一个完整的程序</strong>，而不是像静态链接一样在编译时把所有的模块都链接成一个独立的可执行文件。因此，动态链接可以有效解决静态链接存在的 <strong>内存空间浪费</strong> 和 <strong>程序更新困难</strong> 的问题。</p><p>那么对于动态链接，我们是否可以直接采用静态链接的做法呢？这种方案理论上可以，但却不是最优解，因为静态链接会修改代码段，我们很难让共享对象在被多次重定位之后也能继续安全稳定的运行。</p><p>举一个例子，如下所示，一个动态共享对象 <code>X</code> 内部会引用外部的一个变量 <code>a</code>。当程序 <code>A</code> 与动态共享对象 <code>X</code> 完成重定位后，<code>X</code> 代码段中的某个指令的访存地址可能是一个值；当程序 <code>B</code> 与动态共享对象 <code>X</code> 完成重定位后，<code>X</code> 代码段中同位置的访存地址可能会被修改成另一个值。这时候，必然会出现其他程序无法正常执行的情况。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-01.png?x-oss-process=image/resize,w_800"></p><p>关于如何解决多进程之间的重定位冲突问题，我们可以引用下图所示的经典名言来描述动态链接的解决方案。当然，在具体的实现中，动态链接根据链接的时机，还可以分为 <strong>装载时链接（Load-Time Linking）</strong> 和 <strong>延迟链接（Lazy Linking）</strong>。两者的实现思路只有略微的差异，下面我们将分别进行介绍。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800"></p><h3 id="装载时链接"><a href="#装载时链接" class="headerlink" title="装载时链接"></a>装载时链接</h3><p>下图所示为装载时链接的工作原理示意图。对于共享对象而言，其代码段会被多个进程所共享，因此不能直接在代码段中进行重定位，修改内存地址。考虑到多进程共享对象时，共享对象会为每个进程拷贝一份数据段，支持修改。因此，一种称为 <strong>地址无关代码（PIC，Position-Independent Code）</strong> 的技术诞生了，其基本思想是：在编译时配置 PIC 编译选项，将指令部分中需要被修改的部分分离出来，跟数据部分放在一起。这样指令部分可以保持不变，而数据部分可以在每个进程中有一个独立的副本。</p><p>对于 PIC 技术，代码运行性能会比静态链接要差一点。因为指令在访问外部变量或外部函数时，必须先通过指针去数据段找到对应的位置，再从中取出真实的内存地址，很显然多了一次间接操作，损耗了性能。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-02.png?x-oss-process=image/resize,w_800"></p><p>在装载前，共享对象 <code>X</code> 的符号表中的外部符号 <code>bar</code> 的内存地址是未定义的。但是，程序 <code>A</code> 的符号表中的符号 <code>bar</code> 的内存地址是确定的（因为符号 <code>bar</code> 的符号定义位于程序 <code>A</code> 中）。因此，在装载时我们就可以决议出共享对象 <code>X</code> 的外部符号 <code>bar</code> 的地址。这个过程，我们称之为 <strong>装载时绑定（Load-Time Binding）</strong> 或 <strong>装载时符号绑定（Load-Time Symbol Binding）</strong>。</p><p>当外部符号 <code>bar</code> 的内存地址绑定完成后，我们就可以进行后续的重定位了。其步骤和静态链接的重定位类似，主要包括以下几步：</p><ul><li>根据动态重定位项中的符号索引，去动态符号表中找到对应的符号项，并获取对应符号的符号值，即装载时绑定的内存地址。</li><li>根据动态重定位项中的重定位地址，找到 <strong>数据段</strong> 中对应的字节地址，将其修正为步骤一获取到的内存地址。</li><li>遍历动态重定位表中的所有重定位项，重复步骤一和步骤二。</li></ul><p>在 PIC 技术中，编译器会在数据段中为每一个符号存储一个占位桩（stub），用于存储符号的真实内存地址。这些占位桩组成了一个表，我们称之为 <strong>全局偏移表（GOT，Global Offset Table）</strong>。</p><p>综上述可以看出，装载时链接包含了两个重要的步骤，分别是装载时绑定和重定位。虽然中间多了一步间接索引内存地址，损耗了一些性能，但是程序的灵活性和复用性提高了很多。</p><h3 id="延迟链接"><a href="#延迟链接" class="headerlink" title="延迟链接"></a>延迟链接</h3><p>考虑到程序运行的局部性，实际上在进程生命周期中很多变量或函数并不会被调用。于是，诞生了延迟链接技术，可以支持进程只在第一次调用符号时才进行链接。</p><p>下图所示为延迟链接的工作原理示意图，本质上与装载时链接差不多，主要区别在于：装载时链接在数据段中使用了 GOT 存储符号地址，延迟链接则在数据段中使用了 <strong>过程链接表（PLT，Procedure Linkage Table）</strong> 存储符号地址。当 PLT 表项中符号的内存地址未决议时，PLT 表项中的占位桩（stub）存储的是一段代码的地址。当这段代码完成符号绑定和重定位后，会将符号的真实内存地址回填到占位桩中，覆盖默认的代码地址，从而实现仅在第一次调用符号时才进行链接。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-03.png?x-oss-process=image/resize,w_800"></p><p>延迟链接的关键是如何实现在第一次调用符号时进行链接，这个过程包含了 <strong>延迟绑定（Lazy Binding）</strong> 和重定位。关于 PLT 的存储，很多目标文件会将其存储在命名为 <code>got.plt</code> 的 section 中，Mach-O 和 ELF 都是如此，这一点需要注意。</p><h1 id="Fishhook-实现原理"><a href="#Fishhook-实现原理" class="headerlink" title="Fishhook 实现原理"></a>Fishhook 实现原理</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>上述介绍了程序的链接原理，尤其是在理解了动态链接之后，如果你细想思考一下，很容易就能想到 fishhook 的设计思想。</p><p>下图展示了 fishhook 的设计思想，非常简单巧妙，核心思想就是 <strong>将目标符号（函数）对应的 GOT 表项或 PLT 表项中存储的符号值（内存地址），替换成 hook 函数的内存地址</strong>。通过这种方式，无论是装载时链接还是延迟链接，我们都可以实现对动态共享库函数的 hook。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-04.png?x-oss-process=image/resize,w_800"></p><p>下面，我们来介绍一下 fishhook 实现细节中与 Mach-O 的相关概念。</p><h2 id="Non-lazy-Symbol-Pointer-Lazy-Symbol-Pointer"><a href="#Non-lazy-Symbol-Pointer-Lazy-Symbol-Pointer" class="headerlink" title="Non-lazy Symbol Pointer &amp; Lazy Symbol Pointer"></a>Non-lazy Symbol Pointer &amp; Lazy Symbol Pointer</h2><p>如下所示为《Mach-O Programming Topics》中对两者的解释：</p><blockquote><p> Non-lazy symbol references are resolved (bound to their definitions) by the dynamic linker when a module is loaded.A non-lazy symbol reference is essentially a symbol pointer—a pointer-sized piece of data. The compiler generates non-lazy symbol references for data symbols or function addresses.</p><p> Lazy symbol references are resolved by the dynamic linker the first time they are used (not at load time). Subsequent calls to the referenced symbol jump directly to the symbol’s definition.Lazy symbol references are made up of a symbol pointer and a symbol stub, a small amount of code that directly dereferences and jumps through the symbol pointer. The compiler generates lazy symbol references when it encounters a call to a function defined in another file.</p></blockquote><p>Non-lazy Symbol Pointer 存储的是指向符号定义的指针，它与 GOT 中的表项定义非常类似。由 Non-lazy Symbol Pointer 组成的表，在 Mach-O 中我们称为 Non-lazy Symbol Pointer Table。</p><p>Lazy Symbol Pointer 包含一个指向符号定义的指针、一个占位桩以及一段代码（可用于延迟绑定和重定位），它与 PLT 中的表项定义非常类似。由 Lazy Symbol Pointer 组成的表，在 Mach-O 中我们称之为 Lazy Symbol Pointer Table。</p><h2 id="Indirect-Symbol-Table"><a href="#Indirect-Symbol-Table" class="headerlink" title="Indirect Symbol Table"></a>Indirect Symbol Table</h2><p>上述的 Non-lazy Symbol Pointer 和 Lazy Symbol Pointer 并没有包含符号名相关的信息，然而在实际的符号查找、绑定的过程是需要用到的。因此，对于 Non-lazy Symbol Pointer Table 和 Lazy Symbol Pointer Table 各自有一个同步的间接符号表，可以用于配合完成链接工作。Fishhook 也是借助 Indirect Symbol Table 间接获取符号名，然后与目标符号进行判等比较，从而最终完成 hook 工作。</p><p>Indirect Symbol Table 与 Symbol Pointer Table 的表项是一一对应的，比如：Indirect Symbol Table 中第 1601 项存储的就是 Symbol Pointer Table 中第 1601 项的符号索引，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dynamic-linking-05.png?x-oss-process=image/resize,w_800"></p><h2 id="Symbol-Pointer-目标符号地址替换"><a href="#Symbol-Pointer-目标符号地址替换" class="headerlink" title="Symbol Pointer 目标符号地址替换"></a>Symbol Pointer 目标符号地址替换</h2><p>Fishhook 的核心是 <strong>完成 Symbol Pointer 的地址替换</strong>，无论是 Non-lazy Symbol Pointer 还是 Lazy Symbol Pointer。其实现的关键步骤主要包括以下几步：</p><ul><li>查找数据段，即 <code>SEG_DATA</code> 或 <code>SEG_DATA_CONST</code></li><li>在数据段中查找 <code>LAZY_SYMNBOL_POINTERS</code> 和 <code>NON_LAZY_SYMBOL_POINTERS</code> 类型的 section</li><li>分别对 <code>LAZY_SYMBOL_POINTERS</code> 和 <code>NON_LAZY_SYMBOL_POINTERS</code> section 进行 Symbol Pointer 目标符号地址替换</li></ul><p>Symbol Pointer 目标符号地址替换的过程主要有以下几步：</p><ul><li>根据 <code>LAZY_SYMBOL_POINTERS</code> 或 <code>NON_LAZY_SYMBOL_POINTERS</code> section 获取其对应的 Indirect Symbol Table</li><li>遍历 section，同步遍历 Indirect Symbol Table，获取对应的符号名</li><li>遍历过程中，判断符号名是否与目标符号名匹配。如果匹配，则将 Symbol Pointer 的符号地址替换成 hook 函数的地址；否则，继续遍历，直到结束。</li></ul><p>这里涉及到了 fishhook 中的两个函数实现，分别是 <code>rebind_symbols_for_image</code> 函数和 <code>perform_rebinding_with_section</code> 函数，有兴趣的朋友可以自行阅读，本文就不粘贴代码了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们从链接原理的角度介绍了 fishhook 的设计思路。通过这种自顶向下的方法来分析，我们很快就可以联想到如何去实现一个针对 ELF 格式的 hook 工具。</p><p>最后，我们再来回顾一下本文开头预留的几个问题。</p><p>问题一：fishhook 是在什么时候完成函数 hook 的？fishhook 会在调用 <code>rebind_symbols</code> 或 <code>rebind_symbols_image</code> 方法时去遍历镜像，从而完成对目标符号的地址替换。</p><p>问题二：fishhook 为什么只支持 hook 动态库函数？动态库的 PIC 技术支持在数据段进行重定位，因此允许我们进行目标地址修改。而 fishhook 的整个机制就是建立在动态链接原理的基础上，因此仅支持 hook 动态库函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养：装载、链接与库》</li><li><a href="https://studfile.net/preview/2082911/">OS X ABI Mach-O File Format Reference</a></li><li>Mach-O Programming Topics</li><li><a href="https://github.com/facebook/fishhook">fishhook</a></li><li><a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">BSD Library Functions Manual——dyld(3)</a></li><li><a href="https://man7.org/linux/man-pages/man3/dladdr.3.html">dladdr(3) — Linux manual page</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在三刷《程序员的自我修养：链接、装载与库》，为了加深对于相关知识的理解，我又阅读了 fishhook 的源码。本文希望从程序的链接原理出发，详细介绍 fishhook 的设计原理，学习其中的设计思想。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; clas</summary>
      
    
    
    
    <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
    <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
    <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
    <category term="fishhook" scheme="http://chuquan.me/tags/fishhook/"/>
    
    <category term="PIC" scheme="http://chuquan.me/tags/PIC/"/>
    
    <category term="GOT" scheme="http://chuquan.me/tags/GOT/"/>
    
    <category term="PLT" scheme="http://chuquan.me/tags/PLT/"/>
    
    <category term="延迟绑定" scheme="http://chuquan.me/tags/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>基于原型的继承模式</title>
    <link href="http://chuquan.me/2023/04/22/prototype-based-inheritance/"/>
    <id>http://chuquan.me/2023/04/22/prototype-based-inheritance/</id>
    <published>2023-04-22T14:16:49.000Z</published>
    <updated>2023-06-26T14:51:46.284Z</updated>
    
    <content type="html"><![CDATA[<p><strong>继承</strong>（Inheritance）是 <strong>面向对象编程</strong>（Object Oriented Programming, OOP）的三大特性之一，其他两大特性是 <strong>封装</strong>（Encapsulation）和 <strong>多态</strong>（Polymorphism）。在编程语言中，继承的主流实现方式有两种，分别是：</p><ul><li><strong>基于类的继承</strong>（Class-based Inheritance）：绝大多数面向对象编程语言都使用了基于类的继承，比如：C++、Java、Swift、Kotlin 等。</li><li><strong>基于原型的继承</strong>（Prototype-based Inheritance）：少数面向对象编程语言使用基于原型的继承，一般都是解释型编程语言，即脚本语言，比如：JavaScript、Lua、Io、Self、NewtonScript 等。</li></ul><p>除此之外，有一些辅助继承的实现方式，比如：<strong>接口继承</strong> 和 <strong>类型混入</strong>，一般用于实现多类型复用，可以达到类似多继承的效果。</p><p>本文，我们来简单介绍一下其中基于原型的继承模式。</p><h1 id="基于类的继承-vs-基于原型的继承"><a href="#基于类的继承-vs-基于原型的继承" class="headerlink" title="基于类的继承 vs 基于原型的继承"></a>基于类的继承 vs 基于原型的继承</h1><p>在基于类继承的语言中，对象是类的实例，类可以从另一个类继承。从本质上而言，类相当于模板，对象则通过这些模板来进行创建。</p><p>下图所示，为基于类的继承实现示意图。每个类都有一个类似 <code>superclass</code> 的指针指向其父类。每个对象都有一个类似 <code>isa</code> 的指针指向其所属的类。</p><p>此外，每个类都存储了一系列方法，可用于其实例进行查找和共享。关于方法存储方式，不同语言的实现有所不同。</p><ul><li>对于 C++ 等语言，每个类会保存所有祖先类的方法地址。因此，在方法查找时，无需沿着继承链进行查找</li><li>对于 Ruby、Objective-C 等语言，每个类只会保存其所定义的方法地址，而不保存祖先类的方法地址。因此，在方法查找时，会沿着继承链进行查找，这种模式也被称为 <strong>消息传递</strong>（Message Passing）。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-03.png?x-oss-process=image/resize,w_800"></p><p>在基于原型继承的语言中，没有类的概念，对象可以直接从另一对象继承。中间省略了通过模板创建对象的过程。</p><p>下图所示，为基于原型的继承实现示意图。每个对象都有一个类似 <code>prototype</code> 的指针指向其原型对象。每个对象存储了一系列方法，基于原型链，对象之间可以实现方法共享，当然也可以共享属性。方法和属性的查找过程，类似于上述的消息传递，会沿着原型链进行查找。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-04.png?x-oss-process=image/resize,w_800"></p><h1 id="原型继承的优缺点"><a href="#原型继承的优缺点" class="headerlink" title="原型继承的优缺点"></a>原型继承的优缺点</h1><p>前面，我们简单对比了两种继承模式的实现原理。下面，我们来讨论一下原型继承的优缺点。</p><p>对比而言，原型继承的优点主要有一下这些：</p><ul><li><strong>避免大量的初始化工作</strong>。通过克隆一个现有对象来创建一个新对象，并具有相同的内部状态。</li><li><strong>具有非常强大的动态性</strong>。通过修改原型链，可以将原型指针指向任意对象，使得当前对象可以继承其他对象的能力。</li><li><strong>有效降低程序的代码量</strong>。由于原型继承没有类的概念，因此在代码实现中无需进行类的定义。</li></ul><p>当然，凡事都具有两面性，以下罗列了一些原型继承的缺点：</p><ul><li><strong>性能开销相对较大</strong>。当我们访问属性或方法时，运行时会通过原型链进行查找，中间存在一个遍历的过程。</li><li><strong>原型共享的副作用</strong>。由于多个对象可以共享同一个原型对象，一旦某个对象修改原型对象的状态，将会对其他对象产生副作用。</li><li><strong>面向对象异类设计</strong>。绝大多数面向对象语言及教程都是基于类的实现而设计的，这对于习惯于基于类的 OOP 的开发者很容易产生困惑。</li></ul><h1 id="不同语言的原型继承实现"><a href="#不同语言的原型继承实现" class="headerlink" title="不同语言的原型继承实现"></a>不同语言的原型继承实现</h1><p>下面，我们来看看不同编程语言中，基于原型的继承模式的实现细节。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript 原型实现存在着很多矛盾，它使用了一些复杂的语法，使其看上去类似于基于类的语言，这些语法掩盖了其内在的原型机制。JavaScript 不直接让对象继承其他对象，而是提供了一个中间层——<strong>构造函数</strong>，完成对象的创建和原型的串联，从而间接完成对象继承。由于构造函数的定义类似于类定义，但又不是真正意义的类，因此我们可以称之为 <strong>伪类</strong>（Pseudo Class）。</p><p>默认情况下，伪类包含一个 <code>prototype</code> 指针指向原型，对象包含一个 <code>constructor</code> 指针指向伪类（构造函数），两者之间的关系如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-01.png?x-oss-process=image/resize,w_800"></p><p>为了实现新的对象继承其他对象，一般会先修改伪类中 <code>prototype</code> 的指针，然后再调用伪类进行对象构造和原型绑定。如下所示，为一段代码实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">AType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">AType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BType</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 AType。即修改伪类 BType 的 prototype 指针，使其指向父对象。</span></span><br><span class="line"><span class="title class_">BType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">AType</span>();</span><br><span class="line"><span class="title class_">BType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">BType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其中 <code>BType.prototype = new AType()</code> 修改了 <code>BType</code> 伪类的 <code>prototype</code> 指针，使其指向 <code>AType</code> 对象。当我们调用 <code>BType</code> 构造函数时，所构造的对象自动继承 <code>AType</code> 对象。如下所示，为基于原型的继承关系示意图，其中每个伪类的 <code>prototype</code> 指针都发生了变化，指向了其所继承的父对象。最终，生成的对象中会包含一个 <code>__proto__</code> 指针指向父对象。根据 <code>__proto__</code> 指针我们可以构建一个完整的原型链。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-02.png?x-oss-process=image/resize,w_800"></p><p>当然，在原型继承模式中，原型链中的父对象可能会被多个子对象所共享，因此子对象之间的状态同步问题需要格外注意。一旦，某个子对象修改了父对象的状态，那么会同时影响其他子对象。关于如何解决这个问题，JavaScript 中有很多解决方法，具体细节可以阅读相关书籍和博客，这里不作详细赘述。</p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><p>Lua 中的 <strong>表（table）</strong> 是一种非常强大且常用的数据结构，它类似于其他编程语言中的字典或哈希表，可以以键值对的方式存储数据，包括方法定义。通常会使用 table 来解决模块（module）、包（package）、对象（object）等相关实现。</p><p>与此同时，Lua 还提供了 <strong>元表（metatable）</strong> 的概念，其本质上仍然是一个表结构。但是元表可以对表进行关联和扩展，允许我们改变表的行为。</p><p>元表中最常用的键是 <code>__index</code> 元方法。当我们通过键来访问表时，如果对应的键没有定义值，那么 Lua 会查找表的元表中的 <code>__index</code> 键。如果 <code>__index</code> 指向一个表，那么 Lua 会在这个表中查找对应的键。</p><p>如下所示，我们为表 <code>a</code> 设置一个元表，其中定义元表的。 <code>__index</code> 键为表 <code>b</code>。当查找表 <code>a</code> 时，对应的键没有定义，那么会去查找元表。判断元表是否定义了 <code>__index</code> 键，这里定义为另一个表 <code>b</code>。于是，会在表 <code>b</code> 中查找对应的键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setmetatable</span>(a, &#123; <span class="built_in">__index</span> = b &#125;)</span><br></pre></td></tr></table></figure><p>Lua 中的继承模式正是基于元表和 <code>__index</code> 元方法而实现的。如下所示，分别是 Lua 中继承模式的实现示意图，以及对应的代码实现。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-06.png?x-oss-process=image/resize,w_800"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RootType = &#123; rootproperty = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RootType:new</span> <span class="params">(o)</span></span> </span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">SuperType = RootType:new(&#123; superproperty = <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">SubType = SuperType:new(&#123; subproperty = <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure><p><code>RootType</code> 是一个对象，其实现了一个 <code>new</code> 方法用于完成几项工作：</p><ul><li>构造对象，其本质上是一个表。</li><li>将 <code>RootType</code> 对象设置为新对象的元表。</li><li>将 <code>RootType</code> 对象的 <code>__index</code> 指向 <code>RootType</code> 对象自身。</li></ul><p>最终形成图中所示的对象继承关系。由于 Lua 中的继承实现没有类的概念，而只有对象的概念。因此也被归类成基于原型的继承模式。当 <code>SubType</code> 对象中没有找到对应的键时，会根据 <code>metatable</code> 指针找到对应的元表，并根据元表的 <code>__index</code> 指针找到进一步查找的表对象 <code>SuperType</code>。如果 <code>SuperType</code> 中仍然没有，那么继续根据 <code>metatable</code> 和 <code>__index</code> 指针进行查找。</p><h2 id="Io"><a href="#Io" class="headerlink" title="Io"></a>Io</h2><p>Io 的继承模式也是基于原型实现的，它的实现相对而言更加简单、直观。</p><p>在 Io 中，一切都是对象（包括闭包、命名空间等），所有行为都是消息（包括赋值操作）。这种消息传递机制其实与 Objective-C、Ruby 是一样的机制。在 Io 中，对象的组成非常关键，其主要包含两个部分：</p><ul><li><strong>槽</strong>（slots）：一系列键值对，可以存储方法或属性。</li><li><strong>原型</strong>（protos）：一个内部的对象数组，记录该对象所继承的原型。</li></ul><p>Io 使用克隆的方式创建对象，对应提供了一个 <code>clone</code> 方法。当对父对象进行克隆时，新对象的 <code>protos</code> 数组中会加入对父对象的引用，从而建立继承关系。如下所示，为 Io 中继承模式的实现示意图，以及对应的代码实现。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-07.png?x-oss-process=image/resize,w_800"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RootType := Object clone</span><br><span class="line">RootType rootproperty := 0</span><br><span class="line"></span><br><span class="line">SuperType := RootType clone</span><br><span class="line">SuperType superproperty := 0</span><br><span class="line"></span><br><span class="line">SubType := SuperType clone</span><br><span class="line">SubType subproperty := 0</span><br></pre></td></tr></table></figure><p>相比于 JavaScript 和 Lua 的链表式单继承模式，Io 是支持多继承的，其采用了多叉树的模式来实现的，其中最关键的就是 <code>protos</code> 数组。很显然，<code>protos</code> 数组可以存储多个原型对象。因此，可以实现多继承。如下所示，是 Io 中多继承模式的实现示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/prototype-chain-08.png?x-oss-process=image/resize,w_800"></p><p>因此，Io 中方法和属性的查找方式也有所不同，其基于 <code>protos</code> 数组，使用深度优先搜索的方式来进行查找。在这种模式下，如果一个对象继承的对象越多，那么方法和属性的查找效率也会越低。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文，我们首先简单对比了基于类的继承模式与基于原型的继承模式，其核心区别在于是否基于类来进行构建继承关系。对于后者，没有类的概念，即使有，那也是一种语法糖，为了向基于类的语言靠拢，降低开发者的学习成本和理解成本。</p><p>其次，我们简单介绍了基于原型继承的优缺点。当我们对编程语言进行技术选型时，也可以从这方面进行考虑和权衡，判断是否适用于特定的场景。</p><p>最后，我们介绍了三种编程语言中基于原型的继承实现，分别是：JavaScript、Lua、Io。三种语言各有其实现特点，但核心思想基本是一致的，即直接在对象之间建立引用关系，从而便于进行方法和属性的查找。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《深入设计模式》</li><li>《JavaScript 高级程序设计》</li><li>《JavaScript 语言精粹》</li><li>《七周七语言：理解多种编程范式》</li><li><a href="http://siffiejoe.github.io/lua-prototype/">prototype —— Prototype Based OO Programming For Lua</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a></li><li><a href="https://en.wikipedia.org/wiki/Prototype-based_programming">Prototype-based programming</a></li><li><a href="https://developer-interview.com/p/oop-ood/how-prototype-based-oop-is-different-from-class-based-13">Difference from class-based inheritance</a></li><li><a href="https://developer-interview.com/p/oop-ood/what-are-advantages-and-disadvantages-of-prototypal-oop-12">What are advantanges and disadvantages of prototypal OOP</a></li><li><a href="https://developer-interview.com/p/oop-ood/what-is-prototype-based-oop-how-it-is-different-from-class-based-4">What is prototype-based OOP?</a></li><li><a href="https://exploringjs.com/impatient-js/ch_proto-chains-classes.html">Prototype chains and classes</a></li><li><a href="https://github.com/nusov/lua-object">lua-object</a></li><li><a href="https://juejin.cn/post/6975694337698955295">01.原型(prototype)和原型链(prototype chain)</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">对象原型</a></li><li><a href="http://kenneth-kin-lum.blogspot.com/2012/10/javascripts-pseudo-classical.html">JavaScript’s Pseudo Classical Inheritance diagram</a></li><li><a href="https://www.lua.org/pil/contents.html">Programming in Lua</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;（Inheritance）是 &lt;strong&gt;面向对象编程&lt;/strong&gt;（Object Oriented Programming, OOP）的三大特性之一，其他两大特性是 &lt;strong&gt;封装&lt;/strong&gt;（Encapsulat</summary>
      
    
    
    
    <category term="编程范式" scheme="http://chuquan.me/categories/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
    
    <category term="继承" scheme="http://chuquan.me/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="原型继承" scheme="http://chuquan.me/tags/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    
    <category term="类继承" scheme="http://chuquan.me/tags/%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
    
    <category term="原型链" scheme="http://chuquan.me/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    <category term="元表" scheme="http://chuquan.me/tags/%E5%85%83%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>结构化并发</title>
    <link href="http://chuquan.me/2023/03/11/structured-concurrency/"/>
    <id>http://chuquan.me/2023/03/11/structured-concurrency/</id>
    <published>2023-03-11T14:03:51.000Z</published>
    <updated>2023-04-02T14:59:49.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/structured-concurrency-logo.png?x-oss-process=image/resize,w_800"></p><!-- more ---><p>对于异步与并发，一直以来，业界都有着非常广泛的研究，针对特定场景提出了很多相关的技术，如：Future&#x2F;Promise、Actor、CSP、异步函数等等。本文，我们来介绍一个近些年才出现的一个概念——<strong>结构化并发（Structured Concurrency）</strong>。</p><p>2016 年，ZeroMQ 的作者 Martin Sústrik 于在其 C 语言结构化并发库 libdill 中首次提出了“结构化并发”的概念。事实上，这个概念其实是受到了更早期 Dijkstra 所提出的 <strong>结构化编程（Structured Programming）</strong> 的启发。</p><p>为了引出结构化并发，我们首先来介绍一下什么是结构化编程，这一切要从 GOTO 有害论说起。</p><h1 id="GOTO-有害论"><a href="#GOTO-有害论" class="headerlink" title="GOTO 有害论"></a>GOTO 有害论</h1><p>计算机发展的早期，程序员使用汇编语言进行编程，在之后的一段时期，诞生了比汇编略微高级的编程语言，如 FORTRAN、FLOW-MATIC 等。这些语言虽然在一定程度上提高了可读性，但是仍然存在很大的局限性。如下所示就是一段 FLOW-MATIC 代码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-01.png?x-oss-process=image/resize,w_800"></p><p>由于当时块语法还没有发明，因此 FLOW-MATIC 不支持 <code>if</code> 块、循环块、函数调用、块修饰符等现代语言必备的基础特性。整段代码就是一系列按顺序排列并打平的命令。关于控制流，程序支持两种方式，分别是：</p><ul><li><strong>顺序执行</strong></li><li><strong>跳转执行</strong>，即 GOTO 语句。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-03.png?x-oss-process=image/resize,w_800"></p><p>顺序执行的逻辑非常简单，它总是能够找到执行入口与出口。与之相反，跳转执行则充满了不确定性。如果程序中存在 GOTO 语句，那么它可以在 <strong>任何时候跳转至任何指令位置</strong>。一旦程序大量使用了 GOTO 语句，那么最终将变成 <strong>面条式代码（Spaghetti code）</strong>。</p><p>如下所示，我们对 FLOW-MATIC 代码的控制流使用箭头进行变标记，可以发现整个逻辑变成了一团糟，如同面条一般。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/goto-harmful-02.png?x-oss-process=image/resize,w_800"></p><h1 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h1><p>在发表 <a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">《Goto Statement Considered Harmful》</a> 之后，Dijkstra 又发表了 <a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF">《Notes on Structured Programming》</a> 表达了其理想的编程范式，提出了 <strong>结构化编程</strong> 的概念。</p><p>结构化编程在现在看来是理所当然的，但是在当时并不是。结构化编程的核心是 <strong>基于块语句，实现代码逻辑的抽象与封装，从而保证控制流具有单一入口和单一出口</strong>。现代编程语言中的条件语句、循环语句、函数定义与调用都是结构化编程的体现。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-01.png?x-oss-process=image/resize,w_800"></p><p>相比 GOTO 语句，基于块的控制流有一个显著的特征：控制流从程序入口进入，中途可能会经历条件、循环、函数调用等控制流转换，但是最终控制流都会从程序出口退出。这种编程范式使得代码结构变得更加结构化，思维模型变得更加简单，也为编译器在低层级提供了优化的可能。</p><p>因此，完全禁用 GOTO 语句已经成为了大部分现代编程语言的选择。虽然，少部分编程语言仍然支持 GOTO，但是它们大都支持高德纳（Donald Ervin Knuth）所提出的前进分支和后退分支不得交叉的理论。类似 <code>break</code>、<code>continue</code> 等控制流命令，依然遵循结构化的基本原则：<strong>控制流拥有单一的入口与出口</strong>。</p><p>如今，我们基于现代编程语言所编写的程序，绝大部分都是结构化的，结构化编程范式早已深入人心。</p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>在单线程编程模型中，编程语言 <strong>通过代码块避免控制流随意跳转</strong>，从而实现程序的结构化。但是，在多线程编程（并发编程）模型中，线程之间控制和归属关系仍然存在很多问题，其面临的问题与 GOTO 的问题非常相似，这也是结构化并发所要解决的问题。</p><p>下面，我们先来看一下非结构化并发的问题。</p><h2 id="非结构化并发"><a href="#非结构化并发" class="headerlink" title="非结构化并发"></a>非结构化并发</h2><p>我们首先来看一个使用 Swift 编写的非结构化并发的例子，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        foo(completion: &#123; <span class="built_in">print</span>(<span class="string">&quot;main get <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">foo</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        bar(completion: &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;foo get <span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>)</span><br><span class="line">            completion(<span class="variable">$0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">bar</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Int</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">Int</span>(arc4random())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bar get <span class="subst">\(result)</span>&quot;</span>)</span><br><span class="line">    completion(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程执行</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>上述代码中，主线程执行 <code>main</code> 方法是一个结构化的过程。而 <code>main</code> 和 <code>foo</code> 内部则以非阻塞的方式执行并发任务，并通过 <code>completion</code> 获取结果。<code>bar</code> 内部则以阻塞的方式执行计算任务，并调用 <code>completion</code> 返回结果。</p><p>进一步分析这段代码中各个方法，可以发现 <code>main</code> 和 <code>foo</code> 中的并发任务派发其实是一种函数间的无条件 “跳转” 行为。虽然，<code>main</code> 和 <code>foo</code> 都会立即将控制流返回至调用者，但是它们各自生成了新的并发任务。这些并发任务并不知道自己从哪里来，它们的初始调用不存在于其所属线程的调用栈中，其生命周期也与调用者的作用域完全无关。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-02.png?x-oss-process=image/resize,w_800"></p><p>这样的非结构化并发不仅使得代码的控制流变得非常复杂，而且还会带来了一个致命的后果：<strong>由于和调用者具有不同的调用栈，因此无法得知原始的调用者，进而无法以抛出的方式向上传递错误</strong>。</p><p>在非结构化并发的编程范式下，我们在调用任意一个方法，我们都会存在很多担忧：</p><ul><li>方法是否会产生一个后台任务？</li><li>方法虽然返回了，它所产生的后台任务是否仍然在运行？什么时候完成？其又会产生什么行为？</li><li>作为调用者，应该在哪里处理回调？如何处理回调？</li><li>是否保持这个方法用到的资源？后台任务是否会自动持有这些资源？还是要手动释放资源？</li><li>后台任务是否可以被管理？如果取消这些后台任务？</li><li>后台任务时候会产生其他后台任务？这些任务是否可以被正确管理？当任务取消时，二次派发的任务是否也会被取消？</li></ul><p>这些问题都是非结构化并发可能存在的问题，而结构化并发正是为了解决这些问题而提出的。</p><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><p>那么，到底什么是结构化并发呢？结构化并发的核心是 <strong>在并发模型下，也要保证控制流的单一入口和单一出口</strong>。程序可以产生多个控制流来实现并发，但是所有并发控制流在出口时都应该处于完成或取消状态，控制流最终在出口处完成合并。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-03.png?x-oss-process=image/resize,w_800"></p><p>在结构化并发的编程范式下，<code>foo</code> 方法将所产生的并发控制流最终都会收束至 <code>foo</code> 方法中，<code>main</code> 方法也是如此，实现了真正的自包含。此时，我们调用黑盒方法，能够确信即使方法会产生额外的并发任务，控制流最终也会回归到方法调用的位置，一切尽在掌握之中！</p><h1 id="通用实现模式"><a href="#通用实现模式" class="headerlink" title="通用实现模式"></a>通用实现模式</h1><h2 id="整体技术栈"><a href="#整体技术栈" class="headerlink" title="整体技术栈"></a>整体技术栈</h2><p>大多数情况下，结构化并发的实现技术栈如下图所示。从上层到底层可以分为五个部分，分别是：</p><ul><li>作用域（Scope）</li><li>异步函数（Async function）</li><li>协程（Coroutine）</li><li>计算续体（Continuation）</li><li>内核态线程（Kernel Thread）</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-08.png?x-oss-process=image/resize,w_800"></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>结构化编程是以 <strong>代码块（Code Block）</strong> 为基本要素进行组织的，而结构化并发则是以 <strong>作用域（Scope）</strong> 为基本要素进行组织的。在不同的编程语言或技术框架中，对于作用域的命名所有不同，如：Kotlin 称为 <code>Scope</code>，Swift 称为 <code>Task</code>，Python trio 称为 <code>nursery</code>，C libdll 称为 <code>bundle</code>。</p><p>类似于块语法用于标注结构化编程中的代码逻辑块，作用域则用于标注并发操作的执行范围。下图所示，为作用域标识并发操作作用域的示意图。另外，作用域之间的关系只有包含和并列关系，而没有部分重叠关系，这一点与块语法规则相同。这使得作用域之间的关系变得非常清晰，而易于管理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-04.png?x-oss-process=image/resize,w_800"></p><p>在基于作用域的实现模式下，很多并发问题变得简单很多，比如：</p><ul><li>对于数据交换：以作用域为中心进行数据交互和传递，避免多线程数据操作导致问题。</li><li>对于返回值&#x2F;异常传递：以作用域构成的关系链进行传递，类似于 UI 事件传递。</li><li>对于异步取消：以作用域为粒度，取消其所包含的异步任务以及子作用域，从而递归取消所有异步任务。</li></ul><h2 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h2><p>很多编程语言都支持了异步函数，为了与同步函数进行区分，基本都提供了特定的关键词来进行声明或调用，比如：<code>async</code>&#x2F;<code>await</code>，<code>suspend</code>、<code>yield</code>&#x2F;<code>resume</code> 等。通过异步函数，我们可以通过同步调用的方式来编写代码，从而避免出现低于回调，进而提高代码的可读性。</p><p>如果编程语言只提供了异步函数，而不支持作用域，事实上也能够避免内部异步任务生命周期超出外部调用方法声明周期，因为异步函数的调用是通过以阻塞式的方式执行的。</p><p>相比而言，作用域的作用则在于管理多任务并发执行，解决多任务取消，值&#x2F;异常传递等问题，这些是异步函数所无法解决的。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>对于并发任务本身，其运算调度则由线程来支持。但是在高并发的场景下，基于传统意义上的线程池可能会面临性能瓶颈，如：线程爆炸、线程切换等。</p><p>为了解决性能和效率问题，大部分支持结构化并发的编程语言都以 <strong>协程（Coroutine）</strong> 作为运算调度的最小单元。那么到底什么是协程？协程本质上就是 <strong>用户态线程</strong>，关于协程的进一步介绍可以阅读我之前写过的一篇博客—— <a href="http://chuquan.me/2021/05/05/getting-to-know-coroutine/">《初识协程》</a>。</p><p>我们知道操作系统线程模型主要有 3 种，如下图所示。其中，纯用户态线程模型是早期单核 CPU 的产物，纯内核态线程模式是多核 CPU 下相对高效的模型。现代操作系统普遍采用的是组合式线程模型，支持提供远超 CPU 核心数量的用户态线程池。用户态线程的切换不涉及线程资源（包括寄存器、栈指针、栈内存等）切换，因此性能开销相对较小。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/coroutine-user-kernel-thread.png?x-oss-process=image/resize,w_800"></p><p>在传统的同步编程模式下，我们始终维护一个线性的调用栈，而在基于作用域和协程实现的并发编程模式下，我们可以维护一个树形的调用栈，如下图所示。基于树形调用栈，我们可以有效记录父子并发任务之间的调用关系，便于问题定位与追踪。注意，协程可以根据是否基于调用栈实现，分为有栈协程和无栈协程，这里我们以有栈协程为例，介绍结构化并发的优势。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-05.png?x-oss-process=image/resize,w_800"></p><h2 id="计算续体"><a href="#计算续体" class="headerlink" title="计算续体"></a>计算续体</h2><p>在代码层面，异步函数之后的代码是怎么实现等待异步函数执行完成之后再执行的呢？试想一下如下这段伪代码，为什么 <code>print result</code> 会等待异步函数 <code>asyncOperation</code> 完成之后才会执行的呢？怎么做到的？</p><pre><code>val result = await asyncOperation()print result</code></pre><p>事实上，这样要归功于 <strong>计算续体（Continuation）</strong>。知道回调函数的人很多，但是知道计算续体的人并不多。<strong>当一个计算过程在中间被打断，其剩余部分可以使用一个对象进行表示</strong>，这个对象就是计算续体。当然，操作系统暂停一个线程时保存的那些数据快照，也可以看成是一个计算续体。基于计算续体，我们就能实现从上次中断的地方继续执行。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-06.png?x-oss-process=image/resize,w_800"></p><p>既然可以利用续体来等待异步操作执行完成，那么执行过程中运行时系统是如何选择哪些部分作为续体呢？对此，大多数编程语言会提供相关的关键词进行修饰，最常见的就是 <code>async</code> 和 <code>await</code>。一般 <code>async</code> 用于声明一个异步函数，<code>await</code> 用于挂起（执行）一个异步函数。事实上，计算续体就是异步函数的底层实现技术。</p><p>当使用 <code>await</code> 调用一个异步函数时，那么编译器会 <strong>将后续部分的代码转换成续体，当异步任务执行完毕之后，再将值传递至续体中继续执行，有点类似于方法回调</strong>。</p><p>在不同的编程语言中，计算续体的表示也有所不同。Kotlin 和 Swift 使用 <code>Continuation</code> 表示，Lua 使用 <code>Coroutine Object</code> 表示，JavaScript 使用 <code>Generator</code> 表示，Dart 使用 <code>Async Generator</code> 表示。</p><h3 id="续体与栈帧"><a href="#续体与栈帧" class="headerlink" title="续体与栈帧"></a>续体与栈帧</h3><p>事实上，计算续体与函数栈帧有着非常紧密的关系，前者是保存和恢复栈帧的一种机制。</p><p>在函数调用时，每个函数都会创建一个栈帧，其包含函数的局部变量、参数以及返回地址等信息。栈帧被存放在进程空间的栈区，当函数返回时，对应的栈帧会从栈中弹出，程序恢复到调用该函数的地方。</p><p>计算续体则是将 <strong>当前栈帧</strong> 以及 <strong>程序计算器</strong> 等信息保存至一个对象中，然后将该对象传递给一个续体函数。续体函数可以在需要时将保存的状态恢复，从而继续执行程序。</p><p>因此，从运行时层面看，计算续体就是当前函数的栈帧与现场状态；从代码层面看，计算续体就是等待异步操作完成的后续代码。</p><h3 id="CPS-变换"><a href="#CPS-变换" class="headerlink" title="CPS 变换"></a>CPS 变换</h3><p>提到计算续体，我们就不得不提一下 <strong>CPS 变换（Continuation-Passing-Style Transformation）</strong>。</p><p>CPS 变换本质上就是 **将等待执行的代码转换成一个函数，计算续体作为函数的参数，参数名通常命名成 <code>Continuation</code>**。</p><p>下面，我们以 Swift 为例进行介绍。假如，我们有一个旧版 <code>oldLoad</code> 方法，通过闭包进行异步回调。此时，我们希望设计基于异步函数的新版 <code>newLoad</code> 方法，但是内部仍然使用旧版 <code>oldLoad</code> 方法进行复用。在这种场景下，我们就可以利用 CPS 变换来实现预期目标。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 旧版方法</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">oldLoad</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ([<span class="type">String</span>]<span class="operator">?</span>, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line"># 新版方法</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">newLoad</span>() <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">await</span> withUnsafeThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        oldLoad &#123; values, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> values <span class="operator">=</span> values &#123;</span><br><span class="line">                continuation.resume(returing: values)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                continuation.resume(throwing: error)   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assertFailure(<span class="string">&quot;both parameters are nil&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示，当我们使用新版 <code>newLoad</code> 方法时，等待异步执行的代码被封装成了一个函数，函数的参数是一个 <code>Continuation</code>。我们可以根据不同的情况向 <code>Continuation</code> 传递值或错误，从而让等待异步执行的代码继续执行。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-07.png?x-oss-process=image/resize,w_800"></p><p>事实上，Kotlin 协程就是通过 CPS 转换实现的，其在编译期间对调用挂起函数的上下文进行拆分，完成 CPS 转换。这也是为什么 Kotlin 可以不用修改 VM 或 OS 就能够支持协程的原因。</p><h1 id="并发调度模型"><a href="#并发调度模型" class="headerlink" title="并发调度模型"></a>并发调度模型</h1><p>通过上一节我们知道了结构化并发所涉及的各种技术。下面，我们来通过一段 Swift 代码，介绍一下并发任务的调度模型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">save</span>(<span class="keyword">_</span> <span class="params">contents</span>: [<span class="type">Contents</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; [<span class="type">ID</span>] &#123; <span class="operator">...</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handle</span>(<span class="keyword">_</span> <span class="params">contents</span>: [<span class="type">Content</span>]) <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ids <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> save(contents)</span><br><span class="line">    <span class="keyword">for</span> (id, content) <span class="keyword">in</span> <span class="built_in">zip</span>(ids, contents) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(id)</span>: <span class="subst">\(content)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设一个线程调用了一个 <code>handle</code> 方法。在这个阶段，最近的堆栈将是 <code>handle</code>。当 <code>handle</code> 遇到内部的 <code>await</code> 关键词修饰的异步操作时，运行时会将 <code>handle</code> 方法的计算续体存储至堆中，从而等待异步操作完成。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-09.png?x-oss-process=image/resize,w_800"></p><p>当运行时发现存在空闲的线程时，则将异步操作 <code>save</code> 加入对应线程的栈中并开始执行。但是 <code>save</code> 方法内部又存在异步 I&#x2F;O 操作，因此 <code>save</code> 方法的计算续体又会被存储至堆中，从而等待 I&#x2F;O 操作完成。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-10.png?x-oss-process=image/resize,w_800"></p><p>在等待 I&#x2F;O 操作的过程中，线程会被让出，从而允许其他任务进行复用。下图中，运行时会将 <code>otherWork1</code> 方法加入线程并执行。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-11.png?x-oss-process=image/resize,w_800"></p><p>当 <code>save</code> 所等待的 I&#x2F;O 操作完成之后，运行时会寻找空闲的线程，并将 <code>save</code> 的计算续体加入栈中并执行。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-12.png?x-oss-process=image/resize,w_800"></p><p>当 <code>save</code> 执行完毕，运行时会将与 <code>save</code> 计算续体关联等待的 <code>handle</code> 续体取出，选择一个空闲的线程来执行。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-13.png?x-oss-process=image/resize,w_800"></p><p>在 <code>handle</code> 计算续体执行过程中，会调用同步方法如 <code>zip</code>，那么栈上将会正常加入 <code>zip</code> 的栈帧。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-14.png?x-oss-process=image/resize,w_800"></p><p><code>zip</code> 执行完毕之后，对应的栈帧出栈，继续执行 <code>hanle</code> 计算续体。由于这里是一个 <code>for</code> 循环，<code>zip</code> 栈帧的入栈和出栈会循环往复多次。最终，<code>handle</code> 计算续体也执行完毕。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/concurrency-15.png?x-oss-process=image/resize,w_800"></p><!--# 应用--><!--最后，我们来举一个例子看看不同编程语言是如何使用结构化并发来解决并发问题的。假如，我们需要一张图片来显示头像，图片有两个备选分别是 imageA 和imageB，其中 imageA 被分割成了两部分：imageA-1 和imageA-2。当 imageA-1 和 imageA-2 同时下载完成后才能使用。此时，我们需要构造三个下载任务，只要有一个完整的图片下载成功，就取消其他下载任务。--><!--下面，我们来分别看一下 Kotlin 和 Swift 可以如何使用结构化合并解决这个问题的。--><!--## Kotlin 结构化并发--><!--```kotlin--><!--import kotlinx.coroutines.*--><!--fun downloadImage(imageName: String): String {--><!--    // 模拟下载过程，打印下载状态以及返回图片名称--><!--    println("开始下载 $imageName")--><!--    Thread.sleep(1000)--><!--    println("完成下载 $imageName")--><!--    return imageName--><!--}--><!--suspend fun downloadImageA(): String {--><!--    val imageA1 = async { downloadImage("imageA-1") }--><!--    val imageA2 = async { downloadImage("imageA-2") }--><!--    return "${imageA1.await()},${imageA2.await()}"--><!--}--><!--suspend fun downloadImageB(): String {--><!--    return async { downloadImage("imageB") }.await()--><!--}--><!--fun main() = runBlocking<Unit> {--><!--    // 创建一个父级 CoroutineScope--><!--    coroutineScope {--><!--        // 在父级 CoroutineScope 内创建一个新的 CoroutineScope，并将 downloadImageA 协程放在其中，启动 imageA 任务。--><!--        val scopeForImageA = CoroutineScope(coroutineContext)--><!--        val imageAJob = scopeForImageA.launch { downloadImageA() }--><!--        // 在父级 CoroutineScope 内启动 imageB 任务--><!--        val imageBJob = launch { downloadImage("imageB") }--><!--        // 等待 imageA 和 imageB 中有一个完成--><!--        val downloadedImage = select<String> {--><!--            imageAJob.onJoin {--><!--                imageBJob.cancel()--><!--            }--><!--            imageBJob.onJoin {--><!--                scopeForImageA.cancel()--><!--            }--><!--        }--><!--        // 输出完成的图片--><!--        println("成功下载：$downloadedImage")--><!--    }--><!--}--><!--```--><!--## Swift 结构化并发--><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文通过 GOTO 有害论引出编程历史中结构化编程的演化。以结构化编程作为类比，介绍了结构化并发的核心观点，以及结构化并发的设计理念。结构化并发主要包括作用域、异步函数、计算续体、协程等技术，此外还需要运行时系统的调度，才能最终实现理想的结构化并发。</p><p>关于高级编程语言中结构化并发的实践，后续我们将继续在其他文章中进行讨论。目前原生支持结构化并发的编程语言并不多，幸运的是移动端开发的编程语言 Kotlin、Swift 是支持的，后面我们会研究一下这两者对于结构化并发的实现。另外，有时间的话，我们也会介绍一些结构化并发的辅助框架，比如：trio、libdll 等，进而加深对于结构化并发的理解。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://en.wikipedia.org/wiki/Continuation">Continuation</a></li><li><a href="https://en.wikipedia.org/wiki/Structured_concurrency">Structured concurrency</a></li><li><a href="https://en.wikipedia.org/wiki/Structured_programming">Structured programming</a></li><li><a href="https://pic.plover.com/knuth-GOTO.pdf">Structured Programming with go to Statements</a></li><li><a href="http://jacques.rouillard.org/A_l_epoch/goto.pdf">Go To Statement Considered Harmful</a></li><li><a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD249.PDF">Notes on structured programming</a></li><li><a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a></li><li><a href="https://250bpm.com/blog:71/index.html">Structured Concurrency</a></li><li><a href="https://250bpm.com/blog:124/index.html">Structured Concurrency in High-level Languages</a></li><li><a href="https://archive.fosdem.org/2019/schedule/event/structured_concurrency/">Structured Concurrency Finding our way out of callback hell</a></li><li><a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">Some thoughts on asynchronous API design in a post-async&#x2F;await world</a></li><li><a href="https://trio.discourse.group/t/structured-concurrency-resources/21">Structured concurrency resources</a></li><li><a href="https://trio.discourse.group/t/structured-concurrency-kickoff/55">Structured Concurrency Kickoff</a></li><li><a href="https://elizarov.medium.com/structured-concurrency-722d765aa952">Structured concurrency</a></li><li><a href="https://www.youtube.com/watch?v=_hfBv0a09Jc">KotlinConf 2017 - Introduction to Coroutines by Roman Elizarov</a></li><li><a href="https://gist.github.com/belm0/4c6d11f47ccd31a231cde04616d6bb22">Structured concurrency and Lua(part1)</a></li><li><a href="https://gist.github.com/belm0/abbe9acb832eafa10dcbfd2b26eb74fc">Structured concurrency and Lua(part2)</a></li><li><a href="https://gist.github.com/belm0/20bc069ca676fcfc591f29930069f788">Structured concurrency and Lua(part2)</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2021/10134/">Explore structured concurrency in Swift</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2021/10254/">Swift concurrency: Behind the scenes</a></li><li>《swift 异步与并发》</li><li><a href="https://aisia.moe/2018/02/08/kotlin-coroutine-kepa/">Kotlin协程 - 先入个门吧</a></li><li><a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html">Kotlin协程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/structured-concurrency-logo.png?x-oss-process=image/res</summary>
      
    
    
    
    <category term="异步与并发" scheme="http://chuquan.me/categories/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="协程" scheme="http://chuquan.me/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="作用域" scheme="http://chuquan.me/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    <category term="计算续体" scheme="http://chuquan.me/tags/%E8%AE%A1%E7%AE%97%E7%BB%AD%E4%BD%93/"/>
    
    <category term="异步函数" scheme="http://chuquan.me/tags/%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    
    <category term="async/await" scheme="http://chuquan.me/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Actor 模型</title>
    <link href="http://chuquan.me/2023/01/15/actor/"/>
    <id>http://chuquan.me/2023/01/15/actor/</id>
    <published>2023-01-15T10:00:18.000Z</published>
    <updated>2023-01-15T10:03:05.571Z</updated>
    
    <content type="html"><![CDATA[<p>自分布式计算出现以来，业界已经开始广泛研究基于消息传递编程模型的解决方案。关于消息传递，Wikipedia 描述其广泛定义主要包括：<strong>远程过程调用（Remote Procedure Calls, RPC）</strong> 和 <strong>消息传递接口（Message Passing Interface, MPI）</strong>。但是，如今我们所谈到的消息传递，通常是指 <strong>actor 模型（Actor Model）</strong>。作为一种通用的消息传递编程模型，其起源于 20 世纪 70 年代，如今被广泛用于构建大规模可伸缩分布式系统。</p><p>作为入门，本文我们来简单聊一聊 actor 模型。</p><h1 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h1><p>一个 actor 定义为一个计算单元。所谓麻雀虽小，五脏俱全，每个 Actor 包含了存储、通信、计算等能力。在分布式系统中，通常包含了非常多的服务器集群，每一台服务器又包含了大量 actor 实例，它们共同构成了强大的并行计算能力。</p><p>Actor 的核心思想是 <strong>独立维护隔离状态，并基于消息传递实现异步通信</strong>。围绕其进行实现，actor 通常包含以下特征：</p><ul><li>每个 actor 持有一个邮箱（mailbox），本质上是一个队列，用于存储消息。</li><li>每个 actor 可以发送消息至任何 actor。</li><li>每个 actor 可以通过处理消息来更新内部状态，对于外部而言，actor 的状态是隔离的状态（isolated state）。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/actor-01.png?x-oss-process=image/resize,w_800"></p><p>为了便于通信，actor 模型使用 <strong>异步</strong> 消息传递。消息传递不使用任何中间实体，如：通道（channel）。由于 actor 模型的消息是异步传递的，中间可能会经过很长时间，甚至丢失，因此无法保证消息到达目标 actor 时的顺序。每个 actor 都完全独立于任何其他实例，actor 之间的交互完全基于异步消息，因此能够在很大程度上避免共享内存的存在问题。</p><h1 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h1><p>Actor 模型根据任务调度的方式可以分为两种，分别是：</p><ul><li><strong>基于线程（thread-based）的 actor 模型</strong></li><li><strong>事件驱动（event-driven）的 actor 模型</strong></li></ul><h2 id="基于线程的-actor-模型"><a href="#基于线程的-actor-模型" class="headerlink" title="基于线程的 actor 模型"></a>基于线程的 actor 模型</h2><p>基于线程的 actor 模型，其本质是为每一个 actor 分配一个独立的“线程”。这里的“线程”并不是严格意义的操作系统线程，而是广泛意义的执行过程，它可以是线程、协程或虚拟机线程。</p><p>在基于线程的 actor 模型中，每个 actor 独占一个线程，如果当前 actor 的邮箱为空，actor 会阻塞当前线程，等待接收新的消息。在实现中，一般使用 <code>receive</code> 原语。</p><p>这种 actor 模型实现起来比较简单，但是缺点也非常明显，由于线程数量受到系统的限制，因此 actor 的数量也会受到限制。现阶段，只有少部分 actor 模型采用基于线程的实现方式，如：Erlang、Scala Actor、Cloud Haskell。</p><h3 id="Erlang-Actor"><a href="#Erlang-Actor" class="headerlink" title="Erlang Actor"></a>Erlang Actor</h3><p>Erlang 是第一种实现基于线程的 actor 模型的编程语言。Erlang 提供三种基本操作以实现 actor 模型，分别是：</p><ul><li><code>spawn</code>：创建一个进程（process）。在 Erlang 中，进程属于虚拟机，而非操作系统。</li><li><code>send</code>：发送消息至一个线程。</li><li><code>receive</code>：接收消息。</li></ul><p>如下所示，为一个基于 Erlang actor 的使用示例。</p><figure class="highlight erl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% area_server.erl</span></span><br><span class="line"><span class="keyword">-module</span><span class="params">(area_server)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">0</span>, area/<span class="number">2</span>, loop/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span> spawn(area_server, loop, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">area</span><span class="params">(Pid, What)</span> -&gt;</span></span><br><span class="line">    rpc(Pid, What).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span> </span><br><span class="line">    Pid ! &#123;self(), Request&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;Pid, Response&#125; -&gt;</span><br><span class="line">            Response</span><br><span class="line">    <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span> </span><br><span class="line">        &#123;From, &#123;rectangle, Width, Ht&#125;&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), Width * Ht&#125;,</span><br><span class="line">            loop();</span><br><span class="line">        &#123;From, &#123;circle, R&#125;&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), <span class="number">3.14159</span> * R * R&#125;,</span><br><span class="line">            loop();</span><br><span class="line">        &#123;From, Other&#125; -&gt;</span><br><span class="line">            From ! &#123;self(), &#123;error, Other&#125;&#125;,</span><br><span class="line">            loop()</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>我们可以 Shell 环境下通过 <code>erl</code> 解释执行。当进入 Erlang REPL 环境后，我们可以执行如下代码进行测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1&gt; c(area_server).</span><br><span class="line">&#123;ok,area_server&#125;</span><br><span class="line"></span><br><span class="line">2&gt; Pid = area_server:start().</span><br><span class="line">&lt;0.94.0&gt;</span><br><span class="line"></span><br><span class="line">3&gt; area_server:area(Pid, &#123;rectangle, 10 * 8&#125;).</span><br><span class="line">&#123;error,&#123;rectangle,80&#125;&#125;</span><br><span class="line"></span><br><span class="line">4&gt; area_server:area(Pid, &#123;circle, 5&#125;).</span><br><span class="line">78.53975</span><br></pre></td></tr></table></figure><h3 id="Scala-Actor"><a href="#Scala-Actor" class="headerlink" title="Scala Actor"></a>Scala Actor</h3><p>Scala Actor 同样也实现了基于线程的 actor 模型，它将 Erlang 风格的轻量级消息传递并发性待到了 JVM，并将其集成到了重量级的线程&#x2F;进程并发模型中。如下所示，为 Scala Actor 的使用示例，其实现语法也与 Erlang 非常相似。不过，从 Scala 2.11 开始，scala actors 不再作为标准库，示例中的代码我们需要进行一番改造才能运行。但是，从实现上来看，Scala Actor 和 Erlang Actor 非常相似，均采用 <code>receive</code> 原语接收消息，阻塞线程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pingpong.scala</span></span><br><span class="line"><span class="keyword">import</span> scala.actors.<span class="type">Actor</span></span><br><span class="line"><span class="keyword">import</span> scala.actors.<span class="type">Actor</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Ping</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Pong</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Stop</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ping</span>(<span class="params">count: int, pong: <span class="type">Actor</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> pingsLeft = count - <span class="number">1</span></span><br><span class="line">    pong ! <span class="type">Ping</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      receive &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Pong</span> =&gt;</span><br><span class="line">          <span class="keyword">if</span> (pingsLeft % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="type">Console</span>.println(<span class="string">&quot;Ping: pong&quot;</span>)</span><br><span class="line">          <span class="keyword">if</span> (pingsLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pong ! <span class="type">Ping</span></span><br><span class="line">            pingsLeft -= <span class="number">1</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Console</span>.println(<span class="string">&quot;Ping: stop&quot;</span>)</span><br><span class="line">            pong ! <span class="type">Stop</span></span><br><span class="line">            exit()</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pong</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> pongCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      receive &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Ping</span> =&gt;</span><br><span class="line">          <span class="keyword">if</span> (pongCount % <span class="number">1000</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="type">Console</span>.println(<span class="string">&quot;Pong: ping &quot;</span>+pongCount)</span><br><span class="line">          sender ! <span class="type">Pong</span></span><br><span class="line">          pongCount = pongCount + <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Stop</span> =&gt;</span><br><span class="line">          <span class="type">Console</span>.println(<span class="string">&quot;Pong: stop&quot;</span>)</span><br><span class="line">          exit()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">pingpong</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> pong = <span class="keyword">new</span> <span class="type">Pong</span></span><br><span class="line">  <span class="keyword">val</span> ping = <span class="keyword">new</span> <span class="type">Ping</span>(<span class="number">100000</span>, pong)</span><br><span class="line">  ping.start</span><br><span class="line">  pong.start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件驱动的-actor-模型"><a href="#事件驱动的-actor-模型" class="headerlink" title="事件驱动的 actor 模型"></a>事件驱动的 actor 模型</h2><p>在事件驱动的 actor 模型，actor 并不直接与线程耦合，只有在事件触发（即接收消息）时，才为 actor 的任务分配线程并执行。这种方式使用续体闭包（Continuation Closure）来封装 actor 及其状态。当事件处理完毕，即退出线程。通过这种方式，我们可以使用很少的线程来执行大量 actor 产生的任务。在实现中，一般使用 <code>react</code> 原语。</p><p>事件驱动的 actor 模型在消息触发时，会自动创建并分配线程。在这种过程中，一般的优化是将 actor 执行建立在底层的线程池之上，这些线程可以是线程、协程或虚拟机线程。从概念上讲，这种实现与 run loop、event loop 机制非常相似。</p><p>现阶段，大部分 actor 模型采用事件驱动的调度方式。</p><h3 id="Dart-Isolate"><a href="#Dart-Isolate" class="headerlink" title="Dart Isolate"></a>Dart Isolate</h3><p>Dart Isolate 本质上是一种事件驱动的 actor 模型，一个 Isolate 对应一个 Actor。一个 IsolateGroup 管理多个 Isolate，基于此可以实现结构化并发。Dart VM 底层实现了一个线程池，管理操作系统线程。当接收到一个消息时，会自动创建一个线程来执行对应的处理方法。</p><p>如下所示，是一个 Dart Isolate 的使用示例。<code>ReceivePort</code> 和 <code>SendPort</code> 本质上就是 Isolate 的地址，只不过从语义上进行区分，定义了接收者和发送者。<code>spawn</code> 方法创建一个新的 Isolate，续体闭包 <code>_readAndParseJson</code> 即新创建的 actor。执行完毕之后，通过 <code>SendPort</code> 将结果返回给主 Isolate。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> jsonData = <span class="keyword">await</span> _parseInBackground();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Number of JSON keys: <span class="subst">$&#123;jsonData.length&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&gt; _parseInBackground() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> p = ReceivePort();</span><br><span class="line">  <span class="keyword">await</span> Isolate.spawn(_readAndParseJson, p.sendPort);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> p.first <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; _readAndParseJson(SendPort p) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> fileData = <span class="keyword">await</span> File(filename).readAsString();</span><br><span class="line">  <span class="keyword">final</span> jsonData = jsonDecode(fileData);</span><br><span class="line">  Isolate.exit(p, jsonData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Groovy-Actor"><a href="#Groovy-Actor" class="headerlink" title="Groovy Actor"></a>Groovy Actor</h3><p>Groovy 的 Gpars Actor 也是一种事件驱动的 actor 模型，并发的 actor 共享一个线程池，底层使用 fork&#x2F;join 进行线程调度，其使用了 <code>react</code> 原语。</p><p>如下所示，为一个 Gpars Actor 的使用示例。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovyx.gpars.actor.Actor</span><br><span class="line"><span class="keyword">import</span> groovyx.gpars.actor.Actors</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">def</span> doubler = Actors.reactor &#123;</span><br><span class="line">    <span class="number">2</span> * it</span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line">Actor actor = Actors.actor &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.10</span>).each &#123;doubler &lt;&lt; it&#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span></span><br><span class="line">    loop &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) stop()</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            react &#123;message -&gt;</span><br><span class="line">                println <span class="string">&quot;Double of $i = $message&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start()</span><br><span class="line"></span><br><span class="line">actor.join()</span><br><span class="line">doubler.stop()</span><br><span class="line">doubler.join()</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Actor 模型是分布式&#x2F;并发编程中常用的一种解决方案，其基本的设计结构非常简单，其核心思想是 “独立维护隔离状态，并基于消息传递实现异步通信”。</p><p>根据 actor 的底层调度方式，其又可以分为：基于线程的 actor 和事件驱动的 actor。两者在底层的线程使用方式上有所区别。目前，绝大多数编程语言采用的事件驱动的 actor 模型，其在资源分配方面更加合理，执行效率也更高；缺点在于底层实现复杂度高。</p><p>后续有机会我们来探索一下 actor 的实现源码，加强一下对于 actor 实现的整体认知。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://en.wikipedia.org/wiki/Message_passing">Message passing</a></li><li><a href="https://en.wikipedia.org/wiki/Actor_model">Actor model</a></li><li><a href="http://dist-prog-book.com/chapter/3/message-passing.html#why-the-actor-model">Message Passing and the Actor Model</a></li><li><a href="https://dart.cn/guides/language/concurrency">Dart 中的并发</a></li><li>《七周七并发模型》</li><li><a href="https://berb.github.io/diploma-thesis/original/054_actors.html">Actor-based Concurrency</a></li><li><a href="https://www.state-machine.com/doc/Bereznitsky2009.pdf">The Actor Model Towards Better Concurrency</a></li><li><a href="https://www.adit.io/posts/2013-05-15-Locks,-Actors,-And-STM-In-Pictures.html">Locks, Actors, And Stm In Pictures</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">并发模型与事件循环</a></li><li><a href="https://dzone.com/articles/erlangs-actor-model">Erlang’s actor model</a></li><li><a href="https://www.cnblogs.com/jeffreyzhao/archive/2009/05/11/a-simple-actor-model-implementation.html">ActorLite: 一个轻量级Actor模型实现</a></li><li>《Erlang 程序设计》</li><li><a href="https://docs.scala-lang.org/overviews/core/actors.html">The Scala Actors API</a></li><li><a href="https://www.scala-lang.org/old/node/242">Scala Actors: A Short Tutorial</a></li><li><a href="https://doc.akka.io/docs/akka/current/actors.html">Classic Actors</a></li><li><a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">Dart asynchronous programming: Isolates and event loops</a></li><li><a href="https://mrale.ph/dartvm/">Introduction to Dart VM</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自分布式计算出现以来，业界已经开始广泛研究基于消息传递编程模型的解决方案。关于消息传递，Wikipedia 描述其广泛定义主要包括：&lt;strong&gt;远程过程调用（Remote Procedure Calls, RPC）&lt;/strong&gt; 和 &lt;strong&gt;消息传递接口（M</summary>
      
    
    
    
    <category term="异步与并发" scheme="http://chuquan.me/categories/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="actor" scheme="http://chuquan.me/tags/actor/"/>
    
    <category term="事件驱动" scheme="http://chuquan.me/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="Isolate" scheme="http://chuquan.me/tags/Isolate/"/>
    
  </entry>
  
  <entry>
    <title>2022 年度总结</title>
    <link href="http://chuquan.me/2022/12/31/2022-summary/"/>
    <id>http://chuquan.me/2022/12/31/2022-summary/</id>
    <published>2022-12-31T11:04:03.000Z</published>
    <updated>2023-01-15T05:35:10.303Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-08.png?x-oss-process=image/resize,w_600"></p><!-- more ---><p>又到了一年一次例行总结的时候，写篇文章来回顾一下这一年的经历、收获和成长吧。</p><h1 id="自由市场"><a href="#自由市场" class="headerlink" title="自由市场"></a>自由市场</h1><p>今年年初，部门内出现了不少人员变动，印象中有 @周剑、@向南、@孝发、@全义 等都提了离职。一方面，考虑到公司因政策影响无法上市，未来非常不明朗；另一方面，我工作 4 年至今未曾接触自由市场。因此，想了解一下自己在市场中属于什么水平，看看有没有好的机会。</p><p>我从 1 月 20 日第一次面试，到 3 月 17 日最后一次面试，中间经历了过年，有两个多星期没有安排面试，总共历时 2 个月。简历差不多投递了十几家公司，基本都是知名的互联网大厂和中厂，最终差不多面试了 30 场，也是心力交瘁，自我介绍和项目介绍都背麻了…不过，好在结果还是挺好的，除了有一家技术面面挂了，其他的基本上要么是流程到了 HR 面，要么是我主动结束面试流程，还有几家是给了书面 Offer 或口头 Offer。</p><p>这三个月业余时间一直在复习基础、刷算法题、复盘面试，期间和 @瑀晗、@金俊 也经常交流面试情况和工作选择。万万没想到的是 @瑀晗 和 @金俊 最终去了同一家公司的同一个小组，换了个公司做同事。当然，这期间基本上没有放在太多心思在工作和学习上，但总的来说，收获还是挺大的，大概有几点：</p><ul><li>了解了自己在大厂职级体系中所对应的水平，因此个人自信心增长了不少。</li><li>了解了岗位所需要的知识体系，看到了自己的短板，摸清了各个公司面试重点和套路。</li><li>了解了更加高阶的岗位要求是什么，找到了自己努力和进阶的方向。</li></ul><p>当然，最终我没有选择跳槽，主要原因还是 @碧峰 说的 “有更大的发挥空间和成长空间”。另外，还有几个次要原因：</p><ul><li>觉得通过面试已经找到了努力的方向，如果换个地方，可能适应环境都要花费很久，而且很多东西都要从头开始。</li><li>觉得外面的公司绝大多数都太卷，薪资性价比不是特别高。</li><li>觉得整体大环境不好，裁员比比皆是，有点不稳定，担心“毕业”。</li></ul><p>在作出决定之前，@李哲 转岗去了搜题，大哥找我聊了一次；在作出决定之后，我找大哥又聊了一次。在得到了大哥的一些承诺之后，开始逐步接管客户端团队，负责 Android&#x2F;iOS&#x2F;Cocos&#x2F;Flutter 的日常事务和工作安排，这时候差不多 4 月份了。</p><h1 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h1><p>今年的工作角色发生了转变，从 iOS Owner 转变成客户端负责人。这一年来，自己也推动了一些事情的落地。</p><p>第一件事是优化 Zeta Math 上课路径效果。经过综合考虑后，设计了一套基于 Cocos View 复用，支持代码热更新、内容增量更新的技术方案。相比于第一版基于 Native 实现的方案，新版本的视觉效果和用户体验好了很多。项目整体开发经历了一个月，最终顺利上线。</p><p>第二件事是 GitLab CICD 建设，搭建了一套基于 Danger 的 Lua&#x2F;Swift&#x2F;Kotlin 的静态代码检查能力。由于 Lua 较为小众，没有现成的插件可供使用，对此，开发了一个 ruby gem——<a href="https://rubygems.org/gems/danger-luacheck">danger-luacheck</a>。Dart 的静态代码检查能力暂时还没支持，后续有时间再整吧。</p><p>当然，CICD 能做的事远远不止这些，包括：单元测试、依赖分析、编译检查、代码扫描等等。等到后续人手充足，时间充裕，再捡起来。</p><p>第三件事是去 Flutter 化。海豚自习 App 的首页四个 Tab，包括一部分二级页都是用 Flutter 写的。在需求迭代过程中，Flutter 开发的很多痛点逐步暴露出来了，主要包括以下这些：</p><ul><li>调试不方便。特别是涉及到 Native 和 Flutter 混合调试时，大部分情况只能使用日志进行调试。</li><li>线上问题多。由于我们的 Tab 也是 Flutter 实现的，因此 Flutter 页面曝光率是 100%。对此，线上经常出现白屏、内存泄露、页面卡顿、图片锯齿等问题。由于我们对于 Flutter 的投入太少，很多东西都无法解决。</li><li>新人不友好。新入职的同学基本都没有 Flutter 开发经验，从头开始学得占用一段时间。最头疼的是，我们的需求变动最频繁的几个 Flutter 页面都非常复杂，新人上手的成本非常高。</li><li>提效不明显。在开发效率方面，Flutter 的目标是 Native 的 2 倍，然而在实践中，我觉得顶多也就 1.5 倍左右。有时候也会遇到 Native 很容易实现，而 Flutter 却很难实现的情况。另外很多情况下，还需要双端同时开发插件。</li></ul><p>一方面，考虑到后续几个 Tab 首页的需求迭代会越来越多；另一方面，希望能够让更多的同学参与到这些需求的开发中。于是，开始规划 Tab 重写。很幸运地，在国庆前找到了一个空档期，所有同学都参与了 Tab 重写，同样也花了一个月的时间，顺利上线。上线后的优化效果的确很明显，白屏没有人报了，崩溃率也下降了不少，页面流畅度也提升了不少。</p><p>第四件事是基于 page scheme 的动态弹窗管理能力建设。构想并建设 page scheme 主要基于几个事实：</p><ul><li>一个定制弹窗需求。对此，我调研了淘宝的 PopLayer 方案，设计了一套基于 WebView 的弹窗方案，称之为 WebLayer。</li><li>一个卡牌激励需求。对此，我们上线了基于 MQTT 的长连接能力，并设计了一套基于页面白名单和黑名单的消息处理能力。</li><li>统一页面曝光需求。这是一个技术需求，希望能够在当前页面上报埋点时，携带上级页面的信息，此外，还能够处理页面停留时长、网络请求时长等信息。</li><li>统跳链接信息维护。一直以来，包括小猿搜题、海豚自习馆等诸多 App，我们都是通过手动维护一个 wiki 来记录统跳信息。这里，我希望能够通过代码生成统跳信息，甚至还包括其他的页面信息、参数信息等等。</li></ul><p>最终，我构想了一套 page scheme 能力，通过项目代码生成不同版本的 page scheme 文件，后台可以根据 page scheme 配置指定的页面显示弹窗或一些其他能力。服务器将后台配置结合消息数据，通过 MQTT 或 HTTP 的方式下发至 App，App 再进行处理。</p><p>期望的项目终极形态是，支持在运营在后台配置任意弹窗，包括：WebLayer、Native 弹窗等，支持指定页面显示（或不显示）。其中，WebLayer 支持类似弹窗、新手引导、红包雨、气泡等各种运营效果。</p><p>目前，page scheme 能力的搭建还在进行中，客户端的相关能力基本已经完成，包括：弹窗管理器、page scheme 定义、配置文件生成、MQTT 分派、WebLayer 管理器等。后续，还要继续推动后台相关的基础设施的搭建。整体来讲，我个人觉得这个项目还是比较有意义的，并且具有一定的创新性，期待上线后的效果。</p><h1 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h1><h2 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h2><p>今年阅读了四个开源项目的代码，分别是：getopt、git、Aspects、PromiseKit。</p><p>关于 getopt 源码，主要是出于两个契机。一个是自己看完了《C 语言教程》；一个是出于优化 nox 的目的。最终，产出了一篇源码解读文章 <a href="http://chuquan.me/2022/04/04/getopt/">《源码解读——getopt》</a>。</p><p>关于 git 源码，我首先精读了创世版的代码，也就是 Linus Torvalds 写的那个版本。然后看了下 2.0.0 版本的代码，核心的数据结构和设计原理没有太大的变化。同时又看了《Pro Git》的部分章节，最终对 Git 的底层设计原理有了一个比较清晰的认识。对此，写了篇文章 <a href="http://chuquan.me/2022/05/21/understand-principle-of-git/">《深入理解 Git 底层实现原理》</a>，并在团队内部做了次技术分享。</p><p>关于 Aspects 源码，框架的实现非常精简，只有一份代码文件。当然，也是非常仔细的阅读了一遍，整理了一下思路，并写了篇文章 <a href="http://chuquan.me/2022/11/13/understand-principle-of-aspects/">《深入理解 Aspects 设计原理》</a>。</p><p>关于 PromiseKit 源码，是因为年底的时候对于异步编程比较感兴趣，想到辅导的代码里也用到了，于是想来学习了一下。最后也产出了两篇相关的文章：</p><ul><li><a href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise 核心实现原理》</a></li><li><a href="http://chuquan.me/2022/10/29/promisekit/">《源码解读——PromiseKit》</a></li></ul><h2 id="技术书籍"><a href="#技术书籍" class="headerlink" title="技术书籍"></a>技术书籍</h2><p>今年自己读书相关的计划完成的还可以，主要看了以下这么些：</p><ul><li>《C语言教程》</li><li>《C++ Primer Plus》</li><li>《Software Engineering at Google》</li><li>《编译原理》：泛读了一下，另外看了两遍哈工大的编译原理公开课。</li><li>《How to write your own compiler》：这本书花了一个月的业余时间，精读、翻译、实验，但是发现其所使用的 LLVM 版本过低，导致我花了很多时间用于解决各种报错。最后几章节的一些报错实在解决不了了，遂放弃。</li><li>《Kaleidoscope: Implementing a Language with LLVM》：这本书差不多用了两个月的业余时间，精读、翻译、实验。</li><li>《大型网站技术架构》</li><li>《Swift 异步与并发》</li><li>《计算之魂》</li></ul><p>除了技术书籍之外，其他的就看了毛选的卷一，看了一半，确实能感受到教员的伟大。后面，有时间有心境的时候，还是要好好读读毛选。</p><h2 id="博客文章"><a href="#博客文章" class="headerlink" title="博客文章"></a>博客文章</h2><p>今年总共写了 20 来篇博客，有一半是对于《Kaleidoscope: Implementing a Language with LLVM》的章节翻译，当然也包含了一部分自己精读后的理解。除此之外，一部分是跟编译原理工具有关，一部分是跟异步编程有关，其他的还有一些琐碎的主题。整体来说，涉及的技术广度还不是很大。</p><h2 id="学习英语"><a href="#学习英语" class="headerlink" title="学习英语"></a>学习英语</h2><p>因为今年年初的面试经历，了解到外企的一些高级岗位还是有英语要求的，特别是口语。考虑到未来失业了能多一个选择🐶，于是想着从现在开始好好练练口语。苦于没有语言环境，最后抱着试试看的心态，买了个流利说的课。想着坚持一年，看看效果。从4月份到现在，总体感觉是有点帮助的，至少语感，语言组织要比以前好很多。后续再看看，要不要考虑一下真人一对一。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-02.jpeg?x-oss-process=image/resize,w_200"></p><h1 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h1><p>今年生活中最大的里程碑就是还完了房贷，好歹少还了大几十万的利息。</p><p>其次，便是休了一个长假，国庆节 + 8 天年假 + 1 个周末，总共休假 17 天。假期计划分三段行程：湖州长兴、南京、合肥。</p><p>在长兴的几天，见了假期最后一天的老弟，走了几家亲戚，和发小看了场”乡BA”、吃了顿夜宵。在家的几天，和老姐、外甥去了次太湖龙之梦。龙之梦确实非常大，比环球影城大不少，但是有些主题公园还没有完全造好。我们只体验了动物世界主题公园，整体感觉还是挺不错的，比北京动物园强多了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-05.jpeg?x-oss-process=image/resize,w_600"></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-04.jpeg?x-oss-process=image/resize,w_600"></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-06.jpeg?x-oss-process=image/resize,w_600"></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-03.jpeg?x-oss-process=image/resize,w_600"></p><p>因为疫情原因，本来去南京玩的计划取消了，直接去了合肥。在合肥待的时间比较久，于是定了计划，把《Software Engineering at Google》看完了。由于国庆期间天气太极端，不是极端热就是寒潮降温，周边玩也没玩好。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-07.jpeg?x-oss-process=image/resize,w_600"></p><p>国庆前两天，偶然看了下北京健康宝，发现弹窗3。因为可能会耽误回京，导致后面几天每天都在尝试消弹窗，也没什么心情出去玩。</p><p>一整年来，因为疫情反复，也没有出去好好玩玩。2023 年放开了之后，希望一切都能恢复正常吧。</p><h1 id="关于运动"><a href="#关于运动" class="headerlink" title="关于运动"></a>关于运动</h1><p>今年一直在保持运动，跟 @龙哥 一伙人组了局，同时部门内部又组了个局，基本上每周都能打次球，甚至打两次。</p><p>另外，今年算是把跑步坚持了下来。从 7 月份开始，每周跑一次十公里。配速从 6:00 提高到了最快  5:16。可惜，到了十一月份，因为疫情，再加上室外过于寒冷，风又太大，就暂停了。希望明年能够从开春就坚持跑步，保持每周十公里，争取能参加一次马拉松。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-01.jpeg?x-oss-process=image/resize,w_280"></p><h1 id="新年愿景"><a href="#新年愿景" class="headerlink" title="新年愿景"></a>新年愿景</h1><p>2022 年一直处于较为紧张和规律的状态，收获也挺多，看了些书，读了些源码，写了些博客，希望 2023 年能够继续保持吧。</p><p>另外，身体才是革命的本钱。少熬夜，多喝水。保护视力，坚持运动。</p><p>最后，祝新年快乐~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2022-summary-08.png?x-oss-process=image/resize,w_600&quot;&gt;&lt;/p</summary>
      
    
    
    
    <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="总结" scheme="http://chuquan.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Future 和 Promise</title>
    <link href="http://chuquan.me/2022/12/05/future-and-promise/"/>
    <id>http://chuquan.me/2022/12/05/future-and-promise/</id>
    <published>2022-12-05T10:46:53.000Z</published>
    <updated>2022-12-25T12:56:45.027Z</updated>
    
    <content type="html"><![CDATA[<p>从异步与并发编程兴起以来，学术界与工业界提出了非常多的解决方案，本文将要介绍的 Future 和 Promise 正是其中的两种解决方案。Future 和 Promise 的实现理念非常相似，两者在发展过程中相互借鉴，相互融合。目前，很多流行的语言和框架都引入了 Future 和 Promise 的概念，如：JavaScript、Node.js、Scala、Java、C++ 等。</p><p>本文，我们来简单聊一聊 Future 和 Promise 历史和设计，以及两者之间的关系与区别。</p><h1 id="历史简介"><a href="#历史简介" class="headerlink" title="历史简介"></a>历史简介</h1><h2 id="1962-Thunk"><a href="#1962-Thunk" class="headerlink" title="1962. Thunk"></a>1962. Thunk</h2><p>关于 Future 和 Promise 的起源，最早可以追溯到 1961 年的 Thunk。根据创造者 P.Z. Ingerman 的描述，<strong>Thunk 是提供地址的一段代码</strong>。</p><p>Thunk 被设计为一种将实际参数绑定到 Algol-60 过程调用中的正式定义的方法。如果用表达式代替形式参数调用过程，编译器会生成一个 thunk，它将执行表达式并将结果的地址留在某个标准位置。</p><p>目前，thunk 的用法仍然非常广泛，我在 <a href="http://chuquan.me/2021/09/25/swift-generic-protocol/">《Swift 泛型协议》</a> 一文中也提到过 thunk 的释义。</p><h2 id="1977-Future"><a href="#1977-Future" class="headerlink" title="1977. Future"></a>1977. Future</h2><p>1977 年，Henry C. Baker 和 Hewitt 在论文《The Incremental Garbage Collection of Process》中首次提到 Future。</p><p>他们提出了一个新的术语 <code>call-by-future</code>，用于描述一种基于 Future 的调用形式。当将表达式提供给执行器时，将返回该表达式的 <code>.future</code>。如果表达式返回类型为值类型，那么当未来表达式计算得到值时，会将值返回。这里会为每一个 <code>future</code> 都会创建一个进程，并立即执行表达式。如果表达式已完成，则值立即可用；如果表达式未完成，则请求进程等待表达式执行完成。</p><p>在论文中，Future 主要由三部分组成：</p><ul><li><strong>进程（Process）</strong>：用于执行表达式的进程。</li><li><strong>单元（Cell）</strong>：可写入值的内存地址，用于存储表达式的未来值。</li><li><strong>队列（Queue）</strong>：等待未来值的进程列表。</li></ul><p>从 Future 的概念我们可以看出，论文所提到的 Future 几乎已经和现代的 Future 概念非常接近了。</p><h2 id="1985-Multilisp"><a href="#1985-Multilisp" class="headerlink" title="1985. Multilisp"></a>1985. Multilisp</h2><p>1985 年，Robert H. Halstead 在论文《Multilisp: A Language for Concurrent Symbolic Computation》中提出的 Multilisp 语言支持了基于 <code>future</code> 注解的 <code>call-by-future</code> 能力。</p><p>在 Multilisp 中，如果变量绑定到 Future 的表达式，则会自动创建一个新的进程。表达式会在新的进程中执行，一旦执行完成，则将计算结果保存至变量引用中。通过这种方式，Multilisp 支持在新进程中同时计算任意表达式的能力。因此，也支持无需等待 Future 完成，继续执行其他计算的能力。这样的话，如果 Future 的值从未使用过，那么整个进程就不会被阻塞，从而消除了潜在的死锁源。</p><p>相比于 1977 年提出的 Future，Mutilisp 实现的 Future 支持在特定情况下不阻塞进程，从而一定程度上优化了程序的执行效率。</p><h2 id="1988-Promise"><a href="#1988-Promise" class="headerlink" title="1988. Promise"></a>1988. Promise</h2><p>1988 年，Liskov 和 Shrira 在论文《Distributed Programming in Argus》中提出的 Argus 语言设计了一种称为 Promises 的结构。</p><p>与 Multilisp 中的 Future 类似，Argus 中的 Promise 也提供一个用于存储未来值的占位符。Promise 的特别之处在于，当调用 Promise 时，会立即创建并返回一个 Promise，并在新进程中进行类型安全的异步 PRC 调用。当异步 PRC 调用执行完毕，由调用者设置返回值。</p><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>经过数十年的发展，Future 和 Promise 的设计理念整体上非常相似，但是在不同的语言和框架实现中又存在一定的区别，对此，这里我们基于最广泛的定义进行介绍。</p><h2 id="整体实现"><a href="#整体实现" class="headerlink" title="整体实现"></a>整体实现</h2><p>在 Scala、C++ 等编程语言中，同时包含两种结构分别对应 Future 和 Promise。作为整体实现，Future 和 Promise 可被视为同一异步编程技术中的两个部分：</p><ul><li><strong>Future</strong>：表示异步任务的 <strong>返回值</strong>，表示一个未来值的占位符，即 <strong>值的消费者</strong>。</li><li><strong>Promise</strong>：表示异步任务的 <strong>执行过程</strong>，表示一个值的生产过程，即 <strong>值的生产者</strong>。</li></ul><p>在同时包含 Future 和 Promise 的实现中，一般 Promise 对象会有一个关联的 Future 对象。当 Promise 创建时，Future 对象会自动实例化。当异步任务执行完毕，Promise 在内部设置结果，从而将值绑定至 Future 的占位符中。Future 则提供读取方法。</p><p>将异步操作分成 Future 和 Promise 两个部分的主要原因是 <strong>为了实现读写分离，对外部调用者只读，对内部实现者只写</strong>。</p><p>下面，我们以几种语言中的实现来分别进行介绍。</p><h3 id="C-Future-Promise"><a href="#C-Future-Promise" class="headerlink" title="C++ Future &amp; Promise"></a>C++ Future &amp; Promise</h3><p>在 C++ 中，Future 和 Promise 是一个异步操作的两个部分。</p><ul><li><code>std::future</code>：作为异步操作的消费者。</li><li><code>std::promise</code>：作为异步操作的生产者。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;std::string&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> producer = std::<span class="built_in">thread</span>([&amp;]</span><br><span class="line">&#123;</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> consumer = std::<span class="built_in">thread</span>([&amp;]</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; future.<span class="built_in">get</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">producer.<span class="built_in">join</span>();</span><br><span class="line">consumer.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，C++ Promise 包含了 Future，可以通过 <code>get_future</code> 方法获取 Future 对象。两者有明确的分工，Promise 提供了 <code>set_value</code> 方法支持写操作，Future 提供了 <code>get</code> 方法支持读操作。</p><h3 id="Scala-Future-Promise"><a href="#Scala-Future-Promise" class="headerlink" title="Scala Future &amp; Promise"></a>Scala Future &amp; Promise</h3><p>在 Scala 中，同样如此，Future 和 Promise 可作为同一个异步操作的两个部分。</p><ul><li><code>Future</code> 作为一个可提供只读占位符，用于存储未来值的对象。</li><li><code>Promise</code> 作为一个实现一个 Future，并支持可写操作的单一赋值容器。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.&#123; <span class="type">Future</span>, <span class="type">Promise</span> &#125;</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p = <span class="type">Promise</span>[<span class="type">T</span>]()</span><br><span class="line"><span class="keyword">val</span> f = p.future</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> producer = <span class="type">Future</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> r = produceSomething()</span><br><span class="line">  p success r</span><br><span class="line">  continueDoingSomethingUnrelated()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> consumer = <span class="type">Future</span> &#123;</span><br><span class="line">  startDoingSomething()</span><br><span class="line">  f onSuccess &#123;</span><br><span class="line">    <span class="keyword">case</span> r =&gt; doSomethingWithResult()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，Scala Promise 同样包含了 Future，可以通过 <code>future</code> 属性获取 Future 对象。Promise 提供了 <code>success</code>、<code>failure</code> 等方法来更新状态。Future 提供了 <code>onSuccess</code>、<code>onFailure</code> 等方法来监听未来值。</p><h2 id="独立实现"><a href="#独立实现" class="headerlink" title="独立实现"></a>独立实现</h2><p>其他很多编程语言中，并不同时包含 Future 和 Promise 两种结构，比如：Dart 只包含 Future，JavaScript 只包含 Promise，甚至有些编程语言混淆了 Future 和 Promise 的原始区别。</p><p>在独立实现中，Future 和 Promise 各自都有着相对比较统一的表示形式，在实现方面的差异也相对比较一致，主要包括以下几个方面区别：</p><ul><li><strong>状态表示</strong></li><li><strong>状态更新</strong></li><li><strong>返回机制</strong></li></ul><h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>在状态表示方面，Future 只有两种状态：</p><ul><li><code>uncomplete</code>：表示未完成状态，即未来值还未计算出来。</li><li><code>completed</code>：表示已完成状态，即未来值已经计算出来。当然计算结果可以分为值或错误两种情况。</li></ul><p>对于 Promise，一般使用三种状态进行表示：</p><ul><li><code>pending</code>：待定状态，即 Promise 的初始状态。</li><li><code>fulfilled</code>：满足状态，表示任务执行成功。</li><li><code>rejected</code>：拒绝状态，表示任务执行失败。</li></ul><p>无论是 Future 还是 Promise，状态转移的过程都是不可逆的。</p><h3 id="状态更新"><a href="#状态更新" class="headerlink" title="状态更新"></a>状态更新</h3><p>在状态更新方面，Future 的状态由 <strong>内部进行自动管理</strong>。当异步任务执行完成或抛出错误时，其状态将隐式地自动从 <code>uncomplete</code> 状态更新为 <code>completed</code> 状态。</p><p>对于 Promise，其状态由 <strong>外部进行手动管理</strong>。通常由开发者根据控制流逻辑，执行特定的状态更新方法显式地从 <code>pending</code> 状态更新为 <code>fulfilled</code> 或 <code>rejected</code> 状态。</p><h3 id="返回机制"><a href="#返回机制" class="headerlink" title="返回机制"></a>返回机制</h3><p>在返回机制方面，Future 以传统的 <code>return</code> 方式返回结果。如下所示为 Dart 中 Future 的返回机制示例，其返回正如普通的方法一样，通过 <code>return</code> 完成。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; _readFileAsync() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> file = File(filename);</span><br><span class="line">  <span class="keyword">final</span> contents = <span class="keyword">await</span> file.readAsString();</span><br><span class="line">  <span class="keyword">return</span> contents.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Promise 通常将结果作为闭包参数进行传递，并执行闭包从而实现返回。如下所示为 JavaScript 中 Promise 的返回机制示例，<code>resolve</code> 是一个只接受成功值的闭包，其参数为 <code>Image</code> 类型；<code>reject</code> 是一个只接受错误值的闭包，其参数为 <code>Error</code> 类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语言实现"><a href="#语言实现" class="headerlink" title="语言实现"></a>语言实现</h3><p>下面，我们来看一下各种编程语言是如何独立实现 Future 或 Promise 的。</p><h4 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h4><p>Dart 内置提供了标准 <code>Future</code> 实现，其同时提供了 <code>async</code> 和 <code>await</code> 关键字分别用于描述异步函数和等待异步函数。如下所示，为 Dart 中的 Future 应用示例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; createOrderMessage() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> order = <span class="keyword">await</span> fetchUserOrder();</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Your order is: <span class="subst">$order</span>&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; fetchUserOrder() &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),</span><br><span class="line">      () =&gt; <span class="string">&#x27;Large Latte&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h4><p>C# 提供了 <code>Task</code>，其本质上类似于一种 Future 实现。此外，C# 还提供了异步函数关键字 <code>async</code> 和 <code>await</code>，分别用于描述异步函数和等待异步函数。如下所示，为 C# 中的使用示例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">AccessTheWebAsync</span>()</span> &#123;   </span><br><span class="line">    HttpClient client = <span class="keyword">new</span> HttpClient();  </span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; getStringTask = client.GetStringAsync(<span class="string">&quot;http://msdn.microsoft.com&quot;</span>);  </span><br><span class="line">    DoIndependentWork();  </span><br><span class="line">    <span class="built_in">string</span> urlContents = <span class="keyword">await</span> getStringTask;  </span><br><span class="line">    <span class="keyword">return</span> urlContents.Length;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> urlContents = <span class="keyword">await</span> client.GetStringAsync();</span><br></pre></td></tr></table></figure><h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><p>Swift 提供了 <code>Task</code>，其本质是一种加强版的 Future 实现。Swift 通过提供额外的 <code>TaskGroup</code> 的概念，使其同时支持结构化并发和非结构化并发。此外，Swift 也提供的 <code>async</code> <code>await</code> 关键字支持异步函数，基于此，Swift 也能够实现和其他语言一样的 Future 实现。如下所示，为 Swift 中类似于 Future 的使用示例。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newPhoto <span class="operator">=</span> <span class="comment">// ... some photo data ...</span></span><br><span class="line"><span class="keyword">let</span> handle <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> add(newPhoto, toGalleryNamed: <span class="string">&quot;Spring Adventures&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> handle.value</span><br></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java 1.5 提供了 <code>Future</code> 和 <code>FutureTask</code>，其中 <code>Future</code> 是一个接口，<code>FutureTask</code> 是一种实现，它们提供了一种相对标准的 Future 实现。其通过 <code>Runnable</code> 和 <code>Callable</code> 进行实例化，有一个无参构造器，<code>Future</code> 和 <code>FutureTask</code> 支持外部只读，<code>FutureTask</code> 的 set 方法是 <code>protected</code>，未来值只能由内部进行设置。如下所示，为基于 <code>FutureTask</code> 的一个应用示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task result: &quot;</span>+ futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 提供了 <code>CompletableFuture</code>，其本质上是一种 Promise 的实现。按照我们之前的定义，Future 是只读的，Promise 是可写的，而 <code>CompletableFuture</code> 提供了可由外部调用的状态更新方法，因此可以将其归类为 Promise。另一方面，<code>CompletableFuture</code> 又实现了 Future 的读取方法 <code>get</code>。整体上，<code>CompletableFuture</code> 混合了 Future 和 Promise 的能力。如下所示，为 <code>CompletableFuture</code> 的一个应用示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; momsPurse = ()-&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//mom is busy</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">ex</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; promise =  </span><br><span class="line">CompletableFuture.supplyAsync(momsPurse, ex);</span><br><span class="line">promise.thenAccept(u-&gt;System.out.println(<span class="string">&quot;Thank you mom for $&quot;</span> + u ));</span><br><span class="line">promise.complete(<span class="number">10</span>); </span><br></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>从 ES6 开始，JavaScript 支持了 Promise 的经典实现，同时支持了 <code>async</code> 和 <code>await</code> 关键字用于描述异步任务。使用 <code>async</code> 关键字修饰函数的返回值是一个 <code>Promise</code> 对象。<code>await</code> 关键字修饰一个 <code>Promise</code> 对象，表示等待异步任务的值，有点类似等待 Future。如下所示，为 JavaScript 中 <code>Promise</code> 的使用示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">timeout</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timeout</span> = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime),</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timeout</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sleepTime = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sleepTime);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单介绍了一下 Future 和 Promise 的发展历史。然后，分别介绍了两者在实现中的关系和区别。同时，介绍了 Future 和 Promise 在各种编程语言中的实现。</p><p>后续有时间，我们在来深入研究一下编程语言层面是如何支持 Future 和 Promise 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Multilisp: A Language for Concurrent Symbolic Computation</li><li>The Incremental Garbage Collection of Process</li><li><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures and Promises</a></li><li><a href="http://dist-prog-book.com/chapter/2/futures.html">Futures and Promises</a></li><li><a href="https://blog.yorkfish.me/2020/Future%E5%92%8CPromise%E7%9A%84%E5%8C%BA%E5%88%AB/readme/">Future和Promise的区别</a></li><li><a href="https://stackoverflow.com/questions/14541975/whats-the-difference-between-a-future-and-a-promise">What’s the difference between a Future and a Promise?</a></li><li><a href="https://www.youtube.com/watch?v=CITVS-gwySo">Futures and Promises</a></li><li><a href="https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift/">Under the hood of Futures and Promises in Swift</a></li><li><a href="https://stackoverflow.com/questions/12620186/futures-vs-promises">Futures vs. Promises</a></li><li><a href="https://stackoverflow.com/questions/11004273/what-is-stdpromise/12335206">What is std::promise?</a></li><li><a href="https://cplusplus.com/reference/future/promise/">std::promise</a></li><li><a href="https://putridparrot.com/blog/threads-promises-futures-async-c/">threads, promises, futures, async, C++</a></li><li><a href="https://docs.scala-lang.org/zh-cn/overviews/core/futures.html">FUTURE和PROMISE</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html">Java并发编程：callable、Future和FutureTask</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html">Class FutureTask<V></a></li><li><a href="https://es6.ruanyifeng.com/#docs/async">ECMAScript 6 入门</a></li><li><a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/concurrent/Promise.java">Netty Promise</a></li><li><a href="https://www.cnblogs.com/rickiyang/p/12742091.html">Netty 中的异步编程 Future 和 Promise </a></li><li><a href="https://thunk.org/">So what’s a thunk?</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从异步与并发编程兴起以来，学术界与工业界提出了非常多的解决方案，本文将要介绍的 Future 和 Promise 正是其中的两种解决方案。Future 和 Promise 的实现理念非常相似，两者在发展过程中相互借鉴，相互融合。目前，很多流行的语言和框架都引入了 Futur</summary>
      
    
    
    
    <category term="异步与并发" scheme="http://chuquan.me/categories/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Future" scheme="http://chuquan.me/tags/Future/"/>
    
    <category term="Promise" scheme="http://chuquan.me/tags/Promise/"/>
    
    <category term="await" scheme="http://chuquan.me/tags/await/"/>
    
    <category term="async" scheme="http://chuquan.me/tags/async/"/>
    
    <category term="Task" scheme="http://chuquan.me/tags/Task/"/>
    
    <category term="Thunk" scheme="http://chuquan.me/tags/Thunk/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Aspects 设计原理</title>
    <link href="http://chuquan.me/2022/11/13/understand-principle-of-aspects/"/>
    <id>http://chuquan.me/2022/11/13/understand-principle-of-aspects/</id>
    <published>2022-11-13T11:35:25.000Z</published>
    <updated>2022-11-14T03:10:52.811Z</updated>
    
    <content type="html"><![CDATA[<p>最近希望在业务中实现一套基于 AOP 的埋点方案，调研过程中，我花了些时间阅读了一下 Aspects 的源码，对于 Aspects 设计有了一些更深入的理解。因此，通过本文记录我在阅读源码后的一些收获和思考，以供后续进行回顾。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Aspects 是一款轻量且简易的面向切面编程的框架，其基于 Objective-C Runtime 原理实现。Aspects 允许我们对 <strong>类的所有实例的实例方法</strong> 或 <strong>单个实例的实例方法</strong> 添加额外的代码，并且支持设置代码的执行时机，包括：<code>before</code>、<code>instead</code>、<code>after</code> 三种。</p><p><strong>注意：Aspects 无法为类方法提供面向切面编程的能力</strong>。</p><table><thead><tr><th align="left">对象类型</th><th align="left">目标方法类型</th><th align="left">Aspects 是否支持 hook</th><th align="left">hook 效果</th></tr></thead><tbody><tr><td align="left">类对象（UIViewController）</td><td align="left">类方法（“+”开头的方法）</td><td align="left">不支持</td><td align="left">-</td></tr><tr><td align="left">类对象（UIViewController）</td><td align="left">实例方法（“-”开头的方法）</td><td align="left">支持</td><td align="left">对类的所有实例对象生效</td></tr><tr><td align="left">实例对象（vc）</td><td align="left">类方法（“+”开头的方法）</td><td align="left">不支持</td><td align="left">-</td></tr><tr><td align="left">实例对象（vc）</td><td align="left">实例方法（“-”开头的方法）</td><td align="left">支持</td><td align="left">对单个实例对象生效</td></tr></tbody></table><p>这里我们提出第一个问题：为什么 Aspects 仅支持对实例方法进行 hook？</p><p>另一方面，Aspects 的作者在框架的 README 中明确表示不要在生产环境中使用 Aspects。这里我们提出第二个问题：在项目中使用 Aspects 进行 hook 是否有什么坑？</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Aspects 巧妙利用了 Objective-C 的消息传递和消息转发机制，实现了一套与 KVO 类似的技术方案。为了能够更加清晰地理解 Aspects 的设计，这里我们简单地回顾一下 Objective-C 的消息传递和消息转发机制。</p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>Objective-C 是一门动态语言，其 <strong>方法调用</strong> 在底层的实现是 <strong>消息传递（Message Passing）</strong>。本质上，消息发送是 <strong>沿着一条引用链依次查找不同的对象，判断该对象是否能够处理消息</strong>。在 Objective-C 中，一切都是对象，包括类、元类，消息就是在这些对象之间进行传递的。</p><p>因此，我们需要了解这些对象之间的关系。下图所示，为 Objective-C 对象在内存中的引用关系图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-passing-01.png?x-oss-process=image/resize,w_800"></p><p>在 Objective-C 中，涉及消息传递的方法主要有两种：实例方法、类方法。下面，我们来分别介绍。</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>对于实例方法，消息传递时，根据当前实例对象的 <code>isa</code> 指针，找到其所属的类对象，并在类对象的方法列表中查找。如果找到，则执行；否则，根据 <code>superclass</code> 指针，找到类对象的超类对象，并在超类对象的方法列表中查找，以此类推，如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-passing-02.png?x-oss-process=image/resize,w_800"></p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>虽然 Aspects 不支持 hook 类方法，但是为了方便进行对照，这里我们也介绍一下类方法的查找。</p><p>对于类方法，消息传递时，根据当前类对象的 <code>isa</code> 指针，找到其所属的元类对象，并在元类对象的方法列表中查找。如果找到，则执行；否则，根据 <code>superclass</code> 指针，找到元类对象的元超类对象，并在元超类对象的方法列表中查找，以此类推，如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-passing-03.png?x-oss-process=image/resize,w_800"></p><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>如果消息传递无法找到可以处理消息的对象，那么，Objective-C runtime 将进入消息转发（Message Forwarding）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/objc-message-forward.png?x-oss-process=image/resize,w_800"></p><p>消息转发包含三个阶段：</p><ul><li><strong>动态消息解析</strong></li><li><strong>备用接收者</strong></li><li><strong>完整消息转发</strong></li></ul><h3 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h3><p>当对象接收到未知消息时，首先会调用所属类的实例方法 <code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code> 或类方法 <code>+ (BOOL)resolveClassMethod:(SEL)sel</code>。我们可以在方法内部动态添加一个“处理方法”，通过 <code>class_addMethod</code> 函数动态添加到类中。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicMethodIMP</span><span class="params">(id self, SEL _cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == @<span class="built_in">selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        <span class="built_in">class_addMethod</span>([self <span class="keyword">class</span>], aSEL, (IMP) dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>如果上一步无法处理消息，则 runtime 会继续调用 <code>forwardingTargetForSelector:</code> 方法。</p><p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是 <code>self</code>） 的对象，则这个对象会作为消息的新接收者，消息会被分发到这个对象。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = <span class="built_in">NSStringFromSelector</span>(aSelector);</span><br><span class="line">    <span class="keyword">if</span> ([selString isEqualToString:@<span class="string">&quot;walk&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。</p><p>这步调用 <code>methodSignatureForSelector:</code> 进行方法签名，这可以将函数的参数类型和返回值进行封装。如果返回 <code>nil</code>，则说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:@<span class="string">&quot;testInstanceMethod&quot;</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> [NSMethodSignature signatureWithObjcTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果返回 <code>methodSignature</code>，则进入 <code>forwardInvocation</code>。对象会创建一个表示消息的 <code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在 <code>anInvocation</code> 中，包括 <code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@<span class="built_in">selector</span>(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>Aspects 的核心原理主要包括三个部分：</p><ul><li><strong>注册关联对象</strong>：在 hook 实例方法时，均会注册关联对象 <code>AspectsContainer</code>。</li><li><strong>创建动态类</strong>：只有在 hook 实例对象的实例方法时，才会创建动态类。</li><li><strong>核心方法交换</strong>：在 hook 实例方法时，均会对核心方法的实现进行交换。</li></ul><h2 id="注册关联对象"><a href="#注册关联对象" class="headerlink" title="注册关联对象"></a>注册关联对象</h2><p>当 hook 实例方法时，Aspects 会为 <strong>实例对象</strong> 或 <strong>类对象</strong> 注册关联对象 <code>AspectsContainer</code>。<code>AspectsContainer</code> 保存了用户 hook 的目标方法、执行闭包、闭包参数、执行时机等信息。下图所示，为 <code>AspectsContainer</code> 引用关系图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-uml.png?x-oss-process=image/resize,w_800"></p><p>关联对象注册的目标分两种情况，这种设计策略是有原因的：</p><ul><li><strong>在实例对象中注册关联对象，可以实现让每个实例对象单独管理 aspects，从而保证实例之间相互不影响。</strong></li><li><strong>在类对象中注册关联对象，可以实现让类的每个实例对象共享 aspects，从而实现影响所有实例对象。</strong></li></ul><h2 id="创建动态类"><a href="#创建动态类" class="headerlink" title="创建动态类"></a>创建动态类</h2><p>当且仅当 hook 实例对象的实例方法时，Aspects 会为实例的所属类 <code>TestClass</code> 创建一个子类 <code>TestClass_Aspects_</code>（同时创建对应的元类），并修改实例的 <code>isa</code> 指针，使其指向 <code>TestClass_Aspects_</code> 子类，同时 hook <code>TestClass_Aspects_</code> 的 <code>class</code> 方法，使其返回实例的所属类 <code>TestClass</code>，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-01.png?x-oss-process=image/resize,w_800"></p><p>整体的实现方式与 KVO 原理一致，尤其是修改动态类 <code>class</code> 方法的实现，使得在外部看来，实例的所属类并没有发生任何变化。</p><p>这里，我们可以思考一下第三个问题：为什么在 hook 实例对象的实例方法时要创建动态类？</p><h2 id="核心方法交换"><a href="#核心方法交换" class="headerlink" title="核心方法交换"></a>核心方法交换</h2><p>当 hook 实例方法时，最重要的一步是对 <strong>动态创建的类对象</strong>（下文简称：动态类对象） 或 <strong>原始继承链中的类对象</strong>（下文简称：目标类对象） 的两个核心方法与 Aspects 提供的方法进行交换。这两个方法分别是：目标 selector 和 <code>forwardInvocation:</code>。具体的交换逻辑如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-02.png?x-oss-process=image/resize,w_800"></p><p>Aspects 会将目标 selector 的实现设置为 Aspects 提供的 <code>aspect_getMsgForwardIMP</code> 方法的返回值。<code>aspects_getMsgForwardIMP</code> 的返回值本质上是一个能够直接触发消息转发机制的方法。更加特殊的地方在于，这里会直接进入消息转发的最后一步 <code>forwardInvocation:</code>。</p><p>与此同时，Aspects 会将动态类对象或目标类对象的 <code>forwardInvocation:</code> 的实现设置为 Aspects 提供的 <code>__ASPECTS_ARE_BEING_CALLED__</code> 方法实现。<code>__ASPECTS_ARE_BEING_CALLED__</code> 内部会从 <strong>实例对象</strong> 或 <strong>类对象</strong> 中取出关联对象 <code>AspectsContainer</code>，并根据其所保存的 hook 信息执行闭包和目标 selector 的原始实现。</p><p><strong>注意：对于核心方法交换，Aspects 支持幂等。即如果对同一个实例方法 hook 多次，Aspects 会保证对这两个方法只交换一次</strong>。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>下面，我们来通过源码，具体分析一下 Aspects 中的设计细节。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先，简要介绍一下 Aspects 定义的数据结构，主要包括三种数据结构：</p><ul><li><code>AspectsContainer</code></li><li><code>AspectIdentifier</code></li><li><code>AspectInfo</code></li></ul><h3 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h3><p>如下所示，为 <code>AspectsContainer</code> 的数据结构定义。<code>AspectsContainer</code> 是 Aspects 所有信息的根容器，其包含了三个数组，用于保存三种类型的 <code>AspectIdentifier</code>。</p><ul><li><code>beforeAspects</code>：用于保存执行时机为 <code>AspectPositionBefore</code> 的 <code>AspectIdentifier</code>。</li><li><code>insteadAspects</code>：用于保存执行时机为 <code>AspectPositionInstead</code> 的 <code>AspectIdentifier</code>。</li><li><code>afterAspects</code>：用于保存执行时机为 <code>AspectPositionAfter</code> 的 <code>AspectIdentifier</code>。</li></ul><p>除此之外，<code>AspectsContainer</code> 还提供了对于数组进行增删操作的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tracks all aspects for an object/class.</span></span><br><span class="line">@interface AspectsContainer : NSObject</span><br><span class="line">- (<span class="type">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (BOOL)removeAspect:(id)aspect;</span><br><span class="line">- (BOOL)hasAspects;</span><br><span class="line">@<span class="built_in">property</span> (atomic, copy) NSArray *beforeAspects;</span><br><span class="line">@<span class="built_in">property</span> (atomic, copy) NSArray *insteadAspects;</span><br><span class="line">@<span class="built_in">property</span> (atomic, copy) NSArray *afterAspects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="AspectIdentifer"><a href="#AspectIdentifer" class="headerlink" title="AspectIdentifer"></a>AspectIdentifer</h3><p>如下所示，为 <code>AspectIdentifier</code> 的数据结构定义。<code>AspectIdentifier</code> 是用于表示一个 aspect 的相关信息，其包含了目标 selector、执行闭包、闭包签名、目标对象、执行时机等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tracks a single aspect.</span></span><br><span class="line">@interface AspectIdentifier : NSObject</span><br><span class="line">+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;</span><br><span class="line">- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, assign) SEL selector;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) id block;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong) NSMethodSignature *blockSignature;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, weak) id object;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, assign) AspectOptions options;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h3><p>如下所示，为 <code>AspectInfo</code> 的数据结构定义。<code>AspectInfo</code> 的作用是保存目标 selector 的原始实现的执行环境。由于目标 selector 会被交换方法实现，因此 <code>originalInvocation</code> 的 <code>selector</code> 其实是 Aspects 交换的 selector，即 <code>aspects__SEL</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface AspectInfo : NSObject &lt;AspectInfo&gt;</span><br><span class="line">- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, unsafe_unretained, readonly) id instance;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong, readonly) NSArray *arguments;</span><br><span class="line">@<span class="built_in">property</span> (nonatomic, strong, readonly) NSInvocation *originalInvocation;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><p>如下所示，Aspects 对外提供两个接口，分别用于 hook 类方法和实例方法，即添加 aspect。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds a block of code before/instead/after the current `selector` for a specific class.</span></span><br><span class="line">+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(id)block</span><br><span class="line">                            error:(NSError **)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span></span><br><span class="line">- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(id)block</span><br><span class="line">                            error:(NSError **)error;</span><br></pre></td></tr></table></figure><p>两者的内部实现都只调用了同一个方法 <code>aspect_add</code>，其内部实现逻辑如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> id <span class="title">aspect_add</span><span class="params">(id self, SEL selector, AspectOptions options, id block, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(self);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block);</span><br><span class="line"></span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    <span class="built_in">aspect_performLocked</span>(^&#123;</span><br><span class="line">        <span class="comment">// 判断是否允许 add aspect</span></span><br><span class="line">        <span class="comment">// 如果允许，会顺带构建 tracker 链。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">aspect_isSelectorAllowedAndTrack</span>(self, selector, options, error)) &#123;</span><br><span class="line">            <span class="comment">// 加载或创建 container，每个 selector 对应一个 container。</span></span><br><span class="line">            AspectsContainer *aspectContainer = <span class="built_in">aspect_getContainerForObject</span>(self, selector);</span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Modify the class to allow message interception.</span></span><br><span class="line">                <span class="built_in">aspect_prepareClassAndHookSelector</span>(self, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>aspect_add</code> 方法内部实现中，首先通过 <code>aspect_isSelectorAllowedAndTrack</code> 方法判断是否允许添加 aspect。如果允许，则初始化 <code>AspectsContainer</code>，并将其设置成实例对象或类对象的关联对象。一个 selector 对应一个 container，一个实例对象或类对象可包含多个 container。最后通过 <code>aspect_prepareClassAndHookSelector</code> 执行核心方法交换，对于实例对象，还会创建动态类。</p><h3 id="aspect-isSelectorAllowedAndTrack"><a href="#aspect-isSelectorAllowedAndTrack" class="headerlink" title="aspect_isSelectorAllowedAndTrack"></a><code>aspect_isSelectorAllowedAndTrack</code></h3><p>Aspects 通过 <code>aspect_isSelectorAllowedAndTrack</code> 方法来判断是否允许添加 aspect，如果允许则进行追踪。具体实现逻辑如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> BOOL <span class="title">aspect_isSelectorAllowedAndTrack</span><span class="params">(NSObject *self, SEL selector, AspectOptions options, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// part 1</span></span><br><span class="line">    <span class="comment">// 静态变量，作为黑名单</span></span><br><span class="line">    <span class="type">static</span> NSSet *disallowedSelectorList;</span><br><span class="line">    <span class="type">static</span> <span class="type">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        <span class="comment">// 不允许添加 aspect 的方法黑名单</span></span><br><span class="line">        disallowedSelectorList = [NSSet setWithObjects:@<span class="string">&quot;retain&quot;</span>, @<span class="string">&quot;release&quot;</span>, @<span class="string">&quot;autorelease&quot;</span>, @<span class="string">&quot;forwardInvocation:&quot;</span>, nil];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查方法是否属于黑名单</span></span><br><span class="line">    NSString *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</span><br><span class="line">        NSString *errorDescription = [NSString stringWithFormat:@<span class="string">&quot;Selector %@ is blacklisted.&quot;</span>, selectorName];</span><br><span class="line">        <span class="built_in">AspectError</span>(AspectErrorSelectorBlacklisted, errorDescription);</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 dealloc 方法，只允许在 before 阶段进行 hook</span></span><br><span class="line">    AspectOptions position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:@<span class="string">&quot;dealloc&quot;</span>] &amp;&amp; position != AspectPositionBefore) &#123;</span><br><span class="line">        NSString *errorDesc = @<span class="string">&quot;AspectPositionBefore is the only valid position when hooking dealloc.&quot;</span>;</span><br><span class="line">        <span class="built_in">AspectError</span>(AspectErrorSelectorDeallocPosition, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能 hook 不存在的实例方法</span></span><br><span class="line">    <span class="keyword">if</span> (![self respondsToSelector:selector] &amp;&amp; ![self.<span class="keyword">class</span> instancesRespondToSelector:selector]) &#123;</span><br><span class="line">        NSString *errorDesc = [NSString stringWithFormat:@<span class="string">&quot;Unable to find selector -[%@ %@].&quot;</span>, <span class="built_in">NSStringFromClass</span>(self.<span class="keyword">class</span>), selectorName];</span><br><span class="line">        <span class="built_in">AspectError</span>(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// part 2</span></span><br><span class="line">    <span class="comment">// 如果 hook 目标是类对象，必须保证类继承链上，只允许对一个方法进行一次 hook</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">class_isMetaClass</span>(<span class="built_in">object_getClass</span>(self))) &#123;</span><br><span class="line">        Class klass = [self <span class="keyword">class</span>];</span><br><span class="line">        NSMutableDictionary *swizzledClassesDict = <span class="built_in">aspect_getSwizzledClassesDict</span>();</span><br><span class="line">        Class currentClass = [self <span class="keyword">class</span>];</span><br><span class="line">        <span class="comment">// 检查继承链中是否 hook 过目标类方法</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">            <span class="comment">// 依次遍历超类直到根类，根据类对应的 track 进行判断</span></span><br><span class="line">            <span class="comment">// 如果类方法已经 hook 过，则进一步判断</span></span><br><span class="line">            <span class="keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tracker.parentEntry) &#123;</span><br><span class="line">                    <span class="comment">// 如果父类中 hook 过，则不允许 hook</span></span><br><span class="line">                    <span class="comment">// 同时查找最顶层 tracker，打印日志</span></span><br><span class="line">                    AspectTracker *topmostEntry = tracker.parentEntry;</span><br><span class="line">                    <span class="keyword">while</span> (topmostEntry.parentEntry) &#123;</span><br><span class="line">                        topmostEntry = topmostEntry.parentEntry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    NSString *errorDescription = [NSString stringWithFormat:@<span class="string">&quot;Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&quot;</span>, selectorName, <span class="built_in">NSStringFromClass</span>(topmostEntry.trackedClass)];</span><br><span class="line">                    <span class="built_in">AspectError</span>(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</span><br><span class="line">                    <span class="keyword">return</span> NO;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (klass == currentClass) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前类的方法已经 hook 过，则允许 hook</span></span><br><span class="line">                    <span class="keyword">return</span> YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((currentClass = <span class="built_in">class_getSuperclass</span>(currentClass)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果继承链上没有类对目标方法hook过，则允许 hook，并记录 tracker</span></span><br><span class="line">        <span class="comment">// Add the selector as being modified.</span></span><br><span class="line">        currentClass = klass;</span><br><span class="line">        AspectTracker *parentTracker = nil;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">            <span class="keyword">if</span> (!tracker) &#123;</span><br><span class="line">                tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];</span><br><span class="line">                swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker;</span><br><span class="line">            &#125;</span><br><span class="line">            [tracker.selectorNames addObject:selectorName];</span><br><span class="line">            <span class="comment">// All superclasses get marked as having a subclass that is modified.</span></span><br><span class="line">            parentTracker = tracker;</span><br><span class="line">        &#125;<span class="keyword">while</span> ((currentClass = <span class="built_in">class_getSuperclass</span>(currentClass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aspect_isSelectorAllowedAndTrack</code> 的内部逻辑可以分为两部分：<strong>方法黑名单检查</strong>、<strong>对象类型检查</strong>。</p><p>对于方法黑名单检查，可细分为三个步骤：</p><ul><li>判断目标方法是不是 <code>retain</code>、<code>release</code>、<code>autorelease</code> 等，如果是，则不允许 hook。</li><li>如果目标方法是 <code>dealloc</code>，则只允许 hook <code>before</code> 时机，其他时机，则不允许 hook。</li><li>进一步确认 hook 的目标方法是否存在，如果不存在，则不允许 hook。</li></ul><p>对于对象类型检查，如果对象类型是实例对象，则允许 hook。如果对象类型是类对象，则进一步判断。根据目标类对象，遍历继承链，对于继承链中的每一个类对象，从全局字典 <code>swizzledClassesDict</code> 中读取对应的追踪器 <code>AspectTracker</code>。根据追踪器的记录，我们可以处理两种情况：</p><ul><li><strong>如果目标类没有 hook 过目标方法，但其父类 hook 过，则不允许 hook。</strong></li><li><strong>如果目标类 hook 过父类方法，但其子类没有 hook 过，则允许 hook。</strong></li></ul><p>如下图所示，为追踪器工作原理示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-03.png?x-oss-process=image/resize,w_800"></p><p>当对 <code>SubClass</code> 类对象 hook 实例方法 <code>SEL01</code> 时，Aspects 会从 <code>SubClass</code> 类对象开始，遍历其继承链，读取继承链上的每一个类对象所对应的追踪器（如果没有则创建），将目标方法 <code>SEL01</code> 保存至其内部的 <code>selectorNames</code> 数组中作为记录。</p><p>后续，如果对 <code>Class</code> 类对象 hook 实例方法 <code>SEL01</code> 时，由于其子类 <code>SubClass</code> 已经 hook 过同名方法，则不允许 <code>Class</code> 对其再次 hook。根据消息传递的原理，对 <code>Class</code> 进行 hook 是不会生效的，因为子类 <code>SubClass</code> 会在消息传递链中提前返回 <code>SEL01</code>。所以，Aspects 的设计不允许在这种情况下再次 hook 同名方法。</p><p>当然，如果对 <code>Class</code> 类对象 hook 实例方法 <code>SEL02</code> 时，由于所有其子类均没有 hook 过同名方法，因此允许 <code>Class</code> 对其再次 hook。</p><p>本质上，Aspects 利用了 <strong>正向的类对象继承链</strong> 和 <strong>反向的追踪器链</strong>，通过全局字典 <code>swizzledClassDict</code> 进行绑定，形成了一个双向链表，便于判断是否允许对类对象的实例方法进行 hook。</p><h3 id="aspect-prepareClassAndHookSelector"><a href="#aspect-prepareClassAndHookSelector" class="headerlink" title="aspect_prepareClassAndHookSelector"></a><code>aspect_prepareClassAndHookSelector</code></h3><p>如下所示，为 <code>aspect_prepareClassAndHookSelector</code> 的实现逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">aspect_prepareClassAndHookSelector</span><span class="params">(NSObject *self, SEL selector, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line">    <span class="comment">// Aspects_Class_</span></span><br><span class="line">    Class klass = <span class="built_in">aspect_hookClass</span>(self, error);</span><br><span class="line">    <span class="comment">// 读取 Aspects_Class_ 的 selector 方法</span></span><br><span class="line">    Method targetMethod = <span class="built_in">class_getInstanceMethod</span>(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = <span class="built_in">method_getImplementation</span>(targetMethod);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">aspect_isMsgForwardIMP</span>(targetMethodIMP)) &#123;</span><br><span class="line">        <span class="comment">// IMP 不能是 _objc_msgForward 或 _objc_msgForward_stret</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *typeEncoding = <span class="built_in">method_getTypeEncoding</span>(targetMethod);</span><br><span class="line">        <span class="comment">// aspects__SEL</span></span><br><span class="line">        SEL aliasSelector = <span class="built_in">aspect_aliasForSelector</span>(selector);</span><br><span class="line">        <span class="keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">            <span class="comment">// 如果不存在 aspects__SEL，即没有被交换过，则新增一个 aspects__SEL 方法，其实现指向 selector IMP</span></span><br><span class="line">            __unused BOOL addedAlias = <span class="built_in">class_addMethod</span>(klass, aliasSelector, <span class="built_in">method_getImplementation</span>(targetMethod), typeEncoding);</span><br><span class="line">            <span class="built_in">NSCAssert</span>(addedAlias, @<span class="string">&quot;Original implementation for %@ is already copied to %@ on %@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(selector), <span class="built_in">NSStringFromSelector</span>(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 selector 方法的实现指向 _objc_msgForward，从而直接触发消息转发</span></span><br><span class="line">        <span class="built_in">class_replaceMethod</span>(klass, selector, <span class="built_in">aspect_getMsgForwardIMP</span>(self, selector), typeEncoding);</span><br><span class="line">        <span class="built_in">AspectLog</span>(@<span class="string">&quot;Aspects: Installed hook for -[%@ %@].&quot;</span>, klass, <span class="built_in">NSStringFromSelector</span>(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>aspect_hookClass</code> 将判断对象类型，如果是实例对象，则创建一个动态类对象返回；如果是类对象，则返回对应的类对象。</p><p>基于 <code>aspect_hookClass</code> 返回的对象，Aspects 将修改该对象的两个方法，使其指向 Aspects 的两个方法实现，即上述我们介绍的 <strong>核心方法交换</strong>。</p><p>在 <code>aspect_prepareClassAndHookSelector</code> 的实现中，Aspects 会在进行方法交换之前进行检查，避免重复交换，从而实现幂等。</p><h3 id="aspect-hookClass"><a href="#aspect-hookClass" class="headerlink" title="aspect_hookClass"></a><code>aspect_hookClass</code></h3><p>如下所示，为 <code>aspect_hookClass</code> 的实现逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Class <span class="title">aspect_hookClass</span><span class="params">(NSObject *self, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(self);</span><br><span class="line">    Class statedClass = self.<span class="keyword">class</span>;         <span class="comment">// 其所声明的类</span></span><br><span class="line">    Class baseClass = <span class="built_in">object_getClass</span>(self);<span class="comment">// isa</span></span><br><span class="line">    NSString *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">        <span class="comment">// 如果是实例对象，且实例对象已经 hook 过方法，即其 isa 指向的是动态类对象 Aspects_Class_，则直接复用动态类对象</span></span><br><span class="line">        <span class="keyword">return</span> baseClass;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">class_isMetaClass</span>(baseClass)) &#123;</span><br><span class="line">        <span class="comment">// 如果是类对象，则将该类对象 forwardInvocation: 的实现设置为 _aspects_forwardInvocation:。</span></span><br><span class="line">        <span class="comment">// 方法交换完成后，返回该类对象。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">aspect_swizzleClassInPlace</span>((Class)self);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="comment">// 如果是被 KVO 的实例对象。</span></span><br><span class="line">        <span class="comment">// baseClass 为 KVO 所创建的动态类，则直接对 KVO 创建的动态类对象进行方法交换，交换 forwardInvocation: 与 _aspects_forwardInvocation: 的方法实现。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">aspect_swizzleClassInPlace</span>(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是实例对象，且实例对象未 hook 过方法，则创建动态子类 Aspects_Class_</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">    Class subclass = <span class="built_in">objc_getClass</span>(subclassName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subclass == nil) &#123;</span><br><span class="line">        subclass = <span class="built_in">objc_allocateClassPair</span>(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (subclass == nil) &#123;</span><br><span class="line">            NSString *errrorDesc = [NSString stringWithFormat:@<span class="string">&quot;objc_allocateClassPair failed to allocate class %s.&quot;</span>, subclassName];</span><br><span class="line">            <span class="built_in">AspectError</span>(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将动态类对象的 forwardInvocation: 与 _aspects_forwardInvocation: 进行方法交换</span></span><br><span class="line">        <span class="built_in">aspect_swizzleForwardInvocation</span>(subclass);</span><br><span class="line">        <span class="comment">// 将动态类对象的 class 设置成 statedClass</span></span><br><span class="line">        <span class="built_in">aspect_hookedGetClass</span>(subclass, statedClass);</span><br><span class="line">        <span class="comment">// 将动态类对象的元类的 class 设置成 stateClass</span></span><br><span class="line">        <span class="built_in">aspect_hookedGetClass</span>(<span class="built_in">object_getClass</span>(subclass), statedClass);</span><br><span class="line">        <span class="built_in">objc_registerClassPair</span>(subclass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 isa 指针，指向 subclass</span></span><br><span class="line">    <span class="built_in">object_setClass</span>(self, subclass);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>aspect_hookClass</code> 方法主要用于 <strong>选择对哪个对象的目标方法执行 hook</strong>，这里面包含了 4 种具体的情况，依次为：</p><ul><li>如果目标对象是实例对象，且实例对象曾经 hook 过方法，则直接返回已创建的动态类对象。</li><li>如果目标对象是类对象，则对类对象的 <code>forwardInvocation:</code> 方法的实现设置为 Aspects 提供的 <code>_aspects_forwardInvocation:</code>，并返回该类对象。</li><li>如果目标对象是被 KVO 的对象，则直接复用 KVO 所创建的动态类，并对动态类对象的 <code>forwardInvocation:</code> 方法的实现设置为 Aspects 提供的 <code>_aspects_forwardInvocation:</code>，并返回 KVO 的动态类对象。</li><li>如果目标对象是实例对象，且实例对象没有 hook 过方法，则创建一个动态类对象 <code>Aspects_Class_</code>，同时包括元类对象，并对动态类对象的 <code>forwardInvocation:</code> 方法执行方法交换，并且设置动态类与原始类之间的关系，最终返回动态类对象。</li></ul><h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>本节，我们将来介绍上文所提出的几个问题。</p><h2 id="问题一：为什么-Aspects-仅支持对实例方法进行-hook？"><a href="#问题一：为什么-Aspects-仅支持对实例方法进行-hook？" class="headerlink" title="问题一：为什么 Aspects 仅支持对实例方法进行 hook？"></a>问题一：为什么 Aspects 仅支持对实例方法进行 hook？</h2><p>在 Aspects 的实现中，在判断能够添加 aspect 的逻辑中，会通过 <code>aspect_isCompatibleBlockSignature</code> 方法来判断 block 与 selector 的方法签名是否匹配，如下所示。其中，它会通过类的 <code>instanceMethodSignatureForSelector</code> 方法获取 selector 的方法签名。对于类方法，通过这种方式必然返回 <code>nil</code>，从而导致判断条件无法满足，因此无法 hook 类方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> BOOL <span class="title">aspect_isCompatibleBlockSignature</span><span class="params">(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(blockSignature);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(object);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(selector);</span><br><span class="line"></span><br><span class="line">    BOOL signaturesMatch = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于类方法，通过 instanceMethodSignatureForSelector: 读取必然返回 nil</span></span><br><span class="line">    NSMethodSignature *methodSignature = [[object <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</span><br><span class="line">        signaturesMatch = NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题二：在项目中使用-Aspects-进行-hook-是否有什么坑？"><a href="#问题二：在项目中使用-Aspects-进行-hook-是否有什么坑？" class="headerlink" title="问题二：在项目中使用 Aspects 进行 hook 是否有什么坑？"></a>问题二：在项目中使用 Aspects 进行 hook 是否有什么坑？</h2><p>如果我们真正理解了 Aspects 的设计原理，很容易明白为什么作者不推荐在生产环境中使用 Aspects。事实上，在实际的项目开发中，我们经常会用到对已有方法进行 hook。当然，我们可以保证自己写的代码只使用 Aspects 进行 hook，但是我们无法确定引入的第三方库是否使用其他方式对方法进行 hook。那么，这时候埋下了未知的风险。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-04.png?x-oss-process=image/resize,w_800"></p><p>如上图所示，假如我们对 <code>SEL</code> 与 <code>bcq_SEL</code> 进行了 swizzle。那么，<code>bcq_SEL</code> 的实现将指向 <code>SEL</code> 的实现 <code>aspect_getMsgForwardIMP</code>；<code>SEL</code> 的实现将指向 <code>bcq_SEL</code> 的实现 <code>bcq_IMP</code>。</p><p>在有些情况下，比如：hook <code>viewWillAppear:</code> 方法。<code>bcq_IMP</code> 里会再次调用 <code>bcq_SEL</code>，从而再次调用原始实现。这时候，我们调用 <code>SEL</code>，它最终仍然会调用 <code>aspect_getMsgForwardIMP</code>，Aspects 的设置不受影响。</p><p>但是有些情况下，<code>bcq_IMP</code> 的内部逻辑可能只在特定条件下调用原始实现，其他条件下调用自定义实现。这时候，我们调用 <code>SEL</code>，在某些条件下将不会触发 <code>aspect_getMsgForwardIMP</code>，最终导致 Aspects 的设置不生效。</p><p>显而易见，在生产环境在使用 Aspects 的确可能会出现不确定的异常问题。因此，作者不建议我们在生产环境中使用 Aspects。</p><h2 id="问题三：为什么在-hook-实例对象的实例方法时要创建动态类？"><a href="#问题三：为什么在-hook-实例对象的实例方法时要创建动态类？" class="headerlink" title="问题三：为什么在 hook 实例对象的实例方法时要创建动态类？"></a>问题三：为什么在 hook 实例对象的实例方法时要创建动态类？</h2><p>对于实例对象的实例方法，我们显然不能直接 hook 继承链中的类对象，否则将影响类的所有实例的实例方法。因此，Aspects 选择了一种类似于 KVO 的设计，动态创建一个子类，并将实例对象的 <code>isa</code> 指针指向动态子类。动态子类的 <code>class</code> 方法则指向实例对象的声明类，从而是外部看来没有任何变化。</p><p>这种做法，为实例对象单独开辟了一条继承链分支，如下图所示。只有被 hook 的实例对象才会走这条分支继承链，因此不影响其他实例。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aspects-05.png?x-oss-process=image/resize,w_800"></p><p>如果对同一个类的多个实例进行 Aspects，那么会怎么样？从上图中，我们也能猜到，Aspects 会复用动态子类。只不过 hook 的闭包由各个实例对象自己管理而已。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过分析 Aspects 的源码及其设计原理，我们同时加深了对于 Objective-C Runtime 的理解。从中，我们也了解到 Aspects 的局限性，引入需谨慎。</p><p>在 Aspects 中，我们看到了很多 Objective-C 的黑魔法 API，比如：</p><ul><li><code>_objc_msgForward</code>&#x2F;<code>_objc_msgForward_stret</code>：直接触发 <code>forwardInvocation:</code></li><li><code>objc_allocateClassPair</code>：动态创建类对象和元类对象</li><li><code>objc_registerClassPair</code>：注册类对象和元类对象</li><li><code>object_setClass</code>：设置 <code>isa</code> 指针指向。</li></ul><p>除此之外，Aspects 使用了非常底层的方式实现了闭包的参数检查与匹配，这一块非常值得我们深入学习，后续有机会我们再来研究一下。</p><p>最后，向作者表达一下敬意！如果对 Objective-C 底层原理没有如此深刻的理解，一般人是写不出来这样的框架的！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/steipete/Aspects">Aspects</a></li><li><a href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C Runtime 消息传递与转发</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-03-27-objective-c-message-forwarding.html">Friday Q&amp;A 2009-03-27: Objective-C Message Forwarding</a></li><li><a href="https://wereadteam.github.io/2016/06/30/Aspects/">面向切面编程之 Aspects 源码解析及应用</a></li><li><a href="https://www.jianshu.com/p/ae5c32708bc6">object_getClass(obj)与[obj class]的区别</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a></li><li><a href="https://www.jianshu.com/p/a420751e3e93">Aspects关联&amp;调用流程浅析</a></li><li><a href="https://juejin.cn/post/6844903828265893895#heading-6">Aspects源码分析</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近希望在业务中实现一套基于 AOP 的埋点方案，调研过程中，我花了些时间阅读了一下 Aspects 的源码，对于 Aspects 设计有了一些更深入的理解。因此，通过本文记录我在阅读源码后的一些收获和思考，以供后续进行回顾。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
    <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="KVO" scheme="http://chuquan.me/tags/KVO/"/>
    
    <category term="Aspects" scheme="http://chuquan.me/tags/Aspects/"/>
    
    <category term="AOP" scheme="http://chuquan.me/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>源码解读——PromiseKit</title>
    <link href="http://chuquan.me/2022/10/29/promisekit/"/>
    <id>http://chuquan.me/2022/10/29/promisekit/</id>
    <published>2022-10-29T13:26:13.000Z</published>
    <updated>2022-11-27T14:13:35.040Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-01.png?x-oss-process=image/resize,w_800"></p><span id="more"></span><p>PromiseKit 是一款基于 Swift 的 Promise 异步编程框架，作者是大名鼎鼎的 Max Howell，Max Howell 同时也是 Homebrew 的作者，因在面试 Google 时写不出算法题反转二叉树而走红。</p><p>最近，我在研究 Promise 异步编程，一开始尝试从阅读 PromiseKit 源码上手，但是发现里面的一些设计理念难以理解。因此，转而去研究 Promise 核心原理，并产出了一篇文章——<a href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise 核心实现原理》</a>。最后，再回过头来阅读 PromiseKit 源码，很多当初不理解的设计立马豁然开朗了。这里，希望通过本文记录自己对于 PromiseKit 设计思想的一些理解。</p><p>注：本文分析的 PromiseKit 版本是 <code>6.18.1</code>。</p><h1 id="Thenable-CatchMixin"><a href="#Thenable-CatchMixin" class="headerlink" title="Thenable &amp; CatchMixin"></a>Thenable &amp; CatchMixin</h1><p><code>Thenable</code> 是 PromiseKit 的核心协议之一，其声明了一个关键方法 <code>pipe(to:)</code>，并实现了一系列链式操作符（方法），具体如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Thenable</span>: <span class="title class_">AnyObject</span> &#123;</span><br><span class="line">    <span class="comment">/// The type of the wrapped value</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// `pipe` is immediately executed when this `Thenable` is resolved</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">pipe</span>(<span class="params">to</span>: <span class="keyword">@escaping</span>(<span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The resolved result or nil if pending.</span></span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">Thenable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">then</span>&lt;<span class="type">U</span>: <span class="type">Thenable</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>.<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">map</span>&lt;<span class="type">U</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">compactMap</span>&lt;<span class="type">U</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">transform</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) -&gt; <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">done</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">get</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">tap</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">asVoid</span>() -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遵循 <code>Thenable</code> 协议的有两个泛型类型，分别是：</p><ul><li><code>Promise&lt;T&gt;</code>：支持异步任务的成功和失败状态。</li><li><code>Guarantee&lt;T&gt;</code>：仅支持异步任务的成功状态，不接受失败状态。</li></ul><p>两者的主要区别在于 <code>Promise</code> 支持失败状态，而 <code>Guarantee</code> 不支持失败状态。因此，PromiseKit 定义了另一个协议 <code>CatchMixin</code>，该协议声明并实现了错误处理相关的方法，如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">CatchMixin</span>: <span class="title class_">Thenable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">CatchMixin</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">`catch`</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">policy</span>: <span class="type">CatchPolicy</span> <span class="operator">=</span> conf.catchPolicy, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">PMKFinalizer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>&lt;<span class="type">U</span>: <span class="type">Thenable</span>&gt;(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">policy</span>: <span class="type">CatchPolicy</span> <span class="operator">=</span> conf.catchPolicy, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; <span class="keyword">where</span> <span class="type">U</span>.<span class="type">T</span> <span class="operator">==</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) -&gt; <span class="type">Guarantee</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Guarantee</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ensure</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ensureThen</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.return, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Guarantee</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Guarantee</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">recover</span>(<span class="params">on</span>: <span class="type">DispatchQueue</span>? <span class="operator">=</span> conf.<span class="type">Q</span>.map, <span class="params">flags</span>: <span class="type">DispatchWorkItemFlags</span>? <span class="operator">=</span> <span class="literal">nil</span>, <span class="params">policy</span>: <span class="type">CatchPolicy</span> <span class="operator">=</span> conf.catchPolicy, <span class="keyword">_</span> <span class="params">body</span>: <span class="keyword">@escaping</span>(<span class="type">Error</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CatchMixin</code> 协议继承自 <code>Thenable</code> 协议，从而限制 PromiseKit 只为遵循 <code>Thenable</code> 协议的类型支持 <code>catch</code> 和 <code>recover</code> 等能力。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-02.png?x-oss-process=image/resize,w_800"></p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>从 <a href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise 核心实现原理》</a> 中，我们知道 Promise 内部主要包含几个部分：</p><ul><li><strong>执行状态</strong>：用于表示 Promise 的三种状态，<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>。</li><li><strong>执行结果</strong>：对于成功状态，为任务的返回值；对于失败状态，为任务的错误码。</li><li><strong>回调任务列表</strong>：当 Promise 达到结束态时，将自动执行回调任务列表中的任务，并将当前执行结果作为参数传入回调任务。</li><li><strong>执行器</strong>：用于更新执行状态和执行结果，并执行回调任务列表中的任务。</li></ul><p>在 PromiseKit 的实现中，使用两个类型来表示 4 个部分：</p><ul><li><code>Box</code>：表示一个容器，包含了 <strong>执行状态</strong>、<strong>执行结果</strong>、<strong>回调任务列表</strong>。</li><li><code>Resolver</code>：<strong>执行器</strong>。</li></ul><p>在 <a href="http://chuquan.me/2022/10/16/promise-core-implement/">《Promise 核心实现原理》</a> 中，我们设计实现的 <code>Promise</code> 强关联了回调任务列表和执行器，执行器同时反向强引用了 Promise。然而，在 PromiseKit 中，<code>Promise</code> 仅强关联了 <code>Box</code>，而弱依赖了 <code>Resolver</code>，<code>Resolver</code> 则强关联了 <code>Box</code>。当然，两种设计在内存管理中的作用是一样的。如下所示为 <code>Promise</code> 与 <code>Box</code>、<code>Resolver</code> 的引用关系。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-03.png?x-oss-process=image/resize,w_800"></p><p>下面，我们来分别介绍一下 <code>Box</code> 和 <code>Resolver</code> 的设计。</p><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><p>PromiseKit 通过两种具体的 <code>Box</code> 子类来表示不同状态下的容器，分别是：</p><ul><li><code>EmptyBox</code>：表示 <code>pending</code> 状态下的容器。</li><li><code>SealedBox</code>：表示 <code>resolved</code> 状态下的容器，具体可以是 <code>fulfilled</code> 或 <code>rejected</code> 状态。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-04.png?x-oss-process=image/resize,w_800"></p><h3 id="执行状态-执行结果-回调任务列表"><a href="#执行状态-执行结果-回调任务列表" class="headerlink" title="执行状态 &amp; 执行结果 &amp; 回调任务列表"></a>执行状态 &amp; 执行结果 &amp; 回调任务列表</h3><p>Promise 通过 <code>Sealant</code> 枚举类型将三种执行状态（<code>pending</code>、<code>fulfilled</code>、<code>rejected</code>）分成两种执行状态：</p><ul><li><strong>开始状态</strong>：<code>pending</code> 状态。</li><li><strong>结束状态</strong>：<code>resolved</code> 状态，具体可以是 <code>fulfilled</code> 或 <code>rejected</code>。</li></ul><p><code>Sealant</code> 的定义如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Sealant</span>&lt;<span class="title class_">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> pending(<span class="type">Handlers</span>&lt;<span class="type">R</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> resolved(<span class="type">R</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Handlers</span>&lt;<span class="title class_">R</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> bodies: [(<span class="type">R</span>) -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="keyword">@escaping</span>(<span class="type">R</span>) -&gt; <span class="type">Void</span>) &#123; bodies.append(item) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>pending</code> 状态的关联值存储了 <strong>回调任务列表</strong> <code>Handlers</code>；<code>resolved</code> 状态的关联值存储了两种细分的状态 <code>Result</code>。</p><p><code>Result</code> 枚举类型则用于进一步表示 <code>fulfilled</code> 和 <code>rejected</code> 状态，具体定义如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> fulfilled(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> rejected(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过关联对象，分别存储两种 <strong>执行结果</strong>：返回值 <code>T</code> 和错误码 <code>Error</code>。</p><h3 id="EmptyBox-SealedBox"><a href="#EmptyBox-SealedBox" class="headerlink" title="EmptyBox &amp; SealedBox"></a>EmptyBox &amp; SealedBox</h3><p><code>Box</code> 抽象类定义了三个方法，分别是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inspect</span>() -&gt; <span class="type">Sealant</span>&lt;<span class="type">T</span>&gt; &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">inspect</span>(<span class="keyword">_</span>: (<span class="type">Sealant</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>) &#123; <span class="built_in">fatalError</span>() &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">seal</span>(<span class="keyword">_</span>: <span class="type">T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inspect()</code> 方法用于检查内部状态，返回值为 <code>Sealant</code> 值。对于 <code>SealedBox</code>，其返回始终为 <code>resolved&lt;T&gt;</code>。</p><p><code>inspect(_ body: (Sealant&lt;T&gt;) -&gt; Void)</code> 方法将内部结果作为参数传递给闭包并执行。</p><p><code>seal(_: T)</code> 方法非常关键，当 <code>Box</code> 为 <code>pending</code> 状态时，<code>seal</code> 方法可以将内部状态更新为 <code>resolved</code>，同时执行 <strong>回调任务列表</strong> 中的所有任务。<code>Resolver</code> 就是通过 <code>seal</code> 方法来更新状态的。具体如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmptyBox</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Box</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">seal</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers: <span class="type">Handlers</span>&lt;<span class="type">T</span>&gt;!</span><br><span class="line">        barrier.sync(flags: .barrier) &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">case</span> .pending(<span class="keyword">let</span> _handlers) <span class="operator">=</span> <span class="keyword">self</span>.sealant <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="comment">// already fulfilled!</span></span><br><span class="line">            &#125;</span><br><span class="line">            handlers <span class="operator">=</span> _handlers</span><br><span class="line">            <span class="keyword">self</span>.sealant <span class="operator">=</span> .resolved(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> handlers <span class="operator">=</span> handlers &#123;</span><br><span class="line">            handlers.bodies.forEach&#123; <span class="variable">$0</span>(value) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h2><p><code>Resolver</code> 的核心作用是更新执行状态和执行结果，并执行回调任务列表中的任务。由于 <code>Box</code> 封装了执行状态、执行结果、回调任务列表，并且提供了更新状态的方法 <code>seal</code>。因此，<code>Resolver</code> 只需提供针对不同状态的便利方法，内部调用 <code>Box</code> 的 <code>seal</code> 方法进行更新即可。具体如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Resolver</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> box: <span class="type">Box</span>&lt;<span class="type">Result</span>&lt;<span class="type">T</span>&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">box</span>: <span class="type">Box</span>&lt;<span class="type">Result</span>&lt;<span class="type">T</span>&gt;&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.box <span class="operator">=</span> box</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> .pending <span class="operator">=</span> box.inspect() &#123;</span><br><span class="line">            conf.logHandler(.pendingPromiseDeallocated)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">extension</span> <span class="title class_">Resolver</span> &#123;</span><br><span class="line">    <span class="comment">/// Fulfills the promise with the provided value</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fulfill</span>(<span class="keyword">_</span> <span class="params">value</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        box.seal(.fulfilled(value))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Rejects the promise with the provided error</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">reject</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">Error</span>) &#123;</span><br><span class="line">        box.seal(.rejected(error))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Resolves the promise with the provided result</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">resolve</span>(<span class="keyword">_</span> <span class="params">result</span>: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">        box.seal(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务串联"><a href="#任务串联" class="headerlink" title="任务串联"></a>任务串联</h2><p>Promise 的核心能力之一是串联任务（异步或同步）。从 <code>Thenable</code> 的方法中，我们可以看到几乎所有的串联方法内部都是通过 <code>pipe(to:)</code> 方法实现任务串联的。下面，我们来看一下 <code>Promise</code> 中该方法的定义。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt;: <span class="title class_">Thenable</span>, <span class="title class_">CatchMixin</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">pipe</span>(<span class="params">to</span>: <span class="keyword">@escaping</span>(<span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> box.inspect() &#123;</span><br><span class="line">        <span class="keyword">case</span> .pending:</span><br><span class="line">            box.inspect &#123;</span><br><span class="line">                <span class="keyword">switch</span> <span class="variable">$0</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> .pending(<span class="keyword">let</span> handlers):</span><br><span class="line">                    handlers.append(to)</span><br><span class="line">                <span class="keyword">case</span> .resolved(<span class="keyword">let</span> value):</span><br><span class="line">                    to(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .resolved(<span class="keyword">let</span> value):</span><br><span class="line">            to(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现中可以看到，<code>pipe(to:)</code> 方法会先判断 <code>Box</code> 的状态，如果是 <code>pending</code> 状态，则将闭包加入回调任务列表；如果是 <code>resolved</code> 状态，则立即执行闭包。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>PromiseKit 所实现的 <code>Promise</code> 的内存管理是非常清晰。我们可以通过阅读各种链式操作符的内部实现来梳理其内存引用关系。如下所示，为链式操作符下产生的线性内存引用关系。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-05.png?x-oss-process=image/resize,w_800"></p><p>当对 <code>promise 0</code> 执行链式操作符时，链式操作符会创建一个 <code>promise 1</code>，并在内部创建一个匿名闭包对用户闭包进行封装。同时，匿名闭包将引用 <code>promise 1</code> ，以处理 <code>rejected</code> 状态。</p><p>当 <code>promise 0</code> 为 <code>fulfilled</code> 时，执行匿名闭包，进而执行用户闭包，从而创建一个临时的 <code>promise m</code>。此时，<code>promise m</code> 通过 <code>pipe(to:)</code> 方法将 <code>promise 1</code> 的状态更新方法（任务）<code>box.seal</code> 加入回调任务列表，最终形成上图所示的内存引用关系。</p><h1 id="Guarantee"><a href="#Guarantee" class="headerlink" title="Guarantee"></a>Guarantee</h1><p><code>Guarantee</code> 其实是裁剪版的 <code>Promise</code>，不支持错误处理，即 <strong>保证有返回值</strong> 的含义。</p><p><code>Guarantee</code> 遵循 <code>Thenable</code> 协议，并重新实现了一套链式操作符（方法），不同的是，返回值为 <code>Guarantee</code> 类型，从而避免交错使用 <code>Promise</code> 和 <code>Guarantee</code>。</p><h1 id="全局方法"><a href="#全局方法" class="headerlink" title="全局方法"></a>全局方法</h1><p>为了便于使用，PromiseKit 还提供了几个常用的全局方法，包括：</p><ul><li><code>after</code>：延时任务，<code>Guarantee</code> 类型。</li><li><code>firstly</code>：语法糖，让代码更具可读性，立即执行闭包。</li><li><code>race</code>：当有一个 Promise 为 <code>fulfilled</code> 状态时，执行回调任务列表。 </li><li><code>when</code>：当所有 Promise 均为 <code>fulfilled</code> 状态时，执行回调任务列表。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整体而言，PromiseKit 以 <code>Thenable</code> 和 <code>CatchMixin</code> 协议为基础，实现了两种类型的 Promise，分别是 <code>Promise</code> 和 <code>Guarantee</code>。</p><p><code>Promise</code> 的工作流程主要涉及了 <code>Box</code> 和 <code>Resolver</code>，两者有各自的职责。<code>Box</code> 包含了执行结果、执行状态、回调任务列表，并提供了状态更新方法 <code>seal</code>。<code>Resolver</code> 作为执行器，提供给用户来更新状态。</p><p><code>Thenable</code> 提供的 <code>pipe(to:)</code> 方法是串联任务的关键，几乎所有的链式操作符均使用了 <code>pipe(to:)</code> 方法进行任务串联。</p><p>从编码角度而言，PromiseKit 在职责单一、方法命名方面的设计与实践，还是非常值得我们来学习的。</p><p>后续，我们将继续阅读一些不错的开源源码，学习其中的设计思想。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li><li><a href="http://chuquan.me/2022/10/16/promise-core-implement/">Promise 核心实现原理</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promisekit-01.png?x-oss-process=image/resize,w_800&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="异步与并发" scheme="http://chuquan.me/categories/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    <category term="Promise" scheme="http://chuquan.me/tags/Promise/"/>
    
    <category term="Guarantee" scheme="http://chuquan.me/tags/Guarantee/"/>
    
  </entry>
  
  <entry>
    <title>Promise 核心实现原理</title>
    <link href="http://chuquan.me/2022/10/16/promise-core-implement/"/>
    <id>http://chuquan.me/2022/10/16/promise-core-implement/</id>
    <published>2022-10-16T07:43:06.000Z</published>
    <updated>2022-11-27T14:13:25.848Z</updated>
    
    <content type="html"><![CDATA[<p>在传统的基于 <strong>闭包</strong> 的异步编程中，经常会出现 <strong>地狱嵌套</strong> 的问题，这使得高度异步的代码几乎无法阅读。Promise 则是解决这个问题的众多方案之一。</p><p>Promise 的核心思想是：<strong>实现一个容器，对内管理异步任务的执行状态，对外提供同步编程的代码结构，从而具备更好的可读性</strong>。本文，我们将通过分析 Promise 的设计思想，并实现 Promise 核心逻辑，从而深入理解 Promise 实现原理。</p><p>本文所实现的 Promise 代码已在 Github 开源——<a href="https://github.com/baochuquan/implementing-promise">传送门</a>。</p><h1 id="Future-vs-Promise"><a href="#Future-vs-Promise" class="headerlink" title="Future vs. Promise"></a>Future vs. Promise</h1><p>Future 和 Promise 是异步编程中经常提到的两个概念，两者的关系经常用一句话来概括——A Promise to Future。</p><p>我们可以认为 Future 和 Promise 是一种异步编程技术的两个部分：</p><ul><li><strong>Future 是异步任务的返回值，表示一个未来值的占位符，是值的消费者。</strong></li><li><strong>Promise 是异步任务的执行过程，表示一个值的生产过程，是值的生产者。</strong></li></ul><p>以如下一段 Dart 代码为例，<code>getUserInfo</code> 方法体是一个 Promise，其定义了值的生产过程，<code>getUserInfo</code> 方法返回值是一个 Future，其定义了一个未来值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;UserInfo&gt; getUserInfo(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> response = <span class="keyword">await</span> <span class="keyword">get</span>(<span class="string">&#x27;https://chuquan.me/userinfo&#x27;</span>);</span><br><span class="line">        <span class="keyword">final</span> userInfo = UserInfo.fromJson(response.data <span class="keyword">as</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;);</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125; <span class="keyword">on</span> DioError <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        Toast.instance.showNetworkError(context, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future 和 Promise 来源于函数式编程语言，其目的是分离一个值和生产值的方法，从而简化异步编程。本质上，两者是一一对应的。</p><p>很多语言都有 Future 和 Promise 的实现，比如：Swift Task、C# Task、C++ std::future、Scala Future 对应的是 Future 的实现；C++ std::promise、JavaScript Promise、Scala Promise 对应的是 Promise 的实现。</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>Promise 支持以同步代码结构编写异步代码逻辑，其提供一系列便利方法以支持链式调用，如：<code>then</code>、<code>done</code>、<code>catch</code>、<code>finally</code> 等。注意，不同的编程语言或库实现中，方法命名有所不同。</p><p>如下所示，是一个以 JavaScript 编写的 Promise 的基本用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>本质上，Promise 是一个对象，其包含三种状态，分别是：</p><ul><li><strong><code>pending</code>：表示进行中状态</strong>。</li><li><strong><code>fulfilled</code>：表示已成功状态状态</strong>。此时，Promise 得到一个结果值 <code>value</code>。</li><li><strong><code>rejected</code>：表示已失败状态</strong>。此时，Promise 得到一个错误值 <code>error</code>，用于表示错误原因。</li></ul><p><code>pending</code> 是起始状态，<code>fulfilled</code> 和 <code>rejected</code> 是结束状态。一旦 Promise 的状态发生了变化，它将不会再改变。因此，Promise 是一种 <strong>单赋值</strong> 的结构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promise-03.png?x-oss-process=image/resize,w_800"></p><p>Promise 内部的状态由 <strong>执行器（executor）</strong> 或 <strong>解析器（resolver）</strong> 来进行更新。Promise 创建时的状态默认为 <code>pending</code>，用户为 Promise 提供状态转移逻辑，比如：网络请求成功时将状态设置为 <code>fulfilled</code>，网络请求失败时将状态设置为 <code>rejected</code>。通常，执行器会提供两个方法 <code>resolve</code> 和 <code>reject</code> 分别用于设置 <code>fulfilled</code> 和 <code>rejected</code> 状态。</p><p>此外，Promise 还支持通过链式操作符实现回调任务的链式执行，其原理是在内部维护一个回调任务列表，当 Promise 到达结束状态时，自动执行内部的回调任务，从而整体实现异步任务的链式执行。</p><h1 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h1><p>下面，我们来手动实现 Promise 的核心逻辑，编程语言为 Swift。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>首先，定义 Promise 的三个状态，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> pending</span><br><span class="line">    <span class="keyword">case</span> fulfilled</span><br><span class="line">    <span class="keyword">case</span> rejected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>Promise 的核心目标是为了解决异步（或同步）任务的相关问题。首先，要解决两个问题：</p><ul><li><strong>如何表示异步任务？</strong></li><li><strong>如何更新任务状态？</strong></li></ul><p>对于第一个问题，很简单，我们可以提供一个闭包，让用户在闭包中自定义任务即可。</p><p>对于第二个问题，同样，我们可以提供两个状态更新方法，让用户在任务的特定阶段调用即可。</p><p>这里，我们定义的执行器如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Resolve</span>&lt;<span class="type">T</span>&gt; <span class="operator">=</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Reject</span> <span class="operator">=</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Executor</span> <span class="operator">=</span> (<span class="keyword">_</span> resolve: <span class="keyword">@escaping</span> <span class="type">Resolve</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">_</span> reject: <span class="keyword">@escaping</span> <span class="type">Reject</span>) -&gt; <span class="type">Void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上述定义的执行器是一个闭包，闭包的参数是两个状态更新方法，分别是 <code>resolve</code> 和 <code>reject</code>，可供用户在任务的特定阶段调用，以更新任务的状态。</p><p>由于 <code>resolve</code> 和 <code>reject</code> 方法分别用于设置 <code>fulfilled</code> 和 <code>rejected</code> 状态，两个状态分别对应两个值：<code>value</code> 和 <code>error</code>，从方法的入参可以看出两者的区别。因此，除了状态之外，还需定义两个字段，分别用于保存 <code>value</code> 和 <code>error</code>，具体定义如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> state: <span class="type">State</span> <span class="operator">=</span> .pending</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> value: <span class="type">T</span>?</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> error: <span class="type">Error</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式执行"><a href="#链式执行" class="headerlink" title="链式执行"></a>链式执行</h2><p>Promise 的核心功能之一是 <strong>链式执行</strong> 异步任务。那么，如何实现链式执行异步任务呢？很简单，我们将后一个 Promise 的异步任务存储在前一个 Promise 的回调任务列表中，当前一个 Promise 达到结束状态（<code>fulfilled</code> 或 <code>rejected</code>）时，执行其内部保存的下一个（组）回调任务即可。</p><p>对此，我们可以在 Promise 内部保存两个数组，分别用户存储 <code>fulfilled</code> 状态和 <code>rejected</code> 状态时要执行的回调任务。除此之外，我们还需要对 <code>resolve</code> 和 <code>reject</code> 方法进行进一步加工，方法调用时，分别设置当前异步任务的返回值、状态，并执行回调任务。具体定义如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> onFulfilledCallbacks <span class="operator">=</span> [<span class="type">Resolve</span>&lt;<span class="type">T</span>&gt;]()</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> onRejectedCallbacks <span class="operator">=</span> [<span class="type">Reject</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">executor</span>: <span class="type">Executor</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：resolve 和 reject 必须强引用 self，避免在执行 resolve 和 reject 之前系统释放 self</span></span><br><span class="line">        <span class="keyword">let</span> resolve: <span class="type">Resolve</span>&lt;<span class="type">T</span>&gt; <span class="operator">=</span> &#123; value <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">            <span class="keyword">self</span>.onFulfilledCallbacks.forEach &#123; onFullfilled <span class="keyword">in</span></span><br><span class="line">                onFullfilled(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.state <span class="operator">=</span> .fulfilled</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject: <span class="type">Reject</span> <span class="operator">=</span> &#123; error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.error <span class="operator">=</span> error</span><br><span class="line">            <span class="keyword">self</span>.onRejectedCallbacks.forEach &#123; onRejected <span class="keyword">in</span></span><br><span class="line">                onRejected(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.state <span class="operator">=</span> .rejected</span><br><span class="line">        &#125;</span><br><span class="line">        executor &#123; value <span class="keyword">in</span></span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125; <span class="keyword">_</span>: &#123; error <span class="keyword">in</span></span><br><span class="line">            reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们分别使用 <code>onFulfilledCallbacks</code> 和 <code>onRejectedCallbacks</code> 保存回调任务。同时定义了 <code>resolve</code> 和 <code>reject</code> 两个方法，内部分别设置异步任务的返回值、状态，并执行回调任务。</p><p>Promise 初始化时，执行器会立即执行，从而触发异步任务的执行，同时将两个状态更新方法作为参数传入闭包，以供用户在任务的特定阶段调用。</p><h2 id="任务串联"><a href="#任务串联" class="headerlink" title="任务串联"></a>任务串联</h2><p>Promise 通过 <code>then</code> 方法来串联任务，即让前一个 Promise 保存下一个 Promise 的任务。<code>then</code> 方法包含两个闭包 <code>onFulfilled</code> 和 <code>onRejected</code>，分别表示不同状态的回调任务，其在前一个 Promise 的状态为 <code>fulfilled</code> 和 <code>rejected</code> 时分别执行。</p><p>当 <code>then</code> 串联任务时，我们需要考虑前一个 Promise 的状态。这里，我们分三种情况进行考虑：</p><ul><li>当前一个 Promise 的状态为 <code>pending</code> 时，我们创建一个 Promise，其任务的核心是将 <code>onFulfilled</code> 和 <code>onRejected</code> 分别加入前一个 Promise 的回调任务队列中。</li><li>当前一个 Promise 的状态为 <code>fulfilled</code> 时，我们创建一个 Promise，其任务的核心是立即执行 <code>onFulfilled</code> 任务。</li><li>当前一个 Promise 的状态未 <code>rejected</code> 时，我们创建一个 Promise，其任务的核心是立即执行 <code>onRejected</code> 任务。</li></ul><p><code>then</code> 方法的具体实现如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="comment">// Functor</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">then</span>&lt;<span class="type">R</span>&gt;(<span class="params">onFulfilled</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">R</span>, <span class="params">onRejected</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .pending:</span><br><span class="line">            <span class="comment">// 将普通函数应用到包装类型，并返回包装类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] resolve, reject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 初始化时即执行</span></span><br><span class="line">                <span class="comment">// 在 curr promise 加入 onFulfilled/onRejected 任务，任务可修改 curr promise 的状态</span></span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onFulfilledCallbacks.append &#123; value <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">let</span> r <span class="operator">=</span> onFulfilled(value)</span><br><span class="line">                    resolve(r)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onRejectedCallbacks.append &#123; error <span class="keyword">in</span></span><br><span class="line">                    onRejected(error)</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .fulfilled:</span><br><span class="line">            <span class="keyword">let</span> value <span class="operator">=</span> value<span class="operator">!</span></span><br><span class="line">            <span class="comment">// 将普通函数应用到包装类型，并返回包装类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; resolve, <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> r <span class="operator">=</span> onFulfilled(value)</span><br><span class="line">                resolve(r)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .rejected:</span><br><span class="line">            <span class="keyword">let</span> error <span class="operator">=</span> error<span class="operator">!</span></span><br><span class="line">            <span class="comment">// 将普通函数应用到包装类型，并返回包装类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; <span class="keyword">_</span>, reject <span class="keyword">in</span></span><br><span class="line">                onRejected(error)</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>onFulfilled</code> 和 <code>onRejected</code> 闭包的入参和返回值，这是 <code>then</code> 能够实现异步任务的值传递的关键。</p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>上一节的 <code>then</code> 方法主要是 Functor 实现，为了进一步扩展 <code>then</code> 方法的，我们来实现 Monad <code>then</code> 方法，具体实现如下所示。</p><p>关于 Functor 和 Monad 的概念，可以阅读 <a href="http://chuquan.me/2020/07/06/fp-functor-applicative-monad/">《函数式编程——Functor、Applicative、Monad》</a>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="comment">// Monad</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">then</span>&lt;<span class="type">R</span>&gt;(<span class="params">onFulfilled</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">R</span>&gt;, <span class="params">onRejected</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> state &#123;</span><br><span class="line">        <span class="keyword">case</span> .pending:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] resolve, reject <span class="keyword">in</span></span><br><span class="line">                <span class="comment">// 初始化时即执行</span></span><br><span class="line">                <span class="comment">// 在 prev promise 的 callback 队列加入一个生成 midd promise 的任务。</span></span><br><span class="line">                <span class="comment">// 在 midd promise 的 callback 队列加入一个任务，修改 curr promise 状态。</span></span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onFulfilledCallbacks.append &#123; value <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">let</span> promise <span class="operator">=</span> onFulfilled(value)</span><br><span class="line">                    promise.then(onFulfilled: &#123; r <span class="keyword">in</span></span><br><span class="line">                        resolve(r)</span><br><span class="line">                    &#125;, onRejected: &#123; <span class="keyword">_</span> <span class="keyword">in</span> &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">self</span><span class="operator">?</span>.onRejectedCallbacks.append &#123; error <span class="keyword">in</span></span><br><span class="line">                    onRejected(error)</span><br><span class="line">                    reject(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .fulfilled:</span><br><span class="line">            <span class="keyword">return</span> onFulfilled(value<span class="operator">!</span>)</span><br><span class="line">        <span class="keyword">case</span> .rejected:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">R</span>&gt; &#123; <span class="keyword">_</span>, reject <span class="keyword">in</span></span><br><span class="line">                onRejected(error<span class="operator">!</span>)</span><br><span class="line">                reject(error<span class="operator">!</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="便利方法"><a href="#便利方法" class="headerlink" title="便利方法"></a>便利方法</h2><p>通常 Promise 还具有一系列遍历方法，如：<code>fistly</code>、<code>catch</code>、<code>done</code>、<code>finally</code> 等。下面，我们依次实现。</p><p><code>firstly</code> 方法本质上是语法糖，表示异步任务组的第一步。我们实现一个全局方法，通过闭包实现任务的具体逻辑，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">firstly</span>&lt;<span class="type">T</span>&gt;(<span class="params">closure</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Promise</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>catch</code> 方法仅用于处理错误，其可通过 <code>then</code> 方法实现，关键是实现 <code>onRejected</code> 方法，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">`catch`</span>(<span class="params">onError</span>: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> then(onFulfilled: &#123; <span class="keyword">_</span> <span class="keyword">in</span> &#125;, onRejected: onError)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>done</code> 方法仅用于处理返回值，其可通过 <code>then</code> 方法实现，关键是实现 <code>onFulfilled</code> 方法，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">done</span>(<span class="params">onNext</span>: <span class="keyword">@escaping</span> (<span class="type">T</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Promise</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> then(onFulfilled: onNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finally</code> 方法用于 Promise 链式调用的末尾，其并不接收之前任务的返回值和错误，支持用户在任务结束时执行状态无关的任务，具体实现如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">finally</span>(<span class="params">onCompleted</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        then(onFulfilled: &#123; <span class="keyword">_</span> <span class="keyword">in</span> onCompleted() &#125;, onRejected: &#123; <span class="keyword">_</span> <span class="keyword">in</span> onCompleted() &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>类似 Rx，Promise 的内存管理十分巧妙，其核心原理是 <strong>通过闭包强引用对象</strong>。下面，我们来分别介绍一下 Functor <code>then</code> 和 Monad <code>then</code> 的内存管理。</p><h2 id="Functor-then"><a href="#Functor-then" class="headerlink" title="Functor then"></a>Functor <code>then</code></h2><p>如下所示，为 Functor <code>then</code> 方法产生的内存管理示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promise-01.png?x-oss-process=image/resize,w_800"></p><p>在初始化 Promise 时，<code>resolve</code> 和 <code>reject</code> 方法必须强引用 Promise，否则等到异步任务执行完成时，Promise 早已释放，根本无法通过 Promise 执行回调任务。</p><p>当调用 Functor <code>then</code> 方法时，Promise 的两个回调任务列表将引用 <code>then</code> 方法所传入的两个闭包 <code>onFulfilled</code> 和 <code>onRejected</code>，同时引用 <code>then</code> 方法内部创建的 Promise 的 <code>resolve</code> 和 <code>reject</code> 方法。新创建的 Promise 又被自身的 <code>resolve</code> 和 <code>reject</code> 方法所引用，从而实现线性的内存引用关系。</p><h2 id="Monad-then"><a href="#Monad-then" class="headerlink" title="Monad then"></a>Monad <code>then</code></h2><p>如下所示，为 Monad <code>then</code> 方法产生的内存管理示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/promise-02.png?x-oss-process=image/resize,w_800"></p><p>同样，当调用 Monad <code>then</code> 方法是，Promise 的两个回调任务数组将引用 <code>then</code> 方法所传入的两个闭包 <code>onFulfilled</code> 和 <code>onRejected</code>，同时引用 <code>then</code> 方法内部创建的 Promise 的 <code>reject</code> 方法。从而实现线性的内存引用关系。</p><p>区别于 Functor <code>then</code>，Monad <code>then</code> 方法的 <code>onFulfilled</code> 闭包会返回一个包装类型 <code>Promise&lt;R&gt;</code>。因此，当 Promise 状态为 <code>fulfilled</code> 或 <code>rejected</code> 时，<code>then</code> 会立即返回由该闭包生成的 Promise；当 Promise 状态为 <code>pending</code> 时，<code>then</code> 会将闭包生成的 Promise 作为中间层 Promise，由中间层 Promise 调用 Functor <code>then</code>，从而产生一个间接的线性内存引用。</p><h1 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h1><p>下面，我们来编写一个网络请求的例子来对我们实现的 Promise 进行测试。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">NetworkError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> decodeError</span><br><span class="line">    <span class="keyword">case</span> responseError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> avatarURL: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123; <span class="string">&quot;name: =&gt; <span class="subst">\(name)</span>; avatar =&gt; <span class="subst">\(avatarURL)</span>&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAPI</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">user</span>() -&gt; <span class="type">Promise</span>&lt;<span class="type">User</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">User</span>&gt; &#123; (resolve, reject) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// Mock HTTP Request</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;request user info&quot;</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> arc4random() <span class="operator">%</span> <span class="number">10</span> <span class="operator">!=</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> result &#123;</span><br><span class="line">                    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>(name: <span class="string">&quot;chuquan&quot;</span>, avatarURL: <span class="string">&quot;avatarurl&quot;</span>)</span><br><span class="line">                    resolve(user)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">NetworkError</span>.responseError)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">avatar</span>() -&gt; <span class="type">Promise</span>&lt;<span class="type">UIImage</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>&lt;<span class="type">UIImage</span>&gt; &#123; (resolve, reject) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// Mock HTTP Request</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;request avatar info&quot;</span>)</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> arc4random() <span class="operator">%</span> <span class="number">10</span> <span class="operator">!=</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> result &#123;</span><br><span class="line">                    <span class="keyword">let</span> avatar <span class="operator">=</span> <span class="type">UIImage</span>()</span><br><span class="line">                    resolve(avatar)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(<span class="type">NetworkError</span>.decodeError)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个 <code>TestAPI</code> 的类，其提供两个方法，分别请求用户信息和头像信息，返回值均为 Promise。其内部我们使用 GDC 延迟进行模拟，使用随机数设置网络请求的成功和失败情况。</p><p>接下来，我们来进行功能测试，依次请求用户信息和头像信息，如下所示。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api <span class="operator">=</span> <span class="type">TestAPI</span>()</span><br><span class="line">firstly &#123;</span><br><span class="line">    api.user()</span><br><span class="line">&#125;.then &#123; user <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;user name =&gt; <span class="subst">\(user)</span>&quot;</span>)</span><br><span class="line">    api.avatar()</span><br><span class="line">&#125;.catch &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;request error&quot;</span>)</span><br><span class="line">&#125;.finally &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;request complete&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当网络请求成功时，我们会得到如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request user info</span><br><span class="line">user name =&gt; User(name: <span class="string">&quot;chuquan&quot;</span>, avatarURL: <span class="string">&quot;avatarurl&quot;</span>)</span><br><span class="line">request avatar info</span><br><span class="line">request complete</span><br></pre></td></tr></table></figure><p>当网络请求失败时，我们则得到如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request user info</span><br><span class="line">request error</span><br><span class="line">request complete</span><br></pre></td></tr></table></figure><p>从执行顺序和结果而言，是符合我们的预期的。当然，我们还可以编写更多测试用例来进行测试，本文将不再赘述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文，我们介绍了一种常见的异步编程技术 Promise，深入分析其设计原理，并最终手动实现一套简易的 Promise 框架。此外，我们还对 Promise 的内存管理进行了简要的分析，以深入了解内部的运行机制。</p><p>后续，有机会的话，我们来分析一款流行的 Promise 开源框架，以进一步验证 Promise 的设计。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures and Promises</a></li><li><a href="http://dist-prog-book.com/chapter/2/futures.html">Futures and Promises</a></li><li><a href="https://promisesaplus.com/">Promises&#x2F;A+</a></li><li><a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li><li><a href="https://juejin.cn/post/6945319439772434469">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li><li><a href="https://fuzhe1989.github.io/2018/01/30/future-promise/">Future与Promise</a></li><li><a href="http://khanlou.com/2015/09/what-the-heck-is-a-monad/">A promise is a Monad</a></li><li><a href="https://gist.github.com/peter-leonov/c86720d1517235a1f28cd453a9d39bb4">async&#x2F;await is just the do-notation of the Promise monad</a></li><li><a href="https://khanlou.com/2015/09/what-the-heck-is-a-monad/">What The Heck Is A Monad</a></li><li><a href="https://bluepnume.medium.com/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">Understand promises before you start using async&#x2F;await</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在传统的基于 &lt;strong&gt;闭包&lt;/strong&gt; 的异步编程中，经常会出现 &lt;strong&gt;地狱嵌套&lt;/strong&gt; 的问题，这使得高度异步的代码几乎无法阅读。Promise 则是解决这个问题的众多方案之一。&lt;/p&gt;
&lt;p&gt;Promise 的核心思想是：&lt;strong</summary>
      
    
    
    
    <category term="异步与并发" scheme="http://chuquan.me/categories/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Functor" scheme="http://chuquan.me/tags/Functor/"/>
    
    <category term="Monad" scheme="http://chuquan.me/tags/Monad/"/>
    
    <category term="Promise" scheme="http://chuquan.me/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(10)——总结</title>
    <link href="http://chuquan.me/2022/09/17/compiler-for-kaleidoscope-10/"/>
    <id>http://chuquan.me/2022/09/17/compiler-for-kaleidoscope-10/</id>
    <published>2022-09-17T14:52:12.000Z</published>
    <updated>2023-01-14T03:13:42.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>本章是本系列教程的最后一章。通过本教程，我们实现并扩展 Kaleidoscope 编程语言，使其语言的特性和功能不断增强。</p><p>在这个过程中，我们构建了词法分析器、解析器、AST、代码生成器、REPL、JIT，并为可执行文件支持了调试信息。所有的功能仅仅用了 1000 行左右代码就实现了。</p><p>我们的语言支持几个有趣的特性，比如：支持自定义的二元运算符和一元运算符，支持 JIT 编译并执行，支持构造控制流等。</p><p>本教程的初衷是为了向开发者展示定义、构建、使用语言是如此简单和有趣，编译器的实现也并不是难如登天！现在，我们已经了解了自制编译器的一些基础知识，这里强烈建议开发者能够使用代码对其进行魔改。比如，可以尝试支持以下这些特性：</p><ul><li><strong>全局变量</strong>：虽然全局变量在软件工程中并不是一个非常有价值的特性，但是将它应用于 Kaleidoscope 中，其实是非常有用的。在目前的实现中，我们可以非常容易地为 Kaleidoscope 支持全局变量：只需要在全局变量符号表中查找未解析的变量即可。如果要创建全局变量，请使用 LLVM <code>GlobalVariable</code> 类。</li><li><strong>类型变量</strong>：目前，Kaleidoscope 只支持一种数据类型 <code>double</code>。由于只支持一种类型，因此无需指定变量类型。如果要支持多种数据类型，最简单的方法是要求用户为每个变量定义指定类型，并在符号表中记录变量的类型及其值。</li><li><strong>数组、结构体、向量</strong>：一旦支持了多种类型，我们可以通过各种方式对类型系统进行扩展。对于数组、结构体、向量等类型，其核心是基于 LLVM <code>getelementptr</code> 进行实现。</li><li><strong>标准运行时</strong>：目前，Kaleidoscope 运行用于访问任意外部函数，比如：<code>printd</code>、<code>putchard</code> 等。当我们扩展语言以支持更高级的特性时，可以考虑实现运行时。比如：对于实现哈希表，哈希表底层封装了一系列实现，如果将这些实现内联至代码中，那么每定义一个哈希表会生成底层的实现代码，如果我们将哈希表的底层实现作为一个子程序定义在运行时，那么将会非常具有优化意义。</li><li><strong>内存管理</strong>：目前，Kaleidoscope 只能访问栈内存。如果为 Kaleidoscope 支持通过调用标准的 libc <code>malloc</code>&#x2F;<code>free</code> 接口或使用垃圾收集器来分配堆内存，那么也能够极大地增强语言的能力。对此，LLVM 是完全支持精准垃圾收集（Accurate Garbage Collection）功能的，包括对象移动、栈扫描与更新等算法。</li><li><strong>异常处理</strong>：LLVM 支持生成零开销异常。此外，我们还可以隐式地使每个函数返回一个错误值并检查，从而生成代码。我们还可以显式地使用 <code>setjmp</code>&#x2F;<code>longjmp</code>。</li><li>**面向对象、泛型、数据库访问、复数、几何编程…**：我们可以为语言扩展任何特性。</li><li><strong>其他领域</strong>：我们可以将 LLVM 应用至很多领域，从而构建特定语言。当然，还有很多其他领域会利用编译相关技术，比如：LLVM 被用于实现 OpenGL图形加速、C++ 代码转换为 ActionScript 等等。甚至，也许你将是第一个使用 LLVM 将正则表达式解释器 JIT 编译成本机代码的人！</li></ul><h1 id="LLVM-IR-属性"><a href="#LLVM-IR-属性" class="headerlink" title="LLVM IR 属性"></a>LLVM IR 属性</h1><p>对于 LLVM IR，我们经常会有一些疑问。本章，我们梳理了一些常见的问题，并进行解答。</p><h2 id="目标独立"><a href="#目标独立" class="headerlink" title="目标独立"></a>目标独立</h2><p>Kaleidoscope 是<strong>可移植语言</strong> 的一个例子：任何用 Kaleidoscope 编写的程序都可以在它运行的任何目标上以相同的方式工作。绝大多数编程语言都具有此属性，如：lisp、java、haskell、javascript、python 等。但需要注意的是，虽然这些语言是可移植的，但并非所有的库都是如此。</p><p>LLVM 有一个特性是它通常能够在 IR 中保持目标独立：我们可以将 LLVM IR 用于 Kaleidoscope 编译的程序并在 LLVM 支持的任何目标上运行它。简而言之，Kaleidoscope 编译器生成与目标无关的代码，因为它在生成代码时不会查询任何特定于目标的信息。</p><h2 id="安全保证"><a href="#安全保证" class="headerlink" title="安全保证"></a>安全保证</h2><p>上面提到的一些编程语言，很多都是 <strong>安全</strong> 的语言。比如，用 Java 编写的程序不可能破坏其地址空间并使进程崩溃（假设 JVM 没有错误）。 安全性是一个有趣的属性，它需要结合语言设计、运行时支持以及操作系统支持。</p><p>在 LLVM 中实现安全语言是完全可以的，但 LLVM IR 本身并不能保证安全。LLVM IR 允许不安全的指针转换、释放错误后使用、缓冲区溢出和各种其他问题。要实现安全的特性，我们需要在 LLVM 之上构建一个层来实现。</p><h2 id="语言特定优化"><a href="#语言特定优化" class="headerlink" title="语言特定优化"></a>语言特定优化</h2><p>和其他工具一样，LLVM 不能在一个系统中解决所有的问题。对此，很多开发者会抱怨 LLVM 无法执行高级语言的特定优化，因为 LLVM 丢失了太多信息。对此，本章给出了如下的一些看法。</p><p>首先，LLVM 确实会丢失信息。例如，在撰写本教程时，在 LLVM IR 中无法区分 SSA 值是来自 ILP32 机器上的 C <code>int</code> 还是 C <code>long</code>（调试信息除外）。两者都被编译为 <code>i32</code> 值，并且关于它来自什么的信息丢失了。这里更普遍的问题是 LLVM 类型系统使用 “结构等价” 而不是 “命名等价”。另一个让人感到惊讶的地方是，如果我们在高级语言中有两种具有相同结构的类型（例如，两个具有单个 <code>int</code> 字段的不同结构），那么这些类型将被编译成单个 LLVM 类型。</p><p>其次，虽然 LLVM 确实会丢失信息，但 LLVM 并不是一个固定的目标：我们会继续以许多不同的方式增强和改进它。除了添加新功能（LLVM 并不总是支持异常或调试信息）外，我们还扩展了 IR 以捕获重要信息以进行优化（例如，参数是符号扩展还是零扩展、指针别名信息等）。许多增强功能都是用户驱动的：开发者希望 LLVM 包含一些特定功能，为此，开发者们一直在对它进行扩展。</p><p>第三，添加特定于语言的优化是可能且容易的。举一个简单的例子，我们可以很容易地添加特定于语言的优化通道，从而为一种语言编译的代码。对于 C 系列，有一个标准 C 库函数的优化通道。如果我们在 <code>main()</code> 中调用 <code>exit(0)</code>，它会知道将其优化为 <code>return 0;</code> 是安全的。</p><p>此外，还可以将各种其他语言特定的信息嵌入到 LLVM IR 中。即使在最坏的情况下，我们也可以将 LLVM 视为纯粹的代码生成器，并在特定于语言的 AST 上在编译前端实现我们想要的高级优化。</p><h1 id="提示与技巧"><a href="#提示与技巧" class="headerlink" title="提示与技巧"></a>提示与技巧</h1><p>在使用 LLVM 之后，我们会了解到许多有用的提示与技巧，这些技巧和技巧乍一看并不明显。这里，我们只讨论其中的一些问题。</p><h2 id="实现可移植的-offsetof-sizeof"><a href="#实现可移植的-offsetof-sizeof" class="headerlink" title="实现可移植的 offsetof&#x2F;sizeof"></a>实现可移植的 offsetof&#x2F;sizeof</h2><p>如果我们希望让编译器生成的代码保持 <strong>目标独立</strong>，那么会出现一件有趣的事情，那就是我们经常需要知道某些 LLVM 类型的大小或 llvm 结构中某些字段的偏移量。 例如，我们可能需要将类型的大小传递给分配内存的函数。</p><p>不幸的是，这在不同目标之间可能会有很大差异：例如，指针的宽度是特定于目标的。不过，有一种巧妙的方法，即使用 <code>getelementptr</code> 指令，它允许我们以可移植的方式计算它。</p><h2 id="垃圾回收栈帧"><a href="#垃圾回收栈帧" class="headerlink" title="垃圾回收栈帧"></a>垃圾回收栈帧</h2><p>某些语言想要显式地管理栈帧，通常是为了支持垃圾收集栈帧或允许实现闭包。事实上，通常有比显式管理栈帧更好的方法来实现这些功能，但如果我们执意这么做，LLVM 也是支持的。 这需要我们的编译前端将代码转换为连续传递样式并使用尾调用（LLVM 也支持）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本系列教程通过基于 LLVM 自制一款针对 Kaleidoscope 编程语言的编译器，在这个过程中，展示了自制编程语言或编译器所涉及的一些相关概念和知识，从而产生一个系统的认知。至此，本教程结束了！如果希望有更进一步探索，建议大家着手开始 LLVM，毕竟代码才是真理！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.html">Conclusion and other useful LLVM tidbits</a></li><li><a href="https://llvm.org/docs/LangRef.html#getelementptr-instruction">getelementptr</a></li><li><a href="https://llvm.org/docs/GetElementPtr.html">The Often Misunderstood GEP Instruction</a></li><li><a href="https://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt">clever way to use the getelementptr instruction</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;展望&quot;&gt;&lt;a href=&quot;#展望&quot; class=&quot;headerlink&quot; title=&quot;展望&quot;&gt;&lt;/a&gt;展望&lt;/h1&gt;&lt;p&gt;本章是本系列教程的最后一章。通过本教程，我们实现并扩展 Kaleidoscope 编程语言，使其语言的特性和功能不断增强。&lt;/p&gt;
&lt;p&gt;在</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="运行时" scheme="http://chuquan.me/tags/%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
    <category term="内存管理" scheme="http://chuquan.me/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="类型系统" scheme="http://chuquan.me/tags/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(9)——调试信息</title>
    <link href="http://chuquan.me/2022/09/17/compiler-for-kaleidoscope-09/"/>
    <id>http://chuquan.me/2022/09/17/compiler-for-kaleidoscope-09/</id>
    <published>2022-09-17T08:54:24.000Z</published>
    <updated>2023-01-14T03:13:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过 8 章的教程，我们实现了一门支持函数和变量的编程语言。那么，如果代码运行或编译出错时，我们该如何调试程序呢？</p><p>本质上，源码调试是基于 <strong>格式化数据</strong> 实现的，<strong>格式化数据可以辅助调试器实现二进制和机器状态转换至程序员编写的源码</strong>。在 LLVM 中，我们通常使用一种称为 <strong>DWARF</strong> 的格式。<strong>DWARF 是一种紧凑的编码，可以表示类型、源码位置、变量位置</strong>。</p><p>本章，我们将介绍如何基于 DWARF 为 Kaleidoscope 实现调试能力。</p><blockquote><p>目前我们无法通过 JIT 进行调试，因此我们需要将我们的程序编译为小型且独立的东西。作为其中的一部分，我们将对语言的运行和程序的编译方式进行一些修改。 这意味着我们将拥有一个源文件，其中包含一个用 Kaleidoscope 编写的简单程序，而不是交互式 JIT。它确实涉及一个限制，即我们一次只能有一个“顶级”命令，以减少必要的更改数量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fib</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h1 id="实现难点"><a href="#实现难点" class="headerlink" title="实现难点"></a>实现难点</h1><p>编译器支持调试信息的主要实现难点在于 <strong>已优化的代码</strong>。</p><p>首先，编译器代码优化使得保留源码位置更加困难。在 LLVM IR 中，我们为每个 IR 级指令保留源码位置。优化通道同样也会保存新创建指令的源码位置，但合并的指令只能保留一个位置，这可能会导致在单步执行优化程序时出现跳转。</p><p>其次，部分优化通道可能会移动变量的位置，从而导致变量难以追溯。</p><h1 id="源码位置"><a href="#源码位置" class="headerlink" title="源码位置"></a>源码位置</h1><p>从实现难点中我们可以看出，实现调试的关键在于 <strong>源码位置</strong>。因此，我们定义了 <code>SourceLocation</code> 数据结构，用于存储源码位置信息，同时使用两个全局变量 <code>CurLoc</code> 和 <code>LexLoc</code> 分别存储词法分析时的当前位置信息和 token 位置信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SourceLocation</span> &#123;</span><br><span class="line">  <span class="type">int</span> Line;</span><br><span class="line">  <span class="type">int</span> Col;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> SourceLocation CurLoc;</span><br><span class="line"><span class="type">static</span> SourceLocation LexLoc = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>为了让 AST 支持存储源码位置，我们对 <code>ExprAST</code> 扩展了 <code>Loc</code> 字段，用于保存对应表达式的位置信息，如下所示。同时，<code>ExprAST</code> 提供了几个便利方法，用于读取行和列的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExprAST</span> &#123;</span><br><span class="line">  SourceLocation Loc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ExprAST</span>(SourceLocation Loc = CurLoc) : <span class="built_in">Loc</span>(Loc) &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getLine</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Loc.Line; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCol</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Loc.Col; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> raw_ostream &amp;<span class="title">dump</span><span class="params">(raw_ostream &amp;out, <span class="type">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; <span class="built_in">getLine</span>() &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; <span class="built_in">getCol</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-31.png?x-oss-process=image/resize,w_800"></p><p>那么源码位置在哪里读取呢？很显然，在词法分析阶段进行读取。因此，我们实现了一个新的词法分析输入器 <code>advance()</code>，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> LastChar = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">&#x27;\n&#x27;</span> || LastChar == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">    LexLoc.Line++;</span><br><span class="line">    LexLoc.Col = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    LexLoc.Col++;</span><br><span class="line">  <span class="keyword">return</span> LastChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们将词法分析器的输入器 <code>getchar()</code> 替换成 <code>advance()</code>，从而实现了字符、位置等信息的读取。</p><h1 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h1><p>接下来，我们定义一个 <code>DebugInfo</code> 结构用于表示调试信息，其主要包含三个字段：</p><ul><li><code>TheCU</code>：<code>DICompileUnit *</code> 类型，用于表示一个编译单元。在编译过程中，一个源文件对应一个编译单元。</li><li><code>DblTy</code>：<code>DIType *</code> 类型，用于表示一个数据类型。由于 Kaleidoscope 只包含一种类型 <code>double</code>，因此这里只定义一个字段。</li><li><code>LexicalBlocks</code>：<code>vector&lt;DIScope *&gt;</code> 类型，用于表示一个作用域栈，栈顶的作用域表示当前作用域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DebugInfo</span> &#123;</span><br><span class="line">  DICompileUnit *TheCU;</span><br><span class="line">  DIType *DblTy;</span><br><span class="line">  std::vector&lt;DIScope *&gt; LexicalBlocks;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">emitLocation</span><span class="params">(ExprAST *AST)</span></span>;</span><br><span class="line">  <span class="function">DIType *<span class="title">getDoubleTy</span><span class="params">()</span></span>;</span><br><span class="line">&#125; KSDbgInfo;</span><br><span class="line"></span><br><span class="line"><span class="function">DIType *<span class="title">DebugInfo::getDoubleTy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (DblTy)</span><br><span class="line">    <span class="keyword">return</span> DblTy;</span><br><span class="line"></span><br><span class="line">  DblTy = DBuilder-&gt;<span class="built_in">createBasicType</span>(<span class="string">&quot;double&quot;</span>, <span class="number">64</span>, dwarf::DW_ATE_float);</span><br><span class="line">  <span class="keyword">return</span> DblTy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DebugInfo::emitLocation</span><span class="params">(ExprAST *AST)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!AST)</span><br><span class="line">    <span class="keyword">return</span> Builder-&gt;<span class="built_in">SetCurrentDebugLocation</span>(<span class="built_in">DebugLoc</span>());</span><br><span class="line">  DIScope *Scope;</span><br><span class="line">  <span class="keyword">if</span> (LexicalBlocks.<span class="built_in">empty</span>())</span><br><span class="line">    Scope = TheCU;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    Scope = LexicalBlocks.<span class="built_in">back</span>();</span><br><span class="line">  Builder-&gt;<span class="built_in">SetCurrentDebugLocation</span>(DILocation::<span class="built_in">get</span>(</span><br><span class="line">      Scope-&gt;<span class="built_in">getContext</span>(), AST-&gt;<span class="built_in">getLine</span>(), AST-&gt;<span class="built_in">getCol</span>(), Scope));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确保每条指令都能获得正确的源码位置，当处于新的源码位置时，我们必须通知 <code>IRBuilder</code>。为此，我们通过 <code>DebugInfo</code> 提供一个辅助方法 <code>emitLocation</code>。</p><h1 id="DWARF-生成设置"><a href="#DWARF-生成设置" class="headerlink" title="DWARF 生成设置"></a>DWARF 生成设置</h1><p>对于支持 LLVM IR，我们通过 <code>IRBuilder</code> 来实现代码生成。对于支持调试信息，我们通过 <code>DIBuilder</code> 来构建 <strong>调试元数据</strong>。</p><p>这里，我们使用 <code>DIBuilder</code> 来构建所有的 IR 级别描述。基于 <code>DIBuilder</code> 构建 LLVM IR 的前提是必须构建一个模块。因此，我们在构建模块之后立即构建 <code>DIBuilder</code>，并将其作为全局静态变量，以便于使用，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;DIBuilder&gt; DBuilder;</span><br></pre></td></tr></table></figure><h1 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h1><p>上面，我们让词法分析器支持读取位置信息，并且定义了 <code>DebugInfo</code> 类型用于表示调试信息。</p><p>下面，我们来修改编译器的主流程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmParser</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;=&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  TheJIT = <span class="built_in">ExitOnErr</span>(KaleidoscopeJIT::<span class="built_in">Create</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitializeModule</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the current debug info version into the module.</span></span><br><span class="line">  TheModule-&gt;<span class="built_in">addModuleFlag</span>(Module::Warning, <span class="string">&quot;Debug Info Version&quot;</span>,</span><br><span class="line">                           DEBUG_METADATA_VERSION);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Darwin only supports dwarf2.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Triple</span>(sys::<span class="built_in">getProcessTriple</span>()).<span class="built_in">isOSDarwin</span>())</span><br><span class="line">    TheModule-&gt;<span class="built_in">addModuleFlag</span>(llvm::Module::Warning, <span class="string">&quot;Dwarf Version&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct the DIBuilder, we do this here because we need the module.</span></span><br><span class="line">  DBuilder = std::<span class="built_in">make_unique</span>&lt;DIBuilder&gt;(*TheModule);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the compile unit for the module.</span></span><br><span class="line">  <span class="comment">// Currently down as &quot;fib.ks&quot; as a filename since we&#x27;re redirecting stdin</span></span><br><span class="line">  <span class="comment">// but we&#x27;d like actual source locations.</span></span><br><span class="line">  KSDbgInfo.TheCU = DBuilder-&gt;<span class="built_in">createCompileUnit</span>(</span><br><span class="line">      dwarf::DW_LANG_C, DBuilder-&gt;<span class="built_in">createFile</span>(<span class="string">&quot;fib.ks&quot;</span>, <span class="string">&quot;.&quot;</span>),</span><br><span class="line">      <span class="string">&quot;Kaleidoscope Compiler&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main &quot;interpreter loop&quot; now.</span></span><br><span class="line">  <span class="built_in">MainLoop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finalize the debug info.</span></span><br><span class="line">  DBuilder-&gt;<span class="built_in">finalize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print out all of the generated code.</span></span><br><span class="line">  TheModule-&gt;<span class="built_in">print</span>(<span class="built_in">errs</span>(), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主流程中，当模块初始化完毕之后，我们基于模块构造 <code>DIBuilder</code>。然后通过 <code>DIBuilder</code> 构造一个编译单元，并存储在全局变量 <code>KSDgbInfo</code> 的 <code>TheCU</code> 字段中。中间开始执行代码的编译。最后，通过调用 <code>DBuilder-&gt;finalize()</code> 确定调试信息。</p><p>这里有几点值得注意：</p><ul><li>首先，当我们为一种 Kaleidoscope 语言生成编译单元时，我们使用了 C 语言常量。这是因为调试器不一定能理解它无法识别的语言的调用或 ABI，相对而言，我们在 LLVM 代码生成中使用 C ABI，这是比较准确的。这能够确保我们可以真正从调试器调用函数并让它们执行。</li><li>其次，我们在 <code>createCompileUnit</code> 调用中看到 <code>fib.ks</code>。这里是一个默认的硬编码值，因为我们使用 shell 重定向将源代码输入 Kaleidoscope 编译器。在常规的编译前端中，我们会有一个输入文件名。</li></ul><p>在主流程中，<code>MainLoop()</code> 包含了编译器的核心逻辑。接下来，我们来看看其中函数的定义与调用是如何支持调试信息的。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上面，我们介绍了编译单元和源码位置。现在，我们为函数定义支持调试信息中。如下所示，我们对 <code>FunctionAST::codegen()</code> 进行了改造，使其支持插入调试信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">  Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">    BinopPrecedence[P.<span class="built_in">getOperatorName</span>()] = P.<span class="built_in">getBinaryPrecedence</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a subprogram DIE for this function.</span></span><br><span class="line">  DIFile *Unit = DBuilder-&gt;<span class="built_in">createFile</span>(KSDbgInfo.TheCU-&gt;<span class="built_in">getFilename</span>(),</span><br><span class="line">                                      KSDbgInfo.TheCU-&gt;<span class="built_in">getDirectory</span>());</span><br><span class="line">  DIScope *FContext = Unit;</span><br><span class="line">  <span class="type">unsigned</span> LineNo = P.<span class="built_in">getLine</span>();</span><br><span class="line">  <span class="type">unsigned</span> ScopeLine = LineNo;</span><br><span class="line">  DISubprogram *SP = DBuilder-&gt;<span class="built_in">createFunction</span>(</span><br><span class="line">      FContext, </span><br><span class="line">      P.<span class="built_in">getName</span>(), </span><br><span class="line">      <span class="built_in">StringRef</span>(), </span><br><span class="line">      Unit, </span><br><span class="line">      LineNo,</span><br><span class="line">      <span class="built_in">CreateFunctionType</span>(TheFunction-&gt;<span class="built_in">arg_size</span>(), Unit), </span><br><span class="line">      ScopeLine,</span><br><span class="line">      DINode::FlagPrototyped, </span><br><span class="line">      DISubprogram::SPFlagDefinition</span><br><span class="line">  );</span><br><span class="line">  TheFunction-&gt;<span class="built_in">setSubprogram</span>(SP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push the current scope.</span></span><br><span class="line">  KSDbgInfo.LexicalBlocks.<span class="built_in">push_back</span>(SP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unset the location for the prologue emission (leading instructions with no</span></span><br><span class="line">  <span class="comment">// location in a function are considered part of the prologue and the debugger</span></span><br><span class="line">  <span class="comment">// will run past them when breaking on a function)</span></span><br><span class="line">  KSDbgInfo.<span class="built_in">emitLocation</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="type">unsigned</span> ArgIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, Arg.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a debug descriptor for the variable.</span></span><br><span class="line">    DILocalVariable *D = DBuilder-&gt;<span class="built_in">createParameterVariable</span>(</span><br><span class="line">        SP, Arg.<span class="built_in">getName</span>(), ++ArgIdx, Unit, LineNo, KSDbgInfo.<span class="built_in">getDoubleTy</span>(),</span><br><span class="line">        <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    DBuilder-&gt;<span class="built_in">insertDeclare</span>(Alloca, D, DBuilder-&gt;<span class="built_in">createExpression</span>(),</span><br><span class="line">                            DILocation::<span class="built_in">get</span>(SP-&gt;<span class="built_in">getContext</span>(), LineNo, <span class="number">0</span>, SP),</span><br><span class="line">                            Builder-&gt;<span class="built_in">GetInsertBlock</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = Alloca;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 <code>FunctionAST::codegen()</code> 中关于调试信息相关的逻辑如下</p><ul><li>基于编译单元 <code>KSDbgInfo.TheCU</code> ，调用 <code>DBuilder-&gt;createFile</code> 方法，构造 <code>DIFile</code> 调试文件。</li><li>根据函数行号、函数名、函数作用域、<code>DIFile</code> 等信息，调用 <code>DBuilder-&gt;createFunction</code> 方法，构造 <code>DISubprogram</code> 调试函数，其包含了对函数多有元数据的引用，可用于辅助支持调试。</li><li>开始解析函数内容。由于函数支持嵌套作用域。因此，将当前的函数作用域向 <code>KSDbgInfo.LexicalBlocks</code> 作用域栈压栈。</li><li>开始解析函数参数。为了避免为函数原型生成行信息，我们调用 <code>KSDbgInfo.emitLocation(nullptr)</code> 对源码位置进行复位。</li><li>函数参数解析过程，对于每一个参数，调用 <code>DBuilder-&gt;createParameterVariable</code> 方法，构造 <code>DILocalVariable</code> 调试变量。基于调试变量，调用 <code>DBuilder-&gt;insertDeclare</code> 方法（lvm.dbg.declare），声明引用一个 <code>alloca</code> 指令分配的变量，并设置源码位置。</li><li>结束解析函数参数，开始解析函数体。我们调用 <code>KSDbgInfo.emitLocation(Body.get())</code> 对源码位置进行设置。</li><li>结束解析函数内容。将当前作用域从 <code>KSDbgInfo.LexicalBlocks</code> 作用域栈中出栈。</li></ul><p>注意，并不是所有代码都需要包含行信息。在 <code>FunctionAST::codegen()</code> 方法中，我们专门通过 <code>KSDbgInfo.emitLocation(nullptr)</code> 避免为函数原型生成行信息。</p><h1 id="AOT-编译模式"><a href="#AOT-编译模式" class="headerlink" title="AOT 编译模式"></a>AOT 编译模式</h1><p>之前，我们实现的编译器始终是基于 JIT 编译模式，现在，我们实现的编译器将基于 AOT 编译模式。对此，我们在源码中删除交互式输入的相关逻辑，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="comment">// fprintf(stderr, &quot;ready&gt; &quot;);</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>最后，我们可以通过以下命令行将 Kaleidoscope 代码编译为可执行程序。然后，输入 Kaleidoscope 源码文件，生成 LLRVM IR，其中包含了 DWARF 调试信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Kaleidoscope-Ch9 &lt; fib.ks </span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文，我们对 Kaleidoscope 进行了改造，使其能够支持 DWARF 调试信息。DWARF 调试信息作用非常大，可以辅助我们进行代码调试，后续有机会，我们将继续深入了解一下 DWARF。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html">Kaleidoscope: Adding Debug Information</a></li><li><a href="https://dwarfstd.org/">The DWARF Debugging Standard</a></li><li><a href="https://llvm.org/docs/SourceLevelDebugging.html">Source Level Debugging with LLVM</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;通过 8 章的教程，我们实现了一门支持函数和变量的编程语言。那么，如果代码运行或编译出错时，我们该如何调试程序呢？&lt;/p&gt;
&lt;p&gt;本质上，源</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="DWARF" scheme="http://chuquan.me/tags/DWARF/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(8)——目标文件编译</title>
    <link href="http://chuquan.me/2022/09/11/compiler-for-kaleidoscope-08/"/>
    <id>http://chuquan.me/2022/09/11/compiler-for-kaleidoscope-08/</id>
    <published>2022-09-11T15:06:31.000Z</published>
    <updated>2023-01-14T03:13:23.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本章，我们将使用自制的编译器将 Kaleidoscope 代码编译成目标文件，并结合 C++ 代码进行混编。</p><h1 id="目标选择"><a href="#目标选择" class="headerlink" title="目标选择"></a>目标选择</h1><p>LLVM 支持交叉编译，因此可以将源代码编译成任意目标架构的可执行文件。本章，我们将本机架构作为目标架构，编译可执行文件。</p><p>那么，如何获取本机架构的信息呢？我们使用一个字符串来表示，也称为 <strong>Target Triple</strong>，其采用 <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code> 格式来表示目标架构的基本信息。详细信息可见 <a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Cross-Compilation using Clang</a>。</p><p>如下所示，我们可以通过 clang 的相关命令获取本机的 target triple。对于不同的目标架构和操作系统，target triple 的值也不同。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang --version | grep Target</span><br><span class="line">Target: x86_64-apple-darwin21.6.0</span><br></pre></td></tr></table></figure><p>在实际开发中，我们不需要为本机架构硬编码 target triple。LLVM 提供了 <code>sys::getDefaultTargetTriple</code> 以支持动态获取本机的 target triple。</p><!--LLVM 不要求我们链接所有目标功能。比如，如果我们只使用 JIT，我们就不需要汇编打印功能。同样，如果我们只针对某些架构，我们只能链接这些架构的功能。--><p>在我们的编译器实现中，首先注册所有平台的目标信息，从而支持用户指定任意目标进行编译，具体如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">InitializeAllTargetInfos</span>();</span><br><span class="line"><span class="built_in">InitializeAllTargets</span>();</span><br><span class="line"><span class="built_in">InitializeAllTargetMCs</span>();</span><br><span class="line"><span class="built_in">InitializeAllAsmParsers</span>();</span><br><span class="line"><span class="built_in">InitializeAllAsmPrinters</span>();</span><br></pre></td></tr></table></figure><p>当所有平台的目标信息注册完成后，我们获取本机的目标进行，并设置模块的目标为本机目标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> TargetTriple = sys::<span class="built_in">getDefaultTargetTriple</span>();</span><br><span class="line">TheModule-&gt;<span class="built_in">setTargetTriple</span>(TargetTriple);</span><br></pre></td></tr></table></figure><p>然后，我们基于本机目标的 target triple 来获取一个 <code>Target</code>，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::string Error;</span><br><span class="line"><span class="keyword">auto</span> Target = TargetRegistry::<span class="built_in">lookupTarget</span>(TargetTriple, Error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print an error and exit if we couldn&#x27;t find the requested target.</span></span><br><span class="line"><span class="comment">// This generally occurs if we&#x27;ve forgotten to initialise the</span></span><br><span class="line"><span class="comment">// TargetRegistry or we have a bogus target triple.</span></span><br><span class="line"><span class="keyword">if</span> (!Target) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; Error;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目标机器"><a href="#目标机器" class="headerlink" title="目标机器"></a>目标机器</h1><p>除了 target triple，我们还需要更加完整的目标机器的信息。对此，LLVM 提供了一个 <code>TargetMachine</code> 的类，用于描述目标机器的完整信息。如果我们希望指定一个特定特性（如：SSE）或特定 CPU（如：Intel 的 Sandylake），我们就可以基于 <code>TargetMachine</code> 进行配置。</p><p>为了查看 LLVM 支持的所有的特性和 CPU，我们可以通过 <code>llc</code> 命令进行查看。比如，我们可以查看 x86 相关的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ llc -march=x86 -mattr=<span class="built_in">help</span></span><br><span class="line">Available CPUs <span class="keyword">for</span> this target:</span><br><span class="line"></span><br><span class="line">  alderlake      - Select the alderlake processor.</span><br><span class="line">  amdfam10       - Select the amdfam10 processor.</span><br><span class="line">  athlon         - Select the athlon processor.</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">Available features <span class="keyword">for</span> this target:</span><br><span class="line"></span><br><span class="line">  16bit-mode                      - 16-bit mode (i8086).</span><br><span class="line">  32bit-mode                      - 32-bit mode (80386).</span><br><span class="line">  3dnow                           - Enable 3DNow! instructions.</span><br><span class="line">  3dnowa                          - Enable 3DNow! Athlon instructions.</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在我们的编译器实现中，我们使用通用的 CPU，并且不包含任何额外的特性、选项或重定位模型，具体的设置如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> CPU = <span class="string">&quot;generic&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> Features = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">TargetOptions opt;</span><br><span class="line"><span class="keyword">auto</span> RM = <span class="built_in">Optional</span>&lt;Reloc::Model&gt;();</span><br><span class="line"><span class="keyword">auto</span> TheTargetMachine = Target-&gt;<span class="built_in">createTargetMachine</span>(TargetTriple, CPU, Features, opt, RM);</span><br></pre></td></tr></table></figure><h1 id="模块配置"><a href="#模块配置" class="headerlink" title="模块配置"></a>模块配置</h1><p>下面，我们来对模块进行配置，指定目标和数据布局。虽然模块配置不是必须的，但是官方教程推荐进行配置。配置模块，指定目标和数据布局，有利于后续进行优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TheModule-&gt;<span class="built_in">setDataLayout</span>(TargetMachine-&gt;<span class="built_in">createDataLayout</span>());</span><br><span class="line">TheModule-&gt;<span class="built_in">setTargetTriple</span>(TargetTriple);</span><br></pre></td></tr></table></figure><h1 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h1><p>至此，我们已经完成了代码生成的前期准备和设置。下面，我们来定义输出文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Filename = <span class="string">&quot;output.o&quot;</span>;</span><br><span class="line">std::error_code EC;</span><br><span class="line"><span class="function">raw_fd_ostream <span class="title">dest</span><span class="params">(Filename, EC, sys::fs::OF_None)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EC) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Could not open file: &quot;</span> &lt;&lt; EC.<span class="built_in">message</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们定义了一个通道用于进行代码生成，并最终调用执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">legacy::PassManager pass;</span><br><span class="line"><span class="keyword">auto</span> FileType = CGFT_ObjectFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TheTargetMachine-&gt;<span class="built_in">addPassesToEmitFile</span>(pass, dest, <span class="literal">nullptr</span>, FileType)) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;TheTargetMachine can&#x27;t emit a file of this type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pass.<span class="built_in">run</span>(*TheModule);</span><br><span class="line">dest.<span class="built_in">flush</span>();</span><br></pre></td></tr></table></figure><h1 id="混合编译"><a href="#混合编译" class="headerlink" title="混合编译"></a>混合编译</h1><p>下面，我们来编译代码，生成编译器，并进行测试。我们输入基于 Kaleidoscope 编写的 <code>average</code> 函数，并输入 <code>Ctr-D</code> 退出执行。此时编译器编译生成一个 <code>output.o</code> 文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./Kaleidoscope-Ch8</span><br><span class="line">ready&gt; def average(x y) (x + y) * 0.5;</span><br><span class="line">^D</span><br><span class="line">Wrote output.o</span><br></pre></td></tr></table></figure><p>至此，我们生成了一个基于 Kaleidoscope 编写的 <code>average</code> 函数的 <code>output.o</code> 目标文件。接下来，我们使用 C++ 编写一个简单的程序 <code>main.cpp</code>，并调用 Kaleidoscope 编写的 <code>average</code> 函数。C++ 程序如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;average of 3.0 and 4.0: &quot;</span> &lt;&lt; <span class="built_in">average</span>(<span class="number">3.0</span>, <span class="number">4.0</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们编译 <code>main.cpp</code> 文件，链接 <code>output.o</code> 文件，并运行最终的可执行文件。如下所示，最终的可执行文件 <code>main</code> 的执行结果与我们的预期是一致的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ main.cpp output.o -o main</span><br><span class="line">$ ./main</span><br><span class="line">average of 3.0 and 4.0: 3.5</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章，我们为本机架构配置目标信息，并基于此构建 Kaleidoscope 编译器。我们通过该编译器，对一段 Kaleidoscope 代码进行编译，生成了一个目标文件。最终，对一段 C++ 代码进行编译，链接 Kaleidoscope 目标文件，实现混合编译。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple">Cross-Compilation using Clang</a></li><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl08.html">Kaleidoscope: Compiling to Object Code</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本章，我们将使用自制的编译器将 Kaleidoscope 代码编译成目标文件，并结合 C++ 代码进行混编。&lt;/p&gt;
&lt;h1 id=&quot;目标选</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="clang" scheme="http://chuquan.me/tags/clang/"/>
    
    <category term="混编" scheme="http://chuquan.me/tags/%E6%B7%B7%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(7)——语言扩展：可变变量</title>
    <link href="http://chuquan.me/2022/09/04/compiler-for-kaleidoscope-07/"/>
    <id>http://chuquan.me/2022/09/04/compiler-for-kaleidoscope-07/</id>
    <published>2022-09-04T15:03:40.000Z</published>
    <updated>2023-01-14T03:13:14.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过第 1 章至第 6 章，我们实现了一门简单的函数式编程语言。在这个过程中，我们学习了解析器相关的技术，如何构建并表示 AST，如何构建 LLVM IR，如何对生成代码进行优化，如何使用 JIT 进行编译等等。</p><p>Kaleidoscope 是一门函数式编程语言，函数式的特点之一是变量不可重复赋值，这使得 LLVM IR 代码生成非常容易。特别是，函数式编程语言能够直接以 SSA 形式构建 LLVM IR。由于 LLVM 要求输入代码使用 SSA 形式，虽然这是一个非常好的特性，但是会让新手不知道如何为命令式编程语言中的可变变量生成代码。</p><h1 id="可变变量的实现难点"><a href="#可变变量的实现难点" class="headerlink" title="可变变量的实现难点"></a>可变变量的实现难点</h1><p>那么，为什么可变变量难以构建 SSA 呢？下面，我们先来看一个例子，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> G, H;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(_Bool Condition)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> X;</span><br><span class="line">  <span class="keyword">if</span> (Condition)</span><br><span class="line">    X = G;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    X = H;</span><br><span class="line">  <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例子中，我们有一个 <code>X</code> 变量，其值取决于程序的执行路径。由于这里有两个潜在的目标值，我们需要插入一个 phi 节点来合并这两个值。因此，我们希望生成的 LLVM IR 如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@G = weak global i32 <span class="number">0</span>   ; type of @G is i32*</span><br><span class="line">@H = weak global i32 <span class="number">0</span>   ; type of @H is i32*</span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">test</span>(i1 %Condition) &#123;</span><br><span class="line">entry:</span><br><span class="line">  br i1 %Condition, label %cond_true, label %cond_false</span><br><span class="line"></span><br><span class="line">cond_true:</span><br><span class="line">  %X<span class="number">.0</span> = load i32, i32* @G</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_false:</span><br><span class="line">  %X<span class="number">.1</span> = load i32, i32* @H</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_next:</span><br><span class="line">  %X<span class="number">.2</span> = phi i32 [ %X<span class="number">.1</span>, %cond_false ], [ %X<span class="number">.0</span>, %cond_true ]</span><br><span class="line">  ret i32 %X<span class="number">.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成的 LLVM IR 通过 <code>load</code> 指令显式地加载全局变量 <code>G</code> 和 <code>H</code>，分别用于 <code>if</code> 语句的 <code>then/else</code> 分支逻辑 <code>cond_true</code> 和 <code>cond_false</code> 基本块。为了将传入值进行合并，<code>cond_next</code> 基本块中的 phi 节点 <code>X.2</code> 根据控制流选择正确值。如果控制流来自 <code>cond_false</code> 基本块，则 <code>X.2</code> 使用 <code>X.1</code> 的值；如果控制流来自 <code>cond_true</code> 基本块，则 <code>X.2</code> 使用 <code>X.0</code> 的值。</p><p>这里的问题在于：<strong>当对可变变量进行赋值时，由谁来负责插入 phi 节点</strong>？</p><p>事实上，通过编译前端创建并插入 phi 节点是一个非常复杂且低效的操作。相对而言，通过编译前端实现控制流的 phi 节点还算简单。</p><h1 id="LLVM-内存模型"><a href="#LLVM-内存模型" class="headerlink" title="LLVM 内存模型"></a>LLVM 内存模型</h1><p>那么，我们该如何实现可变变量呢？事实上，我们可以借助内存模型原理来解决这个问题。</p><p>我们知道，LLVM 要求所有的寄存器值必须采用 SSA 形式，但是 LLVM 并不要求内存对象必须采用 SSA 形式。</p><p>基于此，我们可以为函数中的每个可变对象创建一个栈变量（它存在于内存中，因为它在栈上）。为了理解这种方法，我们首先介绍一下 LLVM 如何是表示栈变量的。</p><p>在 LLVM 中，所有内存访问都是显式的，使用 <code>load</code> &#x2F; <code>store</code> 指令，没有（或不需要）<code>address-of</code> 运算符。注意，<code>@G</code> &#x2F; <code>@H</code> 全局变量的类型实际上是 <code>i32*</code>，即使该变量被定义为 <code>i32</code>。 这意味着 <code>@G</code> 为全局数据区域中的 <code>i32</code> 定义了内存空间，但它的名称实际上是指该内存空间的地址。 <strong>栈变量的工作方式类似，只是它们并不使用全局变量进行声明，而使用 <code>alloca</code> 指令进行声明</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">example</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %X = alloca i32           ; type of %X is i32*.</span><br><span class="line">  ...</span><br><span class="line">  %tmp = load i32, i32* %X  ; load the stack value %X from the stack.</span><br><span class="line">  %tmp2 = add i32 %tmp, <span class="number">1</span>   ; increment it</span><br><span class="line">  store i32 %tmp2, i32* %X  ; store it back</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>上述代码展示了如何在 LLVM IR 中声明和操作栈变量。使用 <code>alloca</code> 指令分配的栈内存是完全通用的，我们可以将栈槽的地址传递给函数，也可以将其存储在其他变量中。下面，我们通过 <code>alloca</code> 指令来代替使用 phi 节点，具体如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@G = weak global i32 <span class="number">0</span>   ; type of @G is i32*</span><br><span class="line">@H = weak global i32 <span class="number">0</span>   ; type of @H is i32*</span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">test</span>(i1 %Condition) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %X = alloca i32           ; type of %X is i32*.</span><br><span class="line">  br i1 %Condition, label %cond_true, label %cond_false</span><br><span class="line"></span><br><span class="line">cond_true:</span><br><span class="line">  %X<span class="number">.0</span> = load i32, i32* @G</span><br><span class="line">  store i32 %X<span class="number">.0</span>, i32* %X   ; Update X</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_false:</span><br><span class="line">  %X<span class="number">.1</span> = load i32, i32* @H</span><br><span class="line">  store i32 %X<span class="number">.1</span>, i32* %X   ; Update X</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_next:</span><br><span class="line">  %X<span class="number">.2</span> = load i32, i32* %X  ; Read X</span><br><span class="line">  ret i32 %X<span class="number">.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过基于栈变量的方式，我们无需创建 phi 节点也能够处理任意可变变量，具体包含以下几个点。</p><ul><li><strong>将可变变量转换成栈变量</strong></li><li><strong>将读取可变变量转换成加载栈变量</strong></li><li><strong>将更新可变变量转换成存储栈变量</strong></li><li><strong>将读取可变变量地址转换成读取栈变量地址</strong></li></ul><p><strong>简而言之，我们通过一个额外的栈变量来存储不同分支所计算得到值，从而避免手动构建 phi 节点。</strong></p><p>虽然基于栈变量的方法解决了我们当前的问题，但是它引入了另一个问题。很显然，这种情况下，对于非常简单和常见的操作，我们也会引入了大量的栈操作，从而引发性能问题。幸运的是，LLVM 优化器有一个名为 <code>mem2reg</code> 的优化通道能够对此进行优化，该优化通道能将类似的栈分配提优化为寄存器，并在适当的时候插入 phi 节点。例如，我们通过执行 <code>mem2reg</code> Pass，可以得到如下所示的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ llvm-as &lt; example.ll | opt -mem2reg | llvm-dis</span><br><span class="line">@G = weak global i32 <span class="number">0</span></span><br><span class="line">@H = weak global i32 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">test</span>(i1 %Condition) &#123;</span><br><span class="line">entry:</span><br><span class="line">  br i1 %Condition, label %cond_true, label %cond_false</span><br><span class="line"></span><br><span class="line">cond_true:</span><br><span class="line">  %X<span class="number">.0</span> = load i32, i32* @G</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_false:</span><br><span class="line">  %X<span class="number">.1</span> = load i32, i32* @H</span><br><span class="line">  br label %cond_next</span><br><span class="line"></span><br><span class="line">cond_next:</span><br><span class="line">  %X<span class="number">.01</span> = phi i32 [ %X<span class="number">.1</span>, %cond_false ], [ %X<span class="number">.0</span>, %cond_true ]</span><br><span class="line">  ret i32 %X<span class="number">.01</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-29.png?x-oss-process=image/resize,w_800"></p><p><code>mem2reg</code> Pass 实现了用于构造 SSA 的标准 <strong>迭代支配边界</strong>（Iterated Dominance Frontier）算法，并包含大量优化手段。<code>mem2reg</code> 优化通道可以用来处理可变变量，我们强烈建议使用它。注意，<code>mem2reg</code> 仅在某些情况下适用于可变变量：</p><ul><li><code>mem2reg</code> 是 <code>alloca</code> 驱动的，其查找 <code>alloca</code> 指令，如果可以处理，则对它们进行优化。它不适用于全局变量或堆分配。</li><li><code>mem2reg</code> 仅在函数的入口块中查找 <code>alloca</code> 指令。在入口块即保证了 <code>alloca</code> 只会执行一次，这样能够使分析更加简单。</li><li><code>mem2reg</code> 只优化用于直接加载和存储的 <code>alloca</code> 指令。如果将栈对象的地址传递给函数，或者涉及任何指针运算，则不会优化 <code>alloca</code>。</li><li><code>mem2reg</code> 仅适用于一等类型的值的分配（例如指针、标量和向量），并且仅当分配的数组大小为 1（或 .ll 文件丢失）时。 <code>mem2reg</code> 不能将结构体或数组优化为寄存器。 注意，LLVM 还有其他更加强大的优化通道，如：<code>sroa</code> Pass，其能够在很多情况下可以优化结构体、联合体、数组。</li></ul><p>我们强烈建议使用上述方式来构建 SSA，通过额外的栈变量避免手动构建 phi 节点，然后使用 LLVM 优化通道进行优化，内部自动构建 phi 节点，如：<code>mem2reg</code> Pass。推荐使用这种方式主要有几个原因：</p><ul><li>具备良好的验证和测试。经典的 Clang 编译器就采用该方法来处理局部可变变量。</li><li>构建速度快。<code>mem2reg</code> 支持在多种场景下进行加速构建。</li><li>支持生成调试所需信息。LLVM 中的调试信息依赖于公开变量的地址，基于变量地址才能将调试信息附加至变量中。这种技术与这种调试信息风格非常自然地吻合。</li></ul><p>这种方式能够让我们的编译前端的启动和运行变得更加容易，并且实现起来非常简单。下面，让我们在 Kaleidoscope 中扩展可变变量！</p><h1 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h1><p>上文，我们介绍了可变变量的实现难点，以及一种基于栈变量的解决方案。接下来，我们来进行实战，为 Kaleidoscope 进行语言扩展，支持可变变量。</p><p>为了支持可变变量，我们期望实现两个功能：</p><ul><li><strong>基于 <code>=</code> 运算符实现已有变量可变</strong></li><li><strong>基于 <code>var/in</code> 关键词实现局部变量定义</strong></li></ul><p>如下所示，是我们期望实现的最终目标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Define <span class="string">&#x27;:&#x27;</span> <span class="keyword">for</span> sequencing: as a low-precedence <span class="keyword">operator</span> that ignores operands</span><br><span class="line"><span class="meta"># and just returns the RHS.</span></span><br><span class="line">def binary : <span class="number">1</span> (x y) y;</span><br><span class="line"></span><br><span class="line"># Recursive fib, we could <span class="keyword">do</span> <span class="keyword">this</span> before.</span><br><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(x &lt; <span class="number">3</span>)</span> then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"># Iterative fib.</span><br><span class="line"><span class="function">def <span class="title">fibi</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  var a </span>= <span class="number">1</span>, b = <span class="number">1</span>, c <span class="built_in">in</span></span><br><span class="line">  (<span class="keyword">for</span> i = <span class="number">3</span>, i &lt; x in</span><br><span class="line">     c = a + b :</span><br><span class="line">     a = b :</span><br><span class="line">     b = c) :</span><br><span class="line">  b;</span><br><span class="line"></span><br><span class="line"># Call it.</span><br><span class="line"><span class="built_in">fibi</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="已有变量可变"><a href="#已有变量可变" class="headerlink" title="已有变量可变"></a>已有变量可变</h1><p>首先，我们来实现第一个功能——已有变量可变。</p><p>在我们之前的实现中，Kaleidoscope 在代码生成时的符号表是由 <code>NamedValues</code> 负责管理。符号表存储的键值对，键位变量名，值为 LLVM <code>Value*</code>。</p><p>为了实现已有变量可变，我们需要修改一下 <code>NamedValues</code> 存储的键值对的类型，使得 <code>NamedValues</code> 能够保存可变变量的内存位置。</p><p>目前，Kaleidoscope 只支持两种类型的变量：函数的传入参数、<code>for</code> 循环的归纳变量。为了保持一致性，除了其他用户定义的变量外，我们还允许对这些变量进行更新。 这意味着它们都需要占用内存空间。</p><p>对此，我们首先对符号表 <code>NamedValues</code> 进行修改，将键值对中值的类型修改为 <code>AllocaInst*</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::map&lt;std::string, AllocaInst*&gt; NamedValues;</span><br></pre></td></tr></table></figure><p>由于我们需要创建 <code>alloca</code> 指令，我们还需要一个辅助函数来保证 <code>alloca</code> 指令在函数入口块创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of</span></span><br><span class="line"><span class="comment">/// the function.  This is used for mutable variables etc.</span></span><br><span class="line"><span class="function"><span class="type">static</span> AllocaInst *<span class="title">CreateEntryBlockAlloca</span><span class="params">(Function *TheFunction,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::string &amp;VarName)</span> </span>&#123;</span><br><span class="line">  IRBuilder&lt;&gt; <span class="built_in">TmpB</span>(&amp;TheFunction-&gt;<span class="built_in">getEntryBlock</span>(),</span><br><span class="line">                 TheFunction-&gt;<span class="built_in">getEntryBlock</span>().<span class="built_in">begin</span>());</span><br><span class="line">  <span class="keyword">return</span> TmpB.<span class="built_in">CreateAlloca</span>(Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="number">0</span>,</span><br><span class="line">                           VarName.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个 <code>IRBuilder</code> 对象，它指向入口块的第一条指令（<code>.begin()</code>）。然后创建一个具有指定名称的 <code>alloca</code> 并返回。由于 Kaleidoscope 中的所有值都是双精度类型，所以不需要传入要使用的类型。</p><p>接下来，我们分别对变量表达式、<code>for</code> 表达式、函数表达式的代码生成逻辑进行修改，从而支持已有变量可变。</p><h2 id="VariableExprAST-代码生成"><a href="#VariableExprAST-代码生成" class="headerlink" title="VariableExprAST 代码生成"></a>VariableExprAST 代码生成</h2><p>首先，对于变量，我们需要修改引用方式。基于栈变量的实现中，变量存储于栈中，因此，我们必须通过加载栈槽，从而引用栈变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VariableExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  AllocaInst *A = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!A)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the value.</span></span><br><span class="line">  <span class="keyword">return</span> Builder-&gt;<span class="built_in">CreateLoad</span>(A-&gt;<span class="built_in">getAllocatedType</span>(), A, Name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForExprAST-代码生成"><a href="#ForExprAST-代码生成" class="headerlink" title="ForExprAST 代码生成"></a>ForExprAST 代码生成</h2><p><code>VariableExprAST</code> 实现了栈变量的读取逻辑，那么如何实现写入逻辑呢？由于 <code>for</code> 表达式包含了归纳变量，因此，我们首先了修改 <code>ForExprAST</code> 的代码生成逻辑。</p><p>如下所示，首先，我们在入口块创建一个栈变量，当设置初始值时，通过 <code>Builder</code> 的 <code>CreateStore()</code> 方法将初始值写入栈变量。当归纳变量迭代时，通过 <code>Builder</code> 的 <code>CreateLoad()</code> 方法读取栈变量，并与步长值相加，然后再写入栈变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">ForExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Function *TheFunction = Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an alloca for the variable in the entry block.</span></span><br><span class="line">  AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Emit the start code first, without &#x27;variable&#x27; in scope.</span></span><br><span class="line">  Value *StartVal = Start-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!StartVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Store the value into the alloca.</span></span><br><span class="line">  Builder-&gt;<span class="built_in">CreateStore</span>(StartVal, Alloca);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Compute the end condition.</span></span><br><span class="line">  Value *EndCond = End-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!EndCond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reload, increment, and restore the alloca.  This handles the case where</span></span><br><span class="line">  <span class="comment">// the body of the loop mutates the variable.</span></span><br><span class="line">  Value *CurVar =</span><br><span class="line">      Builder-&gt;<span class="built_in">CreateLoad</span>(Alloca-&gt;<span class="built_in">getAllocatedType</span>(), Alloca, VarName.<span class="built_in">c_str</span>());</span><br><span class="line">  Value *NextVar = Builder-&gt;<span class="built_in">CreateFAdd</span>(CurVar, StepVal, <span class="string">&quot;nextvar&quot;</span>);</span><br><span class="line">  Builder-&gt;<span class="built_in">CreateStore</span>(NextVar, Alloca);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FunctionAST-代码生成"><a href="#FunctionAST-代码生成" class="headerlink" title="FunctionAST 代码生成"></a>FunctionAST 代码生成</h2><p>为了让函数的入参支持可变，我们还需要对 <code>FunctionAST</code> 的代码逻辑进行修改。如下所示，我们遍历函数的入参，为每一个参数创建一个栈变量，并存储初始值，同时将入参的变量名写入符号表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">  NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>()) &#123;</span><br><span class="line">    <span class="comment">// Create an alloca for this variable.</span></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, Arg.<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the initial value into the alloca.</span></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(&amp;Arg, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add arguments to variable symbol table.</span></span><br><span class="line">    NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化通道"><a href="#优化通道" class="headerlink" title="优化通道"></a>优化通道</h2><p>最后，我们向通道管理器注册一部分优化通道，包括 <code>mem2reg</code>，从而能够生成优化后的 LLVM IR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promote allocas to registers.</span></span><br><span class="line">TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createPromoteMemoryToRegisterPass</span>());</span><br><span class="line"><span class="comment">// Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class="line">TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createInstructionCombiningPass</span>());</span><br><span class="line"><span class="comment">// Reassociate expressions.</span></span><br><span class="line">TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createReassociatePass</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="LLVM-IR-对比"><a href="#LLVM-IR-对比" class="headerlink" title="LLVM IR 对比"></a>LLVM IR 对比</h2><p>我们以递归版本的 <code>fib</code> 函数作为测试用例，来对比 <code>mem2reg</code> 优化通道执行前后的 LLVM IR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(x &lt; <span class="number">3</span>)</span> then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如下所示，为执行 <code>mem2reg</code> 前生成的 LLVM IR。其中，只有一个函数入参变量 <code>x</code>。在入口块中，LLVM 创建了一个 <code>alloca</code> 指令，并将初始输入值存入其中。 对变量的每个引用都会从栈中进行加载。由于我们没有修改 <code>if/then/else</code> 表达式，所以在 <code>ifcont</code> 基本块中仍然插入了一个 <code>phi</code> 节点。对于 <code>if/then/else</code> 表达式，其实我们也可以为它创建 <code>alloca</code> 指令，不过，为它构建一个 <code>phi</code> 节点反而会更容易，所以这里我们仍然手动构建 <code>phi</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">define <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %x1 = alloca <span class="type">double</span></span><br><span class="line">  store <span class="type">double</span> %x, <span class="type">double</span>* %x1</span><br><span class="line">  %x2 = load <span class="type">double</span>, <span class="type">double</span>* %x1</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %x2, <span class="number">3.000000e+00</span></span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %ifcond = fcmp one <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:       ; preds = %entry</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:       ; preds = %entry</span><br><span class="line">  %x3 = load <span class="type">double</span>, <span class="type">double</span>* %x1</span><br><span class="line">  %subtmp = fsub <span class="type">double</span> %x3, <span class="number">1.000000e+00</span></span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp)</span><br><span class="line">  %x4 = load <span class="type">double</span>, <span class="type">double</span>* %x1</span><br><span class="line">  %subtmp5 = fsub <span class="type">double</span> %x4, <span class="number">2.000000e+00</span></span><br><span class="line">  %calltmp6 = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp5)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp6</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line">ifcont:     ; preds = %<span class="keyword">else</span>, %then</span><br><span class="line">  %iftmp = phi <span class="type">double</span> [ <span class="number">1.000000e+00</span>, %then ], [ %addtmp, %<span class="keyword">else</span> ]</span><br><span class="line">  ret <span class="type">double</span> %iftmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，为执行 <code>mem2reg</code> 后生成的 LLVM IR。很明显，<code>mem2reg</code> 对大量的 <code>alloc</code> 和 <code>store</code> 指令进行了优化，将它们优化成寄存器操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">define <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %x, <span class="number">3.000000e+00</span></span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %ifcond = fcmp one <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  %subtmp = fsub <span class="type">double</span> %x, <span class="number">1.000000e+00</span></span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp)</span><br><span class="line">  %subtmp5 = fsub <span class="type">double</span> %x, <span class="number">2.000000e+00</span></span><br><span class="line">  %calltmp6 = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp5)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp6</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line">ifcont:     ; preds = %<span class="keyword">else</span>, %then</span><br><span class="line">  %iftmp = phi <span class="type">double</span> [ <span class="number">1.000000e+00</span>, %then ], [ %addtmp, %<span class="keyword">else</span> ]</span><br><span class="line">  ret <span class="type">double</span> %iftmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，为所有优化通道执行完毕之后的 LLVM IR。很显然，LLVM IR 得到了进一步的优化。其中，<code>simplifycfg</code> 优化通道将返回指令拷贝至 <code>else</code> 基本块的末尾，从而消除部分分支代码和 <code>phi</code> 节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">define <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %x, <span class="number">3.000000e+00</span></span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %ifcond = fcmp ueq <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %<span class="keyword">else</span>, label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  %subtmp = fsub <span class="type">double</span> %x, <span class="number">1.000000e+00</span></span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp)</span><br><span class="line">  %subtmp5 = fsub <span class="type">double</span> %x, <span class="number">2.000000e+00</span></span><br><span class="line">  %calltmp6 = call <span class="type">double</span> @<span class="built_in">fib</span>(<span class="type">double</span> %subtmp5)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp6</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line"></span><br><span class="line">ifcont:</span><br><span class="line">  ret <span class="type">double</span> <span class="number">1.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>至此，我们已经将符号表的引用修改为栈变量。接下来，我们来添加赋值运算符 <code>=</code>，从而实现变量可变。</p><p>基于当前的框架，添加一个新的赋值运算符非常简单。首先，我们对赋值运算符设置优先级。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;=&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>由于赋值运算符是一个二元运算符，且赋值运算符已经设置了运算符优先级。因此，我们只需要修改 <code>BinaryExprAST</code> 的代码生成逻辑，使其支持赋值运算符。具体如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Special case &#x27;=&#x27; because we don&#x27;t want to emit the LHS as an expression.</span></span><br><span class="line">  <span class="keyword">if</span> (Op == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Assignment requires the LHS to be an identifier.</span></span><br><span class="line">    <span class="comment">// This assume we&#x27;re building without RTTI because LLVM builds that way by</span></span><br><span class="line">    <span class="comment">// default.  If you build LLVM with RTTI this can be changed to a</span></span><br><span class="line">    <span class="comment">// dynamic_cast for automatic error checking.</span></span><br><span class="line">    VariableExprAST *LHSE = <span class="built_in">static_cast</span>&lt;VariableExprAST *&gt;(LHS.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">if</span> (!LHSE)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;destination of &#x27;=&#x27; must be a variable&quot;</span>);</span><br><span class="line">    <span class="comment">// Codegen the RHS.</span></span><br><span class="line">    Value *Val = RHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Val)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look up the name.</span></span><br><span class="line">    Value *Variable = NamedValues[LHSE-&gt;<span class="built_in">getName</span>()];</span><br><span class="line">    <span class="keyword">if</span> (!Variable)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(Val, Variable);</span><br><span class="line">    <span class="keyword">return</span> Val;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其他二元运算符不同，赋值运算符不遵循 “<strong>生成 LHS，生成 RHS，再进行计算</strong>” 的模型。因此，对于赋值运算符，我们要对它进行特殊处理。此外，赋值运算符要求 LHS 必须是一个变量，比如：<code>(x+1) = expr</code> 语句是无效的，<code>x = expr</code> 是有效的。</p><p>因此，<code>BinaryExprAST::codegen</code> 的解析逻辑中，会先检查 LHS 是否有效。如果有效，则将 LHS 注册至符号表并进一步计算 RHS，最终将 RHS 的结果存入变量。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>至此，我们为 Kaleidoscope 扩展支持了变量可变的能力。下面，我们来进行一个简单的测试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Function to print a <span class="type">double</span>.</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">printd</span><span class="params">(x)</span></span>;</span><br><span class="line"></span><br><span class="line"># Define <span class="string">&#x27;:&#x27;</span> <span class="keyword">for</span> sequencing: as a low-precedence <span class="keyword">operator</span> that ignores operands</span><br><span class="line"><span class="meta"># and just returns the RHS.</span></span><br><span class="line">def binary : <span class="number">1</span> (x y) y;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="title">printd</span><span class="params">(x)</span> :</span></span><br><span class="line"><span class="function">  x =</span> <span class="number">4</span> :</span><br><span class="line">  <span class="built_in">printd</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>当输入测试代码后，程序先打印了 <code>123</code>，然后打印了 <code>4</code>，运行结果证明了变量的值发生了变化！</p><h1 id="局部变量定义"><a href="#局部变量定义" class="headerlink" title="局部变量定义"></a>局部变量定义</h1><p>我们的第二个目标功能是：基于 <code>var/in</code> 关键词实现局部变量定义，使其能够编写如下所示的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fibi</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  var a </span>= <span class="number">1</span>, b = <span class="number">1</span>, c <span class="built_in">in</span></span><br><span class="line">  (<span class="keyword">for</span> i = <span class="number">3</span>, i &lt; x in</span><br><span class="line">     c = a + b :</span><br><span class="line">     a = b :</span><br><span class="line">     b = c) :</span><br><span class="line">  b;</span><br></pre></td></tr></table></figure><p>下面，我们分别对编译器的各个部分进行扩展。</p><h2 id="词法分析器扩展"><a href="#词法分析器扩展" class="headerlink" title="词法分析器扩展"></a>词法分析器扩展</h2><p>首先，我们要为 Kaleidoscope 扩展关键词 <code>var</code> 和 <code>in</code>。这里，我们只需要新增 <code>var</code> 关键词即可，<code>in</code> 关键词在 <code>for/in</code> 语句中已经支持了。具体扩展如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// var definition</span></span><br><span class="line">  tok_var = <span class="number">-13</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="built_in">gettok</span>() &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;binary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;unary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;var&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_var;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="AST-扩展"><a href="#AST-扩展" class="headerlink" title="AST 扩展"></a>AST 扩展</h2><p>为了表示 <code>var/in</code> 语句，我们定义一个表达式子类的 AST 节点类型 <code>VarExprAST</code>，具体如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// VarExprAST - Expression class for var/in</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VarExprAST</span>(std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames,</span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Body)</span><br><span class="line">    : <span class="built_in">VarNames</span>(std::<span class="built_in">move</span>(VarNames)), <span class="built_in">Body</span>(std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-30.png?x-oss-process=image/resize,w_800"></p><p>我们扩展的 <code>var/in</code> 允许一次定义一组变量，并且每个变量都可以有一个初始值。因此，我们通过 <code>VarNames</code> 数组来存储多个变量。此外，<code>var/in</code> 支持设置一个表达式体，用于对变量进行初始化。同时，表达式体能够访问 <code>var/in</code> 所定义的变量。</p><h2 id="解析器扩展"><a href="#解析器扩展" class="headerlink" title="解析器扩展"></a>解析器扩展</h2><p>接下来，我们为 <code>var/in</code> 表达式定义解析函数，具体如下所示。在 <code>ParseVarExpr</code> 解析函数中，我们首先对 token 进行遍历，将局部变量存入 <code>VarNames</code> 中。然后解析表达式体，将其存入 <code>Body</code> 中。最后返回表达式的 AST 节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseVarExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat the var.</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At least one variable name is required.</span></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected identifier after var&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    std::string Name = IdentifierStr;</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the optional initializer.</span></span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; Init = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (CurTok == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">getNextToken</span>(); <span class="comment">// eat the &#x27;=&#x27;.</span></span><br><span class="line"></span><br><span class="line">      Init = <span class="built_in">ParseExpression</span>();</span><br><span class="line">      <span class="keyword">if</span> (!Init)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VarNames.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(Name, std::<span class="built_in">move</span>(Init)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of var list, exit loop.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// eat the &#x27;,&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected identifier list after var&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point, we have to have &#x27;in&#x27;.</span></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;in&#x27; keyword after &#x27;var&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat &#x27;in&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;VarExprAST&gt;(std::<span class="built_in">move</span>(VarNames), std::<span class="built_in">move</span>(Body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其他表达式相同，我们也把 <code>ParseForExpr</code> 解析函数方法插入到主表达式的解析函数 <code>ParsePrimary</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="comment">///   ::= ifexpr</span></span><br><span class="line"><span class="comment">///   ::= forexpr</span></span><br><span class="line"><span class="comment">///   ::= varexpr</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_for:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseForExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_var:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseVarExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>下面，我们来为 <code>VarExprAST</code> 实现代码生成的逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VarExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;AllocaInst *&gt; OldBindings;</span><br><span class="line"></span><br><span class="line">  Function *TheFunction = Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register all variables and emit their initializer.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, e = VarNames.<span class="built_in">size</span>(); i != e; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> std::string &amp;VarName = VarNames[i].first;</span><br><span class="line">    ExprAST *Init = VarNames[i].second.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit the initializer before adding the variable to scope, this prevents</span></span><br><span class="line">    <span class="comment">// the initializer from referencing the variable itself, and permits stuff</span></span><br><span class="line">    <span class="comment">// like this:</span></span><br><span class="line">    <span class="comment">//  var a = 1 in</span></span><br><span class="line">    <span class="comment">//    var a = a in ...   # refers to outer &#x27;a&#x27;.</span></span><br><span class="line">    Value *InitVal;</span><br><span class="line">    <span class="keyword">if</span> (Init) &#123;</span><br><span class="line">      InitVal = Init-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">      <span class="keyword">if</span> (!InitVal)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// If not specified, use 0.0.</span></span><br><span class="line">      InitVal = ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">0.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AllocaInst *Alloca = <span class="built_in">CreateEntryBlockAlloca</span>(TheFunction, VarName);</span><br><span class="line">    Builder-&gt;<span class="built_in">CreateStore</span>(InitVal, Alloca);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember the old variable binding so that we can restore the binding when</span></span><br><span class="line">    <span class="comment">// we unrecurse.</span></span><br><span class="line">    OldBindings.<span class="built_in">push_back</span>(NamedValues[VarName]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember this binding.</span></span><br><span class="line">    NamedValues[VarName] = Alloca;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Codegen the body, now that all vars are in scope.</span></span><br><span class="line">  Value *BodyVal = Body-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!BodyVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop all our variables from scope.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, e = VarNames.<span class="built_in">size</span>(); i != e; ++i)</span><br><span class="line">    NamedValues[VarNames[i].first] = OldBindings[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the body computation.</span></span><br><span class="line">  <span class="keyword">return</span> BodyVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VarExprAST</code> 代码生成的基本逻辑包括以下几部分：</p><ul><li>遍历所有变量，对于每个变量，将其存入符号表，并使用 <code>OldBindings</code> 保存旧值，因为存在嵌套的同名变量。</li><li>对于每个变量，构造对应的 <code>alloca</code> 指令，并更新符号表，使该变量指向生成的 <code>alloca</code> 指令，即 <code>AllocaInst</code>。</li><li>当所有变量都保存至符号表后，对 <code>var/in</code> 语句中的表达式体进行代码生成。</li><li>在返回之前，通过 <code>OldBindings</code> 恢复旧值。</li></ul><p>通过这部分的扩展，我们实现了在作用域中定义局部变量的功能。类似的，我们也可以对实现的程序进行测试，输入迭代版本的 <code>fib</code> 函数，查看最终的执行结果以及生成的 LLVM IR。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本章，我们进一步扩展了 Kaleidoscope 语言，实现了可变变量的能力。至此，Kaleidoscope 已经具备了工业级编程语言的基本雏形。下一章，我们来进一步增加 Kaleidoscope 的能力。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.html">Kaleidoscope: Extending the Language: Mutable Variables</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;通过第 1 章至第 6 章，我们实现了一门简单的函数式编程语言。在这个过程中，我们学习了解析器相关的技术，如何构建并表示 AST，如何构建 </summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="可变变量" scheme="http://chuquan.me/tags/%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(6)——语言扩展：自定义运算符</title>
    <link href="http://chuquan.me/2022/08/28/compiler-for-kaleidoscope-06/"/>
    <id>http://chuquan.me/2022/08/28/compiler-for-kaleidoscope-06/</id>
    <published>2022-08-28T15:02:58.000Z</published>
    <updated>2023-01-14T03:13:06.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目前为止，Kaleidoscope 已经是一门功能齐全且有用的编程语言了。但是，它仍然存在一个很大的问题。当前的 Kaleidoscope 缺少很多有用的运算符，比如：取反、比较等。</p><p>本章，我们将为 Kaleidoscope 支持自定义运算符，从而让 Kaleidoscope 具备更强大的编程能力。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>我们希望为 Kaleidoscope 支持的 <strong>运算符重载</strong>（Operator Overloading）能够比 C++ 等语言更加通用。在 C++ 中，我们只能够重新定义已存在的运算符，我们不能以编程方式修改其语法，也不能引入新的运算符、修改运算符优先级等。在本章中，我们将为 Kaleidoscope 支持这种更加强大的能力。</p><p>目前为止，我们通过手写的方式实现了一个递归下降的解析器，能够解析目前我们所定义的表达式，包括语法、运算符优先级等。通过运算符优先级解析，我们可以非常简单地引入新的运算符。</p><p>本文我们将扩展两种运算符：</p><ul><li><strong>一元运算符</strong>（Unary Operator）</li><li><strong>二元运算符</strong>（Binary Operator）</li></ul><p>如下所示，为 Kaleidoscope 中自定义一元运算符和二元运算符的示例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Logical unary <span class="keyword">not</span>.</span><br><span class="line">def unary!(v)</span><br><span class="line">  <span class="keyword">if</span> v then</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Define &gt; with the same precedence as &lt;.</span><br><span class="line">def binary&gt; <span class="number">10</span> (LHS RHS)</span><br><span class="line">  RHS &lt; LHS;</span><br><span class="line"></span><br><span class="line"># Binary <span class="string">&quot;logical or&quot;</span>, (note that it does <span class="keyword">not</span> <span class="string">&quot;short circuit&quot;</span>)</span><br><span class="line">def binary| <span class="number">5</span> (LHS RHS)</span><br><span class="line">  <span class="keyword">if</span> LHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> RHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># Define = with slightly lower precedence than relationals.</span><br><span class="line">def binary= <span class="number">9</span> (LHS RHS)</span><br><span class="line">  !(LHS &lt; RHS | LHS &gt; RHS);</span><br></pre></td></tr></table></figure><p>很多语言希望能够在语言本身中实现其标准运行时库。在本章中，我们会在 Kaleidoscope 中将自定义运算符在其标准库中实现。</p><h1 id="词法分析器扩展"><a href="#词法分析器扩展" class="headerlink" title="词法分析器扩展"></a>词法分析器扩展</h1><p>无论是一元运算符还是二元运算符，对于词法分析器而言，两者只不过是关键词不同，分别是：<code>unary</code> 和 <code>binary</code>。因此，我们为 <code>unary</code> 和 <code>binary</code> 分别定义对应的 token 类型和 token 值，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// operators</span></span><br><span class="line">  tok_binary = <span class="number">-11</span>,</span><br><span class="line">  tok_unary = <span class="number">-12</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;for&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_for;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_in;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;binary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_binary;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;unary&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_unary;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure><h1 id="运算符的定义解析"><a href="#运算符的定义解析" class="headerlink" title="运算符的定义解析"></a>运算符的定义解析</h1><p>从上述的目标可以看出，一元运算符和二元运算符均使用函数的方式进行定义。与普通函数定义不同的是，一元运算符和二元运算符的函数原型略有不同。因此，我们需要对 <code>PrototypeAST</code> 进行修改，从而支持解析两种类型的运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,</span></span><br><span class="line"><span class="comment">/// which captures its argument names as well as if it is an operator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrototypeAST</span> &#123;</span><br><span class="line">  std::string Name;</span><br><span class="line">  std::vector&lt;std::string&gt; Args;</span><br><span class="line">  <span class="type">bool</span> IsOperator;</span><br><span class="line">  <span class="type">unsigned</span> Precedence;  <span class="comment">// Precedence if a binary op.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrototypeAST</span>(<span class="type">const</span> std::string &amp;name, std::vector&lt;std::string&gt; Args,</span><br><span class="line">               <span class="type">bool</span> IsOperator = <span class="literal">false</span>, <span class="type">unsigned</span> Prec = <span class="number">0</span>)</span><br><span class="line">  : <span class="built_in">Name</span>(name), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)), <span class="built_in">IsOperator</span>(IsOperator),</span><br><span class="line">    <span class="built_in">Precedence</span>(Prec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Function *<span class="title">codegen</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string &amp;<span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isUnaryOp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.<span class="built_in">size</span>() == <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isBinaryOp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> IsOperator &amp;&amp; Args.<span class="built_in">size</span>() == <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">getOperatorName</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isUnaryOp</span>() || <span class="built_in">isBinaryOp</span>());</span><br><span class="line">    <span class="keyword">return</span> Name[Name.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="title">getBinaryPrecedence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Precedence; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-27.png?x-oss-process=image/resize,w_800"></p><p>我们在原始的 <code>PrototypeAST</code> 定义的基础上，新增两个属性用于表示普通的函数原型和自定义运算符。</p><ul><li><code>IsOperator</code> 表示是否是运算符。</li><li><code>Precedence</code> 表示运算符的优先级。优先级仅用于二元运算符。</li></ul><p>通过修改 <code>PrototypeAST</code>，使其支持识别一元运算符和二元运算符的定义后，我们来进一步实现具体的解析逻辑，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id &#x27;(&#x27; id* &#x27;)&#x27;</span></span><br><span class="line"><span class="comment">///   ::= binary LETTER number? (id, id)</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParsePrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string FnName;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> Kind = <span class="number">0</span>;  <span class="comment">// 0 = identifier, 1 = unary, 2 = binary.</span></span><br><span class="line">  <span class="type">unsigned</span> BinaryPrecedence = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected function name in prototype&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    FnName = IdentifierStr;</span><br><span class="line">    Kind = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> tok_unary:</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected unary operator&quot;</span>);</span><br><span class="line">    FnName = <span class="string">&quot;unary&quot;</span>;</span><br><span class="line">    FnName += (<span class="type">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> tok_binary:</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected binary operator&quot;</span>);</span><br><span class="line">    FnName = <span class="string">&quot;binary&quot;</span>;</span><br><span class="line">    FnName += (<span class="type">char</span>)CurTok;</span><br><span class="line">    Kind = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the precedence if present.</span></span><br><span class="line">    <span class="keyword">if</span> (CurTok == tok_number) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NumVal &lt; <span class="number">1</span> || NumVal &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Invalid precedence: must be 1..100&quot;</span>);</span><br><span class="line">      BinaryPrecedence = (<span class="type">unsigned</span>)NumVal;</span><br><span class="line">      <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getNextToken</span>() == tok_identifier)</span><br><span class="line">    ArgNames.<span class="built_in">push_back</span>(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;)&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify right number of names for operator.</span></span><br><span class="line">  <span class="keyword">if</span> (Kind &amp;&amp; ArgNames.<span class="built_in">size</span>() != Kind)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Invalid number of operands for operator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;PrototypeAST&gt;(FnName, std::<span class="built_in">move</span>(ArgNames), Kind != <span class="number">0</span>,</span><br><span class="line">                                         BinaryPrecedence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ParsePrototype</code> 的解析逻辑中，我们通过解析运算符得到 <code>FnName</code> 变量，将其作为自定义运算符的构建名称，比如：为 <code>@</code> 操作符构建 <code>binary@</code> 的名称。由于 LLVM 符号表中的符号允许包含任何字符，所以我们可以将构建名称（如：<code>binary@</code>）存入符号表。</p><p>这里，一元运算符和二元运算符的定义的解析逻辑非常相似，唯一的区别在于，二元运算符需要额外解析运算符优先级。</p><h1 id="运算符的表达式解析"><a href="#运算符的表达式解析" class="headerlink" title="运算符的表达式解析"></a>运算符的表达式解析</h1><p>上一节，我们介绍了如何解析运算符定义。本节，我们来介绍如何解析运算符表达式。</p><p>在第 2 章中，我们已经介绍了 Kaleidoscope 中定义的三种类型的 AST 结构，分别是：<strong>表达式</strong>、<strong>原型</strong>、<strong>函数</strong>。其中，我们已经定义了一种表达式子类型 <code>BinaryExprAST</code>，用于表示二元运算符表达式。因此，我们只需要额外定义一种新的表达式子类型 <code>UnaryExprAST</code> 表示一元运算符表达式即可。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-28.png?x-oss-process=image/resize,w_800"></p><p><code>UnaryExprAST</code> 的具体定义如下所示。其中，<code>Opcode</code> 表示运算符符号，<code>Operand</code> 表示运算符所作用的操作数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// UnaryExprAST - Expression class for a unary operator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnaryExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="type">char</span> Opcode;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UnaryExprAST</span>(<span class="type">char</span> Opcode, std::unique_ptr&lt;ExprAST&gt; Operand)</span><br><span class="line">    : <span class="built_in">Opcode</span>(Opcode), <span class="built_in">Operand</span>(std::<span class="built_in">move</span>(Operand)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，我们来分别看有一下二元运算符和一元运算符的代码生成实现逻辑。</p><h2 id="二元表达式代码生成"><a href="#二元表达式代码生成" class="headerlink" title="二元表达式代码生成"></a>二元表达式代码生成</h2><p>如下所示，为二元表达式实现代码生成的逻辑。我们仅仅是在原有的代码生成逻辑中进行了扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *L = LHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  Value *R = RHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFAdd</span>(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFSub</span>(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFMul</span>(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    L = Builder.<span class="built_in">CreateFCmpULT</span>(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateUIToFP</span>(L, Type::<span class="built_in">getDoubleTy</span>(TheContext),</span><br><span class="line">                                <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it wasn&#x27;t a builtin binary operator, it must be a user defined one. Emit</span></span><br><span class="line">  <span class="comment">// a call to it.</span></span><br><span class="line">  Function *F = <span class="built_in">getFunction</span>(std::<span class="built_in">string</span>(<span class="string">&quot;binary&quot;</span>) + Op);</span><br><span class="line">  <span class="built_in">assert</span>(F &amp;&amp; <span class="string">&quot;binary operator not found!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Value *Ops[<span class="number">2</span>] = &#123; L, R &#125;;</span><br><span class="line">  <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(F, Ops, <span class="string">&quot;binop&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析二元表达式时，我们需要处理两种情况：</p><ul><li>处理 <strong>默认运算符</strong>，比如：<code>+</code>、<code>-</code>、<code>*</code>、<code>&lt;</code> 等。我们只需要调用 <code>Builder</code> 生成对应的 LLVM IR 即可。</li><li>处理 <strong>自定义运算符</strong>，比如：<code>@</code>、<code>|</code> 等。我们只需要在符号表中查找对应的运算符，并生成对函数（如：<code>binary@</code>）的调用，从而生成 LLVM IR。由于自定义运算符只是作为普通函数构建的，所以不存在额外的特殊逻辑。</li></ul><h2 id="一元表达式代码生成"><a href="#一元表达式代码生成" class="headerlink" title="一元表达式代码生成"></a>一元表达式代码生成</h2><p>如下所示，为一元表达式实现代码生成的逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">UnaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *OperandV = Operand-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!OperandV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  Function *F = <span class="built_in">getFunction</span>(std::<span class="built_in">string</span>(<span class="string">&quot;unary&quot;</span>) + Opcode);</span><br><span class="line">  <span class="keyword">if</span> (!F)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown unary operator&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(F, OperandV, <span class="string">&quot;unop&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其生成逻辑非常简单，通过在符号表中查找对应的运算符，并生成对函数（如：<code>binary!</code>）的调用，从而生成 LLVM IR。</p><h2 id="通用表达式解析优化"><a href="#通用表达式解析优化" class="headerlink" title="通用表达式解析优化"></a>通用表达式解析优化</h2><p>由于现在我们新增了一种表达式类型 <code>UnaryExprAST</code>，因此，我们需要对原始的通用表达式解析函数进行优化，以支持解析一元表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= unary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = <span class="built_in">ParseUnary</span>();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ParseBinOpRHS</span>(<span class="number">0</span>, std::<span class="built_in">move</span>(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseExpression</code> 的实现逻辑非常简单，使用 <code>ParseUnary</code> 解析左操作数。然后继续解析结果，再解析右操作数。</p><p>由于表达式的右部可能也包含一元表达还是，因此，我们还需要修改 <code>ParseBinOpRHS</code>，支持解析一元运算符，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= (&#x27;+&#x27; unary)*</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseBinOpRHS</span><span class="params">(<span class="type">int</span> ExprPrec,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              std::unique_ptr&lt;ExprAST&gt; LHS)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// Parse the unary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = <span class="built_in">ParseUnary</span>();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的修改最终都会调用 <code>ParseUnary</code> 解析函数，其具体实现如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// unary</span></span><br><span class="line"><span class="comment">///   ::= primary</span></span><br><span class="line"><span class="comment">///   ::= &#x27;!&#x27; unary</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseUnary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If the current token is not an operator, it must be a primary expr.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok) || CurTok == <span class="string">&#x27;(&#x27;</span> || CurTok == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParsePrimary</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a unary operator, read it.</span></span><br><span class="line">  <span class="type">int</span> Opc = CurTok;</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Operand = <span class="built_in">ParseUnary</span>())</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;UnaryExprAST&gt;(Opc, std::<span class="built_in">move</span>(Operand));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseUnary</code> 解析函数的实现非常简单。当我们在解析主表达式时遇到一元运算符时，我们会将运算符符作为前缀，并将剩余部分作为另一个一元运算符进行解析。这样使得我们能够处理多个一元运算符串联的场景，比如： <code>!!x</code>。注意，一元运算符不能像二元运算符那样具有二义性的解析，因此不需要设置优先级。</p><h2 id="运算符函数调用"><a href="#运算符函数调用" class="headerlink" title="运算符函数调用"></a>运算符函数调用</h2><p>无论是一元运算符还是二元运算符，最终的实现逻辑均由函数体实现。因此，我们需要通过扩展 <code>FunctionAST</code> 的解析函数 <code>codegen()</code>，从而生成对应的 LLVM IR，具体如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">  Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is an operator, install it.</span></span><br><span class="line">  <span class="keyword">if</span> (P.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">    BinopPrecedence[P.<span class="built_in">getOperatorName</span>()] = P.<span class="built_in">getBinaryPrecedence</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">  BasicBlock *BB = BasicBlock::<span class="built_in">Create</span>(TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (P.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">    BinopPrecedence.<span class="built_in">erase</span>(P.<span class="built_in">getOperatorName</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>其主要是在为 <code>FunctionAST</code> 生成代码时，判断是否是自定义运算符的函数定义，如果是，则设置运算符优先级，并在代码生成后移除对应的运算符优先级。通过这种方式，我们可以同时实现一元运算符和二元运算符的底层代码生成逻辑。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>通过以上简单的扩展，我们开发出了一门真正的语言。基于 Kaleidoscope，我们可以做很多有趣的事情，包括：I&#x2F;O、数学运算等。比如，我们添加一个串联操作符，如下所示。注意：<code>printd</code> 用于打印指定值或换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">printd</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">printd</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; def binary : <span class="number">1</span> (x y) <span class="number">0</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="string">&quot;binary:&quot;</span>(<span class="type">double</span> %x, <span class="type">double</span> %y) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret <span class="type">double</span> <span class="number">0.000000e+00</span></span><br><span class="line">&#125;</span><br><span class="line">ready&gt; <span class="built_in">printd</span>(<span class="number">123</span>) : <span class="built_in">printd</span>(<span class="number">456</span>) : <span class="built_in">printd</span>(<span class="number">789</span>);</span><br><span class="line"><span class="number">123.000000</span></span><br><span class="line"><span class="number">456.000000</span></span><br><span class="line"><span class="number">789.000000</span></span><br><span class="line">Evaluated to <span class="number">0.000000</span></span><br></pre></td></tr></table></figure><p>我们还可以定义一系列的原始操作符，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># Logical unary <span class="keyword">not</span>.</span><br><span class="line">def unary!(v)</span><br><span class="line">  <span class="keyword">if</span> v then</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Unary negate.</span><br><span class="line">def unary-(v)</span><br><span class="line">  <span class="number">0</span>-v;</span><br><span class="line"></span><br><span class="line"># Define &gt; with the same precedence as &lt;.</span><br><span class="line">def binary&gt; <span class="number">10</span> (LHS RHS)</span><br><span class="line">  RHS &lt; LHS;</span><br><span class="line"></span><br><span class="line"># Binary logical <span class="keyword">or</span>, which does <span class="keyword">not</span> <span class="type">short</span> circuit.</span><br><span class="line">def binary| <span class="number">5</span> (LHS RHS)</span><br><span class="line">  <span class="keyword">if</span> LHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> RHS then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># Binary logical <span class="keyword">and</span>, which does <span class="keyword">not</span> <span class="type">short</span> circuit.</span><br><span class="line">def binary&amp; <span class="number">6</span> (LHS RHS)</span><br><span class="line">  <span class="keyword">if</span> !LHS then</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    !!RHS;</span><br><span class="line"></span><br><span class="line"># Define = with slightly lower precedence than relationals.</span><br><span class="line">def binary = <span class="number">9</span> (LHS RHS)</span><br><span class="line">  !(LHS &lt; RHS | LHS &gt; RHS);</span><br><span class="line"></span><br><span class="line"># Define <span class="string">&#x27;:&#x27;</span> <span class="keyword">for</span> sequencing: as a low-precedence <span class="keyword">operator</span> that ignores operands</span><br><span class="line"><span class="meta"># and just returns the RHS.</span></span><br><span class="line">def binary : <span class="number">1</span> (x y) y;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，Kaleidoscope 开始成为一种真实而强大的语言。</p><p>通过本章，我们增强了 Kaleidoscope 语言，在库中添加了扩展语言的能力。此时，Kaleidoscope 可以构建各种功能性的应用程序，并且可以调用具有副作用的函数，但它实际上不能定义和改变变量本身。</p><p>然而，变量更新是大多数编程语言的一个重要特性。下一章，我们将描述如何在不在前端构建 SSA 的情况下支持变量更新。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.html">Kaleidoscope: Extending the Language: User-defined Operators</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;目前为止，Kaleidoscope 已经是一门功能齐全且有用的编程语言了。但是，它仍然存在一个很大的问题。当前的 Kaleidoscope </summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="运算符" scheme="http://chuquan.me/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(5)——语言扩展：控制流</title>
    <link href="http://chuquan.me/2022/08/21/compiler-for-kaleidoscope-05/"/>
    <id>http://chuquan.me/2022/08/21/compiler-for-kaleidoscope-05/</id>
    <published>2022-08-21T14:48:11.000Z</published>
    <updated>2023-01-14T03:12:54.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在前 4 章中，我们介绍了 Kaleidoscope 语言的实现，包括支持 LLVM IR 代码生成、优化器、JIT 编译器等。然而，目前我们设计的 Kaleidoscope 的功能非常简单，除了函数调用和返回外，甚至不包含控制流的能力。这意味着我们在代码中无法使用条件分支，因此极大地限制了编程语言的能力。本章，我们将对 Kaleidoscope 进行扩展，使其支持 <code>if/then/else</code> 语句和 <code>for</code> 语句。</p><h1 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if&#x2F;then&#x2F;else"></a>if&#x2F;then&#x2F;else</h1><p>为 Kaleidoscope 进行语言扩展 <code>if/then/else</code> 语句其实非常简单。我们只需要修改词法分析器、解析器、AST、LLVM 代码生成器就可以实现这个新的特性。</p><p>在我们介绍如何实现该特性之前，我们首先需要清楚这个特性是什么。本质上，我们其实就是就是希望 Kaleidoscope 能够支持如下所示的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在第 2 章中，我们为 Kaleidoscope 的 AST 设计了三种结构，分别是 <strong>表达式</strong>、<strong>原型</strong>、<strong>函数</strong>。其中，表达式结构均会返回一个值，而 <code>if/then/else</code> 同样也会返回一个值。本质上，<code>if/then/else</code> 语句是先对条件进行计算，然后根据条件的结果选择返回 <code>then</code> 或 <code>else</code> 的值。因此，我们定义一个表达式子类用于表示 <code>if/then/else</code> 语句。</p><p><code>if/then/else</code> 的语义是将条件的计算结果作为一个布尔等价值：0.0 表示 <code>false</code>，其他值则为 <code>true</code>。如果条件为 <code>true</code>，则计算并返回第一个子表达式；如果条件为 <code>false</code>，则计算并返回第二个子表达式。</p><p>下面，我们来对各个部分进行扩展从而实现 <code>if/then/else</code> 表达式。</p><h2 id="词法分析器扩展"><a href="#词法分析器扩展" class="headerlink" title="词法分析器扩展"></a>词法分析器扩展</h2><p>词法分析器的扩展非常简单。首先，我们需要新增几种 token 类型，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// control</span></span><br><span class="line">tok_if = <span class="number">-6</span>,</span><br><span class="line">tok_then = <span class="number">-7</span>,</span><br><span class="line">tok_else = <span class="number">-8</span>,</span><br></pre></td></tr></table></figure><p>然后，我们分别为这些 token 类型定义 token 值，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_def;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_extern;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;if&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_if;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;then&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_then;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;else&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_else;</span><br><span class="line"><span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure><h2 id="AST-扩展"><a href="#AST-扩展" class="headerlink" title="AST 扩展"></a>AST 扩展</h2><p>为了表示 <code>if/then/else</code> 语句，我们定义一个表达式子类的 AST 节点类型 <code>IFExprAST</code>，如下所示。<code>IFExprAST</code> 节点包含三个指针，分别指向 <code>Cond</code> 子表达式、<code>Then</code> 子表达式、<code>Else</code> 子表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// IfExprAST - Expression class for if/then/else.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IfExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IfExprAST</span>(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then,</span><br><span class="line">            std::unique_ptr&lt;ExprAST&gt; Else)</span><br><span class="line">    : <span class="built_in">Cond</span>(std::<span class="built_in">move</span>(Cond)), <span class="built_in">Then</span>(std::<span class="built_in">move</span>(Then)), <span class="built_in">Else</span>(std::<span class="built_in">move</span>(Else)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-11.png?x-oss-process=image/resize,w_800"></p><h2 id="解析器扩展"><a href="#解析器扩展" class="headerlink" title="解析器扩展"></a>解析器扩展</h2><p>至此，我们已经有了针对 <code>if/then/else</code> 的 token 的定义和 AST 节点定义。接下来，我们来对解析器进行扩展。</p><p>首先，我们来定义一个对应的解析函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ifexpr ::= &#x27;if&#x27; expression &#x27;then&#x27; expression &#x27;else&#x27; expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseIfExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat the if.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition.</span></span><br><span class="line">  <span class="keyword">auto</span> Cond = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Cond)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_then)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected then&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat the then</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Then = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Then)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_else)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected else&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Else = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Else)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;IfExprAST&gt;(std::<span class="built_in">move</span>(Cond), std::<span class="built_in">move</span>(Then), std::<span class="built_in">move</span>(Else));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将解析函数加入到主表达式解析函数中，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>至此，我们已经解析并构造了 AST。接下来，我们来为 <code>if/then/else</code> 支持 LLVM IR 代码生成。上述扩展的相关代码在之前的章节中都已经进行了详细的介绍，而这部分的扩展，我们将引入一些新的概念。</p><p>我们首先来看一个简单的例子，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">def <span class="title">baz</span><span class="params">(x)</span> <span class="keyword">if</span> x then <span class="title">foo</span><span class="params">()</span> <span class="keyword">else</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>如果，我们不进行代码优化，生成的代码会是如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="type">double</span> @<span class="built_in">foo</span>()</span><br><span class="line"></span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">bar</span>()</span><br><span class="line"></span><br><span class="line">define <span class="type">double</span> @<span class="built_in">baz</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %ifcond = fcmp one <span class="type">double</span> %x, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %ifcond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:       ; preds = %entry</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">foo</span>()</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:       ; preds = %entry</span><br><span class="line">  %calltmp1 = call <span class="type">double</span> @<span class="built_in">bar</span>()</span><br><span class="line">  br label %ifcont</span><br><span class="line"></span><br><span class="line">ifcont:     ; preds = %<span class="keyword">else</span>, %then</span><br><span class="line">  %iftmp = phi <span class="type">double</span> [ %calltmp, %then ], [ %calltmp1, %<span class="keyword">else</span> ]</span><br><span class="line">  ret <span class="type">double</span> %iftmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述 LLVM IR 代码，我们可以将其转换成如下所示的控制流图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-12.png?x-oss-process=image/resize,w_800"></p><p>在 LLVM IR 中，<code>entry</code> 基本块对条件表达式进行计算（结果存储在 <code>x</code> 中），并使用 <code>fcmp one</code>（<code>one</code> 表示 <code>Ordered and Ont Equal</code>）命令将结果值与 <code>0.0</code> 进行比较。然后，根据表达式的结果决定代码跳转至 <code>then</code> 基本块或 <code>else</code> 基本块。</p><p>当 <code>then/else</code> 基本块执行完毕，它们均会进入 <code>ifcont</code> 基本块，从而执行 <code>if/then/else</code> 表达式后续的代码。在例子中，我们只需返回至函数调用者即可。</p><h3 id="φ-函数"><a href="#φ-函数" class="headerlink" title="φ 函数"></a>φ 函数</h3><p>在上述例子中，我们最终会向函数调用者返回一个表达式，那么问题来了：代码是否如何知道应该返回哪个表达式？答案是通过 phi 操作实现。</p><p>在第 3 章，我们提到 LLVM 的 <code>Value</code> 是用来表示 <strong>静态单赋值形式（SSA form）</strong> 的类型，LLVM IR 则是 SSA 的指令表示形式。当我们对基于 SSA 形式的控制流图进行分析时，如果有两条控制流边汇合到一起时，如何使每个变量只有一次赋值就不是那么显而易见的了。如下所示 (a) 图中，如果我们在基本块 1 和基本块 3 中分别为 a 实现了一次定值，那么基本块 4 该使用哪个值呢？</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-13.png?x-oss-process=image/resize,w_800"></p><p>为了解决这个问题，我们引入一个虚构符号，称为 <strong>φ函数</strong>。如上所示 (b) 图中，使用 <code>a3 &lt;- φ(a1, a2)</code> 来合并 <code>a1</code>（基本块 1 中的定值）和 <code>a2</code>（基本块 3 中的定值）。<br>如果控制流沿边 2 -&gt; 4 到达基本块 4，φ(a1, a2) 产生 a1；如果控制流沿边 3 -&gt; 4 到达基本块 4，φ(a1, a2) 产生 a2。</p><p>在 LLVM IR 中，使用 <code>phi</code> 指令实现 φ 函数。在例子中，如果控制流来自 <code>then</code> 基本块，那么 <code>phi</code> 指令会读取 <code>calltmp</code> 的值，如果控制流来自 <code>else</code> 基本块，那么 <code>phi</code> 指令会读取 <code>calltmp1</code> 的值。</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>如下所示为 <code>IFExprAST</code> 类的 <code>codegen</code> 方法，用于 LLVM IR 代码生成。我们依次对这个方法的各个部分进行介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">IfExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *CondV = Cond-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!CondV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">  CondV = Builder-&gt;<span class="built_in">CreateFCmpONE</span>(</span><br><span class="line">      CondV, ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">0.0</span>)), <span class="string">&quot;ifcond&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-14.png?x-oss-process=image/resize,w_800"></p><p>首先，我们解析得到条件表达式，并通过将其值与 0.0 进行比较，从而转换成一个布尔类型。上图所示，展示了这部分逻辑生成的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();</span><br><span class="line"></span><br><span class="line">// Create blocks for the then and else cases.  Insert the &#x27;then&#x27; block at the</span><br><span class="line">// end of the function.</span><br><span class="line">BasicBlock *ThenBB = BasicBlock::Create(*TheContext, &quot;then&quot;, TheFunction);</span><br><span class="line">BasicBlock *ElseBB = BasicBlock::Create(*TheContext, &quot;else&quot;);</span><br><span class="line">BasicBlock *MergeBB = BasicBlock::Create(*TheContext, &quot;ifcont&quot;);</span><br><span class="line"></span><br><span class="line">Builder-&gt;CreateCondBr(CondV, ThenBB, ElseBB);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-15.png?x-oss-process=image/resize,w_800"></p><p>其次，分别为 <code>if/then/else</code> 语句创建相关基本块，如：<code>ThenBB</code>、<code>ElseBB</code>、<code>MergeBB</code>。这里，其首先获取当前正在构建的 <code>Function</code> 对象。基于 <code>Function</code> 对象，创建三个基本块。注意，这里将 <code>TheFunction</code> 传入 <code>then</code> 基本块的构造函数，其用于将新创建的基本块插入到指定函数 <code>TheFunction</code> 的末尾。其他两个基本块创建后并没有立即插入函数。当基本块创建完成后，我们通过 <code>Builder-&gt;CreateCondBr</code> 方法创建条件分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emit then value.</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(ThenBB);</span><br><span class="line"></span><br><span class="line">Value *ThenV = Then-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"><span class="keyword">if</span> (!ThenV)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Builder-&gt;<span class="built_in">CreateBr</span>(MergeBB);</span><br><span class="line"><span class="comment">// Codegen of &#x27;Then&#x27; can change the current block, update ThenBB for the PHI.</span></span><br><span class="line">ThenBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-16.png?x-oss-process=image/resize,w_800"></p><p>随后，我们设置 <code>Builder</code> 中基本块的插入点并开始插入 <code>then</code> 基本块。严格来说，它会将插入点移动到指定基本块的末尾。但是，由于此时 <code>then</code> 基本块是空的，所以它也是在块的开头开始插入。</p><p>当插入点设置完成后，我们递归地为 <code>then</code> 表达式生成代码。为了完成 <code>then</code> 基本块，我们为无条件分支创建 <code>merge</code> 基本块。LLVM IR 要求所有基本块都使用诸如返回 <code>ret</code> 或分支 <code>br</code> 的控制流指令来终止。这意味着我们必须在 LLVM IR 中明确所有控制流，包括 <code>fall through</code>。如果我们没有遵循这个规则，后续的验证器会报错。</p><p>这里的最后一行非常微妙，但也非常重要。这里的问题在于，当我们在 <code>merge</code> 基本块中创建 phi 节点时，我们需要设置 phi 要处理的块&#x2F;值对。然而，phi 节点希望控制流图中每个基本块都有一个入口。那么，我们为什么要执行 <code>ThenBB</code> 之前的 5 行代码呢？问题是 <code>Then</code> 表达式本身可能实际上改变了 <code>Builder</code> 生成的基本块，比如，它包含了一个嵌套的 <code>if/then/else</code> 表达式。因为递归调用 <code>codegen()</code> 可以任意修改当前基本块，所以我们需要获取将设置 phi 节点的代码的最新值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emit else block.</span></span><br><span class="line">TheFunction-&gt;<span class="built_in">getBasicBlockList</span>().<span class="built_in">push_back</span>(ElseBB);</span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(ElseBB);</span><br><span class="line"></span><br><span class="line">Value *ElseV = Else-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"><span class="keyword">if</span> (!ElseV)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Builder-&gt;<span class="built_in">CreateBr</span>(MergeBB);</span><br><span class="line"><span class="comment">// Codegen of &#x27;Else&#x27; can change the current block, update ElseBB for the PHI.</span></span><br><span class="line">ElseBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-17.png?x-oss-process=image/resize,w_800"></p><p><code>else</code> 基本块的代码生成与 <code>then</code> 基本块的代码生成基本相同。唯一的区别在于第一行，它将 <code>else</code> 基本块添加到了函数中。至此，<code>then</code> 基本块和 <code>else</code> 基本块都已创建完成，接下来我们可以进行合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Emit merge block.</span></span><br><span class="line">  TheFunction-&gt;<span class="built_in">getBasicBlockList</span>().<span class="built_in">push_back</span>(MergeBB);</span><br><span class="line">  Builder-&gt;<span class="built_in">SetInsertPoint</span>(MergeBB);</span><br><span class="line">  PHINode *PN = Builder-&gt;<span class="built_in">CreatePHI</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), <span class="number">2</span>, <span class="string">&quot;iftmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  PN-&gt;<span class="built_in">addIncoming</span>(ThenV, ThenBB);</span><br><span class="line">  PN-&gt;<span class="built_in">addIncoming</span>(ElseV, ElseBB);</span><br><span class="line">  <span class="keyword">return</span> PN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-18.png?x-oss-process=image/resize,w_800"></p><p>这里的前两行代码我们很熟悉：</p><ul><li>第一行将 <code>merge</code> 基本块添加到 <code>Funciton</code> 对象</li><li>第二行修改插入点，以便新创建的代码将进入 <code>merge</code> 基本块</li></ul><p>然后，我们创建 phi 节点，并为它设置块&#x2F;值对。</p><p>最后，<code>codegen</code> 方法将 phi 节点作为 <code>if/then/else</code> 表达式的值进行返回。在上述例子中，该返回值将输入到顶级函数的代码中，该函数将创建返回指令。</p><h1 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h1><p>通过上面的实践，我们了解了如何为编程语言扩展控制流结构。接下来，我们来继续为 Kaleidoscope 支持 <code>for</code> 循环，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern putchard(char);</span><br><span class="line">def printstar(n)</span><br><span class="line">  for i = 1, i &lt; n, 1.0 in</span><br><span class="line">    putchard(42);  # ascii 42 = &#x27;*&#x27;</span><br><span class="line"></span><br><span class="line"># print 100 &#x27;*&#x27; characters</span><br><span class="line">printstar(100);</span><br></pre></td></tr></table></figure><p><code>for</code> 语句定义了一个新的变量，变量从起始值开始迭代，当条件为真时，使用步长值进行递增。如果省略步长值，则默认为 1.0。当条件为真时，执行内部的表达式。</p><p>下面，我们来看一下如何进行扩展。</p><h2 id="词法分析器扩展-1"><a href="#词法分析器扩展-1" class="headerlink" title="词法分析器扩展"></a>词法分析器扩展</h2><p>与 <code>if/then/else</code> 扩展类似，对于 <code>for</code> 语句，我们为词法分析器新增了两个 token 类型和 token 值，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">... in <span class="keyword">enum</span> <span class="title class_">Token</span> ...</span><br><span class="line"><span class="comment">// control</span></span><br><span class="line">tok_if = <span class="number">-6</span>, tok_then = <span class="number">-7</span>, tok_else = <span class="number">-8</span>,</span><br><span class="line">tok_for = <span class="number">-9</span>, tok_in = <span class="number">-10</span></span><br><span class="line"></span><br><span class="line">... in gettok ...</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_def;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_extern;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;if&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_if;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;then&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_then;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;else&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_else;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;for&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_for;</span><br><span class="line"><span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> tok_in;</span><br><span class="line"><span class="keyword">return</span> tok_identifier;</span><br></pre></td></tr></table></figure><h2 id="AST-扩展-1"><a href="#AST-扩展-1" class="headerlink" title="AST 扩展"></a>AST 扩展</h2><p>为了表示 <code>for</code> 语句，我们定义一个表达式子类的 AST 节点类型 <code>ForExprAST</code>。<code>ForExprAST</code> 包含四个指针，分别指向 <code>Start</code>，<code>End</code>，<code>Step</code>，<code>Body</code> 子表达式，此外还包含一个变量 <code>VarName</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ForExprAST - Expression class for for/in.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  std::string VarName;</span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ForExprAST</span>(<span class="type">const</span> std::string &amp;VarName, </span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Start,</span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; End, </span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Step,</span><br><span class="line">             std::unique_ptr&lt;ExprAST&gt; Body)</span><br><span class="line">    : <span class="built_in">VarName</span>(VarName), <span class="built_in">Start</span>(std::<span class="built_in">move</span>(Start)), <span class="built_in">End</span>(std::<span class="built_in">move</span>(End)),</span><br><span class="line">      <span class="built_in">Step</span>(std::<span class="built_in">move</span>(Step)), <span class="built_in">Body</span>(std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-19.png?x-oss-process=image/resize,w_800"></p><h2 id="解析器扩展-1"><a href="#解析器扩展-1" class="headerlink" title="解析器扩展"></a>解析器扩展</h2><p>如下所示为 <code>for</code> 表达式的解析函数。<code>for</code> 表达式支持可选的步长值，对此，解析函数通过检查是否存在第二个逗号来进行处理步长值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// forexpr ::= &#x27;for&#x27; identifier &#x27;=&#x27; expr &#x27;,&#x27; expr (&#x27;,&#x27; expr)? &#x27;in&#x27; expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseForExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat the for.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected identifier after for&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::string IdName = IdentifierStr;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;=&#x27; after for&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;=&#x27;.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Start = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Start)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;,&#x27; after for start value&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> End = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!End)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The step value is optional.</span></span><br><span class="line">  std::unique_ptr&lt;ExprAST&gt; Step;</span><br><span class="line">  <span class="keyword">if</span> (CurTok == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">    Step = <span class="built_in">ParseExpression</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Step)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_in)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;in&#x27; after for&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;in&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> Body = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Body)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;ForExprAST&gt;(IdName, std::<span class="built_in">move</span>(Start),</span><br><span class="line">                                       std::<span class="built_in">move</span>(End), std::<span class="built_in">move</span>(Step),</span><br><span class="line">                                       std::<span class="built_in">move</span>(Body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 <code>if/then/else</code> 相同，我们也把 <code>ParseForExpr</code> 解析函数方法插入到主表达式的解析函数 <code>ParsePrimary</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_if:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIfExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_for:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseForExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LLVM-IR-1"><a href="#LLVM-IR-1" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>下面，我们来为 <code>for</code> 表达式生成 LLVM IR。我们将上面的例子进行转换成得到如下所示的 LLVM IR 代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="type">double</span> @<span class="built_in">putchard</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">define <span class="type">double</span> @<span class="built_in">printstar</span>(<span class="type">double</span> %n) &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; initial value = <span class="number">1.0</span> (inlined into phi)</span><br><span class="line">  br label %loop</span><br><span class="line"></span><br><span class="line">loop:       ; preds = %loop, %entry</span><br><span class="line">  %i = phi <span class="type">double</span> [ <span class="number">1.000000e+00</span>, %entry ], [ %nextvar, %loop ]</span><br><span class="line">  ; body</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">putchard</span>(<span class="type">double</span> <span class="number">4.200000e+01</span>)</span><br><span class="line">  ; increment</span><br><span class="line">  %nextvar = fadd <span class="type">double</span> %i, <span class="number">1.000000e+00</span></span><br><span class="line"></span><br><span class="line">  ; termination test</span><br><span class="line">  %cmptmp = fcmp ult <span class="type">double</span> %i, %n</span><br><span class="line">  %booltmp = uitofp i1 %cmptmp to <span class="type">double</span></span><br><span class="line">  %loopcond = fcmp one <span class="type">double</span> %booltmp, <span class="number">0.000000e+00</span></span><br><span class="line">  br i1 %loopcond, label %loop, label %afterloop</span><br><span class="line"></span><br><span class="line">afterloop:      ; preds = %loop</span><br><span class="line">  ; loop always returns <span class="number">0.0</span></span><br><span class="line">  ret <span class="type">double</span> <span class="number">0.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，LLVM IR 包含了与 <code>if/then/else</code> 中相同的结构：一个 phi 节点、几个表达式和一些基本块。下面，让我们看看它们是如何组合在一起的。</p><h2 id="代码生成-1"><a href="#代码生成-1" class="headerlink" title="代码生成"></a>代码生成</h2><p><code>codegen</code> 的第一部分非常简单，为 <code>Start</code> 表达式生成代码，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">ForExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Emit the start code first, without &#x27;variable&#x27; in scope.</span></span><br><span class="line">  Value *StartVal = Start-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!StartVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>随后，我们为循环体的开始设置 LLVM 基本块。在上面的例子中，整个循环体是一个基本块，而循环体代码本身可以由多个基本块组成（例如，如果它包含嵌套的 <code>if/then/else</code> 或 <code>for/in</code> 表达式）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make the new basic block for the loop header, inserting after current</span></span><br><span class="line"><span class="comment">// block.</span></span><br><span class="line">Function *TheFunction = Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">BasicBlock *PreheaderBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br><span class="line">BasicBlock *LoopBB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;loop&quot;</span>, TheFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert an explicit fall through from the current block to the LoopBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">CreateBr</span>(LoopBB);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-20.png?x-oss-process=image/resize,w_800"></p><p>第二部分的代码与 <code>if/then/else</code> 非常相似。由于我们需要创建 phi 节点，因此要记住会进入循环的基本块。当我们获取到此基本块后，我们创建一个实际启动循环的基本块 <code>PreheaderBB</code> ，并为两个基本块创建一个无条件分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start insertion in LoopBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(LoopBB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the PHI node with an entry for Start.</span></span><br><span class="line">PHINode *Variable = Builder-&gt;<span class="built_in">CreatePHI</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), <span class="number">2</span>, VarName);</span><br><span class="line">Variable-&gt;<span class="built_in">addIncoming</span>(StartVal, PreheaderBB);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-21.png?x-oss-process=image/resize,w_800"></p><p>至此，我们已经设置了循环的 <code>PreheaderBB</code> 基本块，我们开始为循环体生成代码。首先，我们移动插入点，并为循环归纳变量创建 phi 节点。由于我们已经知道起始值的传入值，我们将其加入至 phi 节点。注意，phi 节点最会获得第二个值作为另一个边界，但是，目前我们还无法进行设置，因为它不存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Within the loop, the variable is defined equal to the PHI node.  If it</span></span><br><span class="line"><span class="comment">// shadows an existing variable, we have to restore it, so save it now.</span></span><br><span class="line">Value *OldVal = NamedValues[VarName];</span><br><span class="line">NamedValues[VarName] = Variable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Emit the body of the loop.  This, like any other expr, can change the</span></span><br><span class="line"><span class="comment">// current BB.  Note that we ignore the value computed by the body, but don&#x27;t</span></span><br><span class="line"><span class="comment">// allow an error.</span></span><br><span class="line"><span class="keyword">if</span> (!Body-&gt;<span class="built_in">codegen</span>())</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-22.png?x-oss-process=image/resize,w_800"></p><p>此时，<code>for</code> 将会向符号表中引入循环变量 <code>VarName</code>，从而使得符号表能够包含函数参数、循环变量等。为此，我们在为循环体生成代码之前，必须要将循环变量加入符号表，并存储其当前的值。注意，在外层作用域中有可能存在同名的变量 <code>VarName</code>，这里将符号表中的外部同名变量的值暂存至 <code>OldVal</code> 局部变量中，当代码生成完毕后，再进行恢复。</p><p>当循环变量存入符号表后，我们为循环体生成代码。这允许循环体使用循环变量：任何对于循环变量的引用都会通过符号表进行查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emit the step value.</span></span><br><span class="line">Value *StepVal = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (Step) &#123;</span><br><span class="line">  StepVal = Step-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!StepVal)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// If not specified, use 1.0.</span></span><br><span class="line">  StepVal = ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Value *NextVar = Builder-&gt;<span class="built_in">CreateFAdd</span>(Variable, StepVal, <span class="string">&quot;nextvar&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-23.png?x-oss-process=image/resize,w_800"></p><p>至此，循环体代码生成完毕，我们将通过增加步长值（如果没有则为 1.0）来计算迭代变量的下一个值。<code>NextVar</code> 将是循环的下一次迭代时循环变量的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the end condition.</span></span><br><span class="line">Value *EndCond = End-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"><span class="keyword">if</span> (!EndCond)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert condition to a bool by comparing non-equal to 0.0.</span></span><br><span class="line">EndCond = Builder-&gt;<span class="built_in">CreateFCmpONE</span>(</span><br><span class="line">    EndCond, ConstantFP::<span class="built_in">get</span>(*TheContext, <span class="built_in">APFloat</span>(<span class="number">0.0</span>)), <span class="string">&quot;loopcond&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-24.png?x-oss-process=image/resize,w_800"></p><p>最后，我们计算循环的退出值，从而决定循环是否退出。这与 <code>if/then/else</code> 语句的条件判断类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the &quot;after loop&quot; block and insert it.</span></span><br><span class="line">BasicBlock *LoopEndBB = Builder-&gt;<span class="built_in">GetInsertBlock</span>();</span><br><span class="line">BasicBlock *AfterBB =</span><br><span class="line">    BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;afterloop&quot;</span>, TheFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert the conditional branch into the end of LoopEndBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">CreateCondBr</span>(EndCond, LoopBB, AfterBB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any new code will be inserted in AfterBB.</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(AfterBB);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-25.png?x-oss-process=image/resize,w_800"></p><p>当循环体代码生成完成，我们只需要处理结束后的控制流。这里，首先创建一个基本块用于循环退出（<code>afterloop</code>）。基于退出条件的值，创建一个条件分支用于选择再次执行循环或退出循环。后续的代码则位于 <code>afterloop</code> 基本块中，因此设置了对应的插入点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Add a new entry to the PHI node for the backedge.</span></span><br><span class="line">  Variable-&gt;<span class="built_in">addIncoming</span>(NextVar, LoopEndBB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the unshadowed variable.</span></span><br><span class="line">  <span class="keyword">if</span> (OldVal)</span><br><span class="line">    NamedValues[VarName] = OldVal;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    NamedValues.<span class="built_in">erase</span>(VarName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for expr always returns 0.0.</span></span><br><span class="line">  <span class="keyword">return</span> Constant::<span class="built_in">getNullValue</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-26.png?x-oss-process=image/resize,w_800"></p><p>最后一部分代码则进行了各种清理操作。至此，我们有了 <code>NextVar</code> 的值，因此我们可以将传入的值加入到 phi 节点中。之后，我们将循环变量从符号表中删除，使得其不属于循环以外的作用域。最后，循环的代码生成会返回 <code>0.0</code>，即 <code>ForExprAST::codegen()</code> 的返回值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们为 Kaleidoscope 实现了控制流能力，包括 <code>if/then/else</code> 和 <code>for/in</code> 两种结构。我们通过实现这两种控制流，并介绍了 LLVM IR 相关的概念，如：φ 函数。下一章，我们将进一步对 Kaleidoscope 进行扩展，支持自定义运算符的能力。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.html">Kaleidoscope: Extending the Language: Control Flow</a></li><li><a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static Single Assignment</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在前 4 章中，我们介绍了 Kaleidoscope 语言的实现，包括支持 LLVM IR 代码生成、优化器、JIT 编译器等。然而，目前我</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="JIT" scheme="http://chuquan.me/tags/JIT/"/>
    
    <category term="Optimizer" scheme="http://chuquan.me/tags/Optimizer/"/>
    
    <category term="LLVM Pass" scheme="http://chuquan.me/tags/LLVM-Pass/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(4)——代码优化器、JIT 编译器</title>
    <link href="http://chuquan.me/2022/08/14/compiler-for-kaleidoscope-04/"/>
    <id>http://chuquan.me/2022/08/14/compiler-for-kaleidoscope-04/</id>
    <published>2022-08-14T07:19:15.000Z</published>
    <updated>2023-01-14T03:12:45.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前面几章我们介绍了如何实现一门简单的编程语言，同时支持了 LLVM IR 代码生成。本文，我们将介绍并实现两类技术：</p><ul><li><strong>代码优化器</strong></li><li><strong>JIT 编译器</strong></li></ul><h1 id="常量合并优化"><a href="#常量合并优化" class="headerlink" title="常量合并优化"></a>常量合并优化</h1><p>在第 3 章中，我们实现了 LLVM IR 代码生成的能力。不过，生成的代码仍然具有很大的优化空间。当然，我们所使用的 <code>IRBuider</code> 对代码也进行了一定程度的优化，如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) 1+2+x;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double %x, 3.000000e+00</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>IRBuilder</code> 对代码进行了常量合并优化。如果根据输入内容进行 AST 构建，基于字面含义生成的代码则将如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) 1+2+x;</span><br><span class="line">Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double 2.000000e+00, 1.000000e+00</span><br><span class="line">  %addtmp1 = fadd double %addtmp, %x</span><br><span class="line">  ret double %addtmp1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量合并</strong>（Contants Folding）是一种非常常见且重要的优化方法，几乎所有编程语言都在其 AST 中实现了常量合并优化。</p><p>在使用 LLVM 时，我们无需显式地开启常量合并优化功能，<strong>因为 LLVM IR 构造器内部会自动检测并执行常量合并</strong>。</p><p>事实上，我们通常建议使用 <code>IRBuilder</code> 来生成代码。<code>IRBuilder</code> 在构建过程中没有 <strong>语法开销</strong>（Syntactic Overhead），即无需显式指定编译器进行常量检查。此外，还能够显著减少某些情况下的 LLVM IR 代码量。</p><p>当然，<code>IRBuilder</code> 也有一定的限制，其在生成代码时将所有分析的代码进行内联，从而会导致无法探测到某些优化点。比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def <span class="built_in">test</span>(x) (1+2+x)*(x+(1+2));</span><br><span class="line">ready&gt; Read <span class="keyword">function</span> definition:</span><br><span class="line">define double @<span class="built_in">test</span>(double %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd double 3.000000e+00, %x</span><br><span class="line">  %addtmp1 = fadd double %x, 3.000000e+00</span><br><span class="line">  %multmp = fmul double %addtmp, %addtmp1</span><br><span class="line">  ret double %multmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述这种情况下，乘法操作的 <code>LHS</code> 和 <code>RHS</code> 是相同的值。我们期望生成的代码是 <code>tmp = x+3; result = tmp * tmp</code>，而不是计算两次 <code>x+3</code>。</p><p>遗憾的是，本地分析很难探测并纠正类似的优化点。这里，我们需要两种优化方式才能消除例子中冗余的 <code>fadd</code> 指令，分别是：</p><ul><li><strong>表达式重联</strong>（Reassociation Of Expression）</li><li><strong>公共子表达式消除</strong>（Common Subexpression Elimination）</li></ul><p>对此，LLVM 以 <strong>通道（Pass）</strong> 的形式提供了各种类型的优化，其中就包含上述的两种优化方式。</p><h1 id="代码优化器"><a href="#代码优化器" class="headerlink" title="代码优化器"></a>代码优化器</h1><p>LLVM 为各种类型的优化提供了对应的优化通道（下文简称 <code>Pass</code>）。与其他系统不同，LLVM 并没有错误地认为某一组优化适用于所有编程语言和所有情况。相反，LLVM 允许编译器开发者自定义选择哪些优化、以哪种顺序优化、在哪种情况下优化。</p><p>比如，LLVM 提供了 <code>whole module</code> Pass，其能够尽可能多地查看代码体（通常是整个文件，如果在链接时执行，那么它可能是整个程序的很大一部分）。LLVM 还支持 <code>per-function</code> Pass，其一次只对一个函数进行操作，而不查看其他函数。关于 Pass 的更多细节，可以查看官方文档——<a href="https://llvm.org/docs/WritingAnLLVMPass.html">How to Write a Pass</a>、<a href="https://llvm.org/docs/Passes.html">LLVM’s Analysis and Transform Passes</a>。</p><p>现阶段，当用户输入代码时，我们会实时生成 LLVM IR。在实时解析过程中，我们会在用户输入代码时运行 <code>per-function</code> Pass 进行优化。如果我们想实现一个“静态编译器”，我们可以完全使用现有的代码，不同的是，我们只会在整个文件被解析完成之后，才运行优化器。</p><p>为了执行 <code>per-function</code> Pass，我们需要设置一个 <code>FunctionPassManager</code> 来管理我们希望运行的 LLVM 优化通道。当 <code>FunctionPassManager</code> 设置完成后，我们可以向其注册一组优化通道来执行。对于每一个 Module，需要创建一个对应的 <code>FunctionPassManager</code>，因此我们可以实现一个函数来为完成创建并初始化模块和通道管理器，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Open a new module.</span></span><br><span class="line">  TheModule = std::<span class="built_in">make_unique</span>&lt;Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, TheContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = std::<span class="built_in">make_unique</span>&lt;legacy::FunctionPassManager&gt;(TheModule.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createInstructionCombiningPass</span>());</span><br><span class="line">  <span class="comment">// Reassociate expressions.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createReassociatePass</span>());</span><br><span class="line">  <span class="comment">// Eliminate Common SubExpressions.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createGVNPass</span>());</span><br><span class="line">  <span class="comment">// Simplify the control flow graph (deleting unreachable blocks, etc).</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">add</span>(<span class="built_in">createCFGSimplificationPass</span>());</span><br><span class="line"></span><br><span class="line">  TheFPM-&gt;<span class="built_in">doInitialization</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先初始化了全局模块 <code>TheModule</code> 和通道管理器 <code>TheFPM</code>，后者被附加到了 <code>TheModule</code> 中。当通道管理器初始化完毕，我们通过调用 <code>add</code> 方法来添加一系列 LLVM 优化通道。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-07.png?x-oss-process=image/resize,w_800"></p><p>这里，我们添加了 4 种优化通道，包括：<strong>窥孔优化</strong>、<strong>表达式重联</strong>、<strong>公共子表达式消除</strong>、<strong>控制流图简化</strong> 等。这是一组非常标准的代码清理优化，可用于各种代码。</p><p>当通道管理器初始化完毕后，我们会在 <code>FunctionAST::codegen()</code> 方法的末尾来调用并执行通道管理器，最终将优化结果返回，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">  <span class="comment">// Finish off the function.</span></span><br><span class="line">  Builder.<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">  <span class="built_in">verifyFunction</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optimize the function.</span></span><br><span class="line">  TheFPM-&gt;<span class="built_in">run</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TheFunction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，通道管理器的执行非常简单。<code>FunctionPassageManager</code> 直接对 LLVM Funtion* 进行优化和更新。我们可以对它进行简单的测试，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">test</span><span class="params">(x)</span> <span class="params">(<span class="number">1</span>+<span class="number">2</span>+x)</span>*<span class="params">(x+(<span class="number">1</span>+<span class="number">2</span>))</span></span>;</span><br><span class="line">ready&gt; Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">test</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, <span class="number">3.000000e+00</span></span><br><span class="line">  %multmp = fmul <span class="type">double</span> %addtmp, %addtmp</span><br><span class="line">  ret <span class="type">double</span> %multmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之前，生成的 LLVM IR 代码得到了预期的优化，去掉了冗余的 <code>fadd</code> 指令。</p><p>LLVM 为不同的场景提供了各种类型的优化。官方文档 <a href="https://llvm.org/docs/Passes.html">LLVM’s Analysis and Transform Passes</a> 列出了一部分优化相关的通道，但不是非常完整。此外，我们也可以查看 Clang 启动时所执行的通道，还可以通过 <code>opt</code> 工具来试验通道。</p><h1 id="JIT-编译器"><a href="#JIT-编译器" class="headerlink" title="JIT 编译器"></a>JIT 编译器</h1><p>LLVM 提供了非常多的工具，以支持操作 LLVM IR。例如：我们可以对 LLVM IR 执行各种类型的优化（如上文所示），可以将 LLVM IR 转换成文本形式或二进制形式，可以将 LLVM IR 编译成特定架构的汇编代码，可以对 LLVM IR 进行即时编译（JIT，Just In Time）。<strong>LLVM IR 的核心作用是作为编译器不同部分之间的通用传递形式</strong>。</p><p>在这一节中，我们将为 Kaleidoscope 实现 JIT 编译器。<strong>JIT 的基本思想是：当用户输入代码时，即时分析并评估其顶层表达式</strong>。比如：当用户输入 <code>1+2;</code> 时，我们将输出 <code>3</code>。</p><p>对此，我们首先准备相关环境，包括：</p><ul><li><strong>初始化本机目标（Native Target）</strong>：通过调用 <code>InitializeNativeTarget</code> 相关方法实现。</li><li><strong>初始化 JIT</strong>：通过设置 <code>KaleidoscopeJIT</code> 类型的 <code>TheJIT</code> 全局变量实现。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">InitializeNativeTarget</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmPrinter</span>();</span><br><span class="line">  <span class="built_in">InitializeNativeTargetAsmParser</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;=&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>; <span class="comment">// highest.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prime the first token.</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ready&gt; &quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  TheJIT = <span class="built_in">ExitOnErr</span>(KaleidoscopeJIT::<span class="built_in">Create</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the main &quot;interpreter loop&quot; now.</span></span><br><span class="line">  <span class="built_in">MainLoop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们还需要为 JIT 设置数据内存布局，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeModuleAndPassManager</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Open a new module.</span></span><br><span class="line">  TheContext = std::<span class="built_in">make_unique</span>&lt;LLVMContext&gt;();</span><br><span class="line">  TheModule = std::<span class="built_in">make_unique</span>&lt;Module&gt;(<span class="string">&quot;my cool jit&quot;</span>, *TheContext);</span><br><span class="line">  TheModule-&gt;<span class="built_in">setDataLayout</span>(TheJIT-&gt;<span class="built_in">getDataLayout</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new pass manager attached to it.</span></span><br><span class="line">  TheFPM = std::<span class="built_in">make_unique</span>&lt;legacy::FunctionPassManager&gt;(TheModule.<span class="built_in">get</span>());</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>KaleidoscopeJIT</code> 类表示针对 Kaleidoscope 语言的 JIT。在后续的章节中，我们将介绍它是如何工作的，并使用新功能对其进行扩展。它的 API 非常简单，包括：</p><ul><li><code>addModule</code>：用于向 JIT 注册 LLVM IR module，使其函数可用于执行。</li><li><code>lookup</code>：允许我们查找指向已编译代码的指针。</li></ul><p>我们在顶层表达式解析函数中调用 <code>KaleidoscopeJIT</code> 的 AIP，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = <span class="built_in">ParseTopLevelExpr</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FnAST-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">      <span class="comment">// Create a ResourceTracker to track JIT&#x27;d memory allocated to our</span></span><br><span class="line">      <span class="comment">// anonymous expression -- that way we can free it after executing.</span></span><br><span class="line">      <span class="keyword">auto</span> RT = TheJIT-&gt;<span class="built_in">getMainJITDylib</span>().<span class="built_in">createResourceTracker</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> TSM = <span class="built_in">ThreadSafeModule</span>(std::<span class="built_in">move</span>(TheModule), std::<span class="built_in">move</span>(TheContext));</span><br><span class="line">      <span class="built_in">ExitOnErr</span>(TheJIT-&gt;<span class="built_in">addModule</span>(std::<span class="built_in">move</span>(TSM), RT));</span><br><span class="line">      <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Search the JIT for the __anon_expr symbol.</span></span><br><span class="line">      <span class="keyword">auto</span> ExprSymbol = <span class="built_in">ExitOnErr</span>(TheJIT-&gt;<span class="built_in">lookup</span>(<span class="string">&quot;__anon_expr&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the symbol&#x27;s address and cast it to the right type (takes no</span></span><br><span class="line">      <span class="comment">// arguments, returns a double) so we can call it as a native function.</span></span><br><span class="line">      <span class="built_in">double</span> (*FP)() = (<span class="built_in">double</span> (*)())(<span class="type">intptr_t</span>)ExprSymbol.<span class="built_in">getAddress</span>();</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Evaluated to %f\n&quot;</span>, <span class="built_in">FP</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Delete the anonymous expression module from the JIT.</span></span><br><span class="line">      <span class="built_in">ExitOnErr</span>(RT-&gt;<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果解析成功且代码生成，那么会将包含顶层表达式的 module 注册至 JIT 中。我们通过调用 <code>addModule</code> 方法实现，该方法会为 module 中的所有函数生成代码，并将 module 与一个资源追踪器进行绑定，以用于后续从 JIT 中移除 module。当 module 注册完成后，将无法对其进行修改，因此我们需要创建一个新的 module 用于持有后续的代码，通过调用 <code>InitializeModuleAndPassManager()</code> 方法实现。</p><p>当 module 注册完毕后，我们需要获取一个指向最终生成代码的指针。为此，我们调用 JIT 的 <code>lookup</code> 方法，并传递顶层表达式函数的名称：<code>__anon_expr</code>。</p><p>接下来，我们通过该符号调用 <code>getAddress()</code> 来获取 <code>__anon_expr</code> 函数的内存地址。回想一下，我们将顶层表达式编译成一个自包含的 LLVM 函数，该函数不接受任何参数并返回计算的双精度值。由于 LLVM JIT 编译器与本机平台 ABI 匹配，因此我们可以将结果指针转换为该类型的函数指针并直接调用它。这意味着，JIT 编译代码和静态链接到应用程序的本机机器代码之间没有区别。</p><p>最后，由于我们不支持重新评估顶层表达式，所以当我们完成释放相关内存时，我们会从 JIT 中删除 module。然而，我们之前创建的 module（通过 <code>InitializeModuleAndPassManager</code>）仍然打开并等待添加新代码。</p><p>如下所示，为我们对 JIT 的测试代码。顶层表达式使用无参函数进行表示，返回了一个 double 类型的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="number">4</span>+<span class="number">5</span>;</span><br><span class="line">Evaluated to <span class="number">9.000000</span></span><br></pre></td></tr></table></figure><p>下面，我们再来测试 JIT 下的函数的定义与调用，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">testfunc</span><span class="params">(x y)</span> x + y*2</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">testfunc</span>(<span class="type">double</span> %x, <span class="type">double</span> %y) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul <span class="type">double</span> %y, <span class="number">2.000000e+00</span></span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, %multmp</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">testfunc</span>(<span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">Evaluated to <span class="number">24.000000</span></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">testfunc</span>(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">ready&gt; Error: Unknown function referenced</span><br></pre></td></tr></table></figure><p>上述代码中，在第二次调用 <code>testfunc</code> 函数时，LLVM 提示找不到 <code>testfunc</code> 函数，这是怎么回事？从前面介绍 JIT 的 API 中我们可以知道，module 是 JIT 的分配单元，<code>testfunc</code> 的定义与 <code>testfunc</code> 的调用（匿名表达式）处于同一个 moudle 中，当我们从 JIT 中删除 module 以释放匿名表达式时的内存时，module 中 <code>testfunc</code> 的定义也被删除了。因此，当我们再次尝试调用 <code>testfunc</code> 时，JIT 提示找不到该函数。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-08.png?x-oss-process=image/resize,w_800"></p><p>一种简单的解决方法是：<strong>将匿名表达式与函数定义放在不同的 module 中</strong>。每个函数原型都会提前注册至 JIT 中，当执行函数调用时，JIT 会进行跨 module 查找。通过将匿名表达式放在不同的 module 中，我们可以在不影响其他功能的情况下将其释放。如下所示，为该解决方法的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-09.png?x-oss-process=image/resize,w_800"></p><p>事实上，我们可以进一步进行优化，将每个函数定义存储在其对应的 module 中。这样的话，我们可以实现更加真实的 REPL 环境：同名函数可以多次添加至 JIT 中。当通过 KaleidoscopeJIT 查找符号时，它将返回最新的函数定义，最终达到如下所示的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x)</span> x + 1</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, <span class="number">1.000000e+00</span></span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">Evaluated to <span class="number">3.000000</span></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x)</span> x + 2</span>;</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %x, <span class="number">2.000000e+00</span></span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">Evaluated to <span class="number">4.000000</span></span><br></pre></td></tr></table></figure><p>为了让每个函数定义能够存储在其对应的 module 中，我们需要一种方法来重新生成函数声明，并将它们存储至新的 module 中。具体实现，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">getFunction</span><span class="params">(std::string Name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// First, see if the function has already been added to the current module.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *F = TheModule-&gt;<span class="built_in">getFunction</span>(Name))</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If not, check whether we can codegen the declaration from some existing</span></span><br><span class="line">  <span class="comment">// prototype.</span></span><br><span class="line">  <span class="keyword">auto</span> FI = FunctionProtos.<span class="built_in">find</span>(Name);</span><br><span class="line">  <span class="keyword">if</span> (FI != FunctionProtos.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> FI-&gt;second-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no existing prototype exists, return null.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = <span class="built_in">getFunction</span>(Callee);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Transfer ownership of the prototype to the FunctionProtos map, but keep a</span></span><br><span class="line">  <span class="comment">// reference to it for use below.</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;P = *Proto;</span><br><span class="line">  FunctionProtos[Proto-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(Proto);</span><br><span class="line">  Function *TheFunction = <span class="built_in">getFunction</span>(P.<span class="built_in">getName</span>());</span><br><span class="line">  <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>如下所示，为调整后的设计原理示意图。由于每个函数定义都对应一个模块，而 <code>TheModule</code> 仅仅指向当前模块。因此，无法通过 <code>TheModule</code> 查找其他模块中是否存在特定的函数定义。为了解决这个问题，引入了 <code>FunctionProtos</code> 来存储所有模块定义的函数原型，方便进行查找。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-10.png?x-oss-process=image/resize,w_800"></p><p>我们首先设置一个全局的 <code>FunctionProtos</code>，用于存储每个函数的原型，支持覆盖。此外，我们还定义一个便利方法 <code>getFunction()</code> 用于替换 <code>TheModule-&gt;getFunction()</code> <code>getFunction()</code> 的核心逻辑如下所示。</p><ul><li>首先，在 <code>TheModule</code> 中查找函数声明。</li><li>如果存在，则返回。</li><li>如果不存在，则在 <code>FunctionProtos</code> 中继续查找函数声明。</li></ul><p>在 <code>CallExprAST::codegen()</code> 中，我们只需要将 <code>TheModule-&gt;getFunction()</code> 替换成 <code>getFunction()</code> 即可。</p><p>在 <code>FunctionAST::codegen()</code> 中，我们首先更新 <code>FunctionProtos</code>，然后调用 <code>getFunction()</code> 即可。</p><p>之后，我们就可以在当前 module 中查找并调用之前声明的函数。</p><p>为此，我们还需要进行如下改造。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> FnAST = <span class="built_in">ParseDefinition</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = FnAST-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Read function definition:&quot;</span>);</span><br><span class="line">      FnIR-&gt;<span class="built_in">print</span>(<span class="built_in">errs</span>());</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      <span class="built_in">ExitOnErr</span>(TheJIT-&gt;<span class="built_in">addModule</span>(<span class="built_in">ThreadSafeModule</span>(std::<span class="built_in">move</span>(TheModule), std::<span class="built_in">move</span>(TheContext))));</span><br><span class="line">      <span class="built_in">InitializeModuleAndPassManager</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> ProtoAST = <span class="built_in">ParseExtern</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *FnIR = ProtoAST-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Read extern: &quot;</span>);</span><br><span class="line">      FnIR-&gt;<span class="built_in">print</span>(<span class="built_in">errs</span>());</span><br><span class="line">      <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      FunctionProtos[ProtoAST-&gt;<span class="built_in">getName</span>()] = std::<span class="built_in">move</span>(ProtoAST);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>HandleDefinition</code> 函数中，我们新增了两行代码：将定义的函数注册至 JIT 中并初始化一个新的模块与通道管理器。</p><p>在 <code>HandleExtern</code> 函数中，我们新增了一行代码：将函数原型添加至 <code>FunctionProtos</code> 中。</p><p>完成上述修改后，我们再来测试一下，如下所示。此时，函函数重复定义后，能够自动匹配最新定义的函数。<strong>注意：由于 LLVM 9.0 及以后版本不支持不同模块定义相同符号，因此 LLVM 9.0 及以后版本并不支持本文所示的覆盖函数定义的能力。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; def foo(x) x + 1;</span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 3.000000</span><br><span class="line"></span><br><span class="line">ready&gt; def foo(x) x + 2;</span><br><span class="line">ready&gt; foo(2);</span><br><span class="line">Evaluated to 4.000000</span><br></pre></td></tr></table></figure><p>最后，我们再来测试一下能否调用外部函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">sin</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">sin</span>(<span class="number">1.0</span>);</span><br><span class="line">Evaluated to <span class="number">0.841471</span></span><br><span class="line"></span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x)</span> <span class="title">sin</span><span class="params">(x)</span>*<span class="title">sin</span><span class="params">(x)</span> + <span class="title">cos</span><span class="params">(x)</span>*<span class="title">cos</span><span class="params">(x)</span></span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %x) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">sin</span>(<span class="type">double</span> %x)</span><br><span class="line">  %multmp = fmul <span class="type">double</span> %calltmp, %calltmp</span><br><span class="line">  %calltmp2 = call <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span> %x)</span><br><span class="line">  %multmp4 = fmul <span class="type">double</span> %calltmp2, %calltmp2</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %multmp, %multmp4</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">foo</span>(<span class="number">4.0</span>);</span><br><span class="line">Evaluated to <span class="number">1.000000</span></span><br></pre></td></tr></table></figure><p>从上述执行结果来看，JIT 是能够查找到外部函数 <code>sin</code> 和 <code>cos</code>。这是如何做到的？事实上，<code>KaleidoscopeJIT</code> 内部有一个简单的符号解析规则，用于查找所注册 module 中不存在的符号：首先搜索已添加到 JIT 的所有 module，找到函数定义。如果 JIT 中没有找到定义，那么它将到 Kaleidoscope 进程自身上调用 <code>dlsym(&quot;sin&quot;)</code>。由于 <code>sin</code> 是在 JIT 的地址空间中定义的，它将 module 中对 <code>sin</code> 函数的调用转换成对 libm 版本的 <code>sin</code> 函数的调用。在某些情况下，它会更进一步，因为 <code>sin</code> 和 <code>cos</code> 是标准的数学函数名称，当使用上面的 <code>sin(1.0)</code> 时，常量合并优化器能够直接返回其计算结果。</p><p>后续，我们将介绍如何调整 <code>KaleidoscopeJIT</code> 中的这套符号解析规则，从而启用各种功能，从安全性（限制 JIT 代码可用的符号集）到基于符号名称的动态代码生成、以及懒编译（Lazy Compilation）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们完成了对 Kaleidoscope 的 JIT 和优化器的支持。我们可以实现一门非图灵完备的编程语言，以用户驱动的方式对齐进行优化和 JIT 编译。后续，我们将研究使用控制流结构扩展编程语言，并在此过程中解决一些 LLVM IR 相关的问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.html">Kaleidoscope: Adding JIT and Optimizer Support</a></li><li><a href="https://llvm.org/docs/WritingAnLLVMPass.html">How to Write a Pass</a></li><li><a href="https://llvm.org/docs/Passes.html">LLVM’s Analysis and Transform Passes</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;前面几章我们介绍了如何实现一门简单的编程语言，同时支持了 LLVM IR 代码生成。本文，我们将介绍并实现两类技术：&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="JIT" scheme="http://chuquan.me/tags/JIT/"/>
    
    <category term="Pass" scheme="http://chuquan.me/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(3)——LLVM IR 代码生成</title>
    <link href="http://chuquan.me/2022/08/07/compiler-for-kaleidoscope-03/"/>
    <id>http://chuquan.me/2022/08/07/compiler-for-kaleidoscope-03/</id>
    <published>2022-08-07T14:10:12.000Z</published>
    <updated>2023-01-14T03:12:36.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在上一章中，我们介绍了如何构建抽象语法树 AST。这一章，我们进一步将抽象语法树转换成 LLVM IR。此外，我们会简单介绍 LLVM 的工作原理和使用方法。</p><blockquote><p>注意：本章源码要求 LLVM 版本大于等于 3.7。</p></blockquote><h1 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h1><p>为了支持 LLVM IR 代码生成，我们需要实现相关的初始化设置。</p><p>首先，我们在每一个 AST 类中定义虚拟代码生成方法，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExprAST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Value *<span class="title">codegen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">  <span class="type">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NumberExprAST</span>(<span class="type">double</span> Val) : <span class="built_in">Val</span>(Val) &#123;&#125;</span><br><span class="line">  <span class="function">Value *<span class="title">codegen</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>codegen()</code> 方法为对应 AST 节点及其所依赖的内容生成 IR，返回一个 LLVM <code>Value</code> 对象。</p><p><code>Value</code> 是 LLVM 中用于表示 <strong>静态单赋值（Static Single Assignment，SSA）寄存器</strong> 或 <strong>SSA 形式</strong> 的类。静态单赋值，顾名思义，其要求每个变量只能赋值一次，并且每个变量在使用之前定义。因此，在重新计算之前，变量的值不会发生改变。</p><p>其次，我们实现了一个 <code>LogError</code> 方法，用于在代码生成期间报告错误，比如：未声明的参数。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">LogErrorV</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Str)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">LogError</span>(Str);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，我们定义了一系列全局静态变量，用于辅助代码生成，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::unique_ptr&lt;LLVMContext&gt; TheContext;</span><br><span class="line"><span class="type">static</span> std::unique_ptr&lt;IRBuilder&lt;&gt;&gt; Builder;</span><br><span class="line"><span class="type">static</span> std::unique_ptr&lt;Module&gt; TheModule;</span><br><span class="line"><span class="type">static</span> std::map&lt;std::string, Value *&gt; NamedValues;</span><br></pre></td></tr></table></figure><p><code>TheContenxt</code> 是一个不透明的对象，它包含许多 LLVM 核心数据结构，比如类型和常量值表。我们不需要详细了解它，只需要一个单例来传递其所需的 API。</p><p><code>Builder</code> 对象是一个辅助对象，用于生成 LLVM 指令。<code>IRBuilder</code> 类模板的实例能够追踪插入指令的当前位置，并能够创建新指令。</p><p><code>TheModule</code> 是一个包含一系列函数和全局变量的 LLVM 数据结构。在许多方面，它是 LLVM IR 用来包含代码的顶层结构。其持有了生成的所有 IR 的内存，这也是 <code>codegen()</code> 方法返回 <code>Value*</code> 指针，而不是 <code>unique_ptr&lt;Value&gt;</code> 的原因。</p><p><code>NamedValues</code> 用于存储当前作用域内所定义的值及其 LLVM 表示形式。本质上就是代码的符号表。在 Kaleidoscope 中，唯一可以被引用的是函数参数。因此，在为函数体生成代码时，函数参数将存储在 <code>NamedValues</code> 中。</p><p>在介绍了代码生成的基础设置之后，下面我们开始介绍如何为每个表达式生成代码。</p><h1 id="表达式代码生成"><a href="#表达式代码生成" class="headerlink" title="表达式代码生成"></a>表达式代码生成</h1><p>表达式节点的 LLVM IR 代码生成非常简单。下面，我们分别进行介绍。</p><h2 id="数值表达式"><a href="#数值表达式" class="headerlink" title="数值表达式"></a>数值表达式</h2><p>如下所示，为数值表达式的代码生成方法定义，其创建并返回一个 <code>ConstantFP</code>。事实上，在 LLVM IR 中，数字常量由 <code>ConstantFP</code> 类表示，其内部将数值保存在 <code>APFloat</code> 中（<code>APFloat</code> 能够保存任意精度浮点常量）。注意，在 LLVM IR 中，常量都是唯一且共享的。因此，API 通常使用 <code>foo::get(...)</code> 的用法，而不是 <code>new foo(..)</code> 或 <code>foo::Create(..)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">NumberExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ConstantFP::<span class="built_in">get</span>(TheContext, <span class="built_in">APFloat</span>(Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h2><p>如下所示，为变量表达式的代码生成方法定义，其仅检查指定变量是否在符号表 <code>NameValues</code> 中（如果没有，则引用未知变量）并返回它的值。在目前的定义中，我们在 <code>NamedValues</code> 中仅存储函数参数。在后续文章节中，我们将在符号表中支持 <strong>循环归纳变量</strong>（Loop Induction Variable）和 <strong>局部变量</strong>（Local Variable）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">VariableExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look this variable up in the function.</span></span><br><span class="line">  Value *V = NamedValues[Name];</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown variable name&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二元表达式"><a href="#二元表达式" class="headerlink" title="二元表达式"></a>二元表达式</h2><p>如下所示，为二元表达式的代码生成方法定义，其基本思想是：<strong>分别为二元表达式的左部和右部递归生成代码，然后根据操作符的类型分别计算二元表达式的结果</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">BinaryExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Value *L = LHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  Value *R = RHS-&gt;<span class="built_in">codegen</span>();</span><br><span class="line">  <span class="keyword">if</span> (!L || !R)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (Op) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFAdd</span>(L, R, <span class="string">&quot;addtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFSub</span>(L, R, <span class="string">&quot;subtmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateFMul</span>(L, R, <span class="string">&quot;multmp&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">    L = Builder.<span class="built_in">CreateFCmpULT</span>(L, R, <span class="string">&quot;cmptmp&quot;</span>);</span><br><span class="line">    <span class="comment">// Convert bool 0/1 to double 0.0 or 1.0</span></span><br><span class="line">    <span class="keyword">return</span> Builder.<span class="built_in">CreateUIToFP</span>(L, Type::<span class="built_in">getDoubleTy</span>(TheContext), <span class="string">&quot;booltmp&quot;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;invalid binary operator&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码实现中，我们通过 LLVM <code>Builder</code> 类的相关方法来生成代码，其内部知道在何处创建指令，我们要做的就是指定指令的类型（如：<code>CreateFAdd</code>），指定使用的操作数（如：<code>L</code> 和 <code>R</code>），指定生成指令的名称（如：<code>addtmp</code>）。</p><p>关于生成指令的名称，其实只是一个提示。比如如，上述代码中如果发出多个 <code>addtmp</code> 变量，LLVM 将自动为每个变量提供一个递增的、唯一的数字后缀。 指令的名称完全是可选的，它的作用仅仅是提高 LLVM IR 的可读性。</p><p>LLVM 指令有着严格规则约束，比如，加法指令的左右操作数的类型必须相同，加法的结果类型必须与操作数类型相同。由于 Kaleidoscope 中的所有值都是双精度值类型，这使得 <code>add</code>、<code>sub</code> 和 <code>mul</code> 的代码非常简单。</p><p>此外，LLVM 规定 <code>fcmp</code> 指令必须返回一个 <code>i1</code> 值（一个一位整数）。然而，我们定义的 Kaleidoscope 希望该值是 0.0 或 1.0（浮点数）。为了获得这些语义，我们将 <code>fcmp</code> 指令与 <code>uitofp</code> 指令结合起来。后者通可以将输入整数转换为浮点值。与此相反，如果我们使用 <code>sitofp</code> 指令，那么 Kaleidoscope 的 <code>&lt;</code> 运算符将根据输入值返回 0.0 和 -1.0。</p><h2 id="函数调用表达式"><a href="#函数调用表达式" class="headerlink" title="函数调用表达式"></a>函数调用表达式</h2><p>如下所示，为函数调用表达式的代码生成方法定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Value *<span class="title">CallExprAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Look up the name in the global module table.</span></span><br><span class="line">  Function *CalleeF = TheModule-&gt;<span class="built_in">getFunction</span>(Callee);</span><br><span class="line">  <span class="keyword">if</span> (!CalleeF)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Unknown function referenced&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If argument mismatch error.</span></span><br><span class="line">  <span class="keyword">if</span> (CalleeF-&gt;<span class="built_in">arg_size</span>() != Args.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorV</span>(<span class="string">&quot;Incorrect # arguments passed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Value *&gt; ArgsV;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>, e = Args.<span class="built_in">size</span>(); i != e; ++i) &#123;</span><br><span class="line">    ArgsV.<span class="built_in">push_back</span>(Args[i]-&gt;<span class="built_in">codegen</span>());</span><br><span class="line">    <span class="keyword">if</span> (!ArgsV.<span class="built_in">back</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Builder.<span class="built_in">CreateCall</span>(CalleeF, ArgsV, <span class="string">&quot;calltmp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述方法实现中，在 LLVM Module 的符号表中查找对应的函数。LLVM Module 是 JIT 阶段存储函数的容器。通过为每个函数指定与用户指定的名称相同的名称，我们可以使用 LLVM 符号表为我们解析函数名称。</p><p>当发生调用函数时，我们递归地对每个入参进行代码生成，并创建一个 LLVM 函数调用指令。注意，LLVM 默认使用 C 调用规范，允许这些函数调用同时调用标准库函数，如 <code>sin</code> 和 <code>cos</code>。</p><h1 id="函数相关代码生成"><a href="#函数相关代码生成" class="headerlink" title="函数相关代码生成"></a>函数相关代码生成</h1><p>函数和原型的代码生成涉及一系列的细节处理，这也使得其代码实现不如表达式代码生成实现那么简洁优雅。下面，我们来分别介绍函数原型和函数定义的代码生成。</p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>函数原型的代码生成也可以应用于函数定义和外部原型。如下所示，为函数原型的代码生成方法定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">PrototypeAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make the function type:  double(double,double) etc.</span></span><br><span class="line">    <span class="function">std::vector&lt;Type *&gt; <span class="title">Doubles</span><span class="params">(Args.size(), Type::getDoubleTy(*TheContext))</span></span>;</span><br><span class="line">    FunctionType *FT = FunctionType::<span class="built_in">get</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), Doubles, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Function *F = Function::<span class="built_in">Create</span>(FT, Function::ExternalLinkage, Name, TheModule.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set names for all arguments.</span></span><br><span class="line">    <span class="type">unsigned</span> Idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : F-&gt;<span class="built_in">args</span>())</span><br><span class="line">        Arg.<span class="built_in">setName</span>(Args[Idx++]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PrototypeAST::codegen</code> 函数返回的类型是 <code>Function *</code>，而不是 <code>Value</code>。本质上，原型用于描述函数的外部接口，而不是表达式计算的值，因此其返回代码生成时对应的 LLVM 函数，即 <code>Function *</code> 类型。</p><p><code>FunctionType::get</code> 函数为原型创建函数类型 <code>FunctionType</code>。由于 Kaleidoscope 中的所有函数参数都是双精度类型，因此在调用 <code>FunctionType::get</code> 之前，我们根据参数的数量 <code>Args.siz()</code> 创建了一个包含 <code>N</code> 个 LLVM 双精度类型的向量。然后，使用 <code>FunctionType::get</code> 方法创建一个函数类型，该函数类型接受 <code>N</code> 个双精度类型的值作为参数，返回一个双精度类型的值作为结果。</p><p><code>Function::Create</code> 函数使用函数类型创建 IR 函数，其指定函数类型、链接和名称，以及写入的目标模块。<strong>外部链接（External Linkage）</strong> 表示该函数可以在当前模块外部进行定义，或者可以被模块外部的函数所调用。传入的 <code>Name</code> 参数表示用户指定的名称，由于指定了 <code>TheModule</code>，因此该名称会被注册在 <code>TheModule</code> 的符号表中。</p><p>最后，我们为每个函数参数设置名称。这个步骤并非必要，但保持名称一致会使 IR 更具有更好的可读性，并且允许后续代码直接引用参数名称，而不必在原型的 AST 中进行查找。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>如下所示，为函数定义的代码生成方法定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Function *<span class="title">FunctionAST::codegen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First, check for an existing function from a previous &#x27;extern&#x27; declaration.</span></span><br><span class="line">    Function *TheFunction = TheModule-&gt;<span class="built_in">getFunction</span>(Proto-&gt;<span class="built_in">getName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">        TheFunction = Proto-&gt;<span class="built_in">codegen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TheFunction)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new basic block to start insertion into.</span></span><br><span class="line">    BasicBlock *BB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;entry&quot;</span>, TheFunction);</span><br><span class="line">    Builder-&gt;<span class="built_in">SetInsertPoint</span>(BB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the function arguments in the NamedValues map.</span></span><br><span class="line">    NamedValues.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Arg : TheFunction-&gt;<span class="built_in">args</span>())</span><br><span class="line">        NamedValues[std::<span class="built_in">string</span>(Arg.<span class="built_in">getName</span>())] = &amp;Arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Value *RetVal = Body-&gt;<span class="built_in">codegen</span>()) &#123;</span><br><span class="line">        <span class="comment">// Finish off the function.</span></span><br><span class="line">        Builder-&gt;<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the generated code, checking for consistency.</span></span><br><span class="line">        <span class="built_in">verifyFunction</span>(*TheFunction);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TheFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error reading body, remove function.</span></span><br><span class="line">    TheFunction-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数定义，我们首先在模块的符号表中查找该函数的已有版本。如果 <code>Module::getFunction</code> 返回 <code>null</code> 则表示不存在，因此我们将通过 <code>Proto-&gt;codegen</code> 来生成。</p><p>然后，我们对 <code>Builder</code> 进行设置，具体分为两个步骤：</p><ul><li>通过 <code>BasicBlock::Create</code> 函数创建一个 <strong>基本块</strong>（Basic Block），基本块随后被插入到 <code>TheFunction</code> 中。</li><li>通过 <code>Builder-&gt;SetInsertPoint</code> 函数设置基本块的末尾为指令的插入位置。LLVM 中的基本块是定义 <strong>控制流图</strong>（Control Flow Graph）中的函数的重要组成部分。 由于我们没有任何控制流语句，我们的函数此时只包含一个基本块。</li></ul><p>随后，我们将函数参数添加到 <code>NamedValues</code> 符号表中，以便 <code>VariableExprAST</code> 节点进行访问。</p><p>当设置了代码插入点并注册了 <code>NamedValues</code> 符号表后，我们开始对函数体执行 <code>codegen()</code> 方法。如果没有发生错误，我们会进而创建一个 LLVM <code>ret</code> 指令，表示函数的终止。当函数构建完成后，我们调用 LLVM 的 <code>verifyFunction</code> 函数对生成的代码进行各种一致性检查，以确保我们的编译器是否一切正常。<code>verifyFunction</code> 函数非常重要，它能够检测出很多 bug。检测完毕且无错误，我们返回构造的函数。</p><p>最后的实现逻辑是错误处理。当错误发生时，我们仅通过调用 <code>eraseFromParent</code> 函数来删除过程中生成的函数。这样能够允许用户重新定义他们之前输入的错误函数，如果我们不删除它，它将存在于符号表中，并且无法重新定义。</p><h1 id="驱动器适配"><a href="#驱动器适配" class="headerlink" title="驱动器适配"></a>驱动器适配</h1><p>为了进行测试，我们对驱动器了进行简单的适配，将对 <code>codegen</code> 的调用插入到 <code>HandleDefinition</code>、<code>HandleExtern</code> 等函数，并在其内部打印 LLVM IR。</p><p>对于顶层二元表达式，LLVM IR 的代码生成结果如下所示。我们可以看到解析器如何为将顶层表达式转换为匿名函数的，这对于我们后续支持 JIT 是非常有用的。此外，我们可以看到生成的 IR 是逐字翻译的，除了常量合并，没有作其他任何优化。在后续的文章中，我们会显式地进行优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="number">4</span>+<span class="number">5</span>;</span><br><span class="line">Read top-level expression:</span><br><span class="line">define <span class="type">double</span> @__anon_expr() &#123;</span><br><span class="line">entry:</span><br><span class="line">  ret <span class="type">double</span> <span class="number">9.000000e+00</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于简单的函数定义，如下所示，分别是 LLVM IR 的代码生成结果，以及生成过程的示意图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(a b)</span> a*a + 2*a*b + b*b</span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %a, <span class="type">double</span> %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul <span class="type">double</span> %a, %a</span><br><span class="line">  %multmp1 = fmul <span class="type">double</span> <span class="number">2.000000e+00</span>, %a</span><br><span class="line">  %multmp2 = fmul <span class="type">double</span> %multmp1, %b</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %multmp, %multmp2</span><br><span class="line">  %multmp3 = fmul <span class="type">double</span> %b, %b</span><br><span class="line">  %addtmp4 = fadd <span class="type">double</span> %addtmp, %multmp3</span><br><span class="line">  ret <span class="type">double</span> %addtmp4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-06.png?x-oss-process=image/resize,w_800"></p><p>对于简单的函数调用，LLVM IR的代码生成结果如下所示。当我们调用 <code>bar</code> 函数时，其会消耗比较长的时间执行完毕。后续，我们添加条件控制流来优化递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">bar</span><span class="params">(a)</span> <span class="title">foo</span><span class="params">(a, <span class="number">4.0</span>)</span> + <span class="title">bar</span><span class="params">(<span class="number">31337</span>)</span></span>;</span><br><span class="line">Read function definition:</span><br><span class="line">define <span class="type">double</span> @<span class="built_in">bar</span>(<span class="type">double</span> %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">foo</span>(<span class="type">double</span> %a, <span class="type">double</span> <span class="number">4.000000e+00</span>)</span><br><span class="line">  %calltmp1 = call <span class="type">double</span> @<span class="built_in">bar</span>(<span class="type">double</span> <span class="number">3.133700e+04</span>)</span><br><span class="line">  %addtmp = fadd <span class="type">double</span> %calltmp, %calltmp1</span><br><span class="line">  ret <span class="type">double</span> %addtmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示，为声明外部 <code>cos</code> 函数以及调用 <code>cos</code> 函数的 IR 代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(x)</span></span>;</span><br><span class="line">Read <span class="keyword">extern</span>:</span><br><span class="line">declare <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line">ready&gt; <span class="built_in">cos</span>(<span class="number">1.234</span>);</span><br><span class="line">Read top-level expression:</span><br><span class="line">define <span class="type">double</span> @__anon_expr() &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call <span class="type">double</span> @<span class="built_in">cos</span>(<span class="type">double</span> <span class="number">1.234000e+00</span>)</span><br><span class="line">  ret <span class="type">double</span> %calltmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们退出测试进程时（MacOS 系统，输入 <code>cmd+D</code>），其会打印生成的 Module 的所有 IR 代码。我们可以看到很多方法相互引用，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; ^D</span><br><span class="line">; ModuleID = <span class="string">&#x27;my cool jit&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;my cool jit&quot;</span></span><br><span class="line"></span><br><span class="line">define double @foo(double %a, double %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %multmp = fmul double %a, %a</span><br><span class="line">  %multmp1 = fmul double 2.000000e+00, %a</span><br><span class="line">  %multmp2 = fmul double %multmp1, %b</span><br><span class="line">  %addtmp = fadd double %multmp, %multmp2</span><br><span class="line">  %multmp3 = fmul double %b, %b</span><br><span class="line">  %addtmp4 = fadd double %addtmp, %multmp3</span><br><span class="line">  ret double %addtmp4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define double @bar(double %a) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %calltmp = call double @foo(double %a, double 4.000000e+00)</span><br><span class="line">  %calltmp1 = call double @bar(double 3.133700e+04)</span><br><span class="line">  %addtmp = fadd double %calltmp, %calltmp1</span><br><span class="line">  ret double %addtmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">declare</span> double @cos(double)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文，我们为解析器支持了 LLVM IR 代码生成功能，后续在此基础上，为 Kaleidoscope 支持 JIT 代码生成以及优化器。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.html">Kaleidoscope: Code generation to LLVM IR</a></li><li><a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static single-assignment form</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在上一章中，我们介绍了如何构建抽象语法树 AST。这一章，我们进一步将抽象语法树转换成 LLVM IR。此外，我们会简单介绍 LLVM 的工</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="LLVM IR" scheme="http://chuquan.me/tags/LLVM-IR/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(2)——解析器、抽象语法树</title>
    <link href="http://chuquan.me/2022/07/31/compiler-for-kaleidoscope-02/"/>
    <id>http://chuquan.me/2022/07/31/compiler-for-kaleidoscope-02/</id>
    <published>2022-07-31T06:31:22.000Z</published>
    <updated>2023-01-14T03:12:27.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本章，我们将基于词法分析器，为 Kaleidoscope 构建一个完整的解析器（Parser）。通过解析器，我们可以定义并构造抽象语法树（Abstract Syntax Tree，AST）。</p><p>我们构造的解析器使用两种方法进行语法分析：</p><ul><li><strong>递归下降分析法（Recursive Descent Parsing）</strong>：用于基本表达式的解析。</li><li><strong>算符优先分析法（Operator-Precedence Parsing）</strong>：用于二元表达式的解析。</li></ul><p>在实现解析器之前，我们先来介绍一下解析器的输出——抽象语法树。</p><h1 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h1><p><strong>抽象语法树（AST）为编译器后续的各个阶段提供了一种易于解释的表示形式</strong>，比如：代码生成。通常，我们希望编程语言中的每一种结构都有一个对应的表示对象。为了实现这种映射关系，我们使用 AST 对语言进行分析建模。</p><p>在 Kaleidoscope 的 AST 中，我们设计了三种结构，分别是：</p><ul><li><strong>表达式</strong></li><li><strong>原型</strong></li><li><strong>函数</strong></li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>如下所示，<code>ExprAST</code> 是 AST 中表达式的基类定义，其包含了多种子类定义，分别用于对应不同的具体表达式。由于 Kaleidoscope 只有一种数据类型——双精度浮点类型，因此我们没有必要存储类型信息。当然，现实的编程语言通常都包含多种类型，这种情况下 <code>ExprAST</code> 会包含一个用于存储类型信息的字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// ExprAST - Base class for all expression nodes.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExprAST</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ExprAST</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下所示为 <code>ExprAST</code> 的各种子类定义，分别是：</p><ul><li><code>NumberExprAST</code>：用于表示 <strong>数值表达式</strong>，其捕获字面量的数值保存于 <code>Val</code> 中。</li><li><code>VariableExprAST</code>：用于表示 <strong>变量表达式</strong>，其捕获变量名保存于 <code>Name</code> 中。</li><li><code>BinaryExprAST</code>：用于表示 <strong>二元表达式</strong>，其使用 <code>Op</code> 保存操作符，如：<code>+</code>。使用 <code>LHS</code> 和 <code>RHS</code> 分别保存左子表达式和右子表达式。</li><li><code>CallExprAST</code>：用于表示 <strong>函数调用表达式</strong>，其使用 <code>Callee</code> 保存函数名。使用 <code>Args</code> 数组变量保存函数的各个参数。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-03.png?x-oss-process=image/resize,w_800"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    <span class="type">double</span> Val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberExprAST</span>(<span class="type">double</span> Val) : <span class="built_in">Val</span>(Val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    std::string Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VariableExprAST</span>(<span class="type">const</span> std::string &amp;Name) : <span class="built_in">Name</span>(Name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// BinaryExprAST - Expression class for a binary operator.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    <span class="type">char</span> Op;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; LHS, RHS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryExprAST</span>(<span class="type">char</span> op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : <span class="built_in">Op</span>(op), <span class="built_in">LHS</span>(std::<span class="built_in">move</span>(LHS)), <span class="built_in">RHS</span>(std::<span class="built_in">move</span>(RHS)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CallExprAST - Expression class for function calls.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallExprAST</span> : <span class="keyword">public</span> ExprAST &#123;</span><br><span class="line">    std::string Callee;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CallExprAST</span>(<span class="type">const</span> std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args) : <span class="built_in">Callee</span>(Callee), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于仅包含基本功能的编程语言而言，上述为全部的 AST 表达式节点定义。由于不包含条件控制流，因此这并不是图灵完备的；对此，我们将在后面进一步对其进行优化。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-04.png?x-oss-process=image/resize,w_800"></p><p>如下所示，<code>PrototypeAST</code> 为 AST 中原型（Prototype）的定义。原型用于表示一个函数的原型，用于捕获函数的名称，各个参数的名称等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrototypeAST</span> &#123;</span><br><span class="line">    std::string Name;</span><br><span class="line">    std::vector&lt;std::string&gt; Args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrototypeAST</span>(<span class="type">const</span> std::string &amp;name, std::vector&lt;std::string&gt; Args) : <span class="built_in">Name</span>(name), <span class="built_in">Args</span>(std::<span class="built_in">move</span>(Args)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp;<span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-05.png?x-oss-process=image/resize,w_800"></p><p>如下所示，<code>FunctionAST</code> 为 AST 中函数的定义。函数由函数原型和函数体组成，其分别使用 <code>Proto</code> 和 <code>Body</code> 进行存储。其中函数体是一个 AST 表达式结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionAST</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;PrototypeAST&gt; Proto;</span><br><span class="line">    std::unique_ptr&lt;ExprAST&gt; Body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FunctionAST</span>(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : <span class="built_in">Proto</span>(std::<span class="built_in">move</span>(Proto)), <span class="built_in">Body</span>(std::<span class="built_in">move</span>(Body)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="解析器基础"><a href="#解析器基础" class="headerlink" title="解析器基础"></a>解析器基础</h1><p>上文，我们定义了 AST 的结构，包括各种类型的节点。下面，我们来介绍如何通过解析器构建 AST。例如，对于表达式 <code>x+y</code> 可以通过如下方式将其解析成 AST。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> LHS = std::<span class="built_in">make_unique</span>&lt;VariableExprAST&gt;(<span class="string">&quot;x&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> RHS = std::<span class="built_in">make_unique</span>&lt;VariableExprAST&gt;(<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> Result = std::<span class="built_in">make_unique</span>&lt;BinaryExprAST&gt;(<span class="string">&#x27;+&#x27;</span>, std::<span class="built_in">move</span>(LHS), std::<span class="built_in">move</span>(RHS));</span><br></pre></td></tr></table></figure><p>为此，我们需要实现一些辅助函数，如下所示。我们通过 <code>CurToken</code> 作为词法分析器的输出 token 缓冲区。解析器内部每次调用词法分析器，输出一个 token，存储在缓冲区中。解析器则通过读取 <code>CurToken</code> 用于后续的解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current</span></span><br><span class="line"><span class="comment">/// token the parser is looking at.  getNextToken reads another token from the</span></span><br><span class="line"><span class="comment">/// lexer and updates CurTok with its results.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> CurTok;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNextToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CurTok = <span class="built_in">gettok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了处理错误，我们还定义了 <code>LogError</code> 函数。这里我们对于不同类型的错误处理均返回 <code>nullptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// LogError* - These are little helper functions for error handling.</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ExprAST&gt; <span class="title">LogError</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;LogError: %s\n&quot;</span>, Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::unique_ptr&lt;PrototypeAST&gt; <span class="title">LogErrorP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LogError</span>(Str);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="表达式解析"><a href="#表达式解析" class="headerlink" title="表达式解析"></a>表达式解析</h1><p>Kaleidoscope 文法的每一个产生式，我们定义一个对应的解析函数。关于表达式的解析，其实可以分为以下几种类型：</p><ul><li><strong>数值表达式</strong>：解析 <code>NumberExprAST</code>。</li><li><strong>括号表达式</strong>：解析 <code>BinaryExprAST</code>。</li><li><strong>标识符表达式</strong>：解析两种 AST 类型 <code>VariableExprAST</code> 和 <code>CallExprAST</code>。</li></ul><p>下面我们分别进行介绍。</p><h2 id="数值表达式"><a href="#数值表达式" class="headerlink" title="数值表达式"></a>数值表达式</h2><p>对于数值表达式，我们定义如下解析函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// numberexpr ::= number</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseNumberExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Result = std::<span class="built_in">make_unique</span>&lt;NumberExprAST&gt;(NumVal);</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// consume the number</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当词法分析器分析当前 token 的类型为 <code>tok_number</code> 时，解析器会调用 <code>ParseNumberExpr</code> 解析函数，读取全局变量 <code>NumVal</code>，从而获取数值，最终创建并返回一个 <code>NumberExprAST</code> 节点。</p><p>在 <code>ParseNumberExpr</code> 解析函数中，它将读取所有与产生式相关的 token，并将下一个 token 写入词法分析器缓存 <code>CurTok</code> 中，以用于后续的分析。这其实是递归下降分析的标准方式，即 <strong>预测分析</strong>——提前读取下一个 token 进行分析，避免深度优先搜索带来回溯开销。</p><h2 id="括号表达式"><a href="#括号表达式" class="headerlink" title="括号表达式"></a>括号表达式</h2><p>对于括号表达式，我们定义如下解析函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// parenexpr ::= &#x27;(&#x27; expression &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseParenExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat (.</span></span><br><span class="line">  <span class="keyword">auto</span> V = <span class="built_in">ParseExpression</span>();</span><br><span class="line">  <span class="keyword">if</span> (!V)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;expected &#x27;)&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">getNextToken</span>(); <span class="comment">// eat ).</span></span><br><span class="line">  <span class="keyword">return</span> V;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ParseParenExpr</code> 解析函数中，我们可以看到对于 <code>LogError</code> 的使用。当调用 <code>LogError</code> 时，表示当前 token 是 <code>(</code>，在解析完子表达式之后，发现并没有与之匹配的 <code>)</code>。比如，当我们使用 <code>(4 x</code> 替代 <code>(4)</code> 作为输入，解析器就会调用 <code>LogError</code> 进行报错处理。</p><p>除此之外，我们还可以发现内部递归调用了 <code>ParseExpression</code> 解析函数（后面我们会提到该函数）。通过递归调用，解析器能够处理递归语法，从而简化每一个文法产生式，最终返创建并返回一个 <code>BinaryExprAST</code> 节点。</p><p>注意，括号并不会构建 AST 节点，其最大的作用是辅助解析器进行分组。当 AST 构建完毕，括号也就不需要了。</p><h2 id="标识符表达式"><a href="#标识符表达式" class="headerlink" title="标识符表达式"></a>标识符表达式</h2><p>对于标识符表达式，我们定义如下解析函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法表达式</span></span><br><span class="line"><span class="comment">/// identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= identifier</span></span><br><span class="line"><span class="comment">///   ::= identifier &#x27;(&#x27; expression* &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseIdentifierExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string IdName = IdentifierStr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat identifier.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>) <span class="comment">// Simple variable ref.</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;VariableExprAST&gt;(IdName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat (</span></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Arg = <span class="built_in">ParseExpression</span>())</span><br><span class="line">        Args.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(Arg));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CurTok != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;Expected &#x27;)&#x27; or &#x27;,&#x27; in argument list&quot;</span>);</span><br><span class="line">      <span class="built_in">getNextToken</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eat the &#x27;)&#x27;.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;CallExprAST&gt;(IdName, std::<span class="built_in">move</span>(Args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析器会在当前 token 类型为 <code>tok_identifier</code> 时调用 <code>ParseIdentifierExpr</code> 解析函数。其内部同样实现了递归分析和错处处理，并且通过预测分析的方式来判断当前的标识符是变量引用表达式还是函数调用表达式，从而分别进行处理。这里的预测分析是通过判断当前 <code>token</code> 下一个 token 是否是 <code>(</code> 实现的，从而分别构建 <code>VariableExprAST</code> 节点和 <code>CallExprAST</code> 节点。</p><h2 id="主表达式"><a href="#主表达式" class="headerlink" title="主表达式"></a>主表达式</h2><p>我们将四种类型的表达式统称为 <strong>主表达式（Primary Expression）</strong>。<br>为了方便外部对各种类型的表达式进行解析，我们提供一个主表达式解析函数，对外隐藏细节，对内提供实现，该解析方法如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// primary</span></span><br><span class="line"><span class="comment">///   ::= identifierexpr</span></span><br><span class="line"><span class="comment">///   ::= numberexpr</span></span><br><span class="line"><span class="comment">///   ::= parenexpr</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParsePrimary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogError</span>(<span class="string">&quot;unknown token when expecting an expression&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> tok_identifier:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseIdentifierExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> tok_number:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseNumberExpr</span>();</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ParseParenExpr</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParsePrimary</code> 解析函数的实现逻辑非常清晰，即通过读取 <code>CurTok</code> 进行预测分析，判断 token 类型，并调用对应解析函数，从而构建 AST。</p><h1 id="二元表达式解析"><a href="#二元表达式解析" class="headerlink" title="二元表达式解析"></a>二元表达式解析</h1><p>二元表达式是表达式的一种，相比于其他三种表达式，二元表达式（Binary Expression）解析会更加复杂，因为它们通常具有二义性。比如，当我们输入字符串 <code>x+y*z</code>，解析器可以解析成 <code>(x+y)*z</code> 或 <code>x+(y*z)</code>。基于数学定义，我们期望解析器能将其解析为后者，因为乘法 <code>*</code> 的优先级是高于加法 <code>+</code> 的。</p><p>处理二义性的方式很多，其中一种优雅且高效的方式是 <strong>算符优先分析法</strong>。这种分析技术通过为操作符定义优先级来辅助递归分析。比如，我们可以通过如下方式来定义优先级。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// BinopPrecedence - This holds the precedence for each binary operator that is</span></span><br><span class="line"><span class="comment">/// defined.</span></span><br><span class="line"><span class="type">static</span> std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; BinopPrecedence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GetTokPrecedence - Get the precedence of the pending binary operator token.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetTokPrecedence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isascii</span>(CurTok))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure it&#x27;s a declared binop.</span></span><br><span class="line">  <span class="type">int</span> TokPrec = BinopPrecedence[CurTok];</span><br><span class="line">  <span class="keyword">if</span> (TokPrec &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> TokPrec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Install standard binary operators.</span></span><br><span class="line">  <span class="comment">// 1 is lowest precedence.</span></span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;&lt;&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;+&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;-&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">  BinopPrecedence[<span class="string">&#x27;*&#x27;</span>] = <span class="number">40</span>;  <span class="comment">// highest.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以二元运算符为键，优先级为值存储于哈希表中，便于进行扩展。在 Kaleidoscope 中，我们仅支持 4 种二元运算符。<code>GetTokPrecedence</code> 函数根据当前 token 从哈希表中读取对应的优先级，如果 token 不是二元运算符，则返回 -1。</p><p><strong>算符优先分析法的基本思想是：将具有二义性二元运算符的表达式分解为多个片段，依次进行解析</strong>。比如，对于表达式 <code>a+b+(c+d)*e*f+g</code>。算符优先分析法会将其视为一系列由二元运算符分隔的主表达式。因此，解析器会首先分析头部的主表达式 <code>a</code>，然后依次分析 <code>[+, b]</code>，<code>[+, (c+d)]</code>，<code>[*, e]</code>，<code>[*, f]</code>，<code>[+, g]</code>。由于括号表达式也是主表达式，因此二元表达式的解析并不需要关注类似 <code>(c+d)</code> 这样的嵌套子表达式。</p><p>下面，我们来看一下具体的实现。</p><p>首先，我们将表达式分解为 <strong>一个主表达式+多个<code>[binop, primaryexpr]</code></strong> 的形式，对应的解析函数如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// expression</span></span><br><span class="line"><span class="comment">///   ::= primary binoprhs</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> LHS = <span class="built_in">ParsePrimary</span>();</span><br><span class="line">  <span class="keyword">if</span> (!LHS)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ParseBinOpRHS</span>(<span class="number">0</span>, std::<span class="built_in">move</span>(LHS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseBinOpRHS</code> 函数用于解析 <code>[binop, primaryexpr]</code> 序列，其入参包含两个：<strong>优先级</strong>、<strong>已解析的表达式指针</strong>。值得注意的是，表达式 <code>x</code> 其实也是一个有效的表达式，在这种文法表达式 <code>binoprhs</code> 为空的情况下，<code>ParseBinOpRHS</code> 解析函数会将传入的已解析的表达式指针直接返回。</p><p><code>ParseBinOpRHS</code> 函数的优先级的参数表示 <strong>最小算符优先级</strong>（Minimal Operator Precedence），即函数能够允许读取的运算符。比如，如果当前的分析内容是 <code>[+, x]</code>，而传入 <code>ParseBinOpRHS</code> 函数的优先级为 40，那么函数不会读取任何 token，因为 <code>+</code> 的优先级为 20。</p><p><code>ParseBinOpRHS</code> 函数的具体定义如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// binoprhs</span></span><br><span class="line"><span class="comment">///   ::= (&#x27;+&#x27; primary)*</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;ExprAST&gt; <span class="title">ParseBinOpRHS</span><span class="params">(<span class="type">int</span> ExprPrec,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              std::unique_ptr&lt;ExprAST&gt; LHS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If this is a binop, find its precedence.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> TokPrec = <span class="built_in">GetTokPrecedence</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a binop that binds at least as tightly as the current binop,</span></span><br><span class="line">    <span class="comment">// consume it, otherwise we are done.</span></span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; ExprPrec)</span><br><span class="line">      <span class="keyword">return</span> LHS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Okay, we know this is a binop.</span></span><br><span class="line">    <span class="type">int</span> BinOp = CurTok;</span><br><span class="line">    <span class="built_in">getNextToken</span>(); <span class="comment">// eat binop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the primary expression after the binary operator.</span></span><br><span class="line">    <span class="keyword">auto</span> RHS = <span class="built_in">ParsePrimary</span>();</span><br><span class="line">    <span class="keyword">if</span> (!RHS)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If BinOp binds less tightly with RHS than the operator after RHS, let</span></span><br><span class="line">    <span class="comment">// the pending operator take RHS as its LHS.</span></span><br><span class="line">    <span class="type">int</span> NextPrec = <span class="built_in">GetTokPrecedence</span>();</span><br><span class="line">    <span class="keyword">if</span> (TokPrec &lt; NextPrec) &#123;</span><br><span class="line">      RHS = <span class="built_in">ParseBinOpRHS</span>(TokPrec + <span class="number">1</span>, std::<span class="built_in">move</span>(RHS));</span><br><span class="line">      <span class="keyword">if</span> (!RHS)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge LHS/RHS.</span></span><br><span class="line">    LHS =</span><br><span class="line">        std::<span class="built_in">make_unique</span>&lt;BinaryExprAST&gt;(BinOp, std::<span class="built_in">move</span>(LHS), std::<span class="built_in">move</span>(RHS));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>ParseBinOpRHS</code> 函数内部，它会首先读取当前 token 的优先级。如果优先级低于设定 <code>ExprPrec</code>，则直接返回传入的已解析的表达式 <code>LHS</code>。如果优先级符合设定，那么将解析操作符之后的主表达式。</p><p>此时，我们已经解析了表达式的左部以及 RHS 序列的一个分段。接下来，我们需要决定如何关联表达式。比如，这里有两种关联方式：<code>(a+b) binop &lt;未解析部分&gt;</code> 或 <code>a + (b binop &lt;未解析部分&gt;)</code>。为此，我们通过预测分析的方式，继续向前读取一个运算符的优先级，并与 <code>BinOp</code> 的优先级进行比较（例子中是 <code>+</code>）。</p><p>如果 <code>RHS</code> 右边的运算符的优先级小于或等于当前操作符，那么我们选择 <code>(a+b) binop &lt;未解析部分&gt;</code> 的关联方式。在例子中，当前的运算符和下一个运算符都是 <code>+</code>，具有相同的优先级。</p><p>在例子中，解析函数会将 <code>a+b+</code> 解析为 <code>(a+b)</code>，并在下一次循环中继续执行。接下来，它会将 <code>(c+d)</code> 作为主表达式进行解析，即直接解析 <code>[+, (c+d)]</code>。继续解析，则会遇到 <code>*</code> 运算符。由于 <code>*</code> 的优先级大于 <code>+</code>，因此将执行 <code>if</code> 语句的内部逻辑。其内部逻辑会对高优先级的部分作为进行整体解析，然后将其作为低优先级运算符右部。为此，我们递归地调用 <code>ParseBinOpRHS</code> 函数，并指定最低优先级为 <code>TokPrec+1</code>。在例子中，会将 <code>(c+d)*e*f</code> 作为 <code>+</code> 的 <code>RHS</code>。</p><p>最后，<code>[+, g]</code> 会在下一次循环中被解析。</p><p>此时，我们可以使用解析器对任意 token 序列进行解析并构建表达式。当检测到不属于表达式的 token 时停止解析。</p><h1 id="函数相关解析"><a href="#函数相关解析" class="headerlink" title="函数相关解析"></a>函数相关解析</h1><p>关于函数相关的解析，其实可以分为几种类型：</p><ul><li><strong>函数原型</strong></li><li><strong>函数定义</strong></li><li><strong>外部原型</strong></li></ul><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>对于函数原型，我们定义如下解析函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// prototype</span></span><br><span class="line"><span class="comment">///   ::= id &#x27;(&#x27; id* &#x27;)&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParsePrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (CurTok != tok_identifier)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected function name in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  std::string FnName = IdentifierStr;</span><br><span class="line">  <span class="built_in">getNextToken</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;(&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the list of argument names.</span></span><br><span class="line">  std::vector&lt;std::string&gt; ArgNames;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getNextToken</span>() == tok_identifier)</span><br><span class="line">    ArgNames.<span class="built_in">push_back</span>(IdentifierStr);</span><br><span class="line">  <span class="keyword">if</span> (CurTok != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LogErrorP</span>(<span class="string">&quot;Expected &#x27;)&#x27; in prototype&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// success.</span></span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat &#x27;)&#x27;.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;PrototypeAST&gt;(FnName, std::<span class="built_in">move</span>(ArgNames));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>对于函数定义，我们定义如下解析函数。其本质上就是函数原型与普通表达式的组合，后者用于表示函数体，如下图所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// definition ::= &#x27;def&#x27; prototype expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat def.</span></span><br><span class="line">  <span class="keyword">auto</span> Proto = <span class="built_in">ParsePrototype</span>();</span><br><span class="line">  <span class="keyword">if</span> (!Proto) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>())</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-05.png?x-oss-process=image/resize,w_800"></p><h2 id="外部原型"><a href="#外部原型" class="headerlink" title="外部原型"></a>外部原型</h2><p>对于外部原型，我们定义如下解析函数。其本质上就是 <code>extern</code> 关键字与函数原型的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// external ::= &#x27;extern&#x27; prototype</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;PrototypeAST&gt; <span class="title">ParseExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">getNextToken</span>();  <span class="comment">// eat extern.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ParsePrototype</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="顶层表达式解析"><a href="#顶层表达式解析" class="headerlink" title="顶层表达式解析"></a>顶层表达式解析</h1><p>为了允许用户输入任意的顶层表达式，并支持解析。我们定义一个匿名空值（零参数）函数来进行解析，如下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// toplevelexpr ::= expression</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;FunctionAST&gt; <span class="title">ParseTopLevelExpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> E = <span class="built_in">ParseExpression</span>()) &#123;</span><br><span class="line">    <span class="comment">// Make an anonymous proto.</span></span><br><span class="line">    <span class="keyword">auto</span> Proto = std::<span class="built_in">make_unique</span>&lt;PrototypeAST&gt;(<span class="string">&quot;__anon_expr&quot;</span>, std::<span class="built_in">vector</span>&lt;std::string&gt;());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;FunctionAST&gt;(std::<span class="built_in">move</span>(Proto), std::<span class="built_in">move</span>(E));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ParseTopLevelExpr</code> 解析函数会通过调用 <code>ParseExpression</code> 解析函数进行解析。当解析得到 <code>BinaryExprAST</code> 节点后，创建一个 <code>PrototypeAST</code> 节点，并使用 <code>FunctionAST</code> 节点将两者封装成一个匿名函数，最终返回 <code>FunctionAST</code> 节点。</p><p>至此，我们介绍了各种类型的表达式的解析，下面我们通过实现一个驱动器来对实际的代码进行解析。</p><h1 id="驱动器"><a href="#驱动器" class="headerlink" title="驱动器"></a>驱动器</h1><p>驱动器（Driver）的实现如下所示，其仅仅是在一个顶层的循环中调用所有类型的表达式解析函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ParseDefinition</span>()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed a function definition.\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleExtern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ParseExtern</span>()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed an extern\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">HandleTopLevelExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Evaluate a top-level expression into an anonymous function.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ParseTopLevelExpr</span>()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Parsed a top-level expr\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Skip token for error recovery.</span></span><br><span class="line">    <span class="built_in">getNextToken</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 文法产生式</span></span><br><span class="line"><span class="comment">/// top ::= definition | external | expression | &#x27;;&#x27;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ready&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (CurTok) &#123;</span><br><span class="line">    <span class="keyword">case</span> tok_eof:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>: <span class="comment">// ignore top-level semicolons.</span></span><br><span class="line">      <span class="built_in">getNextToken</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_def:</span><br><span class="line">      <span class="built_in">HandleDefinition</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> tok_extern:</span><br><span class="line">      <span class="built_in">HandleExtern</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">HandleTopLevelExpression</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这里我们对顶层的分号进行了忽略处理。原因是，如果我们在命令行中输入 <code>4 + 5</code>，解析器并不是我们输入的内容是否结束。例如，我们可以在下一行输入 <code>def foo...</code>，在这种情况下，<code>4 + 5</code> 是顶层表达式的结尾，或者，我们可以输入 <code>* 6</code> 来续写表达式。对此，使用顶层分号，对应 <code>4 + 5;</code> 表达式，解析器才能知道表达式已经输入完成。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过 400 多行代码，我们定义了一门简单的语言，包括词法分析器、解析器和 AST 构造器。完成之后，我们可以通过可执行文件来验证 Kaleidoscope 代码，从而判断代码是否存储语法语义错误。</p><p>如下所示，为验证步骤及其结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x y)</span> x+<span class="title">foo</span><span class="params">(y, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x y)</span> x+y y</span>;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">Parsed a top-level expr</span><br><span class="line">ready&gt; <span class="function">def <span class="title">foo</span><span class="params">(x y)</span> x+y )</span>;</span><br><span class="line">Parsed a function definition.</span><br><span class="line">Error: unknown token when expecting an expression</span><br><span class="line">ready&gt; <span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(a)</span></span>;</span><br><span class="line">ready&gt; Parsed an <span class="keyword">extern</span></span><br><span class="line">ready&gt; ^C</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>当然，代码仍然具有很大的扩展空间。我们可以定义新的 AST 节点，并以多种方式对语言进行扩展等。下一章，我们将介绍如何从 AST 生成 LLVM 中间表示 <code>IR</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本章，我们将基于词法分析器，为 Kaleidoscope 构建一个完整的解析器（Parser）。通过解析器，我们可以定义并构造抽象语法树（A</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="Parser" scheme="http://chuquan.me/tags/Parser/"/>
    
    <category term="AST" scheme="http://chuquan.me/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>基于 LLVM 自制编译器(1)——Kaleidoscope、词法分析器</title>
    <link href="http://chuquan.me/2022/07/24/compiler-for-kaleidoscope-01/"/>
    <id>http://chuquan.me/2022/07/24/compiler-for-kaleidoscope-01/</id>
    <published>2022-07-24T07:47:03.000Z</published>
    <updated>2023-01-14T03:12:16.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kaleidoscope"><a href="#Kaleidoscope" class="headerlink" title="Kaleidoscope"></a>Kaleidoscope</h1><p>本教程我们将从零开始设计一门玩具版编程语言——Kaleidoscope。Kaleidoscope 支持函数定义、条件语句、数学运算等。在教程的各个章节中，我们将对 Kaleidoscope 的语言特性进行扩展，支持 <code>if/then/else</code> 语句、<code>for</code> 循环、自定义操作符、JIT 编译、调试信息等。</p><p>为了简化数据类型，我们设计的 Kaleidoscope 只有一种数据类型是 64 位浮点类型，即 C 语言中的 <code>double</code> 类型。因此，所有值都是隐式双精度类型，并且无需进行类型声明。如下所示，为基于 Kaleidoscope 的斐波那契计算方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">fib</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x &lt; 3 then</span></span><br><span class="line"><span class="function">    1</span></span><br><span class="line"><span class="function">  <span class="keyword">else</span></span></span><br><span class="line"><span class="function">    <span class="title">fib</span><span class="params">(x<span class="number">-1</span>)</span>+<span class="title">fib</span><span class="params">(x<span class="number">-2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">40</span>)</span></span></span><br></pre></td></tr></table></figure><p>此外，我们将支持 Kaleidoscope 调用标准库函数。因此，我们可以在使用函数之前使用 <code>extern</code> 关键字来定义函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">sin</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">cos</span><span class="params">(arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">atan2</span><span class="params">(arg1 arg2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">atan2</span>(<span class="built_in">sin</span>(<span class="number">.4</span>), <span class="built_in">cos</span>(<span class="number">42</span>))</span><br></pre></td></tr></table></figure><p>下面，我们开始为 Kaleidoscope 语言逐步实现编译器吧！</p><h1 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h1><p>事实上，实现编程语言的本质其实是实现编程语言的编译器。首先，我们要实现编译器的文本处理与内容识别能力，即 <strong>词法分析器</strong>（Lexer）。词法分析器将输入内容分解为 <strong>token</strong>。词法分析器返回的每个 token 都包含相关元数据，如：token 值、token 类型等。如下所示，为 token 定义类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one</span></span><br><span class="line"><span class="comment">// of these for known things.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    tok_eof = <span class="number">-1</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// commands</span></span><br><span class="line">    tok_def = <span class="number">-2</span>,</span><br><span class="line">    tok_extern = <span class="number">-3</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// primary</span></span><br><span class="line">    tok_identifier = <span class="number">-4</span>,</span><br><span class="line">    tok_number = <span class="number">-5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::string IdentifierStr; <span class="comment">// Filled in if tok_identifier</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> NumVal;             <span class="comment">// Filled in if tok_number</span></span><br></pre></td></tr></table></figure><p>词法分析器返回的 token 的类型可以分为两大类：</p><ul><li>预定义类型，即 <code>Token</code> 枚举中定义的枚举值，使用负整数表示。</li><li>未知字符，如：<code>+</code>，使用 <code>[0-255]</code> 正整数表示。</li></ul><p>当词法分析器解析到 <code>tok_identifier</code> 类型或 <code>tok_number</code> 类型的 token 时，会进行以下处理。</p><ul><li>如果当前 token 类型是 <code>tok_identifier</code> 时，则使用全局变量 <code>IdentifierStr</code> 保存标识符的名称，作为 token 值。</li><li>如果当前 token 类型是 <code>tok_number</code>，则使用全局变量 <code>NumVal</code> 保存数值，作为 token 值。</li></ul><blockquote><p><strong>注意，这里其实与 <code>lex</code> 工具使用 <code>yyval</code> 保存 token 值，<code>yytext</code> 保存标识符有着异曲同工之妙。</strong></p></blockquote><p>词法分析器的核心部分由 <code>gettok</code> 函数实现。每一次调用 <code>gettok</code> 函数都将从标准输入中返回下一个 token。<code>gettok</code> 的具体实现如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// gettok - Return the next token from standard input.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">gettok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> LastChar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip any whitespace.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(LastChar))</span><br><span class="line">    LastChar = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(LastChar)) &#123; <span class="comment">// identifier: [a-zA-Z][a-zA-Z0-9]*</span></span><br><span class="line">    IdentifierStr = LastChar;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isalnum</span>((LastChar = <span class="built_in">getchar</span>())))</span><br><span class="line">      IdentifierStr += LastChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;def&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_def;</span><br><span class="line">    <span class="keyword">if</span> (IdentifierStr == <span class="string">&quot;extern&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> tok_extern;</span><br><span class="line">    <span class="keyword">return</span> tok_identifier;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// Number: [0-9.]+</span></span><br><span class="line">    std::string NumStr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      NumStr += LastChar;</span><br><span class="line">      LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(LastChar) || LastChar == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    NumVal = <span class="built_in">strtod</span>(NumStr.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> tok_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (LastChar == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Comment until end of line.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (LastChar != EOF &amp;&amp; LastChar != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; LastChar != <span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LastChar != EOF)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">gettok</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for end of file.  Don&#x27;t eat the EOF.</span></span><br><span class="line">  <span class="keyword">if</span> (LastChar == EOF)</span><br><span class="line">    <span class="keyword">return</span> tok_eof;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, just return the character as its ascii value.</span></span><br><span class="line">  <span class="type">int</span> ThisChar = LastChar;</span><br><span class="line">  LastChar = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> ThisChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gettok</code> 函数使用 C 函数 <code>getChar()</code> 读取标准输入的字符，并通过 <code>while</code> 循环忽略 token 之间的空格。然后，根据第一个字符进行分类处理。</p><ul><li>如果第一个字符是字母，那么 <code>gettok</code> 开始识别标识符和关键字，并将标识符存入 <code>IdentifierStr</code> 全局变量，返回对应的 token 类型。</li><li>如果第一个字符是数字或 <code>.</code>，那么 <code>gettok</code> 开始识别数值，并将数值存入 <code>NumVal</code> 全局变量，返回 token 类型 <code>tok_number</code></li><li>如果第一个字符是 <code>#</code>，那么 <code>gettok</code> 识别注释，该符号之后整行内容均为注释内容，进行忽略处理。</li><li>如果第一个字符是 <code>EOF</code>，那么识别文件结束符，返回 token 类型 <code>token_eof</code>。</li><li>其它情况，则返回该字符的 ASCII 值。</li></ul><p>如下所示，为 <code>gettoken</code> 函数的工作原理示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/kaleidoscope-02.png?x-oss-process=image/resize,w_800"></p><p>至此，我们实现了 Kaleidoscope 的词法分析器。下一章，我们将实现语法分析器（Parser），从而构建抽象语法树（Abstract Syntax Tree）。当实现了词法分析器和语义分析器后，我们会实现一个驱动器（Driver）来使两者协同进行工作，并进行测试。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html">Kaleidoscope: Kaleidoscope Introduction and the Lexer</a></li><li><a href="http://en.wikipedia.org/wiki/Kaleidoscope">Kaleidoscope</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kaleidoscope&quot;&gt;&lt;a href=&quot;#Kaleidoscope&quot; class=&quot;headerlink&quot; title=&quot;Kaleidoscope&quot;&gt;&lt;/a&gt;Kaleidoscope&lt;/h1&gt;&lt;p&gt;本教程我们将从零开始设计一门玩具版编程语言——Kaleido</summary>
      
    
    
    
    <category term="LLVM" scheme="http://chuquan.me/categories/LLVM/"/>
    
    
    <category term="Kaleidoscope" scheme="http://chuquan.me/tags/Kaleidoscope/"/>
    
    <category term="LLVM" scheme="http://chuquan.me/tags/LLVM/"/>
    
    <category term="词法分析器" scheme="http://chuquan.me/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/"/>
    
  </entry>
  
</feed>
