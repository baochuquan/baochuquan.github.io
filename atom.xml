<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2019-03-09T11:19:47.719Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IP 协议相关技术</title>
    <link href="http://chuquan.me/2019/03/09/ip-protocols/"/>
    <id>http://chuquan.me/2019/03/09/ip-protocols/</id>
    <published>2019-03-09T11:16:51.000Z</published>
    <updated>2019-03-09T11:19:47.719Z</updated>
    
    <content type="html"><![CDATA[<p>IP（Internet Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP 是无法实现通信的，还必须具有解析主机名、MAC 地址以及数据包在发送过程中异常情况处理等功能。</p><p>下文将详细介绍 IP 的各种辅助技术，主要包括：</p><ul><li>DNS</li><li>ARP</li><li>DHCP</li><li>NAT</li><li>Mobile IP</li></ul><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>通常来说，我们在访问某个网站时不会直接使用 IP 地址，而是使用类似于 <code>www.chuquan.me</code> 这样的域名进行访问。为什么使用域名就能访问目标地址？因为有 DNS（Domain Name System）的支持，其可以将域名转换为具体的 IP 地址。</p><h2 id="DNS-的产生"><a href="#DNS-的产生" class="headerlink" title="DNS 的产生"></a>DNS 的产生</h2><p>在互联网的起源 ARPANET 中，起初由互联网信息中心（SRI-NIC）整体管理一份 hosts 文件，记录 ARPANET 网中所有计算机的 IP 地址。由于主机的 IP 地址可以变更，所以其他计算机也需要定期下载最新的 hosts 文件才能正常使用网络。</p><p>随着网络规模的扩大，这种集中管理方式的可行性及可靠性均逐渐下降。于是，诞生了一个可以有效管理主机名和 IP 地址之间对应关系的系统，即 DNS 系统。在 DNS 系统中，主机的管理机构维护了一个用来表示组织内部主机名和 IP 地址映射关系的数据库。当用户在应用（如浏览器）中输入主机名（域名）时，DNS 会自动检索数据库，并返回对应的 IP 地址。</p><h2 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h2><p>域名是为了标识主机名和组织机构名的一个具有分层结构的字符串。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pku.edu.cn</span><br></pre></td></tr></table></figure></p><p>其中，<code>pku</code> 表示北京大学（Peking University）固有的域名；<code>edu</code> 表示教育相关结构；<code>cn</code> 表示中国。</p><p>域名的分层如下图所示，各级分层构成一个树形结构，顶点 root 是树的根节点，根节点的下一层称为第 1 层域名，又称 <strong>顶级域名</strong>，如：<code>cn</code>、<code>jp</code> 等国别顶级域名，<code>com</code>、<code>org</code> 等特定领域域名。顶级域名的下一层称为第 2 层域名，如：<code>ac</code>、<code>co</code> 等表示不同组织结构的属性域名，<code>beijing</code> 等表示地域的通用域名。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-hierachy.png" alt=""></p><ul><li><strong>域名服务器</strong><br>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。其所管理的分层称为 <code>ZONE</code>。如图所示，每层都有一个域名服务器。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system.png" alt=""></p><p>DNS 分层结构的根节点设置的 DNS 称为 <strong>根域名服务器</strong>。根域名服务器中注册了 <strong>顶级域名服务器</strong> 的 IP 地址。顶级域名服务器中则注册了第 2 层域名服务器的 IP 地址，以此类推，构成一个分层系统。如果域名服务器宕机，则针对该域的 DNS 查询就会失败。因此为了提高容灾能力，一般会设置至少两个以上的域名服务器。一旦第一个域名服务器无法查询，就会自动转到第二个甚至第三个域名服务器上进行。</p><ul><li><strong>解析器</strong><br>进行 DNS 查询的主机和软件称为 <strong>DNS 解析器</strong>。用户所使用的工作站或个人电脑都属于解析器。<strong>一个解析器至少要注册一个以上域名服务器的 IP 地址</strong>。通常，至少包括组织内部的域名服务器的 IP 地址。</li></ul><h2 id="DNS-工作原理"><a href="#DNS-工作原理" class="headerlink" title="DNS 工作原理"></a>DNS 工作原理</h2><p>那么 DNS 的工作原理是什么呢？假设 <code>yuanfudao.com</code> 域中的主机 A 访问网站 <code>pku.edu.cn</code>，该过程的 DNS 查询流程如图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system-query.png" alt=""></p><p>解析器为了获取 IP 地址，向域名服务器进行查询。接收到查询请求的域名服务器首先在自己的数据库进行查找。如果有该域名对应的 IP 地址就返回。如果没有，则域名服务器再向上一层域名服务器进行查询，依次类推，直到根域名服务器。然后根节点遍历，直到找到指定的域名服务器，并由该域名服务器返回对应的 IP 地址。</p><p>解析器和域名服务器通过将查询结果进行缓存来提高查询性能。</p><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>通过 DNS 确定了目标域名的 IP 地址之后，就可以向该目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时有必要了解每个 IP 地址对应的 MAC 地址。</p><p>ARP（Address Resolution Protocol）是一种解决地址问题的协议。ARP 以目标 IP 地址为线索，确定下一个应该接收数据分包的网络设备的 MAC 地址。如果目标主机不在同一个链路上，可以通过 ARP 查找下一跳路由器的 MAC 地址。</p><blockquote><p>ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以使用 ICMPv6 替代 ARP 发送邻居探索消息。</p></blockquote><h2 id="ARP-工作原理"><a href="#ARP-工作原理" class="headerlink" title="ARP 工作原理"></a>ARP 工作原理</h2><p>ARP 是如果确定 MAC 地址的呢？事实上，ARP 主要通过 <strong>ARP 请求</strong> 与 <strong>ARP 响应</strong> 两种类型的包来确定 MAC 地址的。</p><p>如图所示，主机 A 向同一链路上的主机 B 发送 IP 包，主机 A 的 IP 地址为 <code>172.20.1.1</code>，主机 B 的 IP 地址为 <code>172.20.1.2</code>，它们互不知道对方的 MAC 地址。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/arp-protocol.png" alt=""></p><p>主机 A 为了确定主机 B 的 MAC 地址，先通过广播发送一个 ARP 请求包，请求包中包含了主机 B 的IP 地址 <code>172.20.1.2</code>。由于广播的包可以被同一个链路上的所有主机或路由器接收，因此 ARP 包的请求包也会被同一链路上所有的主机和路由器进行解析。如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，则该节点就将自己的 MAC 地址存入 ARP 响应包并返回给主机 A。</p><p>如果每发送一个 IP 数据报都要进行一次 ARP 请求以此确定 MAC 地址，那么将会产生大量不必要的网络流量。为此，通常会将 IP 与 MAC 地址的映射关系缓存在一个 <strong>ARP 缓存表</strong> 中。除了 ARP 请求发送端可以缓存发送端 MAC 地址，接收端也可以从 ARP 请求包获取发送端主机的 IP 地址及其 MAC 地址并将其进行缓存。</p><p>不过，MAC 地址的缓存是有一定的期限的。超出期限之后，缓存的内容将被清除。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>RARP（Reverse Address Resolution Protocol）是一种根据 MAC 地址定位 IP 地址的协议。例如：将打印机服务器等小型嵌入式设备接入到网络时就会用到。</p><p>通常，我们使用个人电脑设置 IP 地址时，可以通过 DHCP 自动分配获取 IP 地址。但是对于嵌入式设备，会遇到没有任何输入接口或无法通过 DHCP 动态获取 IP 地址的情况。在这种情况下，一般使用 RARP。为此，需要架设一台 RARP 服务器，然后再接入该设备到网络，启动设备时，设备会发送一条类似于“我的 MAC 地址是 xxx，我的 IP 地址是什么”的请求信息。RARP 服务器接收到请求消息之后，返回类似于“MAC 地址为 xxx 的设备，IP 地址为 xxx”的信息。设备根据该应答信息设置自己的 IP 地址。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rarp-protocol.png" alt=""></p><h2 id="代理-ARP"><a href="#代理-ARP" class="headerlink" title="代理 ARP"></a>代理 ARP</h2><p>通常 ARP 包会被路由器隔离，但是采用代理 ARP（Proxy ARP）的路由器可以将 ARP 请求转发给邻近的网段。因此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><p>在目前的 TCP/IP 网络中，一般情况下用路由器链接多个网络时，会在各个网段上定义各自的子网，从而进行路由控制。然而，对于那些不支持设定子网掩码的老设备，不适用代理 ARP，有时就无法更好地使用网络。</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>每一台主机在接入网络时都需要设置 IP 地址，尤其是对于移动设备，每移动到一个新的地方，都需要重新设置 IP 地址。</p><p>DHCP（Dynamic Host Configuration Protocol）就是一种可以实现自动设置 IP 地址、统一管理 IP 地址分配的协议。通过 DHCP，计算机只要连接到网络就可以进行 TCP/IP 通信。</p><h2 id="DHCP-工作原理"><a href="#DHCP-工作原理" class="headerlink" title="DHCP 工作原理"></a>DHCP 工作原理</h2><p>使用 DHCP 之前，需要先架设一台 DHCP 服务器。然后将 DHCP 所要分配的 IP 地址、子网掩码、路由控制信息、DNS 服务器地址等设置到服务器上。</p><p>从 DHCP 获取 IP 地址的过程主要分为两个步骤：</p><ul><li><strong>DHCP 请求</strong>：客户端广播发送 DHCP 发现包，请求设置 IP 地址和子网掩码。DHCP 服务器收到请求后返回 DHCP 提供包，通知可以使用的网络设置。</li><li><strong>DHCP 确认</strong>：客户端再次广播发送 DHCP 请求包，通知想要使用前一次 DHCP 提供包中的网络设置，以确保在 DHCP 服务器上重复设置也可以正常工作。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-protocol.png" alt=""></p><p>当 DHCP 服务器遇到故障时，将导致无法自动分配 IP 地址，从而导致网段内所有主机之间无法进行 TCP/IP 通信。为了提高网络的可靠性，通常会架设两台以上的 DHCP 服务器。由于每个 DHCP 服务器内部都记录着 IP 地址的分配信息，因此可能会导致不同 DHCP 服务器分配的 IP 地址产生冲突。</p><p>为了检查所要分配的 IP 地址以及已分配的 IP 地址是否可用，DHCP 服务器或 DHCP 客户端必须具有以下功能：</p><ul><li><strong>DHCP 服务器</strong>：在分配 IP 地址前发送 ICMP 回送请求包，确认没有返回应答。</li><li><strong>DHCP 客户端</strong>：针对从 DHCP 获取到的 IP 地址发送 ARP 请求包，确认没有返回应答。</li></ul><h2 id="DHCP-中继代理"><a href="#DHCP-中继代理" class="headerlink" title="DHCP 中继代理"></a>DHCP 中继代理</h2><p>家庭网络大多只有一个以太网（无线 LAN）的网段，与其连接的主机台数也不会很多。因此，只需要一台 DHCP 服务器就能应对 IP 地址分配的需求，而大多数情况下都由 <strong>宽带路由器</strong> 充当 DHCP 的角色。</p><p>相比之下，一个企业或学校的网络环境中，一般会有多个以太网（无线 LAN）的网段。在这种情况下，如果针对每个网段都设置 DHCP 服务器，则将是一个浩大的工程。即使路由器可以分担 DHCP 的功能，如果网络中有 100 个路由器，就要为 100 个路由器设置它们各自可分配 IP 地址的范围，并对这些范围进行后续的更新维护，这是极其难以管理的。</p><p>因此，在这类网络环境中，往往需要 DHCP 统一管理，具体方法可以使用 DHCP 中继代理实现。</p><p>这种方法需要在每个网段设置一个 DHCP 中继代理。它可以设置 DHCP 服务器的 IP 地址，从而可以在 DHCP 服务器上为每个网段注册 IP 地址的分配范围。</p><p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，DHCP 中继代理收到广播的请求包后，以单播的方式发给 DHCP 服务器。服务器收到包后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端。由此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理的 IP 地址。 </p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-agent-protocol.png" alt=""></p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时使用全局 IP 地址的技术。NAT 主要是为了应对 IPv4 日渐枯竭而开发的技术。</p><h2 id="NAT-工作原理"><a href="#NAT-工作原理" class="headerlink" title="NAT 工作原理"></a>NAT 工作原理</h2><p>如下图所示，以 <code>10.0.0.10</code> 的主机与 <code>163.221.120.9</code> 的主机进行通信为例。局域网中的主机发起请求时，NAT 路由器会将发送源地址从 <code>10.0.0.10</code> 转换为全局的 IP 地址 <code>202.244.174.37</code> 后再发送数据。反之，当数据从地址 <code>163.221.120.9</code> 发送过来时，目标地址 <code>202.244.174.37</code> 先被转换成私有 IP 地址 <code>10.0.0.10</code> 后再被转发。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nat-protocol.png" alt=""></p><p>NAT 路由器内部有一个自动生成的用来转换地址的表。当 <code>10.0.0.10</code> 向 <code>163.221.120.9</code> 发送第一个数据包时生成这张表，并按照表中的映射关系进行处理。</p><h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><p>NAPT（Network Address Port Translator）是 NAT 的升级版，不仅可以转换 IP 地址，还可以转换 TCP、UDP 端口号，可以实现用一个全局 IP 地址与多个主机的通信。</p><p>如下图所示，主机 <code>163.221.120.9</code> 的端口号是 <code>80</code>，LAN 中有两个客户端 <code>10.0.0.10</code> 和 <code>10.0.0.11</code> 同时进行通信，并且两个客户端的本地端口都是 <code>1025</code>。此时，仅仅将 IP 地址为路由器的全局地址 <code>202.244.174.37</code> 将无法区分两个客户端。因此，只要将 <code>10.0.0.11</code> 的端口号转换为 <code>1026</code> 就可以进行区分。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/napt-protocol.png" alt=""></p><p>类似于 NAT，NAPT 路由器也会生成自动一个转换表。如：在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包发出后就会生成转换表。断开 TCP 连接时的 FIN 包发出后就会被删除。</p><h1 id="Mobile-IP"><a href="#Mobile-IP" class="headerlink" title="Mobile IP"></a>Mobile IP</h1><p>在与移动设备进行通信时，所连接的子网一旦发生变化，则无法通过 TCP 继续通信。因为 TCP 是面向连接的协议，自始至终都需要发送端和接收端主机的 IP 地址保持不变。类似的，UDP 也无法继续通信。</p><p>Mobile IP 技术就是为了解决所连接的子网发生变化时继续保持通信的需求。</p><h2 id="Mobile-IP-工作原理"><a href="#Mobile-IP-工作原理" class="headerlink" title="Mobile IP 工作原理"></a>Mobile IP 工作原理</h2><p><strong>基本概念</strong></p><ul><li><strong>移动节点</strong>（MN，Mobile Node）：从一个网络切换到另一个网络的设备，如：手机从一个网络切换到另一个网络。</li><li><strong>对等节点</strong>（CN，Correspondent Node）：与移动节点通信的设备。</li><li><strong>归属地址</strong>（Permanent Address）：一个固定的 IP 地址，如同一个人的户籍，即使移动了也不会改变。</li><li><strong>转交地址</strong>（CoA：Care-of-Address）：设备移动当前所处网络予以分配的 IP 地址。</li><li><strong>归属代理</strong>（HA：Home Agent）：暂时认为是移动设备当前所处网络的路由器。</li><li><strong>外地代理</strong>（FA：Foreign Agent）：暂时认为是移动设备归属网络的路由器。</li></ul><p>如下图所示，为 Mobile IP 的工作原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/mobile-ip-protocol.png" alt=""></p><p>当移动节点接入切换至另一个网络时，首先请求外地代理为它服务，并向归属代理注册转交地址。</p><p>当对等节点向移动节点的归属地址发送分组数据时，归属代理能够截获该分组，并将该分组转发给移动节点最新注册的转交地址。外地代理收到分组数据后，转发给转交地址对应的设备，即移动节点。移动节点可以直接响应对等节点。</p><p>注意，归属代理和外地代理之间的通信是通过 IP 隧道实现的。因为归属代理会将对等节点的原始分组数据进行封装，再由外地代理进行拆封。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《图解 TCP/IP》</li><li>Mobile IP 基本知识, NC &amp; IS</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IP（Internet Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP 是无法实现通信的，还必须具有解析主机名、MAC 地址以及数据包在发送过程中异常情况处理等功能。&lt;/p&gt;
&lt;p&gt;下文将详细介绍 IP 的各种辅助技术，主要包括：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="网络" scheme="http://chuquan.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IP" scheme="http://chuquan.me/tags/IP/"/>
    
      <category term="DHCP" scheme="http://chuquan.me/tags/DHCP/"/>
    
      <category term="DNS" scheme="http://chuquan.me/tags/DNS/"/>
    
      <category term="ARP" scheme="http://chuquan.me/tags/ARP/"/>
    
      <category term="Mobile IP" scheme="http://chuquan.me/tags/Mobile-IP/"/>
    
      <category term="NAT" scheme="http://chuquan.me/tags/NAT/"/>
    
  </entry>
  
  <entry>
    <title>OSI 模型与 TCP-IP 协议详解</title>
    <link href="http://chuquan.me/2019/03/02/osi-tcp-ip-introduce/"/>
    <id>http://chuquan.me/2019/03/02/osi-tcp-ip-introduce/</id>
    <published>2019-03-02T07:03:12.000Z</published>
    <updated>2019-03-02T07:09:35.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p>在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着异构机型之间通信的需求不断增加，通信技术的标准化也随之展开。于是，ISO（International Organization for Standard）制定了一个国际标准 OSI（Open System Interconnection），即广为人知的 OSI 参考模型，作为标准化通信技术的设计准则。</p><p>OSI 参考模型将通信协议中必要的功能分层了 7 层。每个分层接收下一层提供的特定服务，并负责为上一层提供特定的服务。这些功能上相对独立的分层可以构造一个扩展性和灵活性都较强的系统。</p><p>下表所示为 OSI 参考模型及其各个分层的职责。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi.png?x-oss-process=image/resize,w_570" alt=""></p><ul><li><p><strong>应用层</strong>：主要负责为应用程序提供服务并规定应用程序中通信相关的细节。在该层实现的协议有：文件传输、电子邮件、远程登录等协议。</p></li><li><p><strong>表示层</strong>：主要负责数据格式的转换。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。</p></li><li><p><strong>会话层</strong>：主要负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p></li><li><p><strong>传输层</strong>：主要负责进行可靠传输。只在通信双方节点上进行处理，而无需在路由器上处理。</p></li><li><p><strong>网络层</strong>：主要负责寻址和路由选择，从而将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某个地址。</p></li><li><p><strong>数据链路层</strong>：主要负责物理层面上互连的、节点之间的通信传输。将 0、1 序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。如与 1 个以太网相连的 2 个节点之间的通信。</p></li><li><p><strong>物理层</strong>：主要负责 0、1 比特流（0、1 序列）与电压的高低、光的闪灭之间的互换。</p></li></ul><h1 id="OSI-参考模型通信示例"><a href="#OSI-参考模型通信示例" class="headerlink" title="OSI 参考模型通信示例"></a>OSI 参考模型通信示例</h1><p>下面举例说明 OSI 参考模型的功能。假设使用主机 A 的用户向使用主机 B 的用户发送一封邮件。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email01.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>用户 A 在主机 A 上新建一封邮件，指定收件人为 B，并输入邮件内容为 “早上好”。用户确认发送时，开始进入应用层协议的处理。该协议在传送数据的前端附加一个首部信息。主机 B 在收到主机 A 发送至的数据后，分析其数据首部与数据正文，并将邮件存入本地。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email02.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层会将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复成“该计算机特有的数据格式”，然后在进行相应的处理。</p><p>此例中，“早上好”这段文字根据编码格式被转换成了“统一的网络数据格式”。由于文字的编码格式非常多，如：UTF-8、UTF-16、Unicode 等，如果未能按照特定格式编码，那么在接收端收到的邮件可能就是乱码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email03.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>假如用户 A 新建了 5 封邮件准备发送给用户 B。这 5 封邮件的发送顺序可以有多种：</p><ul><li>每发一封邮件时建立一次连接，随后断开连接</li><li>一旦建立连接后，将 5 封邮件连续发送给对方</li><li>同时建立 5 个连接，将 5 封邮件同时发送给对方</li></ul><p>会话层的主要责任就是决定采用何种连接方式。</p><p>类似应用层、表示层，会话层在其收到的数据前端附加首部之后再转发给下一层。这些首部中 <strong>记录着数据传送顺序的信息</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email04.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>会话层只对何时建立连接、何时发送数据等问题进行管理，并不具备实际传输数据的功能。真正负责在网络上传输数据的是会话层以下的分层。</p><p>主机 A 确保与主机 B 之间的通信并准备发送数据。该过程称为“建立连接”。连接建立后即可使主机 A 发送的邮件到达主机 B。传输结束之后，有必要将连接断开。</p><p>上述两个主机之间创建逻辑上的通信连接是传输层的主要作用。此外，传输层为确保数据到达目标地址，会在通信两端的主机之间进行确认，如果数据没有到达，则负责进行重发。</p><p>示例中，如果主机 A 将“早上好”发送给主机 B，由于网络异常等原因导致只有部分数据到达目标地址。假设主机 B 只收到“早上”这部分数据，那么它会将没有收到“早上”之后那部分数据的事实告诉主机 A，主机 A 得知后会将“好”重新发送给主机 B，并再次确认对端是否收到。</p><p>因此，保证数据传输的可靠性是传输层的一个重要作用。为了确保可靠性，传输层也会对所要传输的数据附加首部以识别这一分层的数据。然而，实际上将数据传输给对端的处理是由网络层完成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email05.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的作用是在网络与网络互连的环境中，将数据从发送端主机发送到接收端主机。如图所示，两端主机之间虽然有众多数据链路，但是能够将数据从主机 A 发送到主机 B 也都是网络层的功劳。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email06.png?x-oss-process=image/resize,w_600" alt=""></p><p>网络层的数据发送通过目标地址选择对应的计算机，因此目标地址是网络中唯一指定的序号，类似于电话号码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email07.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="数据链路层、物理层"><a href="#数据链路层、物理层" class="headerlink" title="数据链路层、物理层"></a>数据链路层、物理层</h2><p>通信传输本质上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过介质互连的设备之间进行数据处理。</p><p>物理层则将数据的 0、1 转换为电压和脉冲光传输给物理的传输介质，而<strong>相互直连的设备之间使用地址实现传输</strong>。这种地址被称为 <strong>MAC</strong> 地址。<strong>采用 MAC 地址，目的是为了识别连接同一传输介质上的设备</strong>。物理层会将包含 MAC 地址的信息的首部附加到同网络层转发过来的数据上，并将其发送到网络中。</p><p>网络层与数据链路层都是基于目标地址将数据发送给接收端，其区别在于：</p><ul><li><strong>网络层负责将整个数据发送给最终的目标地址</strong></li><li><strong>数据链路层只负责发送一个分段内的数据</strong></li></ul><p>详见上图。</p><h1 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h1><h2 id="TCP-IP-的含义"><a href="#TCP-IP-的含义" class="headerlink" title="TCP/IP 的含义"></a>TCP/IP 的含义</h2><p>从字面上看，有人可能会认为 TCP/IP 是指 TCP 与 IP 两种协议。虽然实际中的确有这两种协议，但是在很多情况下，它泛指 IP、ICMP、TCP、UDP、TELNET、FTP、HTTP 等协议群，所以有时也称 TCP/IP 为 <strong>网际协议族</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-protocols.png" alt=""></p><h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p><strong>包、帧、数据报、段、消息</strong> 等五个术语都用来表述数据的单位，其区别在于：</p><ul><li>包：全能性术语</li><li>帧：表示数据链路层中包的单位</li><li>数据报：表示 IP 和 UDP 等网络层以上分层中包的单位</li><li>段：表示 TCP 数据流中的信息</li><li>消息：表示应用层中数据的单位</li></ul><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上层传来的数据。在数据包的首部，明确标明了协议应该如何读取数据。通过解析首部，能够了解该协议必要的信息以及要处理的内容。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-data-header.png" alt=""></p><h2 id="TCP-IP-与-OSI-参考模型"><a href="#TCP-IP-与-OSI-参考模型" class="headerlink" title="TCP/IP 与 OSI 参考模型"></a>TCP/IP 与 OSI 参考模型</h2><p>关于 TCP/IP 与 OSI 参考模型的关系，我们可以认为 TCP/IP 是对 OSI 参考模型的一种具体实现。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-ois-compare.png" alt=""></p><ul><li><p><strong>硬件（物理层）</strong></p><ul><li>TCP/IP 的最底层是负责数据传输的硬件，如以太网或电话线路等物理层的设备。物理层所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等都会有所不同。</li></ul></li><li><p><strong>网络接口层（数据链路层）</strong></p><ul><li>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层，可认为是让 NIC（网卡）正常工作的驱动程序。</li></ul></li><li><p><strong>互联网层（网络层）</strong></p><ul><li>互联网层使用 IP 协议，对应 OSI 模型中的第 3 层网络层。IP 协议基于 IP 地址转发分组数据包。</li><li>TCP/IP 分层中的互联网层与传输层的功能通常由操作系统实现。尤其是路由器，它必须实现通过互联网曾转发分组数据包的功能。连接互联网的所有主机和路由器都必须实现 IP 的功能。</li></ul></li></ul><blockquote><p><strong>为什么要分组？</strong><br>首先需要明确一个事实：一台计算机在收发数据时会独占其所在的整条通信线路。如果一条线路上连接了多台计算机，当计算机相互之间进行数据传输时，则需要等待线路中没有其他计算机占用时才能进行数据传输。如果某台计算机占用线路之后传输大量数据，则其他计算机始终保持等待状态。极端情况下根本无法进行通信。<br>采用分组（交换）技术，数据会被分成更小的单元，所有的计算机就可以并发收发数据，从而提高了通信线路的利用率。</p><p><strong>IP</strong><br>IP 是跨越网络传送数据包，使整个互联网都能收到数据的协议，这个过程中使用 IP 地址作为主机的标识。<br>IP 还隐含着数据链路的功能。通过 IP，相互通信的主机之间无论经过怎样的底层数据链路都能够实现通信。<br>IP 是分组交换的一种协议，但其并不具备重发机制。即使分组数据包未能达到对端主机也不会重发，属于非可靠传输协议。  </p><p><strong>ICMP</strong><br>IP 数据包在发送途中一旦出现异常导致无法到达对端目标地址时，需要向发送端发送一个异常通知。ICMP 就是为这一功能而定制的，常用于 <strong>诊断网络的健康状况</strong>。  </p><p><strong>ARP</strong><br>从分组数据包的 IP 地址中解析出物理地址（MAC 地址）的一种协议。</p></blockquote><ul><li><strong>传输层</strong><ul><li>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同时运行着多个程序。为了识</li><li>别哪些程序之间在进行通信，使用 <strong>端口号</strong> 进行区分。</li></ul></li></ul><blockquote><p><strong>TCP</strong><br>TCP 是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP 能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP 还能够有效利用带宽，缓解网络拥堵。<br> 为了建立和断开连接，TCP 需要进行 3 次握手，4 次挥手，从而会导致网络流量的浪费。</p><p><strong>UDP</strong><br>UDP 是一种面向无连接的传输层协议。UDP 不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。<br>UDP 常用语分组数据较少或多播、广播通信以及视频通信等多媒体领域。  </p></blockquote><ul><li><strong>应用层（会话层以上分层）</strong><ul><li>TCP/IP 协议分层模型将 OSI 参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。</li></ul></li></ul><h1 id="TCP-IP-协议分层模型通信示例"><a href="#TCP-IP-协议分层模型通信示例" class="headerlink" title="TCP/IP 协议分层模型通信示例"></a>TCP/IP 协议分层模型通信示例</h1><p>这里继续以上述电子邮件收发的示例来介绍 TCP/IP 协议分层模型的通信过程。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-example.png" alt=""></p><p>邮件收发过程可分为个主要步骤：</p><ul><li>发送数据包（发送端）</li><li>接收数据包（接收端）</li></ul><h2 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h2><h3 id="应用程序处理"><a href="#应用程序处理" class="headerlink" title="应用程序处理"></a>应用程序处理</h3><p>应用程序在发送邮件那一刻建立 TCP 连接，从而利用该 TCP 连接发送数据。该过程首先将应用层发来的数据发送至下一层的 TCP，再做实际的转发处理。</p><h3 id="TCP-模块处理"><a href="#TCP-模块处理" class="headerlink" title="TCP 模块处理"></a>TCP 模块处理</h3><p>TCP 根据应用程序的指示，负责建立连接、发送数据、断开连接。TCP 会在应用层数据前端附加一个 TCP 首部，其中包括：<strong>源端口号</strong> 和 <strong>目标端口号</strong>（用以识别发送主机和接收主机上的应用）、<strong>序号</strong>（用以标识发送包中哪部分是数据）、<strong>校验和</strong>（用以判断数据是否被损坏）。</p><h3 id="IP-模块处理"><a href="#IP-模块处理" class="headerlink" title="IP 模块处理"></a>IP 模块处理</h3><p>IP 将 TCP 传来的 TCP 首部和 TCP 数据合起来作为自己的数据，并在数据前端附加一个 IP 首部，其中包括：接收端 IP 地址和发送端 IP 地址。</p><p>IP 包生成后，根据路由控制表决定接收此 IP 包的路由器或主机。随后，IP 包将被发送给连接到这些路由器或主机网络接口的驱动程序，以实现真正发送数据。</p><p>如果尚且不知道接收端的 MAC 地址，可利用 ARP 查找。只要知道了对端的 MAC 地址，就可将 MAC 地址和 IP 地址交给以太网的驱动程序，实现数据传输。</p><h3 id="网络接口（以太网驱动）处理"><a href="#网络接口（以太网驱动）处理" class="headerlink" title="网络接口（以太网驱动）处理"></a>网络接口（以太网驱动）处理</h3><p>以太网驱动会将 IP 传来的 IP 包的前端附加上以太网首部并进行发送处理。以太网首部包含：接收端 MAC 地址、发送端 MAC 地址、标志以太网类型的以太网数据的协议。由此产生的以太网数据包将被发送至物理层传输给接收端。</p><h2 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h2><p>数据包的接收流程是发送流程的逆序过程。</p><h3 id="网络接口（以太网驱动）处理-1"><a href="#网络接口（以太网驱动）处理-1" class="headerlink" title="网络接口（以太网驱动）处理"></a>网络接口（以太网驱动）处理</h3><p><strong>主机收到以太网包后，先从以太网包首部找到 MAC 地址判断是否为发给自己的包。如果不是则丢弃。</strong></p><p>如果确认是发给自己的包，则查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。示例中数据的协议类型是 IP，因此将数据传送给处理 IP 的子程序（如果是 ARP，则把数据传给处理 ARP 的子程序）。如果无法识别协议类型，则丢弃数据。</p><h3 id="IP-模块处理-1"><a href="#IP-模块处理-1" class="headerlink" title="IP 模块处理"></a>IP 模块处理</h3><p>IP 模块收到 IP 包首部以数据部分后，也做类似处理。<strong>如果判断首部中的 IP 地址与自己的 IP 地址匹配，则接收数据并从中查找上一层的协议</strong>。如果上一层协议为 TCP，则传给 TCP 处理；如果上一层协议为 UDP，则传给 UDP 处理；<strong>对于路由器，接收端 IP 地址往往不是自己的 IP 地址，此时会根据路由控制表，查询应送达的主机或路由器以后再转发数据</strong>。</p><h3 id="TCP-模块处理-1"><a href="#TCP-模块处理-1" class="headerlink" title="TCP 模块处理"></a>TCP 模块处理</h3><p>TCP 模块会先计算校验和以确认数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。</p><p>数据接收完毕后，接收端则发送一个“确认回执”给发送端。如果回执消息未能达到发送端，发送端会认为接收端没有接收到数据而一直重复发送。</p><p>数据被完整接收后，会传给由端口号识别的应用程序。</p><h3 id="应用程序处理-1"><a href="#应用程序处理-1" class="headerlink" title="应用程序处理"></a>应用程序处理</h3><p>接收端应用程序通过解析数据可最终获取到邮件的具体内容。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI 模型-维基百科</a></li><li>《图解 TCP/IP》</li><li>《TCP/IP 详解》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OSI-参考模型&quot;&gt;&lt;a href=&quot;#OSI-参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 参考模型&quot;&gt;&lt;/a&gt;OSI 参考模型&lt;/h1&gt;&lt;p&gt;在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着
      
    
    </summary>
    
      <category term="网络" scheme="http://chuquan.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IP" scheme="http://chuquan.me/tags/IP/"/>
    
      <category term="OSI" scheme="http://chuquan.me/tags/OSI/"/>
    
      <category term="TCP" scheme="http://chuquan.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://chuquan.me/2018/12/31/2018-summary/"/>
    <id>http://chuquan.me/2018/12/31/2018-summary/</id>
    <published>2018-12-31T08:07:42.000Z</published>
    <updated>2018-12-31T08:13:31.940Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600" alt=""></div><a id="more"></a><p>又到了年末总结的时候了…回望年初立下的 Flag，不知道倒下了多少，扶都扶不起来。</p><p>简单总结一下这一年吧..</p><h2 id="关于运动"><a href="#关于运动" class="headerlink" title="关于运动"></a>关于运动</h2><p>从 7 月份至 10 月份，在这 4 个月期间，每周末去自学游泳。从旱鸭子状态开始，依次掌握了蛙泳，狗刨，自由泳，仰泳，蝶泳。目前，蝶泳还不是非常协调，有待进一步强化练习。毕竟，蝶泳是所用泳姿中门槛最高的一种，无论是在力量方面还是协调性方面。</p><p>当然，完全靠自己摸索来学习游泳是一个很漫长的过程。为了加快我的学习进入，在学游泳期间，我坚持观看 YouTube 上易梦觉教练的一些游泳教学视频，学习一些游泳的技巧。</p><p>年底的时候，开始教妹子学游泳，目前蛙泳差不多已经会了。</p><p>除了游泳，今年在周末的时间还有一部分给了篮球。自从 3 月份那会儿在高家园附近的社科院里发现了一个室外篮球场后，在 7 月份之前几乎每周末都会去打一次球。</p><p>总体来说，今年的运动量增加了不少，同时掌握了游泳这个新技能。</p><h2 id="关于旅行"><a href="#关于旅行" class="headerlink" title="关于旅行"></a>关于旅行</h2><p>今年 10 月底，随公司一起去俄罗斯玩了一周。<a href="http://chuquan.me/2018/11/03/st-petersburg/">游记传送门</a></p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>年初的时候，刚刚开始接手模块级的 iOS 开发任务，那时候还不是非常娴熟。经过这一年的锻炼，已经能够 carry 任何需求了。</p><p>这一年里，公司的工作节奏依然比较快的，毕竟走的是 Scrum 的项目管理模式，需求迭代很快，并且研发人员相对产品经理较少。为了解决研发人员不足的问题，从年初就开始不停地招人。到年底，我们整个研发组从原来的 15 人左右增至 30 多人。公司整体的人员也增涨了不少，去年入职时只有 500 人左右，此刻已经有了 2800 多人了。在全球经济如此不景气，各个公司都不断裁员的背景下，我司还在不断地扩招，不禁感慨教育行业的优越性[手动捂脸]。</p><p>6 月份，公司给我们调了一次薪水，发了期权，虽然不是很多，但符合预期。</p><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>今年来了几位有着丰富工作经验的同事，在他们的积极推动下，我们的搜题和口算的项目也开始引入了一些新的技术框架。口算目前基本已经在使用 Swift 进行开发了，并已经在使用函数响应式编程框架 RxSwift。搜题方面由于历史原因，虽然引入了 RxSwift，但还没有开始全面使用。</p><p>去年立下的关于阅读开源框架的 Flag，今年只是阅读了一些公司内部的框架，如：YTKFrog、YTKRouterManager、YTKResourceSync 等，关于阅读开源框架这个 Flag，希望明年能够重视。</p><h2 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h2><p>今年上半年，我又重新看了一遍《程序员的自我修养——装载、链接与库》，然后写了几篇博客。从中我发现了一种相比以前更加高效的吸收知识、提高阅读效率的方法——写博客。为什么呢？因为我们看完一本书时，其实有效的知识吸收程度并不高，写博客能够让我们加强对关心的主题的理解。写博客的过程中，需要我们不断地重新翻看书中的一些要点，甚至查阅其他书籍、博客，从而加强我们对它的理解。后来我写的几篇博客：<a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">《计算机那些事(7)——图形图像渲染原理》</a>、<a href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/">iOS 图像渲染原理</a> 都是按照同样的方式做的，受益匪浅。后一篇文章甚至被 CocoaChina 社区转载了，虽然没有稿费，但还是非常开心。</p><p>年末的时候，我开始对编程语言、编程范式起了兴趣。依次看了几本书：《七周七语言》、《函数式编程思维》、《函数式 Swift》。希望新的一年能够继续深入研究编程语言，能够产出几篇博文。</p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p>Flag 还是要立起来的，毕竟明年年底要是要给自己打打脸，清醒地认清自我。</p><ol><li>深入研究编程语言，包括编程范式、实现模式、DSL 等。先列一些书单：<ul><li>《类型和程序设计语言》</li><li>《自制编程语言》</li><li>《领域特定语言》</li><li>《编程语言实现模式》</li><li>…</li></ul></li><li>掌握一些其他的编程语言。</li><li>副业搞起来，通过专利代理人资格考试</li><li>横向发展，学习 Android 开发。</li><li>提升 Linux 基本技能</li><li>做一个全栈项目</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://chuquan.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>KVO 原理详解</title>
    <link href="http://chuquan.me/2018/12/12/kvo-principle/"/>
    <id>http://chuquan.me/2018/12/12/kvo-principle/</id>
    <published>2018-12-12T13:41:59.000Z</published>
    <updated>2018-12-12T15:15:01.067Z</updated>
    
    <content type="html"><![CDATA[<p>KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。<a href="https://github.com/baochuquan/BAOStudy" target="_blank" rel="noopener">源码地址</a></p><h1 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self setupSubviews];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = 1;</span><br><span class="line">    p1.age = 2;</span><br><span class="line">    p2.age = 2;</span><br><span class="line"></span><br><span class="line">    // self 监听 p1 的 age 属性</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line">    p1.age = 10;</span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupSubviews &#123;</span><br><span class="line">    [self setupHeaderView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupHeaderView &#123;</span><br><span class="line">    self.headerView.title = @&quot;KVO&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;监听到 %@ 的 %@ 改变了 %@&quot;, object, keyPath,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例对 <code>p1</code> 进行了 KVO 监听，当 <code>p1</code> 发生改变，即调用 <code>observeValueForKeyPath</code> 方法，从而打印以下信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">监听到 &lt;BAOPerson: 0x600003750200&gt; 的 age 改变了 &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 10;</span><br><span class="line">    old = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="KVO-实现原理"><a href="#KVO-实现原理" class="headerlink" title="KVO 实现原理"></a>KVO 实现原理</h1><p>通过上述代码可以发现，一旦 <code>age</code> 属性的值发生改变，就会通知到监听者。我们知道赋值操作都是调用 <code>set</code> 方法，我们可以重写 <code>BAOPerson</code> 类中 <code>age</code> 的 <code>set</code> 方法，观察 KVO 是否是在 <code>set</code> 方法内部做了一些操作来通知监听者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age &#123;</span><br><span class="line">    NSLog(@&quot;override setAge&quot;);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现即使重写了 <code>set</code> 方法，<code>p1</code> 除了调用 <code>set</code> 方法之外还会执行监听者的 <code>observeValueForKeyPath</code> 方法。</p><p>根据上述实验推测：KVO 在运行时对 <code>p1</code> 对象进行了改动，使 <code>p1</code> 对象在调用 <code>setAge</code> 方法时做了一些额外的操作。所以问题出在对象身上，两个对象可能本质上并不一样。下面我们来探索一下 KVO 内部是如何实现的。</p><h1 id="KVO-实现分析"><a href="#KVO-实现分析" class="headerlink" title="KVO 实现分析"></a>KVO 实现分析</h1><p>首先分别在添加 KVO 前后打上断点，以观察添加 KVO 前后 <code>p1</code> 对象有何不同。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-before-after-add-observe.png" alt=""></p><p>通过打印对象的 <code>isa</code> 指针，我们发现，<code>p1</code> 对象的 <code>isa</code> 指针由之前的指向类对象 <code>BAOPerson</code> 变成了指向类对象 <code>NSKVONotifying_BAOPerson</code>。相应地，<code>p2</code> 对象没有改变。因此我们可以推测，<code>p1</code> 对象的 <code>isa</code> 发生改变后，其执行的 <code>setAge</code> 也发生了改变。</p><p>我们知道，<code>p2</code> 在调用 <code>setAge</code> 方法时，首先会通过 <code>p2</code> 对象的 <code>isa</code> 指针找到 <code>BAOPerson</code> 类对象，然后在类对象中找到 <code>setAge</code> 方法，最终找到方法对应的实现。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo001.png" alt=""></p><p>但是，<code>p1</code> 对象的 <code>isa</code> 在添加 KVO 之后已经指向了 <code>NSKVONotifying_BAOPerson</code> 类对象，<code>NSKVONotifying_BAOPerson</code> 则是 <code>BAOPerson</code> 的子类。<code>NSKVONotifying_BAOPerson</code> 是 runtime 在运行时生成的。因此，<code>p1</code> 对象在调用 <code>setAge</code> 方法时必然会根据 <code>p1</code> 的 <code>isa</code> 找到 <code>NSKVONotifying_BAOPerson</code>，并在 <code>NSKVONotifying_BAOPerson</code> 中找到 <code>setAge</code> 方法及其实现。</p><p>经查阅资料了解到，<code>NSKVONotifying_BAOPerson</code> 中的 <code>setAge</code> 方法中其实调用了 Foundation 框架中 C 语言函数 <code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code> 内部的操作大致是：首先调用 <code>willChangeValueForKey</code> 方法，然后调用父类的 <code>setAge</code> 方法对成员变量赋值，最后调用 <code>didChangeValueForKey</code> 方法。<code>didChangeValueForKey</code> 方法中会调用监听者的监听方法，最终调用监听者的 <code>observeValueForKeyPath</code> 方法。</p><h1 id="KVO-原理验证"><a href="#KVO-原理验证" class="headerlink" title="KVO 原理验证"></a>KVO 原理验证</h1><p>前面我们已经通过断点打印 <code>isa</code> 指针的方式验证了：<code>p1</code> 对象在添加 KVO 后，其 <code>isa</code> 指针会指向一个通过 runtime 创建的 <code>BAOPerson</code> 的子类 <code>NSKVONotifying_BAOPerson</code>。</p><p>下面我们可以通过打印方法实现的地址来看一下 <code>p1</code> 和 <code>p2</code> 的 <code>setAge</code> 方法实现的地址在添加 KVO 前后有什么变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过methodForSelector找到方法实现的地址</span><br><span class="line">NSLog(@&quot;添加 KVO 之前 - p1 = %p, p2 = %p&quot;, [p1 methodForSelector: @selector(setAge:)], [p2 methodForSelector: @selector(setAge:)]);</span><br><span class="line">    </span><br><span class="line">NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;添加 KVO 之后 - p1 = %p, p2 = %p&quot;, [p1 methodForSelector: @selector(setAge:)], [p2 methodForSelector: @selector(setAge:)]);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-name-before-after.png" alt=""></p><p>执行上述代码，可以发现：在添加 KVO 之前，<code>p1</code> 和 <code>p2</code> 的 <code>setAge</code> 方法实现的地址是相同的；在添加 KVO 之后， <code>p1</code> 的 <code>setAge</code> 方法实现的地址发生了改变。通过打印方法实现可以证明，<code>p1</code> 的 <code>setAge</code> 方法的实现由 <code>BAOPerson</code> 类方法中的 <code>setAge</code> 方法转换成了 Foundation 框架中的 C 函数 <code>_NSSetIntValueAndNotify</code>。</p><p>事实上，Foundation 框架中很多例如 <code>_NSSetBoolValueAndNotify</code>、<code>_NSSetCharValueAndNotify</code>、<code>_NSSetFloatValueAndNotify</code>、<code>_NSSetLongValueAndNotify</code> 等函数。</p><p>为了查看 Foundation 框架中的相关函数，我们找到 Foundation 文件，通过命令行查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-value-and-notify-methods.png" alt=""></p><h1 id="中间类内部结构"><a href="#中间类内部结构" class="headerlink" title="中间类内部结构"></a>中间类内部结构</h1><p><code>NSKVONotifying_BAOPerson</code> 作为 <code>BAOPerson</code> 的子类，其 <code>superclass</code> 指针指向 <code>BAOPerson</code> 类，其内部对 <code>setAge</code> 方法做了单独的实现，那么 <code>NSKVONotifying_BAOPerson</code> 同 <code>BAOPerson</code> 类的差别可能就在于其内存储的对象方法及实现不同。我们通过 runtime 分别打印 <code>BAOPerson</code> 类对象和 <code>NSKVONotifying_BAOPerson</code> 类对象内存储的对象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = 1;</span><br><span class="line">    p1.age = 2;</span><br><span class="line">    p2.age = 2;</span><br><span class="line">    </span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">    [self printMethods: object_getClass(p2)];</span><br><span class="line">    [self printMethods: object_getClass(p1)];</span><br><span class="line">    </span><br><span class="line">    p1.age = 10;</span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printMethods:(Class)cls &#123;</span><br><span class="line">    unsigned int count;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    NSMutableString *methodNames = [NSMutableString string];</span><br><span class="line">    [methodNames appendFormat:@&quot;%@ - &quot;, cls];</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        NSString *methodName  = NSStringFromSelector(method_getName(method));</span><br><span class="line"></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:@&quot; &quot;];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;, methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的打印结果如下：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-in-middle-class.png" alt=""></p><p>可以发现，<code>NSKVONotifying_BAOPerson</code> 中有 4 个对象方法，分别是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setAge:</span><br><span class="line">class</span><br><span class="line">dealloc</span><br><span class="line">_isKVOA</span><br></pre></td></tr></table></figure></p><p><code>NSKVONotifying_BAOPerson</code> 重写 <code>class</code> 方法是为了隐藏 <code>NSKVONotifying_BAOPerson</code> 不被外界看到。我们在 <code>p1</code> 添加 KVO 之后，分别打印 <code>p1</code> 和 <code>p2</code> 对象的 <code>class</code>，可以发现它们都返回 <code>BAOPerson</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@, %@&quot;, [p1 class], [p2 class]);</span><br><span class="line">// 打印结果 BAOPerson, BAOPerson</span><br></pre></td></tr></table></figure><p>综上，我们可以画出 <code>NSKVONotifying_BAOPerson</code> 的内部结构及方法调用顺序。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo002.png" alt=""></p><h1 id="验证-didChangeValueForKey-内部调用-observeValueForKeyPath-ofObject-change-context-方法"><a href="#验证-didChangeValueForKey-内部调用-observeValueForKeyPath-ofObject-change-context-方法" class="headerlink" title="验证 didChangeValueForKey: 内部调用 observeValueForKeyPath:ofObject:change:context: 方法"></a>验证 <code>didChangeValueForKey:</code> 内部调用 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法</h1><p>在 <code>BAOPerson</code> 类中重写 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，模拟它们的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(NSInteger)age</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;override setAge&quot;);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey: - begin&quot;);</span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey: - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey: - begin&quot;);</span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey: - end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行上述代码，可以确定是在 <code>didChangeValueForKey:</code> 方法内部调用了监听者的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-did-change-value-for-key.png" alt=""></p><p>根据上述原理，可以通过调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 来手动触发 KVO。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5adab70cf265da0b736d37a8" target="_blank" rel="noopener">iOS底层原理总结 - 探寻KVO本质</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。&lt;a href=&quot;https://github.com/baochuquan/BAOStudy&quot; target=&quot;_
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="KVO" scheme="http://chuquan.me/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>GCD 原理详解</title>
    <link href="http://chuquan.me/2018/12/01/gcd-introduce/"/>
    <id>http://chuquan.me/2018/12/01/gcd-introduce/</id>
    <published>2018-12-01T12:55:11.000Z</published>
    <updated>2018-12-01T14:07:37.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h1><p>GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。</p><h1 id="GCD-基本概念"><a href="#GCD-基本概念" class="headerlink" title="GCD 基本概念"></a>GCD 基本概念</h1><p>GCD 主要包含两个核心概念：<strong>任务</strong> 和 <strong>队列</strong>。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p><strong>任务</strong>：即要在线程中执行的那段代码。GCD 将任务定义在 block 中。</p><p>任务的执行主要有两种方式：<strong>同步执行（sync）</strong> 和 <strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列中的任务执行结束，是否具备开启新线程的能力</strong>。因此，根据任务的执行方式可以将任务分成两种类型：</p><p><strong>同步任务（sync）</strong></p><ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul><p><strong>异步任务（async）</strong></p><ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul><blockquote><p>注意： <strong>异步任务（async）</strong> 虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（Dispatch Queue）</strong>：即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic07.png" alt=""></p><p>在 GCD 中有两种队列：<strong>串行队列</strong> 和 <strong>并发队列</strong>。两者的主要区别是：<strong>执行顺序不同，开启线程数不同</strong>。</p><p><strong>串行队列</strong></p><ul><li>每次只有一个任务被执行。（只开启一个线程，一个任务执行完毕后，在执行下一个任务）<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic08.png" alt=""></li></ul><p><strong>并发队列</strong></p><ul><li>允许多个任务（同时）执行。（可以开启多个线程，并同时执行任务）<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic09.png" alt=""></li></ul><blockquote><p>注意：<strong>并发队列</strong> 的并发功能只有在异步（dispatch_async）函数下才有效。</p></blockquote><h1 id="GCD-使用方法"><a href="#GCD-使用方法" class="headerlink" title="GCD 使用方法"></a>GCD 使用方法</h1><p>GCD 的使用主要包含两个步骤：</p><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统会根据任务类型执行任务（同步执行或异步执行）</li></ol><h2 id="队列的创建-获取"><a href="#队列的创建-获取" class="headerlink" title="队列的创建/获取"></a>队列的创建/获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t</span><br><span class="line">dispatch_queue_create(const char *_Nullable label,</span><br><span class="line">dispatch_queue_attr_t _Nullable attr)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>label</code>：表示队列的唯一标识符，用于 DEBUG，可为空。</li><li><code>attr</code>：表示队列的类型。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列；<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><hr><p>对于串行队列，GCD 提供了一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。</p><ul><li><strong>所有放在主队列的任务，都会在主线程执行</strong>。</li><li>可使用 <code>dispatch_get_main_queue()</code> 获取主队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></li></ul><hr><p>对于并发队列，GCD 默认提供了 <strong>全局并发队列（Global Dispatch Queue）</strong>。</p><ul><li>可使用 <code>dispatch_get_global_queue</code> 获取全局并发队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure></li></ul><p>GCD 提供了 4 个 <strong>全局并发队列</strong>，分别对应不同的优先级。</p><ul><li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li><li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li><li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li><li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台队列</li></ul><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>GCD 提供了同步执行任务的创建方法 <code>dispatch_sync</code> 和异步执行任务创建方法 <code>dispatch_async</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="GCD-使用组合"><a href="#GCD-使用组合" class="headerlink" title="GCD 使用组合"></a>GCD 使用组合</h1><p>GCD 有两种队列（串行队列/并发队列），两种任务（同步任务/异步任务），可以得到 4 种不同的使用组合。</p><blockquote><ol><li>同步任务 + 并发队列</li><li>异步任务 + 并发队列</li><li>同步任务 + 串行队列</li><li>异步任务 + 串行队列</li></ol></blockquote><p>实际上，前文还提到两种特殊的队列：全局并发队列、主队列。全局并发队列可作为普通并发队列使用。但是主队列比较特殊，因此又得到 2 种组合：</p><blockquote><ol><li>同步任务 + 主队列</li><li>异步任务 + 主队列</li></ol></blockquote><h2 id="同步执行-并发队列"><a href="#同步执行-并发队列" class="headerlink" title="同步执行 + 并发队列"></a>同步执行 + 并发队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 并发队列</span><br><span class="line"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);          // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic01.png" alt=""></p><p>上图所示为 <code>同步任务 + 并发队列</code> 的工作原理。</p><ul><li><code>syncConcurrent</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至并行队列，并行队列允许多任务同时执行，但由于加入的队列是同步任务，不会开启新线程，在主线程执行。</li><li><code>syncConcurrent</code> 会被同步任务阻塞。</li></ul><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---begin</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---end</span><br></pre></td></tr></table></figure></p><h2 id="异步任务-并发队列"><a href="#异步任务-并发队列" class="headerlink" title="异步任务 + 并发队列"></a>异步任务 + 并发队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 并发队列</span><br><span class="line"> * 特点：可以开启多个线程，任务交替（同时）执行。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic02.png" alt=""></p><p>上图所示为 <code>异步任务 + 并行队列</code> 的工作原理。</p><ul><li><code>asyncConcurrent</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至并行队列，并行队列允许多任务同时执行，且异步任务可以开启新线程，因此每个异步任务都能启动一个独立的线程执行。</li><li><code>asyncConcurrent</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600003e6d580&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncConcurrent---begin</span><br><span class="line">asyncConcurrent---end</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步任务-串行队列"><a href="#同步任务-串行队列" class="headerlink" title="同步任务 + 串行队列"></a>同步任务 + 串行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 串行队列</span><br><span class="line"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic03.png" alt=""></p><p>上图所示为 <code>同步任务 + 串行队列</code> 的工作原理。</p><ul><li><code>syncSerial</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至串行队列，串行队列不允许多任务同时执行，因此同步任务在当前线程执行（主线程）。</li><li><code>syncSerial</code> 会被同步任务阻塞。</li></ul><h2 id="异步任务-串行队列"><a href="#异步任务-串行队列" class="headerlink" title="异步任务 + 串行队列"></a>异步任务 + 串行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 串行队列</span><br><span class="line"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic04.png" alt=""></p><p>上图所示为 <code>异步任务 + 串行队列</code> 的工作原理。</p><ul><li><code>asyncSerial</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至串行队列，异步任务能开启新线程，但是串行队列不允许多任务，所以只能开启一条新线程。</li><li><code>asyncSerial</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600001ef5d00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncSerial---begin</span><br><span class="line">asyncSerial---end</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步任务-主队列"><a href="#同步任务-主队列" class="headerlink" title="同步任务 + 主队列"></a>同步任务 + 主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 主队列</span><br><span class="line"> * 特点(主线程调用)：互等卡主不执行。</span><br><span class="line"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic05.png" alt=""></p><p>上图所示为 <code>同步任务 + 主队列</code> 的工作原理。</p><ul><li><code>syncMain</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至主队列，同步任务不会开启新线程，且主队列（属于串行队列）中的任务只能在主线程执行。</li><li><code>syncMain</code> 会被同步任务阻塞。但是需要注意的是 <code>syncMain</code> 和同步任务均在主队列中，同步任务需要等待 <code>syncMain</code> 执行完毕，因此产生死锁。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">崩溃</span><br></pre></td></tr></table></figure></p><p>对于这种情况，可以将 <code>syncMain</code> 放置新线程执行以避免产生死锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure></p><h2 id="异步任务-主队列"><a href="#异步任务-主队列" class="headerlink" title="异步任务 + 主队列"></a>异步任务 + 主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 主队列</span><br><span class="line"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic06.png" alt=""></p><p>上图所示为 <code>异步任务 + 主队列</code> 的工作原理。</p><ul><li><code>asyncMain</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至主队列，异步任务能开启新线程，但是主队列（属于串行队列）中的任务只能在主线程执行。</li><li><code>asyncMain</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncMain---begin</span><br><span class="line">asyncMain---end</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p><h1 id="GCD-应用"><a href="#GCD-应用" class="headerlink" title="GCD 应用"></a>GCD 应用</h1><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic10.png" alt=""></p><p>上图所示为线程间通信的工作原理。</p><ul><li><code>communication</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至全局队列（并行队列），异步任务能开启新线程，因此异步任务在新线程执行。</li><li><code>communication</code> 不会被异步任务阻塞。</li><li>当异步任务执行完成后，再将一个异步任务添加至主队列，主队列中的任务都在主线程执行，所以该异步任务在主线程执行。从而达到线程间通信的目的。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000022ddd00&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a></li><li><a href="https://www.jianshu.com/p/fbe6a654604c" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCD-简介&quot;&gt;&lt;a href=&quot;#GCD-简介&quot; class=&quot;headerlink&quot; title=&quot;GCD 简介&quot;&gt;&lt;/a&gt;GCD 简介&lt;/h1&gt;&lt;p&gt;GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="GCD" scheme="http://chuquan.me/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 关联对象与 Method Swizzling</title>
    <link href="http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/"/>
    <id>http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/</id>
    <published>2018-11-23T11:39:37.000Z</published>
    <updated>2018-11-23T11:44:54.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h1><p>关联对象，顾名思义，即通过唯一键（<code>key</code>）连接（关联）至某个类的实例上的对象。</p><p>那么什么时候会用到关联对象呢？</p><p>比如，我们需要对内置类 <code>NSArray</code> 添加一个属性（不使用继承）。如何解决？分类似乎只能添加方法。当我们了解关联对象后，就可以轻松实现。</p><h2 id="关联对象基础"><a href="#关联对象基础" class="headerlink" title="关联对象基础"></a>关联对象基础</h2><h3 id="设置关联对象"><a href="#设置关联对象" class="headerlink" title="设置关联对象"></a>设置关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是 <code>self</code></li><li><code>key</code>: 唯一键，在获取值时通过该键获取，通常是使用 <code>static const void *</code> 来声明</li><li><code>value</code>: 关联所设置的值</li><li><code>policy</code>: 内存管理策略</li></ul><h4 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,             // 表示弱引用关联，通常是基本数据类型</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,   // 表示强引用关联对象，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,     // 表示关联对象copy，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,         // 表示强引用关联对象，不是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403            // 表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象释放时，会根据设置关联对象时采用的策略来决定是否释放关联对象。当策略为 <code>RETAIN/COPY</code> 时，释放关联对象。当策略为 <code>ASSIGN</code> 时，不释放关联对象。</p><h3 id="获取关联对象"><a href="#获取关联对象" class="headerlink" title="获取关联对象"></a>获取关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是传 <code>self</code>，在设置关联时所指定的与哪个对象关联的那个对象</li><li><code>key</code>: 唯一键，在设置关联值所指定的键</li></ul><h3 id="取消关联对象"><a href="#取消关联对象" class="headerlink" title="取消关联对象"></a>取消关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure><p>取消对象的所有关联对象。如果要取消指定的关联对象，可使用 <code>setAssociatedObject</code> 设置为 <code>nil</code> 来实现。</p><h2 id="关联对象应用"><a href="#关联对象应用" class="headerlink" title="关联对象应用"></a>关联对象应用</h2><p>给 <code>UIViewController</code> 添加一个是否需要登录的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL needToLogin;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const char *ViewControllerNeedToLoginKey = &quot;ViewControllerNeedToLoginKey&quot;;</span><br><span class="line"></span><br><span class="line">- (void)setNeedToLogin:(BOOL)needToLogin &#123;</span><br><span class="line">    objc_setAssociatedObject(self, ViewControllerNeedToLoginKey, @(needToLogin), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)needToLogin &#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, ViewControllerNeedToLoginKey) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><p>Method Swizzling，顾名思义，就是将两个方法的实现交换。</p><p>那么什么时候会用到 Method Swizzling 呢？</p><p>比如，在开发中，我们可能会遇到系统提供的 API 不能满足实际需求。我们希望能够修改它以达到期望的效果。</p><h2 id="Method-Swizzling-原理"><a href="#Method-Swizzling-原理" class="headerlink" title="Method Swizzling 原理"></a>Method Swizzling 原理</h2><p>Method Swizzling 的实现充分利用了 <a href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C runtime 动态绑定机制</a>。</p><p>在 Objective-C 中调用方法，其实是向一个对象发送消息，而查找消息的唯一依据是方法名 <code>selector</code>。每个类都有一个方法列表 <code>objc_method_list</code>，存放着其所有的方法 <code>objc_method</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法 <code>objc_method</code> 保存了方法名（<code>SEL</code>）和方法实现（<code>IMP</code>）的映射关系。Method Swizzling 其实就是重置了 <code>SEL</code> 和 <code>IMP</code> 的映射关系。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-method-swizzling.png" alt=""></p><h2 id="Method-Swizzling-基础"><a href="#Method-Swizzling-基础" class="headerlink" title="Method Swizzling 基础"></a>Method Swizzling 基础</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 方法名</li></ul><h3 id="获取方法实现"><a href="#获取方法实现" class="headerlink" title="获取方法实现"></a>获取方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nonnull class_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 要添加方法的方法名</li><li><code>imp</code>: 要添加方法的方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nullable class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 目标方法的方法名</li><li><code>imp</code>: 方法的新方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="交换方法实现"><a href="#交换方法实现" class="headerlink" title="交换方法实现"></a>交换方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h3 id="获取方法的编码类型"><a href="#获取方法的编码类型" class="headerlink" title="获取方法的编码类型"></a>获取方法的编码类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * _Nullable method_getTypeEncoding(Method _Nonnull m)</span><br></pre></td></tr></table></figure><h2 id="Method-Swizzling-应用"><a href="#Method-Swizzling-应用" class="headerlink" title="Method Swizzling 应用"></a>Method Swizzling 应用</h2><p>通过分类允许 <code>NSObject</code> 对任意两个方法进行 Method Swizzling。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSEL);</span><br><span class="line">    if (originalMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(self, targetSEL);</span><br><span class="line">    if (targetMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_addMethod(self, originalSEL, class_getMethodImplementation(self, originalSEL), method_getTypeEncoding(originalMethod));</span><br><span class="line">    class_addMethod(self, targetSEL, class_getMethodImplementation(self, targetSEL), method_getTypeEncoding(targetMethod));</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod(self, originalSEL), class_getInstanceMethod(self, targetSEL));</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Class metaClass = object_getClass((id)self);</span><br><span class="line">    return [metaClass swizzleMethod:originalSEL withMethod:targetSEL error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/c68cc81ef763" target="_blank" rel="noopener">iOS runtime实战应用：关联对象</a></li><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h1&gt;&lt;p&gt;关联对象，顾名思义，即通过唯一键（&lt;code&gt;key&lt;/code&gt;）连接（关联）至某个类的实例上的对象。&lt;/p&gt;
&lt;p&gt;那么
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="关联对象" scheme="http://chuquan.me/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Method Swizzling" scheme="http://chuquan.me/tags/Method-Swizzling/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯·圣彼得堡之旅</title>
    <link href="http://chuquan.me/2018/11/03/st-petersburg/"/>
    <id>http://chuquan.me/2018/11/03/st-petersburg/</id>
    <published>2018-11-03T13:00:47.000Z</published>
    <updated>2018-11-20T14:18:45.563Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400" alt=""></div><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5261430&auto=1&height=66"></iframe><p>盼了一年，终于盼来了公司的年度旅行。经过两轮的投票角逐，圣彼得堡众望所归！旅行时间计划是 10 月 27 日~ 11 月1 日，总共 6 天。我们此次行程总共 29 人，走团签，使用公司的旅行基金，每个人额外补贴 1020 元。</p><p>出发前两天，我花了两个晚上做了一下圣彼得堡的旅行攻略。首先，定位各个推荐景点和餐厅的位置，做到心里有点逼数。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg003.png?x-oss-process=image/resize,w_800" alt=""></p><p>然后，综合日期、天气、距离、开/闭馆等情况（圣彼得堡有不少景点会周期性地选择闭馆），做了一个大致的行程计划。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg002.png?x-oss-process=image/resize,w_500" alt=""></p><h1 id="Day-1（周六）"><a href="#Day-1（周六）" class="headerlink" title="Day 1（周六）"></a>Day 1（周六）</h1><p>前一天周五，我们照常上班，部分人（包括我）选择在公司一直待到凌晨，然后一起打车去机场。服务器一帮人去附近的网吧开黑，客户端则在公司打升级，玩任天堂游戏。我在 B 站上看了几个关于圣彼得堡的纪录片。对我来说，旅行中很大一部分乐趣是源自于旅行前的准备工作。</p><p>北京时间凌晨五点，我们从 T3 航站楼启程飞往新西伯利亚。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg004.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg008.png?x-oss-process=image/resize,w_800" alt=""></p><p>经过四个半小时的飞行，飞越了数千公里的冰川，最终抵达新西伯利亚。降落前，从新西伯利亚上空俯瞰整个城市，第一感觉便是衰败。这与我的预期完全不符，心里难免有一些失落。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg005.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg006.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg007.png?x-oss-process=image/resize,w_500" alt=""></p><p>在新西伯利亚机场转机等待了近2个小时，我们踏上了飞往圣彼得堡的行程。经历四个半小时，飞机成功降落于圣彼得堡普尔科沃机场，机舱里响起来热烈的掌声。</p><p>导游和大巴早已在机场等候多时，安置好行李后，我们从机场出发。沿着机场高速，经过跨海大桥，最终抵达我们位于瓦西里岛上的 Park inn 酒店。安排完入住后已经差不多下午2点多了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg009.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg010.png" alt=""></p><p>在客房稍事休息，洗漱一下，我们（@大龙哥，@邱老师，@张成）便出门去逛附近的超市。买了烤鸡、黄瓜、香蕉、面包、啤酒、果汁，然后便是回酒店嗨。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg011.png" alt=""></p><p>来圣彼得堡之前，我听说酒店有游泳池。于是晚上一闲下来，便在酒店一楼大厅瞎转，找游泳池。大厅绕了一圈，一对青年毛子情侣看到了我，小哥立马过来跟我尬聊了起来。小哥用带卷舌的英语，我用蹩脚的 Chinglish。聊了二十分钟，我还是没明白他到底想表达什么。。。</p><h1 id="Day-2（周日）"><a href="#Day-2（周日）" class="headerlink" title="Day 2（周日）"></a>Day 2（周日）</h1><p>一大早起来，打开窗帘，外面已然是白茫茫一片。天气与预期一样，那么计划也是一样。今天行程是冬宫。</p><p>来圣彼得堡之前，我们便以在飞猪上购买了电子票。冬宫早上10点半开放，我们分了好几拨，早早便抵达了冬宫快速通道门口。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg012.png" alt=""></p><p>我们差不多画了5个小时的时间走马观花地逛了一遍冬宫。一楼是古埃及相关的展厅，我没怎么逛。二楼是沙俄以及西方中世纪的一些展品。三楼主要东方的一些展品。二楼的展品尤为绚烂，其中包括两幅达芬奇的真迹（世界仅存14副真迹）。果然不愧为世界四大博物馆，不禁感慨如果圆明园未毁，也许可以与其相媲美。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg013.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg016.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg017.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg015.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg014.png" alt=""></p><p>逛完冬宫差不多已经下午三点半了，早已饥渴难耐，我们打车去附近一家小餐厅Varvara。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg018.png" alt=""></p><p>简餐过后，我们沿着涅瓦大街闲逛，欣赏一下沿途的风景。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg019.png" alt=""></p><h1 id="Day3（周一）"><a href="#Day3（周一）" class="headerlink" title="Day3（周一）"></a>Day3（周一）</h1><p>今天计划的第一站是圣以撒大教堂。刚刚抵达圣以撒大教堂，便遇到一群当地的小孩，冲着我们喊“你好”。尴尬的是我们居然不知道“你好”用俄语怎么说，只能也挥手喊着“你好”予以回应。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg020.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg021.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg022.png" alt=""></p><p>圣以撒大教堂可以允许游客登顶观光，俯瞰整个圣彼得堡。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg023.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg026.png" alt=""></p><p>与圣以撒大教堂合完影之后，我们便步行向北前往十二月党人广场，广场的中央是彼得大帝青铜骑士像。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg024.png" alt=""></p><p>在广场逗留了一会儿，大家分头行动，我们（@邱老师，@大龙哥，@刘杨）决定去救世主滴血大教堂。抵达滴血大教堂，有一些一行，教堂的洋葱头正在维修，据说从去年至今一直在维修。不过教堂的内饰真的是美轮美奂，所有的壁画都是用指甲大小的马赛克拼接而成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg027.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg025.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg028.png?x-oss-process=image/resize,w_500" alt=""></p><p>救世主滴血大教堂参观完毕，我们（@吴迪，@海侠，@大龙哥，@邱老师，@刘杨）来到了涅瓦大街吃午餐。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg030.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg029.png" alt=""></p><p>吃完饭，我们在旁边的纪念品店里逛了一会儿，然后他们准备去商场购物。而我则打算去马路对面的喀山大教堂去拍照。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg032.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg031.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg034.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg033.png?x-oss-process=image/resize,w_500" alt=""></p><p>拍完照，我便独自向我们约定的商场步行而去，与大家汇合。</p><h1 id="Day4（周二）"><a href="#Day4（周二）" class="headerlink" title="Day4（周二）"></a>Day4（周二）</h1><p>雪后第一天尤其寒冷，今天的计划则是去彼得保罗要塞观光。彼得堡罗要塞其实就是一个小岛，岛上有监狱（曾关押过高尔基）、教堂（埋葬了历代沙皇）、博物馆，我们也是挨个儿参观了一遍。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg035.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg037.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg036.png" alt=""></p><p>差不多下午一点参观完各个景点，我们在一个小博物馆里逗留了一会儿，然后决定去岛上的一家推荐餐厅。餐厅位于小岛的西边，迎着涅瓦河。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg039.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg038.png" alt=""></p><p>餐后，大家决定一起去看阿芙乐尔号巡洋舰。在路上顶着寒风大概走了半个小时终于到了阿芙乐尔号巡洋舰的地址。参观的总体感觉是比较坑，门票大约70元人民币，比冬宫还贵。里面只有一个小小的博物馆而已。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg040.png" alt=""></p><h1 id="Day5（周三）"><a href="#Day5（周三）" class="headerlink" title="Day5（周三）"></a>Day5（周三）</h1><p>昨天在去往阿芙乐尔号的路上简直被吹成了傻逼，对于今天去叶卡捷琳娜宫的计划我有些犹豫。“既然都来了，就去看看吧”这样的念头促成我又做了一次傻逼的决定。叶卡捷琳娜宫只在下午一点后对散客开放，并且每15分钟放入20来人。我们上午到叶宫，在前面的花园里逛了一圈。差不多下午一点，到叶宫入口排队。寒风中吹了近两个小时才进入叶宫。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg041.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg042.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg043.png" alt=""></p><p>说实话，叶宫真心无法与冬宫相比，除了琥珀宫，里面基本都是些宴会大厅。另外，加上这几天的行程，基本已经属于审美疲劳状态。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg044.png" alt=""></p><h1 id="Day5（周四）"><a href="#Day5（周四）" class="headerlink" title="Day5（周四）"></a>Day5（周四）</h1><p>早上10:20在酒店大厅集合去机场。第一次来俄罗斯，并且是有如此浓厚艺术气息的圣彼得堡，虽然旅程很短暂，但是内心很满足。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="游记" scheme="http://chuquan.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="自由行" scheme="http://chuquan.me/tags/%E8%87%AA%E7%94%B1%E8%A1%8C/"/>
    
      <category term="俄罗斯" scheme="http://chuquan.me/tags/%E4%BF%84%E7%BD%97%E6%96%AF/"/>
    
      <category term="圣彼得堡" scheme="http://chuquan.me/tags/%E5%9C%A3%E5%BD%BC%E5%BE%97%E5%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 消息传递与转发</title>
    <link href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/"/>
    <id>http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/</id>
    <published>2018-10-20T09:15:32.000Z</published>
    <updated>2018-11-27T13:04:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，在 C 语言的基础上实现了面向对象的功能。在 runtime 中，对象用结构体表示，方法用函数表示。</p><p>C 语言是一门静态语言，其在编译时决定调用哪个函数。而 Objective-C 则是一门动态语言，其在编译时不能决定最终执行时调用哪个函数（Objective-C 中函数调用称为消息传递）。Objective-C 的这种动态绑定机制正是通过 runtime 这样一个中间层实现的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-runtime-hierachry.png?x-oss-process=image/resize,w_300" alt=""></p><p>为了分析 runtime 是如何进行动态绑定，我们首先需要了解一下 Objective-C 中类与对象等基本结构在 C 语言层面是如何实现的。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Objective-C-类"><a href="#Objective-C-类" class="headerlink" title="Objective-C 类"></a>Objective-C 类</h2><p>Objective-C 类是由 <code>Class</code> 类型表示的，它本质上是一个指向 <code>objc_class</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line"></span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure></p><h2 id="Objective-C-对象"><a href="#Objective-C-对象" class="headerlink" title="Objective-C 对象"></a>Objective-C 对象</h2><p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向 <code>objc_object</code> 结构体的指针。如下所示为 <code>objc/objc.h</code> 中关于对象的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>objc_object</code> 结构体中只有一个成员，即指向其类的 <code>isa</code> 指针。<strong>当向一个 Objective-C 对象发送消息时，runtime 会根据实例对象的 <code>isa</code> 指针找到其所属的类。Runtime 会在类的方法列表以及父类的方法列表中去寻找与消息对应的 <code>selector</code> 指向的方法，找到后即运行该方法。</strong></p><h2 id="Objective-C-元类（meta-class）"><a href="#Objective-C-元类（meta-class）" class="headerlink" title="Objective-C 元类（meta class）"></a>Objective-C 元类（meta class）</h2><p><code>meta-class</code> 是一个<strong>类对象的类</strong>。在 Objective-C 中，所有的类本身也是一个对象。事实上，在很多原型编程语言也采用这种“万物皆对象”的设计思想，如：Io。</p><p>通过向该对象发送消息，即可实现对类方法的调用。前提是类的 <code>isa</code> 指针必须指向一个包含这些类方法的 <code>objc_class</code> 结构体。<code>meta-class</code> 中存储着一个类的所有类方法。所以，类对象的 <code>isa</code> 指针指向的就是 <code>meta-class</code>。</p><ul><li><strong>当向一个对象发送消息时，runtime 会在这个对象所属的类的方法列表中查找方法。</strong></li><li><strong>当向一个类发送消息时，runtime 会在这个类的 meta-class 的方法列表中查找。</strong></li></ul><p>思考一下，<code>meta-class</code> 也是一个类，也可以向它发送一个消息，那么它的 <code>isa</code> 又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C 的设计者让所有的 <code>meta-class</code> 的 <code>isa</code> 指向基类的 <code>meta-class</code>，以此作为它们的所属类。</p><p>下图所示，为 Objective-C 对象在内存中的引用关系图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-time-message-send.png" alt=""></p><h2 id="Objective-C-方法"><a href="#Objective-C-方法" class="headerlink" title="Objective-C 方法"></a>Objective-C 方法</h2><p>方法实际上是一个指向 <code>objc_method</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体中包含成员 <code>SEL</code> 和 <code>IMP</code>，两者将方法的名字与实现进行了绑定。通过 <code>SEL</code>，可以找到对应的 <code>IMP</code>，从而调用方法的具体实现。</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>SEL</code> 又称选择器，是一个指向 <code>objc_selector</code> 结构体的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>方法的 <code>selector</code> 用于表示运行时方法的名字。<strong>Objective-C 在编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ <code>Int</code> 类型的地址），即 <code>SEL</code>。</strong></p><p>由于一个类的方法列表中不能存在两个相同的 <code>SEL</code>，所以 Objective-C 不支持重载。但是不同类之间可以存在相同的 <code>SEL</code>，因为不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中去根据 <code>selector</code> 去寻找自己对应的 <code>IMP</code>。</p><p>通过下面三种方法可以获取 <code>SEL</code>：</p><ul><li><code>sel_registerName</code> 函数</li><li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li><li><code>NSSeletorFromString()</code> 方法</li></ul><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code> 本质上就是一个函数指针，指向方法实现的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL,...);</span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><code>id</code>：指向 <code>self</code> 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）</li><li><code>SEL</code>：方法选择器</li><li><code>...</code>：方法的参数列表</li></ul><p><code>SEL</code> 与 <code>IMP</code> 的关系类似于哈希表中 <code>key</code> 与 <code>value</code> 的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p><h1 id="消息传递（方法调用）"><a href="#消息传递（方法调用）" class="headerlink" title="消息传递（方法调用）"></a>消息传递（方法调用）</h1><p>在 Objective-C 中，<strong>消息直到运行时才绑定到方法实现上</strong>。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息函数的调用，即 <code>objc_msgSend</code>。这个函数将消息接收者和方法名作为主要参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)                    // 不带参数</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)    // 带参数</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 通过以下几个步骤实现了动态绑定机制。</p><ul><li>首先，获取 <code>selector</code> 指向的方法实现。由于相同的方法可能在不同的类中有着不同的实现，因此根据 <code>receiver</code> 所属的类进行判断。</li><li>其次，传递 <code>receiver</code> 对象、方法指定的参数来调用方法实现。</li><li>最后，返回方法实现的返回值。</li></ul><p>消息传递的关键在于前文讨论过的 <code>objc_class</code> 结构体，其有两个关键的字段：</p><ul><li><code>isa</code>：指向父类的指针</li><li><code>methodLists</code>: 类的方法分发表（<code>dispatch table</code>）</li></ul><p>当创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 <code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承链。</p><p>下图所示为消息传递过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-messaging-framework.png" alt=""></p><ul><li>当消息传递给一个对象时，首先从运行时系统缓存 <code>objc_cache</code> 中进行查找。如果找到，则执行。否则，继续执行下面步骤。</li><li><code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法分发表 <code>methodLists</code> 中查找方法的 <code>selector</code>。如果未找到，将沿着类的 <code>isa</code> 找到其父类，并在父类的分发表 <code>methodLists</code> 中继续查找。</li><li>以此类推，一直沿着类的继承链追溯至 <code>NSObject</code> 类。一旦找到 <code>selector</code>，传入相应的参数来执行方法的具体实现，并将该方法加入缓存 <code>objc_cache</code> 。如果最后仍然没有找到 <code>selector</code>，则会进入<strong>消息转发</strong>流程（下文将进行介绍）。</li></ul><h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>当一个对象能接收一个消息时，会走正常的消息传递流程。当一个对象无法接收某一消息时，会发生什么呢？默认情况下，如果以 <code>[object message]</code> 的形式调用方法，如果 <code>object</code> 无法响应 <code>message</code> 消息时，编译器会报错。如果是以 <code>performSeletor:</code> 的形式调用方法，则需要等到运行时才能确定 <code>object</code> 是否能接收 <code>message</code> 消息。如果不能，则程序崩溃。</p><p>对于后者，当不确定一个对象是否能接收某个消息时，可以调用 <code>respondsToSelector:</code> 来进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，当一个对象无法接收某一消息时，就会启动所谓“消息转发（message forwarding）”机制。通过消息转发机制，我们可以告诉对象如何处理未知的消息。</p><p>消息转发机制大致可分为三个步骤：</p><ul><li>动态方法解析（Dynamic Method Resolution）</li><li>备用接收者</li><li>完整消息转发</li></ul><p>下图所示为消息转发过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/ios-message-forwarding.png" alt=""></p><h2 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h2><p>对象在接收到未知的消息时，首先会调用所属类的类方法 <code>+resolveClassMethod:</code> 或实例方法 <code>+resolveInstanceMethod:</code>。</p><p>在这两个方法中，我们可以为未知消息新增一个“处理方法”，通过运行时 <code>class_addMethod</code> 函数动态添加到类中。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // 方法实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方案更多的是为了实现@dynamic属性。</p><h2 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h2><p>如果在上一步无法处理消息，则 runtime 会继续调用 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p><p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是 <code>self</code>） 的对象，则这个对象会称为消息的新接收者，消息会被分发到这个对象。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([selString isEqualToString:@&quot;walk&quot;]) &#123;</span><br><span class="line">        return self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><h2 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h2><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>这步调用 <code>methodSignatureForSelector</code> 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 <code>nil</code>，则说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;  </span><br><span class="line">    return [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回 <code>methodSignature</code>，则进入 <code>forwardInvocation</code>。对象会创建一个表示消息的 <code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在 <code>anInvocation</code> 中，包括 <code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以利用备用接受者和完整消息转发实现对接受消息对象的转移，可以实现“多重继承”的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">Objective-C Runtime · 笔试面试知识整理</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li><li><a href="https://www.jianshu.com/p/f493bc6a949e" target="_blank" rel="noopener">iOS内功篇：runtime</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://chuquan.me/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Run Loop 原理详解</title>
    <link href="http://chuquan.me/2018/10/06/understand-ios-runloop/"/>
    <id>http://chuquan.me/2018/10/06/understand-ios-runloop/</id>
    <published>2018-10-06T12:08:25.000Z</published>
    <updated>2018-12-03T15:56:06.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或框架中，需要实现一种这样机制：线程能够随时处理事件或消息，并且不会在执行完成后退出。这种机制称为 Event Loop，其一般逻辑吐下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function main</span><br><span class="line">    initialize()</span><br><span class="line">    while message != quit</span><br><span class="line">        message := get_next_message()</span><br><span class="line">        process_message(message)</span><br><span class="line">    end while</span><br><span class="line">end function</span><br></pre></td></tr></table></figure><p>Event Loop 在很多系统或框架中都有对应的实现，如 Node.js 的事件处理，Windows 程序的消息循环，OSX/iOS 中的 RunLoop。实现这种机制的关键在于：如何管理事件/消息，如何让线程在没有处理任务时休眠以避免资源占用，如何在事件/消息到来时唤醒。</p><h1 id="Run-Loop"><a href="#Run-Loop" class="headerlink" title="Run Loop"></a>Run Loop</h1><p>Run Loop 是 OSX/iOS 平台下对 Event Loop 机制的一种实现。当没有事件/消息时，Run Loop 进入休眠状态。当有事件/消息时，Run Loop 调用对应的 Handler 进行处理。如下图所示为 Run Loop 的工作模式示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop.png" alt=""></p><p>由上图可知，Run Loop 从 <strong>Input sources</strong> 和 <strong>Timer sources</strong> 接收事件，然后在线程中处理。</p><p>Run Loop 本质上就是一个对象，其管理需要处理的事件/消息，并提供一个入口函数来执行上面 Event Loop 的逻辑。线程执行该函数后，会一直处于其内部的“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环中，直到循环结束（比如传入 <code>quit</code> 的消息），函数返回。</p><p>OSX/iOS 中提供了两种 Run Loop 的实现：</p><ul><li><code>CFRunLoopRef</code>：CoreFoundation 框架对于 Run Loop 的实现，其提供纯 C 函数的 API（线程安全）。</li><li><code>NSRunLoop</code>：基于 <code>CFRunLoopRef</code> 的封装，其提供面向对象的 API（非线程安全）。</li></ul><h1 id="Run-Loop-与线程"><a href="#Run-Loop-与线程" class="headerlink" title="Run Loop 与线程"></a>Run Loop 与线程</h1><p>Run Loop 和线程是一一对应的。每个线程（包括主线程）都有一个对应的 Run Loop 对象。Run Loop 对象的创建发生在第一次获取时（如果不主动获取，它一直都不会被创建）；Run Loop 对象的销毁发生在线程结束时。</p><p>用户无法创建 Run Loop 对象，但可以获取系统提供的 Run Loop 对象。注意：<strong>只能在一个线程的内部获取其 Run Loop 对象，主线程不受限制</strong>。</p><p>关于 Run Loop 的启动，主线程的 Run Loop 在应用启动时自动启动，其他线程的 Run Loop 默认不会自动启动，需手动启动。</p><h1 id="Run-Loop-Source"><a href="#Run-Loop-Source" class="headerlink" title="Run Loop Source"></a>Run Loop Source</h1><p>从上面 Run Loop 工作模式示意图中可知，Run Loop 有两种接收事件的渠道：Input Source、Timer Source。</p><h2 id="Input-Source"><a href="#Input-Source" class="headerlink" title="Input Source"></a>Input Source</h2><p>Input Source 可分为三类：</p><ul><li><code>Custom Input Sources</code>（<code>Source0</code>）：用户自定义的事件，不会主动触发事件，也不会主动唤醒 Run Loop 的线程。</li><li><code>Port-Based Sources</code>（<code>Source1</code>）：系统底层的 Port 事件（Mac Port），例如 <code>CFSocketRef</code>。一般用于通过内核和其他线程相互发送消息，应用层很少使用。这种 Source 可以主动唤醒 Run Loop 的线程。</li></ul><h2 id="Timer-Source"><a href="#Timer-Source" class="headerlink" title="Timer Source"></a>Timer Source</h2><p>Timer Source 即定时器事件。</p><h1 id="Run-Loop-Observer"><a href="#Run-Loop-Observer" class="headerlink" title="Run Loop Observer"></a>Run Loop Observer</h1><p>Run Loop 通过监控 Source 来决定是否执行处理程序。而 Runloop Observer 则监控 Runloop 本身的状态。 Runloop Observer 可监控的 runloop 事件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0),   // 即将进入 Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1),   // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6),   // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7),   // 即将退出 Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Run-Loop-Mode"><a href="#Run-Loop-Mode" class="headerlink" title="Run Loop Mode"></a>Run Loop Mode</h1><p>Run Loop Mode 即 Run Loop 工作模式。苹果文档中定义了 5 种 Mode：</p><ul><li><code>NSDefaultRunLoopMode</code></li><li><code>NSConnectionReplyMode</code></li><li><code>NSModalPanelRunLoopMode</code></li><li><code>NSEventTrackingRunLoopMode</code></li><li><code>NSRunLoopCommonModes</code></li></ul><p>iOS 中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和 <code>NSRunLoopCommonModes</code>。 <code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-mode.png" alt=""></p><p>一个 Run Loop 可以包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。Run Loop 在某个时刻只能工作在一个 Mode 下，处理该 Mode 中的 Source/Timer/Observer。如果需要切换 Mode，只能退出 Run Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，使其互不影响。</p><p>如下所示为 Run Loop Mode 和 Run Loop 的部分源码定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">  </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Source/Timer/Observer 被统称为 <code>Mode Item</code>，一个 Item 可以被同时加入多个 Mode。但一个 Item 被重复加入同一个 Mode 时是不会有效果的。如果一个 Mode 中一个 Item 都没有，则 Run Loop 会直接退出，不进入“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环。</p><h2 id="Common-Mode"><a href="#Common-Mode" class="headerlink" title="Common Mode"></a>Common Mode</h2><p>一个 Mode 可以将自己标记为 <code>Common</code>（通过将其 Mode Name 添加到 Run Loop 的 <code>_commonModes</code> 中）。<strong>每当 Run Loop 内容发生变化，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode 里</strong>。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>主线程的 Run Loop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为 <code>Common</code>。<code>kCFRunLoopDefaultMode</code> 是 App 平时所处的状态，<code>UITrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当创建一个 Timer 并加到 <code>kCFRunLoopDefaultMode</code> 时，Timer 会得到重复回调，但此时滑动 TableView 时，Run Loop 会将 Mode 切换为 <code>UITrackingRunLoopMode</code>。这是系统为了保持滑动流畅而做出的 Mode 切换。但这会导致 Timer 不被回调。</p><p>为了让 Timer 能在这两种 Mode 下都能得到回调，有 3 种解决方案：</p><ol><li>将 Timer 分别加入两种 Mode</li><li>将 Timer 加入 Run Loop 的 <code>_commonModeItems</code> 中。因为，Run Loop 发生变化时，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode 里。</li><li>在另一个线程执行和处理 Timer 事件，然后在主线程更新 UI。</li></ol><h1 id="Run-Loop-工作流程"><a href="#Run-Loop-工作流程" class="headerlink" title="Run Loop 工作流程"></a>Run Loop 工作流程</h1><p>下图所示为 Run Loop 工作流程示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-internal-logic.png" alt=""></p><p>如下所示为 Run Loop 工作流程的核心代码整理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">     </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">     </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">  </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// ? 一个基于 port 的Source 的事件。</span><br><span class="line">            /// ? 一个 Timer 到时间了</span><br><span class="line">            /// ? RunLoop 自身的超时时间到了</span><br><span class="line">            /// ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">             </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其内部是一个 do-while 循环。当调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于-Run-Loop-的系统功能"><a href="#基于-Run-Loop-的系统功能" class="headerlink" title="基于 Run Loop 的系统功能"></a>基于 Run Loop 的系统功能</h1><p>如下所示为 App 启动后 Run Loop 的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>modes</code> 成员的状态可知，系统默认注册了 5 个 Mode：</p><ul><li><code>kCFRunLoopDefaultMode</code>：App 的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li><code>UITrackingRunLoopMode</code>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li><code>UIInitializationRunLoopMode</code>：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。</li><li><code>GSEventReceiveRunLoopMode</code>：接收系统事件的内部 Mode，通常用不到。</li><li><code>kCFRunLoopCommonModes</code>：占位的 Mode，无实际作用。</li></ul><h2 id="AutoReleasePool"><a href="#AutoReleasePool" class="headerlink" title="AutoReleasePool"></a>AutoReleasePool</h2><p>App 启动后，系统在主线程 Run Loop 中注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p><p>第一个 Observer 监听了一个事件：</p><ul><li><strong>kCFRunLoopEntry</strong>（即将进入 Loop）：调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，优先级最高，保证在其他所有回调之前创建。</li></ul><p>第二个 Observer 监听了两个事件： </p><ul><li><strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）：调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧池并创建新池。</li><li><strong>kCFRunLoopExit</strong>（即将退出 Loop）：调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。其 order 是 2147483647，优先级最低，保证在其他所有回调之后释放。</li></ul><p>事件回调、Timer 回调一般在主线程执行。这些回调会被 Run Loop 创建的 AutoreleasePool 所环绕，所以不会出现内存泄漏，开发者也不必显式创建自动释放池。</p><h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个 Source1（Mach Port）用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键（锁屏/静音等）、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括：识别 UIGesture、处理屏幕旋转、发送给 UIWindow 等。在此回调中完成的事件包括：UIButton 点击、touchesBegin/Move/End/Cancel 事件等。</p><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）事件，这个 Observer 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p><p>当有 UIGestureRecognizer 的变化（创建/销毁/状态改变）时，这个回调都会进行相应处理。</p><h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠） 和 <strong>kCFRunLoopExit</strong>（即将退出 Loop），回调执行的函数会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 Run Loop 后，Run Loop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20 这几个时间点。Run Loop为了节省资源，并不会在非常准确的时间点回调 Timer。Timer 有个属性叫做 Tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p><h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">Run Loops</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html" target="_blank" rel="noopener">RunLoop</a></li><li><a href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/" target="_blank" rel="noopener">@autoreleasepool-内存的分配与释放</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop&quot;&gt;&lt;/a&gt;Event Loop&lt;/h1&gt;&lt;p&gt;通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Run Loop" scheme="http://chuquan.me/tags/Run-Loop/"/>
    
  </entry>
  
  <entry>
    <title>iOS 图像渲染原理</title>
    <link href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/"/>
    <id>http://chuquan.me/2018/09/25/ios-graphics-render-principle/</id>
    <published>2018-09-24T16:24:50.000Z</published>
    <updated>2018-09-24T16:27:15.787Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a> 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。</p><h1 id="图形渲染技术栈"><a href="#图形渲染技术栈" class="headerlink" title="图形渲染技术栈"></a>图形渲染技术栈</h1><p>下图所示为 iOS App 的图形渲染技术栈，App 使用 <code>Core Graphics</code>、<code>Core Animation</code>、<code>Core Image</code> 等框架来绘制可视化内容，这些软件框架相互之间也有着依赖关系。这些框架都需要通过 OpenGL 来调用 GPU 进行绘制，最终将内容显示到屏幕之上。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-rendering-framework-relationship.png" alt=""></p><h2 id="iOS-渲染框架"><a href="#iOS-渲染框架" class="headerlink" title="iOS 渲染框架"></a>iOS 渲染框架</h2><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a><code>UIKit</code></h3><p><code>UIKit</code> 是 iOS 开发者最常用的框架，可以通过设置 <code>UIKit</code> 组件的布局以及相关属性来绘制界面。</p><p>事实上， <code>UIKit</code> 自身并不具备在屏幕成像的能力，其主要负责对用户操作事件的响应（<code>UIView</code> 继承自 <code>UIResponder</code>），事件响应的传递大体是经过逐层的 <strong>视图树</strong> 遍历实现的。</p><h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a><code>Core Animation</code></h3><p><code>Core Animation</code> 源自于 <code>Layer Kit</code>，动画只是 <code>Core Animation</code> 特性的冰山一角。</p><p><code>Core Animation</code> 是一个复合引擎，其职责是 <strong>尽可能快地组合屏幕上不同的可视内容，这些可视内容可被分解成独立的图层（即 CALayer），这些图层会被存储在一个叫做图层树的体系之中</strong>。从本质上而言，<code>CALayer</code> 是用户所能在屏幕上看见的一切的基础。</p><h3 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a><code>Core Graphics</code></h3><p><code>Core Graphics</code> 基于 Quartz 高级绘图引擎，主要用于运行时绘制图像。开发者可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。</p><p>当开发者需要在 <strong>运行时创建图像</strong> 时，可以使用 <code>Core Graphics</code> 去绘制。与之相对的是 <strong>运行前创建图像</strong>，例如用 Photoshop 提前做好图片素材直接导入应用。相比之下，我们更需要 <code>Core Graphics</code> 去在运行时实时计算、绘制一系列图像帧来实现动画。</p><h3 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a><code>Core Image</code></h3><p><code>Core Image</code> 与 <code>Core Graphics</code> 恰恰相反，<code>Core Graphics</code> 用于在 <strong>运行时创建图像</strong>，而 <code>Core Image</code> 是用来处理 <strong>运行前创建的图像</strong> 的。<code>Core Image</code> 框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。</p><p>大部分情况下，<code>Core Image</code> 会在 GPU 中完成工作，但如果 GPU 忙，会使用 CPU 进行处理。</p><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a><code>OpenGL ES</code></h3><p><code>OpenGL ES</code>（OpenGL for Embedded Systems，简称 GLES），是 OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL 是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。</p><h3 id="Metal"><a href="#Metal" class="headerlink" title="Metal"></a><code>Metal</code></h3><p><code>Metal</code> 类似于 <code>OpenGL ES</code>，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过 <code>Metal</code>，但其实所有开发者都在间接地使用 <code>Metal</code>。<code>Core Animation</code>、<code>Core Image</code>、<code>SceneKit</code>、<code>SpriteKit</code> 等等渲染框架都是构建于 <code>Metal</code> 之上的。</p><p>当在真机上调试 OpenGL 程序时，控制台会打印出启用 <code>Metal</code> 的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL 命令无缝桥接到 <code>Metal</code> 上，由 <code>Metal</code> 担任真正于硬件交互的工作。</p><h1 id="UIView-与-CALayer-的关系"><a href="#UIView-与-CALayer-的关系" class="headerlink" title="UIView 与 CALayer 的关系"></a>UIView 与 CALayer 的关系</h1><p>在前面的 <code>Core Animation</code> 简介中提到 <code>CALayer</code> 事实上是用户所能在屏幕上看见的一切的基础。为什么 <code>UIKit</code> 中的视图能够呈现可视化内容？就是因为 <code>UIKit</code> 中的每一个 UI 视图控件其实内部都有一个关联的 <code>CALayer</code>，即 <code>backing layer</code>。</p><p>由于这种一一对应的关系，视图层级拥有 <strong>视图树</strong> 的树形结构，对应 <code>CALayer</code> 层级也拥有 <strong>图层树</strong> 的树形结构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-viewtree-layertree.png?x-oss-process=image/resize,w_500" alt=""></p><p>其中，视图的职责是 <strong>创建并管理</strong> 图层，以确保当子视图在层级关系中 <strong>添加或被移除</strong> 时，<strong>其关联的图层在图层树中也有相同的操作</strong>，即保证视图树和图层树在结构上的一致性。</p><blockquote><p>那么为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？</p></blockquote><p>其原因在于要做 <strong>职责分离</strong>，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 <code>UIKit</code> 和 <code>UIView</code>，对应 Mac OS X 有 <code>AppKit</code> 和 <code>NSView</code> 的原因。它们在功能上很相似，但是在实现上有着显著的区别。</p><blockquote><p>实际上，这里并不是两个层级关系，而是四个。每一个都扮演着不同的角色。除了 <strong>视图树</strong> 和 <strong>图层树</strong>，还有 <strong>呈现树</strong> 和 <strong>渲染树</strong>。</p></blockquote><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a><code>CALayer</code></h2><p>那么为什么 <code>CALayer</code> 可以呈现可视化内容呢？因为 <code>CALayer</code> 基本等同于一个 <strong>纹理</strong>。纹理是 GPU 进行图像渲染的重要依据。</p><p>在 <a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu">图形渲染原理</a> 中提到纹理本质上就是一张图片，因此 <code>CALayer</code> 也包含一个 <code>contents</code> 属性指向一块缓存区，称为 <code>backing store</code>，可以存放位图（Bitmap）。iOS 中将该缓存区保存的图片称为 <strong>寄宿图</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-contents.png?x-oss-process=image/resize,w_500" alt=""></p><p>图形渲染流水线支持从顶点开始进行绘制（在流水线中，顶点会被处理生成纹理），也支持直接使用纹理（图片）进行渲染。相应地，在实际开发中，绘制界面也有两种方式：一种是 <strong>手动绘制</strong>；另一种是 <strong>使用图片</strong>。</p><p>对此，iOS 中也有两种相应的实现方式：</p><ul><li>使用图片：<strong>contents image</strong></li><li>手动绘制：<strong>custom drawing</strong></li></ul><h3 id="Contents-Image"><a href="#Contents-Image" class="headerlink" title="Contents Image"></a>Contents Image</h3><p> Contents Image 是指通过 <code>CALayer</code> 的 <code>contents</code> 属性来配置图片。然而，<code>contents</code> 属性的类型为 <code>id</code>。在这种情况下，可以给 <code>contents</code> 属性赋予任何值，app 仍可以编译通过。但是在实践中，如果 <code>content</code> 的值不是 <code>CGImage</code> ，得到的图层将是空白的。</p><p> 既然如此，为什么要将 <code>contents</code> 的属性类型定义为 <code>id</code> 而非 <code>CGImage</code>。这是因为在 Mac OS 系统中，该属性对 <code>CGImage</code> 和 <code>NSImage</code> 类型的值都起作用，而在 iOS 系统中，该属性只对 <code>CGImage</code> 起作用。</p><p> 本质上，<code>contents</code> 属性指向的一块缓存区域，称为 <code>backing store</code>，可以存放 bitmap 数据。</p><h3 id="Custom-Drawing"><a href="#Custom-Drawing" class="headerlink" title="Custom Drawing"></a>Custom Drawing</h3><p>Custom Drawing 是指使用 <code>Core Graphics</code> 直接绘制寄宿图。实际开发中，一般通过继承 <code>UIView</code> 并实现 <code>-drawRect:</code> 方法来自定义绘制。</p><p>虽然 <code>-drawRect:</code> 是一个 <code>UIView</code> 方法，但事实上都是底层的 <code>CALayer</code> 完成了重绘工作并保存了产生的图片。下图所示为 <code>-drawRect:</code> 绘制定义寄宿图的基本原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-layer-bitmap-custom-drawing.png?x-oss-process=image/resize,w_500" alt=""></p><ul><li><code>UIView</code> 有一个关联图层，即 <code>CALayer</code>。</li><li><code>CALayer</code> 有一个可选的 <code>delegate</code> 属性，实现了 <code>CALayerDelegate</code> 协议。<code>UIView</code> 作为 <code>CALayer</code> 的代理实现了 <code>CALayerDelegae</code> 协议。</li><li>当需要重绘时，即调用 <code>-drawRect:</code>，<code>CALayer</code> 请求其代理给予一个寄宿图来显示。</li><li><p><code>CALayer</code> 首先会尝试调用 <code>-displayLayer:</code> 方法，此时代理可以直接设置 <code>contents</code> 属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)layer;</span><br></pre></td></tr></table></figure></li><li><p>如果代理没有实现 <code>-displayLayer:</code> 方法，<code>CALayer</code> 则会尝试调用 <code>-drawLayer:inContext:</code> 方法。在调用该方法前，<code>CALayer</code> 会创建一个空的寄宿图（尺寸由 <code>bounds</code> 和 <code>contentScale</code> 决定）和一个 <code>Core Graphics</code> 的绘制上下文，为绘制寄宿图做准备，作为 <code>ctx</code> 参数传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</span><br></pre></td></tr></table></figure></li><li><p>最后，由 <code>Core Graphics</code> 绘制生成的寄宿图会存入 <code>backing store</code>。</p></li></ul><h1 id="Core-Animation-流水线"><a href="#Core-Animation-流水线" class="headerlink" title="Core Animation 流水线"></a>Core Animation 流水线</h1><p>通过前面的介绍，我们知道了 <code>CALayer</code> 的本质，那么它是如何调用 GPU 并显示可视化内容的呢？下面我们就需要介绍一下 Core Animation 流水线的工作原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-steps.png" alt=""></p><p>事实上，app 本身并不负责渲染，渲染则是由一个独立的进程负责，即 <code>Render Server</code> 进程。</p><p>App 通过 IPC 将渲染任务及相关数据提交给 <code>Render Server</code>。<code>Render Server</code> 处理完数据后，再传递至 GPU。最后由 GPU 调用 iOS 的图像设备进行显示。</p><p>Core Animation 流水线的详细过程如下：</p><ul><li>首先，由 app 处理事件（Handle Events），如：用户的点击操作，在此过程中 app 可能需要更新 <strong>视图树</strong>，相应地，<strong>图层树</strong> 也会被更新。</li><li>其次，app 通过 CPU 完成对显示内容的计算，如：视图的创建、布局计算、图片解码、文本绘制等。在完成对显示内容的计算之后，app 对图层进行打包，并在下一次 RunLoop 时将其发送至 <code>Render Server</code>，即完成了一次 <code>Commit Transaction</code> 操作。</li><li><code>Render Server</code> 主要执行 Open GL、Core Graphics 相关程序，并调用 GPU</li><li>GPU 则在物理层上完成了对图像的渲染。</li><li>最终，GPU 通过 Frame Buffer、视频控制器等相关部件，将图像显示在屏幕上。</li></ul><p>对上述步骤进行串联，它们执行所消耗的时间远远超过 16.67 ms，因此为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式进行并行执行，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-core-animation-pipeline-workflow.png" alt=""></p><h2 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h2><p>在 Core Animation 流水线中，app 调用 <code>Render Server</code> 前的最后一步 Commit Transaction 其实可以细分为 4 个步骤：</p><ul><li><code>Layout</code></li><li><code>Display</code></li><li><code>Prepare</code></li><li><code>Commit</code></li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p><code>Layout</code> 阶段主要进行视图构建，包括：<code>LayoutSubviews</code> 方法的重载，<code>addSubview:</code> 方法填充子视图等。</p><h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p><code>Display</code> 阶段主要进行视图绘制，这里仅仅是设置最要成像的图元数据。重载视图的 <code>drawRect:</code> 方法可以自定义 <code>UIView</code> 的显示，其原理是在 <code>drawRect:</code> 方法内部绘制寄宿图，该过程使用 CPU 和内存。</p><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p><code>Prepare</code> 阶段属于附加步骤，一般处理图像的解码和转换等操作。</p><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p><code>Commit</code> 阶段主要将图层进行打包，并将它们发送至 <code>Render Server</code>。该过程会递归执行，因为图层和视图都是以树形结构存在。</p><h1 id="动画渲染原理"><a href="#动画渲染原理" class="headerlink" title="动画渲染原理"></a>动画渲染原理</h1><p>iOS 动画的渲染也是基于上述 Core Animation 流水线完成的。这里我们重点关注 app 与 <code>Render Server</code> 的执行流程。</p><p>日常开发中，如果不是特别复杂的动画，一般使用 <code>UIView</code> Animation 实现，iOS 将其处理过程分为如下三部阶段：</p><ul><li>Step 1：调用 <code>animationWithDuration:animations:</code> 方法</li><li>Step 2：在 Animation Block 中进行 <code>Layout</code>，<code>Display</code>，<code>Prepare</code>，<code>Commit</code> 等步骤。</li><li>Step 3：<code>Render Server</code> 根据 Animation 逐帧进行渲染。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-animation-three-stage-process.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen/" target="_blank" rel="noopener">Getting Pixels onto the Screen</a>，<a href="https://segmentfault.com/a/1190000000390012" target="_blank" rel="noopener">中文版（iOS 开发：绘制像素到屏幕）</a></li><li><a href="https://lision.me/ios-rendering-process/" target="_blank" rel="noopener">深入理解 iOS Rendering Process</a></li><li><a href="https://zsisme.gitbooks.io/ios-/content/" target="_blank" rel="noopener">iOS Core Animation: Advanced Techniques中文译本</a></li><li><a href="https://www.jianshu.com/p/c49833c04362" target="_blank" rel="noopener">关于drawRect</a></li><li>iOS 绘图与动画原理剖析</li><li>WWDC 2014 Session 419: Advanced Graphics and Animations for iOS Apps</li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="noopener">离屏渲染优化详解：实例示范+性能测试</a></li><li><a href="https://github.com/seedante/iOS-Note/wiki/Mastering-Offscreen-Render" target="_blank" rel="noopener">Mastering Offscreen Render</a></li><li><a href="https://download.developer.apple.com/wwdc_2012/wwdc_2012_session_pdfs/session_506__optimizing_2d_graphics_and_animation_performance.pdf" target="_blank" rel="noopener">Optimizing 2D Graphics and Animation Performance</a></li><li><a href="http://docs.huihoo.com/apple/wwdc/2012/session_240__polishing_your_interface_rotations.pdf" target="_blank" rel="noopener">Polishing Your Interface Rotation Animations</a></li><li><a href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/421_core_animation_essentials.pdf" target="_blank" rel="noopener">Core Animation Essentials</a></li><li><a href="https://download.developer.apple.com/wwdc_2011/adc_on_itunes__wwdc11_sessions__pdf/121_understanding_uikit_rendering.pdf" target="_blank" rel="noopener">Understanding UIKit Rendering</a></li><li><a href="http://www.lukeparham.com/blog/2016/5/25/ios-rendering-the-ui" target="_blank" rel="noopener">iOS: Rendering the UI</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a></li><li><a href="https://www.jianshu.com/p/d05d19f70bac" target="_blank" rel="noopener">iOS 动画篇：核心动画</a></li><li><a href="https://developer.samsung.com/game/gpu-framebuffer" target="_blank" rel="noopener">GPU Framebuffer Memory: Understanding Tiling</a></li><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li><li><a href="https://www.jianshu.com/p/456c961164d9" target="_blank" rel="noopener">OpenGL ES 框架详细解析（八） —— OpenGL ES 设计指南</a></li><li><a href="https://www.jianshu.com/p/748f9abafff8" target="_blank" rel="noopener">iOS 开发-视图渲染与性能优化</a></li><li><a href="https://segmentfault.com/a/1190000004164291#articleHeader5" target="_blank" rel="noopener">iOS 视图、动画渲染机制探究</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS 事件处理机制与图像渲染过程</a></li><li><a href="https://www.zybuluo.com/qidiandasheng/note/494700" target="_blank" rel="noopener">iOS界面渲染流程</a></li><li><a href="http://blog.handy.wang/blog/2015/10/03/uiviewyu-calayerxie-zuo-xuan-ran-jie-mian-de-guo-cheng/" target="_blank" rel="noopener">界面渲染的整体流程</a></li><li><a href="https://www.cnblogs.com/feng9exe/p/6723398.html" target="_blank" rel="noopener">iOS图像处理之Core Graphics和OpenGL ES初见</a></li><li>WWDC 2012 Session 506: Optimizing 2D Graphics and Animations Performances</li><li>WWDC 2011 Session 421: Core Animation Essentials</li><li>WWDC 2011 Session 129: Practical Drawing for iOS Developers</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过 &lt;a href=&quot;http://chuquan.me/2018/08/26/graphics-rending-principle-gpu&quot;&gt;图形渲染原理&lt;/a&gt; 一文，大致能够了解图形渲染过程中硬件相关的原理。本文将进一步介绍 iOS 开发过程中图形渲染原理。&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Core Animation Pipeline" scheme="http://chuquan.me/tags/Core-Animation-Pipeline/"/>
    
      <category term="Render Server" scheme="http://chuquan.me/tags/Render-Server/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(7)——图形图像渲染原理</title>
    <link href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/"/>
    <id>http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/</id>
    <published>2018-08-26T10:07:41.000Z</published>
    <updated>2018-09-24T16:38:51.459Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。</p><p>本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识储备。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为程序员，我们或多或少知道可视化应用程序都是由 CPU 和 GPU 协作执行的。那么我们就先来了解一下两者的基本概念：</p><ul><li><strong>CPU（Central Processing Unit）</strong>：现代计算机的三大核心部分之一，作为整个系统的运算和控制单元。CPU 内部的流水线结构使其拥有一定程度的并行计算能力。</li><li><strong>GPU（Graphics Processing Unit）</strong>：一种可进行绘图运算工作的专用微处理器。GPU 能够生成 2D/3D 的图形图像和视频，从而能够支持基于窗口的操作系统、图形用户界面、视频游戏、可视化图像应用和视频播放。GPU 具有非常强的并行计算能力。</li></ul><p>这时候可能会产生一个问题：CPU 难道不能代替 GPU 来进行图形渲染吗？答案当然是肯定的，不过在看了下面这个视频就明白为什么要用 GPU 来进行图形渲染了。</p><p><a href="http://ugcydzd.qq.com/uwMRJfz-r5jAYaQXGdGnC2_ppdhgmrDlPaRvaV7F2Ic/a0310ca26r9.m701.mp4?vkey=40961BB7F3520A37C85D4E4B4130DD91374BFB11499862930CE40B3E09D41D06125BC9EFC73A98DDDE2E5A64EAEB896492064C775F5C82ECD1D72D91D30C53F874EF2C404B480B719C6B8FAA1FA012CEF8743749150271333535195D599FE9F4E8E5FADC8C1A4FBEE74E1C81AA4206F408DE82EE359B3193&amp;br=29&amp;platform=2&amp;fmt=auto&amp;level=0&amp;sdtfrom=v1010&amp;guid=f401ea7eb4e13983f11cfe58f689e34d" target="_blank" rel="noopener">GPU CPU 模拟绘图视频</a></p><p>使用 GPU 渲染图形的根本原因就是：速度。GPU 的并行计算能力使其能够快速将图形结果计算出来并在屏幕的所有像素中进行显示。</p><p>那么像素是如何绘制在屏幕上的？计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为 <strong>渲染</strong>。渲染过程中最常用的技术就是 <strong>光栅化</strong>。</p><p>关于光栅化的概念，以下图为例，假如有一道绿光与存储在内存中的一堆三角形中的某一个在三维空间坐标中存在相交的关系。那么这些处于相交位置的像素都会被绘制到屏幕上。当然这些三角形在三维空间中的前后关系也会以遮挡或部分遮挡的形式在屏幕上呈现出来。一句话总结：光栅化就是将数据转化成可见像素的过程。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-rasterization-basic-concept.png?x-oss-process=image/resize,w_300" alt=""></p><p>GPU 则是执行转换过程的硬件部件。由于这个过程涉及到屏幕上的每一个像素，所以 GPU 被设计成了一个高度并行化的硬件部件。</p><p>下面，我们来简单了解一下 GPU 的历史。</p><h1 id="GPU-历史"><a href="#GPU-历史" class="headerlink" title="GPU 历史"></a>GPU 历史</h1><p>GPU 还未出现前，PC 上的图形操作是由 <strong>视频图形阵列（VGA，Video Graphics Array）</strong> 控制器完成。VGA 控制器由连接到一定容量的DRAM上的存储控制器和显示产生器构成。</p><p>1997 年，VGA 控制器开始具备一些 3D 加速功能，包括用于 <strong>三角形生成</strong>、<strong>光栅化</strong>、<strong>纹理贴图</strong> 和 <strong>阴影</strong>。</p><p>2000 年，一个单片处图形处理器继承了传统高端工作站图形流水线的几乎每一个细节。因此诞生了一个新的术语 GPU 用来表示图形设备已经变成了一个处理器。</p><p>随着时间的推移，GPU 的可编程能力愈发强大，其作为可编程处理器取代了固定功能的专用逻辑，同时保持了基本的 3D 图形流水线组织。</p><p>近年来，GPU 增加了处理器指令和存储器硬件，以支持通用编程语言，并创立了一种编程环境，从而允许使用熟悉的语言（包括 C/C++）对 GPU 进行编程。</p><p>如今，GPU 及其相关驱动实现了图形处理中的 <code>OpenGL</code> 和 <code>DirectX</code> 模型，从而允许开发者能够轻易地操作硬件。<code>OpenGL</code> 严格来说并不是常规意义上的 API，而是一个第三方标准（由 khronos 组织制定并维护），其严格定义了每个函数该如何执行，以及它们的输出值。至于每个函数内部具体是如何实现的，则由 OpenGL 库的开发者自行决定。实际 OpenGL 库的开发者通常是显卡的生产商。<code>DirectX</code> 则是由 Microsoft 提供一套第三方标准。</p><h1 id="GPU-图形渲染流水线"><a href="#GPU-图形渲染流水线" class="headerlink" title="GPU 图形渲染流水线"></a>GPU 图形渲染流水线</h1><p>GPU 图形渲染流水线的主要工作可以被划分为两个部分：</p><ul><li>把 3D 坐标转换为 2D 坐标</li><li>把 2D 坐标转变为实际的有颜色的像素</li></ul><p>GPU 图形渲染流水线的具体实现可分为六个阶段，如下图所示。</p><ul><li><strong>顶点着色器（Vertex Shader）</strong></li><li><strong>形状装配（Shape Assembly）</strong>，又称 <strong>图元装配</strong></li><li><strong>几何着色器（Geometry Shader）</strong></li><li><strong>光栅化（Rasterization）</strong></li><li><strong>片段着色器（Fragment Shader）</strong></li><li><strong>测试与混合（Tests and Blending）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/opengl-graphics-pipeline.png" alt=""></p><p>第一阶段，顶点着色器。该阶段的输入是 <strong>顶点数据（Vertex Data）</strong> 数据，比如以数组的形式传递 3 个 3D 坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器可以对顶点属性进行一些基本处理。</p><p>第二阶段，形状（图元）装配。该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图中则是一个三角形。<strong>图元（Primitive）</strong> 用于表示如何渲染顶点数据，如：点、线、三角形。</p><p>第三阶段，几何着色器。该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p><p>第四阶段，光栅化。该阶段会把图元映射为最终屏幕上相应的像素，生成片段。<strong>片段（Fragment）</strong> 是渲染一个像素所需要的所有数据。</p><p>第五阶段，片段着色器。该阶段首先会对输入的片段进行 <strong>裁切（Clipping）</strong>。裁切会丢弃超出视图以外的所有像素，用来提升执行效率。</p><p>第六阶段，测试与混合。该阶段会检测片段的对应的深度值（<code>z</code> 坐标），判断这个像素位于其它物体的前面还是后面，决定是否应该丢弃。此外，该阶段还会检查 <code>alpha</code> 值（ <code>alpha</code> 值定义了一个物体的透明度），从而对物体进行混合。因此，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>关于混合，GPU 采用如下公式进行计算，并得出最后的颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = S + D * (1 - Sa)</span><br></pre></td></tr></table></figure><p>关于公式的含义，假设有两个像素 S(source) 和 D(destination)，S 在 <code>z</code> 轴方向相对靠前（在上面），D 在 <code>z</code> 轴方向相对靠后（在下面），那么最终的颜色值就是 <strong>S（上面像素） 的颜色 + D（下面像素） 的颜色 * （1 - S（上面像素） 颜色的透明度）</strong>。</p><p>上述流水线以绘制一个三角形为进行介绍，可以为每个顶点添加颜色来增加图形的细节，从而创建图像。但是，如果让图形看上去更加真实，需要足够多的顶点和颜色，相应也会产生更大的开销。为了提高生产效率和执行效率，开发者经常会使用 <strong>纹理（Texture）</strong> 来表现细节。<strong>纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理）</strong>。<strong>纹理一般可以直接作为图形渲染流水线的第五阶段的输入</strong>。</p><p>最后，我们还需要知道上述阶段中的着色器事实上是一些程序，它们运行在 GPU 中成千上万的小处理器核中。这些着色器允许开发者进行配置，从而可以高效地控制图形渲染流水线中的特定部分。由于它们运行在 GPU 中，因此可以降低 CPU 的负荷。着色器可以使用多种语言编写，OpenGL 提供了 GLSL（OpenGL Shading Language） 着色器语言。</p><h1 id="GPU-存储系统"><a href="#GPU-存储系统" class="headerlink" title="GPU 存储系统"></a>GPU 存储系统</h1><p>早期的 GPU，不同的着色器对应有着不同的硬件单元。如今，GPU 流水线则使用一个统一的硬件来运行所有的着色器。此外，nVidia 还提出了 <strong>CUDA（Compute Unified Device Architecture）</strong> 编程模型，可以允许开发者通过编写 C 代码来访问 GPU 中所有的处理器核，从而深度挖掘 GPU 的并行计算能力。</p><p>下图所示为 GPU 内部的层级结构。最底层是计算机的系统内存，其次是 GPU 的内部存储，然后依次是两级 cache：L2 和 L1，每个 L1 cache 连接至一个 <strong>流处理器（SM，stream processor）</strong>。</p><ul><li>SM L1 Cache 的存储容量大约为 16 至 64KB。</li><li>GPU L2 Cache 的存储容量大约为几百 KB。</li><li>GPU 的内存最大为 12GB。</li></ul><p>GPU 上的各级存储系统与对应层级的计算机存储系统相比要小不少。</p><p>此外，GPU 内存并不具有一致性，也就意味着并不支持并发读取和并发写入。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-hierarchy.png?x-oss-process=image/resize,w_400" alt=""></p><h1 id="GPU-流处理器"><a href="#GPU-流处理器" class="headerlink" title="GPU 流处理器"></a>GPU 流处理器</h1><p>下图所示为 GPU 中每个流处理器的内部结构示意图。每个流处理器集成了一个 L1 Cache。顶部是处理器核共享的寄存器堆。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-stream-processor.png?x-oss-process=image/resize,w_400" alt=""></p><h1 id="CPU-GPU-异构系统"><a href="#CPU-GPU-异构系统" class="headerlink" title="CPU-GPU 异构系统"></a>CPU-GPU 异构系统</h1><p>至此，我们大致了解了 GPU 的工作原理和内部结构，那么实际应用中 CPU 和 GPU 又是如何协同工作的呢？</p><p>下图所示为两种常见的 CPU-GPU 异构架构。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cpu-gpu-architecture.png" alt=""></p><p>左图是分离式的结构，CPU 和 GPU 拥有各自的存储系统，两者通过 PCI-e 总线进行连接。这种结构的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。目前使用非常广泛，如PC、智能手机等。</p><p>右图是耦合式的结构，CPU 和 GPU 共享内存和缓存。AMD 的 APU 采用的就是这种结构，目前主要使用在游戏主机中，如 PS4。</p><p>注意，目前很多 SoC 都是集成了CPU 和 GPU，事实上这仅仅是在物理上进行了集成，并不意味着它们使用的就是耦合式结构，大多数采用的还是分离式结构。耦合式结构是在系统上进行了集成。</p><p>在存储管理方面，分离式结构中 CPU 和 GPU 各自拥有独立的内存，两者共享一套虚拟地址空间，必要时会进行内存拷贝。对于耦合式结构，GPU 没有独立的内存，与 GPU 共享系统内存，由 MMU 进行存储管理。</p><p>图形应用程序调用 <code>OpenGL</code> 或 <code>Direct3D</code> API 功能，将 GPU 作为协处理器使用。API 通过面向特殊 GPU 优化的图形设备驱动向 GPU 发送命令、程序、数据。</p><h1 id="GPU-资源管理模型"><a href="#GPU-资源管理模型" class="headerlink" title="GPU 资源管理模型"></a>GPU 资源管理模型</h1><p>下图所示为分离式异构系统中 GPU 的资源管理模型示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/gpu-management-model.png" alt=""></p><ol><li><strong>MMIO（Memory-Mapped I/O）</strong></li></ol><ul><li>CPU 通过 MMIO 访问 GPU 的寄存器状态。</li><li>通过 MMIO 传送数据块传输命令，支持 DMA 的硬件可以实现块数据传输。</li></ul><ol><li><strong>GPU Context</strong></li></ol><ul><li>上下文表示 GPU 的计算状态，在 GPU 中占据部分虚拟地址空间。多个活跃态下的上下文可以在 GPU 中并存。</li></ul><ol><li><strong>CPU Channel</strong></li></ol><ul><li>来自 CPU 操作 GPU 的命令存储在内存中，并提交至 GPU channel 硬件单元。</li><li>每个 GPU 上下文可拥有多个 GPU Channel。每个 GPU 上下文都包含 GPU channel 描述符（GPU 内存中的内存对象）。</li><li>每个 GPU Channel 描述符存储了channel 的配置，如：其所在的页表。</li><li>每个 GPU Channel 都有一个专用的命令缓冲区，该缓冲区分配在 GPU 内存中，通过 MMIO 对 CPU 可见。</li></ul><ol><li><strong>GPU 页表</strong></li></ol><ul><li>GPU 上下文使用 GPU 页表进行分配，该表将虚拟地址空间与其他地址空间隔离开来。</li><li>GPU 页表与 CPU 页表分离，其驻留在 GPU 内存中，物理地址位于 GPU 通道描述符中。<br>通过 GPU channel 提交的所有命令和程序都在对应的 GPU 虚拟地址空间中执行。</li><li>GPU 页表将 GPU 虚拟地址不仅转换为 GPU 设备物理地址，还转换为主机物理地址。这使得 GPU 页面表能够将 GPU 存储器和主存储器统一到统一的 GPU 虚拟地址空间中，从而构成一个完成的虚拟地址空间。</li></ul><ol><li><strong>PFIFO Engine</strong></li></ol><ul><li>PFIFO 是一个提交 GPU 命令的特殊引擎。</li><li>PFIFO 维护多个独立的命令队列，即 channel。</li><li>命令队列是带有 put 和 get 指针的环形缓冲器。</li><li>PFIFO 引擎会拦截多有对通道控制区域的访问以供执行。</li><li>GPU 驱动使用一个通道描述符来存储关联通道的设置。</li></ul><ol><li><strong>BO</strong></li></ol><ul><li>缓冲对象（Buffer Object）。一块内存，可以用来存储纹理，渲染对象，着色器代码等等。</li></ul><h1 id="CPU-GPU-工作流"><a href="#CPU-GPU-工作流" class="headerlink" title="CPU-GPU 工作流"></a>CPU-GPU 工作流</h1><p>下图所示为 CPU-GPU 异构系统的工作流，当 CPU 遇到图像处理的需求时，会调用 GPU 进行处理，主要流程可以分为以下四步：</p><ol><li>将主存的处理数据复制到显存中</li><li>CPU 指令驱动 GPU</li><li>GPU 中的每个运算单元并行处理</li><li>GPU 将显存结果传回主存</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/cuda_processing_flow.png" alt=""></p><h1 id="屏幕图像显示原理"><a href="#屏幕图像显示原理" class="headerlink" title="屏幕图像显示原理"></a>屏幕图像显示原理</h1><p>介绍屏幕图像显示的原理，需要先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 <strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 <strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" alt=""></p><p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 <code>VSync</code> 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_500" alt=""></p><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png" alt=""></p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" alt=""></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cs.utah.edu/~jeffp/teaching/MCMD/S20-GPU.pdf" target="_blank" rel="noopener">GPU Architecture and Models</a></li><li>计算机组成与设计：硬件、软件接口</li><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">欢迎来到OpenGL的世界</a></li><li><a href="https://pdfs.semanticscholar.org/presentation/52d1/963f6a3409aff1f8d73ba1819a187f39f6e1.pdf" target="_blank" rel="noopener">AMD APU Series</a></li><li><a href="http://m.elecfans.com/article/713834.html" target="_blank" rel="noopener">一文详解GPU结构及工作原理</a></li><li><a href="https://www.slideshare.net/mohamedragabslideshare/p12-29046493" target="_blank" rel="noopener">Revisting Co-Processing for Hash Joins on the Coupled CPU-GPU Architecture</a></li><li><a href="https://insujang.github.io/2017-04-27/gpu-architecture-overview/" target="_blank" rel="noopener">GPU Architecture Overview</a></li><li><a href="https://zh.wikipedia.org/wiki/CUDA" target="_blank" rel="noopener">CUDA</a></li><li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流程的技巧</a></li><li><a href="https://segmentfault.com/a/1190000000390012" target="_blank" rel="noopener">iOS 开发：绘制像素到屏幕</a></li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://slideplayer.com/slide/11059244/" target="_blank" rel="noopener">Rendering pipeline: The hardware side</a></li><li><a href="http://meseec.ce.rit.edu/551-projects/spring2015/3-2.pdf" target="_blank" rel="noopener">Graphics Processing Unit(GPU) Memory Hierarchy</a></li><li><a href="http://www.d.umn.edu/~data0003/Talks/gpuarch.pdf" target="_blank" rel="noopener">Graphics Processing Unit Architecture(GPU Arch) With a focus on NVIDIA GeForce 6800 GPU</a></li><li><a href="https://www.jianshu.com/p/d05d19f70bac" target="_blank" rel="noopener">iOS动画篇：核心动画</a></li><li><a href="https://www.anandtech.com/show/7335/the-iphone-5s-review/7" target="_blank" rel="noopener">The iPhone 5s Review</a></li><li><a href="https://www.realworldtech.com/apple-custom-gpu/" target="_blank" rel="noopener">A Look Inside Apple’s Custom GPU for the iPhone</a></li><li><a href="https://appleinsider.com/articles/17/04/17/one-apple-gpu-one-giant-leap-in-graphics-for-iphone-8" target="_blank" rel="noopener">One Apple GPU, one giant leap in graphics for iPhone 8</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在 iOS 开发中做了较多动画相关的编程工作。因此想借此机会深入了解了一下 iOS 动画及渲染相关原理。随着对相关方面的深入了解，发现这里面涉及到从硬件底层到软件框架等一系列相关知识。&lt;/p&gt;
&lt;p&gt;本文将从相对底层的角度对计算图形渲染原理进行简要介绍，以作为后续的知识
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="GPU" scheme="http://chuquan.me/tags/GPU/"/>
    
      <category term="渲染" scheme="http://chuquan.me/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(6)——线程</title>
    <link href="http://chuquan.me/2018/07/10/thread-introduce/"/>
    <id>http://chuquan.me/2018/07/10/thread-introduce/</id>
    <published>2018-07-09T16:15:39.000Z</published>
    <updated>2018-07-09T16:23:56.389Z</updated>
    
    <content type="html"><![CDATA[<p>现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p><strong>线程（Thread）</strong>，也称<strong>轻量级进程（Lightweight Process，LWP）</strong>，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合、堆栈组成。通常，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（如打开文件和信号）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-in-process.png" alt=""></p><p>同一进程中的多个线程可以互不干扰地并发执行，并且共享进程的全局变量和堆的数据。相对于单线程进程，使用多线程的原因有一下几点：</p><ul><li>某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程执行可以有效利用等待时间进行线程切换。如等待网络响应。</li><li>某个操作可能会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会被中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li><li>程序本身要求并发操作，如一个多端下载软件（如Bittorrent）。</li><li>多CPU或多核处理器，本身具备同时执行多个线程的能力，因此单线程程序无法全面发挥计算机的全部计算能力。</li><li>相对于多进程应用，多线程在数据共享方面效率更高。</li></ul><h2 id="线程访问权限"><a href="#线程访问权限" class="headerlink" title="线程访问权限"></a>线程访问权限</h2><p>线程可以访问进程内存中的所有的数据，包括如下几个方面：</p><ul><li><strong>全局变量</strong></li><li><strong>堆数据</strong></li><li><strong>函数里的静态变量</strong></li><li><strong>程序代码，任何线程都有权利读取并执行任何代码</strong></li><li><strong>打开的文件，A线程打开的文件可以由B线程读取</strong></li></ul><p>当然实际上线程也拥有自己的私有存储空间，包括如下几个方面：</p><ul><li><strong>栈</strong>：尽管并非完全无法被其他线程访问，但是一般情况下还是认为栈是私有数据。</li><li><strong>线程局部存储（Thread Local Storage，TLS）</strong>：线程局部存储是某些操作系统为线程单独提供的私有空间，容量有限。</li><li><strong>寄存器</strong>：寄存器是执行流的基本数据，为线程私有。</li></ul><h2 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h2><p>当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上。当线程数据大于处理器数量时，此时至少有一个处理器会运行多个线程。</p><p>在单处理器运行多线程情况下，并发是一种模拟出来的状态。操作系统会让这些多线程轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样每个线程“看起来”在同时执行。这样一个不断在处理器上切换不同的线程的行为称为 <strong>线程调度</strong>。</p><p>在线程调度中，线程通常拥有至少三种状态，分别是：</p><ul><li><strong>运行（Running）</strong>：此时线程正在执行。</li><li><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPI已被占用。</li><li><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（通常是I/O或同步）发生，无法执行。</li></ul><p>处于运行中的线程拥有一段可以执行的时间，这段时间称为 <strong>时间片（Time Slice）</strong>。当时间片用尽时，线程进入就绪状态。如果线程在时间片用尽前就开始等待某事件，则它将进入等待状态。当一个线程离开运行状态时，系统会选择一个处于就绪状态的线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。如下图所示为线程的状态转移图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-state-transition-diagram.png" alt=""></p><p>在线程调度中，主要有两种调度算法：</p><ul><li><strong>优先级调度（Priority Schedule）</strong>：线程拥有各自的 <strong>线程优先级（Thread Priority）</strong>，高优先级的线程会更早执行，低优先级的线程需要等待系统中没有高优先级的可执行线程存在时才能执行。</li><li><strong>轮转调度（Round Robin Schedule）</strong>：让各个线程轮流执行一段时间片。</li></ul><p>实际应用中，系统还会根据不同线程的表现自动调整优先级，提高线程调度效率。在系统中，一般把频繁等待的线程称为 <strong>IO密集型线程（IO Bound Thread）</strong>；把很少等待的线程称为 <strong>CPU密集型线程（CPU Bound Thread）</strong>。通常，IO 密集型线程比 CPU 密集型线程更容易得到优先级的提升。</p><p>在优先级调度中，存在一种 <strong>饿死（Starvation）</strong> 现象，即一个线程的优先级较低，在它执行之前，总是有较高优先级的线程在它之前执行。当一个CPU密集型的线程获得较高优先级时，许多低优先级的进程就可能饿死。当一个IO密集型的线程获得较高优先级时，由于大部分之间处于等待状态，因此相对不容易造成其他线程饿死。为了避免饿死现象，调度系统通常会逐步提升那些等待时间过长且未得到执行的线程的优先级。</p><h2 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h2><p>轮转调度中，线程在用尽时间片后会被强制剥夺继续执行的权利，而进入就绪状态，该过程称为 <strong>抢占（Preemption）</strong>。在早期的一些操作系统中，线程是不可抢占的。在这种调度模型下，线程必须主动进入就绪状态，而不是靠时间片用尽来被强制进入。如果线程始终拒绝进入就绪状态，并且不进行任何等待操作，其他线程将永远无法执行。</p><p>在不可抢占线程中，线程会在两种情况下主动放弃执行：</p><ul><li>当线程试图等待某些事件时（如I/O事件）。</li><li>线程主动放弃时间片。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多线程程序处于一个多变的环境中，可以访问的全局变量和堆数据随时都可能被其他的线程改变。因此，多线程程序在并发时数据的一致性非常重要。</p><h2 id="竞争与原子操作"><a href="#竞争与原子操作" class="headerlink" title="竞争与原子操作"></a>竞争与原子操作</h2><p>多线程同时访问一个共享数据，可能会造成严重的后果。以一个著名的例子为例，假设有两个线程分别执行如下所示的 C 代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 1</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2</span></span><br><span class="line">--i;</span><br></pre></td></tr></table></figure></p><p>在很多体系结构中，++i 的实现方式一般如下：</p><ol><li><strong>读取 i 到某个寄存器 X</strong></li><li><strong>X++</strong></li><li><strong>将 X 的内容存储至 i</strong></li></ol><p>由于线程 1 和线程 2并发执行，因此两个线程的执行可能如下（注意，寄存器 X 的 内容在不同的线程中是不一样的，这里用 X[1] 和 X[2] 分别表示线程 1 和线程 2 中的 X），如下所示：</p><table><thead><tr><th style="text-align:left">执行序号</th><th style="text-align:left">执行指令</th><th style="text-align:left">语句执行后的变量值</th><th style="text-align:left">线程</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">i = 1</td><td style="text-align:left">i = 1, X[1] = 未知</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">X[1] = i</td><td style="text-align:left">i = 1, X[1] = 1</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">X[2] = i</td><td style="text-align:left">i = 1, X[2] = 1</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">X[1]++</td><td style="text-align:left">i = 1, X[1] = 2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">X[2]–</td><td style="text-align:left">i = 1, X[2] = 0</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">i = X[1]</td><td style="text-align:left">i = 2, X[1] = 2</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">i = X[2]</td><td style="text-align:left">i = 0, X[2] = 0</td><td style="text-align:left">2</td></tr></tbody></table><p>从程序逻辑上看，两个线程都执行完毕之后，i 的值应该是 1，但从表中的执行序列可以看到，i 的实际值是 0。实际上，这两个线程如果同时执行，i 的结果有可能是 0 或 1 或 2。</p><p>很明显，由于 i++ 操作在多线程环境下会出现错误是因为该操作被编译成汇编代码后不止一条指令，因此在执行时可能会被调度系统打断，去执行别的代码。通常，我们把单指令的操作称为 <strong>原子操作</strong>，因为单条指令的执行是不会被打断的。很多体系结构都提供了一些常用的原子指令，如 i386 就有一条 inc 指令可以直接增加一个内存单元值，可以避免上例的错误情况。</p><p>尽管原子操作指令非常方便，但是它们仅适用于比较简单特定的场合。在复杂的场合下，比如要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。这里需要更加通用的手段：锁。</p><h2 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h2><p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，需要将各个线程对同一个数据的访问进行 <strong>同步（Synchronization）</strong>。即在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问。</p><p>同步最常见的方法是使用 <strong>锁（Lock）</strong>。锁是一种非强制机制，每个线程在访问数据或资源之前首先试图 <strong>获取（Acquire）</strong> 锁，并在访问结束之后 <strong>释放（Release）</strong> 锁。在锁已经被占用时试图获取锁时，线程会等待，直到锁重新可用。</p><h3 id="二元信号量"><a href="#二元信号量" class="headerlink" title="二元信号量"></a>二元信号量</h3><p><strong>二元信号量（Binary Semaphore）</strong> 是最简单的一种锁，只有两种状态：<strong>占用</strong>、<strong>非占用</strong>。二元信号量适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量置为占用状态，此后其他所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</p><h3 id="多元信号量"><a href="#多元信号量" class="headerlink" title="多元信号量"></a>多元信号量</h3><p>多元信号量是二元信号量的扩展，简称 <strong>信号量（Semaphore）</strong>。一个初始值为 N 的信号量允许 N 个线程并发访问。</p><p>当线程访问资源时，首先获取信号量，进行如下操作：</p><ul><li>将信号量减 1。</li><li>如果信号量的值小于 0，则进入等待状态，否则继续执行。</li></ul><p>当线程结束访问资源后，线程释放信号量，进行如下操作：</p><ul><li>将信号量的值加 1。</li><li>如果信号量的值小于 1，唤醒一个等待中的线程。</li></ul><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p><strong>互斥量（Mutex）</strong> 和二元信号量很相似，资源仅同时允许一个线程访问，但和信号量不同的是：信号量在整个系统中可以被任意线程获取并释放，即同一个信号量可以被系统中的一个线程获取之后由另一个线程释放；互斥量则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p><strong>临界区（Read-Write Lock）</strong> 是比互斥量更加严格的同步手段。在术语中，把临界区的锁的获取称为进入临界区，而把锁的释放称为离开临界区。临界区和互斥量与信号量的区别在于：互斥量和信号量在系统的任何进程里都是可见的，即一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的；临界区的作用范围仅限于本进程，其他的进程无法获取该锁。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>读写锁（Read-Write Lock）</strong> 致力于一种更加特定的场合的同步。对于一段数据，多个线程同时读取总是没有问题的，但假设操作都不是原子型，只要有任何一个线程试图对该数据进行修改，就必须使用同步手段来避免出错。对此，可以使用上述的信号量、互斥量或临界区中的任何一种来进行同步。虽然这样可以保证程序正确执行，但是对于读取频繁的程序，会显得非常低效。读写锁就是用来提高这种情况下的执行效率的。</p><p>读写锁有两种获取方式：<strong>共享的（Shared）</strong>、<strong>独占的（Exclusive）</strong>。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置于对应的状态。如果锁处于共享状态，其他线程以共享的方式获取锁仍然会成功，此时这个锁分配给了多个线程。如果其他线程试图以独占的方式获取已经处于共享状态的锁，那么它必须等待锁被所有线程释放。处于独占状态的锁将阻止任何其他线程获取该锁。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>条件变量（Condition Variable）</strong> 作为一种同步手段，作用类似于一个栅栏。对于条件变量，线程可以有两种操作：首先，线程可以等待条件变量，一个条件变量可以被多个线程等待。其次，线程可以唤醒条件变量，此时所有等待此条件变量的线程都会被唤醒并继续执行。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>线程的并发执行是由多处理器或操作系统调度来实现的。但实际情况要更为复杂：大多数操作系统，包括 Windows 和 Linux，都在内核里提供线程的支持，内核态线程由多处理器或调度来实现并发。然而用户实际使用的线程并不是内核态线程，而是用户态线程。用户态线程并不一定在操作系统内核里对应同等数量的内核态线程。它们之间的对应关系有三种类型。</p><h2 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h2><p>对于直接支持线程的系统，一对一模型始终是最简单的模型。对于一对一模型，一个用户态线程唯一对应一个内核态线程，但一个内核态线程并不一定存在相应的用户态线程。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-one-to-one.png" alt=""></p><p>一对一模型中，用户态线程具有和内核态线程一致的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程的执行不会受到影响。此外，一对一模型也可以让多线程程序在多处理器的系统上有更高的效率。</p><p>一对一线程模型也有两个缺点：</p><ul><li>由于许多操作系统限制了内核态线程的数量，因此一对一线程会让用户态线程的数量受到限制。</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ul><h2 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h2><p>多对一模型将多个用户态线程映射到一个内核态线程上，线程之间的切换由用户态的代码完成。因此相对于一对一模型，多对一模型的切换要快速许多。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-one.png" alt=""></p><p>多对一模型的问题在于：如果其中一个用户态线程阻塞，将导致所有线程都无法执行。另外，在多处理器系统中，处理器的增多对于多对一模型的线程性能也不会有明显的提升。多对一模型的优点在于高效的上下文切换和几乎无限制的线程数量。</p><h2 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h2><p>多对多模型结合了多对一模型和一对一模型的特点，将多个用户态线程映射到少数但不止一个内核态线程。模型示意图如下所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/thread-many-to-many.png" alt=""></p><p>多对多模型中，一个用户态线程阻塞并不会导致所有的用户态线程阻塞，因为此时还有其他的线程可以被调度来执行。此外，多对多模型对用户线程的数量也没什么限制，在多处理器系统中，多对多模型的线程也能得到一定的性能提升，但是提升幅度步入一对一模型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现代软件系统中，除了进程，线程也是一个非常重要的概念。随着CPU频率增长开始出现停滞，处理器逐渐开始想多核方向发展。多线程，作为实现软件并发执行的重要方法之一，也开始被重视。&lt;/p&gt;
&lt;h1 id=&quot;线程基础&quot;&gt;&lt;a href=&quot;#线程基础&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="线程" scheme="http://chuquan.me/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="信号量" scheme="http://chuquan.me/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="临界区" scheme="http://chuquan.me/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(5)——可执行文件的装载与运行</title>
    <link href="http://chuquan.me/2018/06/17/executable-file-load-and-execution/"/>
    <id>http://chuquan.me/2018/06/17/executable-file-load-and-execution/</id>
    <published>2018-06-17T15:33:16.000Z</published>
    <updated>2018-06-24T16:13:39.599Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello.out</span><br></pre></td></tr></table></figure></p><p>那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤：</p><ul><li>创建新进程</li><li>检查可执行文件类型</li><li>搜索匹配装载处理过程</li><li>装载执行可执行文件</li></ul><h1 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h1><p>首先在用户层面，bash 进程会调用 <code>fork()</code> 系统调用创建一个新的进程。其次，新的进程通过调用 <code>execve()</code> 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。</p><p><code>execve()</code> 系统调用被定义在 <code>unistd.h</code>，其原型如下所示。其中的三个参数分别对应被执行程序的 <strong>程序文件名</strong>、<strong>执行参数</strong>、<strong>环境变量</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure></p><h1 id="检查可执行文件类型"><a href="#检查可执行文件类型" class="headerlink" title="检查可执行文件类型"></a>检查可执行文件类型</h1><p>当进入 <code>execve()</code> 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中，<code>execve()</code> 系统调用相应的入口是 <code>sys_execve()</code>。<code>sys_execve()</code> 进行一些参数的检查复制之后，调用 <code>do_execve()</code>。<code>do_execve()</code> 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。</p><p>为什么要先读取文件的前 128 个字节？这是因为Linux支持的可执行文件不止 ELF 一种，还包括 <strong>a.out</strong>、<strong>Java 程序</strong>、<strong>以 <code>#!</code> 开头的脚本程序</strong>。<code>do_execve()</code>通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前4个字节，被称为 <strong>魔数（Magic Number）</strong>。比如：ELF的可执行文件格式的头 4 个字节为 <code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头 4 个字节为 <code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果是解释型语言的脚本，则第一行通常是 <code>#!/bin/sh</code> 或 <code>#!/user/bin/python</code>，其中 <code>#</code> 和 <code>!</code> 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</p><h1 id="搜索匹配装载处理过程"><a href="#搜索匹配装载处理过程" class="headerlink" title="搜索匹配装载处理过程"></a>搜索匹配装载处理过程</h1><p>当 <code>do_execve()</code> 读取了128个字节的文件头部之后，调用 <code>search_binary_handle()</code> 去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux 中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，<code>search_binary_handler()</code> 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示.</p><ul><li>ELF 可执行文件：<code>load_elf_binary()</code></li><li>a.out 可执行文件：<code>load_aout_binary()</code></li><li>可执行脚本程序：<code>load_script()</code></li></ul><h1 id="装载执行可执行文件"><a href="#装载执行可执行文件" class="headerlink" title="装载执行可执行文件"></a>装载执行可执行文件</h1><p>以 ELF 的装载处理过程 <code>load_elf_binary()</code> 为例，其所包含的步骤如下图所示：<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/executable-file-load-process.png" alt=""></p><ol><li>操作系统读取可执行文件 ELF 的 <code>Header</code>，检查文件的有效性。</li><li>操作系统读取可执行文件 ELF的 <code>Program Header Table</code> 中读取每个 <code>Segment</code> 的虚拟地址、文件地址、属性等。</li><li>操作系统根据 <code>Program Header Table</code> 将可执行文件 ELF 映射至内存。</li><li>如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 <code>.interp</code> 节，找到 <strong>动态链接器（Dynamic Linker）</strong> 的位置，并启动动态链接器。在 Linux 下，动态链接器 <code>ld.so</code> 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。</li><li>动态链接器获得控制权后，开始执行一系列初始化操作。</li><li>动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。</li><li>控制权被转交到可执行文件的入口地址，程序开始正式执行。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="装载" scheme="http://chuquan.me/tags/%E8%A3%85%E8%BD%BD/"/>
    
      <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(4)——链接、静态链接、动态链接</title>
    <link href="http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/"/>
    <id>http://chuquan.me/2018/06/03/linking-static-linking-dynamic-linking/</id>
    <published>2018-06-03T15:44:39.000Z</published>
    <updated>2018-06-18T15:51:57.891Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="http://chuquan.me/2018/05/21/elf-introduce/">前面</a>对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件呢？一切都要从链接说起。</p><h1 id="链接概述"><a href="#链接概述" class="headerlink" title="链接概述"></a>链接概述</h1><p>模块化设计是软件开发中最常用的设计思想。<strong>链接（Linking）</strong> 本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。比如：</p><blockquote><p>我们在模块<code>main.c</code>中使用另一个模块<code>func.c</code>中的<code>foo()</code>函数。我们在<code>main.c</code>模块中每一处调用<code>foo</code>时都必须确切知道<code>foo</code>函数的地址。但由于每个模块都是单独编译的。编译器在编译<code>main.c</code>的时候并不知道<code>foo</code>函数的地址。所以编译器会暂时把这些调用<code>foo</code>的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。这就是静态链接最基本的过程和作用。</p></blockquote><p>如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如<code>.c</code>）文件经过编译器编译成<strong>目标文件</strong>（Object File，一般扩展名为<code>.o</code>或<code>.obj</code>）。目标文件和 <strong>库（Library）</strong> 一起链接形成最终的可执行文件。</p><p>其中，最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。<strong>库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/linking-process.png" alt=""></p><p>链接过程主要包含了三个步骤：</p><ol><li><strong>地址与空间分配（Address and Storage Allocation）</strong></li><li><strong>符号解析（Symbol Resolution）</strong></li><li><strong>重定位（Relocation）</strong></li></ol><p>下面，我们以两个源代码文件<code>a.c</code>和<code>b.c</code>为例展开分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.c</span><br><span class="line">extern int shared;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 100;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// b.c</span><br><span class="line">int shared = 1;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>b.c</code>中定义了两个全局符号：变量<code>shared</code>、函数<code>swap</code>；<code>a.c</code>中定义了一个全局符号：<code>main</code>。<code>a.c</code>引用了<code>b.c</code>中的<code>swap</code>和<code>shared</code>。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件<code>ab</code>。</p><p>使用<code>gcc -c</code>命令我们可以分别编译得到<code>a.o</code>和<code>b.o</code>两个目标文件。</p><h2 id="地址与空间分配"><a href="#地址与空间分配" class="headerlink" title="地址与空间分配"></a>地址与空间分配</h2><p>在介绍ELF文件结构关于段与节的区别时，我们就提到过可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。</p><h3 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h3><p>一个最简单的方案就是将输入的文件按序叠加，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-simple-merge.png" alt=""></p><p>虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。</p><h3 id="合并相似节"><a href="#合并相似节" class="headerlink" title="合并相似节"></a>合并相似节</h3><p>一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 <strong><code>.text</code>节</strong>合并到输出文件的 <strong><code>text</code>段</strong>（注意，此时出现了段和节两个概念），如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-similar-merge.png" alt=""></p><p>其中<code>.bss</code>节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的<strong>空间和地址</strong>有两层含义:</p><ol><li>在输出的可执行文件中的空间</li><li>在装载后的虚拟地址中的空间</li></ol><p>对于有实际数据的节，如<code>.text</code>和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于<code>.bss</code>来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。<strong>我们在这里谈到的空间分配只关注于虚拟地址空间的分配</strong>，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。</p><p>现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 <strong>两步链接（Two-pass Linking）</strong> 的方法。即整个链接过程分为两步：</p><ul><li><strong>第一步 地址与空间分配</strong><br>  扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。</li><li><strong>第二步 符号解析与重定位</strong><br>  使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/two-step-linking.png" alt=""></p><p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了<a href="http://chuquan.me/2018/05/21/elf-introduce/">ELF文件结构</a>一文中没有介绍的 <strong>程序头表（Program Header Table）</strong> 结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ <code>text</code>段）、数据段（ <code>data</code>段 ）。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png" alt=""></p><p>我们使用ld或gcc将<code>a.o</code>和<code>b.o</code>链接起来，然后使用objdump工具来查看链接前后的地址分配情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h a.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  0000008f  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h b.o</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004b  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h ab</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  ...</span><br><span class="line">  13 .text         00000202  0000000000400450  0000000000400450  00000450  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  ...</span><br><span class="line">  24 .data         00000014  0000000000601028  0000000000601028  00001028  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  25 .bss          00000004  000000000060103c  000000000060103c  0000103c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>可以发现，链接前目标文件中所有节的 <strong>VMA（Virtual Memory Address）</strong> 都是0，因为虚拟空间还没有分配。链接后，可执行文件<code>ab</code>中各个节被分配到了相应的虚拟地址，如<code>.text</code>节被分配到了地址<code>0x0000000000400450</code>。</p><p>那么，为什么链接器要将可执行文件<code>ab</code>的<code>.text</code>节分配到<code>0x0000000000400450</code>？而不是从虚拟空间的0地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在Linux x86-64系统中，代码段总是从<code>0x0000000000400000</code>开始的，另外<code>.text</code>节之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code>等占用了一定的空间，所以就被分配到了<code>0x0000000000400450</code>。</p><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>在<strong>两步链接</strong>中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。</p><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。</p><p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。</p><p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。</p><h3 id="多重定义的全局符号解析"><a href="#多重定义的全局符号解析" class="headerlink" title="多重定义的全局符号解析"></a>多重定义的全局符号解析</h3><p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p><p>Linux编译系统采用如下的方法解决多重定义的全局符号解析：</p><p><strong>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</strong>  </p><p>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：</p><ul><li><strong>规则1：不允许有多个同名的强符号。</strong></li><li><strong>规则2：如果有一个强符号和多个弱符号同名，则选择强符号。</strong></li><li><strong>规则3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。</strong></li></ul><p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p><ul><li><strong>情况1：两个或两个以上的强符号类型不一致。</strong></li><li><strong>情况2：有一个强符号，其他都是弱符号，出现类型不一致。</strong></li><li><strong>情况3：两个或两个以上弱符号类型不一致。</strong></li></ul><p>其中，情况1由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 <strong>COMMON块（Common Block<br>）</strong> 的机制来处理。其过程如下：</p><p><strong>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况3，最终链接时选择最大的类型。对于情况2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。</strong></p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p><p>那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 <strong>重定位表（Relocation Table）</strong> 专门用来保存这些与重定位相关的信息。</p><p>对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果<code>.text</code>节需要被重定位，则会有一个相对应叫<code>.rel.text</code>的节保存了代码节的重定位表；如果<code>.data</code>节需要被重定位，则会有一个相对应的<code>.rel.tdata</code>的节保存了数据节的重定位表。</p><p>我们可以使用objdump工具来查看目标文件中的重定位表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -r a.o</span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000023 R_X86_64_32       share</span><br><span class="line">0000000000000030 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line">0000000000000049 R_X86_64_PC32     __stack_chk_fail-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p><p>我们可以看到每个要被重定位的地方是一个 <strong>重定位入口（Relocation Entry）</strong>。利用数据结构成员包含的信息，即可完成重定位。</p><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>事实上，静态链接的过程就是上文所描述的过程。在Linux中，静态链接器（static linker）<code>ld</code>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。</p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等。在静态链接中，C语言静态库是很典型的浪费空间的例子。关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序。</p><p>解决空间浪费和更新困难最简单的方法便是将程序的模块相互分割开来，形成独立文件。简而言之，就是不对那些组成程序的目标文件进行链接，而是等到程序要运行时才进行链接。</p><h2 id="动态链接的基本实现"><a href="#动态链接的基本实现" class="headerlink" title="动态链接的基本实现"></a>动态链接的基本实现</h2><p>动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。</p><p>目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 <strong>动态共享对象（DSO，Dynamic Shared Objects）</strong>，一般以<code>.so</code>为后缀；在Windows中，动态链接文件被称为 <strong>动态链接库（Dynamic Linking Library）</strong>，一般以<code>.dll</code>为后缀。</p><p>在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 <code>/lib</code>目录下，文件名为 <code>libc.so</code>。整个系统只保留一份C语言动态链接文件<code>libc.so</code>，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。</p><h2 id="动态链接程序运行时地址空间分布"><a href="#动态链接程序运行时地址空间分布" class="headerlink" title="动态链接程序运行时地址空间分布"></a>动态链接程序运行时地址空间分布</h2><p>对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p><p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p><ul><li><strong>静态共享库（Static Shared Library）</strong>（地址固定）</li><li><strong>动态共享库（Dynamic Shared Libary）</strong>（地址不固定）</li></ul><h3 id="静态共享库"><a href="#静态共享库" class="headerlink" title="静态共享库"></a>静态共享库</h3><p>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在<strong>某个特定的地址</strong>划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为<strong>静态</strong>。</p><p>但是静态共享库的目标地址会导致地址冲突、升级等问题。</p><h3 id="动态共享库"><a href="#动态共享库" class="headerlink" title="动态共享库"></a>动态共享库</h3><p>采用动态共享库的方式，也称为<strong>装载时重定位（Load Time Relocation）</strong>。其基本思路是：<strong>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。</strong></p><p>但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。</p><p>然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为<strong>地址无关代码</strong>的技术被提出以克服这个问题。</p><h4 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h4><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p><strong>地址无关代码（PIC，Position-independent Code）</strong> 技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p><p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型：</p><ul><li><strong>类型1：模块内部的函数调用。</strong></li><li><strong>类型2：模块内部的数据访问，如模块中定义的全局变量、静态变量。</strong></li><li><strong>类型3：模块外部的函数调用。</strong></li><li><strong>类型4：模块外部的数据访问，如其他模块中定义的全局变量。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">extern int b;</span><br><span class="line">extern void ext();</span><br><span class="line"></span><br><span class="line">void bar() &#123;</span><br><span class="line">    a = 1;      // 类型2：模块内部数据访问</span><br><span class="line">    b = 2;      // 类型4：模块外部数据访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">    bar();      // 类型1：模块内部函数调用</span><br><span class="line">    ext();      // 类型4：模块外部函数调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="类型1-模块内部函数调用"><a href="#类型1-模块内部函数调用" class="headerlink" title="类型1 模块内部函数调用"></a>类型1 模块内部函数调用</h5><p>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。</p><h5 id="类型2-模块内部数据访问"><a href="#类型2-模块内部数据访问" class="headerlink" title="类型2 模块内部数据访问"></a>类型2 模块内部数据访问</h5><p>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。</p><h5 id="类型3-模块间数据访问"><a href="#类型3-模块间数据访问" class="headerlink" title="类型3 模块间数据访问"></a>类型3 模块间数据访问</h5><p>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF的实现方法是：在数据段中建立一个<strong>指向这些变量的指针数组</strong>，也称为<strong>全局偏移表（Global Offset Table，GOT）</strong>，当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。过程示意图如下所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/inter-module-data-access.png" alt=""></p><p>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以<strong>在模块装载时被修改</strong>，并且每个进程都可以有独立的副本，相互不受影响。</p><h5 id="类型4-模块间函数调用"><a href="#类型4-模块间函数调用" class="headerlink" title="类型4 模块间函数调用"></a>类型4 模块间函数调用</h5><p>对于模块间函数调用，同样可以采用类型3的方法来解决。与上面的类型有所不同的是，GOT中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上文的描述，我们基本理清了链接的过程以及静态链接和动态链接的区别。事实上，链接的具体实现细节是非常复杂，本文只是对其进行了概述，更多细节以及优化实现还是需要我们自己进一步去探索。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Executable and Linkable Format (ELF)</li><li>《Linux 二进制分析》</li><li>《程序员的自我修养——链接、装载与库》</li><li>《深入理解计算机系统》</li><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过&lt;a href=&quot;http://chuquan.me/2018/05/21/elf-introduce/&quot;&gt;前面&lt;/a&gt;对ELF文件结构的详细介绍，我们对ELF目标文件从整体轮廓到局部细节都有了一定的了解。那么接下来，当我们有多个目标文件时，如何将它们链接起来形成一个可
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="静态链接" scheme="http://chuquan.me/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="动态链接" scheme="http://chuquan.me/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    
      <category term="链接" scheme="http://chuquan.me/tags/%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(3)——ELF文件结构</title>
    <link href="http://chuquan.me/2018/05/21/elf-introduce/"/>
    <id>http://chuquan.me/2018/05/21/elf-introduce/</id>
    <published>2018-05-21T14:45:18.000Z</published>
    <updated>2018-06-18T05:37:29.592Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://chuquan.me/2018/05/12/compiler-principle/#more">前文</a>结尾说到编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，而目标文件经过编译器链接之后得到的就是<strong>可执行文件</strong>。那么目标文件到底是什么？它和可执行文件又有什么区别？链接到底又做了什么呢？接下来，我们将探索一下目标文件的本质。</p><h1 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h1><p>目前，PC平台流行的 <strong>可执行文件格式（Executable）</strong> 主要包含如下两种，它们都是 <strong>COFF（Common File Format）</strong> 格式的变种。</p><ul><li>Windows下的 <strong>PE（Portable Executable）</strong> </li><li>Linux下的 <strong>ELF（Executable Linkable Format）</strong> </li></ul><p><strong>目标文件就是源代码经过编译后但未进行连接的那些中间文件（Windows的<code>.obj</code>和Linux的<code>.o</code>），它与可执行文件的格式非常相似，所以一般跟可执行文件格式一起采用同一种格式存储</strong>。在Windows下采用<strong>PE-COFF</strong>文件格式；Linux下采用<strong>ELF</strong>文件格式。</p><p>事实上，除了<strong>可执行文件</strong>外，<strong>动态链接库（DDL，Dynamic Linking Library）</strong>、<strong>静态链接库（Static Linking Library）</strong> 均采用可执行文件格式存储。它们在Window下均按照PE-COFF格式存储；Linux下均按照ELF格式存储。只是文件名后缀不同而已。</p><ul><li>动态链接库：Windows的<code>.dll</code>、Linux的<code>.so</code></li><li>静态链接库：Windows的<code>.lib</code>、Linux的<code>.a</code></li></ul><p>下面，我们将以ELF文件为例进行介绍。</p><h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-file-format.png" alt=""></p><p><strong>注意：段（<code>Segment</code>）与节（<code>Section</code>）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中。相比而言，节的粒度更小。</strong></p><p>如图所示，为ELF文件的基本结构，其主要由四部分组成：</p><ul><li>ELF Header</li><li>ELF Program Header Table (或称Program Headers、程序头)</li><li>ELF Section Header Table (或称Section Headers、节头表)</li><li>ELF Sections</li></ul><p>从图中，我们就能看出它们各自的数据结构以及相互之间的索引关系。下面我们依次进行介绍。</p><hr><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><p>我们可以使用readelf工具来查看ELF Header。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h hello.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          672 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure></p><p>ELF文件结构示意图中定义的<code>Elf_Ehdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">e_ident</td><td style="text-align:left">Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Class: ELF32</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Data:  2’s complement, little end</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Version: 1(current)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">OS/ABI: UNIX - System V</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ABI Version: 0</td></tr><tr><td style="text-align:left">e_type</td><td style="text-align:left">Type: REL (Relocatable file)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF文件类型</td></tr><tr><td style="text-align:left">e_machine</td><td style="text-align:left">Machine: Advanced Micro Devices X86-64</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF文件的CPI平台属性</td></tr><tr><td style="text-align:left">e_version</td><td style="text-align:left">Version: 0x1</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF版本号。一般为常数1</td></tr><tr><td style="text-align:left">e_entry</td><td style="text-align:left">Entry point address: 0x0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位指令一般没有入口地址，则该值为0</strong></td></tr><tr><td style="text-align:left">e_phoff</td><td style="text-align:left">Start of program headers: 0(bytes into file)</td></tr><tr><td style="text-align:left">e_shoff</td><td style="text-align:left">Start of section headers: 672 (bytes into file)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header Table 在文件中的偏移</td></tr><tr><td style="text-align:left">e_word</td><td style="text-align:left">Flags: 0x0</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF标志位，用来标识一些ELF文件平台相关的属性。</td></tr><tr><td style="text-align:left">e_ehsize</td><td style="text-align:left">Size of this header: 64 (bytes)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">ELF Header本身的大小</td></tr><tr><td style="text-align:left">e_phentsize</td><td style="text-align:left">Size of program headers: 0 (bytes)</td></tr><tr><td style="text-align:left">e_phnum</td><td style="text-align:left">Number of program headers: 0</td></tr><tr><td style="text-align:left">e_shentsize</td><td style="text-align:left">Size of section headers: 64 (bytes)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">单个Section Header大小</td></tr><tr><td style="text-align:left">e_shnum</td><td style="text-align:left">Number of section headers: 13</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header的数量</td></tr><tr><td style="text-align:left">e_shstrndx</td><td style="text-align:left">Section header string table index: 10</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Section Header字符串表在Section Header Table中的索引</td></tr></tbody></table><h3 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h3><p>每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，通常被称为<strong>魔数（Magic Number）</strong>。通过对魔数的判断可以确定文件的格式和类型。如：ELF的可执行文件格式的头4个字节为<code>0x7F</code>、<code>e</code>、<code>l</code>、<code>f</code>；Java的可执行文件格式的头4个字节为<code>c</code>、<code>a</code>、<code>f</code>、<code>e</code>；如果被执行的是Shell脚本或perl、python等解释型语言的脚本，那么它的第一行往往是<code>#!/bin/sh</code>或<code>#!/usr/bin/perl</code>或<code>#!/usr/bin/python</code>，此时前两个字节<code>#</code>和<code>!</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序路径。</p><h3 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h3><p>ELF文件主要有三种类型，可以通过ELF Header中的<code>e_type</code>成员进行区分。</p><ul><li><strong>可重定位文件（Relocatable File）</strong>：<code>ETL_REL</code>。一般为<code>.o</code>文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。</li><li><strong>可执行文件（Executable File）</strong>：<code>ET_EXEC</code>。可以直接执行的程序。</li><li><strong>共享目标文件（Shared Object File）</strong>：<code>ET_DYN</code>。一般为<code>.so</code>文件。有两种情况可以使用。<ul><li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li><li>动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像。</li></ul></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/different-elf-type.png" alt=""></p><hr><h2 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h2><p>ELF 节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。<strong>编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</strong></p><p>我们可以使用readelf工具来查看节头表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S hello.o</span><br><span class="line"></span><br><span class="line">There are 13 section headers, starting at offset 0x2a0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000001f0</span><br><span class="line">       0000000000000030  0000000000000018   I      11     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  00000055</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  00000062</span><br><span class="line">       0000000000000035  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000097</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  00000098</span><br><span class="line">       0000000000000038  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000220</span><br><span class="line">       0000000000000018  0000000000000018   I      11     8     8</span><br><span class="line">  [10] .shstrtab         STRTAB           0000000000000000  00000238</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">  [11] .symtab           SYMTAB           0000000000000000  000000d0</span><br><span class="line">       0000000000000108  0000000000000018          12     9     8</span><br><span class="line">  [12] .strtab           STRTAB           0000000000000000  000001d8</span><br><span class="line">       0000000000000013  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure></p><p>ELF文件结构示意图中定义的<code>Elf_Shdr</code>的各个成员的含义与readelf具有对应关系。如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">sh_name</td><td style="text-align:left">节名</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">节名是一个字符串，保存在一个名为<code>.shstrtab</code>的字符串表（可通过Section Header索引到）。sh_name的值实际上是其节名字符串在<code>.shstrtab</code>中的偏移值</td></tr><tr><td style="text-align:left">sh_type</td><td style="text-align:left">节类型</td></tr><tr><td style="text-align:left">sh_flags</td><td style="text-align:left">节标志位</td></tr><tr><td style="text-align:left">sh_addr</td><td style="text-align:left">节地址：节的虚拟地址</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">如果该节可以被加载，则sh_addr为该节被加载后在进程地址空间中的虚拟地址；否则sh_addr为0</td></tr><tr><td style="text-align:left">sh_offset</td><td style="text-align:left">节偏移</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>如果该节存在于文件中，则表示该节在文件中的偏移；否则无意义，如sh_offset对于BSS 节来说是没有意义的</strong></td></tr><tr><td style="text-align:left">sh_size</td><td style="text-align:left">节大小</td></tr><tr><td style="text-align:left">sh_link、sh_info</td><td style="text-align:left">节链接信息</td></tr><tr><td style="text-align:left">sh_addralign</td><td style="text-align:left">节地址对齐方式</td></tr><tr><td style="text-align:left">sh_entsize</td><td style="text-align:left">节项大小</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">有些节包含了一些固定大小的项，如符号表，其包含的每个符号所在的大小都一样的，对于这种节，sh_entsize表示每个项的大小。<strong>如果为0，则表示该节不包含固定大小的项。</strong></td></tr></tbody></table><h3 id="节类型（sh-type）"><a href="#节类型（sh-type）" class="headerlink" title="节类型（sh_type）"></a>节类型（sh_type）</h3><p>节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）。</p><p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。常见的节类型如下表所示：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHT_NULL</td><td style="text-align:left">0</td><td style="text-align:left">无效节</td></tr><tr><td style="text-align:left">SHT_PROGBITS</td><td style="text-align:left">1</td><td style="text-align:left"><strong>程序节</strong>。代码节、数据节都是这种类型。</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:left">2</td><td style="text-align:left"><strong>符号表</strong></td></tr><tr><td style="text-align:left">SHT_STRTAB</td><td style="text-align:left">3</td><td style="text-align:left"><strong>字符串表</strong></td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:left">4</td><td style="text-align:left"><strong>重定位表</strong>。该节包含了重定位信息。</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">5</td><td style="text-align:left"><strong>符号表的哈希表</strong></td></tr><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">6</td><td style="text-align:left">动态链接信息</td></tr><tr><td style="text-align:left">SHT_NOTE</td><td style="text-align:left">7</td><td style="text-align:left">提示性信息</td></tr><tr><td style="text-align:left">SHT_NOBITS</td><td style="text-align:left">8</td><td style="text-align:left">表示该节在文件中没有内容。如<code>.bss</code>节</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:left">9</td><td style="text-align:left">该节包含了重定位信息</td></tr><tr><td style="text-align:left">SHT_SHLIB</td><td style="text-align:left">10</td><td style="text-align:left">保留</td></tr><tr><td style="text-align:left">SHT_DNYSYM</td><td style="text-align:left">11</td><td style="text-align:left"><strong>动态链接的符号表</strong></td></tr></tbody></table><h3 id="节标志位（sh-flag）"><a href="#节标志位（sh-flag）" class="headerlink" title="节标志位（sh_flag）"></a>节标志位（sh_flag）</h3><p>节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以<code>SHF_</code>开头。常见的节标志位如下表所示：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHF_WRITE</td><td style="text-align:left">1</td><td style="text-align:left">表示该节在进程空间中可写</td></tr><tr><td style="text-align:left">SHF_ALLOC</td><td style="text-align:left">2</td><td style="text-align:left">表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td></tr><tr><td style="text-align:left">SHF_EXECINSTR</td><td style="text-align:left">4</td><td style="text-align:left">表示该节在进程空间中可以被执行</td></tr></tbody></table><h3 id="节链接信息（sh-link、sh-info）"><a href="#节链接信息（sh-link、sh-info）" class="headerlink" title="节链接信息（sh_link、sh_info）"></a>节链接信息（sh_link、sh_info）</h3><p>如果节的类型是与链接相关的（无论是动态链接还是静态链接），如<strong>重定位表、符号表、</strong>等，则<code>sh_link</code>、<code>sh_info</code>两个成员所包含的意义如下所示。其他类型的节，这两个成员没有意义。</p><table><thead><tr><th style="text-align:left">sh_type</th><th style="text-align:left">sh_link</th><th style="text-align:left">sh_info</th></tr></thead><tbody><tr><td style="text-align:left">SHT_DYNAMIC</td><td style="text-align:left">该节所使用的<strong>字符串表</strong>在节头表中的下标</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_HASH</td><td style="text-align:left">该节所使用的<strong>符号表</strong>在节头表中的下标</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">SHT_REL</td><td style="text-align:left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td><td style="text-align:left">该重定位表所作用的节在节头表中的下标</td></tr><tr><td style="text-align:left">SHT_RELA</td><td style="text-align:left">该节所使用的<strong>相应符号表</strong>在节头表中的下标</td><td style="text-align:left">该重定位表所作用的节在节头表中的下标</td></tr><tr><td style="text-align:left">SHT_SYMTAB</td><td style="text-align:left">操作系统相关</td><td style="text-align:left">操作系统相关</td></tr><tr><td style="text-align:left">SHT_DYNSYM</td><td style="text-align:left">操作系统相关</td><td style="text-align:left">操作系统相关</td></tr><tr><td style="text-align:left">other</td><td style="text-align:left">SHN_UNDEF</td><td style="text-align:left">0</td></tr></tbody></table><hr><h2 id="ELF-Sections"><a href="#ELF-Sections" class="headerlink" title="ELF Sections"></a>ELF Sections</h2><h3 id="节的分类"><a href="#节的分类" class="headerlink" title="节的分类"></a>节的分类</h3><p>上述ELF Section Header Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。</p><h4 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h4><p><code>.text</code>节是保存了程序代码指令的<strong>代码节</strong>。<strong>一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中</strong>。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h4><p><code>rodata</code>节保存了只读的数据，如一行C语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="plt节（过程链接表）"><a href="#plt节（过程链接表）" class="headerlink" title=".plt节（过程链接表）"></a>.plt节（过程链接表）</h4><p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，<strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码</strong>。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h4><p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h4><p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本省的空间。<strong><code>.bss</code>节保存了未进行初始化的全局数据</strong>。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p><h4 id="got-plt节（全局偏移表-过程链接表）"><a href="#got-plt节（全局偏移表-过程链接表）" class="headerlink" title=".got.plt节（全局偏移表-过程链接表）"></a>.got.plt节（全局偏移表-过程链接表）</h4><p><code>.got</code>节保存了<strong>全局偏移表</strong>。<strong><code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改</strong>。由于<code>.got.plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p><h4 id="dynsym节（动态链接符号表）"><a href="#dynsym节（动态链接符号表）" class="headerlink" title=".dynsym节（动态链接符号表）"></a>.dynsym节（动态链接符号表）</h4><p><code>.dynsym</code>节保存在<code>text</code>段中。<strong>其保存了从共享库导入的动态符号表</strong>。节类型为<code>SHT_DYNSYM</code>。</p><h4 id="dynstr节（动态链接字符串表）"><a href="#dynstr节（动态链接字符串表）" class="headerlink" title=".dynstr节（动态链接字符串表）"></a>.dynstr节（动态链接字符串表）</h4><p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p><h4 id="rel-节（重定位表）"><a href="#rel-节（重定位表）" class="headerlink" title=".rel.*节（重定位表）"></a>.rel.*节（重定位表）</h4><p>重定位表保存了重定位相关的信息，<strong>这些信息描述了如何在链接或运行时，对ELF目标文件的某部分或者进程镜像进行补充或修改</strong>。由于重定位表保存了重定位相关的数据，所以节类型为<code>SHT_REL</code>。</p><h4 id="hash节"><a href="#hash节" class="headerlink" title=".hash节"></a>.hash节</h4><p><code>.hash</code>节也称为<code>.gnu.hash</code>，其保存了一个用于查找符号的散列表。</p><h4 id="symtab节（符号表）"><a href="#symtab节（符号表）" class="headerlink" title=".symtab节（符号表）"></a>.symtab节（符号表）</h4><p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p><h4 id="strtab节（字符串表）"><a href="#strtab节（字符串表）" class="headerlink" title=".strtab节（字符串表）"></a>.strtab节（字符串表）</h4><p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p><h4 id="ctors节和-dtors节"><a href="#ctors节和-dtors节" class="headerlink" title=".ctors节和.dtors节"></a>.ctors节和.dtors节</h4><p><code>.ctors</code>（<strong>构造器</strong>）节和<code>.dtors</code>（<strong>析构器</strong>）节分别保存了指向构造函数和析构函数的函数指针，<strong>构造函数是在main函数执行之前需要执行的代码；析构函数是在main函数之后需要执行的代码</strong>。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p><p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p><p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。<strong><code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号</strong>。如全局变量，代码中定义的本地函数等。</p><p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p><p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p><p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。<strong><code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号</strong>。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/elf-symtab-strtab.png" alt=""></p><p>上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">st_name</td><td style="text-align:left">符号名。该值为该符号名在字符串表中的偏移地址。</td></tr><tr><td style="text-align:left">st_value</td><td style="text-align:left">符号对应的值。存放符号的值（可能是地址或位置偏移量）。</td></tr><tr><td style="text-align:left">st_size</td><td style="text-align:left">符号的大小。</td></tr><tr><td style="text-align:left">st_other</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">st_shndx</td><td style="text-align:left">符号所在的节</td></tr><tr><td style="text-align:left">st_info</td><td style="text-align:left">符号类型及绑定属性</td></tr></tbody></table><p>使用readelf工具我们也能够看到符号表的相关信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s hello.o</span><br><span class="line"></span><br><span class="line">Symbol table &apos;.symtab&apos; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4</span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5</span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7</span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6</span><br><span class="line">     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts</span><br></pre></td></tr></table></figure></p><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p><p>ELF文件中所有字符表的结构基本一致，如上图所示。</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p><strong>重定位就是将符号定义和符号引用进行连接的过程</strong>。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。</p><p>重定位表是进行重定位的重要依据。我们可以使用objdump工具查看目标文件的重定位表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -r hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000005 R_X86_64_32       .rodata</span><br><span class="line">000000000000000a R_X86_64_PC32     puts-0x0000000000000004</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE</span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></table></figure></p><p>重定位表是一个<code>Elf_Rel</code>类型的数组结构，每一项对应一个需要进行重定位的项。<br>其成员含义如下表所示：</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">r_offset</td><td style="text-align:left">重定位入口的偏移。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可重定位文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可执行文件或共享对象文件</strong>来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址</td></tr><tr><td style="text-align:left">r_info</td><td style="text-align:left">重定位入口的类型和符号</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">对于<strong>可执行文件和共享目标文件</strong>来说，它们的重定位入口是动态链接类型的。</td></tr></tbody></table><p>重定位是目标文件链接成为可执行文件的关键。我们将在后面的进行介绍。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Executable and Linkable Format (ELF)</li><li>《Linux 二进制分析》</li><li>《程序员的自我修养——链接、装载与库》</li><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li></ol><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://chuquan.me/2018/05/12/compiler-principle/#more&quot;&gt;前文&lt;/a&gt;结尾说到编译器编译源代码后生成的文件叫做&lt;strong&gt;目标文件&lt;/strong&gt;，而目标文件经过编译器链接之后得到的就是&lt;stron
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="ELF文件" scheme="http://chuquan.me/tags/ELF%E6%96%87%E4%BB%B6/"/>
    
      <category term="目标文件" scheme="http://chuquan.me/tags/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    
      <category term="可执行文件" scheme="http://chuquan.me/tags/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(2)——程序构建及编译原理</title>
    <link href="http://chuquan.me/2018/05/12/compiler-principle/"/>
    <id>http://chuquan.me/2018/05/12/compiler-principle/</id>
    <published>2018-05-12T13:28:08.000Z</published>
    <updated>2018-06-04T13:21:27.318Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《程序员的自我修养——链接、装载与库》一书，这本书以前看过一部分，由于难啃，当时没有坚持下去。现在工作了，每天接触的都是业务开发，对底层的一些东西感觉越来越陌生。于是，又把此书翻了出来拜读。为了加深阅读的印象，打算对书中的一些有价值的内容进行整理，也方便后续回顾。</p><h1 id="程序构建流程"><a href="#程序构建流程" class="headerlink" title="程序构建流程"></a>程序构建流程</h1><p>下面以“Hello World”程序为例，来介绍程序的编译与链接过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux下，可以直接使用GCC来编译Hello World程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p><p>GCC编译命令隐藏了构建过程中的一些复杂的步骤，主要有4个步骤，如下图所示。</p><ul><li><strong>预处理（Propressing）</strong></li><li><strong>编译（Compilation）</strong></li><li><strong>汇编（Assembly）</strong></li><li><strong>链接（Linking）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/code-compile-process.png" alt=""></p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译步骤将源代码文件<code>hello.c</code>以及相关头文件，如：<code>stdio.h</code>等预编译生成一个.i文件。对于C++程序，其源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，预编译生成.ii文件。</p><p>预编译步骤相当于执行如下命令（选项-E表示只进行预编译）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></p><p><strong>预编译</strong>主要处理源代码中的以“#”开始的预编译指令，如：“#include”、“#define”等，其主要处理规则如下：</p><ul><li>将所有的“#define”删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，如：“#if”、“#ifdef”、“#else”、“#endif”。</li><li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。该过程是递归进行的，因为被包含的文件可能还包含其他文件。</li><li>删除所有的注释“//”和“/<em> </em>/”。</li><li>添加行号和文件名标识，比如#2 “hello.c” 2，以便于编译时编译器产生调试试用的行号信息以及用于编译时产生编译错误或警告时能够显示行号。</li><li>保留所有的#pragma编译器指令，因为编译器须要试用他们。</li></ul><p>预编译生成的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>编译</strong>就是把预处理生成的文件进行一系列词法分析、语法分析、语义分析、优化，生成相应的汇编代码文件。这个过程是整个程序构建的核心部分，也是最复杂的部分之一。</p><p>编译步骤相当于执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></p><p>现在版本的GCC把预编译和编译两个步骤合并成了一个步骤，使用一个叫cc1的程序来完成。该程序位于“<code>/usr/lib/gcc/x86_64-linux-gnu/4.8/</code>”，我们可以直接调用cc1来完成它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c</span><br></pre></td></tr></table></figure></p><p>事实上，对于不同的语言，预编译与编译的程序是不同的，如下所示：</p><ul><li>C：<strong>cc1</strong></li><li>C++：<strong>cc1plus</strong></li><li>Objective-C：<strong>cc1obj</strong></li><li>Fortran：<strong>f771</strong></li><li>Java：<strong>jc1</strong></li></ul><p>GCC是对这些后台程序的封装，它会根据不同的参数来调用预编译程序cc1、汇编器as、链接器ld。</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p><strong>汇编</strong>就是将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。汇编过程相对于编译比较简单，其没有复杂的语法、语义，也无需做指令优化，只是根据汇编指令和机器指令的对照表进行翻译。</p><p>汇编步骤相当执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure></p><p>GCC本质上是调用汇编器as来完成汇编步骤的，我们可以直接调用as来完成该步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>链接</strong>主要是将前面步骤生成多个目标文件进行重定位等复杂的操作，从而生成可执行文件。链接可分为静态链接和动态链接。</p><h1 id="编译器工作原理"><a href="#编译器工作原理" class="headerlink" title="编译器工作原理"></a>编译器工作原理</h1><p>编译过程可以分为6个步骤，如下图所示。</p><ul><li><strong>扫描（Scanning）</strong>（又称词法分析）</li><li><strong>语法分析（Syntax analysis）</strong></li><li><strong>语义分析（Semantic Analysis）</strong></li><li><strong>源代码优化（Source Code Optimization）</strong></li><li><strong>目标代码生成（Target Code Generation）</strong></li><li><strong>目标代码优化（Target Code Optimization）</strong></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-detail-process.png" alt=""></p><p>下面我们以一行简单的C语言代码为例，简单描述从<strong>源代码（Source Code）</strong>到<strong>最终目标代码</strong>的过程。代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)</span><br></pre></td></tr></table></figure></p><h2 id="扫描（词法分析）"><a href="#扫描（词法分析）" class="headerlink" title="扫描（词法分析）"></a>扫描（词法分析）</h2><p>首先源代码被输入到<strong>扫描器（Scanner）</strong>，扫描器的任务很简单，只是简单地进行词法分析，运用一种类似于<strong>有限状态机（Finite State Machine）</strong>的算法将源代码的字符序列分割成一系列的<strong>记号（Token）</strong>。</p><p>以上述代码为例，总共包含了28个非空字符，经过扫描后，产生了16个记号。</p><table><thead><tr><th style="text-align:left">记号</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">array</td><td style="text-align:left">标识符</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">左方括号</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">标识符</td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">右方括号</td></tr><tr><td style="text-align:left">=</td><td style="text-align:left">赋值</td></tr><tr><td style="text-align:left">(</td><td style="text-align:left">左圆括号</td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">标识符</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">数字</td></tr><tr><td style="text-align:left">)</td><td style="text-align:left">右圆括号</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘号</td></tr><tr><td style="text-align:left">(</td><td style="text-align:left">左圆括号</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">数字</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">数字</td></tr><tr><td style="text-align:left">)</td><td style="text-align:left">右圆括号</td></tr></tbody></table><p>词法分析产生的记号一般可以分为一下几类：<strong>关键字</strong>、<strong>字面量</strong>（包含数字、字符串等）和<strong>特殊符号</strong>（如加号、等号）。</p><p>在识别记号的同时，扫描器也完成了其他工作。如：将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。</p><p>有一个名为lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。正因为有这样一个程序存在，编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p><strong>语法分析器（Grammar Parser）</strong>将对由扫描器产生的记号进行语法分析。从而产生<strong>语法树（Syntax Tree）</strong>。整个分析过程采用了<strong>上下文无关语法（Context-freeGrammar）</strong>的分析手段。简单地讲，由语法分析器生成的语法树是以<strong>表达式（Expression）</strong>为节点的树。</p><p>以上述代码为例，其中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句，下图所示为该语句经过语法分析器后生成的语法树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// CompilerExpression.c</span><br><span class="line">array[index] = (index + 4) * (2 + 6)</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-syntax-tree.png" alt=""></p><p>在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。如：乘法表达式的优先级比加法高，圆括号表达式的优先级比乘法高，等等。另外，有些符号具有多重含义，如“*”在C语言中可以表示乘法表达式，也可以表示对指针取内容的表达式，因此语法分析阶段必须对这些内容进行区分。如果出现了表达式不合法，如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。</p><p>有一个名为yacc（Yet Another Compiler Compiler）的工具可以实现语法分析。其根据用户给定的语法规则对输入的记号序列进行解析，从而构建出语法树。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器编写一个语法分析器。因此，其也称为“编译器编译器（Compiler Compiler）”</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语法分析仅仅完成了对表达式的语法层面的分析，但它并不了解这个语句的真正含义，如：C语言里两个指针做乘法运算是没有意义的，但这个语句在语法上是合法的。编译器所能分析的语义是<strong>静态语义（Static Semantic）</strong>，所谓静态语义是指在编译期间可以确定的语义，与之对应的<strong>动态语义（Dynamic Semantic）</strong>就是只有在运行期才能确定的语义。</p><p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型的转换过程，语义分析过程中需要完成该步骤。比如讲一个浮点赋值给一个指针时，语义分析程序会发现这个类型不匹配，编译器将会报错。动态语义一般是指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p><p>经过语义分析阶段之后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。下图所示为标记语义后的语法树。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-commented-syntax-tree.png" alt=""></p><h2 id="源代码优化（中间代码生成）"><a href="#源代码优化（中间代码生成）" class="headerlink" title="源代码优化（中间代码生成）"></a>源代码优化（中间代码生成）</h2><p>现代编译器有着很多层次的优化，<strong>源码优化器（Source Code Optimizer）</strong>则是在源代码级别进行优化。上述例子中，（2 + 6）这个表达式可以被优化掉。因为它的值在编译期就可以被确定。下图所示为优化后的语法树。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/compile-optimized-syntax-tree.png" alt=""></p><p>事实上，直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong>，它是语法树的顺序表示，其实它已经非常接近目标代码了。但它一般与目标机器和运行时环境是无关的，比如它不包含数据的尺寸、变量地址和寄存器的名字等。</p><p>中间代码有很多种类型，在不同的编译器中有着不同的形式，比较常见的有：<strong>三地址码（Three-address Code）</strong>、<strong>P-代码（P-Code）</strong>。以三地址码为例，最基本的三地址码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y op z</span><br><span class="line"># 表示将变量y和z进行op操作后，赋值给x。</span><br></pre></td></tr></table></figure></p><p>因此，可以将上述例子的代码翻译成三地址码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 = 2 + 6</span><br><span class="line">t2 = index + 4</span><br><span class="line">t3 = t2 * t1</span><br><span class="line">array[index] = t3</span><br></pre></td></tr></table></figure></p><p>为了使所有的操作符合三地址码形式，这里使用了几个临时变量：t1、t2和t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果计算出来，得到t1 = 6。因此，进一步优化后可以得到如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 = index + 4</span><br><span class="line">t2 = t2 * 8</span><br><span class="line">array[index] = t2</span><br></pre></td></tr></table></figure></p><p>中间代码将编译器分为<strong>前端（Front End）</strong>和<strong>后端（Back End）</strong>。编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码。这样，对于一些可跨平台的编译器，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。比如clange就是一个前端工具，而LLVM则负责后端处理。GCC则是一个套装，包揽了前后端的所有任务。</p><hr><h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>目标代码生成主要由<strong>代码生成器（Code Generator）</strong>完成。代码生成器将中间代码转换成目标机器代码，该过程十分依赖目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。</p><p>上述例子的中间代码，经过代码生成器的处理之后可能会生成如下所示的代码序列（以x86汇编为例，假设index的类型为int型，array的类型为int型数组）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl index, %ecx            ; value of index to ecx</span><br><span class="line">addl $4, %ecx               ; ecx = ecx + 4</span><br><span class="line">mull $8, %ecx               ; ecx = ecx * 8</span><br><span class="line">movl index, %eax            ; value of index to eax</span><br><span class="line">movl %ecx, array(,%eax,4)    ; array[index] = ecx</span><br></pre></td></tr></table></figure></p><h2 id="目标代码优化"><a href="#目标代码优化" class="headerlink" title="目标代码优化"></a>目标代码优化</h2><p>目标代码生成后，由<strong>目标代码优化器（Target Code Optimizer）</strong>来进行优化。比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</p><p>上述例子中，乘法由一条相对复杂的<strong>基址比例变址寻址（Base Index Scale Addressing）</strong>的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的。如下所示为优化后的目标代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(,%edx,8), %eax</span><br><span class="line">movl %eax, array(,%edx,4)</span><br></pre></td></tr></table></figure></p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>经过扫描、语法分析、语义分析、源代码优化、目标代码生成、目标代码优化等一系列步骤之后，源代码终于被编译成了目标代码。但是这个目标代码中有一个问题：</p><blockquote><p>index和array的地址还没有确定</p></blockquote><p>如果我们把目标代码使用汇编器编译成真正能够在机器上运行的指令，那么index和array的地址来自哪里？<br>如果index和array定义在跟上面的源代码同一个编译单元里，那么编译器可以为index和array分配空间，确定地址；但如果是定义在其他的程序模块呢？</p><p>事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。所以现代编译器可以将一个源文件编译成一个未链接的目标文件，然后由编译器最终将这些目标文件链接起来形成可执行文件。</p><p>后面，我们将继而探讨链接的原理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《程序员的自我修养——链接、装载与库》</li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看《程序员的自我修养——链接、装载与库》一书，这本书以前看过一部分，由于难啃，当时没有坚持下去。现在工作了，每天接触的都是业务开发，对底层的一些东西感觉越来越陌生。于是，又把此书翻了出来拜读。为了加深阅读的印象，打算对书中的一些有价值的内容进行整理，也方便后续回顾。&lt;
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="http://chuquan.me/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一种简易的客户端存储架构设计</title>
    <link href="http://chuquan.me/2018/04/26/a-design-of-ios-storage-architecture/"/>
    <id>http://chuquan.me/2018/04/26/a-design-of-ios-storage-architecture/</id>
    <published>2018-04-25T16:43:18.000Z</published>
    <updated>2018-06-09T15:03:30.706Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了公司内部某三个APP项目的存储相关代码。总体来说，存储架构基本上是类似的。对此，我绘制了其存储架构的示意图，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/leo-local-storage.png" alt=""></p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>项目使用自定义的数据库<code>KVDBStore</code>，该数据库实际上只是对开源数据库<code>FMDatabase</code>进行了封装，其包含如下两个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface KVDBStore()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) FMDatabaseQueue *dbQueue;</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *dbPath;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>KVDBStore</code>存储于应用沙盒的<code>Data Container</code>中的<code>Documents</code>目录下（<a href="http://chuquan.me/2018/02/06/ios-reverse-engineering-basis">进一步了解应用沙盒结构</a>）。该目录可以通过如下方法获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];</span><br></pre></td></tr></table></figure></p><p><code>KVDBStore</code>数据库的存储条目具有几个特定的值，使用<code>DBItem</code>对象来表示，其属性包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface DBItem : NSObject</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSString * itemId;</span><br><span class="line">@property (strong, nonatomic) id itemObject;</span><br><span class="line">@property (strong, nonatomic) NSDate * createdTime;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><code>KVDBStore</code>主要提供了构造方法、析构方法以及一些基本的操作方法，如：增删查改、Transaction操作等，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (id)initDBWithName:(NSString *)dbName;</span><br><span class="line"></span><br><span class="line">- (id)initWithDBWithPath:(NSString *)dbPath;</span><br><span class="line"></span><br><span class="line">- (BOOL)createTableWithName:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (BOOL)clearTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (void)close;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">///************************ Transaction methods *************************************</span><br><span class="line"></span><br><span class="line">- (BOOL)beginTransaction;</span><br><span class="line"></span><br><span class="line">- (BOOL)rollbackTransaction;</span><br><span class="line"></span><br><span class="line">- (BOOL)commitTransaction;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">///************************ Put&amp;Get methods *****************************************</span><br><span class="line"></span><br><span class="line">- (BOOL)putObject:(id)object withId:(NSString *)objectId intoTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (id)getObjectById:(NSString *)objectId fromTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">- (BOOL)deleteObjectById:(NSString *)objectId fromTable:(NSString *)tableName;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><p><code>KVDBStore</code>是在数据库层面实现的一个类，一个数据库通常是由多个表组成的，在实际开发中，表间的联结操作相对比较少，主要还是对特定表进行增删查改的操作。对此，项目实现了表级类<code>BaseTable</code>以便于进行操作，其包含以下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface BaseTable ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *databaseName;</span><br><span class="line">@property (nonatomic, strong) NSString *tableName;</span><br><span class="line">@property (nonatomic, strong) KVDBStore *databaseStore; </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h1 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a>存储架构</h1><p>项目只实例化了一个数据库，所有的表均建立在该数据库中，并且所有的表都继承自<code>BaseTable</code>，而这些表则定义了与该表相关的数据库操作。以<code>AccountTable</code>为例，其应该定义类似以下的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getAccount;</span><br><span class="line">- (void)setAccount:(NSString *)account;</span><br><span class="line"></span><br><span class="line">- (UserInfo *)userInfo;</span><br><span class="line">- (void)setUserInfo:(UserInfo *)userInfo;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在实际开发中，我们经常会面临同时从（向）一个表（或多个表）读取（写入）数据。对此，项目中实现了各种代理单例来完成这些操作，如：使用<code>AccountAgent</code>定义登录和退出的方法，其内部需要对<code>AccountTable</code>进行很多复杂的操作，。当然，在涉及到表间联结操作时，也应该通过代理来进行实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// AccountAgent</span><br><span class="line"></span><br><span class="line">- (void)login;</span><br><span class="line">- (void)logout;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>后续，希望能够阅读以下<code>FMDatabase</code>的源码，以对iOS底层的存储原理有进一步的理解。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看了公司内部某三个APP项目的存储相关代码。总体来说，存储架构基本上是类似的。对此，我绘制了其存储架构的示意图，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.c
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="存储" scheme="http://chuquan.me/tags/%E5%AD%98%E5%82%A8/"/>
    
      <category term="架构" scheme="http://chuquan.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MVC、MVP、MVVM的演化</title>
    <link href="http://chuquan.me/2018/04/11/mvc-mvp-mvvm/"/>
    <id>http://chuquan.me/2018/04/11/mvc-mvp-mvvm/</id>
    <published>2018-04-10T16:23:49.000Z</published>
    <updated>2018-07-01T12:52:34.396Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="基本MVC模式"><a href="#基本MVC模式" class="headerlink" title="基本MVC模式"></a>基本MVC模式</h2><p>如下图所示为基本的MVC（Model-View-Controller）模式结构图，可分为三部分：模型（Model）、视图（View）、控制器（Controller）。其在MVC模式中所扮演的角色分别为：</p><ol><li>Model：模型管理应用程序的数据，响应有关其状态信息（通常来自View）的请求，并响应指令以更改状态（通常来自Controller）。</li><li>View：视图管理数据的展示。</li><li>Controller：控制器解释用户的输入，并通知模型、视图进行状态更新。</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/basic-MVC.png" alt=""></p><p>其中，View和Controller依赖于Model，而Model并不依赖于View和Controller。这种设计模式的优点在于允许Model不受View的影响，从而能够进行独立的构建和测试。</p><p>此外，根据Model的具体实现还可以进一步分为：<strong>主动型Model</strong>、<strong>被动型Model</strong>。</p><h3 id="被动型Model-MVC模式"><a href="#被动型Model-MVC模式" class="headerlink" title="被动型Model MVC模式"></a>被动型Model MVC模式</h3><p>当只有一个Controller操控着Model时可以采用<strong>被动型Model</strong>。Controller定义Model，并在Model发生改变时通知View，后者再进行更新。在这种场景下，Model完全独立于View和Controller。实际上，被动型Model MVC模式就是基本的MVC模式。</p><h3 id="主动型Model-MVC模式"><a href="#主动型Model-MVC模式" class="headerlink" title="主动型Model MVC模式"></a>主动型Model MVC模式</h3><p>当Model的状态未受Controller干扰的情况下发生变化时，使用<strong>主动型Model</strong>。当其他来源正在更改数据并且必须立刻反应到View中时，可能会发生这种情况。</p><p>为了实现主动型Model，通常使用Observer模式来提供了一种机制来提醒其他对象的状态变化，避免引入依赖关系。各个View实现Observer接口并向Model注册。当Model发生变化时，Model会遍历所有注册的观察者并通知他们相关的变化。这种方法通常被称为“发布 - 订阅”。Model从不需要关于任何View的任何信息。事实上，在Controller需要被告知Model变化的情况下（例如，启用或禁用菜单选项），所有Controller必须通过实现Observer接口并订阅Model的变化。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/active-model-MVC.png" alt=""></p><h2 id="传统版MVC"><a href="#传统版MVC" class="headerlink" title="传统版MVC"></a>传统版MVC</h2><p>上述主动型Model MVC模式通过加入Observer模式进行了改良。事实上，随着业务需求的变化，MVC模式通过不断加入一些更基本的设计模式采演化成现在经典的MVC模式。这些基本模式协同工作，定义了MVC应用程序特有的功能分离和通信路径。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/traditional-MVC.png" alt=""></p><p>上图所示为传统MVC设计模式，其通过Composition、Strategy、Observer等基本设计模式协同工作以实现。用户操作在复合结构的某个层次上操作View，生成一个事件。Controller接收事件，并进行解释。这个过程使用Strategy模式实现，可以是通过消息请求一个Model对象来更新其状态或请求一个View对象来更新其行为或外观。Model对象则在其状态改变时通知所有已注册为观察者的对象。如果观察者是对象，则可以相应更新其外观。</p><h2 id="苹果版MVC"><a href="#苹果版MVC" class="headerlink" title="苹果版MVC"></a>苹果版MVC</h2><p>苹果认为传统的MVC模式中，View通过Observer模式直接观察Model对象以获取相关的通知，而这样的设计会导致View和Model对象不能被广泛复用，因为View与其观察的Model之间存在耦合关系。因此，苹果版MVC与传统MVC基本一致，只是隔离了View和Model。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/apple-MVC.png" alt=""></p><p>在iOS中，UIViewController和UIView是一一对应的。随着业务的深入，MVC最终一点点变成了<strong>Massive-View-Controller</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVC.png" alt=""></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>MVP（Modell-View-Presenter）模式就是为了解决MVC中Controller越来越臃肿的问题，进一步明确代码分工。MVP与苹果版MVC非常相似，但是它们的从属关系有所不同（实线表示持有）。如下图所示，MVP模式中View持有Presenter，Presenter持有Model，View不能直接访问Model；而MVC模式中Controller持有View和Model。</p><p>通过修改从属关系，可以真正意义上实现将UI逻辑和数据逻辑隔离，而隔离之后就可以方便地对数据逻辑部分进行单元测试。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVP.png" alt=""></p><p>在iOS中，MVP的实现一般如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVP.png" alt=""></p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>MVVM（Model View View-Model）就是为了解决MVP中Presenter过于臃肿的问题。MVVM的思想是将Controller中UI控制逻辑与业务逻辑进行分离，并抽离出一个View-Model来完成UI控制的逻辑。而Controller只需要负责业务逻辑即可。如下图便是MVVM的结构图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/MVVM.png" alt=""></p><p>通常，View-Model可以调用Model定义的方法，从Model中获取数据以用于View，并对数据进行预处理，使View可以直接使用。View又可以向View-Model发出用户的操作命令，从而更改Model。MVVM实现了一种双向绑定机制。</p><p>在iOS中，MVVM的实现一般如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-MVVM.png" alt=""></p><p>MVVM的优点在于：降低了View和Model之间的耦合；分离了业务逻辑和视图逻辑。缺点在于：View和Model双向绑定导致bug难以定位，两者中的任何一方出现问题，另一方也会出现问题；增加了胶水代码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://msdn.microsoft.com/en-us/library/ff649643.aspx" target="_blank" rel="noopener">Model-View-Controller</a></li><li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html" target="_blank" rel="noopener">Concepts in Objective-C Programming</a></li><li><a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" target="_blank" rel="noopener">The MVVM Pattern</a></li><li><a href="https://www.jianshu.com/p/caaa173071f3" target="_blank" rel="noopener">iOS 关于MVC和MVVM设计模式的那些事</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC, MVP和MVVM</a></li><li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="noopener">被误解的MVC和被神化的MVVM</a></li><li><a href="http://blog.harrisonxi.com/2017/07/iOS%E4%BD%BF%E7%94%A8RAC%E5%AE%9E%E7%8E%B0MVVM%E7%9A%84%E6%AD%A3%E7%BB%8F%E5%A7%BF%E5%8A%BF.html" target="_blank" rel="noopener">iOS使用RAC实现MVVM的正经姿势</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在iOS开发中苹果定义了一套MVC的软件架构。前几天，同事们聊起了MVC、MVP、MVVM等架构的区别。今天，我也来对此给出一些自己的理解。&lt;/p&gt;
&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="软件" scheme="http://chuquan.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="设计模式" scheme="http://chuquan.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="MVC" scheme="http://chuquan.me/tags/MVC/"/>
    
      <category term="MVP" scheme="http://chuquan.me/tags/MVP/"/>
    
      <category term="MVVM" scheme="http://chuquan.me/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>基于树的iOS页面路径转换设计</title>
    <link href="http://chuquan.me/2018/04/01/ios-tree-based-path-conversion-design/"/>
    <id>http://chuquan.me/2018/04/01/ios-tree-based-path-conversion-design/</id>
    <published>2018-04-01T06:32:18.000Z</published>
    <updated>2018-11-24T13:31:55.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>采集用户在购买VIP或购买商品时的操作路径，如：”首页” -&gt; “搜题历史页” -&gt; “题目详情页1” -&gt; “名师大招”。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>易用性</li><li>可靠性</li></ol><h3 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h3><p>考虑到上述两个设计原则，路径转换在每个页面中的使用都不应该受限于其相对于其他页面的位置或关系。简而言之，即具备独立性和通用性。以view controller为例，路径转换在特定的生命周期阶段使用，就是符合设计原则的。</p><p>以下有两种方案：基于栈的设计、基于多叉树的设计。下面依次进行分析。</p><h4 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h4><p>下图所示为两个View Controller切换时，各个VC的生命周期的切换顺序，其中A为父VC，B为子VC。为了遵循上述设计原则，我们希望能够在特定生命周期进行push/pop操作。合法的push/pop组合应该遵循如下的调用顺序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A push -&gt; B push -&gt; B pop -&gt; A pop</span><br></pre></td></tr></table></figure></p><p>然而，我们在下图中找不到一个合法的push/pop组合，除了【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种情况。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vcs-lifecycle.png?x-oss-process=image/resize,w_570" alt=""></p><p>那么，在【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】是不是真能应对所有场景呢？</p><p>试想如下图所示这样一种场景，当一个VC包含多个VC对象时，其中一个VC再调用子VC。这时候，我们期望得到的路径应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p><p>然而在很多情况下，A会在<code>init</code>/<code>viewDidLoad</code>阶段初始化多有VC对象。这时候如果使用的是【<code>init</code>/<code>viewDidLoad</code>时push，<code>dealloc</code>时pop】这种组合，在E中得到的路径会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D -&gt; E</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-multisubvcs-structure.png?x-oss-process=image/resize,w_250" alt=""></p><p>综合上述，使用栈结构很难实现一种易用、可靠的设计方案。</p><h4 id="2-树"><a href="#2-树" class="headerlink" title="2. 树"></a>2. 树</h4><p>我们使用多叉树实现了一个易用、可靠的路径转换方案。如下左图所示，为一个app经常会面临的vc结构。我们使用多叉树来描述ap的vc结构。在任何时候，页面总是能够返回到根页面（tab页），所以树节点不会形成环，即可以使用树结构来进行描述，如右图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/tree-based-path-conversion-design.png" alt=""></p><p>其中，树节点包括四个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface VGOKeyfromBaseNode : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak, nullable) __kindof VGOKeyfromBaseNode *parentNode;  // 父节点</span><br><span class="line">@property (nonatomic, strong) NSString *value;      // 节点信息</span><br><span class="line">@property (nonatomic, strong) NSMutableArray&lt;__kindof VGOKeyfromBaseNode *&gt; *subNodes;   // 子节点</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>为了能够维护多棵树，使用 <code>VGOKeyfromTreeManager</code> 进行管理，其包含两个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof VGOKeyfromBaseNode *&gt; *keyfromTrees;     // 存储各个树的根节点</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, __kindof VGOKeyfromBaseNode *&gt; *currentNodes;     // 存储各个树的当前节点</span><br></pre></td></tr></table></figure></p><p>以 <code>keyfromNode</code> 的类型名称作为 key，分别保存了树的根节点以及当前节点。</p><p>使用的方法是：</p><ol><li>在<code>viewDidLoad</code>阶段，创建节点并加入树中。</li><li>在<code>viewWillAppear/viewDidAppear</code>阶段或者在进入新页面之前，将该节点设置为当前节点。</li><li>在<code>dealloc</code>阶段，将本节点的父节点设置为当前节点，并将该节点从树中删除。</li></ol><p>树管理器的公有接口如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 创建根节点</span><br><span class="line">- (void)createKeyfromTreeWithRootNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line"></span><br><span class="line">// 设置节点为当前节点</span><br><span class="line">- (void)updateCurrentNodeWithNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line"></span><br><span class="line">// 向树中添加子节点</span><br><span class="line">- (void)addNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line">// 从树中删除子节点</span><br><span class="line">- (void)removeNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line"></span><br><span class="line">// 获取从根节点到指定节点的列表</span><br><span class="line">- (NSArray&lt;__kindof VGOKeyfromBaseNode *&gt; *)nodePathToLastNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line">// 获取从根节点到指定节点的列表，并进行过滤</span><br><span class="line">- (NSArray&lt;__kindof VGOKeyfromBaseNode *&gt; *)nodePathToLastNode:(__kindof VGOKeyfromBaseNode *)node exceptValue:(nullable NSString *)value;</span><br><span class="line"></span><br><span class="line">// 获取从根节点到指定节点的路径</span><br><span class="line">- (NSString *)keyfromPathToLastNode:(__kindof VGOKeyfromBaseNode *)node;</span><br><span class="line">// 获取从根节点到指定节点的路径，并自定义联结符号、过滤内容</span><br><span class="line">- (NSString *)keyfromPathToLastNode:(__kindof VGOKeyfromBaseNode *)node exceptValue:(nullable NSString *)value joinWith:(NSString *)join;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">节点的公有接口如下所示：</span><br></pre></td></tr></table></figure></p><p>// 将本节点设置为根节点</p><ul><li>(void)setAsRootNode;<br>// 将本节点设置为当前节点</li><li>(void)setAsCurrentNode;</li></ul><p>// 将本节点添加至树中</p><ul><li>(void)addToKeyfromTree;<br>// 将本节点从树种删除</li><li>(void)removeFromKeyfromTree;</li></ul><p>// 清空本节点的所有子节点</p><ul><li>(void)clearSubNodes;</li></ul><p>// 获取本节点类型的根节点</p><ul><li>(__kindof VGOKeyfromBaseNode *)rootNode;<br>// 获取本节点类型的当前节点</li><li>(__kindof VGOKeyfromBaseNode *)currentNode;<br>// 获取本节点类型的 keyfrom 路径</li><li>(NSString *)keyfromPath;<br>```</li></ul><p>实践证明，这种设计方案还能够非常简单地应用到一下这些场景之中。</p><ol><li>view Controller、View混合路径；</li><li>统跳；</li><li>view Controller多处复用、节点信息不同；</li><li>忽略路径中特定节点</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求场景&quot;&gt;&lt;a href=&quot;#需求场景&quot; class=&quot;headerlink&quot; title=&quot;需求场景&quot;&gt;&lt;/a&gt;需求场景&lt;/h2&gt;&lt;p&gt;采集用户在购买VIP或购买商品时的操作路径，如：”首页” -&amp;gt; “搜题历史页” -&amp;gt; “题目详情页1” -&amp;gt
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="路径转化" scheme="http://chuquan.me/tags/%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8C%96/"/>
    
      <category term="设计" scheme="http://chuquan.me/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>《徐彬说投资》笔记</title>
    <link href="http://chuquan.me/2018/02/23/xubing-investment/"/>
    <id>http://chuquan.me/2018/02/23/xubing-investment/</id>
    <published>2018-02-23T14:58:22.000Z</published>
    <updated>2018-02-23T15:01:44.211Z</updated>
    
    <content type="html"><![CDATA[<p>几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记<a href="https://note.youdao.com/share/?id=ce6a0c26ad775e2ac31665738ebfc131&amp;type=note#/" target="_blank" rel="noopener">在这里</a></p><h1 id="如何计算自己有多少钱可以用于理财？"><a href="#如何计算自己有多少钱可以用于理财？" class="headerlink" title="如何计算自己有多少钱可以用于理财？"></a>如何计算自己有多少钱可以用于理财？</h1><p>对于我们普通人来说，每个月能够剩余下来的钱（<strong>自由现金流</strong>）均可以用于理财。自由现金流计算公式如下：</p><blockquote><p><strong>自由现金流 = 收入 - 支出</strong><br><strong>收入</strong> = 劳动收入（工资）<br><strong>支出</strong> = 必需支出（房租、房贷、生活费等） + 可选支出（娱乐费用）  </p></blockquote><p>因此，要想有多余的钱理财，必须保证自由现金流为正。如何保证自由现金流为正？两个方法：</p><ul><li><strong>开源</strong>：增加收入</li><li><strong>节流</strong>：减少支出</li></ul><p>很明显，自己容易控制的便是减少支出，其中<strong>可选支出</strong>可控程度是比较大的。</p><p>生活处处有风险，常见有两种风险可能会导致自由现金流为负：<strong>重大疾病</strong>、<strong>失业</strong>。为应对这两种风险，一般我们的措施是：</p><ul><li><strong>重大疾病</strong>：购买重疾险</li><li><strong>失业</strong>：预存应急资金。假设失业以后6个月后必能找到工作。可以将6个月的总支出定为应急资金。应急资金需要充分利用，应该放在货币基金，风险相对较小。</li></ul><p>一般而言，理财收入不能算入收入，各种奖金也不应该算入收入。通过上述公式便可计算出自己有多少钱可用于理财。</p><h1 id="理财的基本概念"><a href="#理财的基本概念" class="headerlink" title="理财的基本概念"></a>理财的基本概念</h1><p>在理财前，投资者需要了解一下这些概念：</p><ol><li><p>任何理财产品都是具有风险的，而风险的本质便是<strong>波动</strong>。比如：股票价格的涨跌波动。</p></li><li><p><strong>风险与收益成正比</strong>。另外还需要有充分的<strong>时间</strong>进行保障。</p></li><li><p><strong>可投资标的</strong>：哪些资产可以在自己的投资期限内进行投资。</p></li><li><p><strong>风险承受能力</strong>：评估可投资标的在投资期限内的最大投资亏损。很多投资亏损就是由于投资前没有评估好自己的风险承受能力，心态受到市场情绪影响导致的。</p></li></ol><h1 id="股票与债券"><a href="#股票与债券" class="headerlink" title="股票与债券"></a>股票与债券</h1><p>我们都知道股票和债券，那么这两者是什么？有什么区别呢？</p><p>一切要从<strong>价值分配模型</strong>说起，价值分配模型包含两部分，分别是<strong>劳动价值</strong>、<strong>剩余价值</strong>。</p><p>一般来说，一个公司的资本分为两类：<strong>债券</strong>、<strong>股票</strong>。相应的投资人也分为两类：<strong>债券投资人</strong>、<strong>股票投资人</strong>（股东）。公司将其运营产生的<strong>剩余价值</strong>通过债券、股票分配给投资人。</p><blockquote><p>假设公司不用交税，一年挣了3千万（即剩余价值）。假设去年发行了一个亿3年期，每年利息10%的债券。那么公司的3千万，债券投资人拿走1千万（1亿 x 10%）。其他全部分给股票投资人。</p><p>如果一年收益1亿，债券投资人只能拿1千万，而股票投资人则可以拿9千万。</p></blockquote><p>相比而言，债券投资人获取收益的优先级更高，收益比股票投资人更明确。即无论有多少剩余价值，都优先分给债券投资人。在上述例子中，债券的收益是每年10%。而股票的风险比较大，对应的收益也可能更高。</p><p>通常，大企业的优势是收益稳定，劣势是发展空间有限；中小企业的优势是发展潜力，劣势是收益。因此，大企业的债券比较可靠，股票的增值空间相对较小；中小企业的债券短期内不一定有收益，长期来看其股票增值空间相对较大。</p><p>关于股票，公司分配给股票投资者的价值有两种方式：</p><ol><li><strong>发放现金分红</strong></li><li><strong>股票价格上涨</strong>：如果公司在一段时间内的收益越高，希望投资的人越多，股票价格会变得越高。</li></ol><h1 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h1><p>如果投资期限为一年，最好的投资标的是<strong>货币基金</strong>，如余额宝。货币基金是<strong>公募基金</strong>的一种。货币基金有以下优点：</p><ul><li>货币基金的门槛很低，一块钱都可以</li><li>货币基金的各种费用很低</li><li>风险极低</li><li>每天都有收益，包括节假日</li><li>货币基金非常灵活，买入后立刻产生收益。</li><li>货币基金往往在其他投资标的表现不好时，收益会更好。</li></ul><p>货币基金主要有两个指标:</p><ul><li><strong>七日年化收益率</strong>：过去七天平均每天的收益如果持续一年可以产生的收益</li><li><strong>万份收益</strong>：货币基金会保持每份一元的净值水平。因此，货币基金的总资产等于货币基金的总份数。每一万份货币基金，在过去一天产生的收益。</li></ul><p>那么为什么货币基金风险很低？这是因为货币基金的投资标的是<strong>短期国债</strong>、<strong>中央银行票据</strong>、<strong>银行背书的商业汇票</strong>、<strong>银行承兑汇票</strong>、<strong>银行定存</strong>、<strong>大额可转让存单</strong>等。这些都是金融投资风险最低。另一方面，货币基金的管理要求非常高，如果基金经理的货币基金做亏了，基本职业生涯完了。所以，货币基金的风险非常低。</p><p>货币基金适合投资期限小于一年，随取随存的场景，对于应急资金和工资来说非常适合。我们平时所用的余额宝、活期宝便是货币基金。相对其它投资标的，货币基金收益也较低，一年的收益率大概为4%左右。</p><h2 id="货币基金的4个投资技巧"><a href="#货币基金的4个投资技巧" class="headerlink" title="货币基金的4个投资技巧"></a>货币基金的4个投资技巧</h2><ul><li>季度末，半年末，年末，货币基金的收益率比较高。</li><li>关注央行的行为。其会影响金融市场的流动性。央行加息，提高存款准备金率，会造成市场的钱变少，从而提高货币基金的收益率。</li><li>当股市、债市表现不好时候，往往货币基金表现较好（目前市场共有616支货币基金）。</li><li>平时买规模大（5亿元以上）的基金，收益比较稳定。在季度末、年底买规模较小（2亿~5亿）的基金博取高收益。</li></ul><h1 id="银行理财与货币基金"><a href="#银行理财与货币基金" class="headerlink" title="银行理财与货币基金"></a>银行理财与货币基金</h1><p>根据如下2017年的数据显示，理财产品的期限越长，予以的收益也越多。</p><ul><li>银行活期存款利息：一年0.35%</li><li>一年期定期存款：一年1.5%</li><li>三年期定期存款：每年2.75%</li></ul><p>通常，银行理财都是定期，且5万元起购，这与货币基金的差距较大。另一方面，货币基金的监管比银行理财更严格。网上也经常爆出银行理财的一些骗局，我们可以通过网上银行来进行真伪辨认。</p><h1 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h1><p>国债逆回购，本质就是一种短期贷款。也就是说，个人通过国债回购市场把自己的资金借出去，获得固定的利息收益；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p><p>投资者通过股票账户即可投资国债逆回购，国债逆回购具有以下几个基本特点：</p><ul><li><strong>国债逆回购的门槛</strong>：上证交易所，金额必须是10万的整数倍；深证交易所，金额必须是1000的整数倍。</li><li><strong>国债逆回购的价格</strong>：任何股票软件都可查询。</li><li><strong>国债逆回购的收益</strong>：价格、实际占款天数（1、2、3、7）。</li><li><strong>国债逆回购价格的规律</strong>：季度末、年末的利率较高。一般上午高于下午。</li></ul><h1 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h1><p>根据2006至2016的数据显示，债券基金平均每年的收益大约为7%。债券的本质是发行债券的机构向投资者借钱，债券基金的收益主要包含两部分：</p><ul><li>利息</li><li>债券的价格波动</li></ul><p>目前市场中的债券基金一共有1000多只。通常而言，债券基金和股票基金呈跷跷板效应，两者的表现是相反的。</p><p><strong>通常不建议自选债券基金进行投资</strong>，其知识门槛较高。此外，债券基金进行为期1~2年的投资。长期投资债券基金必然是赚钱的。</p><h2 id="债券涨跌原理"><a href="#债券涨跌原理" class="headerlink" title="债券涨跌原理"></a>债券涨跌原理</h2><p>在金融体系中钱多（收紧或加速流动性）的时候，债券就会上涨；反之，则下跌。</p><p>金融体系受两方面影响：</p><ul><li><strong>中央银行（中国人民银行，简称央行）货币政策</strong>：如加息降息</li><li><strong>影响金融机构买债的监管政策</strong></li></ul><p>央行主要有两个职能：控制物价（通货膨胀CPI）、维持经济增长（GDP增长率）。如果发生矛盾，以第一项为准。当CPI突破3%，表示通货膨胀过快，需要注意；GDP增长率较低时是投资债券的好时机。</p><h2 id="债券基金投资方法"><a href="#债券基金投资方法" class="headerlink" title="债券基金投资方法"></a>债券基金投资方法</h2><p>债券基金有一个指标——<strong>到期收益率</strong>，表示如果债券没有出现违约，每年的收益率。债券收益率越高，则债券的估值越低。如果在三年期AA+企业债到期收益率超过5%时，投资债券基金，则未来三年，每年收益率大约为8%~10%。</p><p>相关数据表明，长期投资债券基金，亏钱的概率极低。对于债券基金的投资有两个建议：</p><ul><li>债券基金的到期收益率越高，投资债券基金赚得越多</li><li>债券基金应该越跌越买</li></ul><h1 id="什么决定了股票的价格"><a href="#什么决定了股票的价格" class="headerlink" title="什么决定了股票的价格"></a>什么决定了股票的价格</h1><p>前面说到股票投资者的收益主要有两部分：<strong>分红</strong>、 <strong>股票价格的变化</strong>。那么股票的价格是由什么决定的呢？股票的价格可以通过如下公式进行计算：</p><blockquote><p><strong>股票的价格</strong> = <strong>盈利</strong>（每股的盈利） <em>  <em>*市盈率</em></em>（每股市价与每股盈利的比率）</p></blockquote><p>比如，某公司一年盈利1000万元，该公司有一亿股股票，则平均每股的盈利为0.1元。如果市盈率是10倍，即每1元的盈利能力是10元。通过公式计算得出，股票的价格为1元。</p><blockquote><p>1元（股票价格） = 0.1（每股的盈利）* 10（市盈率）</p></blockquote><p>因此，市盈率是衡量股票价格高低的重要指标。<strong>市盈率是由股票市场中所有的股票投资者决定的</strong>。在绝大多数情况下，投资者的情绪比较稳定，市盈率也比较稳定。在某些情况下，投资者的情绪会出现集体波动，在投资者投资情绪乐观时，市盈率偏高；投资情绪悲观时，市盈率偏低。</p><h2 id="如何投资股票"><a href="#如何投资股票" class="headerlink" title="如何投资股票"></a>如何投资股票</h2><p>首先需要评估市场的情绪，乐观、平稳还是悲观？因为投资者的情绪决定了市盈率。有两种评估方法：</p><ul><li><strong>定量分析</strong>：分析历史数据进行总结，对于沪深300指数，市盈率为12-14倍是合理的；对于中证500指数，市盈率为30-35倍是合理的。高于则是乐观，低于则是悲观。</li><li><strong>定性分析</strong>：观察财经媒体和大众市场的情绪。情绪乐观时会多买入，情绪悲观时会多卖出。比如：当很多不懂市场的投资者也在争相买入，则是非常乐观。</li></ul><p>在了解市场情绪之后，只需要做到三点：</p><ul><li>在市场情绪平稳时进行投资，但是不要把所有的前都投进去</li><li>在市场情绪悲观时，不仅自己不能恐慌，而应该鼓起勇气追加投资</li><li>在市场情绪乐观时，不应该追加投资，应该准备卖出</li></ul><h2 id="股票选择"><a href="#股票选择" class="headerlink" title="股票选择"></a>股票选择</h2><p>一般而言，优质、稳定的投资标的应该会产生持续、稳定的<strong>内生收益</strong>。公司的盈利、收益是内生收益的来源。股票投资最重要的收益来源就是内生收益。持续、稳定的内生收益会让投资标的有不断上涨的动力。但是在单只股票中寻找能够产生持续、稳定内生收益的股票非常难。</p><p>投资者可以通过市场表现来挑选股票，比如每半年对A股上市公司进行市值排名，只投资排名前300的公司。A股市场最常用的两个指数是：<strong>沪深300指数</strong>、<strong>中证500指数</strong>。前者包含A股中市值最大的前300家公司；后者包含市值排名第301至800的500家公司。一般排名靠前的大公司，内生收益比较低，稳定性较高，长期收益低。 相对而言，中证500指数包含的公司内生收益相对较高，稳定性一般。</p><h2 id="50AH优选"><a href="#50AH优选" class="headerlink" title="50AH优选"></a>50AH优选</h2><p><strong>上证50指数</strong>：表示上海证券交易所上市的市值最大的50家公司。<br><strong>50AH优选指数</strong>：看上证50指数中哪些公司在大陆和香港同时上市，挑选价格便宜的进行投资。</p><p>根据2015至2017年数据显示，50AH优选指数跑赢了上证50指数8个百分数。因此，投资者也可以根据50AH优选指数来进行股票选择</p><h1 id="基金的选择"><a href="#基金的选择" class="headerlink" title="基金的选择"></a>基金的选择</h1><p>目前市场中共有3485只基金，其从投资标的上来分可分为三种：</p><ul><li><strong>货币基金</strong></li><li><strong>债券基金</strong></li><li><strong>股票基金</strong>：变数最大，主要是对比业绩基准。</li></ul><p>根据管理方式来分类，基金可以分为两类：</p><ul><li><strong>被动管理型基金</strong>（指数基金）：其跟随沪深300指数。管理费较低，每年0.7%。 </li><li><strong>主动管理型基金</strong>：想尽一切办法打败业绩基准。研究员使用数据模型定量分析，管理费相对较高，每年1.5%。</li></ul><p>国外一个惊人的理论：绝大多数主动管理型基金很难跑过大盘指数。然而，在中国则截然相反，这是因为美国绝大部分的投资者是投资机构。中国股市有大量的散户，投资机构很容易跑赢散户。在中国，主动型管理基金更好。港股和美股则相反。在中国，股票基金平均收益率约为20%，沪深300每年约为10%。</p><h1 id="如何选择基金"><a href="#如何选择基金" class="headerlink" title="如何选择基金"></a>如何选择基金</h1><p>股票基金的收益有两个来源：</p><ul><li>对标的股票指数的股票收益</li><li>股票基金跑赢股票指数的跑赢收益，即<strong>跑赢收益</strong>。跑赢收益是真正衡量基金经理能力的指标。</li></ul><p>选择基金的完整流程：</p><ul><li>第一步，选择未来会上涨的股票指数。只要股票指数的市盈率处于合理或偏低的水平，都可以选择。</li><li>第二步，在所有以这个股票指数为业绩基准，即对标的股票指数的股票基金里，选择跑赢收益比较高，且稳定性比较好的股票基金。量化基金的跑赢收益更低，稳定性更好。传统基金的跑赢收益更好，稳定性更差。</li><li>第三步，研究基金的策略，判断基金收益是否可持续。比如：通过基金经理访谈。</li></ul><h1 id="股票基金收益来源的“终极”公式"><a href="#股票基金收益来源的“终极”公式" class="headerlink" title="股票基金收益来源的“终极”公式"></a>股票基金收益来源的“终极”公式</h1><blockquote><p><strong>股票基金的收益</strong> = <strong>对标股票指数的收益</strong> + <strong>跑赢收益</strong></p></blockquote><p><strong>股票指数</strong>是由若干股票组成，可以用于分析股票。每只股票都是一个公司的代表，绝大部分长期来说，其价值在不断提升。通常使用<strong>内生收益</strong>表示股票价值提升带来的收益。但是有内生收益不一定会带来投资收益。</p><p>股票价格的终极计算公式为，其中内生收益代表盈利的上升速度，长期来说内生收益都是正的。</p><blockquote><p><strong>股票价格</strong> = <strong>盈利</strong> <em> <em>*市盈率</em></em> </p></blockquote><p>那么应该如何确定内生收益？沪深300指数的内生收益和名义GDP增速差不多，稍微高一点。名义GDP和统计局公布的GDP不是一回事，后者是实际GDP增速，前者在实际GDP增速的基础上加上物价增速（即CPI）。名义GDP更多的体现实际的经济发展，更适合描述企业收入和盈利的增长速度。中国的GDP大概维持在6-7%，CPI大概在2%，所以名义GDP大概维持在8-9%。因此，沪深300指数的内生收益大约8-9%（非客观）。</p><p>另一方面，市盈率会围绕着合理水平波动。投资者给出的价格水平，乐观时比较高，悲观时比较低。当市盈率回归到合理水平的过程中，产生的收益叫<strong>储备收益</strong>。因此，可以得到股票指数的收益的公式。</p><blockquote><p><strong>股票指数的收益</strong> = <strong>内生收益</strong> + <strong>储备收益</strong></p></blockquote><p>进一步得出股票基金的收益公式：</p><blockquote><p><strong>股票基金的收益</strong> = <strong>内生收益</strong>（经济发展） + <strong>储备收益</strong>（投资者心理波动） + 跑赢收益（基金经理的能力）</p></blockquote><h1 id="定投"><a href="#定投" class="headerlink" title="定投"></a>定投</h1><p>定投：表示定期、定额地投资某一个理财产品的投资方式。这是一种兼顾省心、高收益的投资方式。其适用于长期投资。例如：每个月买1000元的公募基金。</p><p>定投为何会赚钱？这是定投可以大幅降低投资风险，只要坚持就能赚钱。定投期间如果基金曲线呈现微笑曲线，则必然是赚钱的，即<strong>定投第一定理</strong>。</p><p>定投是一种守株待兔的方式，经济是由周期的，只要耐心定投，就肯定能赚钱。</p><h2 id="定投开始时机"><a href="#定投开始时机" class="headerlink" title="定投开始时机"></a>定投开始时机</h2><p>在低于市盈率合理值时投资。在沪深300市盈率14倍或中证500市盈率35倍以下可以投。</p><h2 id="定投结束时机"><a href="#定投结束时机" class="headerlink" title="定投结束时机"></a>定投结束时机</h2><p>3个原则：</p><ul><li>定投还没开始赚钱，永远不要考虑结束</li><li>只要股市估值还没有达到正常水平以上，就不要考虑退出。</li><li>当股市估值回到正常水平以上，应该跟随市场不断变化、计划卖出的点位，即止盈点。比如，当这轮行情市盈率跌倒最高点10%以下，止盈。</li></ul><h2 id="一个真实的定投案例"><a href="#一个真实的定投案例" class="headerlink" title="一个真实的定投案例"></a>一个真实的定投案例</h2><p>3-5年长期的准备，定投。<br>2011年开始，定投沪深300指数4年，总收益80%，平均每年收益15.2%。 分为七个阶段</p><ul><li>2011年4月开始定投到A点，截止2011年12月27日累计亏损19%。从2011年4月开始，中国经济增长率从每年10%下调至8%。同时CPI很高，在2011年年终，达到了6%以上。央行通过加息来降低CPI。沪深300指数从2011年4月的3400点一路跌到年底的2300点，跌幅达到32%。</li><li>A点到B点，截止2012年5月累计盈利0.1%。从2011年底到2012年5月，沪深300指数从2300点反弹到2700点，赚0.1%。</li><li>B点到C点，截止2012年12月累计亏损17.5%。从2012年5月到2012年12月，沪深300指数开启长达8个月的下跌。从2700点跌至2100点，跌幅达到22%。创出了3年新低。</li><li>C点到D点，两年累计盈利8.7%。2012年12月5日的大涨，开启了一波小牛市。沪深300指数用了两个月一口气从2100点涨到了2800点附近，涨幅达到33%。</li><li>D点到E点，累计亏8.5%。2013年2月之后，沪深300指数开始调整，2013年6月开始从2600到2300，跌幅达到22%。2014年7月底，市盈率只有8.2倍，储备收益高达70%。</li><li>F点到完美结局，累计大赚80%。2014年7月到2015年6月，沪深300指数从2200点一路上涨到5380点，上涨幅度达到145%。</li></ul><p>定投总共4年2个月中，有3年3个月是处于亏损状态。是否掌握一定的定投知识将决定成败。经济每五年一个周期，对应到股市就是每5年一个大牛市。定投就是抓住这5年一次的牛市。定投很有可能三年不开张，开张顶三年！</p><h1 id="如何做投资决策"><a href="#如何做投资决策" class="headerlink" title="如何做投资决策"></a>如何做投资决策</h1><p>做投资决策前需要做到以下几点：</p><ul><li>分析一笔钱可能出现的结果有哪几类？</li><li>对每一种结果评估概率</li><li>对每一种结果给出一种应对措施<ul><li>如果赚钱了是否止盈，什么时候止盈</li><li>如果亏钱了是否止损，什么时候止损</li><li>如果赚钱了是否追加投资，什么时候</li><li>如果亏钱了是否追加投资，什么时候</li></ul></li></ul><p>在投资前思考风险可以让我们在投资过程中保持良好的心态。另外，还需要评估好投资周期、盈亏幅度。</p><p>关于如何控制风险？这里也有两种参考方式：</p><ul><li>选择一条移动平均线，一旦大盘跌破这条线就止损。根据历史数据显示，60天移动平均线是最优化的选择。</li><li>设定一个自己愿意接受的亏损比例，如10%。每天记录总资产额。当某天的总资产额比最高总资产额低10%时，可以止损了。</li></ul><h1 id="关于投资笔记"><a href="#关于投资笔记" class="headerlink" title="关于投资笔记"></a>关于投资笔记</h1><p>投资笔记是执行投资、学习投资过程中一个非常重要且有意义的方式。投资笔记有以下优点：</p><ul><li>投资笔记可以帮我们指定投资决策，包括分析过程，思考逻辑，决策分析。投资是不能随机应变的。这是因为，一方面，投资相对比较复杂，需要实现做好预案。另一方面，投资是逆直觉，逆决策的。</li><li>投资笔记可以更好地帮助我们复盘。比如在投资过程中哪些地方做对了，结果及其原因又是什么。通过投资笔记，可以对每一个节点的行为逻辑和心态，复盘结果，更重要的是原因。</li><li>投资笔记可以帮助我们获得更多的知识。</li></ul><h1 id="投资时需要掌握的重要数据"><a href="#投资时需要掌握的重要数据" class="headerlink" title="投资时需要掌握的重要数据"></a>投资时需要掌握的重要数据</h1><p>投资标的一定是不停生长出价值的投资标的。</p><ul><li><strong>经济增长率</strong>：经济增长率分为两种：<strong>季度增长率</strong>、<strong>年度增长率</strong>。GDP同比前一年同期增长多少。绝对值。增长率。实现国家经济调控的部门是央行，其主要有两个职责：<strong>控制物价</strong>、<strong>促进经济增长</strong>。当两者冲突时，往往以第一个为主。物价增长率（CPI），中文学名：通货膨胀率。和GDP不同，CPI是每个月都公布的。<strong>如何解读CPI数据：在中国如果CPI达到3%以上，说明物价增长过快了。这时候央行会通过加息，提高存款准备金率等方法来收紧货币。如果CPI跌倒了1%以下，说明物价增长过慢，意味着经济比较低迷，这时候央行会通过降息、降低存款金率等手段来刺激经济。如果CPI处于1~3%为健康状态，央行一般不会进行干涉</strong>。<strong>GDP在6.5%是合适的；CPI在1-3%是合适的。经济增长率的数据由国家统计局公布，www.stats.gov.cn</strong>。GDP和CPI能够勾勒出四个不同的经济周期，见下文。</li></ul><p>股票、债券方面的数据。</p><p>关于股票，A股共有3000多支股票，关注股票指数就够了，包括：<strong>上证50</strong>（超大规模）、<strong>沪深300</strong>（大规模）、<strong>中证500</strong>（中小规模）。平时需要关注着三个指数的盈利增长率和估值水平</p><ul><li><strong>估值水平</strong>：对于估值水平的描述一般用市盈率这个指标，<strong>对于上证50（10-12倍是合理的），对于沪深300（12-15倍是合理的），对于中证500（30-35倍是合理的）</strong>。如果低于，越跌越买；如果处理合理区间，继续持有；如果高于，原则上是不能追加，应该持有+设置好止盈条件等策略。</li><li><strong>盈利增长率</strong>：必须等每个季度上司公司的财报都公布了以后才知道。与GDP类似，盈利增长的趋势比绝对值更加重要。如果盈利增长在减速，股市的增长水平（市盈率水平）就会下降。如果盈利增长在加速，市盈率就会上升。由于关注的是指数的盈利增长，而这些指数包含的公司都是整个经济体系中的中流砥柱，因此可以用GDP的增长趋势来估计指数盈利增长的趋势。</li></ul><blockquote><p>估值水平：每周六公众号公布；盈利增长率：可以用GDP估算。</p></blockquote><p>债券</p><ul><li><strong>到期收益率</strong>：如果持有债券到期，并且借钱的机构没有耍赖不还钱的情况，投资者平均每年能赚百分之多少。不同期限，不同评级的债券的到期收益率都不一样。一般来说，关注三年期，AA+的企业债券的到期收益率就够了。只要这个数据高于5%，投资债券基金都是比较安全的，未来1-2年的收益也是比较可观的。</li></ul><h1 id="美林团队判断经济周期转折点的重点理论"><a href="#美林团队判断经济周期转折点的重点理论" class="headerlink" title="美林团队判断经济周期转折点的重点理论"></a>美林团队判断经济周期转折点的重点理论</h1><p><strong>美林时钟理论</strong>：只用经济增长率（GDP增速）和通货膨胀率（CPI增速）两个宏观经济指标来描述复杂的经济周期。</p><p>运用美林时钟理论，在2006年至2016年，通过资产配置获得11.5倍的收益。全国房价平均每年的年化收益率只有8%。北京的房价平均每年的年化收益率15%。之所以房子赚钱，是因为房价稳定，愿意长期持，复利使得房子显得很赚钱。数据显示，资产配置如果做好了，可以比投资房产更赚钱。</p><p>美林时钟理论用到两个宏观经济指标：<strong>GDP增长率</strong>（描述经济增长速度），<strong>CPI增长率</strong>（描述通货膨胀速度）</p><ul><li><strong>GDP增长率高、CPI增长率低：复苏期</strong></li><li><strong>GDP增长率高、CPI增长率高：过热期</strong></li><li><strong>GDP增长率低、CPI增长率高：滞障期</strong></li><li><strong>GDP增长率低、CPI增长率低：衰退期</strong></li></ul><p><strong>1 -&gt; 2 -&gt; 3 -&gt; 4：美林时钟</strong></p><blockquote><p>复苏期：重仓股票基金（下一周期GDP仍高）。债券的表现不会差（一时半会不会加息，持有债券去赚利息），应该紧盯通胀，高通货膨胀来了应该减仓。</p><p>过热期：中国股市会快速、甚至疯狂上涨。股票继续持有。不应该持有债券基金。关注熊市出现。</p><p>滞涨期：股票基金表现不会，不应该持有。债券不太好。这个时期的目标是不亏钱。应该投资货币基金。</p><p>衰退期：其末期是特别好的抄底机会。重仓持有债券基金。密切关注股票基金。关注股票基金减仓机会。</p></blockquote><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几个月前，在脉脉上订阅了一个付费的音频课程——《徐彬说投资》。课程每天更新（工作日），共48节。虽然课程内容的连贯性不是非常强，但是对于非专业人士来说，这是一个非常好的理财入门课程。以下内容是我在听完该课程后做的一些笔记和总结。原始笔记&lt;a href=&quot;https://no
      
    
    </summary>
    
      <category term="投资理财" scheme="http://chuquan.me/categories/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="投资" scheme="http://chuquan.me/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="理财" scheme="http://chuquan.me/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
</feed>
