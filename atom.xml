<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="http://chuquan.me/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2024-07-21T05:35:55.915Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识人工神经网络工作原理</title>
    <link href="http://chuquan.me/2024/07/21/neural-network-introduce/"/>
    <id>http://chuquan.me/2024/07/21/neural-network-introduce/</id>
    <published>2024-07-21T05:30:55.000Z</published>
    <updated>2024-07-21T05:35:55.915Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了《Python神经网络编程》一书之后，对于神经网络的工作原理有了一个初步的理解，于是产出此篇文章作为系统性的梳理和总结。</p><span id="more"></span><h1 id="概述">概述</h1><p>计算机设计的初衷是为了解决大量的数学运算，因此适用于解决具有固定模式或计算步骤的问题。对于不具备固定模式或计算步骤的问题，比如图像识别、语音识别等，传统的计算机程序很难有效地予以解决。</p><p>人工智能的重要研究方向之一就是通过计算机来解决这类相对困难的问题。机器学习便是人工智能领域中的一个重要分支，而人工神经网络则是机器学习中一种被广泛使用的算法。</p><h1 id="分类器">分类器</h1><p>为了能够理解神经网络的核心思想，我们先来介绍一个分类器的例子。</p><p>假如花园中有两种虫子：毛虫细而长，瓢虫宽而短。我们希望设计一个分类器，当给定一个虫子的长度和宽度，分类器能够自动进行分类。</p><h2 id="设计分析">设计分析</h2><p>我们考虑对虫子的长度和宽度进行分析，绘制一个二维坐标系，可以发现两种虫子是存在一定的聚类特征的，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-01.png?x-oss-process=image/resize,w_800" /></p><p>因此，分类器的设计目标就是通过数据训练进行学习，从而找到一条分界线，将两种类型的虫子进行有效分类。如下所示，在训练阶段，分界线会不断地进行修正，最终到达一个相对正确的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-02.png?x-oss-process=image/resize,w_800" /></p><p>分类器最终结构如下所示，它有一个输入和一个输出，通过分类器实现内部分类逻辑，最终输出分类结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="样本训练">样本训练</h2><p>那么分类器该如何通过数据训练来调整分界线的斜率呢？首先，我们需要定义一个用于表示分界线的函数（或称测试函数），如下所示。</p><span class="math display">\[\begin{aligned}y = Ax\end{aligned}\]</span><p>然后，我们随机初始化 <span class="math inline">\(A\)</span>的值，假设初始化值为 <code>0.25</code>，那么将得到如下所示的直线 <spanclass="math inline">\(y = 0.25x\)</span>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-03.png?x-oss-process=image/resize,w_800" /></p><p>接下来，我们开始输入训练样本，如下所示。当输入两个虫子的样本数据后，我们发现分界线并没有正确对虫子进行有效分类。此时，我们需要对斜率进行调整，这也是训练的核心目标。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-04.png?x-oss-process=image/resize,w_800" /></p><p>我们观察第一个训练样本数据：宽度 3.0，长度 1.0，瓢虫。我们将 <spanclass="math inline">\(x = 3.0\)</span> 代入函数 <spanclass="math inline">\(y = Ax\)</span>，得到 <spanclass="math inline">\(y = 0.25 * 3.0 =0.75\)</span>。然而，样本数据告诉我们 <span class="math inline">\(y =1.0\)</span>，此时我们看到了误差的存在。值得注意的是，分界线是为了对实现分类，我们需要让<span class="math inline">\(x\)</span> 代入函数后得到的 <spanclass="math inline">\(y\)</span> 值大于 <spanclass="math inline">\(1.0\)</span>。为了避免调整过大，我们将 <spanclass="math inline">\(y\)</span> 的目标值设置为 <spanclass="math inline">\(1.1\)</span>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-05.png?x-oss-process=image/resize,w_800" /></p><p>由此，我们计算输出值和目标值之间的误差，基于此计算出调整的斜率差值。下图显示了初始分界线和一次训练后的分界线。</p><span class="math display">\[\begin{aligned}实际值: &amp; y = Ax = 0.25 * 3.0 = 0.75\\目标值: &amp; t = (A + \Delta A)x = 1.1\\误差值: &amp; E = t - y = (\Delta A)x = 1.1 - 0.75 = 0.35\\斜率差值: &amp; \Delta A = E / x = 0.35 / 3.0 = 0.1167\\斜率修正值: &amp; (A + \Delta A) = 0.25 + 0.1167 = 0.3667\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-06.png?x-oss-process=image/resize,w_800" /></p><p>然后，我们再观察第二个训练样本数据：宽度 1.0，长度3.0，毛虫。采用类似的方法，我们可以计算出调整后的斜率为 <spanclass="math inline">\(2.9\)</span>。下图显示了初始分界线和两次训练后的分界线。</p><span class="math display">\[\begin{aligned}实际值: &amp; y = Ax = 0.3667 * 1.0 = 0.3667\\目标值: &amp; t = (A + \Delta A)x = 2.9\\误差值: &amp; E = t - y = (\Delta A)x = 2.9 - 0.3667 = 2.5333\\斜率差值: &amp; \Delta A = E / x = 2.5333 / 1.0 = 2.5333\\斜率修正值: &amp; (A + \Delta A) = 0.3667 + 2.5333 = 2.9\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-07.png?x-oss-process=image/resize,w_800" /></p><h2 id="适度改进">适度改进</h2><p>如果我们仔细观测两次训练，会发现最终改进的直线与最后一次训练样本非常匹配。这种方式实际上抛弃了所有先前训练样本的学习结果，只对最后一次训练样本进行了学习。</p><p>那么如何解决这个问题呢？一个重要的思路就是<strong>适度改进（Moderate）</strong>。</p><p>我们可以在改进公式中增加一个调节系数 <spanclass="math inline">\(L\)</span> ，也称为 <strong>学习率（LearningRate）</strong>，如下所示。</p><span class="math display">\[\begin{aligned}\Delta A = L (E / x)\end{aligned}\]</span><p>基于新的调整公式，设定学习率 <span class="math inline">\(L =0.5\)</span>，我们再来计算一下斜率的改进过程。</p><span class="math display">\[\begin{aligned}第一次训练: &amp;\\实际值: &amp; y = Ax = 0.25 * 3.0 = 0.75\\目标值: &amp; t = (A + \Delta A)x = 1.1\\误差值: &amp; E = t - y = (\Delta A)x = 1.1 - 0.75 = 0.35\\斜率差值: &amp; \Delta A = L (E / x) = 0.5 * 0.35 / 3.0 = 0.0583\\斜率修正值: &amp; (A + \Delta A) = 0.25 + 0.0583 = 0.3083\\\\第二次训练: &amp;\\实际值: &amp; y = Ax = 0.3083 * 1.0 = 0.3083\\目标值: &amp; t = (A + \Delta A)x = 2.9\\误差值: &amp; E = t - y = (\Delta A)x = 2.9 - 0.3083 = 2.5917\\斜率差值: &amp; \Delta A = L (E / x) = 0.5 * 2.5917 / 1.0 = 1.2958\\斜率修正值: &amp; (A + \Delta A) = 0.3083 + 1.2958 = 1.6042\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-08.png?x-oss-process=image/resize,w_800" /></p><h2 id="分类器组合">分类器组合</h2><p>上述，我们介绍了单一分类器通过训练样本进行学习调整相关参数，最终可用于解决特定问题。</p><p>然而，现实中很多问题并不是一个分类器能够解决的，比如：如何在网格节点中输出逻辑异或（XOR）的值？</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-09.png?x-oss-process=image/resize,w_800" /></p><p>此时，我们无论如何都无法通过一条分界线来正确进行分类。于是，我们开始考虑采用多个分类器进行组合，共同完成对复杂问题的求解，这就是神经网络的基本思想。</p><h1 id="神经网络">神经网络</h1><p>人工神经网络（Artificial NeuralNetwork，ANN，简称神经网络），其设计思想借鉴了动物大脑的生物神经网络，构建了一套类似神经元互连的分层组织结构。</p><h2 id="神经元">神经元</h2><p>无论是人工神经网路，还是生物神经网络，神经元都是其中的基本组成单元，两中神经元的结构也基本差不多。</p><h3 id="生物神经元">生物神经元</h3><p>如下图所示，生物神经元主要包含三部分：</p><ul><li>树突：用于接收外部电信号</li><li>轴突：用于传导电信号</li><li>突触：用于将电信号传递至其他神经元或细胞</li></ul><p>此外，神经元还会通过阈值（threshold）抑制输入，直到电信号超出阈值，才会触发输入。因为神经元不希望传递各种微小的噪音信号，而只传递有意识的明显信号。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-13.png?x-oss-process=image/resize,w_800" /></p><h3 id="人工神经元">人工神经元</h3><p>如下图所示，人工神经元主要包含三个部分：</p><ul><li>输入：类似于树突，可以包含一个或多个输入端，用于接收外部信号</li><li>输出：类似于轴突和突触，用于传递和输出信号</li><li>节点：类似于细胞核，用于处理信号。本质上是两个函数，分别是：<ul><li>求和函数：对所有输入进行求和</li><li>激活函数：或称阈值函数，用于过滤噪音信号，类似于生物神经元中抑制噪音电信号。</li></ul></li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-12.png?x-oss-process=image/resize,w_800" /></p><p>对于激活函数，一个简单的阶跃函数即可实现类似的效果。但是为了更接近自然的效果，这里采用一种平滑且经典的Sigmoid 函数（简称 S函数）作为激活函数，其函数表达式如下所示。除此之外，神经网络中常用的激活函数还有很多，比如：双曲正切函数（HyperbolicTangent）、ReLU函数（Rectified Linear Unit）、LeakyReLU函数、ELU函数（Exponential Linear Unit）、SELU（Scaled ExponentialLinear Unit）、Softmax 等等，有兴趣的朋友可以自行了解。</p><span class="math display">\[\begin{aligned}y = \frac{1}{1+e^{-x}}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-16.png?x-oss-process=image/resize,w_800" /></p><h2 id="基本结构">基本结构</h2><p>通过构建多层神经元，每一层中的神经元都与在其前后层中的所有神经元相互连接，即可得到一个分层的人工神经网络。</p><p>根据分层所在的位置，我们将分层分为三种类型：输入层、隐藏层、输出层。任意一个神经网络的输入层和输出层各自只有一个，隐藏层可以有多个。下图所示是一个三层结构的神经网络，可以看到每个节点都与前一层或后一层的其他每个节点相互连接。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-14.png?x-oss-process=image/resize,w_800" /></p><p>基于训练样本，神经网络会进行学习，那么它有没有可以调整的参数呢？类似上文介绍的分类器，我们可以调整斜率参数。在神经网络中，则是<strong>通过调整节点之间的连接强度作为训练样本的学习反馈</strong>。</p><p>下图所示展示了节点之间各个连接的连接强度，使用<strong>权重</strong>（Weight）表示，比如：<spanclass="math inline">\(w_{1,2}\)</span> 表示当前层节点 1 与后一层节点 2之间的连接强度。通常权重值的范围位于 <span class="math inline">\([0,1]\)</span> 之间，当权重值为 0 时，则表示连接断开。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-15.png?x-oss-process=image/resize,w_800" /></p><h1 id="信号转换">信号转换</h1><p>了解了神经网络的基本结构之后，我们来介绍一下输入信号是如何在神经网络中经过一层一层的神经元，最终转换成输出信号的。在这个过程中，我们会结合矩阵运算来进行表达。</p><p>下图所示是一个具有 3 个分层，每个分层 3个节点的神经网络，为了保持图示清晰，我们没有标注所有权重。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-17.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们来依次看一下输入层、隐藏层、输出层对于信号的转换和处理。</p><h2 id="输入层">输入层</h2><p>在人工神经网络中，输入层的节点通常不会进行求和函数和激活函数的处理。输入层的节点主要负责接收原始的输入信号，并将其直接透传给下一层的隐藏层或输出层。</p><p>对于输入层，我们可以使用矩阵 <spanclass="math inline">\(I_{input}\)</span> 来表示输入信号，使用矩阵 <spanclass="math inline">\(O_{input}\)</span>表示输出信号。由此得到如下所示表示：</p><span class="math display">\[\begin{aligned}O_{input} = I_{input} =\left(\begin{matrix}0.9\\0.1\\0.8\end{matrix}\right)\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-18.png?x-oss-process=image/resize,w_800" /></p><h2 id="隐藏层">隐藏层</h2><p>对于隐藏层，我们可以使用矩阵 <spanclass="math inline">\(W_{input\_hidden}\)</span>来表示输入层与隐藏层之间的连接权重，如下所示：</p><span class="math display">\[\begin{aligned}W_{input\_hidden} =\left(\begin{matrix}0.9 &amp; 0.3 &amp; 0.4\\0.2 &amp; 0.8 &amp; 0.2\\0.1 &amp; 0.5 &amp; 0.6\end{matrix}\right)\end{aligned}\]</span><p>隐藏层神经元节点接收输入信号后，会依次使用求和函数、激活函数进行处理，然后进行输出。关于求和函数，我们可以使用矩阵点乘来表示，这里使用<span class="math inline">\(X_{hidden}\)</span>来表示隐藏层求和函数的计算结果。</p><span class="math display">\[\begin{aligned}X_{hidden} = &amp; W_{input\_hidden} \cdot O_{input}\\= &amp;\left(\begin{matrix}0.9 &amp; 0.3 &amp; 0.4\\0.2 &amp; 0.8 &amp; 0.2\\0.1 &amp; 0.5 &amp; 0.6\end{matrix}\right)\cdot\left(\begin{matrix}0.9\\0.1\\0.8\end{matrix}\right)\\= &amp;\left(\begin{matrix}1.16\\0.42\\0.62\end{matrix}\right)\end{aligned}\]</span><p>关于激活函数，我们使用 <span class="math inline">\(sigmoid\)</span>来表示，隐藏层的最终输出仍然可以矩阵来表示，这里使用 <spanclass="math inline">\(O_{hidden}\)</span> 表示隐藏层的最终输出。</p><span class="math display">\[\begin{aligned}O_{hidden} = &amp; sigmoid \left( X_{hidden} \right)\\= &amp;sigmoid\left(\begin{matrix}1.16\\0.42\\0.62\end{matrix}\right)\\= &amp;\left(\begin{matrix}0.761\\0.603\\0.650\end{matrix}\right)\end{aligned}\]</span><p>由此我们得到隐藏层的输出信号，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-19.png?x-oss-process=image/resize,w_800" /></p><h2 id="输出层">输出层</h2><p>输出层对于信号的转换和处理，本质上和隐藏层没有任何区别，计算的方法和流程是一样的。</p><p>我们使用 <span class="math inline">\(W_{hidden\_output}\)</span>表示隐藏层与输出层之间的连接权重，结合隐藏层的输出 <spanclass="math inline">\(O_{hidden}\)</span>，通过矩阵点乘来运用求和函数，得到<span class="math inline">\(X_{output}\)</span>，如下所示。</p><span class="math display">\[\begin{aligned}X_{output} = &amp; W_{hidden\_output} \cdot O_{hidden}\\= &amp;\left(\begin{matrix}0.3 &amp; 0.7 &amp; 0.5\\0.6 &amp; 0.5 &amp; 0.2\\0.8 &amp; 0.1 &amp; 0.9\end{matrix}\right)\cdot\left(\begin{matrix}0.761\\0.603\\0.650\end{matrix}\right)\\= &amp;\left(\begin{matrix}0.975\\0.888\\1.254\end{matrix}\right)\end{aligned}\]</span><p>最后再应用激活函数，得到输出层的结果 <spanclass="math inline">\(O_{output}\)</span> ，如下所示。</p><span class="math display">\[\begin{aligned}O_{output} = &amp; sigmoid \left( X_{output} \right)\\= &amp;sigmoid\left(\begin{matrix}0.975\\0.888\\1.254\end{matrix}\right)\\= &amp;\left(\begin{matrix}0.726\\0.708\\0.778\end{matrix}\right)\end{aligned}\]</span><p>由此我们得到输出层的输出信号，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-20.png?x-oss-process=image/resize,w_800" /></p><h1 id="训练反馈">训练反馈</h1><p>在实际应用神经网络之前，我们必须使用大量训练样本对其进行训练，训练的核心目的是<strong>调整各节点之间链接权重的值</strong>，使其调整为合适的值，从而让神经网络能够输出相对准确的结果。</p><h2 id="值的约束">值的约束</h2><p>首先我们来看下神经网络中的值，其主要包含四种：目标值、输入值、输出值、权重值。这些值的范围与神经网络运行和训练密切相关，下面我们分别来了解一下。</p><h3 id="输出值-目标值">输出值 &amp; 目标值</h3><p>输出值的范围与激活函数有关。下图所示是 Sigmoid激活函数的曲线图，其输出值的范围为 <span class="math inline">\((0,1)\)</span>。训练样本的目标值的范围也应该与输出值的范围一样；否则，神经网络会驱使更大（或更小）的权重，导致学习能力过犹不足。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-22.png?x-oss-process=image/resize,w_800" /></p><h3 id="输入值">输入值</h3><p>类似输出值，输入值范围也与激活函数有关。对于 sigmoid函数，当输入值超出某个范围之后，输出值会变得非常平坦，换句话说就是梯度（斜率）差异很小，从而会导致学习能力降低。</p><p>很显然，梯度变化适中的区域更适合用于神经网络的训练，如下图所示，输入值的范围在<span class="math inline">\([-1, 1]\)</span>之内的激活函数梯度变化适中。不过，我们要注意输入值为 0的情况，此时结合任意权重值后，信号都会变成 0，权重更新表达式也会变成0，从而导致学习能力丧失（后续权重更新中会详细进行介绍）。因此我们要避免输入值等于0，一般建议将输入值的范围设置为 <span class="math inline">\((0,1]\)</span>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-21.png?x-oss-process=image/resize,w_800" /></p><h3 id="权重值">权重值</h3><p>根据前面的介绍，我们知道权重值会影响求和函数的结果，并最终作为激活函数的输入。因此，初始权重值同样也会影响神经网络的学习能力，过大（或过小）的初始值会造成过大（或过小）的信号传递给激活函数，导致神经网络饱和，从而降低神经网络学习更好权重的能力。</p><p>如下所示，是我们认为 sigmoid激活函数的梯度适中的区域。对此，我们也可以简单地将权重的初始值范围设置为<span class="math inline">\([-1, 1]\)</span>，并随机均匀进行取值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-23.png?x-oss-process=image/resize,w_800" /></p><p>当然，我们还有更好的权重值初始化方案。对此，我们回顾一下求和函数的输入和输出。一个神经元节点的求和函数输出等于与之相连的前一层所有节点的输出的加权求和。因此我们应该根据输出值的范围逆向推导各个连接的权重值，很显然，这与每个节点的连接的节点数量有关。对此，数学家提出了一种基于经验法则的权重初始化方案，即<strong>在一个节点传入连接数量平方根倒数的大致范围内随机采样，作为权重初始值</strong>。比如，每个节点具有100 条输入连接，那么权重的范围应该在 <spanclass="math inline">\([-1/\sqrt{100}, 1/\sqrt{100}]\)</span> 之间，即<span class="math inline">\([-0.1, 0.1]\)</span> 之间。</p><p>从直觉上讲，这种方案是有意义的。一个节点的输入连接越多，就会有越多的信号叠加在一起。因此，如果连接更多，那么减小权重的范围是有道理的。</p><p>当然，这种优化方案还定义了权重初始值应该遵循正泰分布，下图总结了这种基于正态分布的权重初始化方案。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-24.png?x-oss-process=image/resize,w_800" /></p><h2 id="误差分割">误差分割</h2><p>神经网络是基于训练样本的目标值与实际运行的输出值之间的误差来进行反馈学习，从而调整各个连接的权重。然而，每个节点可能有多个输入连接，每个连接有各自的权重值。为了合理分配误差值，神经网络会根据连接的权重来进行分割误差。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-25.png?x-oss-process=image/resize,w_800" /></p><h2 id="误差传播">误差传播</h2><p>了解了误差分割后，我们再来看看神经网络是如何传播误差的。</p><h3 id="输出层-1">输出层</h3><p>我们先来看输出层的误差传播。下图展示了一个具有 2 个输入节点和 2个输出节点的神经网络。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-26.png?x-oss-process=image/resize,w_800" /></p><p>对于输出层节点 1，我们定义其实际输出值为 <spanclass="math inline">\(o_1\)</span>，目标输出值为 <spanclass="math inline">\(t_1\)</span>，那么由此可计算得出误差值 <spanclass="math inline">\(e_1 = (t_1 -o_1)\)</span>。然后我们可以按照连接权重来分割误差，很显然，<spanclass="math inline">\(e_1\)</span> 和 <spanclass="math inline">\(e_2\)</span> 的误差传播组成如下所示。</p><span class="math display">\[\begin{aligned}e_1 = e_1 \frac{w_{1,1}}{w_{1,1} + w_{2,1}} + e_1 \frac{w_{2,1}}{w_{1,1}+ w_{2,1}}\\\\e_2 = e_2 \frac{w_{1,2}}{w_{1,2} + w_{2,2}} + e_2 \frac{w_{2,2}}{w_{1,2}+ w_{2,2}}\end{aligned}\]</span><h3 id="隐藏层-1">隐藏层</h3><p>我们再来看隐藏层的误差传播。下图展示了一个包含输入层、隐藏层、输出层的3 层神经网络。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-27.png?x-oss-process=image/resize,w_800" /></p><p>对于隐藏层的各个节点，它们并没有所谓的目标值，因此无法直接计算其误差。对此，我们可以通过将输出层的误差进行反向传播，层层传递。</p><p>首先，我们根据输出层的误差传播可以计算等到输出层前置连接 <spanclass="math inline">\(w_{1,1}\)</span>、<spanclass="math inline">\(w_{1,2}\)</span>、<spanclass="math inline">\(w_{2,1}\)</span>、<spanclass="math inline">\(w_{2,2}\)</span>各自的误差分量，然后即可计算得到隐藏层节点的误差值 <spanclass="math inline">\(e_1\)</span>、<spanclass="math inline">\(e_2\)</span>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-28.png?x-oss-process=image/resize,w_800" /></p><p>由此方法继续计算，可以进一步得出隐层层前置连接各自的误差分量，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-29.png?x-oss-process=image/resize,w_800" /></p><h3 id="矩阵运算">矩阵运算</h3><p>对于各个层的误差值的计算，我们同样可以使用矩阵来表示。我们使用 <spanclass="math inline">\(error_{output}\)</span> 来表示输出层误差，使用<span class="math inline">\(error_{hidden}\)</span>来表示隐藏层误差，其表示如下。</p><span class="math display">\[\begin{aligned}error_{output} = &amp;\left(\begin{matrix}e_1\\e_2\end{matrix}\right)\\\\error_{hidden} = &amp;\left(\begin{matrix}w_{1,1} &amp; w_{1,2}\\w_{2,1} &amp; w_{2,2}\end{matrix}\right)\cdot\left(\begin{matrix}e_1\\e_2\end{matrix}\right)\end{aligned}\]</span><p>对比之前的权重矩阵 <spanclass="math inline">\(W_{hidden_output}\)</span>，可以发现这里的矩阵其实就是<span class="math inline">\(W_{hidden_output}\)</span>的转置矩阵，因此我们可以将表示式进一步转换成如下所示。</p><span class="math display">\[\begin{aligned}error_{hidden} = W^T_{hidden_output} \cdot error_{output}\end{aligned}\]</span><h2 id="权重更新">权重更新</h2><p>了解了误差分割与传播后，我们再来看看神经网络是如何通过误差来对权重进行更新，从而达到学习的目的。</p><p>事实上，我们很容易就可以基于神经网络的正向信号转换过程，推导出反向权重更新过程。由于正向过程中，神经元对信号依次进行求和函数、激活函数的处理，并且层与层之间是相互依赖的。对于一个3 x 3的神经网络，输出层的某个节点的计算公式将非常复杂，如下所示。一旦神经玩网络的节点数量、层级数量增加，计算公式会更加复杂，基于此进行逆向的权重更新，将会变得极其复杂！</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-30.png?x-oss-process=image/resize,w_800" /></p><h3 id="梯度下降法">梯度下降法</h3><p>为此，研究人员提出了一种 <strong>梯度下降</strong>（GradientDescent） 的方法来绕过这个问题，解决这个问题。</p><p>我们来举一个例子说明一下说明是梯度下降法。想象一下，一个非常复杂、有山峰山谷的群山峻岭。在黑夜中，伸手不见五指。此时，你在某个山坡上，需要到坡底，手里只有一把手电筒，你该怎么做呢？你只能通过手电筒看到脚下的土地是上坡还是下坡，于是你就小步地往这个方向走。通过这种方式，不需要完整的底图，也不需要事先指定路线，缓慢地前进，慢慢地下山。这种方法，在数学上被称为梯度下降。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-31.png?x-oss-process=image/resize,w_800" /></p><p>那么梯度下降法与神经网络有什么关系呢？其实，我们可以寻找一个误差函数<span class="math inline">\(y = f(x)\)</span>，<spanclass="math inline">\(y\)</span> 表示误差值，<spanclass="math inline">\(x\)</span>表示连接的权重值。对于神经网络的样本训练而言，本质上就是找到最小误差值所对应的权重值，从而更新权重，达到学习的目的。</p><p>为了正确理解梯度下降的思想，我们来使用一个简单的例子来演示一下。假设，误差函数为<span class="math inline">\(y = (x-1)^2 + 1\)</span>。我们希望找到 <spanclass="math inline">\(x\)</span>，从而最小化误差 <spanclass="math inline">\(y\)</span>。那么我们可以通过判断斜率（也称梯度）的方式来寻找，当斜率为负时，<spanclass="math inline">\(x\)</span> 可以尝试适当增大；当斜率为正时，<spanclass="math inline">\(x\)</span>可以尝试适当减小，通过这种方式逐步逼近，从而找到最小值，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-32.png?x-oss-process=image/resize,w_800" /></p><p>为了提高训练学习的效率，我们可以动态调节步长。当梯度较大时，可以使用较大的步长，提高学习效率；当梯度较小时，可以使用较小的步长，避免调整过度。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-33.png?x-oss-process=image/resize,w_800" /></p><p>实际情况下，神经网络中的误差函数并不一定那么简单，它可能会有多个局部最小值。为了避免终止于错误的函数最小值，我们可以使用不同的起点（权重初值值）来进行多次训练。如下图所示，我们使用梯度下降法进行了三次尝试，其中有一次终止于错误的最小值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-34.png?x-oss-process=image/resize,w_800" /></p><h3 id="误差函数">误差函数</h3><p>神经网络具有非常多的节点和连接，那么我们该如何使用误差函数来描述这么多的连接权重并实现权重更新呢？这里我们针对每一个层都会使用一个误差函数来批量描述连接权重与误差的关系。</p><h4 id="误差项表示">误差项表示</h4><p>当进行批量处理时，需要对输出层各个节点的误差进行聚合。此时需要考虑批量处理时该如何表示总体误差，对此下面列出了针对3 个输出节点的神经网络的几种误差项表示方法。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-35.png?x-oss-process=image/resize,w_800" /></p><p>方案一：误差 = 目标值 -实际值。这种方案描述误差的方法非常直观，但是在处理多节点的误差聚合时，会出现总和为0 的情况，这会导致神经网络得到很好的训练。</p><p>方案二：误差 = |目标值 -实际值|。这种方案解决了多节点的误差聚合可能为 0的问题。但是它的斜率（或称梯度），在最小值附近会出现跳变，从而导致梯度下降法无法很好地发挥作用。下图所示对应的函数及其导数。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-36.png?x-oss-process=image/resize,w_800" /></p><p>方案三：误差 = (目标值 -实际值)。这种方案即解决了多节点的误差聚合可能为 0的问题，也解决了斜率跳变的问题。因此，我们采用这种方案作为误差项的计算方式。</p><h4 id="斜率推导">斜率推导</h4><p>要使用梯度下降法，我们必须要计算出误差函数相对权重的斜率，这里涉及到微积分的知识。这里如果你对微积分不太熟悉也没关系，我们只要知道最后推导出来的公式即可。</p><p>下图所示分别展示了包含一个权重和两个权重的误差函数及其斜率的示意图。当误差函数中每增加一个权重变量时，函数就会增加一个维度。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-37.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们先来看隐藏层和输出层之间的连接权重。我们使用 <spanclass="math inline">\(w_{i,k}\)</span>表示隐藏层和输出层之间的连接权重，使用 <spanclass="math inline">\(n\)</span> 表示输层节点的数量，然后对误差函数<span class="math inline">\(E\)</span> 进行展开，得到如下表示。</p><span class="math display">\[\begin{aligned}\frac{\partial E}{\partial w_{j,k}} = \frac{\partial \sum_n(t_n -o_n)^2}{\partial w_{j,k}}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-38.png?x-oss-process=image/resize,w_800" /></p><p>注意，在节点 <span class="math inline">\(n\)</span> 的输出 <spanclass="math inline">\(o_n\)</span>只取决于链接到这个节点的连接。对于单个输出节点 <spanclass="math inline">\(k\)</span>，其只依赖于与它连接的节点及其权重。因此，我们可以进一步简化表达式，如下所示。</p><span class="math display">\[\begin{aligned}\frac{\partial E}{\partial w_{j,k}} = \frac{\partial (t_k -o_k)^2}{\partial w_{j,k}}\end{aligned}\]</span><p>为了继续推导，我们利用链式法则对斜率表达式进行拆分，进而推导，如下所示。</p><span class="math display">\[\begin{aligned}\frac{\partial E}{\partial w_{j,k}} = &amp;\frac{\partial E}{\partial o_k} \cdot  \frac{\partial o_k}{\partialw_{j,k}} \\= &amp;-2(t_k - o_k) \cdot \frac{\partial o_k}{\partial w_{j,k}} \\\end{aligned}\]</span><p>输出层的输出 <span class="math inline">\(o_k\)</span>依赖隐藏层的输出 <spanclass="math inline">\(o_j\)</span>，然后经过输出层节点应用求和函数、激活函数，从而转换成<span class="math inline">\(o_k\)</span>。因此，我们可以继续推导。</p><span class="math display">\[\begin{aligned}\frac{\partial E}{\partial w_{j,k}} = &amp;\frac{\partial E}{\partial o_k} \cdot  \frac{\partial o_k}{\partialw_{j,k}} \\= &amp;-2(t_k - o_k) \cdot \frac{\partial o_k}{\partial w_{j,k}} \\= &amp;-2(t_k - o_k) \cdot \frac{\partial sigmoid(\sum_j w_{j,k} \cdoto_j)}{\partial w_{j, k}} \\\end{aligned}\]</span><p>接下来涉及到微分 sigmoid函数，这里我们直接使用数学家们已经推导出来的结果进行应用，如下所示。</p><span class="math display">\[\begin{aligned}\frac{\partial sigmoid(x)}{\partial x} = sigmoid(x) (1 - sigmoid(x))\end{aligned}\]</span><p>将该结果代入上述斜率推导中，得到：</p><span class="math display">\[\begin{aligned}\frac{\partial E}{\partial w_{j,k}} = &amp;-2(t_k - o_k) \cdot sigmoid(\sum_j w_{j,k} \cdot o_j) (1- sigmoid(\sum_jw_{j,k} \cdot o_j)) \cdot \frac{\partial \sum_j w_{j,k} \cdoto_j}{\partial w_{j, k}} \\= &amp;-2(t_k - o_k) \cdot sigmoid(\sum_j w_{j,k} \cdot o_j) (1- sigmoid(\sum_jw_{j,k} \cdot o_j)) \cdot o_j\end{aligned}\]</span><p>由于在梯度下降法中，我们只关注斜率的方向，所以可以进一步去掉系数<code>2</code>，从而得到如下斜率表达式。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-39.png?x-oss-process=image/resize,w_800" /></p><p>由于权重改变方向与梯度方向相反，结合学习率 <spanclass="math inline">\(\alpha\)</span>，我们可以得到权重更新前后的关系式，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-40.png?x-oss-process=image/resize,w_800" /></p><h4 id="矩阵表示">矩阵表示</h4><p>为了推导矩阵表示，我们尝试使用矩阵乘法的形式进行计算，可以得到如下所示的表示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-41.png?x-oss-process=image/resize,w_800" /></p><p>我们可以发现矩阵表达式中的最后一部分，其实就是前一层 <spanclass="math inline">\(o_j\)</span>的输出的转置。最后，我们可以得到权重更新矩阵的矩阵表达式，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/neural-network-intro-42.png?x-oss-process=image/resize,w_800" /></p><h1 id="总结">总结</h1><p>本文我们主要介绍了人工神经网络工作的基本原理，从而能够对它产生一个初步认知，有利于后续的进阶学习。</p><p>首先，我们以一个分类器结构介绍了机器学习的基本思想。在此基础上进行扩展，组合多个分类器，这也是人工神经网络的基本思想。</p><p>然后，我们介绍了神经网络正向的信号转换过程，其中涉及连接权重、求和函数、激活函数等。此外，我们还介绍了神经网络的训练的相关概念，包括：误差分割、误差传播、权重更新等。关于权重更新，我们重点介绍了误差函数及斜率的推导。</p><p>后续有时间我们将进一步介绍如何使用 Python打造一个简单的人工神经网络。</p><h1 id="参考">参考</h1><ol type="1"><li>《Python神经网络编程》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看了《Python
神经网络编程》一书之后，对于神经网络的工作原理有了一个初步的理解，于是产出此篇文章作为系统性的梳理和总结。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://chuquan.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="神经网络" scheme="http://chuquan.me/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="激活函数" scheme="http://chuquan.me/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
    <category term="梯度下降" scheme="http://chuquan.me/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>基于 Threejs 实现 3D 魔方</title>
    <link href="http://chuquan.me/2024/06/01/rubiks-cube-01/"/>
    <id>http://chuquan.me/2024/06/01/rubiks-cube-01/</id>
    <published>2024-06-01T09:54:33.000Z</published>
    <updated>2024-06-01T11:26:13.014Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-12.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>最近这段时间学习了计算机图形学和Threejs，为了巩固一下学习效果，同时也希望给<ahref="https://apps.apple.com/cn/app/%E8%8E%AB%E8%B4%9F%E4%BC%91%E6%81%AF-%E4%BC%91%E6%81%AF%E6%8F%90%E9%86%92/id6474056217?mt=12">「莫负休息」</a>新增主题，于是基于Threejs 实现了一个魔方程序。当然，基于 Threejs的魔方程序其实早就已经有了，我只不过是站在前人的成果上做了一次实践和总结而已。</p><p>源码传送门——<ahref="https://github.com/baochuquan/rubiks-cube">Rubiks Cube</a>，Demo传送门——<a href="http://rubiks.chuquan.me">rubiks.chuquan.me</a>。</p><h1 id="魔方的定义">魔方的定义</h1><p>魔方（Rubik's Cube），是匈牙利建筑学教授和雕塑鲁比克·埃尔内，于 1974年发明的机械益智玩具。</p><p>魔方是一个正立方体，一共 6 个面，对应 6种颜色。魔方的官方配色是：白色、红色、橙色、黄色、绿色、蓝色，其中黄白相对，红橙相对，蓝绿相对，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-01.png?x-oss-process=image/resize,w_800" /></p><p>一个三阶魔方由 3 x 3 x 3 共 27 个方块组成，根据方块的位置，可以分为 3种类型，分别是：</p><ul><li>中心块：中心块有 6个，位于魔方每面的正中心，只有一种颜色。中心块彼此之间的相对位置不会变化。</li><li>棱块：棱块有 12个，位于魔方每个魔方中心块的上下左右，有两种颜色。</li><li>角块：角块有 8 个，位于魔方每个魔方中心块的斜对角，有三种颜色。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-02.png?x-oss-process=image/resize,w_800" /></p><h1 id="场景布置">场景布置</h1><p>对于任意 3D场景，我们都需要先对场景中的基本元素进行设置，主要包括：相机、灯光、渲染器。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-03.png?x-oss-process=image/resize,w_800" /></p><p>首先初始化一个场景<code>Scene</code>，后续所有相关元素都将添加至这个场景中，并设置位置坐标。</p><p>然后，我们初始化相机，Threejs中有两种相机：正交相机、透视相机。透视相机成像的画面具有近大远小的效果，所以我们这里使用透视相机。当然，相机的位置确立之后，我们还需要确定它的观测方向，这里使用<code>lookAt</code> 方法。此外，我们还可以设置相机的视场（Field ofView），它表示相机的可视角度值，决定了屏幕画面的可视范围。</p><p>对于灯光，这里我只设置了一个环境光，因此无需设置坐标。当然，Threejs中有很多光源，比如：点光源、面光源、射线光源等。</p><p>相关的代码实现如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scene, camera, renderer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupScene</span>(<span class="params"></span>) &#123;</span><br><span class="line">  scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>();</span><br><span class="line">  scene.<span class="property">background</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupCamera</span>(<span class="params"></span>) &#123;</span><br><span class="line">  camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(</span><br><span class="line">    <span class="number">45</span>,</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>,</span><br><span class="line">    <span class="number">0.1</span>, </span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">  camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">10</span>, <span class="number">12</span>, <span class="number">10</span>);</span><br><span class="line">  camera.<span class="title function_">lookAt</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">  camera.<span class="property">fov</span> = <span class="number">45</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupLights</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ambientLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">  scene.<span class="title function_">add</span>(ambientLight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们还需要定义一个渲染器。通过渲染器我们才能够将 3D场景的渲染结果并绑定至 2D平面，相关代码如下所示。在具体实现中，我们将渲染器的 DOM 元素绑定至<code>body</code> 中，这样我们才能在 2D 网页中看到渲染效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupRenderer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>(&#123;</span><br><span class="line">    <span class="attr">antialias</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，为了方便查看空间效果，一般我们会创建一个轨道控制器。基于轨道控制器，我们可以通过鼠标旋转整个空间坐标系，从而可以在不同角度进行观测，相关代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupControls</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化控制器</span></span><br><span class="line">  controller = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, renderer.<span class="property">domElement</span>);</span><br><span class="line">  controller.<span class="property">enableDamping</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="魔方建模">魔方建模</h1><p>完成了场景布置之后，我们将在空间中对魔方进行建模。建模的过程非常简单，只需创建3 x 3 x 3 共 27个立方体即可，每个立方体的表面使用贴图作为材质。为了便于后续旋转魔方时获取同一平面中的9 个立方体，我们在建模时会对每个立方体设置编号索引，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-04.png?x-oss-process=image/resize,w_800" /></p><p>魔方建模的实现代码如下所示。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建立方体，并加入场景</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupCubes</span>(<span class="params"></span>) &#123;</span><br><span class="line">  cubes = <span class="title function_">createCube</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> cube = cubes[i];</span><br><span class="line">    scene.<span class="title function_">add</span>(cube);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建立方体，设置空间左边，使用贴图作为材质</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCube</span>(<span class="params">x, y, z, num, len</span>) &#123;</span><br><span class="line">  <span class="comment">// 魔方左上角坐标</span></span><br><span class="line">  <span class="keyword">var</span> leftUpX = x - num / <span class="number">2</span> * len;</span><br><span class="line">  <span class="keyword">var</span> leftUpY = y + num / <span class="number">2</span> * len;</span><br><span class="line">  <span class="keyword">var</span> leftUpZ = z + num / <span class="number">2</span> * len;</span><br><span class="line">  <span class="comment">// 根据颜色生成材质</span></span><br><span class="line">  <span class="keyword">const</span> loader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>();</span><br><span class="line">  <span class="keyword">const</span> textures = [</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/blue.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/green.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/yellow.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/white.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/orange.png&quot;</span>),</span><br><span class="line">    loader.<span class="title function_">load</span>(<span class="string">&quot;./img/red.png&quot;</span>),</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> materials = textures.<span class="title function_">map</span>(<span class="function"><span class="params">texture</span> =&gt;</span> <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">map</span>: texture &#125;));</span><br><span class="line">  <span class="comment">// 生成小方块</span></span><br><span class="line">  <span class="keyword">var</span> cubes = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; num * num; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> box = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(len, len, len);</span><br><span class="line">      <span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(box, materials);</span><br><span class="line">      <span class="comment">// 依次计算各个小方块中心点坐标</span></span><br><span class="line">      mesh.<span class="property">position</span>.<span class="property">x</span> = (leftUpX + len / <span class="number">2</span>) + (j % num) * len;</span><br><span class="line">      mesh.<span class="property">position</span>.<span class="property">y</span> = (leftUpY - len / <span class="number">2</span>) - <span class="built_in">parseInt</span>(j / num) * len;</span><br><span class="line">      mesh.<span class="property">position</span>.<span class="property">z</span> = (leftUpZ - len / <span class="number">2</span>) - i * len;</span><br><span class="line">      mesh.<span class="property">tag</span> = i * <span class="number">9</span> + j;</span><br><span class="line">      cubes.<span class="title function_">push</span>(mesh);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cubes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，魔方建模实现完成，完整的代码可以参考 <ahref="https://github.com/baochuquan/rubiks-cube/blob/main/src/components/RubiksCube01.vue">RubiksCube01.vue</a>文件。</p><h1 id="魔方控制">魔方控制</h1><p>魔方控制是基于鼠标实现的，核心思想分为以下几个步骤：</p><ul><li>首先，通过鼠标触点确定触点目标方块和触点平面法向量</li><li>其次，根据鼠标移动方向和触点平面法向量确定旋转方向</li><li>然后，通过旋转方向和触点目标方块获取整个旋转平面</li><li>最后，对整个旋转平面中的所有方块执行旋转动画</li></ul><h2 id="监听鼠标事件">监听鼠标事件</h2><p>鼠标事件是控制魔方的基础，因此我们需要实现鼠标事件的监听。相关实现如下所示，我们同时处理了鼠标控制和触摸控制两种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupEvents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, startMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, moveMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, stopMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, startMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, moveMouse);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, stopMouse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="确定触点方块与平面法向量">确定触点方块与平面法向量</h2><p>对于确定目标触点方块和平面法向量，这里有两个问题：</p><ul><li>如何通过二维平面中的鼠标位置确定三维空间中的位置呢？</li><li>立方体的位置不固定，那么该如何确定触点平面的方向呢？</li></ul><p>对于第一个问题，解决方法是<strong>射线</strong>（Raycaster），其基本原理是：通过相机位置和鼠标位置确定三维空间中的一根射线，延伸射线，找到三维空间中与射线相交的物体，根据自定义规则（比如：第一个）来找到目标物体。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-05.png?x-oss-process=image/resize,w_800" /></p><p>对于第二个问题，我们首先需要了解一下 Threejs 中的坐标系统： -全局坐标系：也称世界坐标系，是整个 3D 场景的坐标系。 -局部坐标系：也称物体坐标系。在 iOS/Android 中存在视图层级树，在 Threejs中同样存在场景层级树，整个 3D场景是根场景，空间中的物体可以作为子场景，子场景又可以继续添加场景。每个场景有自己的坐标系，当对一个场景进行仿射变换，那么它的子场景也会发生仿射变换，这就是物体坐标系的作用。</p><p>由于魔方旋转过程中，每个立方体自身的也在不停的旋转和移动，此时每个物体的局部坐标系也会发生变换，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-06.png?x-oss-process=image/resize,w_800" /></p><p>此时，如果基于目标立方体获取其表面法向量，那么获取到的法向量是基于局部坐标系的，不具备全局意义。因此，我们必须要将基于<strong>局部坐标系</strong> 的表面法向量转换成基于<strong>全局坐标系</strong> 的表面法向量。</p><p>对此，有两种解决方法：</p><ul><li>对基于局部坐标系的法向量通过矩阵变换，转换成基于全局坐标系。</li><li>增加一个固定不变的透明物体，通过射线获取其表面法向量，以代表立方体的表面法向量。</li></ul><p>对于前者，我们需要记录立方体从原始位置到当前位置的所有变换操作，再对基于局部坐标系的法向量做逆变换。这种方案实现难度且计算量都很大。</p><p>对于后者，其实现难度显然更低。我们只需创建一个透明的立方体，其大小与魔方整体相同，如下图所示。当判断表面法向量时，通过该透明立方体获取即可，由此得到的是基于全局坐标系的法向量。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-07.png?x-oss-process=image/resize,w_800" /></p><p>如下所示为确定触点方块与平面法向量的核心代码逻辑。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupRubiks</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 透明正方体</span></span><br><span class="line">  <span class="keyword">let</span> box = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">vertexColors</span>: <span class="variable constant_">THREE</span>.<span class="property">FaceColors</span>, <span class="attr">opacity</span>: <span class="number">0</span>, <span class="attr">transparent</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  rubiks = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(box, mesh);</span><br><span class="line">  rubiks.<span class="property">cubeType</span> = <span class="string">&#x27;coverCube&#x27;</span>;</span><br><span class="line">  scene.<span class="title function_">add</span>(rubiks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取操作焦点以及该焦点所在平面的法向量 </span></span><br><span class="line"><span class="comment"> * */</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getIntersectAndNormalize</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mouse = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector2</span>();</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">touches</span>) &#123;</span><br><span class="line">    <span class="comment">// 触摸事件</span></span><br><span class="line">    <span class="keyword">var</span> touch = event.<span class="property">touches</span>[<span class="number">0</span>];</span><br><span class="line">    mouse.<span class="property">x</span> = (touch.<span class="property">clientX</span> / <span class="variable language_">window</span>.<span class="property">innerWidth</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    mouse.<span class="property">y</span> = -(touch.<span class="property">clientY</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 鼠标事件</span></span><br><span class="line">    mouse.<span class="property">x</span> = (event.<span class="property">clientX</span> / <span class="variable language_">window</span>.<span class="property">innerWidth</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    mouse.<span class="property">y</span> = -(event.<span class="property">clientY</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raycaster = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Raycaster</span>();</span><br><span class="line">  raycaster.<span class="title function_">setFromCamera</span>(mouse, camera);</span><br><span class="line">  <span class="comment">// Raycaster方式定位选取元素，可能会选取多个，以第一个为准</span></span><br><span class="line">  <span class="keyword">var</span> intersects = raycaster.<span class="title function_">intersectObjects</span>(scene.<span class="property">children</span>);</span><br><span class="line">  <span class="keyword">var</span> intersect, normalize;</span><br><span class="line">  <span class="keyword">if</span> (intersects.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (intersects[<span class="number">0</span>].<span class="property">object</span>.<span class="property">cubeType</span> === <span class="string">&#x27;coverCube&#x27;</span>) &#123;</span><br><span class="line">        intersect = intersects[<span class="number">1</span>];</span><br><span class="line">        normalize = intersects[<span class="number">0</span>].<span class="property">face</span>.<span class="property">normal</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intersect = intersects[<span class="number">0</span>];</span><br><span class="line">        normalize = intersects[<span class="number">1</span>].<span class="property">face</span>.<span class="property">normal</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="comment">//nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">intersect</span>: intersect, <span class="attr">normalize</span>: normalize&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="确定旋转方向">确定旋转方向</h2><p>下面，我们基于触点目标方块、表面法向量，再结合鼠标移动方向，计算旋转方向。具体实现原理主要包括以下几个步骤：</p><ul><li>计算鼠标的平移向量</li><li>判断平移向量与全局坐标系 6 个方向之间的夹角，选择夹角最小的方向</li><li>结合表面法向量，确定旋转方向</li></ul><p>为什么要结合表面法向量来确定旋转方向？因为同一平移向量时，表面法向量不同，则魔方的旋转方向也不同。如下所示，当鼠标平移方向接近<code>x</code> 轴方向，如果表面法向量与 <code>z</code>轴方向相同，那么魔方将环绕 <code>y</code>轴进行逆时针旋转；如果表面法向量与 <code>y</code>轴方向相同，那么魔方将环绕 <code>z</code> 轴进行顺时针旋转。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-08.png?x-oss-process=image/resize,w_800" /></p><p>如下所示，为判断魔方旋转方向的代码逻辑。我们根据不同的拖拽方向分情况讨论，最终确定魔方的6 种旋转方向。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 魔方转动的六个方向</span></span><br><span class="line"><span class="keyword">const</span> xLine = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );     <span class="comment">// X轴正方向</span></span><br><span class="line"><span class="keyword">const</span> xLineAd = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> );  <span class="comment">// X轴负方向</span></span><br><span class="line"><span class="keyword">const</span> yLine = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> );     <span class="comment">// Y轴正方向</span></span><br><span class="line"><span class="keyword">const</span> yLineAd = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span> );  <span class="comment">// Y轴负方向</span></span><br><span class="line"><span class="keyword">const</span> zLine = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> );     <span class="comment">// Z轴正方向</span></span><br><span class="line"><span class="keyword">const</span> zLineAd = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span> );  <span class="comment">// Z轴负方向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得旋转方向</span></span><br><span class="line"><span class="comment"> * vector3: 鼠标滑动的方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDirection</span>(<span class="params">vector3</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> direction;</span><br><span class="line">  <span class="comment">// 判断差向量和 x、y、z 轴的夹角</span></span><br><span class="line">  <span class="keyword">var</span> xAngle = vector3.<span class="title function_">angleTo</span>(xLine);</span><br><span class="line">  <span class="keyword">var</span> xAngleAd = vector3.<span class="title function_">angleTo</span>(xLineAd);</span><br><span class="line">  <span class="keyword">var</span> yAngle = vector3.<span class="title function_">angleTo</span>(yLine);</span><br><span class="line">  <span class="keyword">var</span> yAngleAd = vector3.<span class="title function_">angleTo</span>(yLineAd);</span><br><span class="line">  <span class="keyword">var</span> zAngle = vector3.<span class="title function_">angleTo</span>(zLine);</span><br><span class="line">  <span class="keyword">var</span> zAngleAd = vector3.<span class="title function_">angleTo</span>(zLineAd);</span><br><span class="line">  <span class="keyword">var</span> minAngle = <span class="title class_">Math</span>.<span class="title function_">min</span>(...[xAngle, xAngleAd, yAngle, yAngleAd, zAngle, zAngleAd]);  <span class="comment">// 最小夹角</span></span><br><span class="line">  <span class="keyword">switch</span>(minAngle)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">xAngle</span>:</span><br><span class="line">      direction = <span class="number">10</span>;  <span class="comment">// 向x轴正方向旋转90度（还要区分是绕z轴还是绕y轴）</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">xAngleAd</span>:</span><br><span class="line">      direction = <span class="number">20</span>;  <span class="comment">// 向x轴反方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">yAngle</span>:</span><br><span class="line">      direction = <span class="number">30</span>;  <span class="comment">// 向y轴正方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">yAngleAd</span>:</span><br><span class="line">      direction = <span class="number">40</span>;  <span class="comment">// 向y轴反方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(zLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">5</span>;  <span class="comment">// 绕z轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        direction = direction + <span class="number">6</span>;  <span class="comment">// 绕z轴逆时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">zAngle</span>:</span><br><span class="line">      direction = <span class="number">50</span>;  <span class="comment">// 向z轴正方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">zAngleAd</span>:</span><br><span class="line">      direction = <span class="number">60</span>;  <span class="comment">// 向z轴反方向旋转90度</span></span><br><span class="line">      <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">1</span>;  <span class="comment">// 绕x轴顺时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(yLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">2</span>;  <span class="comment">// 绕x轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLine)) &#123;</span><br><span class="line">        direction = direction + <span class="number">4</span>;  <span class="comment">// 绕y轴逆时针</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalize.<span class="title function_">equals</span>(xLineAd)) &#123;</span><br><span class="line">        direction = direction + <span class="number">3</span>;  <span class="comment">// 绕y轴顺时针</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="确定旋转平面">确定旋转平面</h2><p>随后，我们可以根据触点目标方块的位置，结合旋转方向，找到与它同一旋转平面的立方体。比如，对于绕<code>x</code> 轴旋转时，我们只需要找到所有与触点目标方块的<code>x</code> 坐标相同的立方体即可。相关实现如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-11.png?x-oss-process=image/resize,w_800" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据立方体和旋转方向，找到同一平面上的所有立方体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPlaneCubes</span>(<span class="params">cube, direction</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">let</span> orientation = direction % <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> radians = (orientation % <span class="number">2</span> == <span class="number">1</span>) ? <span class="number">90</span> : -<span class="number">90</span>;</span><br><span class="line">  <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="comment">// 绕x轴</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = cubes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">position</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(curr.<span class="property">position</span>.<span class="property">x</span> - cube.<span class="property">position</span>.<span class="property">x</span>) &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">          results.<span class="title function_">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="comment">// 绕y轴</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = cubes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">position</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(curr.<span class="property">position</span>.<span class="property">y</span> - cube.<span class="property">position</span>.<span class="property">y</span>) &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">          results.<span class="title function_">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      <span class="comment">// 绕z轴</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = cubes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">position</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(curr.<span class="property">position</span>.<span class="property">z</span> - cube.<span class="property">position</span>.<span class="property">z</span>) &lt; <span class="number">0.2</span>) &#123;</span><br><span class="line">          results.<span class="title function_">push</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现旋转动画">实现旋转动画</h2><p>最后，我们需要实现旋转动画。对此，我们首先定义动画时长，根据当前时长与动画时长的比例，计算当前旋转角度的比例，并更新位置，从而实现旋转效果。关于旋转变换，我们在<ahref="https://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/#%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2">《计算机图形学基础（2）——变换》</a>一文中也介绍过。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-09.png?x-oss-process=image/resize,w_800" /></p><p>我们以 2D平面中的物体旋转来推导旋转矩阵。上图所示，我们将左边的图片进行旋转得到右边的图片，那么我们必须求解如下所示的矩阵运算公式，其中<span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>、<spanclass="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>为待求解的变量。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39;\end{matrix}\right)=\left(\begin{matrix}A &amp; B \\C &amp; D \\\end{matrix}\right)\left(\begin{matrix}x \\y\end{matrix}\right)\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-10.png?x-oss-process=image/resize,w_800" /></p><p>为了求解 <span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>、<spanclass="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>四个变量，我们将以 <span class="math inline">\((0, 1)\)</span> 和 <spanclass="math inline">\((1, 0)\)</span> 两个点的旋转为例求解方程。</p><p>对于 <span class="math inline">\((0, 1)\)</span>点的旋转，我们可以得到如下方程：</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}-sin \theta\\cos \theta\end{matrix}\right)=\left(\begin{matrix}A &amp; B \\C &amp; D \\\end{matrix}\right)\left(\begin{matrix}0 \\1\end{matrix}\right)\\-sin \theta = A * 0 + B * 1 = B\\cos \theta = C * 0 + D * 1 = D\end{aligned}\]</span><p>对于 <span class="math inline">\((1, 0)\)</span>点的旋转，我们可以得到如下方程：</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}cos \theta\\sin \theta\end{matrix}\right)=\left(\begin{matrix}A &amp; B \\C &amp; D \\\end{matrix}\right)\left(\begin{matrix}1 \\0\end{matrix}\right)\\cos \theta = A * 1 + B * 0 = A\\sin \theta = C * 1 + D * 0 = C\end{aligned}\]</span><p>至此 <span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>、<spanclass="math inline">\(C\)</span>、<span class="math inline">\(D\)</span>四个变量均已求解，由此得到旋转矩阵如下：</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39;\\y&#39;\end{matrix}\right)=\left(\begin{matrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{matrix}\right)\left(\begin{matrix}1 \\0\end{matrix}\right)\end{aligned}\]</span><p>进而得到 <span class="math inline">\(x&#39;\)</span> 和 <spanclass="math inline">\(y&#39;\)</span> 的计算公式如下：</p><span class="math display">\[\begin{aligned}x&#39; = cos\theta x - sin\theta y\\y&#39; = sin\theta x + cos\theta y\end{aligned}\]</span><p>由于魔方的旋转都是沿着一个轴进行旋转，所以我们可以将它看成三种情况的2D 平面旋转，由此得到如下 3 个旋转方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rotateAroundWorldX</span>(<span class="params">cube, rad</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> y0 = cube.<span class="property">position</span>.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">var</span> z0 = cube.<span class="property">position</span>.<span class="property">z</span>;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Quaternion</span>(); </span><br><span class="line">    q.<span class="title function_">setFromAxisAngle</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> ), rad);</span><br><span class="line">    cube.<span class="property">quaternion</span>.<span class="title function_">premultiply</span>(q);</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * y0 - <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * z0;</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">z</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * z0 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * y0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rotateAroundWorldY</span>(<span class="params">cube, rad</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x0 = cube.<span class="property">position</span>.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">var</span> z0 = cube.<span class="property">position</span>.<span class="property">z</span>;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Quaternion</span>(); </span><br><span class="line">    q.<span class="title function_">setFromAxisAngle</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> ), rad);</span><br><span class="line">    cube.<span class="property">quaternion</span>.<span class="title function_">premultiply</span>( q );</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * x0 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * z0;</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">z</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * z0 - <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * x0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">rotateAroundWorldZ</span>(<span class="params">cube, rad</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> x0 = cube.<span class="property">position</span>.<span class="property">x</span>;</span><br><span class="line">    <span class="keyword">var</span> y0 = cube.<span class="property">position</span>.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Quaternion</span>(); </span><br><span class="line">    q.<span class="title function_">setFromAxisAngle</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ), rad);</span><br><span class="line">    cube.<span class="property">quaternion</span>.<span class="title function_">premultiply</span>( q );</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * x0 - <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * y0;</span><br><span class="line">    cube.<span class="property">position</span>.<span class="property">y</span> = <span class="title class_">Math</span>.<span class="title function_">cos</span>(rad) * y0 + <span class="title class_">Math</span>.<span class="title function_">sin</span>(rad) * x0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于这几个方法仅仅旋转物体、更新坐标，实际上我们需要在一段时间内连续进行调用，从而实现一个完整的旋转动画，具体的调用实现如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rotateAnimation</span>(<span class="params">cubes, direction, currentstamp, startstamp, laststamp</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(startstamp === <span class="number">0</span>)&#123;</span><br><span class="line">        startstamp = currentstamp;</span><br><span class="line">        laststamp = currentstamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currentstamp - startstamp &gt;= rotateDuration)&#123;</span><br><span class="line">      currentstamp = startstamp + rotateDuration;</span><br><span class="line">      isRotating = <span class="literal">false</span>;</span><br><span class="line">      startPoint = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> orientation = direction % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> radians = (orientation % <span class="number">2</span> == <span class="number">1</span>) ? -<span class="number">90</span> : <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="title function_">rotateAroundWorldX</span>(cubes[i], radians * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * (currentstamp - laststamp) / rotateDuration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="title function_">rotateAroundWorldY</span>(cubes[i], radians * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * (currentstamp - laststamp) / rotateDuration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cubes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">          <span class="title function_">rotateAroundWorldZ</span>(cubes[i], radians * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span> * (currentstamp - laststamp) / rotateDuration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currentstamp - startstamp &lt; rotateDuration)&#123;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="function">(<span class="params">timestamp</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">rotateAnimation</span>(cubes, direction, timestamp, startstamp, currentstamp);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，我们实现了通过鼠标控制魔方的旋转，完整的代码可以参考 <ahref="https://github.com/baochuquan/rubiks-cube/blob/main/src/components/RubiksCube02.vue">RubiksCube02.vue</a>文件。</p><h1 id="总结">总结</h1><p>本文我们基于 Threejs 实现了一个 3D魔方，并支持了通过鼠标控制魔方旋转的功能。后续，我们将进一步介绍如何实现魔方的自动还原算法。</p><h1 id="参考">参考</h1><ol type="1"><li><ahref="https://mofang.1or9.com/mofangdingyi.shtml">魔方基本定义</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rubiks-cube-12.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Threejs" scheme="http://chuquan.me/categories/Threejs/"/>
    
    
    <category term="Threejs" scheme="http://chuquan.me/tags/Threejs/"/>
    
    <category term="vue" scheme="http://chuquan.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>欢迎关注我的 Twitter 账号！</title>
    <link href="http://chuquan.me/2024/05/16/my-twitter-account/"/>
    <id>http://chuquan.me/2024/05/16/my-twitter-account/</id>
    <published>2024-05-16T08:43:14.000Z</published>
    <updated>2024-07-19T00:19:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>最近在思考一个问题：如何打造个人品牌？思来想去，我觉得要做到以下几点：</p><ul><li>确定目标受众</li><li>培养专业能力</li><li>维持社交媒体</li><li>建立人脉关系</li></ul><span id="more"></span><p>一直以来，我并没有主动意识到要去打造个人品牌，也白白浪费了写博客的这几年。另一方面，我使用的社交媒体较少，仅限于微信、微博。而其中的朋友和粉丝基本上都是同事、同学、亲戚、朋友。在这样的熟人关系中经常发表一些日常的想法和看法，显然不太合适。从产品的角度解释就是目标人群定位不准确，所以很少更新社交媒体。</p><p>后续，我准备长期维持一个 Twitter 账号，发表一些日常的想法和看法。欢迎各位朋友关注 <a href="https://twitter.com/Baochuquan">Bao Chuquan</a>，你们的支持是我创作的动力！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在思考一个问题：如何打造个人品牌？思来想去，我觉得要做到以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定目标受众&lt;/li&gt;
&lt;li&gt;培养专业能力&lt;/li&gt;
&lt;li&gt;维持社交媒体&lt;/li&gt;
&lt;li&gt;建立人脉关系&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Twitter" scheme="http://chuquan.me/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>如何找到最合适的代码审查者？</title>
    <link href="http://chuquan.me/2024/05/11/git-reviewer/"/>
    <id>http://chuquan.me/2024/05/11/git-reviewer/</id>
    <published>2024-05-11T14:02:51.000Z</published>
    <updated>2024-05-11T14:19:09.384Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-01.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>我的日常工作中有相当一部分时间会用于审查团队成员所提交的代码，即 CodeReview。然而，由我来审查所有代码并不合适，毕竟很多时候我并不了解代码改动的上下文。如果让我重新熟悉别人写的原始逻辑，然后再审查代码改动，很显然是一件费时费力的事情。对此，最好的办法是，针对一次代码提交，合理地找出其最合适的代码审查者。</p><p>为了解决这个问题，我开发了一个 Git 插件——<ahref="https://github.com/baochuquan/git-reviewer">Git Reviewer</a>。</p><h1 id="功能">功能</h1><h2 id="核心功能">核心功能</h2><p>我们知道 Git使用新增和删除两种操作来表示代码改动。事实上，我们还可以从新增和删除两种操作的排列关系中得出第三种操作——编辑。当删除操作和新增操作相互紧邻，那么我们可以将其归为编辑操作。如下所示的代码差异中包含了新增、编辑、删除三种操作。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-03.png?x-oss-process=image/resize,w_800" /></p><p>Git Reviewer 正是基于这三种操作进行了分析：</p><ul><li><p>对于删除类型，Git Reviewer认为删除行的原始作者应该作为每一行的审查者。</p></li><li><p>对于编辑类型，Git Reviewer认为此部分中的新增内容应该全部由紧邻的最后删除行的原始作者作为审查者。注意，为什么是最后删除行？因为Git 所采用的 Myers差分算法默认差分内容优先展示删除操作，其次才是新增操作。因此，从最后的删除行开始，展示的是新增的内容。</p></li><li><p>对于新增类型，Git Reviewer 的策略是基于<code>.gitreviewer.yml</code>配置文件进行分析。<code>.gitreviewer.yml</code> 文件定义了项目所有者<code>project owner</code>、目录所有者<code>folder owner</code>、文件所有者 <code>file owner</code>。此时，GitReviewer 会对新增行的文件与 <code>.gitreviewer.yml</code>所定义的内容进行匹配。</p><ul><li>如果该文件匹配到了文件所有者，那么相关新增类型优先由文件所有者审查。</li><li>如果该文件匹配到了目录所有者，那么相关新增类型其次由目录所有者审查。</li><li>如果前两者均没有匹配该文件，那么将由项目所有者来进行审查。</li></ul></li></ul><p>基于对上述三种操作类型进行分析，Git Reviewer最终将生成一个分析表格，其中罗列了审查者、文件数量、文件占比、代码行数量、代码行占比等信息。GitReviewer 建议以代码行占比为依据，对审查者进行排序。</p><p>如下所示，为核心功能的分析结果示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|                 Suggested reviewers <span class="keyword">for</span> code changes                   |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| Suggested Reviewer | File Count | File Ratio | Line Count | Line Ratio |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerA         | 5          | 50.0%      | 1000       | 50.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerB         | 3          | 30.0%      | 500        | 25.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br><span class="line">| developerC         | 2          | 20.0%      | 500        | 25.0%      |</span><br><span class="line">+--------------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><h2 id="附加功能">附加功能</h2><p>Git Reviewer还提供了分析代码改动的所涉及的作者分布的功能。此功能相对简单，其分析了所有删除行的原始作者和新增行的现有作者，并同样以表格的形式呈现，罗列作者、文件数量、文件占比、代码行数量、代码行占比等信息，以供用户进行评估和参考。</p><p>如下所示，为附加功能的分析结果示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|             Relevant authors involved <span class="keyword">in</span> code changes              |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| Related Author | File Count | File Ratio | Line Count | Line Ratio |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerA     | 5          | 50.0%      | 2000       | 66.6%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerB     | 3          | 30.0%      | 500        | 16.7%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br><span class="line">| developerC     | 2          | 30.0%      | 500        | 16.7%      |</span><br><span class="line">+----------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><h1 id="安装">安装</h1><p>Git Reviewer 支持通过 Homebrew进行安装，命令如下所示。当然，这也是建议的安装方式。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install baochuquan/tap/git-reviewer</span><br></pre></td></tr></table></figure><p>或者，也可以通过 Ruby Gem 进行安装，命令如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install git-reviewer</span><br></pre></td></tr></table></figure><h1 id="使用">使用</h1><p>对于任意 Git 项目，在使用 Git Reviewer之前应该先在根目录下执行初始化命令，如下所示。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --init</span><br></pre></td></tr></table></figure><p>该命令会自动创建一个 <code>.gitreviewer.yml</code> 文件，内部定义了<code>project_owner</code>，<code>folder_owner</code>，<code>file_owner</code>等字段，其中后两者是数组类型，我们可以定义多个<code>path</code>、<code>owner</code>字段，从而对项目进行更精准的划分。</p><p>此外，<code>.gitreviewer.yml</code> 文件还包含<code>ignore_folders</code>、<code>ignore_files</code>字段，它们可以定义一系列目录或文件，以避免加入分析，从而影响分析结果。</p><p>如下所示，是一个 <code>.gitreviewer.yml</code>的示例，我们可以编辑相关字段，从而实现更精准的分析。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">project_owner: admin,</span><br><span class="line">folder_owner:</span><br><span class="line">- owner: developerA,</span><br><span class="line">  path: /path/to/folderA</span><br><span class="line">- owner: developerB</span><br><span class="line">  path: /path/to/folderB</span><br><span class="line"> </span><br><span class="line">file_owner:</span><br><span class="line">- owner: developerC</span><br><span class="line">  path: /path/to/fileC</span><br><span class="line">- owner: developerD</span><br><span class="line">  path: /path/to/fileD</span><br><span class="line"> </span><br><span class="line">ignore_files:</span><br><span class="line">- path/to/file1</span><br><span class="line">- path/to/file2</span><br><span class="line"> </span><br><span class="line">ignore_review_folders:</span><br><span class="line">- path/to/folder1</span><br><span class="line">- path/to/folder2</span><br></pre></td></tr></table></figure><h2 id="分析">分析</h2><p>Git Reviewer 基于两个 Git 分支进行分析，分别是源分支和目标分支。</p><p>源分支，即代码修改所在的分支。默认情况下，Git Reviewer自动获取当前所在分支作为源分支。当然，也可以使用选项来指定源分支<code>--source=&lt;source-branch&gt;</code>。除了分支名，Git Reviewer也支持 Commit ID。</p><p>目标分支，即准备合入的目标分支。对此，Git Reviewer 提供了相关选项<code>--target=&lt;target-branch&gt;</code>。</p><p>如下所示是使用 Git Reviewer 进行分析的命令示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --target=main</span><br></pre></td></tr></table></figure><p>默认情况下，Git Reviewer会同时展示核心功能和附加功能的分析结果。如果我们只希望查看核心功能的结果，可以指定选项<code>--reviewer</code>；如果我们只希望查看附加功能的结果，可以指定选项<code>--author</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --target=main --reviewer</span><br><span class="line"></span><br><span class="line">$ git reviewer --target=main --author</span><br></pre></td></tr></table></figure><p>为了查看更多分析信息，我们可以加上 --verbose 选项。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reviewer --target=main --verbose</span><br></pre></td></tr></table></figure><h1 id="后续">后续</h1><p>目前，Git Reviewer仅仅经历了我自己的自测，未来我会在项目上进行实践。如果遇到问题也会逐步进行修复。当然，在使用过程中还会遇到不足之处或者新的痛点，因此会逐步进行完善和迭代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/git-reviewer-01.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="作品集" scheme="http://chuquan.me/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="Myers" scheme="http://chuquan.me/tags/Myers/"/>
    
    <category term="git-reviewer" scheme="http://chuquan.me/tags/git-reviewer/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（8）——光线追踪</title>
    <link href="http://chuquan.me/2024/04/27/foundation-of-computer-graphic-08/"/>
    <id>http://chuquan.me/2024/04/27/foundation-of-computer-graphic-08/</id>
    <published>2024-04-27T03:13:09.000Z</published>
    <updated>2024-04-27T03:17:47.121Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍了在游戏领域中广泛使用的实时渲染技术——光栅化，本文我们来介绍一下在特效领域中广泛使用的离线渲染技术——光线追踪。</p><span id="more"></span><h1 id="概述">概述</h1><p>那么有了光栅化渲染技术，为什么还要用光线追踪呢？根本原因在于光栅化的着色局部性，使得它无法解决很多全局效果，比如：</p><ul><li><strong>软阴影</strong>（Soft shadows）</li><li><strong>光泽反射</strong>（Glossy reflection）</li><li><strong>间接光照</strong>（Indirect illumination）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-01.png?x-oss-process=image/resize,w_800" /></p><p>软阴影的产生是由于光源的大小和距离。一个面积较大的光源照射一个物体，可以从多个角度投射光线到物体上。当光线从不同角度照射时，阴影边缘的重叠区域会因光线部分遮挡而出现阴影的渐变效果。</p><p>光泽反射是一种既不完全镜面反射也不完全漫反射的光反射现象。光泽度高、粗糙度低的表面产生的反射相对清晰，接近镜面反射；而光泽度低、粗糙度高的表面，反射图像就会更加模糊，趋向漫反射。</p><p>间接光照是一个场景中光线经过一次或多次反射后照射到物体表面的光照效果。在真实世界中，一个房间只通过一扇窗投过光照，但是房间里没有一个地方是完全黑色的，这就是光的多次反射造成的。</p><h1 id="底层依据">底层依据</h1><p>光线追踪依赖以下几个基本的底层依据，分别是：</p><ul><li><strong>光线沿直线传播</strong>：在微观角度，光是沿着波形传播；在宏观角度，光是沿着直线传播。</li><li><strong>光线相互不碰撞</strong>：当光线的传播路径发生交叠时，我们认为光线的传播互不干扰。</li><li><strong>光线具有可逆性</strong>：真实世界中，视觉成像是因为物体发射或反射光线，进入视网膜；在图形学中，屏幕成像是因为从相机向像素建立了反向的光线传播路径，采集路径上的所有着色信息。</li></ul><h1 id="基本原理">基本原理</h1><p>光线追踪的基本原理非常简单，其采用了<strong>针孔相机模型</strong>（Pinhole Camera Model），分为<strong>视线生成</strong> 和 <strong>像素着色</strong> 两个阶段。</p><p>对于视线生成，以相机为起点，以像素为锚点，利用光的可逆性，建立一条视觉射线，如下所示。此时，我们需要找到视线与空间中的物体所产生的最近的交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-02.png?x-oss-process=image/resize,w_800" /></p><p>对于像素着色，当我们找到视线与物体之间的最近交点时，随即建立交点与光源的连线，判断交点是否在阴影之中，并根据结果来计算着色，写回像素结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-03.png?x-oss-process=image/resize,w_800" /></p><h1 id="光线追踪">光线追踪</h1><p>上述基本原理只考虑了光源的直接影响，没有考虑间接影响。在实际情况中，光线会经过空间中物体的多次弹射，汇聚至交点上，从而对着色产生间接影响。</p><p>对此，<strong>经典光线追踪</strong>，也称<strong>惠特式光线追踪</strong>（Whitted-Style Ray Tracing）或<strong>递归光线追踪</strong>（Recursive RayTracing），引入了间接光照的处理。</p><p>在视线生成之后，我们找到最近的交点，然后根据光线的可逆性，找到反射光线（ReflectedRay）与折射光线（Refracted Ray）所产生的交点，依次类推，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-08.png?x-oss-process=image/resize,w_800" /></p><p>之后，我们将所有交点分别与光源进行连线，判断这些交点是否在阴影之中，并根据结果计算着色，写回像素结果。当然，在反射和折射过程中会存在能量折损，因此，在计算着色时也会考虑光线折损的影响。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-09.png?x-oss-process=image/resize,w_800" /></p><h1 id="技术细节">技术细节</h1><p>光线追踪的整体原理非常简单，下面，我们来考虑其中所涉及到的一些技术细节。</p><h2 id="交点判定原理">交点判定原理</h2><p>光线追踪中最重要的技术是交点判定，其中包含光线表示和几何表示两部分。</p><p>对于光线表示，我们只需要使用原点、方向向量即可进行表示，如下所示。</p><span class="math display">\[\begin{aligned}\vec{r}(t) = \vec{o} + t\vec{d}\end{aligned}\]</span><p>对于几何表示，在 <ahref="http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/">《计算机图形学基础（6）——几何》</a>中，我们提到隐式几何表示和显式几何表示两种。</p><h3 id="隐式几何的交点">隐式几何的交点</h3><p>隐式几何使用数学关系式表示，因此我们可以结合光线表示来求解方程组，即可计算得到交点，如下所示。其中，<spanclass="math inline">\(f\)</span>为隐式几何的数学关系式，将光线表示作为参数代入，求解 <spanclass="math inline">\(t\)</span> 即可得到交点。</p><span class="math display">\[\begin{aligned}f(\vec{o} + t\vec{d}) = 0\end{aligned}\]</span><h3 id="显式几何的交点">显式几何的交点</h3><p>显式几何直接或间接（通过参数映射的方式）定义点、线、面等元素集合，基本上最终都会转换成多边形网格来表示。这里，我们介绍平面和三角形两种情况下的交点判定技术。</p><h4 id="平面交点判定">平面交点判定</h4><p>对于任意一个平面，我们可以使用一个向量和一个点来定义。其中，向量是法向量，平面上任意一个点与<span class="math inline">\(\vec{p&#39;}\)</span>所构成的向量都与法向量垂直，两者的点积为0，因此得到如下所示的平面定义。</p><span class="math display">\[\begin{aligned}(\vec{p} - \vec{p&#39;}) \cdot \vec{N} = 0\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-10.png?x-oss-process=image/resize,w_800" /></p><p>此时，我们再结合平面定义和光线表示得到如下所示的方程组，进而解得<span class="math inline">\(t\)</span> 的值，即交点。</p><span class="math display">\[\begin{aligned}(\vec{o} + t \vec{d} - \vec{p&#39;}) \cdot \vec{N} = 0\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-11.png?x-oss-process=image/resize,w_800" /></p><h4 id="三角形交点判定">三角形交点判定</h4><p>对于三角形交点，我们可以通过 Moller Trumbore Algorithm快速求解。算法利用重心坐标定义三角形内的一个点，以此得到如下关系式。</p><span class="math display">\[\begin{aligned}\vec{o} + t \vec{d} = (1 - b_1 - b_2)\vec{P_0} + b_1\vec{P_1} +b_2\vec{P_2}\end{aligned}\]</span><p>根据重心坐标的特性，当 <span class="math inline">\(1- b_1 - b_2 =0\)</span> 时，点在三角形内，因此关系式中存在三个变量 <spanclass="math inline">\(t\)</span>、<spanclass="math inline">\(b_1\)</span>、<spanclass="math inline">\(b_2\)</span>。由于关系式中的向量都是三维空间中的向量，因此每个向量都由三个坐标值构成，可以进一步得到三个线性方程组，从而求解各个变量。</p><h2 id="交点判定加速">交点判定加速</h2><p>在实际应用中，三维空间可能包含非常多的物体，每个物体可能包含非常多的三角形。假如，我们要判断光线与一个物体的交点，那么需要遍历物体的每一个三角形，如下所示。很显然，这是一个非常耗时的操作，尤其是场景中物体非常多的情况下。对此，图形学中也有一些针对交点判定加速的优化方法。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-12.png?x-oss-process=image/resize,w_800" /></p><h3 id="包围盒">包围盒</h3><p><strong>包围盒</strong>（BoundingBox）的原理是使用一个简单的几何体包围一个复杂的物体，如果光线与包围盒没有交点，那么必然与内部物体没有交点，从而达到交点判定加速的目的。</p><h4 id="轴对齐包围盒">轴对齐包围盒</h4><p>包围盒通常是长方体。对于长方体，我们将它理解成<strong>三对不同的平行面形成的交集</strong>，在实际应用中，我们会使用一种特殊的长方体，即三对面各自与坐标系的轴对齐，因此称为<strong>轴对齐包围盒</strong>（Axis-Aligned Bounding Box，AABB）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-13.png?x-oss-process=image/resize,w_800" /></p><h4 id="交点判定">交点判定</h4><p>很显然，接下来的问题就是如何判断光线是否与轴对齐包围盒相交。这里，我们首先考虑2D 情况下的交点判定，然后进一步延伸至 3D 情况下的交点判定。</p><p>对于 2D 的情况，如下所示，分为三个步骤：</p><ul><li>考虑光线与 <span class="math inline">\(x_0\)</span>、<spanclass="math inline">\(x_1\)</span>两个面的交点，根据方程组可以计算出一组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>。</li><li>考虑光线与 <span class="math inline">\(y_0\)</span>、<spanclass="math inline">\(y_1\)</span>两个面的交点，根据方程组又可以计算出一组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>。</li><li>对于两组 <span class="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>，我们必须保证 <spanclass="math inline">\(t_{min}\)</span> 大于0，否则表示交点在光源的背后，没有实际意义。两组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>各自构成一个线段，我们只需要计算两者的交集，即可得到光线在长方形内的传播路径，而传播路径的两个端点正是光线与长方形的两个交点。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-14.png?x-oss-process=image/resize,w_800" /></p><p>对于 3D 的情况，我们只需要额外延伸一步即可。</p><ul><li>考虑光线与 <span class="math inline">\(z_0\)</span>、<spanclass="math inline">\(z_1\)</span>两个面的交点，根据方程组又可以计算出一组 <spanclass="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>。</li><li>求解三组 <span class="math inline">\(t_{min}\)</span> 和 <spanclass="math inline">\(t_{max}\)</span>各自构成的线段，求线段的交集即可得到光线在包围盒内的传播路径，传播路径的两个端点正是光线与包围盒的两个交点。</li></ul><p>最终求解得到的 <span class="math inline">\(t_{enter}\)</span> 和<span class="math inline">\(t_{exit}\)</span>的值可能存在一下几种情况：</p><ul><li>当 <span class="math inline">\(t_{exit}\)</span> &lt; 0时，表示包围盒在光源的背后，没有交点。</li><li>当 <span class="math inline">\(t_{enter}\)</span> &lt; 0 且 <spanclass="math inline">\(t_{exit}\)</span> &gt;= 0时，表示光线在包围盒的内部。</li><li>当且仅当 <span class="math inline">\(t_{enter}\)</span> &lt; <spanclass="math inline">\(t_{exit}\)</span>，<spanclass="math inline">\(t_{exit}\)</span> &gt;= 0时，光线和包围盒存在交点。</li></ul><h3 id="统一网格">统一网格</h3><p>统一网格（Uniformgrids）是包围盒技术的延伸，它对包围盒内部的空间进行预处理。</p><ul><li>将包围盒拆分成统一的立体网格</li><li>将与物体发生重叠的网格进行标识</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-15.png?x-oss-process=image/resize,w_800" /></p><p>在判断光线与包围盒内部物体的交点时，会先遍历所有网格。当网格与光线有交点时，会继续判断网格内的物体是否与光线有交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-16.png?x-oss-process=image/resize,w_800" /></p><p>关于网格的划分，不同的划分方法，加速效果存在差异。</p><ul><li>当只有一个网格时，没有加速效果。</li><li>当网格划分非常密集时，计算交点时遍历网格的开销会增大，甚至会出现性能降低的情况。</li></ul><p>相对而言，一个加速效果良好的网格划分经验是：网格的数量等于物体的数量乘以一个常数（经验值是27）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-17.png?x-oss-process=image/resize,w_800" /></p><p>然而，统一网格划分并不是万能的，它只适用于一些物体分布均匀的场景。如下所示的场景中，在餐桌上方存在大量没有物体的空间，此时使用统一网格划分的效果并不好。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-18.png?x-oss-process=image/resize,w_800" /></p><h3 id="空间划分">空间划分</h3><p>空间划分（Spatialpartitions）主要是为了解决空间中物体分布不均匀的问题，其主要有<strong>Oct-Tree</strong>、<strong>KD-Tree</strong>、<strong>BSP-Tree</strong>等几种技术。</p><p>Oct-Tree，又称八叉树，其基本原理是把立方体分割成八等份，递归进行分割，直到格子为空或者物体足够少。</p><p>KD-Tree，与 Oct-Tree类似，区别在于每次只将格子一分为二，总是沿着有个轴进行分割。相比于Oct-Tree，其节点数量的复杂度不会随着维度而指数型增长。</p><p>BSP-Tree，对空间一分为二，每次选择一个方向进行分割。相比于KD-Tree，其切割的方向并不一定与轴平行。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-19.png?x-oss-process=image/resize,w_800" /></p><h4 id="kd-tree">KD-Tree</h4><p>这里我们着重介绍一下 KD-Tree 的工作原理。</p><p>首先，KD-Tree会对包围盒空间进行预处理，对包围盒空间进行二分，同时构建二叉树，如下所示。其中，非叶子节点表示二分之前的整体空间，它不会存储物体；叶子节点表示存储物体的真实空间。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-20.png?x-oss-process=image/resize,w_800" /></p><p>在进行交点判定时，本质上就是对二叉树进行先序遍历。对于上图中的例子，我们判定光线是否与整体的空间A 有交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-22.png?x-oss-process=image/resize,w_800" /></p><p>显然，上述例子中光线与空间 A 存在交点，那么它会节点 A 的两个叶子节点1 和 B分别进行交点判定，如下所示。如果交点存在则进一步判断内部物体是否与光线有交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-23.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-28.png?x-oss-process=image/resize,w_800" /></p><p>下图所示，当与空间 B 存在交点时，则进一步遍历空间 B 的子节点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-24.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-25.png?x-oss-process=image/resize,w_800" /></p><p>以此类推，空间 C与光线仍然存在交点，则继续遍历二叉树，直到判定光线与物体之间存在交点或不存在交点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-26.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-27.png?x-oss-process=image/resize,w_800" /></p><p>直观而言，KD-Tree 确实能够有效加速交点判定。但是 KD-Tree也存在一些无法解决的问题，比如：</p><ul><li>存在无法判定的例子，比如：三角形反包围了包围盒。</li><li>同一物体被划分在多个包围盒中，会有重复判断的问题。</li></ul><h3 id="物体划分">物体划分</h3><p>针对空间划分无法解决的问题，图形学采用物体划分来解决。下面，我们来介绍物体划分的典型技术——BVH。</p><h4 id="bvh">BVH</h4><p>BVH（Bounding Volume Hierarchy）的整体原理与 KD-Tree类似，唯一的区别在于对于空间划分的方式不同。KD-Tree是对空间进行划分，BVH 是对物体进行划分。</p><p>如下所示，空间中的物体彼此之间非常靠近。如果我们采用 KD-Tree的划分方式，那么一个物体可能会包含在多个空间中，进而存在重复判定的情况。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-29.png?x-oss-process=image/resize,w_800" /></p><p>对此，BVH对物体进行划分，并重新计算包围盒，形成根节点的子节点。以此类推，最终在所有叶子节点存储物体列表。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-30.png?x-oss-process=image/resize,w_800" /></p><h2 id="交点渲染原理">交点渲染原理</h2><p>当我们获取到光线直射、反射至物体表面的交点之后，我们可以进一步计算这些交点的着色，从而完成渲染。</p><h3 id="光线追踪的问题">光线追踪的问题</h3><p>关于经典光线追踪，即 Whitted-Style RayTracing，对光线作出了如下假设。</p><ul><li><strong>光线只进行镜面反射和折射</strong></li><li><strong>光线在漫反射面停止弹射</strong></li></ul><p>对于第一种情况，经典光线追踪只能渲染镜面反射，无法渲染磨砂反射，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-33.png?x-oss-process=image/resize,w_800" /></p><p>对于第二种情况，对于漫反射物体，光线转播至表面时会停止弹射，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-34.png?x-oss-process=image/resize,w_800" /></p><p>既然经典光线追踪是存在问题的，那么我们该如何对交点进行渲染呢？答案是渲染方程。</p><h3 id="渲染方程定义">渲染方程定义</h3><p>关于渲染，我们在 <ahref="http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/">上一篇文章</a>中介绍了辐射度量学，文中我们提到了渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_r(p, {\omega}_r) = L_e(p, {\omega}_r) + \int_{H^2}L_i(p, {\omega}_i)f_r(p, {\omega}_i, {\omega}_r) (n \cdot {\omega}_i) d{\omega}_i\end{aligned}\]</span><h3 id="渲染方程展开">渲染方程展开</h3><p>渲染方程经过一系列变换可以简化成如下表达式。</p><span class="math display">\[\begin{aligned}l(u) = e(u) + \int l(v) K(u, v) dv\end{aligned}\]</span><p>我们将 <span class="math inline">\(K\)</span>作为反射操作符，可以进一步将简化为如下表达式，<spanclass="math inline">\(L\)</span> 是一个递归项。</p><span class="math display">\[\begin{aligned}L = E + KL\end{aligned}\]</span><p>我们的目的是求解 <span class="math inline">\(L\)</span>，前面说 <spanclass="math inline">\(K\)</span>是一个反射操作符，其实我们也可以将其理解为反射次数，反射次数越多，展开项越多，比如：<spanclass="math inline">\(K^2\)</span> 表示光在空间中弹射两次。</p><span class="math display">\[\begin{aligned}L = &amp; E + KL\\IL - KL = &amp; E\\(I - K)L = &amp; E\\L = &amp; (I - K)^{-1}E\\L = &amp; (I + K + K^2 + K^3 + ...)E\\L = &amp; E + KE + K^{2}E + K^{3}E + ...\\\end{aligned}\]</span><p>我们可以非常容易地理解展开后的渲染方程中的各个项，如下所示。全局光照由<strong>光源</strong>、<strong>直接光照</strong>、<strong>间接光照</strong>组合而成，其中光栅化只包含了光源和直接光照两部分，难以实现间接光照；光线追踪则包含了全局光照。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-31.png?x-oss-process=image/resize,w_800" /></p><p>下图所示，展示了全局光照包含不同数量的光照项的渲染对比效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-32.png?x-oss-process=image/resize,w_800" /></p><h3 id="求解理论基础">求解理论基础</h3><p>关于如何求解渲染方程，我们首先介绍两部分与之相关的内容。</p><ul><li>概率论基础</li><li>蒙特卡洛积分</li></ul><h4 id="概率论基础">概率论基础</h4><p>这里我们主要介绍概率、概率分布函数、期望等几个概念。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-35.png?x-oss-process=image/resize,w_800" /></p><p>上图所示是一个的连续的概率分布曲线 <span class="math inline">\(X \simp(x)\)</span>，横坐标表示目标值 <spanclass="math inline">\(x\)</span>，纵坐标表示目标值为 <spanclass="math inline">\(x\)</span> 的概率 <spanclass="math inline">\(p(x)\)</span>，即<strong>概率分布函数</strong>（Probability DistributionFunction，PDF），那么我们可以得到如下两个关系式：</p><ul><li>所有取值的概率之和为 <span class="math inline">\(1\)</span></li><li>期望为概率与目标值乘积的积分 <spanclass="math inline">\(E[X]\)</span></li></ul><span class="math display">\[\begin{aligned}\int p(x) dx = &amp; 1; &amp;&amp;  p(x) \geq 0\\E[X] = &amp; \int x p(x) dx\end{aligned}\]</span><h4 id="蒙特卡洛积分">蒙特卡洛积分</h4><p>假设我们希望求解如下所示的不定积分，那么该如何求解？答案是蒙特卡洛积分。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-36.png?x-oss-process=image/resize,w_800" /></p><p>蒙特卡洛积分（Monte CarloIntegration）的基本思想是：在积分域内不断采样 <spanclass="math inline">\(f(x)\)</span>，不断地与 <spanclass="math inline">\(ab\)</span>构成一个个长方形，然后对所有的长方形的面积之和求平均值。由此我们可以得到离散形式的蒙特卡洛方程，如下所示。</p><span class="math display">\[\begin{aligned}F_N = \frac{1}{N} \sum^{1}_{i=1} \frac{f(x_i)}{p(x_i)}\end{aligned}\]</span><p>我们将其进一步表示为更加通用的连续形式的蒙特卡洛方程，如下所示。</p><span class="math display">\[\begin{aligned}\int_{a}^{b} f(x) dx = \frac{1}{N} \sum_{i=1}^{N} \frac{f(x_i)}{p(x_i)}\end{aligned}\]</span><p>对于蒙特卡洛积分，当 <span class="math inline">\(N\)</span>越大，求解的结果越精准。</p><h3 id="渲染方程求解">渲染方程求解</h3><p>在了解了概率论基础和蒙特卡洛积分之后，我们来正式求解渲染方程。</p><h4 id="求解过程分析">求解过程分析</h4><p>假设，我们只考虑一个像素点的着色过程，如下图所示。其中，<spanclass="math inline">\({\omega}_o\)</span>为观测方向，即从着色点到观测点的方向；<spanclass="math inline">\({\omega}_i\)</span>为光线入射方向，即从光源到着色点的方向。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-37.png?x-oss-process=image/resize,w_800" /></p><p>同时，我们先忽略着色点本身的发光项，那么可以得到一个简化的渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_o(p, {\omega}_o) = \int_{H^2} L_i(p, {\omega}_i) f_r(p, {\omega}_i,{\omega}_o) (n \cdot {\omega}_i) d{\omega}_i\end{aligned}\]</span><p>我们将渲染等价为在半球面上进行采样。因此，任意一点的采样概率 <spanclass="math inline">\(p({\omega}_i)\)</span> 为 <spanclass="math inline">\(1/2\pi\)</span>，即概率分布函数（PDF）。对应，采样值<span class="math inline">\(f({\omega}_i)\)</span> 为 <spanclass="math inline">\(L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o)(n \cdot{\omega}_i)\)</span>。由此可以用蒙特卡洛积分来求解渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_o(p, {\omega}_o) = &amp;\int_{H^2}L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o) (n \cdot{\omega}_i) d{\omega}_i\\\approx &amp;\frac{1}{N} \sum_{i=1}^{N} \frac{f({\omega}_i)}{p({\omega}_i)}\\\approx &amp;\frac{1}{N} \sum_{i=1}^{N} \frac{L_i(p, {\omega}_i) f_r(p, {\omega}_i,{\omega}_o) (n \cdot {\omega}_i) }{p({\omega}_i)}\end{aligned}\]</span><p>根据上述的渲染方程的求解关系式，我们可以实现对应的伪代码，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-38.png?x-oss-process=image/resize,w_800" /></p><p>上述，我们只处理了光的一次弹射，而全局光照还包括二次弹射、三次弹射...我们该如何处理呢？</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-39.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，我们希望计算 Q 点反射到 P点的光线。对此，我们可以转换一下思路：Q 点反射到 P 点的光线，不就等于从P 点观测 Q 点，Q点的着色吗？于是全局光照就转换成了一个递归着色的过程。如下所示，我们加入了处理全局光照的递归着色。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-40.png?x-oss-process=image/resize,w_800" /></p><p>至此，着色算法的整体框架已经实现了，但是还存在两个问题：</p><ul><li>分治爆炸问题</li><li>无限递归问题</li></ul><h4 id="分治爆炸问题">分治爆炸问题</h4><p>在上述算法实现中，对于每一个点的着色，我们都会采样各个方向，而每一个方向所经过的反射点又会采样各个方向。如果我们对于每个点采样100 个方向，那么在下一次递归中将会采样 10000个方向，依次类推，产生分治爆炸问题。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-41.png?x-oss-process=image/resize,w_800" /></p><p>那么如何解决这个问题？很显然，只有当采样数量为 1时，递归时才不会出现分治爆炸问题。在计算机图形学中，对于每个着色点，只通过一条射线进行光线追踪的方式被称为<strong>路径追踪</strong>（Path Tracing）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-42.png?x-oss-process=image/resize,w_800" /></p><p>如下所示，为解决了分支爆炸问题的着色算法。我们不再采样各个方向，而是随机采样一个方向，进而计算着色。然而，我们知道在蒙特卡洛积分中，采样数越小，准确性越低。算法中将采样数降至1，很显然，会出现很大的噪声。那么这又该如何解决呢？</p><p>对此，有一种方法另辟蹊径：<strong>每个像素生成多条光线，进行多次路径追踪，并求解平均值</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-43.png?x-oss-process=image/resize,w_800" /></p><p>如下所示，我们定义了一个 <code>ray_generation</code>方法，它以相机位置和像素点作为参数，内部对这个像素点进行多次路径追踪，即调用<code>shade</code> 方法，最终求解平均值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-44.png?x-oss-process=image/resize,w_800" /></p><h4 id="无限递归问题">无限递归问题</h4><p>对于无限递归问题，很显然，我们必须要找到一个停止递归的策略。对此，图形学借鉴了<strong>俄罗斯轮盘赌</strong>（Russion Roulette，RR）的思想。</p><p>俄罗斯轮盘赌的基本原理是设定一个概率值 <span class="math inline">\(0&lt; P &lt; 1\)</span>。</p><ul><li>射出光线的概率为 <spanclass="math inline">\(P\)</span>，由此返回的着色结果为 <spanclass="math inline">\(L_0/P\)</span></li><li>不射出光线的概率为 <spanclass="math inline">\(1-P\)</span>，由此返回的着色结果为 <spanclass="math inline">\(0\)</span></li></ul><p>使用这种方式，我们仍然可以期望得到 <spanclass="math inline">\(L_0\)</span>，如下所示为俄罗斯轮盘赌的期望公式.</p><span class="math display">\[\begin{aligned}E = P * (L_0 / P) + (1 - P) * 0 = L_0\end{aligned}\]</span><p>于是，我们可以进一步优化着色算法，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-45.png?x-oss-process=image/resize,w_800" /></p><h4 id="光源采样问题">光源采样问题</h4><p>经过上述改进，着色算法是正确了，但是它并不高效。如下所示，像素采样必须达到一定阈值才能得到相对高质量的结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-46.png?x-oss-process=image/resize,w_800" /></p><p>这里的根本原因在于均匀采样，其中只有极少数方向能够打到光源，大多数方向则浪费掉了。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-47.png?x-oss-process=image/resize,w_800" /></p><p>对此，我们可以考虑直接对光源进行采样。考虑到我们在求解蒙特卡洛积分时是在立体角进行采样，因此我们将空间中的面光源投影到球面上，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-48.png?x-oss-process=image/resize,w_800" /></p><p>我们得到立体角和光源微分面积的关系如下所示。</p><span class="math display">\[\begin{aligned}d\omega = \frac{dA cos{\theta}&#39;}{||x&#39; - x||^2}\end{aligned}\]</span><p>然后，我们微分立体角代入渲染方程，如下所示。</p><span class="math display">\[\begin{aligned}L_o(p, {\omega}_o) = &amp;\int_{H^2}L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o) cos\thetad{\omega}_i\\= &amp;\int_{H^2} L_i(p, {\omega}_i) f_r(p, {\omega}_i, {\omega}_o)\frac{cos\theta cos{\theta}&#39;}{||x&#39; - x||^2} dA\end{aligned}\]</span><p>现在，我们认为着色结果来源于两部分：</p><ul><li>光源的直接作用：直接采样光源，无需俄罗斯轮盘赌</li><li>光源的间接作用：反射、漫反射，需要俄罗斯轮盘赌</li></ul><p>由此，我们结合两部分得到如下所示的优化算法。当然，对于光源的直接作用，我们需要判断光源与着色点之间是否存在遮挡，这一点一定要注意。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ray-tracing-49.png?x-oss-process=image/resize,w_800" /></p><h1 id="总结">总结</h1><p>本文我们主要介绍了光线追踪的原理。首先，我们我们介绍了光线追踪的基本原理，其主要包括：视线生成和像素着色两个阶段。</p><p>然后，我们介绍了经典光线追踪技术，也称为 Whitted-Style光线追踪，其引入了间接光照的处理。</p><p>在光线追踪中，主要设计两个关键技术，分别是交点判定和交点渲染。对于交点判定，我们介绍了包围盒原理、统一网格、空间划分、物体划分等技术；对于交点渲染，我们在经典光线追踪的基础上引入了漫反射的处理，整体围绕渲染方程进行展开，使用蒙特卡洛积分进行求解。</p><p>在实现渲染方程算法的过程中，我们遇到了分治爆炸、无限递归、光源采样等问题，对此我们也依次进行了处理。最终实现了一个完整的着色算法。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前我们介绍了在游戏领域中广泛使用的实时渲染技术——光栅化，本文我们来介绍一下在特效领域中广泛使用的离线渲染技术——光线追踪。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Whitted-Stype Ray Tracing" scheme="http://chuquan.me/tags/Whitted-Stype-Ray-Tracing/"/>
    
    <category term="交点判定" scheme="http://chuquan.me/tags/%E4%BA%A4%E7%82%B9%E5%88%A4%E5%AE%9A/"/>
    
    <category term="交点渲染" scheme="http://chuquan.me/tags/%E4%BA%A4%E7%82%B9%E6%B8%B2%E6%9F%93/"/>
    
    <category term="包围盒" scheme="http://chuquan.me/tags/%E5%8C%85%E5%9B%B4%E7%9B%92/"/>
    
    <category term="轴对齐包围盒" scheme="http://chuquan.me/tags/%E8%BD%B4%E5%AF%B9%E9%BD%90%E5%8C%85%E5%9B%B4%E7%9B%92/"/>
    
    <category term="KD-Tree" scheme="http://chuquan.me/tags/KD-Tree/"/>
    
    <category term="BVH" scheme="http://chuquan.me/tags/BVH/"/>
    
    <category term="蒙特卡洛积分" scheme="http://chuquan.me/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86/"/>
    
    <category term="路径追踪" scheme="http://chuquan.me/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"/>
    
    <category term="光线追踪" scheme="http://chuquan.me/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    
    <category term="俄罗斯轮盘赌" scheme="http://chuquan.me/tags/%E4%BF%84%E7%BD%97%E6%96%AF%E8%BD%AE%E7%9B%98%E8%B5%8C/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（7）——辐射度量学</title>
    <link href="http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/"/>
    <id>http://chuquan.me/2024/04/20/foundation-of-computer-graphic-07/</id>
    <published>2024-04-20T14:11:09.000Z</published>
    <updated>2024-04-20T14:13:37.201Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍光线追踪之前，我们先来学习一下其所涉及的重要内容——辐射度量学。由于该内容相对独立，这里单开一篇文章来进行介绍。</p><span id="more"></span><h1 id="概述">概述</h1><p>本质上，辐射度量学是在物理层面准确定义光照的方法。在 <ahref="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">《计算机图形学基础（5）——着色》</a>一文中我们提到了光照强度，我们将半径为 <spanclass="math inline">\(r\)</span> 时，对应的球面的一个点的光照强度为<spanclass="math inline">\(I\)</span>，那么具体它的单位是什么呢？在了解辐射度量学之后，这个疑问就能得到解答。</p><p>在辐射度量学中涉及了很多相关术语，这里我将它们分为两部分进行介绍。</p><h1 id="几何">几何</h1><p>首先我们来看几何的相关术语，主要包含以下几个：</p><ul><li><strong>角（Angles）</strong></li><li><strong>立体角（Solid Angles）</strong></li><li><strong>微分立体角（Differential Solid Angles）</strong></li></ul><h2 id="角">角</h2><p>在平面几何中，角的定义是弧长与半径的比值，其中 <spanclass="math inline">\(\theta\)</span> 表示角，<spanclass="math inline">\(l\)</span> 表示弧长，<spanclass="math inline">\(r\)</span> 表示圆的半径，如下所示。圆自身的角度为<span class="math inline">\(2\pi\)</span>。</p><span class="math display">\[\begin{aligned}\theta = \frac{l}{r}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-01.png?x-oss-process=image/resize,w_800" /></p><h2 id="立体角">立体角</h2><p>在立体几何中，立体角的定义则是弧面积与半径平方的比值，其中 <spanclass="math inline">\(\Omega\)</span> 表示立体角，<spanclass="math inline">\(A\)</span> 表示弧面积，<spanclass="math inline">\(r\)</span>表示球的半径，如下所示。球自身的立体角为 <spanclass="math inline">\(4\pi\)</span>。立体角主要用于描述空间中的一个锥体的张开角度。</p><span class="math display">\[\begin{aligned}\Omega = \frac{A}{r^2}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-02.png?x-oss-process=image/resize,w_800" /></p><h2 id="微分立体角">微分立体角</h2><p>微分立体角通过两个角度来定义球面上的一个唯一的方向，如下所示。其中，两个角度分别是：</p><ul><li>与 <span class="math inline">\(z\)</span> 轴形成的夹角 <spanclass="math inline">\(\theta\)</span></li><li>绕 <span class="math inline">\(z\)</span> 轴形成的夹角 <spanclass="math inline">\(\phi\)</span></li></ul><p>计算微分立体角，我们首先两个角度在球面所形成方向所占据的单位面积<spanclass="math inline">\(dA\)</span>。按照微分的思想，我们认为该面积等同于矩形的面积，因此我们要计算它的长和宽，分别为<span class="math inline">\(rsin{\theta}d\phi\)</span> 和 <spanclass="math inline">\(rd\theta\)</span>，由此可以计算该单位面积。从而进一步求解微分立体角<span class="math inline">\(d\omega\)</span>，如下所示。</p><span class="math display">\[\begin{aligned}dA = &amp;(r d\theta)(r sin{\theta} d\phi) = r^2 sin\theta d\theta d\phi\\d\omega = &amp;\frac{dA}{r^2} = sin\theta d\theta d\phi\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-03.png?x-oss-process=image/resize,w_800" /></p><p>在辐射度量学中，我们通常用 <spanclass="math inline">\(\omega\)</span>来表示三维空间中的一个方向。我们可以使用 <spanclass="math inline">\(\theta\)</span> 和 <spanclass="math inline">\(\phi\)</span> 来确定其方向，并且还可以结合 <spanclass="math inline">\(d\theta\)</span> 和 <spanclass="math inline">\(d\phi\)</span> 来计算其微分立体角。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-04.png?x-oss-process=image/resize,w_800" /></p><h1 id="光学物理">光学物理</h1><p>在辐射度量学中，主要涉及以下几个光学物理相关术语。</p><ul><li><strong>辐射能量（Radiant Energy）</strong></li><li><strong>辐射通量（Radiant Flux）</strong></li><li><strong>辐射强度（Radiant Intensity）</strong></li><li><strong>辐射照度（Irradiance）</strong></li><li><strong>辐射亮度（Radiance）</strong></li></ul><h2 id="辐射能量">辐射能量</h2><p>辐射能量（Radiant Energy）表示电磁辐射的能量，用符号 <spanclass="math inline">\(Q\)</span> 表示，以 <strong>焦耳</strong>（J =Joule）为单位。</p><span class="math display">\[\begin{aligned}Q\\unit: [J = Joule]\end{aligned}\]</span><h2 id="辐射通量">辐射通量</h2><p>辐射通量（RadiantFlux）表示单位时间内流通（发射、反射、传输、接收）的能量，用符号 <spanclass="math inline">\(\Phi\)</span> 表示，以 <strong>瓦特</strong>（W =Watt）或 <strong>流明</strong>（lm =lumen）为单位。<strong>在实际应用中，我们经常将辐射通量称为能量，本质上是因为辐射通量可以结合时间快速计算出辐射能量</strong>。</p><span class="math display">\[\begin{aligned}\Phi = \frac{dQ}{dt}\\unit: [W = Watt]/[lm = lumen]\end{aligned}\]</span><p>在光学物理中，我们也将辐射通量定义为<strong>单位时间辐射出光子的数量</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-05.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射强度">辐射强度</h2><p>辐射强度（Radiant Intensity）表示<strong>单位立体角的辐射通量</strong>。其中 <spanclass="math inline">\(\Phi\)</span> 表示辐射通量，<spanclass="math inline">\(\omega\)</span>表示立体角。我们可以用辐射强度描述一束光线，即形成一个锥体角度的光线，在单位时间内流通的能量。</p><span class="math display">\[\begin{aligned}I(\omega) = \frac{d\Phi}{d\omega}\\unit:[\frac{W}{sr}][\frac{lm}{sr} = cd = candela]\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-06.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射照度">辐射照度</h2><p>辐射照度（Irradiance）表示<strong>单位（正交）面积的辐射通量</strong>。注意，这里计算的辐射通量必须与面垂直，如果光照不垂直于面，则计算其垂直分量。其中<span class="math inline">\(\Phi\)</span> 表示辐射通量，<spanclass="math inline">\(A\)</span> 表示正交面积，$$ 表示位置。</p><span class="math display">\[\begin{aligned}E(p) = \frac{d\Phi(p)}{dA}\\unit: [\frac{W}{m^2}][\frac{lm}{m^2} = lux]\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-07.png?x-oss-process=image/resize,w_800" /></p><p>此时，我们回顾 <ahref="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/">《计算机图形学基础（5）——着色》</a>文中的兰伯特余弦定理，可以计算辐射照度，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-08.png?x-oss-process=image/resize,w_800" /></p><p>同样，我们还可以计算空间中一个点光源在空间中辐射的衰减到底是什么？如下所示，其实我们可以发现辐射照度随着半径增加而指数级衰减，辐射强度并没有发生变化。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-09.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射亮度">辐射亮度</h2><p>辐射亮度（Radiance）表示<strong>单位立体角、单位（正交）面积的辐射通量</strong>。辐射亮度一般用于描述光线在传输过程中的属性。我们可以用辐射亮度来描述某个面光源在某个（锥形）方向的辐射通量。</p><p>从定义上看，辐射亮度在立体角、正交面积两个维度做了两次微分。其中，<spanclass="math inline">\(cos\theta\)</span>表示光线在单位面积垂直方向上的角度分量，<spanclass="math inline">\(p\)</span> 表示位置，<spanclass="math inline">\(\omega\)</span> 表示立体角。</p><span class="math display">\[\begin{aligned}L(p, \omega) = \frac{d^2\Phi(p, \omega)}{d{\omega}dA cos\theta}\\unit: [\frac{W}{sr m^2}][\frac{cd}{m^2} = \frac{lm}{sr m^2} = nit]\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-10.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们回顾一下辐射强度和辐射照度的定义。</p><ul><li>辐射强度：单位立体角的辐射通量。</li><li>辐射照度：单位（正交）面积的辐射通量</li></ul><p>结合辐射强度和辐射照度的定义，我们可以将辐射亮度的定义进行转换，<strong>单位立体角的辐射照度</strong>或<strong>单位（正交）面积的辐射强度</strong>。这两种定义正好可以应用到两种不同方向的辐射亮度，分别是<strong>入射辐射亮度</strong> 和 <strong>出射辐射亮度</strong>。</p><h3 id="入射辐射亮度">入射辐射亮度</h3><p>入射辐射亮度（IncidentRadiance）即单位立体角的辐射照度。我们可以理解从某个方向向一个面进行辐射，该面所接收的辐射照度，如下图所示。如果我们进一步考虑来自四面八方的辐射，比如环境光，那么可以计算得到这个面所接收的全部辐射照度。</p><span class="math display">\[\begin{aligned}L(p, \omega) = \frac{dE{p}}{d{\omega} cos\theta}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-11.png?x-oss-process=image/resize,w_800" /></p><h3 id="出射辐射亮度">出射辐射亮度</h3><p>出射辐射亮度（ExitingRadiance）即单位（正交）面积的辐射强度。我们可以理解一个面向某个方向进行辐射，该方向所发射的辐射强度，如下所示。如果我们进一步考虑一个面向四面八方的辐射，那么可以计算得到这个面所发射的全部辐射强度。</p><span class="math display">\[\begin{aligned}L(p, \omega) = \frac{dI(p, \omega)}{dA cos\theta}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-10.png?x-oss-process=image/resize,w_800" /></p><h2 id="辐射照度-vs.-辐射亮度">辐射照度 vs. 辐射亮度</h2><p>在图形学中，辐射照度（Irradiance）和辐射亮度（Radiance）用的非常多。在下图所示的场景中，辐射照度表示<span class="math inline">\(dA\)</span> 接收的所有能量；辐射亮度表示<span class="math inline">\(dA\)</span>从某个方向接收的能量。相比而言，辐射亮度是一个更细粒度的分析属性。这样，我们就把辐射照度和辐射亮度联系起来了。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-12.png?x-oss-process=image/resize,w_800" /></p><p>对于上图所示的场景，我们可以计算得到某个位置的辐射照度，如下所示，其中<span class="math inline">\(H^2\)</span> 表示单位半球面积。</p><span class="math display">\[\begin{aligned}dE(p, \omega) = &amp;L_{i}(p, \omega) cos\theta d\omega\\E(p) = &amp;\int_{H^2} L_{i}(p, \omega) cos\theta d{\omega}\end{aligned}\]</span><h1 id="应用">应用</h1><h2 id="双反射分布函数">双反射分布函数</h2><p>已知入射光线的能量和角度，当辐射到物体表面后，光线会向各个角度反射，且各个角度反射的能量是不同的。双反射分布函数（BidirectionalReflectance DistributionFunction，BRDF）就是用于计算这种场景下各个角度的反射能量。</p><p>如下所示，是一个入射和反射的场景，我们从辐射度量学的角度分别进行分析。</p><ul><li>入射阶段：当入射光线从 <spanclass="math inline">\({\omega}_i\)</span>角度辐射到物体表面的一个位置时，可以认为该位置吸收了所有的光线能量，用辐射照度来表示，即<span class="math inline">\(dE({\omega}_i)\)</span>。</li><li>反射阶段：可以认为该位置将光线能量向各个方向进行辐射。对于方向 <spanclass="math inline">\({\omega}_i\)</span>的光线能量，用辐射亮度来表示，即 <span class="math inline">\(dL_r(x,{\omega}_r)\)</span>。</li></ul><span class="math display">\[\begin{aligned}dE({\omega}_i) = &amp;L({\omega}_i) cos{\theta}_i d{\omega}_i\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-13.png?x-oss-process=image/resize,w_800" /></p><p>本质上，BRDF 就是表示由入射方向 <spanclass="math inline">\({\omega}_i\)</span> 向反射方向 <spanclass="math inline">\({\omega}_r\)</span> 辐射能量的比例函数 <spanclass="math inline">\(fr({\omega}_i \rightarrow{\omega}_r)\)</span>，其定义如下所示。</p><span class="math display">\[\begin{aligned}BRDF: f_r({\omega}_i \rightarrow {\omega}_r) =\frac{dL_r({\omega}_r)}{dE_i({\omega}_i)} =\frac{dL_r({\omega}_r)}{L_i({\omega}_i) cos{\theta}_i d{\omega}_i}\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-14.png?x-oss-process=image/resize,w_800" /></p><p>在实际应用中，对于镜面反射，BRDF定义反射方向包含所有能量，其他方向均为 0；对于漫反射，BRDF定义所有方向的能量分布相同。事实上，BRDF就是描述了光线和物体表面的作用，也就是决定了物体的材质。</p><h2 id="反射方程">反射方程</h2><p>基于 BRDF，我们可以进一步推导出 <strong>反射方程</strong>（TheReflection Equation）。</p><p>由于 BRDF 定义了一个入射方向 <spanclass="math inline">\({\omega}_i\)</span> 向一个反射方向 <spanclass="math inline">\({\omega}_r\)</span>反射时的能量比例。那么，我们可以通过积分计算所有方向对一个反射方向 <spanclass="math inline">\({\omega}_r\)</span>的能量聚合。因此，我们可以推导得出如下所示的反射方程。</p><span class="math display">\[\begin{aligned}L_r(p, {\omega}_r) = \int_{H^2}f_r(p, {\omega}_i \rightarrow {\omega}_r)L_i(p, {\omega}_i) cos{\theta}_i d{\omega}_i\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/radiometry-14.png?x-oss-process=image/resize,w_800" /></p><h2 id="渲染方程">渲染方程</h2><p>基于反射方程，我们还可以进一步推导出 <strong>渲染方程</strong>（TheRendering Equation）。</p><p>这里我们只需要额外考虑物体本身会发光的情况，于是增加一个发光项即可得到渲染方程，如下所示。其中，<spanclass="math inline">\(cos{\theta}_i\)</span>转换成了法向量和入射方向的点积 <span class="math inline">\(n \cdot{\omega}_i\)</span>。现代图形学中，所有基于表面反射的渲染都是基于该渲染方程实现的。</p><span class="math display">\[\begin{aligned}L_r(p, {\omega}_r) = L_e(p, {\omega}_r) + \int_{H^2} L_i(p, {\omega}_i)f_r(p, {\omega}_i, {\omega}_r)(n \cdot {\omega}_i) d{\omega}_i\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文我们主要介绍了辐射度量学中的几个概念：辐射能量、辐射通量、辐射强度、辐射照度、辐射亮度等。基于这些概念，我们引入了BRDF 的定义。然后依次推导出反射方程和渲染方程。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在介绍光线追踪之前，我们先来学习一下其所涉及的重要内容——辐射度量学。由于该内容相对独立，这里单开一篇文章来进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Radiance" scheme="http://chuquan.me/tags/Radiance/"/>
    
    <category term="Irradiance" scheme="http://chuquan.me/tags/Irradiance/"/>
    
    <category term="Intensity" scheme="http://chuquan.me/tags/Intensity/"/>
    
    <category term="立体角" scheme="http://chuquan.me/tags/%E7%AB%8B%E4%BD%93%E8%A7%92/"/>
    
    <category term="微分立体角" scheme="http://chuquan.me/tags/%E5%BE%AE%E5%88%86%E7%AB%8B%E4%BD%93%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（6）——几何</title>
    <link href="http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/"/>
    <id>http://chuquan.me/2024/04/10/foundation-of-computer-graphic-06/</id>
    <published>2024-04-10T15:10:24.000Z</published>
    <updated>2024-04-11T01:02:20.747Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们介绍了观测变换、光栅化、着色等几个图形学中比较复杂的主题，本文我们稍微放松一下，介绍一个相对比较简单的主题——几何。</p><span id="more"></span><h1 id="几何表示">几何表示</h1><p>通过图形学建模表示现实生活中的各种物体，要解决的第一个问题就是如何定义物体形状，而这就涉及到了几何。</p><p>物体的形状非常多，那么如何通过几何方法表示物体呢？对此，图形学中定义了两种几何表示方法：</p><ul><li><strong>隐式几何表示</strong>（Implicit Representations ofGeometry）</li><li><strong>显示几何表示</strong>（Explicit Representations ofGeometry）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-01.png?x-oss-process=image/resize,w_800" /></p><h2 id="隐式几何表示">隐式几何表示</h2><p>隐式几何表示是一种 <strong>使用数学关系式来描述几何形状</strong>的方法，而不是直接描述其顶点和边界等元素。在隐式几何表示法中，几何形状被定义为方程的解集，即满足某些条件的一组点的集合。比如，下面的关系式定义了一个圆环结构。</p><span class="math display">\[\begin{aligned}f(x, y, z) = (2 - \sqrt{x^2 + y^2})^2 + z^2 - 1\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-02.png?x-oss-process=image/resize,w_800" /></p><p>隐式几何表示的常用技术有以下这些：</p><ul><li><strong>代数曲面</strong>（Algebraic Surface）</li><li><strong>构造实体几何</strong>（Constructive Solid Geometry）</li><li><strong>距离函数</strong>（Distance Function）</li><li><strong>水平集</strong>（Level Set）</li><li><strong>分形</strong>（Fractals）</li></ul><p>下面，我们来介绍一下这些常用的隐式几何表示技术。</p><h3 id="代数曲面">代数曲面</h3><p>代数曲面是通过一组参数方程定义的曲线和表面。它适用于一些简单的，可以使用数学关系式表示的几何体。下图所示，这些几何体就比较适合使用代数曲面来表示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-04.png?x-oss-process=image/resize,w_800" /></p><h3 id="构造实体几何">构造实体几何</h3><p>构造实体几何是通过布尔运算来组合不同的几何体。下图所示，一些复杂的几何体可以通过简单的几何体来组合构造。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-05.png?x-oss-process=image/resize,w_800" /></p><h3 id="距离函数">距离函数</h3><p>距离函数描述空间中任何一个点到几何体表面的最小距离。一种特殊的距离函数，符号距离函数（SignedDistanceFunction），其以空间中任意一个点作为输入，根据距离函数的返回值，可以进行判断：</p><ul><li>当距离函数的值大于 0，表示点在几何体外部</li><li>当距离函数的值小于 0，表示点在几何体内部</li><li>当距离函数的值等于 0，表示点在几何体表面</li></ul><h3 id="水平集">水平集</h3><p>对于表面规则的几何体，我们可以使用距离函数来表示；对于表面复杂的几何体，距离函数难以适用，此时，我们可以使用水平集来表示。</p><p>水平集的核心思想与距离函数一样，区别在于：距离函数使用通过输入空间点来计算该点到几何体表面的距离，水平集则存储了一系列距离值，我们可以通过插值法找到距离为0 的位置，拟合出一条曲面用于表示几何体的表面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-06.png?x-oss-process=image/resize,w_800" /></p><h3 id="分形">分形</h3><p>分形，类似于递归，即局部和整体的形状相似，如下图所示。分形通过迭代函数系统（IFS）来生成。IFS是一种迭代的过程，该过程将函数反复应用于某个起始点或起始数据。这些函数通常是缩放、旋转、平移等操作，同时保持自相似性。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-07.png?x-oss-process=image/resize,w_800" /></p><!--缺点：难以判断哪些点属于关系式--><!--优点：容易判断点是否在几何的表面--><h2 id="显示几何表示">显示几何表示</h2><p>显式几何表示是一种<strong>直接或间接（通过参数映射的方式）定义点、线、面等元素集合</strong>的方法。在显式几何表示中，各元素的位置通常由坐标值直接给出，各元素之间的关系通常由数据结构来表示。比如，下面的关系式通过参数映射的方式间接定义了点的集合。</p><span class="math display">\[\begin{aligned}f: R^2 \rightarrow &amp;R^3\\(u, v) \rightarrow &amp;(x, y, z)\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-03.png?x-oss-process=image/resize,w_800" /></p><p>显式几何表示的常用技术有以下这些：</p><ul><li><strong>点云</strong>（Point Cloud）</li><li><strong>网格模型</strong>（Polygon Mesh）</li></ul><p>下面，我们来介绍一下这两种显式几何表示技术。</p><!--缺点：难以判断是否在内部或外部--><h3 id="点云">点云</h3><p>点云是显式几何表示中最简单的技术，其核心思想是使用大量的点来表示几何体的表面。点的密度越高，几何体的精度越高。由于点云的缺点很明显，内存占用大，因此一般会被再次转换成多边形网格。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-08.png?x-oss-process=image/resize,w_800" /></p><h3 id="多边形网格">多边形网格</h3><p>多边形网格是图形学中最常用的几何表示方法，它存储点和多边形（一般是三角形或四边形），这种形式非常容易处理、模拟、采样。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-09.png?x-oss-process=image/resize,w_800" /></p><p>在 3D 建模中，我们经常会用到 <code>.obj</code>格式的模型文件，其本质上是一个文本文件，记录了顶点、法线、纹理坐标、连接关系，由此构成几何体的形状。如下所示，是一个立方体结构的表示。</p><ul><li><code>v</code> 表示顶点</li><li><code>vn</code> 表示法线（多了两条是因为建模误差）</li><li><code>vt</code> 表示纹理坐标</li><li><code>f</code> 表示面，比如 <code>f 5/1/1 1/2/1 4/3/1</code>表示三角形面是由第 5、1、4 个顶点组成，三个点的纹理坐标是第 1、2、3对应的纹理坐标，面的法线是第 1 条法线。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-10.png?x-oss-process=image/resize,w_800" /></p><h1 id="曲线">曲线</h1><p>曲线（Curves）在图形学中应用非常广泛，比如：相机的拍摄路径、物体的移动路径、动画曲线、矢量字体等。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="贝塞尔曲线">贝塞尔曲线</h2><p>贝塞尔曲线是通过一系列控制点进行定义的曲线。如下图所示，4个控制点定义了一条贝塞尔曲线，起始方向沿着 <spanclass="math inline">\(p_0p_1\)</span>，结束方向沿着 <spanclass="math inline">\(p_2p_3\)</span>，曲线不必经过所有控制点，但必须经过起始点和结束点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-12.png?x-oss-process=image/resize,w_800" /></p><!--特性：--><!--- 必须过起点和终点--><!--- 仿射不变性--><!--- 凸包性质--><h3 id="绘制算法">绘制算法</h3><p>那么控制点是如何影响曲线的呢？贝塞尔曲线绘制算法的原理是什么呢？</p><p>贝塞尔曲线的绘制算法是 <strong>De Casteljau'sAlgorithm</strong>，算法的基本思想是利用线性插值的原理，将高阶贝塞尔曲线转化为一阶贝塞尔曲线的组合。对于一个N阶贝塞尔曲线，首先构建一系列的二维点，然后在这些点上构建线段，以此类推，直到计算出贝塞尔曲线上的一个点。重复这个过程就可以得到贝塞尔曲线上的所有点，从而绘制出完整的贝塞尔曲线。</p><p>下面，我们以 3 个控制点绘制贝塞尔曲线的例子来进行介绍。</p><p>N 个控制点绘制的贝塞尔曲线，称为 <strong>N-1阶贝塞尔曲线</strong>。如下所示，我们定义了 3个控制点，由此绘制的贝塞尔曲线称之为<strong>二阶贝塞尔曲线</strong>（Quadratic Bezier）。对于这 3个控制点，我们首先对相邻控制点进行连线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-13.png?x-oss-process=image/resize,w_800" /></p><p>我们定义一个变量 <code>t</code>，其值的范围为<code>[0, 1]</code>，作为算法的输入值。当 <code>t = 0</code>时，表示贝塞尔曲线起始点的输入值，当 <code>t = 1</code>时，表示贝塞尔曲线结束点的输入值。随后，我们在控制点所构成的各个连线上定义一个点，这个点的位置取决于<code>t</code> 的值，即一个比例值。比如：<spanclass="math inline">\(b_0b_1\)</span> 连线上定义点 <spanclass="math inline">\(b_{0}^{1}\)</span>，<spanclass="math inline">\(b_1b_2\)</span> 连线上定义点 <spanclass="math inline">\(b_{1}^{1}\)</span>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-14.png?x-oss-process=image/resize,w_800" /></p><p>然后，我们继续对 <span class="math inline">\(b_{0}^{1}\)</span> 和<span class="math inline">\(b_{1}^{1}\)</span>进行连线，并按照上述规则，在 <spanclass="math inline">\(b_{0}^{1}b_{1}^{1}\)</span> 连线上定义点 <spanclass="math inline">\(b_{0}^{2}\)</span>，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-15.png?x-oss-process=image/resize,w_800" /></p><p>当新定义的点只有一个时，我们可以将 <code>t</code> 的值逐步从<code>0</code> 变到 <code>1</code>。在这个过程中，<spanclass="math inline">\(b_{0}^{1}\)</span>、<spanclass="math inline">\(b_{0}^{2}\)</span>、<spanclass="math inline">\(b_{1}^{1}\)</span> 的位置都会随着 <code>t</code>的变化而变化。对于最终的贝塞尔曲线，我们只需要关注最后定义的点 <spanclass="math inline">\(b_{0}^{2}\)</span> 的路径即可，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-16.png?x-oss-process=image/resize,w_800" /></p><p>当我们扩展至更多控制点时，比如 4个控制点时，我们仍然按照上述规则来处理，将高阶贝塞尔曲线转化为一阶贝塞尔曲线的组合，最终绘制曲线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-17.png?x-oss-process=image/resize,w_800" /></p><h3 id="代数公式">代数公式</h3><p>对于上述通过 3个控制点绘制贝塞尔曲线，我们可以用代数的方式来表示，如下所示。</p><span class="math display">\[\begin{aligned}b_{0}^{1}(t) = &amp;(1 - t)b_0 + tb_1\\b_{1}^{1}(t) = &amp;(1 - t)b_1 + tb_2\\b_{0}^{2}(t) = &amp;(1 - t)b_{0}^{1} + tb_{1}^{1}\\b_{0}^{2}(t) = &amp;(1 - t)^2b_0 + 2t(1 - t)b_1 + t^2b_2\end{aligned}\]</span><p>由此，我们可以推导出 N 阶贝塞尔曲线的代数公式，如下所示。其中，<spanclass="math inline">\(n\)</span> 表示 N 阶贝塞尔曲线，<spanclass="math inline">\(b_j\)</span> 表示控制点，<spanclass="math inline">\(B_i^n(t)\)</span> 为伯恩斯坦多项式（BernsteinPolynomials）。</p><span class="math display">\[\begin{aligned}b^n(t) = &amp;b_{0}^{n}(t) = \sum_{j=0}^{n}b_jB_{j}^{n}(t)\\B_i^n(t) = &amp;\left(\begin{matrix}n \\i \\\end{matrix}\right)t^i(1-t)^{n-i}\end{aligned}\]</span><h3 id="曲线性质">曲线性质</h3><p>贝塞尔曲线具有以下几个特性：</p><ul><li>一定过起点和终点。</li><li>不受仿射变换影响，受投影变换影响。</li><li>凸包（Convex Hull）性质：贝塞尔曲线在所有控制点的凸包范围内。</li></ul><h2 id="分段贝塞尔曲线">分段贝塞尔曲线</h2><p>根据贝塞尔曲线绘制算法，我们可以知道，改变任意一个控制点的位置都会影响整个贝塞尔曲线。因此，当控制点比较多时，我们很难进行精准的控制和调整。于是就有了分段贝塞尔曲线，即采用多条贝塞尔曲线进行串联。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-18.png?x-oss-process=image/resize,w_800" /></p><h1 id="曲面">曲面</h1><p>曲面（Surface）在图形学中应用同样非常广泛，可以用它来表示各种三维物体。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-19.png?x-oss-process=image/resize,w_800" /></p><h2 id="贝塞尔曲面">贝塞尔曲面</h2><p>贝塞尔曲线控制点都是在同一平面内，由此进行扩展，贝塞尔曲面的控制点则是分部在三维空间中。下图所示，展示了空间中4 x 4 个控制点所构成的贝塞尔曲面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-20.png?x-oss-process=image/resize,w_800" /></p><h3 id="绘制算法-1">绘制算法</h3><p>贝塞尔曲面的绘制算法本质上还是基于 De Casteljau's Algorithm进行多次绘制。以下图为例，首先基于预设的所有控制点（比如：4 x 4的控制点），绘制 4条贝塞尔曲线。然后在与曲线垂直的平面中开始绘制曲线，按照固定间距，以 4条贝塞尔曲线上的点作为控制点，绘制贝塞尔曲线。以此类推，最终得到一个贝塞尔曲面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-21.png?x-oss-process=image/resize,w_800" /></p><h2 id="曲面处理">曲面处理</h2><p>根据上述绘制算法，我们可以得到基于多边形网格的曲面。在实际应用中，我们会对曲面进行进一步的处理。常见的曲面处理操作有以下两种：</p><ul><li><strong>网格细分</strong>（Mesh Subdivision）</li><li><strong>网格简化</strong>（Mesh Simplification）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-22.png?x-oss-process=image/resize,w_800" /></p><h3 id="网格细分">网格细分</h3><p>网格细分就是把一个多边形拆分成多个多边形。这里我们介绍两种细分算法：Loop细分和 Catmull-Clark 细分。</p><h4 id="loop-细分">Loop 细分</h4><p>Loop 细分只适用于三角形面的细分，具体可以分为两步：</p><ul><li>将一个三角形拆分成四个三角形</li><li>更新新顶点和旧顶点的位置，使模型变得更加光滑</li></ul><p>三角形的拆分非常简单，连接每条边的中点，即可将拆分成四个三角形，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-23.png?x-oss-process=image/resize,w_800" /></p><p>对于新顶点的更新，它会基于周围四个旧顶点求加权平均，离它近的顶点权重大，设为3/8，离它远的顶点权重小，设为 1/8，如下所示，白点为待更新的新顶点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-24.png?x-oss-process=image/resize,w_800" /></p><p>对于旧顶点的更新，它会基于周围几个旧顶点求加权平均，其中各个点的权重值与待更新点的度（Degree）有关，最终可以得到如下所示的更新方法。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-25.png?x-oss-process=image/resize,w_800" /></p><p>Loop 细分只针对三角形面进行细分，整体效果如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-29.png?x-oss-process=image/resize,w_800" /></p><h4 id="catmull-clark-细分">Catmull-Clark 细分</h4><p>相比对 Loop 细分，Catmull-Clark细分是一种更加通用的细分方法，适用于各种多边形网格曲面。Catmull-Clark细分涉及到一个概念 <strong>奇异点</strong>（ExtraordinaryVertex），即度不为 4 的点。</p><p>Catmull-Clark 细分的第一步同样是拆分多边形，主要包含以下几点：</p><ul><li>对于边，取其中点；对于面，也取其一个点（比如：重心）</li><li>连接边的中点和面的中点</li></ul><p>我们可以发现，当对非四边形进行一次细分后，所有的非四边形都消失了。不过，一次细分后，会引入两个新的奇异点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-26.png?x-oss-process=image/resize,w_800" /></p><p>对于新顶点的更新，可以分为两种情况，分别边上的点和面中的点，其规则如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-27.png?x-oss-process=image/resize,w_800" /></p><p>对于旧顶点的更新，其更新规则如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-28.png?x-oss-process=image/resize,w_800" /></p><p>Catmull-Clark 适用于任何多边形网格面，整体效果如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-30.png?x-oss-process=image/resize,w_800" /></p><h3 id="网格简化">网格简化</h3><p>网格简化与网格细分正好相反，其目的是为了减少三角形数量，从而提升性能。对于近的物体三角形多，远的物体三角形少。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-31.png?x-oss-process=image/resize,w_800" /></p><p>网格简化是通过 <strong>边坍缩</strong>（EdgeCollapse）实现的，它会减少边的数量，并更新相关顶点的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-32.png?x-oss-process=image/resize,w_800" /></p><p>那么边坍缩的底层依据是什么呢？这里涉及到<strong>二次度量误差</strong>（Quadirc ErrorMetrics）的概念。二次度量误差用来表示网格简化带来的误差大小，其计算方法是新顶点与它关联的面的垂直距离的平方和，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/geometry-33.png?x-oss-process=image/resize,w_800" /></p><p>当删除一条边时，我们会引入一个新的顶点，当新顶点调整至二次度量误差最小时，我们将其设置为边坍缩后的新顶点。利用这种贪心思想，就能实现网格简化。</p><h1 id="总结">总结</h1><p>本文我们主要介绍了计算机图形学中的几何相关部分。首先，我们介绍了几何的几种表示方法：隐式几何表示和显式集合表示，两者各自又有着很多实现方法。</p><p>然后，我们介绍了曲线，特别是贝塞尔曲线，详细介绍了其绘制算法 DeCasteljau's Algorithm。由此延伸值曲面的绘制，特别是贝塞尔曲面。</p><p>最后，我们介绍了曲面的两种常见的处理方式：网格细分和网格简化。</p><p>至此，几何相关的内容均已介绍完毕。后续，我们将探讨光线追踪渲染器的相关内容。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面我们介绍了观测变换、光栅化、着色等几个图形学中比较复杂的主题，本文我们稍微放松一下，介绍一个相对比较简单的主题——几何。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="几何" scheme="http://chuquan.me/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="Loop Subdivision" scheme="http://chuquan.me/tags/Loop-Subdivision/"/>
    
    <category term="Catmull-Clark Subdivision" scheme="http://chuquan.me/tags/Catmull-Clark-Subdivision/"/>
    
    <category term="贝塞尔曲线" scheme="http://chuquan.me/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    
    <category term="De Casteljau&#39;s Algorithm" scheme="http://chuquan.me/tags/De-Casteljau-s-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（5）——着色</title>
    <link href="http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/"/>
    <id>http://chuquan.me/2024/04/05/foundation-of-computer-graphic-05/</id>
    <published>2024-04-05T07:52:33.000Z</published>
    <updated>2024-04-06T03:22:26.023Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <ahref="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">文章</a>我们介绍了光栅化所涉及的基本内容。通过光栅化，我们可以实现将 3D空间模型的投影绘制到 2D屏幕。然而，仅仅实现光栅化，还不足以让渲染结果具有真实感，如下图左部所示。我们希望能够模拟光线所带来的的明暗效果，如下图右部所示。</p><span id="more"></span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-01.png?x-oss-process=image/resize,w_800" /></p><p>在计算机图形学中，<strong>着色</strong>（Shading）就是通过计算来决定三维模型表面每个像素的颜色和亮度的过程。本质而言，着色就是<strong>对不同物体应用不同材质</strong>。</p><h1 id="着色模型">着色模型</h1><h2 id="着色局部性">着色局部性</h2><p>具体分析着色时，我们会分析光线照射到物体表面的每一个点，也称<strong>着色点</strong>（ShadingPoint）。对于每个着色点，我们将其视为一个微平面（或称单位平面），由此我们可以构建法线。整体而言，着色的最终结果受以下几种输入影响，分别是：</p><ul><li>观测方向 <span class="math inline">\(v\)</span></li><li>表面法向 <span class="math inline">\(n\)</span></li><li>光线方向 <span class="math inline">\(l\)</span></li><li>表面参数，如：颜色、材质。</li></ul><blockquote><p>注意：对于着色过程，我们只考虑光照对于物体表面的影响，而不考虑其他物体的阴影对本物体产生的影响。</p></blockquote><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-03.png?x-oss-process=image/resize,w_800" /></p><h2 id="布林-冯反射模型">布林-冯反射模型</h2><p>关于光线与物体表面的作用，根据我们的认知，其实可以分为三种类型：</p><ul><li><strong>漫反射</strong>（Diffuse）</li><li><strong>高光</strong>（Specular）</li><li><strong>环境光</strong>（Ambient）</li></ul><p>在计算机图形学中，有一种广泛使用的光照和颜色计算模型——<strong>布林-冯反射模型</strong>（Blinn-PhongRelectanceModel），其考虑了上述三种光照的叠加效果对物体表面颜色的影响。</p><p>下面，我们分别来介绍这三种光照类型。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-02.png?x-oss-process=image/resize,w_800" /></p><h3 id="漫反射">漫反射</h3><p>当光线照射到一个点时，光线会向各个方向发生反射，这种现象称为<strong>漫反射</strong>。漫反射的反射光强主要受到光照角度、光照强度、漫反射系数等因素的影响。</p><h4 id="光照角度">光照角度</h4><p>在图形学中，<strong>兰伯特余弦定理</strong>（Lambert's cosinelaw）详细描述了光照角度对于表面接收光照照射量的影响。下图所示，列举了三种光照角度。</p><ul><li>情况一，入射角度为 <spanclass="math inline">\(90^{\circ}\)</span>，单位平面会接收全部光照。</li><li>情况二，入射角度为 <spanclass="math inline">\(30^{\circ}\)</span>，单位平面只会接收到一半光照。</li><li>情况三，入射角度为 <spanclass="math inline">\(90^{\circ}-\theta\)</span>，单位平面接收到的光照占全部光照的比例为<span class="math inline">\(cos{\theta} = \hat{l} \cdot\hat{n}\)</span>。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-04.png?x-oss-process=image/resize,w_800" /></p><p>基于兰伯特余弦定理，我们可以推导出一个函数表示单位平面接收的光照照射量占全部光照的比例，如下所示。由于<span class="math inline">\(cos\theta\)</span>可能会负数，但这没有意义，所以我们使用 <spanclass="math inline">\(max(0, cos\theta)\)</span> 来保证其值大于等于0。</p><span class="math display">\[\begin{aligned}f(\theta) = max(0, cos\theta) = max(0, \hat{l} \cdot \hat{n})\end{aligned}\]</span><h4 id="光照强度">光照强度</h4><p>对于光照强度，我们考虑如下所示 3D空间中的一个点光源。根据能量守恒定理，以光源为球心，任意距离为半径的球体，球面所覆盖的光线强度是相等的。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-34.png?x-oss-process=image/resize,w_800" /></p><p>由此，我们可以推导光照强度与光源距离之间的关系。假设半径 <spanclass="math inline">\(r\)</span> 为 <code>1</code>时，球面一个点的光照强度为 <spanclass="math inline">\(I\)</span>。那么当半径为任意值 <spanclass="math inline">\(r\)</span> 时，我们可以根据能量守恒定理得到：</p><span class="math display">\[\begin{aligned}单位球面光照强度：&amp;4{\pi}I\\任意球面光照强度：&amp;4{\pi}r^2I_r\\根据能量守恒定理：&amp;4{\pi}r^2I_r = 4{\pi}I\\任意点的光照强度：&amp;I_r=I/r^2\end{aligned}\]</span><h4 id="漫反射系数">漫反射系数</h4><p>不同的材质具有不同的漫反射系数，我们将漫反射系数定义为 <spanclass="math inline">\(k_d\)</span>。如下所示，<spanclass="math inline">\(k_d\)</span>越大，反射的光线强度越大，看到的物体越亮。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-05.png?x-oss-process=image/resize,w_800" /></p><h4 id="漫反射公式">漫反射公式</h4><p>漫反射光线的计算公式其实就是由上述三部分组成，如下所示。</p><span class="math display">\[\begin{aligned}L_d = k_d(I/r^2)max(0, \hat{l} \cdot \hat{n})\end{aligned}\]</span><h3 id="高光">高光</h3><p>高光反射，当观测向量趋近于光线的反射向量时，我们可以看到镜面反射所产生的高光，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-06.png?x-oss-process=image/resize,w_800" /></p><h4 id="高光区域">高光区域</h4><p>那么如何判断高光区域呢？我们可以通过计算光照方向向量和观测方向向量之间的<strong>半程向量</strong>（HalfVector）。然后再计算半程向量与平面法线之间的夹角，判断两者是否接近。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-07.png?x-oss-process=image/resize,w_800" /></p><p>如下所示为半程向量的计算公式，有了半程向量之后，我们可以计算法向量与半程向量之间的夹角。</p><span class="math display">\[\begin{aligned}\hat{h} = bisector(\hat{v}, \hat{l}) = \frac{\hat{v} + \hat{l}}{|\hat{v}+ \hat{l}|}\end{aligned}\]</span><h4 id="高光突变">高光突变</h4><p>根据日常经验，我们可以发现当法向量与半程向量之间的夹角大于某个阈值之后，高光效应会发生突变。如果我们使用<span class="math inline">\(cos\theta\)</span>来描述这种突变，显示是不合适的。在布林-冯模型中，我们对 <spanclass="math inline">\(cos^p\theta\)</span> 来描述高光突变，其中 <spanclass="math inline">\(p\)</span> 是一个经验值。下图所示，展示了不同<span class="math inline">\(p\)</span> 值随角度变化的曲线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-08.png?x-oss-process=image/resize,w_800" /></p><h4 id="高光系数">高光系数</h4><p>类似于漫反射系数，对于高光，这里也有一个高光系数，使用 <spanclass="math inline">\(k_s\)</span> 表示。下图所示为不同 <spanclass="math inline">\(k_s\)</span> 和不同 <spanclass="math inline">\(p\)</span>的情况下，高光效果的对比。可以看出，高光系数越大，观测的效果越明亮。高光突变的<span class="math inline">\(p\)</span> 值越大，高光区域则越小。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-09.png?x-oss-process=image/resize,w_800" /></p><h4 id="高光公式">高光公式</h4><p>高光的计算公式其实也是由三部分组成：高光系数、光线强度、高光突变，具体公式如下所示。</p><span class="math display">\[\begin{aligned}L_s = k_s(I/r^2)max(0, \hat{n} \cdot \hat{h})^p\end{aligned}\]</span><h3 id="环境光">环境光</h3><p>在现实世界中，我们知道即使没有光源直接照射物体，物体也并不是完全是黑色的。对此，布林-冯着色模型也近似处理了这种情况，即环境光。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-10.png?x-oss-process=image/resize,w_800" /></p><h4 id="环境光公式">环境光公式</h4><p>环境光的计算公式非常简单，由环境光系数和环境光强度组成，具体公式如下所示。</p><span class="math display">\[\begin{aligned}L_a = k_aI_a\end{aligned}\]</span><h3 id="光线反射公式">光线反射公式</h3><p>布林-冯反射模型定义了一个光线反射公式，该公式由上述三种光照反射类型的计算公式组合，具体公式如下所示。</p><span class="math display">\[\begin{aligned}L = L_a + L_d + L_s = k_aI_a + k_d(I/r^2)max(0, \hat{n} \cdot \hat{l}) +k_s(I/r^2)max(0, \hat{n} \cdot \hat{h})^p\end{aligned}\]</span><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-11.png?x-oss-process=image/resize,w_800" /></p><h1 id="着色频率">着色频率</h1><p>在布林-冯反射模型中，我们以着色点（单位平面）为单位介绍三种光照反射类型。那么在真实着色过程中，以什么为单位进行着色呢？考虑到着色性能的开销，实际上可以分为三种类型，分别是：</p><ul><li><strong>平面着色</strong>（Flat Shading）</li><li><strong>顶点着色</strong>（Gouraud Shading）</li><li><strong>像素着色</strong>（冯-着色，Phong Shading）</li></ul><h2 id="平面着色">平面着色</h2><p>平面着色会对每一个平面做一次着色。相对而言，着色频率低，性能开销小，但是着色效果不够丝滑，会有明显的棱边效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-12.png?x-oss-process=image/resize,w_800" /></p><p>在布林-冯反射模型中，着色点的法向量是计算着色的关键变量。对于平面着色而言，我们可以通过三角形的任意两条边所构成的向量，计算叉积，即可得到法向量。</p><h2 id="顶点着色">顶点着色</h2><p>顶点着色会对三角形的三个顶点进行着色。对于三角形内部的点，则基于三个顶点的颜色，使用速度更快的插值法进行计算。相比平面着色，着色频率略高，性能开销略大，但是着色效果会好一点，会有细微的棱边效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-13.png?x-oss-process=image/resize,w_800" /></p><p>对于顶点着色，我们需要计算三个顶点各自的法向量。通常有两种选择：</p><ul><li>当平面属于一个规则几何体的局部表面时，可以通过规则几何体的整体出发，计算对应平面的法向量。</li><li>其他情况时，可以基于周围平面的法向量，求解平均值，计算对应平面的法向量。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-15.png?x-oss-process=image/resize,w_800" /></p><h2 id="像素着色">像素着色</h2><p>像素着色，也称冯-着色，它会对每一个像素进行着色。这种方式着色频率很高，性能开销很大，但是着色效果非常丝滑。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-14.png?x-oss-process=image/resize,w_800" /></p><p>对于像素着色，我们首先以上述方式计算三角形顶点的法向量，对于三角形内部的点，则通过<strong>重心插值法</strong>（BarycentricInterpolation）来计算。关于重心插值法，我们稍后进行介绍。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-16.png?x-oss-process=image/resize,w_800" /></p><h1 id="实时渲染管线">实时渲染管线</h1><p>实时渲染管线（Real-time Rendering），也称图形管线（GraphicsPipeline），其描述了 3D 场景转换成 2D 图像的完整流程，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-17.png?x-oss-process=image/resize,w_800" /></p><p>实时渲染管线可以分为五个阶段，分别是：</p><ul><li><strong>顶点处理</strong>（Vertex Processing）</li><li><strong>三角形处理</strong>（Triangle Processing）</li><li><strong>光栅化</strong>（Rasterization）</li><li><strong>片段处理</strong>（Fragment Processing）</li><li><strong>帧缓冲操作</strong>（Framebuffer Operations）</li></ul><h2 id="顶点处理">顶点处理</h2><p>顶点处理的输入是 3D 空间中的顶点。为什么是顶点而不是 3D模型？这是因为 3D空间的所有模型都是以三角形为基本单元进行表示的，而三角形则可以通过顶点和连线来描述，3D模型的本质就是大量顶点和连线的定义。</p><p>在顶点处理阶段，我们会对顶点进行观测变换，即 <ahref="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">《计算机图形学基础（3）——观测变换》</a>中所介绍的 MVP 变换。最终输出经过观测变换的顶点。</p><h2 id="三角形处理">三角形处理</h2><p>在某些文章中，会将这个阶段定义成 <strong>图元处理</strong>（PrimitiveProcessing），三角形处理只是其中的一个子集，它还会处理点和线。这里我们为了突出重点，将其称为三角形处理。</p><p>由于顶点处理阶段只对顶点进行变换，而 3D模型还包括连线的定义，三角形处理阶段就是根据连线的定义，将顶点装配成三角形（也称图元）。</p><h2 id="光栅化">光栅化</h2><p>当顶点处理和三角形处理完成之后，我们得到了经过观测变换后的三角形。此时三角形仍然处于3D 空间中，不过我们可以通过正交投影快速获取它们在 2D 空间中的投影。</p><p>光栅化则是将连续的 2D 投影进行采样，转换成离散的 2D投影，这是因为屏幕由一个离散的二维像素矩阵所构成。关于光栅化具体要做的事情以及可能遇到的问题，我们在<ahref="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">《计算机图形学（4）——光栅化》</a>中进行了详细的介绍。</p><p>在实际的 GPU设计中，为了支持可编程、并行计算，实时渲染管线中的光栅化的主要任务是对连续的图形进行采样，使其离散化。</p><h2 id="片段处理">片段处理</h2><p>片段处理，也称像素处理，它会对每个片段的颜色、纹理坐标、深度值等进行计算，期间会大量应用插值法进行计算。严格意义上说，片段处理也属于光栅化的一部分。</p><h2 id="帧缓冲操作">帧缓冲操作</h2><p>帧缓冲操作包含了颜色混合、模板测试、深度测试、透明度检查等一系列操作，最终结果会保存在帧缓冲区，显示器会定时读取帧缓冲区，并将内容呈现在屏幕上。</p><h2 id="关于着色">关于着色</h2><p>整体而言，实时渲染管线包含观测变换、光栅化、着色三大部分。</p><p>然而，着色其实在顶点处理和片段处理阶段都可以存在，这取决于着色频率。如果我们采用顶点着色，那么着色可以发生在顶点处理阶段；如果我们采用像素着色，那么着色可以发生在片段处理阶段。</p><p>在现代 GPU中，实时渲染管线的部分阶段是支持可编程的，比如顶点处理阶段和片段处理阶段。在这些可编程阶段中，我们可以编写着色器（Shader）程序，从而生成自定义的着色结果。</p><h3 id="着色器">着色器</h3><p>在实时渲染领域，大部分从业者做的事情就是在写各种各样的着色器。如下所示，是OpenGL 中的一个片段着色器程序，其采用 GLSL着色语言编写。着色器程序最终由 GPU调用，对于每个像素都会执行并生成着色结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D myTexture;    <span class="comment">// program parameter</span></span><br><span class="line">uniform vec3 lightDir;          <span class="comment">// program parameter</span></span><br><span class="line">varying vec2 uv;                <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line">varying vec3 norm;              <span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">diffuseShader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vec3 kd;                                </span><br><span class="line">    kd = <span class="built_in">texture2d</span>(myTexture, uv);                  <span class="comment">// material color from texture</span></span><br><span class="line">    kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);    <span class="comment">// Lambertian shading model</span></span><br><span class="line">    gl_FragColor = <span class="built_in">vec4</span>(kd, <span class="number">1.0</span>);                   <span class="comment">// output fragment color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纹理">纹理</h1><p>在介绍着色模型中，我们提到着色点的材质会影响最终的着色结果，比如各种反射系数<span class="math inline">\(k_d\)</span>、<spanclass="math inline">\(k_s\)</span>、<spanclass="math inline">\(k_a\)</span>等。除此之外，着色点的原始颜色、法线等属性也都会影响着色结果。</p><p>为了能够为着色点定义属性，提出了<strong>纹理</strong>（Texture）的概念，使用纹理来记录每个着色点的各种属性。通常情况下，我们会把纹理等同于贴图（图片），这是因为大多数情况下会使用纹理来定义颜色。不过从严格意义上说，贴图只是纹理的一种而已。</p><h2 id="纹理映射">纹理映射</h2><p>纹理映射的本质就是将纹理定义的属性映射到 3D 模型的各个着色点。</p><p>如下图所示，我们定义了一个模型和一个纹理，中间的模型经过纹理映射后渲染得到了我们期望的效果。在建模时，我们会将模型分割成一个个三角形。与模型所绑定的纹理，我们也会将其分割成一个个三角形。两者之间的三角形会一一对应。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-18.png?x-oss-process=image/resize,w_800" /></p><p>为了方便映射，我们会建立 <strong>纹理坐标系</strong>（TextureCoordinate），横坐标用 <span class="math inline">\(u\)</span>表示，纵坐标用 <span class="math inline">\(v\)</span> 表示。<spanclass="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 的值都在 <code>[0, 1]</code>之间，这是一个约定俗成的规定。模型中的每个顶点都会设定一个纹理坐标，通过这种方式可以实现纹理映射。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-19.png?x-oss-process=image/resize,w_800" /></p><h2 id="重心坐标">重心坐标</h2><p>虽然模型和纹理是绑定的，但是绑定是基于顶点实现的。因此在纹理映射中，对于模型三角形的顶点，我们可以直接使用绑定的纹理坐标找到纹理中对应坐标的属性。但是模型三角形内部的点该如何获取纹理属性呢？为了解决这个问题，提出了<strong>重心坐标</strong>（Barycentric Coordinate）的概念。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-20.png?x-oss-process=image/resize,w_800" /></p><p>以上图中的三角形为例，重心坐标定义了三角形内部任意一个点 <spanclass="math inline">\((x, y)\)</span> 具有以下几个特性。</p><span class="math display">\[\begin{aligned}\begin{cases}(x, y) = {\alpha}A + {\beta}B + {\gamma}C\\\alpha + \beta + \gamma = 1\\\alpha &gt;= 0;\beta &gt;= 0;\gamma &gt;= 0;\end{cases}\end{aligned}\]</span><p>最终，我们可以计算得到三角形内任意一个点的重心坐标 <spanclass="math inline">\((\alpha, \beta,\gamma)\)</span>。此时，我们可以使用重心坐标，结合顶点属性，计算得到该点的属性。这里的属性可以是位置、纹理坐标、颜色、法线、深度、材质等各种属性。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-21.png?x-oss-process=image/resize,w_800" /></p><p>需要注意的是，在投影时三角形的形状会发生变化，所以在着色时应该基于三维空间的坐标计算重心坐标，然后再做插值。</p><h2 id="纹理查询">纹理查询</h2><p>上面我们介绍了使用重心坐标表示三角形中的任意点。那么具体该如何应用重心坐标来查找对应的纹理属性呢？如下所示，我们使用伪代码描述了这个查找过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each rasterized screen <span class="title">sample</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    (u, v) = evaluate texture coordinate <span class="built_in">at</span> (x, y)</span><br><span class="line">    texcolor = texture.<span class="built_in">sample</span>(u, v)</span><br><span class="line">    set sample<span class="number">&#x27;</span>s color to texcolor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先说明一个前提：在光栅化阶段，即当三角形被转换为屏幕上的像素时，每个像素的纹理坐标会通过插值方式在三角形的顶点之间计算出来。此时，我们得到的是每个像素的屏幕坐标以及对应的纹理坐标。</p><p>上述伪代码所描述的流程是：</p><ul><li>遍历光栅化得到的屏幕采样点，比如一个三角形 <spanclass="math inline">\(ABC\)</span> 的区域内的某个像素点 <spanclass="math inline">\((x, y)\)</span>。</li><li>基于上述前提，有了像素的屏幕坐标 <span class="math inline">\((x,y)\)</span>，我们可以直接获取对应的纹理坐标。</li><li>当得到像素点的纹理坐标后，我们就可以在纹理中查找对应的属性，伪代码中查找的是颜色属性。</li><li>最后我们用纹理颜色来给像素着色。</li></ul><p>本质上，这是一个纹理采样过程。一旦涉及采样，就可能会出现走样问题。下面，我们来分情况讨论。</p><h3 id="纹理太小问题">纹理太小问题</h3><p>对于纹理太小的情况，那么会出现多个像素映射到一个<strong>纹素</strong>（Texel），即纹理中的一个点或像素。此时，就会出现锯齿问题。</p><p>为了解决锯齿问题，我们可以通过求均值的方式来解决。如下所示，为最近采样、双线性插值、双三次插值的对比结果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-22.png?x-oss-process=image/resize,w_800" /></p><p>双线性插值的原理非常简单，就是去临近的 4个像素，通过三次插值计算得到一个颜色平均值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-23.png?x-oss-process=image/resize,w_800" /></p><p>双三次插值的原理与双线性插值类似，区别在于前者使用周围的 16个像素求插值，后者使用周围的 4 个像素求插值。</p><h3 id="纹理太大问题">纹理太大问题</h3><p>对于纹理太大的情况，会出现摩尔纹、锯齿等情况。本质上是采样频率低于信号频率，我们在<ahref="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/">计算机图形学基础（4）——光栅化</a>中介绍过两种解决思路，一种是超采样，一种是过滤高频信号。</p><p>这两种思路，在这种场景下都存在开销过大的问题。于是，在图形学中提出了范围查询的方法，即<strong>Mipmap</strong>，从而避开了采样所带来的问题。</p><h4 id="点查询-范围查询">点查询 &amp; 范围查询</h4><p>本质上，采样就是点查询。当纹理太大时，屏幕上一个点对应到纹理上可能是一个很大的区域。然而，从这个区域中取一个点来代表整个区域的颜色，这显然是不合适的。对比而言，范围查询相当于提前计算出一个合适的值来代表这个区域。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-24.png?x-oss-process=image/resize,w_800" /></p><h4 id="mipmap">Mipmap</h4><p>Mipmap正是范围查询的一种实现方案，它会为一张纹理生成多个不同层级的纹理，如下图所示。Mipmap虽然生成了多个不同层级的纹理，但是整体的存储量只增加了不到 1/3。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-25.png?x-oss-process=image/resize,w_800" /></p><p>既然 Mipmap生成了多个不同层级的纹理，那么在纹理查询时，我们应该查询哪个层级的纹理呢？</p><p>如下图所示，对于屏幕上的一个像素点，考虑其相邻的两个点，获取它们的纹理坐标。根据纹理坐标计算相邻的距离，由此近似得到像素对应的矩形区域。我们获取矩形区域较大的边长<span class="math inline">\(L\)</span>。然后对 <spanclass="math inline">\(L\)</span>求对数，即可计算得出要查询的纹理的层级。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-26.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}L = &amp;max(\sqrt{(\frac{du}{dx})^2 + (\frac{du}{dx})^2},\sqrt{(\frac{du}{dy})^2 + (\frac{du}{dy})^2})\\D = &amp;log_2L\end{aligned}\]</span><h4 id="各向异性过滤">各向异性过滤</h4><p>事实上，Mipmap也并不是万能的。在有些场景下，也会出现过度模糊的问题，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-27.png?x-oss-process=image/resize,w_800" /></p><p>根本原因是，Mipmap的范围查询所覆盖的区域是正方形。如果屏幕像素点代表了纹理中的一个长方形区域，那么范围查询就无法准确代表长方形区域内的值，因此会出现走样，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-28.png?x-oss-process=image/resize,w_800" /></p><p>那么如何解决呢？方法是各项异性过滤（AnisotropicFiltering）。具体的技术是：除了生成针对正方形区域的范围查询的纹理外，还要生成其他形状（比如长方形）的范围查询的纹理。通过这种方式，纹理的存储量会增加3 倍，不过能够降低着色走样的概率。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-29.png?x-oss-process=image/resize,w_800" /></p><h2 id="纹理应用">纹理应用</h2><p>至此，我们基本了解了纹理及其工作原理，本质而言，纹理 = 内存存储 +范围查询。上述内容我们主要介绍了通过纹理记录颜色，事实上纹理还能记录其他很多属性，比如：环境光、微几何、法向量、高度偏移等等。</p><p>下面，我们来介绍纹理的其他几种应用。</p><h3 id="环境贴图">环境贴图</h3><p>纹理应用最多的就是 <strong>环境贴图</strong>（EnvironmentMap），这里又有非常多的类型。</p><p><strong>立方体环境贴图</strong>（Cube EnvironmentMap），它是将环境映射到一个立方体的六个面上，可以用于实现镜面反射和环境光照。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-30.png?x-oss-process=image/resize,w_800" /></p><p><strong>光照环境贴图</strong>（Light EnvironmentMap），它在渲染过程中预先计算和存储环境光照信息，以提高实时渲染效率和质量的技术</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-31.png?x-oss-process=image/resize,w_800" /></p><p>除此之外，还有很多环境贴图，比如：球谐环境贴图、镜面反射环境贴图、辐射度环境贴图、天空盒环境贴图等等。</p><h3 id="凹凸贴图">凹凸贴图</h3><p>假如我们希望渲染一个表面凹凸不同的球状体，如果使用三角形来表示，那么需要大量三角形，而且结构非常复杂。对于这种情况，我们可以凹凸贴图（BumpMap），它可以定义点的相对高度，从而改变法线，进而影响着色结果，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-32.png?x-oss-process=image/resize,w_800" /></p><h3 id="位移贴图">位移贴图</h3><p>凹凸贴图改变了着色时所使用的法向量，但并没有真正改变模型的形状。一种更现代化的<strong>位移贴图</strong>（DisplacementMapping），则定义了顶点高度的偏移量，使得真真正改变了模型的形状，从而实现更加逼真的效果。下图所示，为凹凸贴图和位移贴图的对比效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/shading-33.png?x-oss-process=image/resize,w_800" /></p><h1 id="总结">总结</h1><p>本文我们主要介绍了着色相关的内容。</p><p>首先，我们介绍了着色模型，具体介绍了经典的布林-冯反射模型，其由漫反射、高光、环境光三部分组成。</p><p>其次，我们介绍了几种着色频率，包括平面着色、顶点着色、像素着色，简单对比了它们之间的差异。</p><p>然后，我们简单介绍了实时渲染管线的 5个阶段，包括顶点处理、三角形处理、光栅化、片段处理、帧缓冲操作等。</p><p>最后，我们详细介绍了着色中最重要的一部分——纹理。纹理查询是是如何通过重心坐标、纹理坐标查找对应的纹理属性。当然，纹理查询也属于采样，其中也会遇到走样的问题。于是，我们引入了线性插值、Mipmap、各向异性过滤等解决方案。除此之外，我们还介绍了纹理的几种应用，包括：环境贴图、凹凸贴图、位移贴图等。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li><a href="http://shadertop.com">Shadertoy</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇 &lt;a
href=&quot;http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/&quot;&gt;文章&lt;/a&gt;
我们介绍了光栅化所涉及的基本内容。通过光栅化，我们可以实现将 3D
空间模型的投影绘制到 2D
屏幕。然而，仅仅实现光栅化，还不足以让渲染结果具有真实感，如下图左部所示。我们希望能够模拟光线所带来的的明暗效果，如下图右部所示。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Mipmap" scheme="http://chuquan.me/tags/Mipmap/"/>
    
    <category term="各向异性过滤" scheme="http://chuquan.me/tags/%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E8%BF%87%E6%BB%A4/"/>
    
    <category term="纹理" scheme="http://chuquan.me/tags/%E7%BA%B9%E7%90%86/"/>
    
    <category term="重心坐标" scheme="http://chuquan.me/tags/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"/>
    
    <category term="纹理坐标" scheme="http://chuquan.me/tags/%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87/"/>
    
    <category term="布林-冯模型" scheme="http://chuquan.me/tags/%E5%B8%83%E6%9E%97-%E5%86%AF%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（4）——光栅化</title>
    <link href="http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/"/>
    <id>http://chuquan.me/2024/03/30/foundation-of-computer-graphic-04/</id>
    <published>2024-03-30T01:20:55.000Z</published>
    <updated>2024-03-30T01:39:10.562Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <ahref="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/">文章</a>我们介绍了矩阵变换在计算机图形学中的应用，包括：视图变换、模型变换、投影变换。此外，我们还详细介绍了投影变换中的正交投影和透视投影，以及屏幕映射过程中的视口变换。</p><span id="more"></span><p>本文，我们来介绍一下计算机图形学中最重要的内容之一——光栅化。</p><h1 id="栅格显示">栅格显示</h1><p>光栅化（Rasterization）中光栅（Raster）一词来源于德语，表示栅格的意思。我们现在用的显示设备基本上都是由像素点阵构成的栅格显示设备。因此，我们很容易理解光栅化的含义，即在栅格显示设备上绘制图形。</p><p>这里我们先介绍一下常见的栅格显示设备。</p><p>旧式的阴极射线管（Cathode Ray Tube，CRT）电视，它的基本原理是<strong>通过射线管将电子射到屏幕进行逐行扫描</strong>，如下图所示。在实际应用中，会借助视觉暂留效应，对屏幕进行<strong>隔行扫描</strong>，从而降低扫描的计算量。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-01.png?x-oss-process=image/resize,w_800" /></p><p>现代平板显示器（Flat Panel Displays）中最常用的是液晶显示器（LiquidCrystal Display，LCD），它的基本原理是<strong>通过扭转偏振来阻挡或传输光线</strong>，如下图所示。在实际应用中，会使用<strong>帧缓冲</strong>（FrameBuffer）来提前缓存画面的帧数据，从而提高显示流畅度。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-02.png?x-oss-process=image/resize,w_800" /></p><h1 id="光栅化">光栅化</h1><h2 id="基本单元">基本单元</h2><p>光栅化的基本单元是三角形，采用三角形作为基本单元的原因是：</p><ul><li>三角形是最基本的多边形。</li><li>三角形具有平面性。</li><li>三角形可以明确定义内部和外部。我们可以通过向量叉积来判断，详见 <ahref="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">计算机图形学基础（1）——线性代数</a>。</li><li>任意多边形可以拆分成 N 个三角形。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-07.png?x-oss-process=image/resize,w_800" /></p><h2 id="采样绘制">采样绘制</h2><p>2D屏幕是一个离散的像素阵列，空间中的三角形则是一个连续的函数。采样绘制的本质则是对一个函数进行离散化。具体的做法是：</p><ul><li>遍历像素阵列，判断每一个像素阵列是否位于三角形的投射区域内</li><li>如果是，进行绘制像素；否则，不绘制。</li></ul><p>如下所示为采样绘制的伪代码和示意图。注意，像素本身是一个矩形区域，因此判断像素是否在三角形内部时，采用的是像素点的中心作为参照。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inside</span><span class="params">(t, x, y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">point</span><span class="params">(x, y)</span> in <span class="title">triangle</span><span class="params">(t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y) &#123;</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x + <span class="number">0.5</span>, y + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-03.png?x-oss-process=image/resize,w_800" /></p><p>在绘制三角形时，一般不会对整个屏幕的像素点进行扫描，而是仅仅对三角形的<strong>包围盒</strong>（BoundingBox）区域内的像素进行扫描和绘制，从而有效降低算法复杂度。对于一些窄长三角形，甚至可以进一步优化算法，如下图右侧所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-04.png?x-oss-process=image/resize,w_800" /></p><h2 id="核心问题">核心问题</h2><p>我们观察上述这种简单的采样绘制方式，可以发现一个很明显的问题——<strong>锯齿</strong>（Jaggies）。这个问题根本上是采样导致的，对于这种现象我们称之为<strong>走样</strong>（Aliasing）。走样会带来很多奇怪的现象，比如：锯齿、摩尔纹（MoirePatterns）、车轮效应等，如下图所示。</p><p>光栅化要解决的核心问题就是走样问题，即<strong>反走样</strong>（Antialiasing）。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-05.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-06.png?x-oss-process=image/resize,w_800" /></p><h2 id="解决方法">解决方法</h2><p>计算机图形学中解决走样问题的最常用方法是：<strong>先模糊，后采样</strong>。模糊，从字面上理解就是将图片虚化，从数学上理解则是<strong>滤波</strong>，关于滤波，我们将在下一节中进行介绍。</p><p>下图所示，为「直接采样」和「先模糊，后采样」的流程对比图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-08.png?x-oss-process=image/resize,w_800" /></p><p>在具体实践中，通过这种方式能够有效解决光栅化中的锯齿问题，如下所示为反走样前后的效果对比图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-09.png?x-oss-process=image/resize,w_800" /></p><p>这里，我们可能会产生疑问：</p><ul><li>出现走样的根本原因是什么？</li><li>为什么先模糊（滤波）后采样能够实现反走样？</li></ul><p>要讲明白这些内容，我们必须要介绍一下采样理论。</p><h1 id="采样理论">采样理论</h1><p>采样理论是信号系统中非常重要的一个理论，它在数字信号处理、数字通信、图像处理等众多领域都有着广泛的应用。</p><p>在实际应用中，我们通过一定的采样率把连续信号转换为离散信号，然后再对离散信号进行处理。处理完后，我们又可以通过一定的重构方法把离散信号转换回连续信号，以便在实际系统中使用。</p><h2 id="傅里叶级数">傅里叶级数</h2><p>那么如何表示任意一种信号呢？法国数学家傅里叶认为，任何周期函数（信号）都可以用正弦函数和余弦函数构成的无穷级数来表示，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-10.png?x-oss-process=image/resize,w_800" /></p><p>对于上图中的信号，使用傅里叶级数展开的表示如下所示。其中，这里 <spanclass="math inline">\(t\)</span> 表示时间，<spanclass="math inline">\(A\)</span> 表示振幅，<spanclass="math inline">\(w\)</span> 表示角频率。</p><span class="math display">\[\begin{aligned}f(x) = \frac{2Acos(tw)}{\pi} - \frac{2Acos(3tw)}{3\pi} +\frac{2Acos(5tw)}{5\pi} - \frac{2Acos(7tw)}{7\pi} + ...\end{aligned}\]</span><h2 id="时域与频域">时域与频域</h2><p>基于傅里叶级数，我们可以对信号的时域（以时间为横坐标）和频域（以频率为横坐标）进行相互转换：</p><ul><li>时域转换成频域：采用 <strong>傅里叶变换</strong>（FourierTransform）</li><li>频域转换成时域：采用 <strong>逆傅里叶变换</strong>（Inverse FourierTransform）</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="走样原理">走样原理</h2><p>了解了信号的时域和频域之后，我们再来介绍走样的原理。</p><p>理想情况下，对一个连续信号进行采样后得到的离散信号，应该能够近似重构原始信号。然而，当采样频率低于原始信号的频率时，就会很容易出现走样的问题。换句话说，就是采样得到的离散信号无法近似重构原始信号。</p><p>下图所示，我们列举了几种信号，信号频率依次从高到低，我们使用相同的频率对这些信号进行采样。很显然，我们对低频信号进行采样时，由于采样频率大于信号频率，得到的离散信号可以近似重构原始信号；但是，我们对高频信号采样时，由于采样频率小于信号频率，得到的离散信号则无法近似重构原始信号。</p><p>因此走样的根本原因就是 <strong>采样频率小于信号频率</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-12.png?x-oss-process=image/resize,w_800" /></p><h1 id="滤波">滤波</h1><p>由于滤波在反走样中起到了重要作用，因此我们简单介绍一下图像处理中滤波。</p><p>如下图所示，通过傅里叶变换将左侧的像素空间（空间域）变为右侧的频谱（频域）。对于二维信号，其频谱的表示如下：</p><ul><li>高频部分代表细节、边缘、噪声</li><li>低频占据绝大多数能量，其中直流分量（零频）能量占比最大</li><li>频率分部具有中心对称性</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-13.png?x-oss-process=image/resize,w_800" /></p><p>下面，我们来介绍一下几种常见的滤波。</p><h2 id="高通滤波">高通滤波</h2><p>高通滤波（High-passfilter），保留高频信号。在图像中，轮廓的边缘会发生剧烈变化，属于高频信号。经过高通滤波后，图像只会保留一些轮廓信息，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-14.png?x-oss-process=image/resize,w_800" /></p><h2 id="低通滤波">低通滤波</h2><p>低通滤波（Low-passfilter），保留低频信号。在图像中，颜色变化平缓的区域属于低频信号。经过低通滤波后，图像会抹去轮廓信息，如下图所示。模糊处理基于低通滤波实现的。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-15.png?x-oss-process=image/resize,w_800" /></p><h2 id="带通滤波">带通滤波</h2><p>带通滤波（Band-passfilter），顾名思义，只保留一部分频率范围内的信号。对图像滤波后的效果取决于带通滤波所选择的频率范围。下图所示，为两种不同频率范围的带通滤波。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-16.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-17.png?x-oss-process=image/resize,w_800" /></p><h2 id="卷积">卷积</h2><p>那么如何实现滤波呢？卷积（Convolution）就是实现滤波的主要数学工具和底层原理。滤波器的基本原理是<strong>响应函数与输入信号进行卷积运算</strong>，因此滤波器也可以称为<strong>卷积核</strong>。</p><p>如下所示，是卷积的数学定义，两个函数的 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 卷积 <span class="math inline">\(f *g(n)\)</span>。</p><span class="math display">\[\begin{aligned}连续形式：&amp;(f * g)(n) = \int_{-\infty}^{\infty}f(\tau)g(n-\tau)d\tau\\离散形式：&amp;(f * g)(n) = \sum_{-\infty}^{\infty}f(\tau)g(n-\tau)\end{aligned}\]</span><p>观察 <span class="math inline">\(f(\tau)\)</span> 和 <spanclass="math inline">\(g(n-\tau)\)</span> 的关系，可以发现是对<code>g</code> 函数进行了「翻转」，这就是「卷」的来源。同时，对两个函数<code>f</code> 和 <code>g</code> 进行积分，这就是「积」的来源。</p><p>卷积本身是一个很难解释的数学定义，如果你想深入理解卷积，这里推荐一篇知乎高赞回答——<ahref="https://www.zhihu.com/question/22298352/answer/228543288">传送门</a>。简而言之，<strong>两个函数的卷积，会先将一个函数翻转，然后进行滑动叠加</strong>。本质上可以将卷积理解成加权平均。</p><p>下图所示，是对图像进行滤波（卷积）的过程，实现模糊处理。基于傅里叶变换，我们可以实现时域（空间域）与频域之间的相互转换。<strong>时域（空间域）上对两个信号进行卷积，等同于频域上对两个信号的频率进行乘积</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-18.png?x-oss-process=image/resize,w_800" /></p><h1 id="反走样原理">反走样原理</h1><p>在「走样原理」一节中，我们提到了走样的根本原因是<strong>采样频率小于信号频率</strong>。在不提高采样频率的前提下，通过<strong>先滤波，后采样</strong>的方式可以实现反走样，这里的底层逻辑又是什么呢？</p><p>简单的理解就是，<strong>滤波（低通滤波，即模糊处理）会过滤掉信号中大于采样频率的信号分量</strong>。滤波后，剩余的信号分量的频率满足<strong>采样频率 &gt;= 信号频率</strong> 的条件，因此实现了反走样。</p><p>实现反走样的方法主要就是围绕两个角度来实现：</p><ul><li>提高采样频率。如：超采样技术（Supersampling）、多重采样抗锯齿（MSAA）、超分辨率</li><li>过滤高频信号。如：先模糊后采样（Pre-Filter）</li></ul><h1 id="遮挡与可见">遮挡与可见</h1><p>上述内容介绍了光栅化一个三角形的场景，以及其会遇到的问题——走样。下面，我们来介绍光栅化多个三角形会遇到的问题——遮挡与可见问题。</p><p>在 3D空间中，三角形之间存在着前后遮挡关系，那么三角形绘制的先后顺序应该是什么样的呢？</p><h2 id="画家算法">画家算法</h2><p>对此，我们先介绍一个经常被提到的算法：<strong>画家算法</strong>（Painter'sAlgorithm）。</p><p>画家算法，顾名思义，按照画家绘画时的先后顺序来执行，远的物体先绘制，进的物体后绘制，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-22.png?x-oss-process=image/resize,w_800" /></p><p>虽然画家算法适用于绝大多数场景，但是在某些场景下它仍然无法解决可见性问题。如下图所示，三个相互嵌套的三角形，使用画家算法则无法对三角形进行排序，因此无法准确实现光栅化。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-23.png?x-oss-process=image/resize,w_800" /></p><h2 id="深度缓冲算法">深度缓冲算法</h2><p>那么上述问题该如何解决呢？于是出现了<strong>深度缓冲算法</strong>（Z-Buffer Algorithm），其基本原理是：</p><ul><li>光栅化采用两个缓冲区<ul><li>原有的 <strong>帧缓冲区</strong>（FrameBuffer）存储每个像素颜色值</li><li>附加的<strong>深度缓冲区</strong>（Z-Buffer）存储每个像素深度值</li></ul></li><li>深度缓冲区存储每个像素当前的<strong>最小深度值</strong>（Z-Value）</li></ul><p>如下所示，为深度缓冲算法的伪代码实现。注意：我们会初始化深度值为无穷大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (each triangle T) &#123;</span><br><span class="line">    <span class="keyword">for</span> (each <span class="built_in">sample</span> (x, y, z) in T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z &lt; zbuffer[x, y]) &#123;            <span class="comment">// 处理深度更小的采样点</span></span><br><span class="line">            framebuffer[x, y] = rgb;        <span class="comment">// 更新颜色值</span></span><br><span class="line">            zbuffer[x, y] = z;              <span class="comment">// 更新深度值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示，使用深度缓冲算法光栅化两个三角形的示意图。当光栅化红色三角形时，我们遍历红色三角形的每一个像素的深度值，并与当前深度值进行比较。由于当前深度值均为无穷大，所以红色三角形的每一个像素都可以绘制。当光栅化蓝色三角形时，同样会遍历蓝色三角形每一个像素的深度值，并与当前深度值变换，深度值大于当前深度值，则不绘制；否则，绘制并更新当前深度值。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rasterization-24.png?x-oss-process=image/resize,w_800" /></p><p>注意，这里的深度值比较取决于坐标系是如何建立的。按照我们之前的介绍，相机是沿着-Z 轴方向观测，因此深度越大，则 Z 值越小。</p><h1 id="总结">总结</h1><p>本文，我们主要介绍了光栅化技术。首先介绍了光栅化的含义以及栅格设备。其次，我们介绍了光栅化的基本单元——三角形。</p><p>在绘制单个三角形时，我们会遇到走样问题。对此我们介绍了反走样的两种方法：提高采样频率、过滤信号频率。我们着重介绍了后者，先滤波（模糊）后采样，并介绍了其中涉及的原理。</p><p>在绘制多个三角形时，我们会遇到遮挡问题。对此我们介绍了两种算法：画家算法、深度缓冲算法。</p><p>后续，我们还会继续介绍计算机图形学的其他内容，敬请期待吧~</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li><ahref="https://www.zhihu.com/question/22298352/answer/228543288">如何通俗易懂地解释卷积</a></li><li><ahref="https://www.zhihu.com/tardis/zm/art/54946461?source_id=1003">傅里叶变换与图像的频域处理</a></li><li><ahref="https://dezeming.top/wp-content/uploads/2022/04/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86.pdf">采样定理</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇 &lt;a
href=&quot;http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/&quot;&gt;文章&lt;/a&gt;
我们介绍了矩阵变换在计算机图形学中的应用，包括：视图变换、模型变换、投影变换。此外，我们还详细介绍了投影变换中的正交投影和透视投影，以及屏幕映射过程中的视口变换。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="画家算法" scheme="http://chuquan.me/tags/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    
    <category term="深度缓冲算法" scheme="http://chuquan.me/tags/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95/"/>
    
    <category term="采样" scheme="http://chuquan.me/tags/%E9%87%87%E6%A0%B7/"/>
    
    <category term="走样" scheme="http://chuquan.me/tags/%E8%B5%B0%E6%A0%B7/"/>
    
    <category term="滤波" scheme="http://chuquan.me/tags/%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="傅里叶级数" scheme="http://chuquan.me/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/"/>
    
    <category term="卷积" scheme="http://chuquan.me/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（3）——观测变换</title>
    <link href="http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/"/>
    <id>http://chuquan.me/2024/03/23/foundation-of-computer-graphic-03/</id>
    <published>2024-03-23T09:29:30.000Z</published>
    <updated>2024-04-07T14:31:53.927Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们介绍了计算机图形学中的数学基础，包括：2D 变换、3D变换、齐次坐标等。本文，我们则来介绍将三维模型投影到二维屏幕的数学原理。</p><span id="more"></span><h1 id="观测变换">观测变换</h1><p>我们将三维模型投影到二维屏幕的过程称之为<strong>观测变换</strong>（Viewing Transformation）。</p><p>事实上，观测变换和我们平时拍照一样，总体可以分成三个步骤：</p><ul><li>摆放物体。在图形学中称为 <strong>模型变换</strong>（ModelTransformation）</li><li>摆放相机。在图形学中称为 <strong>视图变换</strong>（ViewTransformation）</li><li>拍照。在图形学中称为 <strong>投影变换</strong>（ProjectTransformation）</li></ul><p>根据这三个步骤的英文缩写，观测变换也可以称为 <strong>MVP变换</strong>。不过在图形学中，并不是严格按照这个顺序来执行的，而是先进行视图变换，再进行模型变换。至于为什么，我们稍后再解释。</p><p>下面，我们来分别介绍这三种变换。</p><h1 id="视图变换">视图变换</h1><p>视图变换也称为相机变换（CameraTransformation），视图的内容本质上是由相机的位置决定的，因此这里我们真正要做的是相机变换。</p><p>首先，我们使用如下三个向量来描述相机的<strong>原始位置</strong>，从而唯一确定其位置、观测方向、画面方向。</p><ul><li>位置：<span class="math inline">\(\vec{e}\)</span></li><li>观测方向：<span class="math inline">\(\hat{g}\)</span></li><li>向上方向：<span class="math inline">\(\hat{t}\)</span></li></ul><p>为了方便后续的计算，我们将相机放置到空间坐标系的原点，具体如下：</p><ul><li>位置：原点坐标</li><li>观测方向：<code>-Z</code></li><li>向上方向：<code>Y</code></li></ul><p>这里我们将变换后的观测方向设置为<code>-Z</code>，而在有些渲染引擎中观测方向为<code>Z</code>。这主要取决于空间坐标系的定义，本文我们使用的是右手坐标系。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-01.png?x-oss-process=image/resize,w_800" /></p><h2 id="如何变换">如何变换？</h2><p>那么具体我们该如何进行变换呢？一种非常直观的方法，按照四个步骤进行变换：</p><ul><li>将 <span class="math inline">\(\vec{e}\)</span> 平移变换至原点</li><li>将 <span class="math inline">\(\hat{g}\)</span> 旋转变换至<code>-Z</code></li><li>将 <span class="math inline">\(\hat{t}\)</span> 旋转变换至<code>Y</code></li><li>将 <span class="math inline">\(\hat{g} \times \hat{t}\)</span>旋转变换至 <code>X</code></li></ul><p>很显然，变换矩阵为平移变换和旋转变换的组合，即 <spanclass="math inline">\(M_{view} =R_{view}T_{view}\)</span>。其中，我们很容易就能求解平移变换的变换矩阵，如下。</p><span class="math display">\[\begin{aligned}T_{view}=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; -x_e \\0 &amp; 1 &amp; 0 &amp; -y_e \\0 &amp; 0 &amp; 1 &amp; -z_e \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><p>这里的难点在于求解几个旋转变换的变换矩阵 <spanclass="math inline">\(R_{view}\)</span>。那么，该如何求解呢？这里我们转换一下思路，考虑将位于原点的目标位置逆向转换至原始位置。通过这种方式我们可以得到<span class="math inline">\(R_{view}\)</span> 的逆矩阵 <spanclass="math inline">\(R_{view}^{-1}\)</span>。具体求解过程如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 \\0 \\0 \\0 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x_{\hat{g} \times \hat{t}} \\y_{\hat{g} \times \hat{t}} \\z_{\hat{g} \times \hat{t}} \\0 \\\end{matrix}\right)\\\\\left(\begin{matrix}? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}0 \\1 \\0 \\0 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x_{t} \\y_{t} \\z_{t} \\0 \\\end{matrix}\right)\\\\\left(\begin{matrix}? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\? &amp; ? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}0 \\0 \\1 \\0 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x_{-g} \\y_{-g} \\z_{-g} \\0 \\\end{matrix}\right)\\\\解得：R_{view}^{-1}= &amp;\left(\begin{matrix}x_{\hat{g} \times \hat{t}} &amp; x_{t} &amp; x_{-g} &amp; 0 \\y_{\hat{g} \times \hat{t}} &amp; y_{t} &amp; y_{-g} &amp; 0 \\z_{\hat{g} \times \hat{t}} &amp; z_{t} &amp; z_{-g} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><p>由于旋转矩阵是正交矩阵，所以旋转矩阵的逆矩阵就是它的转置矩阵。由此得到：</p><span class="math display">\[\begin{aligned}R_{view}=\left(\begin{matrix}x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp;z_{\hat{g} \times \hat{t}} &amp; 0 \\x_{t} &amp; y_{t} &amp; z_{t} &amp; 0 \\x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="模型变换">模型变换</h1><p>根据相对性原理，相机完成了特定的变换后，我们也需要对模型进行同样的变换，这样通过相机投影得到的画面才会相对不变。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-02.png?x-oss-process=image/resize,w_800" /></p><p>根据上述的相机变换，我们得到了对应的变换矩阵。根据此变换矩阵，我们再对空间中的所有模型进行变换，即完成了模型变换。之后，我们即可进行投影变换。</p><p>由模型和相机要进行相同的变换，因此也将模型变换和视图变换统称为<strong>模型视图变换</strong>（ModelView Transformation）。</p><h1 id="投影变换">投影变换</h1><p>投影变换本质上就是将 3D 模型投影到 2D画布的过程，具体可以分为两种：</p><ul><li>正交投影（OrthographicProjection）：一般用于工程制图软件，不具有近大远小的透视效果。</li><li>透视投影（PerspectiveProjection）：一般用于游戏引擎、渲染引擎，模拟真实的效果。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-03.png?x-oss-process=image/resize,w_800" /></p><p>事实上，正交投影可以认为是一种特殊的透视投影，即相机位于无限远的位置，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-04.png?x-oss-process=image/resize,w_800" /></p><h2 id="正交投影">正交投影</h2><p>下面，我们先来介绍一下正交投影的两种方法。</p><h3 id="方法一">方法一</h3><p>方法一非常直观，即丢弃 Z 坐标，直接转换成二维坐标系，然后再将其缩放至<span class="math inline">\([-1, 1]^2\)</span>的矩形区域，如下所示。为什么要缩放至 <span class="math inline">\([-1,1]^2\)</span>的矩形区域？事实上，这也是为了方便后续计算，是一种约定俗成的做法。当然，这种方式也存在一个问题，无法直接判断模型之间的远近关系，这个我们后续再讨论。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-05.png?x-oss-process=image/resize,w_800" /></p><h3 id="方法二">方法二</h3><p>不过，更普遍的做法是方法二，包括后续的透视投影也采用了这种方法。</p><p>方法二提出了一个 <strong>观测空间</strong>（ViewVolumne）的概念，这一点非常重要。对于正交投影，它的观测空间是一个无限长的长方体，其中以2D 画布为近面，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-09.png?x-oss-process=image/resize,w_800" /></p><p>由于 2D画布可能是任意比例的矩形，为了方便计算，我们将这个长方体的观测空间转换成成一个规范立方体（CanonicalCube），即 <span class="math inline">\([-1, 1]^3\)</span> 的空间。</p><p>在将观测空间转换成规范立方体的过程中，我们会组合平移、缩放等变换，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-06.png?x-oss-process=image/resize,w_800" /></p><p>很显然，要将模型转换成标准立方体，我们必须计算出变换矩阵 <spanclass="math inline">\(M_{ortho}\)</span>。由于投影变换不涉及旋转，因此变换矩阵相对而言比较容易求解，如下所示。</p><span class="math display">\[\begin{aligned}M_{ortho}=S_{ortho}T_{ortho}=\left(\begin{matrix}\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\0 &amp; 0 &amp; 1  &amp; -\frac{n+f}{2} \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><p>在将观测空间转换成规范立方体的过程中，我们计算得到了变换矩阵 <spanclass="math inline">\(M_{ortho}\)</span>。根据相对不变性原理，我们要使用<span class="math inline">\(M_{ortho}\)</span>对空间中所有物体进行同样的变换。这个过程，这里我们不再赘述。</p><h2 id="透视投影">透视投影</h2><p>透视投影则借鉴了正交投影的做法，只不过相对而言，它多了一步压缩过程，也就是说，透视投影= 压缩 + 正交投影。</p><p>下面，我们重点介绍一下压缩。</p><h3 id="压缩">压缩</h3><p>透视投影不同于正交投影，它的观测空间是一个无限长的纺锤体，其中以 2D画布为近面，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-10.png?x-oss-process=image/resize,w_800" /></p><p>压缩的本质就是将透视投影的观测空间压缩成正交投影的观测空间，即将纺锥体转换成长方体。然后，透视投影就换转化成了正交投影了。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-11.png?x-oss-process=image/resize,w_800" /></p><!--模型压缩本质上并不是真正对模型进行压缩，而是一种透视压缩。如下图所示，透视投影将空间中的一个点投影到一个 2D 的画布上，坐标点 `(x, y, z)` 中 `x` 和 `y` 的值会产生压缩效应，变成 `x'` 和 `y'`。--><!--![](https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-07.png?x-oss-process=image/resize,w_800)--><!--因此，我们可以想像画布上的投影点和空间点构成一个纺椎体，然后对这个纺椎体进行压缩，如下图所示。`(x, y, z)` 经过压缩后会变成 `(x', y', z)`，再经过正交投影后会得到 `(x', y', z')`。--><p>那么，我们该如何求解压缩变换的变换矩阵 <spanclass="math inline">\(M_{persp-&gt;ortho}\)</span> 呢？</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-07.png?x-oss-process=image/resize,w_800" /></p><p>首先，由相似三角形定理，如上图所示，我们可以得出：</p><span class="math display">\[\begin{aligned}y^{&#39;}=\frac{n}{z}y;x^{&#39;}=\frac{n}{z}x\end{aligned}\]</span><p>然后，我们基于齐次坐标，结合三角形定理，计算得出投影点的坐标：</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x^{&#39;} \\y^{&#39;} \\z^{&#39;} \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx/z \\ny/z \\? \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx \\ny \\? \\z \\\end{matrix}\right)\end{aligned}\]</span><p>接下来，我们准备求解变换矩阵 <spanclass="math inline">\(M_{persp-&gt;ortho}^{4 \times4}\)</span>，得出一下关系式：</p><span class="math display">\[\begin{aligned}M_{persp-&gt;ortho}\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)= &amp;\left(\begin{matrix}nx \\ny \\? \\z \\\end{matrix}\right)\\解得：M_{persp-&gt;ortho}= &amp;\left(\begin{matrix}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\? &amp; ? &amp; ? &amp; ? \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{matrix}\right)\end{aligned}\]</span><p>最后，我们来求解第三行的值。我们基于两个以下两个依据：</p><ul><li>近平面上的点的值不会变化，即 2D 画布上的值不变。</li><li>远平面上的在 Z 轴上的点不会变化。</li></ul><p>根据第一个依据，我们可以得出以下关系式。即将 <code>z</code> 替换成<code>n</code>。</p><span class="math display">\[\begin{aligned}M_{persp-&gt;ortho}\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)=M_{persp-&gt;ortho}\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)= &amp;\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)=\left(\begin{matrix}nx \\ny \\n^2 \\n \\\end{matrix}\right)\\推导：\left(\begin{matrix}? &amp; ? &amp; ? &amp; ? \\\end{matrix}\right)\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)= &amp;n^2\\解得：\left(\begin{matrix}? &amp; ? &amp; ? &amp; ? \\\end{matrix}\right)= &amp;\left(\begin{matrix}0 &amp; 0 &amp; ? &amp; ? \\\end{matrix}\right)\end{aligned}\]</span><p>我们使用 <code>(0, 0, A, B)</code> 抽象表示<code>(0, 0, ?, ?)</code>。根据两条依据，我们可以得到一个二元一次方程组，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}0 &amp; 0 &amp; A &amp; B \\\end{matrix}\right)\left(\begin{matrix}x \\y \\n \\1 \\\end{matrix}\right)= &amp;n^2=&gt; &amp;An + B = n^2\\\left(\begin{matrix}0 &amp; 0 &amp; A &amp; B \\\end{matrix}\right)\left(\begin{matrix}0 \\0 \\f \\1 \\\end{matrix}\right)= &amp;\left(\begin{matrix}0 \\0 \\f^2 \\f \\\end{matrix}\right)=&gt; &amp;Af + B = f^2\\解得：A= &amp;n + f\\B= &amp;-nf\end{aligned}\]</span><p>综上述，求解得出压缩变换的变换矩阵如下所示，其中 f是一个动态值，即空间点 <code>(x, y, z)</code> 的 <code>z</code> 值。</p><span class="math display">\[\begin{aligned}M_{persp-&gt;ortho}=\left(\begin{matrix}n &amp; 0 &amp; 0 &amp; 0 \\0 &amp; n &amp; 0 &amp; 0 \\0 &amp; 0 &amp; n+f &amp; -nf \\0 &amp; 0 &amp; 1 &amp; 0 \\\end{matrix}\right)\end{aligned}\]</span><p>对于透视投影，我们首先求解观测空间的压缩变换的变换矩阵 <spanclass="math inline">\(M_{persp-&gt;ortho}\)</span>，然后再利用在将转换后的长方体观测空间转换成规范立方体，即上文正交投影中求解的<span class="math inline">\(M_{ortho}\)</span>。</p><p>当然，根据相对不变性原理，我们还要将这两个变换矩阵应用到空间中所有的物体上，对它们进行变换。</p><h1 id="屏幕映射">屏幕映射</h1><p>当 MVP 变换完成之后，我们则要开始将投影内容绘制到 2D画布中，其中包含了裁剪和视口变换两个步骤。</p><h2 id="裁剪">裁剪</h2><p>无论是正交投影还是透视投影，我们都将观测空间转换成了一个规范立方体，同时将转换矩阵应用到空间中的所有物体中。</p><p>之后，我们就可以通过规范立方体对空间进行裁剪，只保留规范立方体内的物体，如下所示。很显然，只有在规范立方体中的部分才是我们可以看见的部分。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-12.png?x-oss-process=image/resize,w_800" /></p><h2 id="视口变换">视口变换</h2><p>视口（Viewport）本质上就是我们所说的 2D画布，即屏幕。我们知道屏幕有各种各样的分辨率，宽高比。为了处理这种情况，我们将2D 画布抽象成一个 <span class="math inline">\([-1, 1]^2\)</span>的规范平面。然后通过视口变换将它映射到真正的视口中。</p><p>假设真实视口的宽度是 <spanclass="math inline">\(width\)</span>，高度是 <spanclass="math inline">\(height\)</span>，那么视口变换就是将 <spanclass="math inline">\([-1, 1]^2\)</span> 的平面转换成 <spanclass="math inline">\([0, width] \times [0, height]\)</span>的平面。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/projection-13.png?x-oss-process=image/resize,w_800" /></p><p>对此，我们很容易求解变换矩阵，如下所示。</p><span class="math display">\[\begin{aligned}M_{viewport}=\left(\begin{matrix}\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文，我们主要介绍了观测变换的几个重点内容，包括视图变换、投影变换。其中，我们重点介绍了投影变换中的两种：正交投影和透视投影。</p><p>投影变换中提到了一个重要概念——观测空间。我们会将观测空间转换成一个规范立方体，根据相对不变性原理，对空间中所有物体做同样的变换。其中透视投影稍有复杂一点，我们会将纺锤体的观测空间转换成长方体的观测空间。</p><p>最后，我们将规范立方体以外的内容进行裁剪，并采用视口变换将内容映射到具体的屏幕上。</p><p>后面，我们将基于本章的内容继续介绍计算机图形学的相关基础。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li>Image Processing and Computer Graphics——Rendering Pipeline, MatthiasTeschner.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章我们介绍了计算机图形学中的数学基础，包括：2D 变换、3D
变换、齐次坐标等。本文，我们则来介绍将三维模型投影到二维屏幕的数学原理。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="观测变换" scheme="http://chuquan.me/tags/%E8%A7%82%E6%B5%8B%E5%8F%98%E6%8D%A2/"/>
    
    <category term="投影变换" scheme="http://chuquan.me/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"/>
    
    <category term="正交投影" scheme="http://chuquan.me/tags/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1/"/>
    
    <category term="透视投影" scheme="http://chuquan.me/tags/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>我的独立产品集</title>
    <link href="http://chuquan.me/2024/01/18/my-indie-hacker-products/"/>
    <id>http://chuquan.me/2024/01/18/my-indie-hacker-products/</id>
    <published>2024-01-18T15:09:42.000Z</published>
    <updated>2024-04-01T15:03:03.353Z</updated>
    
    <content type="html"><![CDATA[<p>本文罗列了一些我业余时间开发的独立产品，如果我写的博客对你有些许帮助，那我也诚邀你下载体验一下我开发的独立产品。当然，如果能够针对产品提出一些建议或给个好评，那真的不胜感激！这也会是我继续完善产品的动力！</p><span id="more"></span><h1 id="macos-应用">MacOS 应用</h1><h2 id="莫负休息">莫负休息</h2><p>莫负休息（Morph Rest）是一款 MacOS休息提醒应用程序。通过定时休息，可以预防视力疲劳、腰间盘突出、颈椎疼痛等职业病，当然也可以辅助提醒喝水，避免尿酸过高，引发肾结石、痛风等疾病。</p><p>莫负休息的主要特性：</p><ul><li>最低支持 MacOS 10.15 系统</li><li>支持浅色模式、深色模式</li><li>支持简体中文、繁体中文、英语、日语、韩语等多种语言</li><li>支持用户自定义工作、休息间隔</li><li>提供多种主题用于在休息期间展示</li></ul><p>下载地址——<ahref="https://apps.apple.com/cn/app/%E8%8E%AB%E8%B4%9F%E4%BC%91%E6%81%AF-%E4%BC%91%E6%81%AF%E6%8F%90%E9%86%92/id6474056217?mt=12">传送门</a></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-rest/0.9.0-common-market.png?x-oss-process=image/resize,w_800" /></p><h2 id="莫负时钟">莫负时钟</h2><p>莫负时钟（Morph Clock）是一款 MacOS屏幕保护程序。它采用了一种你从未见过的动态时钟效果，让你的 Mac成为办公室中最靓的仔~</p><p>莫负时钟的主要特性：</p><ul><li>最低支持 MacOS 10.14 系统。</li><li>动态渐变背景色，无时无刻都在变换颜色。</li></ul><p>下载地址——<ahref="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-clock/MorphClock.saver.zip">传送门</a></p><div data-align="center"><video src="http://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/morph-clock/MorphClock.mov" type="video/mp4" controls="controls" width="60%" height="60%"></video></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文罗列了一些我业余时间开发的独立产品，如果我写的博客对你有些许帮助，那我也诚邀你下载体验一下我开发的独立产品。当然，如果能够针对产品提出一些建议或给个好评，那真的不胜感激！这也会是我继续完善产品的动力！&lt;/p&gt;</summary>
    
    
    
    <category term="作品集" scheme="http://chuquan.me/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="Indie Hacker" scheme="http://chuquan.me/tags/Indie-Hacker/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（2）——变换</title>
    <link href="http://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/"/>
    <id>http://chuquan.me/2024/01/18/foundation-of-computer-graphic-02/</id>
    <published>2024-01-18T13:29:31.000Z</published>
    <updated>2024-03-18T01:46:47.645Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<ahref="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/">文章</a>我们介绍了计算机图形学中的线性代数基础，包括：点、向量、矩阵等。本文，我们将介绍向量和矩阵的进一步应用——变换。</p><span id="more"></span><h1 id="概述">概述</h1><p>计算机图形学中，我们可能会对图形进行各种变换（Transform），如：</p><ul><li>缩放（Scale）</li><li>平移（Transation）</li><li>旋转（Rotation）</li><li>切变（Shear）</li></ul><h1 id="d-变换">2D 变换</h1><p>首先，我们来介绍一下 2D变换，以便了解变换是如何通过矩阵变换来实现的。</p><h2 id="缩放变换">缩放变换</h2><p>对于缩放变换，它主要包含两种：等比例缩放、非等比缩放。</p><h3 id="等比例缩放">等比例缩放</h3><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-01.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为等比例缩放的示意图。根据等比例缩放的规则，我们可以根据缩放前<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; sx \\y&#39; =&amp; sy \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出缩放矩阵及关系式，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39;\end{matrix}\right)=\left(\begin{matrix}s &amp; 0 \\0 &amp; s \\\end{matrix}\right)\left(\begin{matrix}x \\y\end{matrix}\right)\end{aligned}\]</span><h3 id="非等比缩放">非等比缩放</h3><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-02.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为非等比缩放的示意图。根据非比缩放的规则，我们可以根据缩放前<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到另一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; s_xx \\y&#39; =&amp; s_yy \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出缩放矩阵及关系式，如下所示。对比一下，非等比缩放与等比例缩放的关系式非常相似。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}s_x &amp; 0 \\0 &amp; s_y \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)\end{aligned}\]</span><h2 id="镜像变换">镜像变换</h2><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-03.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为镜像变换的示意图。我们可以根据原始的 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; -x \\y&#39; =&amp; y \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出镜像矩阵及关系式，如下所示。本质上，镜像变换是一种特殊的缩放变换。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}-1 &amp; 0 \\0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y\end{matrix}\right)\end{aligned}\]</span><h2 id="切变变换">切变变换</h2><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-04.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为切变变换的示意图。切变变换相对复杂一点，其 <spanclass="math inline">\(y\)</span> 坐标值与 <spanclass="math inline">\(x\)</span>坐标值成一个比例关系。不过，我们仍然可以根据原始的 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的值，得到一组关系式，如下所示。</p><span class="math display">\[\begin{aligned}x&#39; =&amp; x + ay \\y&#39; =&amp; y \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出镜像矩阵及关系式，如下所示。本质上，镜像变换是一种特殊的缩放变换。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}1 &amp; a \\0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)\end{aligned}\]</span><h2 id="旋转变换">旋转变换</h2><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-05.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为旋转变换的示意图。旋转变换的坐标推导需要借助三角函数，最终可得到如下一组关系式。</p><span class="math display">\[\begin{aligned}x&#39; = cos{\theta}x - sin{\theta}y \\y&#39; = sin{\theta}x + cos{\theta}y \\\end{aligned}\]</span><p>根据此关系式，我们可以进一步推导出旋转矩阵及关系式，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)\end{aligned}\]</span><h2 id="平移变换">平移变换</h2><p>截止目前位置，所有的的变换都可以通过推导得出一个变换矩阵，以此矩阵乘以任意点（以矩阵表示），都可以得到转换后的点（以矩阵表示），符合线性变换。</p><p>下面，我们来看一下比较特殊的平移变换。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-06.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为平移变换的示意图，同样，我们也可以可得到如下一组关系式。</p><span class="math display">\[\begin{aligned}x&#39; = x + t_x \\y&#39; = y + t_y \\\end{aligned}\]</span><p>但是，我们进一步推导，得到的关系式与之前的变换不同，它有额外的偏移量，不符合线性变换，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}1 &amp; 0 \\0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)+\left(\begin{matrix}t_x \\t_y \\\end{matrix}\right)\end{aligned}\]</span><p>我们总是希望能使用一个统一的关系式来描述各种变换，然而，平移变换打破了我们的美好预期。那么该如何解决呢？为此，我们引入了齐次坐标。</p><h1 id="齐次坐标">齐次坐标</h1><p>为了能够统一表示所有变换，我们引入了<strong>齐次坐标</strong>（HomogenousCoordinates）。这里的核心思想是为每一个点或向量添加一个额外的 <spanclass="math inline">\(w\)</span> 坐标。</p><span class="math display">\[\begin{aligned}2D 点的齐次坐标表示：\left(\begin{matrix}x \\y \\1\end{matrix}\right)\\\\2D 向量的齐次坐标表示：\left(\begin{matrix}x \\y \\0 \\\end{matrix}\right)\end{aligned}\]</span><p>此时，我们再来尝试推导平移变换矩阵以及其关系式，可以得到如下所示内容。很显然，原来关系式中的偏移量没有了。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\w&#39; \\\end{matrix}\right)=\left(\begin{matrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\1 \\\end{matrix}\right)=\left(\begin{matrix}x+t_x \\y+t_y \\1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="仿射变换与线性变换">仿射变换与线性变换</h2><p>我们将线性变换和平移变换的组合，称为<strong>仿射变换</strong>（AffineTransform），如下所示。在未引入齐次坐标之前，我们推导出来的平移变换就是一种仿射变换。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\\end{matrix}\right)=\left(\begin{matrix}a &amp; b \\c &amp; d \\\end{matrix}\right)\left(\begin{matrix}x \\y \\\end{matrix}\right)+\left(\begin{matrix}t_x \\t_y \\\end{matrix}\right)\end{aligned}\]</span><p>当引入齐次坐标之后，所有的变换都可以统一使用线性变换来表示，如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\1 \\\end{matrix}\right)=\left(\begin{matrix}a &amp; b &amp; t_x \\c &amp; d &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\1 \\\end{matrix}\right)\end{aligned}\]</span><p>如下所示，是引入齐次坐标后，缩放变换，旋转变换，平移变换所对应的变换矩阵。</p><span class="math display">\[\begin{aligned}缩放变换：&amp;S(s_x, s_y) =\left(\begin{matrix}s_x &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\旋转变换：&amp;R(\alpha) =\left(\begin{matrix}cos\alpha &amp; -sin\alpha &amp; 0 \\sin\alpha &amp; cos\alpha &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\平移变换：&amp;T(t_x, t_y) =\left(\begin{matrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="逆变换">逆变换</h1><p>我们将所有的反向变换都称为 <strong>逆变换</strong>（InverseTransform），比如：我们将从 A 平移到 B 称为平移变换，那么从 B 平移到 A则可称为逆变换，其他的缩放变换、旋转变换同样如此。</p><p>上一节，我们引入了齐次坐标后，所有的变换都可以转换成线性变换，其中以<span class="math inline">\(M\)</span>为变换矩阵。而这些变换的逆变换，同样可以使用线性变换来表示，并以 <spanclass="math inline">\(M\)</span> 的逆矩阵 <spanclass="math inline">\(M^{-1}\)</span> 为变换矩阵。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-07.png?x-oss-process=image/resize,w_800" /></p><h1 id="组合变换">组合变换</h1><p>在真实情况下，我们遇到的变换大多数都是组合变换，也就是同时包含了缩放、旋转、平移等多种变换。</p><p>多种变换组合时，变换的顺序其实是非常重要的，我们以如下一个例子来进行介绍。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-08.png?x-oss-process=image/resize,w_800" /></p><p>对于上面这种变换，如果我们先平移，再旋转，那么最终会变成如下所示的。这里的根本原因在于旋转变换时，仍然是以坐标原点为锚点进行旋转。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-09.png?x-oss-process=image/resize,w_800" /></p><p>对此，正确的顺序应该是先旋转，后平移，这样才能达到预期的效果。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/transform-10.png?x-oss-process=image/resize,w_800" /></p><p>不同的顺序，矩阵变换的结果完全不同。前一篇文章我们提到过矩阵乘法不符合交换律，从这一点其实也能够解释这个现象。</p><p>在实际开发中，遇到这种类似的情况，我们一般都会先将目标平移至原点，然后进行各种其他变换，然后再通过逆变换平移回去。</p><h1 id="d-变换-1">3D 变换</h1><p>关于 3D 变换，本质上与 2D变换一样，只不过在矩阵表示上多了一个维度而已。</p><p>当我们引入齐次坐标之后，3D 的点和向量可以采用如下方式表示。</p><span class="math display">\[\begin{aligned}3D点的齐次坐标表示：&amp;\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)\\\\3D向量的齐次坐标表示：&amp;\left(\begin{matrix}x \\y \\z \\0 \\\end{matrix}\right)\end{aligned}\]</span><p>与此对应，3D 变换的矩阵变换关系式为如下所示。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}x&#39; \\y&#39; \\z&#39; \\1 \\\end{matrix}\right)=\left(\begin{matrix}a &amp; b &amp; c &amp; t_x \\d &amp; e &amp; f &amp; t_y \\g &amp; h &amp; i &amp; t_z \\0 &amp; 0 &amp; 0 &amp;1 \\\end{matrix}\right)\left(\begin{matrix}x \\y \\z \\1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="缩放变换-1">缩放变换</h2><p>如下所示，为 3D 空间中的缩放变换的变换矩阵的定义。</p><span class="math display">\[\begin{aligned}S(s_x, s_y, s_z)=\left(\begin{matrix}s_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; s_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; s_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="平移变换-1">平移变换</h2><p>如下所示，为 3D 空间中的平移变换的变换矩阵的定义。</p><span class="math display">\[\begin{aligned}T(t_x, t_y, t_z)=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; 0 &amp; t_y \\0 &amp; 0 &amp; 1 &amp; t_z \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h2 id="旋转变换-1">旋转变换</h2><p>如下所示，为 3D空间中的旋转变换的变换矩阵的定义，沿着不同的轴旋转，变换矩阵的定义也有所不同。</p><span class="math display">\[\begin{aligned}R_x(\alpha)=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; cos\alpha &amp; -sin\alpha &amp; 0 \\0 &amp; sin\alpha &amp; cos\alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\R_y(\alpha)=\left(\begin{matrix}cos\alpha &amp; 0 &amp; sin\alpha &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-sin\alpha &amp; 0 &amp; cos\alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\\\\R_z(\alpha)=\left(\begin{matrix}cos\alpha &amp; -sin\alpha &amp; 0 &amp; 0 \\sin\alpha &amp; cos\alpha &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文我们简单梳理了一下缩放、旋转、平移几种变换对应的矩阵关系式。其中，平移变换比较特殊，为了能够统一关系式，我们引入了齐次坐标，在点、向量的矩阵表示中增加了一个维度。然后，我们介绍了一下在组合变换中变换顺序的重要性。最后，我们简单总结了3D 变换的矩阵关系式。</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li>《计算机图形学入门：3D渲染指南》</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇&lt;a
href=&quot;http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/&quot;&gt;文章&lt;/a&gt;我们介绍了计算机图形学中的线性代数基础，包括：点、向量、矩阵等。本文，我们将介绍向量和矩阵的进一步应用——变换。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="缩放变换" scheme="http://chuquan.me/tags/%E7%BC%A9%E6%94%BE%E5%8F%98%E6%8D%A2/"/>
    
    <category term="平移变换" scheme="http://chuquan.me/tags/%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2/"/>
    
    <category term="旋转变换" scheme="http://chuquan.me/tags/%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2/"/>
    
    <category term="切变变换" scheme="http://chuquan.me/tags/%E5%88%87%E5%8F%98%E5%8F%98%E6%8D%A2/"/>
    
    <category term="仿射变换" scheme="http://chuquan.me/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础（1）——线性代数</title>
    <link href="http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/"/>
    <id>http://chuquan.me/2024/01/15/foundation-of-computer-graphic-01/</id>
    <published>2024-01-15T12:09:48.000Z</published>
    <updated>2024-03-18T01:23:03.865Z</updated>
    
    <content type="html"><![CDATA[<p>最近对计算机图形学比较感兴趣，刷了一遍《计算机图形学入门：3D渲染指南》，看了一遍《GAMES101》。本文对计算机图形学的线性代数相关基础进行了梳理和总结，以便后续进行复习和回顾。</p><span id="more"></span><h1 id="点">点</h1><p><strong>点</strong>（Point）表示坐标系中的一个特定位置，其具体表示和抽象表示分别如下。</p><ul><li>使用 <strong>大写字母</strong> 的方式来抽象表示一个点，如：<spanclass="math inline">\(P\)</span>。</li><li>使用 <strong>圆括号 + 数字序列</strong>的方式来具体表示一个点，如：<span class="math inline">\((4,3)\)</span>。</li></ul><p>在具体表示中，数字序列的顺序很重要。按照惯例，在 2D 平面中依次表示<span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span> 轴的值；在 3D 空间中依次表示 <spanclass="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>、<span class="math inline">\(z\)</span>轴的值。对此，我们也可以结合两种方式来表示一个抽象的点，比如：<spanclass="math inline">\((P_x, P_y)\)</span>。</p><h1 id="向量">向量</h1><p><strong>向量</strong>（Vector）表示两个点所构成线段的长度和方向，其具体表示和抽象表示分别如下。</p><ul><li>向量的抽象表示一般有三种，分别是：<ul><li>使用 <strong>小写字母 + 箭头上标</strong> 的方式，如：<spanclass="math inline">\(\vec{a}\)</span>。</li><li>使用 <strong>加粗小写字母</strong> 的方式，如：<spanclass="math inline">\(\textbf{a}\)</span>。</li><li>使用 <strong>两个点 + 箭头上标</strong> 的方式，如：<spanclass="math inline">\(\overrightarrow{AB} = B -A\)</span>。注：大写字母表示点。</li></ul></li><li>向量的具体表示中，默认以坐标原点作为起点，因此只需要描述终点即可。向量一般使用矩阵来表示，包含两种方式，分别是：</li></ul><span class="math display">\[\begin{aligned}列向量表示法：&amp;\left(\begin{matrix}x \\y\end{matrix}\right)\\行向量表示法：&amp;\left(\begin{matrix}x &amp; y\end{matrix}\right)\end{aligned}\]</span><p>在定义中我们提到向量包含了两个点之间的长度和方向两种信息。对此，我们可以各自使用一种方式来表示这两种信息。</p><ul><li>使用 <strong>小写字母 + <code>^</code> 上标</strong> 的方式表示<strong>单位向量</strong>（Unit Vector），即长度等于 1 的向量，如：<spanclass="math inline">\(\widehat{a}\)</span>。一般用来表示方向。</li><li>使用 <strong>向量 + 双竖线</strong> 的方式表示<strong>向量长度</strong>（Vector Length），如：<spanclass="math inline">\(|\vec{a}|\)</span>。</li></ul><p>单位向量可以通过向量除以向量长度的方式计算得到，如下所示。</p><span class="math display">\[\begin{aligned}\widehat{a} = \vec{a} / |\vec{a}|\end{aligned}\]</span><p>在计算机图形学中，单位向量的应用非常多，比如：法线向量。在计算光线的折射和反射时，法线必不可少。</p><h2 id="向量的加减运算">向量的加减运算</h2><p>向量的加减运算可以使用 <strong>平行四边形法则</strong> 或<strong>三角形法则</strong> 进行计算，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-01.png?x-oss-process=image/resize,w_800" /></p><p>向量的加减运算非常简单，只需要把两个向量的对应坐标的值进行加减运算即可，如下所示。</p><span class="math display">\[\begin{aligned}\vec{a} + \vec{b}=\left(\begin{matrix}a_x &amp; a_y\end{matrix}\right)+\left(\begin{matrix}b_x &amp; b_y\end{matrix}\right)=\left(\begin{matrix}a_x + b_x &amp; a_y + b_y\end{matrix}\right)\\\vec{a} - \vec{b}=\left(\begin{matrix}a_x &amp; a_y\end{matrix}\right)-\left(\begin{matrix}b_x &amp; b_y\end{matrix}\right)=\left(\begin{matrix}a_x - b_x &amp; a_y - b_y\end{matrix}\right)\end{aligned}\]</span><h2 id="向量的乘法运算">向量的乘法运算</h2><p>向量的乘法运算比较特殊，它有两种乘法运算，分别是：</p><ul><li><strong>点积</strong>（Dot Product），或称<strong>点乘</strong></li><li><strong>叉积</strong>（Cross Product），或称<strong>叉乘</strong></li></ul><h3 id="点积">点积</h3><p>两个向量之间的点积是一个数值，一般使用 <strong>点运算符</strong>表示。</p><p>点积的运算非常简单，只要将每个向量对应的坐标值相乘并求和即可，如下所示为一个点积的示例。</p><span class="math display">\[\begin{aligned}\vec{a} \cdot \vec{b}=\left(\begin{matrix}a_x &amp; a_y &amp; a_z\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)=a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z\end{aligned}\]</span><p>向量点积的特性</p><ul><li>符合交换律，即 <span class="math inline">\(\vec{a} \cdot \vec{b} =\vec{b} \cdot \vec{a}\)</span></li><li>符合分配律，即 <span class="math inline">\(\vec{a} \cdot (\vec{b} +\vec{c}) = \vec{a} \cdot \vec{b} + \vec{a} \cdot \vec{c}\)</span></li><li>不符合结合律。点乘的结果是一个标量，不是向量，因此无法与另一个向量继续进行点乘运算。</li></ul><p>在计算机图形学中，点积的应用非常广泛，主要包括：</p><ul><li><strong>计算两个向量之间的夹角</strong></li><li><strong>计算一个向量在另一个向量上的投影</strong></li><li><strong>计算一个向量正交分解后的两个向量</strong></li><li><strong>判断一个向量相对于另一个向量是正向还是反向</strong></li></ul><p>下面，我们来看一下这几种应用是如果通过计算实现的。</p><p>首先，如何计算两个向量之间的夹角？在几何上，两个向量的点积与它们的长度以及它们之间的夹角<span class="math inline">\(a\)</span>有关，确切的公式巧妙地将线性代数和三角函数联系在了一起，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-02.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}\vec{a} \cdot \vec{b} =&amp; |\vec{a}| \cdot |\vec{b}| \cdot cos\theta\\cos\theta =&amp; \frac{\vec{a} \cdot \vec{b}}{|\vec{a}| \cdot |\vec{b}|}\\cos\theta =&amp; \widehat{a} \cdot \widehat{b}\end{aligned}\]</span><p>其次，如何计算一个向量在另一个向量上的投影？如下所示，求向量 <spanclass="math inline">\(\vec{b}\)</span> 在向量 <spanclass="math inline">\(\vec{a}\)</span> 上的投影 <spanclass="math inline">\(\vec{b}_\bot\)</span>，很显然，<spanclass="math inline">\(\vec{b}_\bot\)</span> 与 <spanclass="math inline">\(\vec{a}\)</span>的方向是一致的，只是长度可能不同。因此，我们可以通过前面提到的方式计算两者之间的夹角，然后计算投影长度，并使用该长度乘以单位向量<span class="math inline">\(\widehat{a}\)</span> 即可。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-03.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}\vec{b}_\bot =&amp; k \cdot \widehat{a}\\k =&amp; |\vec{b_\bot}| = |\vec{b}| \cdot cos\theta = |\vec{b}| \cdot\widehat{a} \cdot \widehat{b}\\\end{aligned}\]</span><p>接着，如何计算一个向量正交分解后的两个向量？上面我们在计算一个向量在另一个向量上的投影时，已经计算得到了一个方向的分解向量，另一个方向的分解向量我们只需通过向量减法即可得到，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-04.png?x-oss-process=image/resize,w_800" /></p><p>最后，如何判断一个向量相对于另一个向量是正向还是反向？判断两个向量的方向关系，本质上是看两者之间的夹角，如果是锐角，则认为是正向，如果是钝角，则认为是反向，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-05.png?x-oss-process=image/resize,w_800" /></p><h3 id="叉积">叉积</h3><p>两个向量之间的叉积是一个向量，一般使用 <strong>叉乘符号</strong>表示。</p><p>叉积是一个垂直于两个向量的向量，其方向可以通过<strong>右手螺旋定则</strong> 确定。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-06.png?x-oss-process=image/resize,w_800" /></p><span class="math display">\[\begin{aligned}\vec{c}= &amp;\vec{a} \times \vec{b}\\= &amp;\left(\begin{matrix}a_x &amp; a_y &amp; a_z\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)\\= &amp;\left(\begin{matrix}a_y \cdot b_z - a_z \cdot b_y \\a_z \cdot b_x - a_x \cdot b_z \\a_x \cdot b_y - a_y \cdot b_x \\\end{matrix}\right)\\即：\\c_x =&amp; a_y \cdot b_z - a_z \cdot b_y\\c_y =&amp; a_z \cdot b_x - a_x \cdot b_z\\c_z =&amp; a_x \cdot b_y - a_y \cdot b_x\end{aligned}\]</span><p>向量叉积的特性</p><ul><li>符合分配律，即 <span class="math inline">\(\vec{a} \times (\vec{b} +\vec{c}) = \vec{a} \times \vec{b} + \vec{a} \times \vec{c}\)</span></li><li>不符合结合律，即 <span class="math inline">\((\vec{a} \times\vec{b}) \times \vec{c} \neq \vec{a} \times (\vec{b} \times\vec{c})\)</span></li><li>不符合交换律，即 <span class="math inline">\(\vec{a} \times \vec{b}\neq \vec{b} \times \vec{a}\)</span></li></ul><p>在计算机图形学中，乘积的应用主要包括一下这些：</p><ul><li><strong>判断一个向量相对于另一个向量的左右关系</strong></li><li><strong>判断一个向量相对于一个三角形的内外关系</strong></li></ul><p>那么，如何判断一个向量相对于另一个向量的左右关系？可以直接判断两个向量叉积的正负值。如下所示，在一个3D 坐标中，<span class="math inline">\(\vec{a}\)</span> 和 <spanclass="math inline">\(\vec{b}\)</span>的叉乘符合右手螺旋定则的方向（图中与 Y 轴方向相同），则表示 <spanclass="math inline">\(\vec{A}\)</span> 在 <spanclass="math inline">\(\vec{B}\)</span> 的右边，反之则表示 <spanclass="math inline">\(\vec{A}\)</span> 在 <spanclass="math inline">\(\vec{B}\)</span> 的左边。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-07.png?x-oss-process=image/resize,w_800" /></p><p>以及，如何判断一个向量相对于一个三角形的内外关系？事实上，我们可以利用上面这种左右关系判断的方法来组合判断。如下所示，我们可以分别判断<span class="math inline">\(\overrightarrow{AP}\)</span> 和 <spanclass="math inline">\(\overrightarrow{AB}\)</span> 的左右关系，<spanclass="math inline">\(\overrightarrow{BP}\)</span> 和 <spanclass="math inline">\(\overrightarrow{BC}\)</span> 的左右关系，<spanclass="math inline">\(\overrightarrow{CP}\)</span> 和 <spanclass="math inline">\(\overrightarrow{CA}\)</span>的左右关系，如果前者都在后者的一边（左边或右边），那么 <spanclass="math inline">\(P\)</span> 就在三角形内；否则，在三角形外。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/vector-08.png?x-oss-process=image/resize,w_800" /></p><h1 id="矩阵">矩阵</h1><p>矩阵是一个 <span class="math inline">\(m\)</span> 行 <spanclass="math inline">\(n\)</span> 列的数字阵列，通常我们使用一个<strong>加粗的大写字母</strong>抽象表示一个矩阵。在计算机图形学中，它被广泛应用于各种变换计算中，比如：平移、旋转、缩放等。</p><h2 id="矩阵的乘法运算">矩阵的乘法运算</h2><p>矩阵的乘法必须满足一个前提：矩阵 <spanclass="math inline">\(A\)</span> 的列数等于矩阵 <spanclass="math inline">\(B\)</span> 的行数，即<code>(M x N)(N x P) = (M x P)</code>。</p><p>矩阵 <span class="math inline">\(A\)</span> 乘以矩阵 <spanclass="math inline">\(B\)</span> 得到矩阵 <spanclass="math inline">\(C\)</span>，其中矩阵 <spanclass="math inline">\(C\)</span> 中的任意元素 <code>(i, j)</code>的值等于 <span class="math inline">\(A\)</span> 中第 <code>i</code> 行与<span class="math inline">\(B\)</span> 中第 <code>j</code>列的点积，如下所示是一个矩阵乘法的示例。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}1 &amp; 3 \\5 &amp; 2 \\0 &amp; 4 \\\end{matrix}\right)\left(\begin{matrix}3 &amp; 6 &amp; 9 &amp; 4 \\2 &amp; 7 &amp; 8 &amp; 3 \\\end{matrix}\right)=\left(\begin{matrix}9 &amp; 27 &amp; 33 &amp; 13 \\19 &amp; 44 &amp; 61 &amp; 26 \\8 &amp; 28 &amp; 32 &amp; 12 \\\end{matrix}\right)\end{aligned}\]</span><p>矩阵乘法的特性</p><ul><li>不符合交换律，即 <span class="math inline">\(AB \neqBA\)</span></li><li>符合分配律，即 <span class="math inline">\(A(B + C) = AB +BA\)</span></li><li>符合结合律，即 <span class="math inline">\((AB)C =A(BC)\)</span></li></ul><p>在计算机图形学中，向量也会使用矩阵（行矩阵或列矩阵）来表示，向量之间的乘法以及向量与矩阵的乘法都符合矩阵乘法的基本规则。</p><h2 id="矩阵的转置运算">矩阵的转置运算</h2><p>矩阵的转置本质上就是沿着主对角线（从左上角至右下角）的对角线将 i x j的矩阵翻转成 j x i 的矩阵。一般我们使用一个 <strong>上标 T</strong>表示一个矩阵的转置，如：<span class="math inline">\(A^T\)</span>。</p><p>如下所示，是一个矩阵转置运算的示例。</p><span class="math display">\[\begin{aligned}\left(\begin{matrix}1 &amp; 2 \\3 &amp; 4 \\5 &amp; 6 \\\end{matrix}\right)^T=\left(\begin{matrix}1 &amp; 3 &amp; 5 \\2 &amp; 4 &amp; 6 \\\end{matrix}\right)\end{aligned}\]</span><p>矩阵转置的特性</p><ul><li><span class="math inline">\((AB)^T = B^TA^T\)</span></li></ul><h2 id="矩阵的类型">矩阵的类型</h2><p>下面，我们来介绍各种不同类型的矩阵。</p><h3 id="对角矩阵">对角矩阵</h3><p>对角矩阵，其主对角线（从左上角到右下角）上的元素都是非0，其他元素都为 0。</p><h3 id="单位矩阵">单位矩阵</h3><p>单位矩阵，其主对角线（从左上角到右下角）上的元素都为 1，其余元素都为0，一般使用大写字母 <span class="math inline">\(I\)</span>来表示。单位矩阵是一个特殊的对角矩阵。如下所示，是一个单位矩阵实例。</p><span class="math display">\[\begin{aligned}I_{3 \times 3}=\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\end{aligned}\]</span><h3 id="逆矩阵">逆矩阵</h3><p>给定一个矩阵 <spanclass="math inline">\(A\)</span>，如果存在一个与之维度相同的矩阵，使得这两个矩阵相乘的结果是一个单位矩阵，那么我们称这个矩阵为矩阵<span class="math inline">\(A\)</span> 的逆矩阵，使用 <spanclass="math inline">\(A^{-1}\)</span>表示。如下所示，为逆矩阵的示例。</p><span class="math display">\[\begin{aligned}A A^{-1} =&amp; A^{-1}A = I\\(AB)^{-1} =&amp; B^{-1}A^{-1}\end{aligned}\]</span><h2 id="矩阵的应用">矩阵的应用</h2><p>上述我们介绍的向量的两种运算，其实完全可以使用矩阵的乘法来实现。</p><p>关于向量的点积，我们可以使用如下矩阵乘法来表示。</p><span class="math display">\[\begin{aligned}\vec{a} \cdot \vec{b}=\vec{a}^T \cdot \vec{b}=\left(\begin{matrix}a_x &amp; a_y &amp; a_z\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)=a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z\end{aligned}\]</span><p>关于向量的叉积，我们可以使用如下矩阵乘法来表示，如下所示。其中 <spanclass="math inline">\(A^*\)</span> 为矩阵 <spanclass="math inline">\(A\)</span> 的对偶矩阵。</p><span class="math display">\[\begin{aligned}\vec{a} \times \vec{b}=A^* b=\left(\begin{matrix}0    &amp; -a_z &amp; a_y \\a_z  &amp; 0    &amp; -a_x \\-a_y &amp; a_x  &amp; 0 \\\end{matrix}\right)\left(\begin{matrix}b_x \\b_y \\b_z \\\end{matrix}\right)=\left(\begin{matrix}a_y \cdot b_z - a_z \cdot b_y \\a_z \cdot b_x - a_x \cdot b_z \\a_x \cdot b_y - a_y \cdot b_x \\\end{matrix}\right)\end{aligned}\]</span><h1 id="总结">总结</h1><p>本文介绍了点、向量、矩阵的基本定义和运算方法。向量的乘法包含两种：点积和叉积，两者被广泛应用在了在计算机图形学中。</p><p>点积和叉积的具体运算可以通过矩阵运算来实现，这也是为什么我们常说计算机图形学中包含了大量矩阵运算。</p><p>下文，我们将探讨矩阵在图形的变换中的应用，敬请期待吧~</p><h1 id="参考">参考</h1><ol type="1"><li>《GAMES 101》</li><li>《计算机图形学入门：3D渲染指南》</li><li><ahref="https://blog.csdn.net/weixin_42782150/article/details/104878759">史上最全Markdown公式、符号总结</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近对计算机图形学比较感兴趣，刷了一遍《计算机图形学入门：3D渲染指南》，看了一遍《GAMES
101》。本文对计算机图形学的线性代数相关基础进行了梳理和总结，以便后续进行复习和回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="图形学" scheme="http://chuquan.me/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="向量" scheme="http://chuquan.me/tags/%E5%90%91%E9%87%8F/"/>
    
    <category term="矩阵" scheme="http://chuquan.me/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="点积" scheme="http://chuquan.me/tags/%E7%82%B9%E7%A7%AF/"/>
    
    <category term="叉积" scheme="http://chuquan.me/tags/%E5%8F%89%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>2023，31岁客三消从业者的年度回顾</title>
    <link href="http://chuquan.me/2024/01/05/2023-summary/"/>
    <id>http://chuquan.me/2024/01/05/2023-summary/</id>
    <published>2024-01-05T14:55:30.000Z</published>
    <updated>2024-06-05T10:43:46.522Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-01.jpg?x-oss-process=image/resize,w_600" alt="" /></p><span id="more"></span><p>每年总是要例行回顾一下过去一年，看看自己做了什么，收获了什么。</p><h1 id="角色适应"><a class="markdownIt-Anchor" href="#角色适应"></a> 角色适应</h1><p>今年是作为移动客户端负责人的第 2 年，自己基本已经适应了这个角色。一开始，我和团队中很多成员都是一线的研发，后面被提拔到这个位置。那时候，在技术决策、任务分配、会议沟通时，经常会想自己的决策和做法是否被认可？是否被信服？团队成员是否认可自己？总之，心理负担一直都是有的。</p><p>在业务的迭代和发展过程中，我会回顾自己做的决策。从结果看来，整体都是符合预期的，比如：</p><ul><li><strong>关于兄弟团队借人的决策</strong>。部门内有两条业务线，另一条业务线今年年初在快速发展，缺 iOS 开发，于是经过部门老大的同意向我们借人，希望能够支援 3 个月。，最终我决定让组内的几个同学轮流支援，每人支援一个月。一方面，可以避免外派同学产生边缘心理；另一方面，也可以避免借人还人的情况。</li><li><strong>关于提测质量竞赛的决策</strong>。年初在与测试同学的沟通中了解到：在服务端、前端、客户端的测试过程中，测试体验最差的往往都是客户端。当然，这里面是存在客观原因的。关于服务端，其主要是开发业务逻辑，不包含 UI 逻辑，一旦联调完毕，在测试阶段 BUG 其实是很少的；关于前端，其与客户端非常相似，区别在于前端在测试阶段可以热修复 BUG，前一分钟还存在的 BUG，后一分钟可能就解决了。关于客户端，相比服务端多了 UI BUG，相比前端修复周期比较长（修复、编译、验证、打包、提测）。最终产生客户端测试体验差的感觉。为了提高提测质量，提出了提测质量竞赛的机制，对于同一个需求，Android/iOS BUG 数量出现大于等于 5 的情况时，BUG 数量少的一方和对应的测试同学将获得一杯喜茶，并记录在 Score Board 中。一年下来，组内成员的自测意识确实提高了不少，产生的 BUG 基本上都是测试用例之外的 BUG。</li></ul><p>正确的决策会带来正向的激励，从而产生正反馈效应。于是，之前心理负担开始慢慢的消失，自己对于这个角色也开始逐步适应，慢慢开始变得得心应手起来。</p><h1 id="工作产出"><a class="markdownIt-Anchor" href="#工作产出"></a> 工作产出</h1><p>在工作产出方面，今年主要做了一些工程能力和技术调研等工作，比如：</p><ul><li>构建客户端 NodeJS 服务，支持 Sentry 崩溃告警、GitLab Code Review、包体积分析等能力。</li><li>Cocos 引擎定制的工程化，解决底层引擎替换问题，增加引擎日志，独立引擎打包等。</li><li>推进并落地 Cocos 资源代码隔离能力，从而让 App 内的 Cocos 互动题具备全局的热修复能力。</li><li>直播自建、局部录屏、恢复购买、家庭共享、Deferred Deep Link 等技术方案调研。</li></ul><p>今年，在 iOS 同学外派支援期间，我做了一些业务需求，其他时间基本都没有参与复杂业务和模块的具体开发。因为团队内  Android 和 iOS 的研发人员数量对等，所以不需要我来承担额外的开发任务。只有当出现临时需求或者排期时没有分配的需求时，为了不打乱既定的排期，一般会由我来兜底做这些需求，一个人同时写 Android 和 iOS。</p><p>整体而言，今年开始逐步退居二线，做一些技术决策和工程能力等相关工作。不过，在日常中我仍然坚持写代码，因为我始终觉得一旦自己脱离一线太久，很容易会作出一些不符合现实的决策和排期。</p><h1 id="身体是革命的本钱"><a class="markdownIt-Anchor" href="#身体是革命的本钱"></a> 身体是革命的本钱</h1><h2 id="眼睛疲劳"><a class="markdownIt-Anchor" href="#眼睛疲劳"></a> 眼睛疲劳</h2><p>从 2021 年下半年到 2022 年上半年，我一直有着眼睛疲劳的症状，具体表现就是 <strong>眼睛无法准确对焦</strong>。当我在观察 3 米以外的物体时，大脑中呈现的视觉效果是有两个物体（两个眼镜各自成像的物体），两个物体无法合成到一个画面中，需要非常努力的弄眉挤眼才能对焦上，但是过不了多久又会失焦。</p><p>这个问题我一直都没有发现，因为在工作生活中，眼睛对焦基本都在 3 米以内。最后是在电影院观影时才发现的，画面有重影，观影感极差。从那时起，我才开始重视视力问题。</p><p>在 4 月份，我预约了同仁医院的眼科挂号。在医院里，我看到了各种饱受眼科疾病困扰的患者，青光眼、视网膜脱落、近视手术后遗症等等，这让我视力恢复之前都非常焦虑。在经历一系列眼科诊断之后，医生得出的结论是眼睛疲劳 + 近视度数上涨。于是，在同仁医院配了一副眼镜，自己额外配了一副隔蓝光的镜片，配合着服用叶黄素，进行修养。总体来说，是有效果的，但是效果还是有点慢。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-02.jpg?x-oss-process=image/resize,w_600" alt="" /></p><p>在 5 月份，五一长假休假在家，我尝试尽量不使用电脑和手机。即使使用电脑，也是投屏到电视上，然后坐在沙发上观看电视屏幕，尽量保持远距离观看。经过一个多星期的调养。眼睛疲劳改善非常明显。假期结束后，我期望着眼睛能完全恢复，可惜大概一个月作用的时间，眼睛又开始疲劳。特别是中午遇到强光时，症状会更加严重。</p><p>在 8 月份，我开始意识到眼睛疲劳可能是因为睡前和醒后躺在床上刷手机导致的。每次睡觉前我都会不由自主地刷一个多小时的手机，早上醒来也是躺在床上刷一个多小时手机，加上姿势不正确，导致视力疲劳。于是，我开始强制自己在床上玩手机不超过 20 分钟。坚持了半年了，现在视力明显恢复了。</p><p>在视力恢复之前，我一度非常焦虑，经常思考程序员的职业给我带来了什么？如果视力无法治疗该怎么办？…好在现在恢复了，这次经历让我明白了身体健康的重要性。一定要注意身体，不要让打工挣的钱成为身体的医疗费！从而言之，身体是革命的本钱。</p><h2 id="运动健身"><a class="markdownIt-Anchor" href="#运动健身"></a> 运动健身</h2><h3 id="健身"><a class="markdownIt-Anchor" href="#健身"></a> 健身</h3><p>8 月份，在 @昱总 的安利下，我办了天奥的健身卡，怕自己坚持不下来，先办了一年的年卡。由于 8 月份期间参加各种篮球赛，所以真正开始规律健身应该是从 9 月份开始，周一练背，周四练肩，周五练手臂，偶尔练练卧推。目前卧推能 60KG 做组，左右手力量也均衡了很多。除此之外，双十一配了肌酸和蛋白粉，喝的不算多，佛系健身。于我而言，健身的目的是为了自己变得壮一点，而不是看起来像细狗，仅此而已，什么健体、健美并不是我的目标。</p><h3 id="篮球"><a class="markdownIt-Anchor" href="#篮球"></a> 篮球</h3><p>今年算是工作以来打篮球最多的一年了，首先是固定每周二中午打 2 小时篮球。另外就是篮球赛，8 月参加了 CBD 篮球联赛，9 月参加了 CYBA 篮球联赛，这两个月周末总有一天是在打篮球。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-03.jpg?x-oss-process=image/resize,w_600" alt="" /></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-04.jpg?x-oss-process=image/resize,w_600" alt="" /></p><h3 id="跑步"><a class="markdownIt-Anchor" href="#跑步"></a> 跑步</h3><p>2022 年终总结时给自己定了一个目标——<strong>参加一次半程马拉松</strong>。因此，我计划参加 4 月份的北京半程马拉松。结果，等到报名时发现要求必须三年内参加过其他马拉松，并提供相关证明。没办法，没有资格参加，只能选择参加奥森马拉松。</p><p>我从 2.25 开始备战，从 5 公里开始，每周跑一次，每次比上一次增加 2.5 公里左右，最终达到 21 公里。练了一次 21 公里后，参加比赛。最终成绩还不错，用时 <code>2:01:52</code>。定一个 2024 年的小目标——<strong>半马破 2 小时</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-05.jpg?x-oss-process=image/resize,w_320" alt="" /></p><p>参加半马之后，我开始坚持每周末都跑一次 10 公里，偶尔还会参加一下线上马拉松，收集了不少奖牌。最终坚持到了 10 月底，11 月份室外跑步属实太冷了，打算 2 月份重新开始。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-06.jpg?x-oss-process=image/resize,w_800" alt="" /></p><h3 id="作息"><a class="markdownIt-Anchor" href="#作息"></a> 作息</h3><p>正是办了健身卡之后，我和媳妇开始调整生活作息，拒绝熬夜，晚上 11:20 之前睡觉。早上差不多能 6、7 点起床，起来后去四得公园，媳妇跑步，我则散步。在公园大概 40 分钟，期间能呼吸一下新鲜空气，放空一下大脑。当然在一个人散步的时候会思考很多，比如：职业规划、业余项目、技术问题等。散步结束回来大概 8 点左右，还能有两个小时看会儿书或写会儿代码。</p><p>调整作息之后，感觉自己的精神状态好了很多，下班时间的使用效率也变得更高了。当然，周末也不再是没有上午的周末，时间也变得更加充足。作息调整是今年个人转变的最大成就，为了健康和效率，未来一直要继续保持下去。</p><h1 id="学习收获"><a class="markdownIt-Anchor" href="#学习收获"></a> 学习收获</h1><p>上半年因为眼睛问题，有意减少电脑使用时间，下半年业余时间主要在项目，因此整体而言，2023 年在学习上投入的时间并不是很多。关于学习方面的成就主要有以下几部分。</p><h2 id="书籍"><a class="markdownIt-Anchor" href="#书籍"></a> 书籍</h2><p>因为尽量不过度用眼，今年看的书并不多，只有以下几本：</p><ul><li>《第一行代码——Android（第3版）》</li><li>《架构师的自我修炼》</li><li>《程序员修炼之道》</li><li>《On Java 基础版》</li><li>《重构》</li><li>《程序员的自我修养》三刷</li><li>《计算机图形学入门：3D渲染指南》</li></ul><h2 id="博客"><a class="markdownIt-Anchor" href="#博客"></a> 博客</h2><p>今年写的博客也不多，年初的时候产出了几篇编程语言相关的博客：<a href="http://chuquan.me/2023/01/15/actor/">《浅谈 Actor 模型》</a>、<a href="http://chuquan.me/2023/03/11/structured-concurrency/">《结构化并发》</a>、<a href="http://chuquan.me/2023/04/22/prototype-based-inheritance/">《基于原型的继承模式》</a>。</p><p>年中的时候研究 Homebrew 和 fishhook 产出了两篇原理分析博客：<a href="http://chuquan.me/2023/06/24/understand-fishhook-design/">《如何从链接原理的角度理解 fishhook 的设计思想？》</a>、<a href="http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/">《Homebrew 的设计哲学》</a>。</p><p>最后就是十一那会儿写了两篇关于差分算法的博客：<a href="http://chuquan.me/2023/09/13/myers-difference-algorithm/">《Myers 差分算法<br />》</a>、<a href="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/">《Paul Heckel 差分算法》</a>。</p><h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2><p>今年业余时间总共做了三个半项目，相比之前几年，产出高出了不少，希望明年继续保持。</p><p>第一个项目是 <a href="https://github.com/baochuquan/taskloop">Taskloop</a>。这是一款基于 crontab 的定时任务管理器，支持语义化的配置规则，并且支持环境变量导入、日持查询等功能。具体介绍详见 <a href="http://chuquan.me/2023/07/30/introduction-to-taskloop/">《如何优雅地管理你的定时任务？》</a>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800" alt="" /></p><p>第二个项目是 Morph Clock（中文名：莫负时钟）屏幕保护程序。这是一款 MacOS 屏幕保护程序，采用一种数字变形的艺术效果实现。</p><p>第三个项目是 <a href="https://apps.apple.com/us/app/morph-rest-break-reminder/id6474056217">Morph Rest</a>（中文名：莫负休息）。这是一款 MacOS 休息提醒应用程序，预防眼睛疲劳、腰间盘突出、劲椎疼痛等职业病，也可辅助提醒喝水，避免尿酸过高，引发痛风等疾病。为什么做这个项目？主要有两方面原因：一方面，我经历了眼睛疲劳，迫切需要一款软件能够经常提醒我站起来活动活动，让视线远离屏幕，顺带提醒自己多喝水。另一方面，我希望打造一款独立产品，尝试利用业务时间成为一位 Indie Hacker。于是，差不多花了一个半月的业余时间，完成了项目，并最终上架。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-07.png?x-oss-process=image/resize,w_800" alt="" /></p><p>Morph Clock 和 Morph Rest 则是面向普通 Mac 用户的独立产品。项目代码并没有开源，因为我希望能够通过它们创造收入，这里定一个小目标：<strong>在未来 2024 年内通过独立产品创造 99 美元的收入，回收的开通苹果开发者账号的成本</strong>。如果有用户支持，欢迎下载使用。</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>其他方面的学习收获也是有的，首先是 Android 开发，春节假期期间，在家学习了一下 Android 开发，重写了海豚 AI 学中的一个 Flutter 页面，算是入门了 Android。鉴于此，下半年能够做一些 Android 小需求。但是没有深入研究 Android 开发，也没有做过一些复杂业务开发，这一方面希望 2024 年能够有所改善。</p><p>其次，在下半年做独立产品期间，系统性地学习了 Sketch 相关技巧和理论。Morph Rest 和 Morph Clock 相关的 UI 设计和切图也都是自己完成的，算是额外掌握了一个 Indie Hacker 必备的技能吧。</p><p>最后，系统性地学习了一下 MacOS 开发，它与 iOS 开发在整体上一致的，在一些实现细节上有所不同。如果按照自己所认知的 iOS 原理来开发 MacOS 应用会遇到很多奇怪的 BUG。在系统性学习之后，再来开发 MacOS 应用会简单很多，这一点我深有体会。</p><h1 id="生活不只有工作"><a class="markdownIt-Anchor" href="#生活不只有工作"></a> 生活不只有工作</h1><p>今年是工作以来第一个没有债务的年份，因此不再考虑紧巴巴地生活了，该吃吃，该喝喝，该玩玩。不过因为疫情三年养成了一种「宅」感，所以还需要继续调整和适应。</p><h2 id="假期"><a class="markdownIt-Anchor" href="#假期"></a> 假期</h2><h3 id="合肥"><a class="markdownIt-Anchor" href="#合肥"></a> 合肥</h3><p>五一假期回合肥休假，为了调养眼睛疲劳，没怎么学习，主打的就是休假。期间主要在滨湖转悠，骑上共享电驴，环游了一些景点和公园，渡江战役纪念馆、岸上草原、安徽名人馆、塘西河公园、金斗公园等。比较可惜的是，没约上安徽美术馆，不过以后有的是机会。</p><p>在家期间，用闲置的 Mac Mini 配上电视，效果很不错，也很护眼。用这一套装置在家看完了《漫长的季节》！《漫长的季节》成为了我心中国产剧的 No.1，墙裂推荐！</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-09.jpg?x-oss-process=image/resize,w_800" alt="" /></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-10.jpg?x-oss-process=image/resize,w_800" alt="" /></p><h3 id="廊坊"><a class="markdownIt-Anchor" href="#廊坊"></a> 廊坊</h3><p>7 月份，我在朋友圈看到有同事去了廊坊的只有红楼梦·梦幻戏剧城，感觉很不错，加上自己很喜欢《红楼梦》，所以抽了一个周末去了一趟廊坊。园区非常大，网上的评价大多是一天的游玩时间不够，于是我们就订了 2 日通票。不得不说，里面的建筑和剧场都非常惊艳！绝对值得去玩一次！</p><p>不过很可惜，我们去的那个周末天气不太好。周六阴天，周日暴雨。因为暴雨园区闭园，给我们退了一半的票，算下来也就是玩了一天时间，差不多玩了大半个园区吧，只不过话剧和情景剧没看够。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-08.jpg?x-oss-process=image/resize,w_800" alt="" /></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-11.jpg?x-oss-process=image/resize,w_800" alt="" /></p><h3 id="哈尔滨"><a class="markdownIt-Anchor" href="#哈尔滨"></a> 哈尔滨</h3><p>今年 10 月份原本打算去哈尔滨，结果跟我弟了解了一下情况后，决定等到冰雪大世界开放之后再去。最终在元旦前请了几天假提前出发，主要是为了避开假期旅游高峰。好巧不巧，哈尔滨旅游今年出圈了，游客非常多，几个热门项目排队时间都超长，几乎每个都要排队 3 个小时起步，比如：大滑梯、摩天轮、哈冰秀。我们在冰雪大世界整一天就是佛系游玩，毕竟在零下十度的室外排队几个小时的体验可不是那么好。不过有一说一，冰雪大世界里的冰雕、雪雕确实都非常精美、壮观，绝对值得去参观一次！</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-12.jpg?x-oss-process=image/resize,w_800" alt="" /></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-13.jpg?x-oss-process=image/resize,w_600" alt="" /></p><h2 id="搬家"><a class="markdownIt-Anchor" href="#搬家"></a> 搬家</h2><p>今年 10 月份搬了一次家，离开了住了 6 年的高家园。高家园附近环境其实很不错，小区门口很多街边商店，很繁华；马路对面就是丽都，是一个相对比较高端的街区；500 米远处是四得公园，疫情期间翻修了一次，环境非常不错。因为生活很方便，所以在这里住了 6 年。搬家期间，特别是对面的室友搬走的时候，内心非常感慨：岁月匆匆，人生匆匆，北漂生活何时终了？</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-14.jpg?x-oss-process=image/resize,w_600" alt="" /></p><h1 id="思维转变"><a class="markdownIt-Anchor" href="#思维转变"></a> 思维转变</h1><p>2023 年，我感觉自己最大的变化是思维的转换，主要是两点：</p><ul><li>身体是最重要的，其他的一切都是身外之物。</li><li>打工是没有出路的，提前计划自己的未来。</li></ul><p>第一点不用多说，是眼睛疲劳期间非常焦虑，那会儿才真正体会和理解这一点。第二点是因为今年 8 月开始早起散步，散步期间开始思考未来的打算。这两年各种裁员消息层出不穷，即使你学历再好，技术再厉害，当公司不需要你时，无外乎其他任何因素，随时都可能裁你。一旦失业，你再就业的难度会与你的年龄正比，这是非常现实的问题。</p><p>于是，我开始逛一下独立开发者相关的网站，比如：Indie Hacker，Product Hunt，w2solo。在这些论坛中，我看到了很多独立开发者的成功案例，这也激励了我尝试使用业余时间来走这条道路。11 月份，我开始着手做一款 iOS App，期间自己做产品调研，画设计稿，代码实现。期间感觉自己对于产品的最终效果还是有点不确定，而且担心战线太长，所以果断暂停了项目，转而开发形态更加确定的一款 MacOS App——<a href="https://apps.apple.com/cn/app/morph-rest-break-reminder/id6474056217?mt=12">MorphRest</a>。期间，还写了一个 MacOS 屏幕保护程序——Morph Clock。这些产品未来不一定能成功，但是我不迈出这一步，那么永远都不会成功。</p><h1 id="新年愿景"><a class="markdownIt-Anchor" href="#新年愿景"></a> 新年愿景</h1><p>未来一年，我应该还会继续尝试做一些独立产品，努力成为 Indie Hacker。当然，技术博客也会被不定期更新，毕竟这是热爱，而不是生活。</p><p>最后，祝新年快乐~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/2023-summary-01.jpg?x-oss-process=image/resize,w_600&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="年度总结" scheme="http://chuquan.me/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Sketch Cheat Sheet</title>
    <link href="http://chuquan.me/2023/10/21/sketch-cheat-sheet/"/>
    <id>http://chuquan.me/2023/10/21/sketch-cheat-sheet/</id>
    <published>2023-10-21T14:01:50.000Z</published>
    <updated>2023-10-21T14:05:47.410Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/sketch-exercise01.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>我的博客文章配图基本上都是使用 Sketch绘制的，但是绘制方法仅限我的自我认知而已。由于没有系统性地学习过Sketch，因此在遇到一些复杂场景时，绘制的效率非常低。于是最近业余时间在 B站上学习了一套 Sketch 教程——<ahref="https://www.bilibili.com/video/BV1hd4y1z7pZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=247f8a5d677ea1cff0161b9afe62e41f">《Sketch零基础速学教程（矢量绘图设计工具）》</a>。</p><p>这里记录一下教程中提到的快捷键技巧，便于后续参考。经过实测，这些技巧确实能够提升效率，文章封面图就是学完教程结合技巧绘制的图标。</p><h1 id="快捷键">快捷键</h1><h2 id="基础快捷键">基础快捷键</h2><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">新建画板（New Artboard）</td><td style="text-align: left;">A</td></tr><tr class="even"><td style="text-align: left;">插入矩形（Rectangle）</td><td style="text-align: left;">R</td></tr><tr class="odd"><td style="text-align: left;">插入原型（Oval）</td><td style="text-align: left;">O</td></tr><tr class="even"><td style="text-align: left;">插入文本（Text）</td><td style="text-align: left;">T</td></tr><tr class="odd"><td style="text-align: left;">钢笔工具（Vector Point）</td><td style="text-align: left;">V</td></tr><tr class="even"><td style="text-align: left;">放大（Zoom</td><td style="text-align: left;">按住 Z，然后框选想放大的区域</td></tr><tr class="odd"><td style="text-align: left;">查看间距（Guides）</td><td style="text-align: left;">Alt（选中一个图层，按住Alt，鼠标移动移动到另一个图层，可查看选中图层到指向图层的间距）</td></tr><tr class="even"><td style="text-align: left;">创建分组（Group）</td><td style="text-align: left;">⌘ G</td></tr><tr class="odd"><td style="text-align: left;">取消分组（Ungroup）</td><td style="text-align: left;">⌘ ⇧ G</td></tr><tr class="even"><td style="text-align: left;">复制上一步操作（Duplicate</td><td style="text-align: left;">⌘ D</td></tr><tr class="odd"><td style="text-align: left;">编辑（Edit）</td><td style="text-align: left;">Enter</td></tr></tbody></table><h2 id="吸管工具">吸管工具</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">吸取颜色（Color Picker）</td><td style="text-align: left;">⌃ C</td></tr></tbody></table><h2 id="复制样式">复制样式</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">复制图层样式（Copy Style）</td><td style="text-align: left;">⌘ ⌥ C</td></tr><tr class="even"><td style="text-align: left;">粘贴图层样式（Paste Style）</td><td style="text-align: left;">⌘ ⌥ V</td></tr></tbody></table><h2 id="视图模式">视图模式</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">演示模式（Presentation Mode）</td><td style="text-align: left;">⌘ .</td></tr><tr class="even"><td style="text-align: left;">以画布为中心放大（Center Canvas）</td><td style="text-align: left;">⌘ 1</td></tr><tr class="odd"><td style="text-align: left;">以选择的图层为中心放大（ZoomSelection）</td><td style="text-align: left;">⌘ 2</td></tr><tr class="even"><td style="text-align: left;">视图放大</td><td style="text-align: left;">⌘ +</td></tr><tr class="odd"><td style="text-align: left;">视图缩小</td><td style="text-align: left;">⌘ -</td></tr><tr class="even"><td style="text-align: left;">恢复到画布实际大小</td><td style="text-align: left;">⌘ 0</td></tr></tbody></table><h2 id="图层">图层</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">在图层面板从上往下选择图层（SelectingLayer Below）</td><td style="text-align: left;">tab</td></tr><tr class="even"><td style="text-align: left;">在图层面板从下往上选择图层（SelectingLayer Below）</td><td style="text-align: left;">⇧ tab</td></tr><tr class="odd"><td style="text-align: left;">上移图层（Bring Forward）</td><td style="text-align: left;">⌘ ]</td></tr><tr class="even"><td style="text-align: left;">下移图层（Bring Backward）</td><td style="text-align: left;">⌘ [</td></tr><tr class="odd"><td style="text-align: left;">置顶图层（Bring to Front）</td><td style="text-align: left;">⌘ ⌥ ]</td></tr><tr class="even"><td style="text-align: left;">置底图层（Bring to End）</td><td style="text-align: left;">⌘ ⌥ [</td></tr></tbody></table><h2 id="相关补充">相关补充</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">隐藏图层</td><td style="text-align: left;">⌘ ⇧ H</td></tr><tr class="even"><td style="text-align: left;">锁定图层</td><td style="text-align: left;">⌘ ⇧ L</td></tr><tr class="odd"><td style="text-align: left;">查找图层</td><td style="text-align: left;">⌘ F</td></tr><tr class="even"><td style="text-align: left;">变换工具</td><td style="text-align: left;">⌘ ⇧ T</td></tr><tr class="odd"><td style="text-align: left;">旋转工具</td><td style="text-align: left;">⌘ ⇧ R</td></tr><tr class="even"><td style="text-align: left;">将字体转换成轮廓</td><td style="text-align: left;">⌘ ⌥ O</td></tr><tr class="odd"><td style="text-align: left;">显示/取消填充</td><td style="text-align: left;">F</td></tr><tr class="even"><td style="text-align: left;">显示/取消描边</td><td style="text-align: left;">B</td></tr><tr class="odd"><td style="text-align: left;">将当前图层用作蒙版</td><td style="text-align: left;">⌘ ⌃ M</td></tr><tr class="even"><td style="text-align: left;">改变形状尺寸</td><td style="text-align: left;">⌘ 键盘上/下/左/右</td></tr><tr class="odd"><td style="text-align: left;">切换不同的 Sketch 文件</td><td style="text-align: left;">⌘ ~</td></tr></tbody></table><h2 id="设置">设置</h2><table><thead><tr class="header"><th style="text-align: left;">功能</th><th style="text-align: left;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">打开设置</td><td style="text-align: left;">⌘ ,</td></tr></tbody></table><h1 id="屏幕分辨率尺寸">屏幕分辨率尺寸</h1><table><thead><tr class="header"><th style="text-align: left;">设备</th><th style="text-align: left;">屏幕尺寸</th><th style="text-align: left;">屏幕分辨率（px）</th><th style="text-align: left;">逻辑分辨率（pt）</th><th style="text-align: left;">PPI</th><th style="text-align: left;">倍率</th><th style="text-align: left;">换算</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">iPhone14</td><td style="text-align: left;">6.1寸</td><td style="text-align: left;">1170x2532</td><td style="text-align: left;">390x844</td><td style="text-align: left;">460</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone12 Pro Max</td><td style="text-align: left;">6.7寸</td><td style="text-align: left;">1284x2778</td><td style="text-align: left;">428x926</td><td style="text-align: left;">458</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="odd"><td style="text-align: left;">iPhone12 Pro</td><td style="text-align: left;">6.1寸</td><td style="text-align: left;">1170x2532</td><td style="text-align: left;">390x844</td><td style="text-align: left;">460</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone11 Pro Max</td><td style="text-align: left;">6.5寸</td><td style="text-align: left;">1242x2688</td><td style="text-align: left;">414x896</td><td style="text-align: left;">458</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="odd"><td style="text-align: left;">iPhone11 Pro</td><td style="text-align: left;">6.1寸</td><td style="text-align: left;">1125x2436</td><td style="text-align: left;">375x812</td><td style="text-align: left;">458</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone11</td><td style="text-align: left;">5.8寸</td><td style="text-align: left;">828x1792</td><td style="text-align: left;">414x896</td><td style="text-align: left;">326</td><td style="text-align: left;"><span class="citation"data-cites="2x">@2x</span></td><td style="text-align: left;">1pt=2px</td></tr><tr class="odd"><td style="text-align: left;">iPhone8 Plus</td><td style="text-align: left;">5.5寸</td><td style="text-align: left;">1242x2208</td><td style="text-align: left;">414x736</td><td style="text-align: left;">401</td><td style="text-align: left;"><span class="citation"data-cites="3x">@3x</span></td><td style="text-align: left;">1pt=3px</td></tr><tr class="even"><td style="text-align: left;">iPhone8</td><td style="text-align: left;">4.7寸</td><td style="text-align: left;">750x1334</td><td style="text-align: left;">375x667</td><td style="text-align: left;">326</td><td style="text-align: left;"><span class="citation"data-cites="2x">@2x</span></td><td style="text-align: left;">1pt=2px</td></tr><tr class="odd"><td style="text-align: left;">iPhoneSE</td><td style="text-align: left;">4.0寸</td><td style="text-align: left;">640x1136</td><td style="text-align: left;">320x568</td><td style="text-align: left;">326</td><td style="text-align: left;"><span class="citation"data-cites="2x">@2x</span></td><td style="text-align: left;">1pt=2px</td></tr><tr class="even"><td style="text-align: left;">iPhone3GS</td><td style="text-align: left;">3.5寸</td><td style="text-align: left;">320x480</td><td style="text-align: left;">320x480</td><td style="text-align: left;">163</td><td style="text-align: left;"><span class="citation"data-cites="1x">@1x</span></td><td style="text-align: left;">1pt=1px</td></tr></tbody></table><p>UI 设计一般以 390x844 或 375x812 为尺寸进行绘制。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/sketch-exercise01.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计" scheme="http://chuquan.me/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Sketch" scheme="http://chuquan.me/tags/Sketch/"/>
    
  </entry>
  
  <entry>
    <title>Paul Heckel 差分算法</title>
    <link href="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/"/>
    <id>http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/</id>
    <published>2023-10-06T14:01:00.000Z</published>
    <updated>2023-10-07T00:13:19.803Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇 <ahref="http://chuquan.me/2023/09/13/myers-difference-algorithm/">文章</a>我们介绍了 Myers差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——PaulHeckel 差分算法。</p><span id="more"></span><h1 id="解决什么问题">解决什么问题？</h1><p>通过前一篇文章，我们知道 Myers 差分算法主要用于<strong>解决特定设定下的最小编辑距离问题</strong>，即：当编辑操作只支持<strong>插入</strong> 和 <strong>删除</strong> 时，计算一个文件从<code>A</code> 状态转换成 <code>B</code>状态所需的最少编辑次数（或编辑方式）。算法特别适用于对编辑次数敏感，但是对速度和内存不敏感的系统，比如版本控制系统。</p><p>对比而言，Paul Heckel 差分算法则主要用于<strong>解决最小化差异问题</strong>，即：当一个文件从 <code>A</code>状态转换成 <code>B</code>状态时，两种状态之间的数据差异。算法会为每一项差异定义一个对应的类型（操作），比如：删除、插入、移动等，其侧重点在于最小化差异，而不是最小化编辑。PaulHeckel 差分算法特别适合对计算速度敏感，但是对于<strong>差异不敏感</strong> 的系统，比如实时数据分析系统，UI框架数据差分。</p><h1 id="算法原理">算法原理</h1><h2 id="核心思想">核心思想</h2><p>Paul Heckel算法使用三种类型来表示两个文件之间的差异结果，分别是：<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。基于此，算法的核心思路其实非常简单，分别是：</p><ul><li><strong>确定旧文件中待删除的行</strong></li><li><strong>确定新文件中待插入的行</strong></li><li><strong>确定旧文件至新文件中待移动的行，并记录行号关系（旧文件行号、新文件行号）</strong></li></ul><h2 id="数据结构">数据结构</h2><p>很显然，根据算法的核心思想，新旧两个文件中的所有行最终都将被分类为三种类型（如果行的内容和位置都没有变化，则分类为移动类型，只不过移动的行号保持不变而已）。</p><p>Paul Heckel 差分算法使用两个数组 <code>NA</code>（New Array）和<code>OA</code>（OldArray）分别记录新旧两个文件的每一行的信息。数组元素分为两种类型：<strong>指针</strong>或<strong>行号</strong>。通过这种方式，我们可以对新旧两个文件中的所有行进行分类：</p><ul><li>当旧文件中某一行在 <code>OA</code>中对应的元素为指针时，表示这一行是待删除的。</li><li>当新文件中某一行在 <code>NA</code>中对应的元素为指针时，表示这一行是待插入的。</li><li>当新文件（旧文件）中某一行在<code>NA</code>（<code>OA</code>）中对应的元素为行号时，表示这一行是待移动的。行号记录了它在旧文件（新文件）的位置。两两配对。</li></ul><p>这里提到了数组元素可能是指针类型，那么它到底指向什么类型的数据呢？事实上，这是Paul Heckel 算法预定义的一种数据类型，这里我们称之为 entry 类型。entry的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">entry</span> &#123;</span><br><span class="line">    <span class="type">int</span> oc;         <span class="comment">// old count. 记录该行在旧文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> nc;         <span class="comment">// new count. 记录该行在新文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> olno;       <span class="comment">// old line number. 记录该行在旧文件中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，为了方便快速查找某一行所对应的entry，这里还定义了一个哈希表，算法中称为 <strong>符号表（SymbolTable）</strong>，其中 Key 为行内容，Value 为 entry。</p><p>如下所示，为算法所定义的相关数据结构。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-01.png?x-oss-process=image/resize,w_800" /></p><h1 id="算法实现">算法实现</h1><p>算法的实现主要分为三个部分，分别是：</p><ul><li>构建阶段</li><li>移动类型筛选</li><li>分析输出</li></ul><p>下面依次进行介绍。</p><h2 id="构建阶段">构建阶段</h2><p>在构建阶段，将遍历新文件和旧文件的每一行，同时构建数组、符号表表项（Key为行内容，Value 为 Entry）。</p><ul><li>对于新文件，在构建 Entry 时，对 <code>nc</code> 字段加 1。</li><li>对于旧文件，在构建 Entry 时，对 <code>oc</code> 字段加 1，并设置<code>olno</code> 为当前的行号。</li></ul><p>在构建数组（ <code>NA</code> 和 <code>OA</code>）时，其元素均为指针类型，指向当前行对应在符号表中的 entry。</p><p>很显然，构建阶段需要进行两次遍历，其对应在论文中分别是 Pass 1 和 Pass2。</p><h2 id="移动类型筛选">移动类型筛选</h2><p>在构建阶段完成后，数组 <code>NA</code> 和 <code>OA</code>中的所有元素都是指针类型，指向符号表中的某个entry。接下来，只要我们把属于 <strong>移动</strong>类型的行筛选出来，也就是把数组中的某些元素修改为行号，即可完成对三种类型的分类。</p><p>在继续介绍之前，我们先说明一种常见的情况：<strong>一个文件中行内容可能是唯一项，也可能是重复项</strong>。比如，在下图所示的两个文件中，<code>THE</code>在新旧两个文件中都重复出现了两次，<code>A</code>、<code>MASS</code>、<code>OF</code>等内容在各自的文件中都是唯一项。对此，算法的处理方式也有所不同。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-03.png?x-oss-process=image/resize,w_800" /></p><h3 id="唯一项筛选">唯一项筛选</h3><p>对于唯一项，很显然，如果符合移动类型的话，行所对应的 entry 中的<code>oc</code> 和 <code>nc</code> 的值均为1，表示它们在新旧文件中各自只出现了一次。</p><p>由于移动类型是对等的，所以我们只需要遍历 <code>NA</code>数组就可以找到所有唯一项的移动类型。具体的做法是：</p><ul><li>遍历 <code>NA</code> 数组，根据元素（指针类型）找到对应的entry。</li><li>判断 entry 的 <code>oc</code> 和 <code>nc</code> 字段是否均为 1。<ul><li>如果符合条件，则将 <code>NA</code>对应的位置的元素设置成行号类型，值为<code>olno</code>（即该行对应在旧文件中的位置）；同时将 <code>OA</code>的 <code>olno</code> 位置的元素设置成行号类型，值为<code>i</code>（即当前遍历到的行号）。此时，两者实现了移动匹配（各自记录了彼此的位置）。</li><li>如果不符合条件，则将继续遍历 <code>NA</code>。</li></ul></li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-04.png?x-oss-process=image/resize,w_800" /></p><p>在遍历完成后，数组 <code>NA</code> 和 <code>OA</code>中均可能有一部分元素变成了行号类型，值为对方的某个行号。本轮遍历对应在论文中是Pass 3。</p><h3 id="重复项筛选">重复项筛选</h3><p>对于重复项，算法采用了一种模糊处理的方式。这里主要遵循了下面这个设定：</p><blockquote><p>If a line has been found to be unaltered, and the lines immediatelyadjacent to it in both files are identical, then these lines must be thesame line. This information can be used to find blocks of unchangedlines.</p><p>译：如果某一行没有发生改变，并且在新旧两个文件中与它紧邻的行都是相同的，那么这些行必须是相同的行。这个信息可以用来找到未改变的行块。</p></blockquote><p>上述设定需要寻找某一行前后邻近的行，很显然，需要进行两次遍历，分别是正向遍历和反向遍历。同样，这里只需要遍历<code>NA</code> 即可。</p><p>对于正向遍历，会进行以下处理：</p><ul><li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示<code>NA[i]</code> 指向 <code>OA[j]</code>）<ul><li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>类型的行，那么继续判断 <code>NA[i+1]</code> 是否与 <code>OA[j+1]</code>指向同一个 entry。<ul><li>如果是，则将 <code>NA[i+1]</code> 的元素设置成行号类型，值为<code>j+1</code>；将 <code>OA[j+1]</code> 的元素设置成行号类型，值为<code>i+1</code>。</li></ul></li></ul></li><li>此外其他情况均继续遍历 <code>NA</code>。</li></ul><p>对于反向遍历，其处理与正向遍历类似，只不过方向相反：</p><ul><li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示<code>NA[i]</code> 指向 <code>OA[j]</code>）<ul><li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>类型的行，那么继续判断 <code>NA[i-1]</code> 是否与 <code>OA[j-1]</code>指向同一个 entry。<ul><li>如果是，则将 <code>NA[i-1]</code> 的元素设置成行号类型，值为<code>j-1</code>；将 <code>OA[j-1]</code> 的元素设置成行号类型，值为<code>i-1</code>。</li></ul></li></ul></li><li>此外其他情况均继续遍历 <code>NA</code>。</li></ul><p>经过这一番操作后，算法会处理筛选出重复项，下图所示红色标识。这些重复项的<strong>移动</strong> 类型，可以与某些唯一项连成<strong>移动块</strong>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-02.png?x-oss-process=image/resize,w_800" /></p><p>重复项的筛选，经历了两次遍历，分别对应论文中的 Pass 4 和 Pass 5。</p><h2 id="分析输出">分析输出</h2><p>经过上述一系列处理之后，数组 <code>NA</code> 和 <code>OA</code>将所有行分成了三种类型，分别是<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。根据这些信息，我们可以遍历<code>NA</code> 和<code>OA</code>，输出差异的分析结果。这一步，对应在论文中则是 Pass6。</p><h1 id="算法缺陷">算法缺陷</h1><p>至此，仔细的同学可能会发现，在重复项筛选的过程中，算法会遗漏一部分属于<strong>移动</strong> 类型的行，而将它们误判为 <strong>删除</strong> 或<strong>插入</strong> 类型。</p><p>如下所示为算法误判的一个例子。我们将新文件中的第一个 <code>THE</code>前后相邻的两个行改成两个唯一项 <code>UNIQUE1</code> 和<code>UNIQUE2</code>。由于旧文件中不存在 <code>UNIQUE1</code> 和<code>UNIQUE2</code>，所以它们是属于插入类型的项。此时，我们再看上述Pass 4 和 Pass 5 的执行逻辑，可以看出新文件中的第一个 <code>THE</code>并不会并筛选为移动类型，而是被错误地认为是插入类型。所以说，Paul Heckel算法对于重复项的处理采用了一种模糊处理的方式。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-05.png?x-oss-process=image/resize,w_800" /></p><p>事实上，这也是 Paul Heckel差分算法的特点，它牺牲了一部分差异精准度，换来了更快的分析速度。这也是为什么我们在「解决了什么问题」这一节中说Paul Heckel 算法适合速度敏感、差异不敏感的系统。</p><h1 id="算法应用">算法应用</h1><p>基于 Paul Heckel 算法变种的差分算法应用其实非常多，在 iOS开发中就有很多相关的框架，比如：IGListKit、DifferenceKit、RxDataSources、FlexibleDiff、DeepDiff等。下面，我们来看看 IGListKit 是如何应用并优化 Paul Heckel差分算法的。</p><h2 id="类型扩展">类型扩展</h2><p>由于绝大多数应用都对 Paul Heckel算法进行了一定程度的优化，因此，我们必须要先了解它们到底优化了什么。</p><p>事实上，原始的 Paul Heckel 算法只对 <strong>位置</strong> 和<strong>内容</strong> 两个维度进行差分检测（符号表的 Key和数据判等都是基于 <strong>内容</strong>），从而产生 3种分类，如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">位置</th><th style="text-align: left;">内容</th><th style="text-align: left;">分类</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move（起始位置不变）</td></tr><tr class="even"><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr><tr class="odd"><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move</td></tr><tr class="even"><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr></tbody></table><p>但是在实际应用中，为了支持更加复杂多变的场景，一般会额外支持<strong>标识</strong> 或 <strong>ID</strong> 的维度。此时，算法将基于<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong>三个维度进行差分检测（符号表的 Key 基于<strong>标识</strong>，数据判等基于 <strong>内容</strong>），对此将产生4 种分类，如下表所示。</p><table><thead><tr class="header"><th style="text-align: left;">标识（ID）</th><th style="text-align: left;">位置</th><th style="text-align: left;">内容</th><th style="text-align: left;">分类</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move（起始位置不变）</td></tr><tr class="even"><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">update</td></tr><tr class="odd"><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">move</td></tr><tr class="even"><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">update &amp; move</td></tr><tr class="odd"><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">相同</td><td style="text-align: left;">insert/delete</td></tr><tr class="even"><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr><tr class="odd"><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">相同</td><td style="text-align: left;">insert/delete</td></tr><tr class="even"><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">不同</td><td style="text-align: left;">insert/delete</td></tr></tbody></table><h2 id="iglistdiff">IGListDiff</h2><h3 id="数据结构-1">数据结构</h3><p>在数据结构定义上，IGListDiff与原始算法类似，也定义了一个符号表和两个数组，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-06.png?x-oss-process=image/resize,w_800" /></p><p>对于符号表，IGListDiff 使用数据的标识（ID）作为 Key，以<code>IGListEntry</code> 作为 Value。<code>IGListEntry</code>的定义如下所示，很显然，它与原始算法中的 <code>entry</code>结构非常类似：</p><ul><li><code>oldCounter</code> 和 <code>newCounter</code> 对应的是<code>oc</code> 和 <code>nc</code> 字段。</li><li><code>oldIndex</code> 对应<code>olno</code>，但是它支持记录多个位置信息，支持处理重复项。<code>olno</code>只能记录一个位置。</li><li><code>IGListEntry</code> 额外还有一个 <code>updated</code>字段，用于标记扩展的 <strong>更新</strong>（update）类型。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Used to track data stats while diffing.</span></span><br><span class="line"><span class="keyword">struct</span> IGListEntry &#123;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the old array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> oldCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the new array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The indexes of the data in the old array</span></span><br><span class="line">    stack&lt;<span class="built_in">NSInteger</span>&gt; oldIndexes;</span><br><span class="line">    <span class="comment">/// Flag marking if the data has been updated between arrays by checking the isEqual: method</span></span><br><span class="line">    <span class="type">BOOL</span> updated = <span class="literal">NO</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于两个数组，IGListDiff同样具备，区别在于元素的表示形式。在原始算法中，<code>NA</code> 和<code>OA</code> 数组存储的元素可能是指针或行号，而 IGListDiff 则使用<code>IGListRecord</code>类型来记录两种信息，其定义如下所示。其中，<code>entry</code>用于存储指针，<code>index</code> 用于存储行号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Track both the entry and algorithm index. Default the index to NSNotFound</span></span><br><span class="line"><span class="keyword">struct</span> IGListRecord &#123;</span><br><span class="line">    IGListEntry *entry;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">NSInteger</span> index;</span><br><span class="line"></span><br><span class="line">    IGListRecord() &#123;</span><br><span class="line">        entry = <span class="literal">NULL</span>;</span><br><span class="line">        index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，IGListDiff 定义一个 <code>IGListDiffable</code>协议，所有希望调用 IGListDiff 差分算法的数据都必须支持该协议。如下所示为<code>IGListDiffable</code> 的定义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListDiffable)</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListDiffable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a key that uniquely identifies the object.</span></span><br><span class="line"><span class="comment"> @return A key that can be used to uniquely identify the object.</span></span><br><span class="line"><span class="comment"> @note Two objects may share the same identifier, but are not equal. A common pattern is to use the `NSObject` category for automatic conformance. However this means that objects will be identified on their pointer value so finding updates becomes impossible.</span></span><br><span class="line"><span class="comment"> @warning This value should never be mutated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;)diffIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns whether the receiver and a given object are equal.</span></span><br><span class="line"><span class="comment"> @param object The object to be compared to the receiver.</span></span><br><span class="line"><span class="comment"> @return `YES` if the receiver and object are equal, otherwise `NO`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToDiffableObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;IGListDiffable&gt;)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>算法会使用数据的 <code>diffIdentifier</code>作为标识（ID），符号表也将以此为 Key 记录对应的 entry。另一个协议方法<code>isEqualToDiffableObject:</code> 则用于进行内容判等。</p><p>关于输出，原始算法并没有做相关说明。对此，IGListDiff自定义了两种输出结构，分别是 <code>IGListIndexSetResult</code> 和<code>IGListIndexPathResult</code>，如下所示。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexPathResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexPathResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The index paths inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *inserts;</span><br><span class="line"><span class="comment">// The index paths deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *deletes;</span><br><span class="line"><span class="comment">// The index paths in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *updates;</span><br><span class="line"><span class="comment">// The moves from an index path in the old collection to an index path in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndexPath *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexSetResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexSetResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The indexes inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *inserts;</span><br><span class="line"><span class="comment">// The indexes deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *deletes;</span><br><span class="line"><span class="comment">// The indexes in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *updates;</span><br><span class="line"><span class="comment">// The moves from an index in the old collection to an index in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndex *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>两者均携带了所有差异数据的位置信息，包括：插入、删除、更新、移动。区别则在于<code>IGListIndexPathResult</code> 用于表示位置信息的类型是<code>NSIndexPath</code> 类型，适用于 iOS中的列表数据，<code>IGListIndexSetResult</code> 用于表示位置信息的类型是<code>NSInteger</code> 类型，更适合通用的数组数据。</p><h3 id="核心逻辑">核心逻辑</h3><p>IGListDiff 中 <code>IGListDiff.m</code> 文件的<code>IGListDiffing</code>方法实现了差分算法的核心逻辑，大概可分为三个步骤：</p><ul><li><strong>构建阶段</strong></li><li><strong>标记移动类型和更新类型</strong></li><li><strong>格式化输出</strong></li></ul><h4 id="构建阶段-1">构建阶段</h4><p>在构建阶段，IGListDiff分别正向遍历新数据和反向遍历旧数据，从而构建数组元素<code>NA</code>、<code>OA</code>、符号表，这一点与原始算法类似。这里反向遍历旧数据是因为这里使用栈来记录所有的<code>olno</code>，以便后续正向地出栈旧数据的位置信息。具体代码如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;, IGListEntry, IGListHashID, IGListEqualID&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 1</span></span><br><span class="line"><span class="comment">// create an entry for every item in the new array</span></span><br><span class="line"><span class="comment">// increment its new count for each occurence</span></span><br><span class="line">vector&lt;IGListRecord&gt; newResultsArray(newCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(newArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.newCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add NSNotFound for each occurence of the item in the new array</span></span><br><span class="line">    entry.oldIndexes.push(<span class="built_in">NSNotFound</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    newResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 2</span></span><br><span class="line"><span class="comment">// update or create an entry for every item in the old array</span></span><br><span class="line"><span class="comment">// increment its old count for each occurence</span></span><br><span class="line"><span class="comment">// record the original index of the item in the old array</span></span><br><span class="line"><span class="comment">// MUST be done in descending order to respect the oldIndexes stack construction</span></span><br><span class="line">vector&lt;IGListRecord&gt; oldResultsArray(oldCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(oldArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.oldCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the original indices where the item occurred onto the index stack</span></span><br><span class="line">    entry.oldIndexes.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    oldResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标记移动类型和更新类型">标记移动类型和更新类型</h4><p>构建完成之后，开始对移动类型和更新类型进行标记，具体如下代码所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass 3</span></span><br><span class="line"><span class="comment">// handle data that occurs in both arrays</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    IGListEntry *entry = newResultsArray[i].entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grab and pop the top original index. if the item was inserted this will be NSNotFound</span></span><br><span class="line">    <span class="built_in">NSCAssert</span>(!entry-&gt;oldIndexes.empty(), <span class="string">@&quot;Old indexes is empty while iterating new item %li. Should have NSNotFound&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> originalIndex = entry-&gt;oldIndexes.top();</span><br><span class="line">    entry-&gt;oldIndexes.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// originalIndex 存在表示「标识相同」。这里判断 originalIndex &lt; oldCount 应该是为了做越界保护。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex &lt; oldCount) &#123;</span><br><span class="line">        <span class="comment">// 对于「内容不同」的项，将其标记为更新类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; n = newArray[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; o = oldArray[originalIndex];</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffPointerPersonality:</span><br><span class="line">                <span class="comment">// 基于指针判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffEquality:</span><br><span class="line">                <span class="comment">// 基于指针 + 内容判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o &amp;&amp; ![n isEqualToDiffableObject:o]) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，并且内容不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0 表示新旧数据均存在</span></span><br><span class="line">    <span class="comment">// originalIndex != NSNotFound 的是为了让新旧数据两两匹配，因为 oldIndexes 随着遍历的迭代，始终在出栈。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex != <span class="built_in">NSNotFound</span></span><br><span class="line">        &amp;&amp; entry-&gt;newCounter &gt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; entry-&gt;oldCounter &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 对于「内容相同」的项，交换记录其在对方数组中的位置，表示移动类型</span></span><br><span class="line">        newResultsArray[i].index = originalIndex;</span><br><span class="line">        oldResultsArray[originalIndex].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，每次迭代会从根据 <code>NA</code> 数组元素<code>IGListRecord</code> 的 <code>entry</code> 字段索引到符号表中对应的<code>IGListEntry</code>。然后从 <code>IGListEntry</code> 的<code>oldIndexes</code> 字段出栈一个旧文件中存在的位置。</p><p>如果 <code>originalIndex</code> 存在，则表示 <code>NA</code> 和<code>OA</code> 均存在，此时进一步判断内容，如果内容发生了变化则标记<code>updated</code> 字段为<code>YES</code>。判断内容变化的方式有两种，用户可以选择配置：</p><ul><li><strong>基于指针判断</strong>：如果指针不同，则表示数据发生了变化</li><li><strong>基于指针+内容判断</strong>：如果指针不同，并且内容不同，则表示数据发生了变化</li></ul><p>在遍历过程中，还会记录移动类型的位置信息。它的前提条件包含两部分：</p><ul><li><code>newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0</code>：表示新旧数据均存在</li><li><code>originalIndex != NSNotFound</code>：表示新旧数据可以进行移动类型的匹配，每一次匹配，<code>oldIndexes</code>都会出栈一次，消耗一次对等的匹配。举个例子：<ul><li>如果 <code>newCounter = 3</code>，<code>oldCounter = 2</code>时，<code>NA</code>中第三个数据会被归为插入类型，前两个数据会被归为移动类型。</li><li>如果 <code>newCounter = 2</code>，<code>oldCounter = 3</code>时，<code>OA</code>中的第三个数据会被归为删除类型，前两个数据会被归为移动类型。</li></ul></li></ul><h4 id="格式化输出">格式化输出</h4><p>首先，遍历 <code>OA</code>数组，确定删除类型，具体代码如下所示。数组元素的 <code>index</code>类型为 <code>NSNotFound</code> 类似于原始算法中 <code>OA</code>元素的类型为指针。当符合这个条件时，表示数据类型为删除类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterate old array records checking for deletes</span></span><br><span class="line"><span class="comment">// incremement offset for each delete</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">    deleteOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = oldResultsArray[i];</span><br><span class="line">    <span class="comment">// if the record index in the new array doesn&#x27;t exist, its a delete</span></span><br><span class="line">    <span class="comment">// 对 OA 中的删除项进行分类</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，遍历 <code>NA</code>数组，确定插入、更新、移动等类型，具体代码如下所示。数组元素的<code>index</code> 类型为 <code>NSNotFound</code> 类似于原始算法中<code>NA</code>元素的类型为指针。当符合这个条件时，表示数据类型为插入类型。否则，均属于移动类型。</p><p>这里由于 IGListDiff 额外扩展了一个 <code>updated</code>字段，所以有一部分元素为同时标记为更新类型。这一点其实很容易理解，当新旧数据中有一个数据标识相同，但是位置不同，且内容不同，我们可以认为它做了一次移动操作修改了位置，又做了一次更新操作修改了内容。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    insertOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = newResultsArray[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> oldIndex = record.index;</span><br><span class="line">    <span class="comment">// add to inserts if the opposing index is NSNotFound</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定插入类型</span></span><br><span class="line">        addIndexToCollection(returnIndexPaths, mInserts, toSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// note that an entry can be updated /and/ moved</span></span><br><span class="line">        <span class="keyword">if</span> (record.entry-&gt;updated) &#123;</span><br><span class="line">            <span class="comment">// 确定更新类型</span></span><br><span class="line">            addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate the offset and determine if there was a move</span></span><br><span class="line">        <span class="comment">// if the indexes match, ignore the index</span></span><br><span class="line">        <span class="comment">// 确定移动类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> insertOffset = insertOffsets[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> deleteOffset = deleteOffsets[oldIndex];</span><br><span class="line">        <span class="keyword">if</span> ((oldIndex - deleteOffset + insertOffset) != i) &#123;</span><br><span class="line">            <span class="type">id</span> move;</span><br><span class="line">            <span class="keyword">if</span> (returnIndexPaths) &#123;</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *from = [<span class="built_in">NSIndexPath</span> indexPathForItem:oldIndex inSection:fromSection];</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *to = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:toSection];</span><br><span class="line">                move = [[IGListMoveIndexPath alloc] initWithFrom:from to:to];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                move = [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i];</span><br><span class="line">            &#125;</span><br><span class="line">            [mMoves addObject:move];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, toSection, i, newArray[i], newMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化小结">优化小结</h3><p>整体而言，IGListDiff 在 Paul Heckel差分算法的基础上扩展了差分类型，从原来的<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong> 3种类型扩展成<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong>、<strong>更新</strong>4 种类型。类型的扩展本质上是通过增加检测维度实现的，Paul Heckel差分算法只支持 <strong>位置</strong>、<strong>内容</strong> 2个维度进行检测，而 IGListDiff 则支持<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong> 3个维度进行检测。</p><p>此外，IGListDiff 实现了精准检测，而 Paul Heckel算法实现的是模糊处理，会存在移动类型误判为插入或删除等情况。这种精准检测的能力，适用于对差异敏感的系统，使得算法的应用场景进一步扩大。</p><h1 id="总结">总结</h1><p>本文首先介绍了原始的 Paul Heckel 差分算法的实现原理。原始的 PaulHeckel 差分算法基于位置、内容 2个维度进行差分检测，支持检测插入、删除、移动等 3种类型。但是，其实现的是一种模糊处理的差分检测，会存在将移动类型归为插入或删除的情况。</p><p>其次，我们介绍了 IGListKit 中的 IGListDiff 模块，其在 Paul Heckel差分算法的基础上进行了优化，基于标识、位置、内容 3个维度进行差分检测，支持检测插入、删除、移动、更新等 4种类型。IGListDiff 实现了一种精确分析的差分算法，这更符合我们在 UI框架中对于数据差异精准检测的需求。</p><p>通过上文的介绍，我们可以举一反三猜想地其他应用是如何实现数据差分检测的。对此，如果你感兴趣的话，可以研究一个其他的框架，来印证一下你的猜想，甚至可以考虑自己实现差分算法。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://dl.acm.org/doi/pdf/10.1145/359460.359467">ATechnique for Isolating Differences Between Files</a>. Paul Heckel.</li><li><a href="https://gist.github.com/ndarville/3166060">IsolatingDifferences Between Files</a></li><li><a href="https://github.com/Instagram/IGListKit">IGListKit</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;前一篇 &lt;a
href=&quot;http://chuquan.me/2023/09/13/myers-difference-algorithm/&quot;&gt;文章&lt;/a&gt;
我们介绍了 Myers
差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit
等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——Paul
Heckel 差分算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://chuquan.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="差分算法" scheme="http://chuquan.me/tags/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/"/>
    
    <category term="Paul Heckel" scheme="http://chuquan.me/tags/Paul-Heckel/"/>
    
    <category term="IGListKit" scheme="http://chuquan.me/tags/IGListKit/"/>
    
    <category term="IGListDiff" scheme="http://chuquan.me/tags/IGListDiff/"/>
    
  </entry>
  
  <entry>
    <title>关于本次博客升级</title>
    <link href="http://chuquan.me/2023/09/16/about-blog-upgrade/"/>
    <id>http://chuquan.me/2023/09/16/about-blog-upgrade/</id>
    <published>2023-09-16T08:56:52.000Z</published>
    <updated>2024-01-19T00:50:26.829Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一篇文章 <ahref="http://chuquan.me/2023/09/13/myers-difference-algorithm/">《Myers差分算法》</a>，发布之后发现 NexT默认使用的公式渲染器的效果不太好，于是...搞了几晚，整体升级了 Hexo系统和 NexT 主题。</p><span id="more"></span><p>升级后的博客支持了以下这些特性：</p><ul><li>黑暗模式：自动识别系统当前的模式，自动切换，并提供按钮支持手动切换。</li><li>公式渲染：使用 pandoc 渲染公式，支持独立和内嵌两种渲染方式。</li><li>评论系统：摒弃了原先的 LiveRe评论系统（不稳定，经常加载不出来），使用了 Waline评论系统，支持评论通知。</li><li>独立留言区：<ahref="https://vercel.chuquan.me">vercel.chuquan.me</a></li></ul><p>在升级过程中，我在 LiveRe后台看到了博客里的很多评论，还是蛮开心的，承蒙大家的喜欢和支持[手动抱拳]。之前评论系统非常不稳定，导致我一直都不太关注评论，因为我也经常加载不出来（除非挂代理）[手动狗头]。而且我也没有看过评论后台，加上评论系统也不支持评论通知，所以很多留言和问题都没有及时回复，感到十分抱歉。</p><p>为了能有更好的交流体验，这次我换了个评论系统，并将历史评论导入了进来，可惜的是历史评论时间无法修改。同时，我也支持了评论通知功能。如果有评论，我会立即收到微信通知；如果我回复了，你也会收到邮件。所以留言时，请正确填写你的邮箱。</p><p>后续，我会持续关注博客中的留言，并及时予以回复（毕竟支持了评论通知能力）。Waline评论系统支持匿名评论和登录评论，如果后续会有回复，我强烈建议你点击登录按钮注册一个账号。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/comment-example.jpg?x-oss-process=image/resize,w_800" /></p><p>当然，除了在指定文章下面留言，这里还提供了一个独立的留言区 <ahref="https://vercel.chuquan.me/">vercel.chuquan.me</a>。如果你有一些与具体文章无关的想法，欢迎在这里留言，比如：关于文章主题的建议（因为有时候我也不知道要写什么主题的文章）、关于开源项目或自主创业的想法、关于人生的思考、关于职场的吐槽...</p><p>最后，再解答一个重复度比较高的问题：</p><p>Q：文章中的图是用什么画的？<br />A：绝大部分的彩色配图都是使用 Sketch 画的，少部分类图使用 draw.io画的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在写一篇文章 &lt;a
href=&quot;http://chuquan.me/2023/09/13/myers-difference-algorithm/&quot;&gt;《Myers
差分算法》&lt;/a&gt;，发布之后发现 NexT
默认使用的公式渲染器的效果不太好，于是...搞了几晚，整体升级了 Hexo
系统和 NexT 主题。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="Waline" scheme="http://chuquan.me/tags/Waline/"/>
    
    <category term="Vercel" scheme="http://chuquan.me/tags/Vercel/"/>
    
  </entry>
  
  <entry>
    <title>Myers 差分算法</title>
    <link href="http://chuquan.me/2023/09/13/myers-difference-algorithm/"/>
    <id>http://chuquan.me/2023/09/13/myers-difference-algorithm/</id>
    <published>2023-09-13T05:24:31.000Z</published>
    <updated>2024-04-26T00:16:26.482Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-01.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>差分算法（DifferenceAlgorithm）是一种数值计算方法，其主要用于解决两个数据集之间的差异问题，通过计算两个数据集之间的差异，取代对整个数据集的处理。</p><p>差分算法的应用非常广泛，主要有以下这些应用领域：</p><ul><li><strong>数据压缩</strong>：差分算法可以用来检测和删除冗余数据，从而实现数据的压缩。比如，对于一段音频数据，如果相邻的数据点之间的值几乎没有变化，那么就可以用差分值来代替原始数据，从而大大减小数据的大小。</li><li><strong>版本控制</strong>：差分算法可以用来比较不同版本的源代码，以便开发者能够知道哪些部分被修改了。比如：git、svn等版本控制工具。</li><li><strong>UI框架</strong>：差分算法可以用来比较两个状态的界面树，并找到最少的更新操作，从而高性能刷新界面。比如：SwiftUI、IGList、React、Flutter等 UI 框架。</li></ul><p>本文，我们将深入探讨广泛应用在各种版本控制工具中的差分算法——Myers差分算法。</p><h1 id="最长公共子序列">最长公共子序列</h1><p>在介绍 Myers 算法之前，我们先来了解一下著名的<strong>最长公共子序列（Longest Common Subsequence，LCS）</strong>问题。我们引用一下 LeetCode 中的问题描述，如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 text1 和 text2，返回这两个字符串的最长「公共子序列」的长度。如果不存在「公共子序列」，则返回 0 。</span><br><span class="line"> </span><br><span class="line">一个字符串的「子序列」是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span><br><span class="line"></span><br><span class="line">例如，<span class="string">&quot;ace&quot;</span> 是 <span class="string">&quot;abcde&quot;</span> 的子序列，但 <span class="string">&quot;aec&quot;</span> 不是 <span class="string">&quot;abcde&quot;</span> 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">&gt; 输入：text1 = <span class="string">&quot;CBABAC&quot;</span>, text2 = <span class="string">&quot;ABCABBA&quot;</span> </span><br><span class="line">&gt; 输出：4  </span><br><span class="line">&gt; 解释：最长公共子序列是 <span class="string">&quot;BABA&quot;</span> 或 <span class="string">&quot;CABA&quot;</span> 或 <span class="string">&quot;CBBA&quot;</span> ，它的长度为 4 。</span><br></pre></td></tr></table></figure><p>对于 LCS 问题，经典思路是使用动态规划来解决。动态规划的核心思想是<strong>将一个大问题拆分成多个子问题，分别求解各个子问题，基于各个子问题的解推断出大问题的解</strong>。与分治、递归相比，动态规划会记录各个子问题的解，避免重复运算，以空间换时间，从而实现对时间复杂度的优化。下面，我们来介绍一下LCS 的动态规划解法。</p><p>假设字符串 <span class="math inline">\(text1\)</span> 和<code>text2</code> 的长度分别为 <code>m</code> 和<code>n</code>，对此创建一个 <code>m+1</code> 行 <code>n+1</code>列的二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示<code>text1[0:i]</code> 和 <code>text2[0:j]</code>的最长公共子序列的长度。</p><blockquote><p>上述表示中，<code>text1[0:i]</code> 表示 <code>text1</code> 的长度为<code>i</code> 的前缀，<code>text2[0:j]</code> 表示 <code>text2</code>的长度为 <code>j</code> 的前缀。</p></blockquote><p>考虑动态规划的边界情况：</p><ul><li>当 <code>i = 0</code> 时，<code>text1[0:i]</code>为空，空字符串和任何字符串的最长公共子序列的长度都是<code>0</code>，因此对任意 <code>0 ≤ j ≤ n</code>，有<code>dp[0][j] = 0</code>；</li><li>当 <code>j = 0</code> 时，<code>text2[0:j]</code>为空，同理可得，对任意 <code>0 ≤ i ≤ m</code>，有<code>dp[i][0] = 0</code>。</li></ul><p>因此动态规划的边界情况是：当 <code>i = 0</code> 或 <code>j = 0</code>时，<code>dp[i][j] = 0</code>。</p><p>当 <code>i &gt; 0</code> 且 <code>j &gt; 0</code> 时，考虑<code>dp[i][j]</code> 的计算：</p><ul><li>当 <code>text1[i-1] = text2[j-1]</code>时，将这两个相同的字符称为公共字符，考虑 <code>text1[0:i-1]</code> 和<code>text2[0:j-1]</code> 的最长公共子序列，再增加一个公共字符即可得到<code>text1[0:i]</code> 和 <code>text2[0:j]</code>的最长公共子序列，因此 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</li><li>当 <code>text1[i-1] != text2[j-1]</code> 时，考虑一下两种情况：<ul><li>情况一：<code>text1[0:i-1]</code> 和 <code>text2[0:j]</code>的最长公共子序列</li><li>情况二：<code>text1[0:i]</code> 和 <code>text2[0:j-1]</code>的最长公共子序列</li><li>对此，计算 <code>text1[0:i]</code> 和 <code>text2[0:j]</code>的最长公共子序列，应取两项中长度较大的一项，因此<code>dp[i][j] = max(dp[i-1]][j], dp[i][j-1])</code>。</li></ul></li></ul><p>最终得到如下所示的状态转移方程：</p><p><span class="math display">\[dp[i][j] =\begin{cases}dp[i-1][j-1] + 1, &amp; \text{text1[i-1] = text2[j-1]}  \\max(dp[i-1][j], dp[i][j-1]), &amp; \text{text1[i-1]$\neq$text2[j-1]}\end{cases}\]</span></p><p>根据状态转移方程，我们可以得到如下代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图所示为二维数组 <code>dp[i][j]</code>的存储内容，大问题的解由子问题的解推导而出，数组整体从左到右，从上到下推导构建。我们在图中使用黄色标识了<code>text1[i-1] == text2[j-1]</code>的情况。此时将从左上角相邻的位置取值并加1；否则，取左边或上边的相邻值中的最大值。整个二维数组中保存的最大值就是LCS 问题的解。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-02.png?x-oss-process=image/resize,w_800" /></p><p>至此我们计算得到了最长公共子序列的长度，然而在实际情况中，我们倾向于得到最长公共子序列本身。此时，可以借助我们构建的二维数组进行回溯。</p><p>回溯的方法是：从二维数组的右下角向左上角遍历，当<code>i = m+1</code>，<code>j = n+1</code> 时可能会遇到三种情况：</p><ul><li>如果 <code>text1[i] = text2[j]</code>，那么向左上角遍历。</li><li>如果 <code>text1[i] != text2[j]</code>，判断 <code>dp[i][j]</code>和 <code>dp[i-1][j]</code> 的值。<ul><li>如果 <code>dp[i][j] = dp[i-1][j]</code>，则向上遍历；</li><li>否则，向左遍历。</li></ul></li></ul><p>由此，我们可以得到如下的遍历路径。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-03.png?x-oss-process=image/resize,w_800" /></p><p>在回溯得到遍历路径之后，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列<code>CABA</code>，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-05.png?x-oss-process=image/resize,w_800" /></p><p>当然，细心的同学可能会对上述的回溯方法产生疑问：为什么<code>dp[i][j] = dp[i-1][j]</code>时向上遍历，而非向左遍历？事实上，如果我们也可以修改回溯方法，得到如下的遍历路径。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-04.png?x-oss-process=image/resize,w_800" /></p><p>同样，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列<code>BABA</code>，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-06.png?x-oss-process=image/resize,w_800" /></p><h1 id="最小编辑距离">最小编辑距离</h1><p>事实上，在特定设定下，最长公共子序列问题可以等价为<strong>最小编辑距离（Minimum Edit Distance，也称 Levenshtein）</strong>问题。</p><p>具体设定为：在最小编辑距离问题中，如果编辑操作只有<strong>删除</strong> 和 <strong>插入</strong>，没有<strong>替换</strong> 操作，且每个操作的代价是 1，那么从字符串 A转换成字符串 B 的最小编辑距离就可以转换成如下公式。</p><p><span class="math display">\[med(A, B) = length(A) + length(B) - 2 * lcs(A, B)\]</span></p><p>以上述 <code>text1 = CBABAC</code>，<code>text2 = ABCABBA</code>为例，寻找最长公共子序列问题，我们可以视为将 <code>text2</code> 转换成<code>text1</code> 的最小编辑距离问题。</p><p>此时，我们可以将向左遍历的起始位置染成红色，将向上遍历的起始位置染成绿色，如下所示是分别对<code>CABA</code> 和 <code>BABA</code> 遍历路径的染色图。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-07.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-08.png?x-oss-process=image/resize,w_800" /></p><p>这里，我们对已经染色的路径进行编辑规则的定义，如下：</p><ul><li>被染成红色的位置，表示在路径中删除原始字符串对应的字符</li><li>被染成绿色的位置，表示在路径中插入目标字符串对应的字符</li><li>被染成黄色的位置，表示不进行任何编辑编辑操作</li></ul><p>此时，我们就可以得到最小编辑距离的实际操作步骤，即<strong>最短编辑脚本（Shortest EditScript，SES）</strong>，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-09.png?x-oss-process=image/resize,w_800" /></p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-10.png?x-oss-process=image/resize,w_800" /></p><p>上面两图的右半部分是两个符合预期的最短编辑脚本。然而，在实际过程中，对某一个原始文本进行编辑得到另一个目标文本，可能会存在非常多的最短编辑脚本。此时我们该如何选择？<strong>根据实际经验，我们认为先删除旧内容，后插入新内容，具有更直观的体验</strong>。比如：CodeReview的差异比较也都是按照先删除后插入的方式进行展示，如下所示。因此，上述第一种最短编辑脚本更加直观，符合预期。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-11.png?x-oss-process=image/resize,w_800" /></p><h1 id="myers-差分算法">Myers 差分算法</h1><p>1986 年 Eugene W.Myers 发表了一篇论文《An O(ND) Difference Algorithmand ItsVariations》，提出一种基于广度优先搜索和贪心策略的算法，优化了最短编辑路径问题。该算法在求解大规模字符串编辑距离问题时比传统的动态规划更加有效。</p><p>下面，我们以 <code>source = ABCABBA</code>为原始字符串，<code>target = CBAABAC</code> 为目标字符串，基于 Myers差分算法来查找最短编辑距离和最小编辑脚本。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-12.png?x-oss-process=image/resize,w_800" /></p><h2 id="基本定义">基本定义</h2><p>与上述算法类似，Myers差分算法的基本思想仍然是查找一条从左上角至右下角的路径。在路径遍历时，这里有几个基本定义：</p><ul><li><strong>遍历的方向</strong>：仅支持三个方向，分别是<strong>向右</strong>、<strong>向下</strong>、<strong>右下</strong>。</li><li><strong>遍历的步长</strong>：对于向右和向下，步长为1。一次只能移动一格；对于右下，一次可以移动任意长度，前提是移动过程中所有坐标的x、y值对应在原始字符串和目标字符串中的对应位置的字符必须相同。下图所示，黄色箭头表示可以允许移动的起始位置和终点位置。</li><li><strong>遍历的深度</strong>：对于向右和向下，每移动一步，深度加1；对于右下，无论移动步长为多少，深度始终加 0。</li></ul><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-13.png?x-oss-process=image/resize,w_800" /></p><h2 id="k-d-坐标系">K-D 坐标系</h2><p>除了对比原始字符串和目标字符串所建立的 X-Y 坐标系外，Myers还建立了一个 K-D 坐标系，如下图所示。</p><p>K 来源于 X 与 Y 的关系式 <code>y = x - k</code>，即偏移量。根据 X 和K 的值，我们可以计算得到 Y 的值。</p><p>D 表示遍历的深度。由于向右或向下移动一步，深度加1；右下移动一步，深度加 0。因此，D 轴并不是完全垂直于 K轴，而是类似于等高线，向多方向增长，相同 D值所连成的线可能是折线，而不一定是直线。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-21.png?x-oss-process=image/resize,w_800" /></p><h2 id="最佳位置">最佳位置</h2><p>Myers 差分算法是基于贪心策略实现的，对此它定义了一个<strong>最佳位置</strong> 的概念，作为贪心的基准值。在 K-D坐标系中，同一条 K 线上，X 值越大的位置（根据 K 的值可以计算得到 Y值），则越靠近右下角的终点。</p><p>那么如何记录最佳位置？很显然，每一个 K值需要单独记录各自的最佳位置，因此，需要有一个 Map 来进行存储，其中 Key是 K 值，Value 则是 X 值。根据 K 和 X，我们可以计算出 Y 值。</p><h2 id="算法原理">算法原理</h2><p>在了解了算法的基本定义、K-D坐标系以及最佳位置等概念之后，我们来看一下算法具体原理。</p><p>算法整体包含两层循环：</p><ul><li>外层循环：迭代遍历的深度。在最坏的情况下（删除全部原始字符，掺入全部目标字符），遍历的深度为两个字符的长度之和，因此深度的范围为<code>[0, M+N)</code>。</li><li>内层循环：迭代必要的 K 值。对于每一条 K线，从其上的最佳位置出发，移动深度加 1 后的位置只能在其相邻的两条 K线上。因此，相同深度的最佳位置所在的 K 线，相邻之间的 K 值差为2。对应地，内层循环的步长也为 2，并且每一轮遍历，深度加 1，K的范围也会外扩 2。</li></ul><p>下面，我们来图解一下算法的运行过程，以下每张图表示一次完整的内层循环。</p><p>首先，为 <code>k(0)</code> 查找所有深度为 <code>d0</code>的最佳位置，很显然，只有起点符合，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-22.png?x-oss-process=image/resize,w_800" /></p><p>其次，为 <code>k(-1)</code> 和 <code>k(1)</code> 查找所有深度为<code>d1</code> 的最佳位置。由于 <code>d1</code> 是基于 <code>d0</code>宽度优先搜索查找的，而 <code>d0</code>只有一个，所以由此向两个方向搜索的 K 线只有 <code>k(-1)</code> 和<code>k(1)</code>。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-23.png?x-oss-process=image/resize,w_800" /></p><p>然后，我们继续基于 <code>d1</code> 的各个最佳位置进行宽度优先搜索，为<code>(k-2)</code>、<code>k(0)</code>、<code>k(2)</code> 查找<code>d2</code> 的各个最佳位置。由于每一轮内层循环的 K 线数量都会外扩1，因此，首尾的两条 K 线，只能基于内侧 K线的上一轮循环最佳位置来查找本轮最佳位置；对于中间的 K 线，它两侧的 K线都有上一轮的最佳位置，它可以从中选择更优的最佳位置（即 X值更大的最佳位置）来查找本轮的最佳位置。如下图所示，<code>k(-2)</code>的最佳位置 <code>d2</code> 只能基于 <code>k(-1)</code> 的最佳位置<code>d1</code> 来查找得到；<code>k(2)</code> 的最佳位置 <code>d2</code>只能基于 <code>k(1)</code> 的最佳位置 <code>d1</code>来查找得到。对于中间的 K 线，这里只有<code>k(0)</code>，它会在左右两边的 K 线中选择一个最佳位置，显然<code>k(1)</code> 上的 <code>d1</code> 的 X值更大，因此选择它作为搜索的起点。</p><p>从图中，我们还可以看到，当到达深度加 1的位置后，算法还会进一步判断是否可以向右下移动，因为右下移动时，深度不会增加。此时，我们发现这几个位置都能沿着黄色的线移动，于是<code>d2</code> 就到达了图中所示的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-24.png?x-oss-process=image/resize,w_800" /></p><p>接着，为<code>k(-3)</code>、<code>k(-1)</code>、<code>k(1)</code>、<code>k(3)</code>查找 <code>d3</code> 的各个最佳位置。注意，这里我们看一下<code>k(-1)</code> 的处理，此时它两侧 <code>k(-2)</code> 和<code>k(0)</code> 的最佳位置的 X 值相同。此时，我们选择基于<code>k(-2)</code> 右移，很明显，这样必然会比基于 <code>k(0)</code>下移能找到 X 值更大的位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-25.png?x-oss-process=image/resize,w_800" /></p><p>然后，为<code>k(-4)</code>、<code>k(-2)</code>、<code>k(0)</code>、<code>k(2)</code>、<code>k(4)</code>查找 <code>d4</code> 的各个最佳位置。注意，此时会存在部分 K线的最佳位置不包含 X-Y 坐标系中真实存在的位置，比如 <code>k(-4)</code>的最佳位置。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-26.png?x-oss-process=image/resize,w_800" /></p><p>最后，我们在为<code>k(-5)</code>、<code>k(-3)</code>、<code>k(-1)</code>、<code>k(1)</code>、<code>k(3)</code>、<code>k(5)</code>查找最佳位置时，发现其中一条 K线的最佳位置已经到达终点，那么此时我们已经找到了最短编辑距离，那么可以结束遍历。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-27.png?x-oss-process=image/resize,w_800" /></p><p>在上述过程中，Myers 算法使用一个 Map 记录每条 K 线的最佳位置，其中Key 为 K 值，Value 为最佳位置。当对同一条 K 线多次更新最佳位置时，Map只会记录最新的最佳位置。为了便于复现完整的编辑路径，Myers 算法还使用一个Map 用于记录每个深度的所有最佳位置，其中 Key 为深度值 D，Value 是一个子Map，记录了该深度时各个 K 线的最佳位置。通过回溯这个包含全部最佳位置的Map，我们可以重建遍历路径，如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-28.png?x-oss-process=image/resize,w_800" /></p><h2 id="算法实现">算法实现</h2><p>下面，我们使用代码来实现一下 Myers 算法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ruby </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myers</span>(<span class="params">stra, strb</span>)</span><br><span class="line">  <span class="comment"># 字符串 a 和 b 的长度，分别为 n 和 m</span></span><br><span class="line">  m = stra.length</span><br><span class="line">  n = strb.length</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于存储每条 K 线上最佳位置的 Map</span></span><br><span class="line">  v = &#123; <span class="number">1</span> =&gt; <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment"># 用于存储所有深度的所有最佳位置的 Map，用于回溯编辑路径</span></span><br><span class="line">  vs = &#123; <span class="number">0</span> =&gt; &#123; <span class="number">1</span> =&gt; <span class="number">0</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">  loop <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 外层循环，遍历深度</span></span><br><span class="line">    (<span class="number">0</span>..m + n).each <span class="keyword">do</span> |<span class="params">d</span>|</span><br><span class="line">      tmp = &#123;&#125;</span><br><span class="line">      <span class="comment"># 内层循环，宽度优先搜索，遍历 K 线</span></span><br><span class="line">      (-d..d).step(<span class="number">2</span>) <span class="keyword">do</span> |<span class="params">k</span>|</span><br><span class="line">        down = ((k == -d) |<span class="params"></span>| ((k != d) &amp;&amp; v[k + <span class="number">1</span>] &gt; v[k - <span class="number">1</span>]))</span><br><span class="line">        kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 获取移动的起点位置</span></span><br><span class="line">        xStart = v[kPrev]</span><br><span class="line">        yStart = xStart - kPrev</span><br><span class="line">        <span class="comment"># 获取移动一步的中间位置，向右或向下</span></span><br><span class="line">        xMid = down ? xStart : xStart + <span class="number">1</span></span><br><span class="line">        yMid = xMid - k</span><br><span class="line">        <span class="comment"># 获取移动的终点位置，后续可能会向右下移动。</span></span><br><span class="line">        xEnd = xMid</span><br><span class="line">        yEnd = yMid</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向右下移动，深度始终不变</span></span><br><span class="line">        <span class="keyword">while</span>(xEnd &lt; m &amp;&amp; yEnd &lt; n &amp;&amp; stra[xEnd] == strb[yEnd]) <span class="keyword">do</span></span><br><span class="line">          xEnd += <span class="number">1</span></span><br><span class="line">          yEnd += <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录对应 K 线所能达到的最佳位置</span></span><br><span class="line">        v[k] = xEnd</span><br><span class="line"></span><br><span class="line">        tmp[k] = xEnd</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果两个字符串均到达末端，表示找到了终点，可以结束查找</span></span><br><span class="line">        <span class="keyword">if</span> xEnd == m &amp;&amp; yEnd == n</span><br><span class="line">          vs[d] = tmp</span><br><span class="line">          <span class="comment"># 生成最短编辑路径</span></span><br><span class="line">          snakes = solution(vs, m, n, d)</span><br><span class="line">          <span class="comment"># 打印最短编辑路径</span></span><br><span class="line">          printDiff(snakes, stra, strb)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="comment"># 记录深度为 D 的所有 K 线的最佳位置</span></span><br><span class="line">      vs[d] = tmp</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">vs, m, n, d</span>)</span><br><span class="line">  snakes = []</span><br><span class="line">  <span class="comment"># 定义位置结构</span></span><br><span class="line">  p = &#123; <span class="symbol">x:</span> m, <span class="symbol">y:</span> n &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 回溯最短编辑路径</span></span><br><span class="line">  <span class="keyword">while</span> d &gt; <span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">    v = vs[d]</span><br><span class="line">    vPrev = vs[d-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    k = p[<span class="symbol">:x</span>] - p[<span class="symbol">:y</span>]</span><br><span class="line">    <span class="comment"># 判断之前位置到当前位置最开始移动的方式，向下或向右</span></span><br><span class="line">    down = ((k == -d) |<span class="params"></span>| ((k != d) &amp;&amp; (vPrev[k + <span class="number">1</span>] &gt; vPrev[k - <span class="number">1</span>])))</span><br><span class="line">    kPrev = down ? k + <span class="number">1</span> : k - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当前位置</span></span><br><span class="line">    xEnd = v[k]</span><br><span class="line">    yEnd = xEnd - k</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 之前位置</span></span><br><span class="line">    xStart = vPrev[kPrev]</span><br><span class="line">    yStart = xStart - kPrev</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中间走斜线时的起始位置</span></span><br><span class="line">    xMid = down ? xStart : xStart + <span class="number">1</span></span><br><span class="line">    yMid = xMid - k</span><br><span class="line"></span><br><span class="line">    snakes.unshift([xStart, xMid, xEnd])</span><br><span class="line"></span><br><span class="line">    p[<span class="symbol">:x</span>] = xStart</span><br><span class="line">    p[<span class="symbol">:y</span>] = yStart</span><br><span class="line"></span><br><span class="line">    d -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> snakes</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printDiff</span>(<span class="params">snakes, stra, strb</span>)</span><br><span class="line">  diffresult = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  yOffset = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  snakes.each_with_index <span class="keyword">do</span> |<span class="params">snake, index</span>|</span><br><span class="line">    s = snake[<span class="number">0</span>]</span><br><span class="line">    m = snake[<span class="number">1</span>]</span><br><span class="line">    e = snake[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是第一个差异，并且差异的开始点不是字符串头（即两字符串在开始部分有相同子字符串）</span></span><br><span class="line">    <span class="keyword">if</span> index === <span class="number">0</span> &amp;&amp; s != <span class="number">0</span></span><br><span class="line">      <span class="comment"># 打印所有相同字符，直到s</span></span><br><span class="line">      (<span class="number">0</span>..s-<span class="number">1</span>).each <span class="keyword">do</span> |<span class="params">j</span>|</span><br><span class="line">        diffresult += <span class="string">&quot;  <span class="subst">#&#123;stra[j]&#125;</span>\n&quot;</span></span><br><span class="line">        yOffset += <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> m - s == <span class="number">1</span></span><br><span class="line">      <span class="comment"># 用红色打印删除的字符</span></span><br><span class="line">      diffresult += <span class="string">&quot;\033[0;31m- <span class="subst">#&#123;stra[s]&#125;</span>\033[0m\n&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment"># 用绿色打印插入的字符</span></span><br><span class="line">      diffresult += <span class="string">&quot;\033[0;32m+ <span class="subst">#&#123;strb[yOffset]&#125;</span>\033[0m\n&quot;</span></span><br><span class="line">      yOffset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># 打印相同的字符</span></span><br><span class="line">    (<span class="number">0</span>..e-m-<span class="number">1</span>).each <span class="keyword">do</span> |<span class="params">i</span>|</span><br><span class="line">      diffresult += <span class="string">&quot;  <span class="subst">#&#123;stra[m+i]&#125;</span>\n&quot;</span></span><br><span class="line">      yOffset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  puts diffresult</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;ABCABBA&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;CBABAC&#x27;</span></span><br><span class="line">myers(s1, s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>传统动态规划的时间复杂度为 <code>O(mn)</code>，空间复杂度为<code>O(mn)</code>，其中 <code>m</code> 和 <code>n</code>分别是两个字符串的长度；Myers 算法的时间复杂度为<code>O((m+n)D)</code>，<code>D</code>是最小编辑距离，当最短编辑距离相对较小时，Myers算法的时间效率是优于传统动态规划的，Myers 算法的空间复杂度为<code>O(m+n)</code>。因此，当面对大规模且较为相似的字符串比较任务时，Myers算法相比动态规划更具优势。</p><p>后续，我们将阅读一些开源软件或框架，来学习一下 Myers差分算法在其中的应用。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://www.nathaniel.ai/myers-diff/">VisualizingDiffs</a></li><li><ahref="https://chenshinan.github.io/2019/05/02/git%E7%94%9F%E6%88%90diff%E5%8E%9F%E7%90%86%EF%BC%9AMyers%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/">git生成diff原理：Myers差分算法</a></li><li><ahref="https://mcll.top/2019/05/23/diff%E7%AE%97%E6%B3%95/">一种diff算法：Myers</a></li><li><ahref="https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/">TheMyers diff algorithm: part 1</a></li><li><ahref="https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/">TheMyers diff algorithm: part 2</a></li><li><ahref="https://blog.jcoglan.com/2017/02/17/the-myers-diff-algorithm-part-3/">TheMyers diff algorithm: part 3</a></li><li><ahref="https://blog.jcoglan.com/2017/03/22/myers-diff-in-linear-space-theory/">Myersdiff in linear space: theory</a></li><li><ahref="https://blog.jcoglan.com/2017/04/25/myers-diff-in-linear-space-implementation/">Myersdiff in linear space: implementation</a></li><li>An O(ND) Difference Algorithm and Its Variations. EugeneW.Myers.</li><li><a href="https://zhuanlan.zhihu.com/p/35256233">Diff应用：从LCS到UICollectionView</a></li><li><ahref="https://www.cnblogs.com/oto-G/p/16357245.html">Myers差分算法的理解、实现、可视化</a></li><li><ahref="https://juejin.cn/post/6887367495021330445#heading-8">Myers‘Diff之贪婪算法</a></li><li><a href="https://github.com/pkg/diff">pkg diff</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/myers-01.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://chuquan.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Myers" scheme="http://chuquan.me/tags/Myers/"/>
    
    <category term="最长公共子序列" scheme="http://chuquan.me/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
    <category term="最短编辑距离" scheme="http://chuquan.me/tags/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
    <category term="最短编辑脚本" scheme="http://chuquan.me/tags/%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew 的设计哲学</title>
    <link href="http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/"/>
    <id>http://chuquan.me/2023/08/27/understand-the-design-of-homebrew/</id>
    <published>2023-08-27T02:30:08.000Z</published>
    <updated>2023-09-16T09:08:13.053Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-00.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>如果你是一位 MacOS 用户，那么你一定知道 Homebrew。Homebrew 是 MacOS下的包管理工具，类似 apt-get/apt 之于 Linux，yum 之于CentOS。如果一款软件发布时支持了 homebrew 安装渠道，那么我们就可以通过homebrew 一键安装，省时省力省心。</p><p>本文，我们将来探索一下 homebrew 的底层工作原理。</p><p>通过学习其工作原理，我们可以举一反三，推测并理解其他平台的包管理工具的设计思想。此外，我们还能借此理解开源软件的设计范式，从而为软件设计提供思路和指导。当然，最直接的收益则是加深对于homebrew 的理解，可以基于其原理来解决日常工作中的相关问题。</p><h1 id="酿酒术语">酿酒术语</h1><p>Homebrew 的作者 Max Howell借用了西方的酿酒文化，为软件定义了一系列的术语。因此，想要捋清楚各个术语及其之间的关系，我们有必要先简单了解一下酿酒文化中的相关术语。</p><p>对于工厂而言，酒一般会以 <strong>木桶（Cask）</strong>的形式存放在规模较大的厂房中，即<strong>酒桶房（Caskroom）</strong>。通常，木桶可以直接安装<strong>酒龙头（Tap）</strong> 来打酒或装罐。具体如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-01.png?x-oss-process=image/resize,w_800" /></p><p>对于家庭而言，酒一般会以 <strong>瓶装酒（Bottle）</strong> 或<strong>罐装酒（Keg）</strong> 的形式存放在规模较小的屋子里，即<strong>酒窖（Cellar）</strong>。由于瓶装酒和罐装酒体积较小，同时为了便于分类和存取，一般会摆放在<strong>酒架（Rack）</strong> 上。具体如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-02.png?x-oss-process=image/resize,w_800" /></p><h1 id="软件术语">软件术语</h1><p>Homebrew将软件比喻成酒，对于不同类型的软件，其管理（保存）方式有所不同：</p><ul><li><strong>对于原生应用，将其比作桶装酒，以 Cask 作为容器，保存在Caskroom 中。</strong></li><li><strong>对于非原生应用，将其比作瓶装酒或罐装酒，以 Bottle 或 Keg作为容器，保存在 Cellar 的 Rack 中。</strong></li></ul><blockquote><p>什么是 MacOS 原生应用？ MacOS 原生应用是指为 MacOS操作系统专门设计和开发的应用程序。通常使用 Apple 提供的软件开发工具（如Xcode）和编程语言（Swift 或Objective-C）进行开发，直接调用操作系统提供的 API 进行各种操作。 每个MacOS 原生应用都会有一个唯一的BundleIdentifier，系统以此标识符来管理和区分不同应用。</p></blockquote><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-04.png?x-oss-process=image/resize,w_800" /></p><p>上图所示，为 MacOS 系统中 homebrew对于软件管理的层级结构。这里有一个细节，我们发现 Caskroom 和 Casks构建了一个两层关系，而 Cellar、Racks、Kegs/Bottles则构建了一个三层关系。对此，我的理解是：</p><ul><li><strong>对于非原生应用，其索引方式是通过软链接实现的，因此同一台机器中可以存储同一应用的不同版本，通过修改软链接的指向来使用不同的版本。</strong></li><li><strong>对于原生应用，系统以应用的 Bundle Identifier作为唯一标识，同一应用的不同版本的 Bundle Identifier是相同的，因此同一台机器中只能覆盖安装，不同版本无法共存。</strong></li></ul><p>综合上述原因，非原生应用需要三层结构进行管理，而原生应用只需两层结构进行管理。从这个角度来看，正好与Cellar 和 Caskroom 的层级结构相匹配。</p><p>从图中，我们还可以看到 Cellar 的管理下包含了两种类型的软件，分别使用<strong>罐装酒（Keg）</strong> 和 <strong>瓶装酒（Bottle）</strong>来描述，它们是存在一些细微的区别的：</p><ul><li><strong>对于 Keg，表示的是 homebrew通过使用源码进行编译构建的软件。</strong></li><li><strong>对于 Bottle，表示的是 homebrew直接下载预编译的二进制的软件。</strong></li></ul><p>既然 homebrew将软件比喻成酒，那么很显然，软件的安装过程则对等比喻成酿酒。对此，homebrew使用 <strong>木桶（Cask）</strong> 和 <strong>配方（Formula）</strong>作为软件安装的两个基本元素，它们分别作为原生应用的包定义和非原生应用的包定义。为了便于管理，homebrew统一将它们放在 <strong>酒龙头（Tap）</strong> 下进行管理，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-05.png?x-oss-process=image/resize,w_800" /></p><p>对于 homebrew 这样设计 Tap 和 Formula、Cask之间的关系，我个人认为，从语义上来说属实有点牵强，因为它们在任何维度上都不是包含关系。这里，我们只要知道它们之间存在着包含关系即可，无需深究。</p><h1 id="存储结构">存储结构</h1><p>通过上文，我们大致了解了 homebrew中术语的含义与关系。下面，我们来看一下它们具体在文件系统中的存储结构。</p><p>对于 MacOS 系统，homebrew 在 ARM 架构（Apple Silicon）和 X86架构（Intel）中的存储位置所有不同，但是术语之间相对关系是一致的。作出这种区分的主要原因是，当从X86 架构迁移至 ARM 架构时，支持在 Rosetta 模式下继续运行在 X86架构下安装的软件应用。</p><p>对于 X86 架构，Caskroom 的路径是<code>/usr/local/Caskroom</code>，Cellar 的路径是<code>/usr/local/Cellar</code>，Taps 的路径是<code>/usr/local/Homebrew/Library/Taps</code>。</p><p>对于 ARM 架构，Caskroom 的路径是<code>/opt/homebrew/Caskroom</code>，Cellar 的路径是<code>/opt/homebrew/Cellar</code>，Taps 的路径是<code>/opt/homebrew/Library/Taps</code>。</p><h2 id="caskroom">Caskroom</h2><p>Caskroom主要负责管理原生应用，由于原生应用无法同时维护多个版本，所以在 Caskroom下对应只会存在一个版本目录。如下所示，以 <code>aerial</code>为例，在两次安装时，后一次会覆盖前一次的版本数据。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-03.jpg?x-oss-process=image/resize,w_800" /></p><h2 id="cellar">Cellar</h2><p>Cellar 主要负责管理非原生应用，由于是通过软链接进行版本管理，所以在Cellar 下对应会存在多个版本目录。如下所示，以 <code>git</code>为例，它会保存多个版本的数据。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-06.jpg?x-oss-process=image/resize,w_800" /></p><p>对于非原生应用，我们还可以在<code>/usr/local/bin</code>（Intel）目录下看到 homebrew为命令行应用创建的所有软链接，如下所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-07.jpg?x-oss-process=image/resize,w_800" /></p><p>由于 <code>PATH</code> 环境变量包含了<code>/usr/local/bin</code>，所以系统能查找 homebrew所安装的软件的软链接，进而找到真正的可执行文件。不过在某些情况下，我们可能需要让homebrew安装的软件对于用户不可见，比如：避免版本冲突、仅用于依赖构建等。这时候，homebrew不会为这些软件创建软链接，对于这种类型的软件，homebrew 称之为<strong>keg-only</strong>，比如：<code>openjdk</code>。</p><h2 id="taps">Taps</h2><p>Taps 主要负责管理 <strong>包定义</strong> 和<strong>外部命令</strong>。</p><ul><li>包定义：一个包定义对应一款软件，主要用于指导对应软件的安装。</li><li>外部命令：支持用户对 homebrew 进行扩展，提供更多的命令和功能。</li></ul><p>Taps 目录维护了多个 Git 仓库（Tap仓库å），包括开发者自建的仓库，以及官方维护的仓库，比如：<code>homebrew/homebrew-core</code>和 <code>homebrew/homebrew-cask</code> 等。</p><p>如下所示，这些仓库大多数都维护了一个 <code>Formula</code> 或<code>Casks</code> 目录，其中存放了软件的包定义。这些包定义本质上是一个Ruby 类定义，图中的 <code>muesli/homebrew-tap</code> 中虽然没有定义<code>Formula</code> 或 <code>Casks</code> 目录，但其保存的 Ruby文件都是包定义。</p><p>除此之外，部分仓库维护了一个 <code>cmd</code>目录，其中存放了一些外部命令的定义，我们可以以文件名作为子命令进行调用，比如：<code>cmd</code>目录中有一个 <code>check-ci-status.rb</code> 文件，我们可以通过<code>brew check-ci-status</code>命令来调用执行。通过这种方式，我们可以对 homebrew 的命令进行扩展。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-08.jpg?x-oss-process=image/resize,w_800" /></p><h1 id="包定义">包定义</h1><p>作为一个软件包管理工具，homebrew 中最核心的设计便是包定义（PackageDefinition）。通过包定义，homebrew 才能够正确地安装对应的软件。</p><p>在上文 Taps 一节中，我们知道 homebrew支持两种管理方式，具体而言分别是：</p><ul><li><strong>官方仓库管理</strong>，我们可以实现自己的包定义，并向<code>homebrew/homebrew-core</code>（用于 Formula）或<code>homebrew/homebrew-cask</code>（用于 Cask）提交 PullRequest。这种方式会对包定义有着严格的规范和约束。</li><li><strong>自建仓库管理</strong>，我们在自定义的仓库中实现包定义，并自行维护。在安装软件时，我们将该仓库加入至Taps 目录进行管理。</li></ul><p>对于自建仓库，我们可以使用<code>brew tap-new &lt;user&gt;/&lt;repo&gt;</code>命令来创建一个模板仓库。如下所示，我们使用<code>brew tap-new baochuquan/homebrew-nox</code> 创建了一个 Tap仓库。命令会在 Taps 目录下创建一个仓库，并默认创建一个 Formula目录用于存放 Formula 包定义。如果希望存放 Cask包定义，我们可以再手动创建一个 Casks 目录。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-10.jpg?x-oss-process=image/resize,w_800" /></p><p>Homebrew 中的包定义有两种：Formula 和 Cask。</p><h2 id="formula">Formula</h2><p>Formula 是非原生应用的包定义，如下所示是 CocoaPods 的 Formula包定义。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cocoapods</span> &lt; <span class="title class_ inherited__">Formula</span></span><br><span class="line">  desc <span class="string">&quot;Dependency manager for Cocoa projects&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://cocoapods.org/&quot;</span></span><br><span class="line">  url <span class="string">&quot;https://github.com/CocoaPods/CocoaPods/archive/1.12.1.tar.gz&quot;</span></span><br><span class="line">  sha256 <span class="string">&quot;da018fc61694753ecb7ac33b21215fd6fb2ba660bd7d6c56245891de1a5f061c&quot;</span></span><br><span class="line">  license <span class="string">&quot;MIT&quot;</span></span><br><span class="line"></span><br><span class="line">  bottle <span class="keyword">do</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_ventura:</span>  <span class="string">&quot;6f1fca1cb0df79912e10743a80522e666fe605a1eaa2aac1094c501608fb7ee4&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_monterey:</span> <span class="string">&quot;8f7eff899cc1807286374e29e634c1008e286c3360df6cbcb90e27b0fe5567a9&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">arm64_big_sur:</span>  <span class="string">&quot;346833fef239df933ddb67341c55c9c4a7e547fc03afdc332861ac2ae8ba3372&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">ventura:</span>        <span class="string">&quot;b114ec0a11a2e472026f0f7337d17558bead2ac1122d9c2bb9278fc6b31fd744&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">monterey:</span>       <span class="string">&quot;946f0282afe0000ba9e23f30ce2175bc4b1f0c6d7e27145f01be4665b9786f8a&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any</span>,                 <span class="symbol">big_sur:</span>        <span class="string">&quot;1fe6f0c45e0c13e122aa1d8bf1f9bd9496fa3bb00fe7bc19286425e029e5c278&quot;</span></span><br><span class="line">    sha256 <span class="symbol">cellar:</span> <span class="symbol">:any_skip_relocation</span>, <span class="symbol">x86_64_linux:</span>   <span class="string">&quot;e297731632b715118c13688acff976ce56c49df705ba2ae616445fb68cb49152&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  depends_on <span class="string">&quot;pkg-config&quot;</span> =&gt; <span class="symbol">:build</span></span><br><span class="line">  depends_on <span class="string">&quot;ruby&quot;</span></span><br><span class="line">  uses_from_macos <span class="string">&quot;libffi&quot;</span>, <span class="symbol">since:</span> <span class="symbol">:catalina</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">install</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">Mac</span>OS.version &gt;= <span class="symbol">:mojave</span> &amp;&amp; <span class="title class_">Mac</span>OS::<span class="variable constant_">CLT</span>.installed?</span><br><span class="line">      <span class="variable constant_">ENV</span>[<span class="string">&quot;SDKROOT&quot;</span>] = <span class="variable constant_">ENV</span>[<span class="string">&quot;HOMEBREW_SDKROOT&quot;</span>] = <span class="title class_">Mac</span>OS::<span class="variable constant_">CLT</span>.sdk_path(<span class="title class_">Mac</span>OS.version)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="variable constant_">ENV</span>[<span class="string">&quot;GEM_HOME&quot;</span>] = libexec</span><br><span class="line">    system <span class="string">&quot;gem&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;cocoapods.gemspec&quot;</span></span><br><span class="line">    system <span class="string">&quot;gem&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;cocoapods-<span class="subst">#&#123;version&#125;</span>.gem&quot;</span></span><br><span class="line">    <span class="comment"># Other executables don&#x27;t work currently.</span></span><br><span class="line">    bin.install libexec/<span class="string">&quot;bin/pod&quot;</span>, libexec/<span class="string">&quot;bin/xcodeproj&quot;</span></span><br><span class="line">    bin.env_script_all_files(libexec/<span class="string">&quot;bin&quot;</span>, <span class="variable constant_">GEM_HOME</span>: <span class="variable constant_">ENV</span>[<span class="string">&quot;GEM_HOME&quot;</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  test <span class="keyword">do</span></span><br><span class="line">    system <span class="string">&quot;<span class="subst">#&#123;bin&#125;</span>/pod&quot;</span>, <span class="string">&quot;list&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Formula 包定义本质上是定义一个 <code>Formula</code>的子类，将子类的名称转换成小写，以 <code>-</code> 代替驼峰命名，即可得到homebrew 对应的应用名称，比如：<code>brew install cocoapods</code>。</p><p>Formula包含一些必须的属性设置，比如：<code>desc</code>、<code>homepage</code>、<code>url</code>、<code>sha256</code>、<code>license</code>等，用于描述应用的基本信息，源码下载地址，完整性校验值等。</p><p>此外，它支持了非常多的属性和方法，通过配置这些属性和方法，我们可以自定义应用的安装方式。比如：<code>bottle</code>可以指定预编译二进制（针对不同系统）的相关配置；<code>depends_on</code>可以指定应用安装所需的依赖；<code>install</code>方法可以指定安装的具体操作，等等。关于 Formula定义的更多细节，我们可以参考 <code>homebrew/homebrew-core</code>中的其他示例，或者参考官方文档 <ahref="https://docs.brew.sh/Formula-Cookbook">Formula Cookbook</a>。</p><p>总而言之，对于非原生应用，homebrew 会根据对应的 Formula包定义，去下载对应的二进制或源码，然后在本地进行构建、安装。</p><h2 id="cask">Cask</h2><p>Cask 是原生应用的包定义，如下所示是 SourceTree 的 Cask 定义。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">cask <span class="string">&quot;sourcetree&quot;</span> <span class="keyword">do</span></span><br><span class="line">  on_sierra <span class="symbol">:or_older</span> <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;2.7.6a&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;d60614e9ab603e0ed158b6473c36e7944b2908d9943e332c505eba03dc1d829e&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://downloads.atlassian.com/software/sourcetree/Sourcetree_<span class="subst">#&#123;version&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;downloads.atlassian.com/software/sourcetree/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_high_sierra <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;3.2.1,225&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;4bd82affa3402814c3d07ff613fbc8f45da8b0cda294d498ffbb0667bf729c9f&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_mojave <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;4.2.1,248&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;3dac6ab514c7debe960339e2aee99f018342a41baf743dbb59524728b373561f&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      skip <span class="string">&quot;Legacy version&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  on_catalina <span class="symbol">:or_newer</span> <span class="keyword">do</span></span><br><span class="line">    version <span class="string">&quot;4.2.4,254&quot;</span></span><br><span class="line">    sha256 <span class="string">&quot;62dfaeedd63ac491ba3e49a5129d338c60886cb935e3654622147369023daf77&quot;</span></span><br><span class="line"></span><br><span class="line">    url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_<span class="subst">#&#123;version.csv.first&#125;</span>_<span class="subst">#&#123;version.csv.second&#125;</span>.zip&quot;</span>,</span><br><span class="line">        <span class="symbol">verified:</span> <span class="string">&quot;product-downloads.atlassian.com/software/sourcetree/ga/&quot;</span></span><br><span class="line"></span><br><span class="line">    livecheck <span class="keyword">do</span></span><br><span class="line">      url <span class="string">&quot;https://product-downloads.atlassian.com/software/sourcetree/Appcast/SparkleAppcast.xml&quot;</span></span><br><span class="line">      strategy <span class="symbol">:sparkle</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  name <span class="string">&quot;Atlassian SourceTree&quot;</span></span><br><span class="line">  desc <span class="string">&quot;Graphical client for Git version control&quot;</span></span><br><span class="line">  homepage <span class="string">&quot;https://www.sourcetreeapp.com/&quot;</span></span><br><span class="line"></span><br><span class="line">  auto_updates <span class="literal">true</span></span><br><span class="line">  depends_on <span class="symbol">macos:</span> <span class="string">&quot;&gt;= :el_capitan&quot;</span></span><br><span class="line"></span><br><span class="line">  app <span class="string">&quot;Sourcetree.app&quot;</span></span><br><span class="line">  binary <span class="string">&quot;<span class="subst">#&#123;appdir&#125;</span>/Sourcetree.app/Contents/Resources/stree&quot;</span></span><br><span class="line"></span><br><span class="line">  uninstall <span class="symbol">launchctl:</span> <span class="string">&quot;com.atlassian.SourceTreePrivilegedHelper2&quot;</span>,</span><br><span class="line">            <span class="symbol">quit:</span>      <span class="string">&quot;com.torusknot.SourceTreeNotMAS&quot;</span></span><br><span class="line"></span><br><span class="line">  zap <span class="symbol">trash:</span> [</span><br><span class="line">    <span class="string">&quot;~/Library/Application Support/com.apple.sharedfilelist/com.apple.LSSharedFileList.ApplicationRecentDocuments/com.torusknot.sourcetreenotmas.sfl2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Application Support/SourceTree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Caches/com.torusknot.SourceTreeNotMAS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Logs/Sourcetree&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Preferences/com.torusknot.SourceTreeNotMAS.LSSharedFileList.plist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Preferences/com.torusknot.SourceTreeNotMAS.plist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;~/Library/Saved Application State/com.torusknot.SourceTreeNotMAS.savedState&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Cask 包定义本质上是初始化一个 cask实例。它同样包含了一系列基本属性，如：<code>token</code>、<code>name</code>、<code>desc</code>、<code>homepage</code>、<code>app</code>、<code>url</code>、<code>sha256</code>等。</p><p>Cask 的安装逻辑基上和 Formula 是类似的。示例中，SourceTree针对不同平台提供了不同的下载地址和 sha256 校验值，如：sierra、highsierra、mojave、catalina 等。</p><p>除此之外，Cask 也包含了大量的属性和方法，关于 Cask的更多细节，我们可以参考 <code>homebrew/homebrew-cask</code>中的其它示例，或者参考官方文档 <ahref="https://docs.brew.sh/Cask-Cookbook">Cask Cookbook</a>。</p><h1 id="外部命令">外部命令</h1><p>类似于 git，homebrew 也支持外部命令，通过这种方式可以允许用户对 brew进行定制和扩展，其运行方式如下所示，<code>extcmd</code>可以替换成任意自定义的子命令。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew extcmd --option1 --option2 &lt;formula&gt;</span><br></pre></td></tr></table></figure></p><p>Homebrew支持外部命令，从编程语言实现角度而言，可以分两种，分别是：Ruby和其他语言。从本质上而言，它们都是可执行的（chmod+ x）脚本，存放在<code>PAHT</code> 环境变量的路径中，支持系统索引。</p><p>由于 homebrew 是使用 Ruby 实现的，因此基于 Ruby的外部命令会比较特殊。只要我们将脚本命名为<code>brew-extcmd.rb</code>（<code>extcmd</code>可替换成任意自定义的子命令），homebrew 通过 <code>require</code>加载后，<code>brew-extcmd.rb</code> 会进入 homebrew的执行环境，因此可以访问 homebrew定义的所有环境变量和功能模块，开发者可使用的工具和模块会非常多。</p><p>对于其他语言实现的脚本，脚本实现中必须使用 <code>#!</code>来指定脚本的解释器，因此可支持 Python、Bash、Perl 等各种脚本语言。不同于Ruby 脚本，对于其他语言的脚本，homebrew要求脚本的名称不能有后缀，比如：<code>brew-extcmd.sh</code>脚本必须命名为 <code>brew-extcmd</code>。在运行时，homebrew会导入脚本参数和一部分环境变量。相比 Ruby 脚本而言，homebrew对于其他语言的脚本，在功能上支持会相对弱一些。</p><p>上述两种方式都是在本地扩展外部命令，如果我们希望外部命令能给其他用户使用，那应该怎么办？对此，我们仍然可以通过Taps 来实现。 类似于 Formula 使用 <code>Formula</code> 目录管理，Cask使用 <code>Casks</code> 目录管理，对于外部命令，我们使用<code>cmd</code>管理外部命令的实现脚本。当然，外部命令的维护也分为官方仓库和自建仓库，只是官方仓库的要求和规范会更加严格。</p><p>关于外部命令的具体细节，我们可以参考<code>homebrew/homebrew-core/cmd</code> 中的例子，也可以参考官方文档 <ahref="https://docs.brew.sh/External-Commands">ExternalCommands</a>。</p><h1 id="工作原理">工作原理</h1><p>整体而言，homebrew 的设计架构是比较清晰的。下面，我们来介绍 homebrew中的一些重要设计的工作原理，主要包括：</p><ul><li>命令分发</li><li>软件搜索</li><li>软件安装</li></ul><h2 id="命令分发">命令分发</h2><p>命令分发是所有命令行工具的核心功能之一，绝大部分的设计思路是：<strong>通过入口脚本对命令进行解析，一个子命令匹配一个脚本，最终由对应的脚本来解析参数、选项，并执行</strong>。</p><p>Homebrew 也不例外，我们执行的 <code>brew</code> 命令本质上是一个指向<code>Homebrew/bin/brew</code>脚本的软链接，子命令、参数、选项都会作为脚本的输入进行解析。</p><p><code>Homebrew/bin/brew</code> 脚本的核心作用是<strong>初始化一系列环境变量，并将导入 homebrew的执行环境</strong>。它并没有对命令的参数和选项进行解析，而是直接转发给了<code>Homebrew/brew.sh</code> 脚本。</p><p><code>Homebrew/brew.sh</code>脚本的职责相对而言更多，主要包括以下几分部：</p><ul><li>初始化并导入一系列环境变量。</li><li>定义了一部分工具方法，主要包括：不同等级的打印方法、自动更新方法等。</li><li>处理根命令选项和特定子命令，直接派发至 <code>Homebrew/cmd/</code>目录下对应的 Shell脚本，比如：<code>shellenv.sh</code>、<code>--cellar.sh</code> 等。</li><li>设置执行环境，包括 CA 证书、语言设置、常用工具（git、curl）等。</li><li>处理命令缩写，比如：<code>brew ls</code> 识别为<code>brew list</code>。</li><li>根据子命令加载 <code>Homebrew/cmd/</code> 目录下对应的 Shell脚本，如果加载成功，则执行匹配的方法；否则将转发至<code>Homebrew/brew.rb</code> 脚本继续解析。</li></ul><p><code>Homebrew/brew.rb</code> 脚本的职责相对简单，主要是负责处理<code>Homebrew/brew.sh</code> 未识别的命令、选项、参数。上文，我们提到brew 支持外部命令。因此，这里 <code>Homebrew/brew.rb</code>处理了一部分的逻辑：</p><ul><li>查找内部的 <code>cmd</code> 和 <code>dev-cmd</code>目录下对应的脚本，如果有则执行，否则进入下一步。</li><li>查找 <code>PATH</code> 路径和 Taps 路径下查找的符合<code>brew-&lt;cmd&gt;.rb</code> 或 <code>brew-&lt;cmd&gt;</code>模式的脚本，如果有则执行，否则报错。</li></ul><p>命令分发的整体流程如下图所示。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-11.png?x-oss-process=image/resize,w_800" /></p><h2 id="软件搜索">软件搜索</h2><p>当我们希望安装某个应用时，我们会使用<code>brew search &lt;formula&gt;</code> 或<code>brew search &lt;cask&gt; --cask</code> 来搜索一下 homebrew是否支持安装该应用。</p><p>通过上述的介绍，我们很容易猜到软件搜索的逻辑，其核心原理就是借助 Taps进行搜索和查找，包括官方的 <code>homebrew/homebrew-core</code> 和<code>homebrew/homebrew-cask</code>，以及其他自定义的 Tap仓库，从中查找各种 Formula 和 Cask的定义，从而显示精确匹配或模糊匹配的应用。</p><h2 id="软件安装">软件安装</h2><p>上文提到包定义是用于辅助完成软件安装，在安装过程中，homebrew会使用包定义中指定的 url 下载对应的源码或预编译二进制，并根据对应的<code>sha256</code> 值校验其完整性，防止被替换或篡改。</p><p>如果包定义中指定了安装过程所需要的依赖，那么 homebrew会先下载并安装对应的依赖。</p><p>然后，执行 <code>install</code>方法进行安装，对于源码则需要编译、构建，对于预编译二进制则可以执行安装。</p><p>最后，为应用创建软链接，软链接的存储路径加入了 <code>PATH</code>环境变量，因此可以被系统索引。</p><h1 id="总结">总结</h1><p>本文，我们首先介绍了 homebrew中酿酒术语与软件术语的对应关系，从而理清了术语之间的关系，建立对homebrew 的基本认知。然后介绍了 homebrew安装的软件在文件系统中的存储结构、两种包定义的基本概念，以及外部命令的实现方式。最后介绍了homebrew中几个关键设计的工作原理，包括：命令分发、软件搜索、软件安装等。</p><p>这里我们没有深入探讨 homebrew中的各种实现细节，而是着重介绍了整体的实现结构和理念。如果你有兴趣的话，可以自行探索其中的各种实现细节，相信也能获益不少。</p><p>通过学习开源软件的设计，我们能学到很多学习系统设计的方法，包括：如何规划软件的各个部分，比如，在什么地方存储日志，什么地方存储文件，软件的更新策略，软件的调度方式等。当然也能学到很多编程技巧，比如homebrew 中对于 Shell的使用，这些技巧简洁高效，能体现出作者深厚的编程功力。</p><p>后面，我还会继续学习各种开源软件的设计，总结并分享我的看法和理解~</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://github.com/Homebrew/brew">brew</a></li><li><a href="https://docs.brew.sh/">Homebrew Documentation</a></li><li><a href="https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap">Howto Create and Maintain a Tap</a></li><li><a href="https://docs.brew.sh/Formula-Cookbook">FormulaCookbook</a></li><li><a href="https://docs.brew.sh/Cask-Cookbook">Cask Cookbook</a></li><li><a href="https://docs.brew.sh/External-Commands">ExternalCommands</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/homebrew-00.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开源软件" scheme="http://chuquan.me/categories/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="Homebrew" scheme="http://chuquan.me/tags/Homebrew/"/>
    
    <category term="Formula" scheme="http://chuquan.me/tags/Formula/"/>
    
    <category term="Cask" scheme="http://chuquan.me/tags/Cask/"/>
    
    <category term="Cellar" scheme="http://chuquan.me/tags/Cellar/"/>
    
    <category term="Bottle" scheme="http://chuquan.me/tags/Bottle/"/>
    
    <category term="Keg" scheme="http://chuquan.me/tags/Keg/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅地管理你的定时任务？</title>
    <link href="http://chuquan.me/2023/07/30/introduction-to-taskloop/"/>
    <id>http://chuquan.me/2023/07/30/introduction-to-taskloop/</id>
    <published>2023-07-30T14:28:05.000Z</published>
    <updated>2023-09-16T09:10:09.973Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800" /></p><span id="more"></span><p>在日常开发中，我们经常会使用一些定时任务来辅助完成某些事情。对此，绝大多数人都会选择使用crontab 来配置定时任务。</p><p>不可否认，crontab的确是管理定时任务的经典利器，但是你是否和我一样，踩过不少 crontab的坑呢？</p><p>下面，我将介绍一下个人认为 crontab的一些痛点和坑。最终，给出另一种优化的解决方案。</p><h1 id="crontab">crontab</h1><p>提到 crontab，这里必须要介绍一下它的配置规则，如下所示。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.---------------- 分 (0 - 59)</span><br><span class="line">|  .------------- 时 (0 - 23)</span><br><span class="line">|  |  .---------- 日 (1 - 31) </span><br><span class="line">|  |  |  .------- 月 (1 - 12) </span><br><span class="line">|  |  |  |  .---- 星期 (0 - 6) (星期日可为0或7) </span><br><span class="line">|  |  |  |  | </span><br><span class="line">*  *  *  *  * 执行的命令</span><br></pre></td></tr></table></figure> crontab 的配置规则可以分为 5 列，其作用分别是：</p><ul><li>第一列单位为分，表示每时第几分钟，范围为 0-59</li><li>第二列单位为时，表示每天第几小时，范围为 0-23</li><li>第三列单位为日，表示每月第几天，范围为 1-31</li><li>第四列单位为月，表示每年第几月，范围为 1-12</li><li>第五列单位为星期，表示每星期第几天，范围 0-7，0 与 7表示星期日，其他分别为星期 1-6</li></ul><p>整体而言，crontab对于不同的单位（除了星期），均支持了三种配置规则：</p><ul><li>指定时间</li><li>指定范围</li><li>指定步长</li></ul><p>通过组合这些配置规则，crontab 可以实现非常多的定时配置。</p><p>在使用 crontab 很长时间之后，我发现 crontab还是存在着一些使用痛点的，主要有以下几点，下面分别进行介绍。</p><h2 id="输出重定向">输出重定向</h2><p>默认为情况下，crontab会将任务输出默认写入到执行用户的邮件中。如果任务有大量输出，则会大量占用磁盘资源，甚至导致系统宕机。</p><p>如下所示，我们配置一个输出当前日志的定时任务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span></span><br></pre></td></tr></table></figure><p>我们可以查看当前用户的邮件，如下所示。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /var/mail/<span class="variable">$USER</span></span><br><span class="line">...</span><br><span class="line">Tue Aug  1 22:11:22 CST 2023</span><br></pre></td></tr></table></figure></p><p>关于这个问题，实践经验都是建议采用如下的方式对任务的输出进行重定向。很显然，这对于新手是非常不友好的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">date</span> &gt;&gt; /dev/null/ 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="环境变量">环境变量</h2><p>在实践中，我们可以发现 crontab的环境变量与控制台的环境变量是存在差异的。因此，经常会出现这样的情景：在控制台中调试完成的任务，在cron中执行时，其结果会与预期不相符。事实上，产生这种差异的根本原因就是环境变量。</p><p>此外，crontab中环境变量不会全局共享。因此，当我们配置多个任务时，可能需要为每个任务单独配置环境变量。很显然，这是一个重复而又繁琐的问题。</p><h2 id="规则语法">规则语法</h2><p>关于 crontab的规则语法，这是个仁者见仁智者见智的问题。对于老手来说，可能比较简单；对于新人来说，在使用时得去查询各个位置的单位以及不同规则的写法。我觉得crontab的规则语法不容易理解的根本原因是缺少语义。如果能优化其规则语法的语义，那就更好不过了。</p><p>另一方面，对于某些极客来说，crontab的规则可能还不够完备。比如：预期一个定时任务从某个时刻开始或停止执行，或者，预期一个任务循环执行n 次后结束。对于这种规则，crontab无法一次性满足，只能通过配置多个任务来辅助完成。</p><h2 id="运行日志">运行日志</h2><p>在实际应用中，我们经常需要借助任务的运行日志来排查问题。此时，我们就需要修改crontab，将任务的输出重定向至某个文件，从而方便后续进行查看。当任务非常多的时候，我们很难记住每个任务对应的日志文件是哪个。这也是crontab 的一个痛点。</p><h1 id="taskloop">taskloop</h1><p>为了解决 crontab的诸多痛点，我在业余时间开发了一款优化版的定时任务管理器——<ahref="https://github.com/baochuquan/taskloop">taskloop</a>。</p><p>taskloop 底层运行在 cron 守护进程之上，基于 crontab配置了最小粒度的调度规则，实现了一个中间层，从而解决了 crontab的诸多痛点。</p><p><imgsrc="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/cs-of-luxun.png?x-oss-process=image/resize,w_800" /></p><h2 id="命令">命令</h2><p>taskloop提供了一系列的命令，实现了一个相对完整（如有缺失，补充实现）的工作流，其主要包含以下这些特性。</p><h3 id="环境变量-1">环境变量</h3><p><code>taskloop env</code>命令提供了查看、导入、删除环境变量的功能。</p><p>如下所示，为环境变量查看的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> </span><br><span class="line"></span><br><span class="line">PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5/bin:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global/bin:/Users/baochuquan/.rvm/rubies/ruby-2.6.5/bin:/usr/local/texlive/2023basic/bin/universal-darwin:/Users/baochuquan/.nvm/versions/node/v18.16.0/bin:/usr/local/opt/sqlite/bin:/usr/local/sbin:/usr/local/opt/gettext/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Users/baochuquan/.rvm/bin:/Users/baochuquan/Flutter/bin:/Users/baochuquan/Library/Android/sdk/tools</span><br><span class="line">RUBY_VERSION=ruby-2.6.5</span><br><span class="line">GEM_PATH=/Users/baochuquan/.rvm/gems/ruby-2.6.5:/Users/baochuquan/.rvm/gems/ruby-2.6.5@global</span><br><span class="line">GEM_HOME=/Users/baochuquan/.rvm/gems/ruby-2.6.5</span><br><span class="line">IRBRC=/Users/baochuquan/.rvm/rubies/ruby-2.6.5/.irbrc</span><br><span class="line">NOX_ROOT=/Users/baochuquan/Develop/nox</span><br><span class="line">NOX_NAME=nox</span><br><span class="line">NOX_COMMON=/Users/baochuquan/Develop/nox/common</span><br><span class="line">NOX_CONFIG=/Users/baochuquan/Develop/nox/config</span><br><span class="line">NOX_SCRIPTS=/Users/baochuquan/Develop/nox/scripts</span><br></pre></td></tr></table></figure></p><p>如下所示，为环境变量导入的使用示例。示例中，我导入了两个环境变量<code>JAVA_HOME</code> 和 <code>GROOVY_HOME</code>。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --import=JAVA_HOME,GROOVY_HOME</span><br><span class="line"></span><br><span class="line">importing JAVA_HOME ...</span><br><span class="line">    JAVA_HOME=/Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home</span><br><span class="line">importing GROOVY_HOME ...</span><br><span class="line">    GROOVY_HOME=/usr/local/opt/groovy/libexec</span><br><span class="line"></span><br><span class="line">import global environment variables complete.</span><br></pre></td></tr></table></figure></p><p>如下所示，为环境变量删除的使用示例。示例中，我删除了<code>GROOVY_HOME</code> 环境变量。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">env</span> --remove=GROOVY_HOME</span><br><span class="line"></span><br><span class="line">remove global environment variables complete.</span><br></pre></td></tr></table></figure></p><p>经过一系列导入、删除操作之后，我们可以通过 <code>taskloop env</code>命令来查看导入结果是否正确。</p><h3 id="启动关闭">启动/关闭</h3><p>taskloop 具有一个全局的开关，即启动和关闭的能力。前面我们提到taskloop 底层是运行在 cron 守护进程之上，对此，启动功能的本质就是将taskloop 注册至 crontab；关闭功能的本质就是将 taskloop 从 crontab注销。</p><p>如下所示，为启动 taskloop 的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$  taskloop launch</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has launched successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>如下所示，为关闭 taskloop 的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop shutdown</span><br><span class="line"></span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@   @@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@    @@@@@       @@@   @@   @@    @@@@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@   @@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@   @@@    @@@@@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@@@@    @@@      @@@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@   @@@   @@   @@@   @@   @   @@@    @@@@   @@   @@   @@   @@   @@   @@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@        @@@       @@@   @@   @@      @@@      @@@@      @@@       @@@@@@@@@</span><br><span class="line">@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line"></span><br><span class="line">    taskloop has shutdown successfully.</span><br><span class="line"></span><br><span class="line">    byeeeeeeeeeeeeeeeee !</span><br></pre></td></tr></table></figure></p><h3 id="初始化">初始化</h3><p>taskloop 通过读取注册的 Taskfile 来执行所有的任务，Taskfile中可以定义一系列用户自定义的任务。为了便于使用，taskloop提供了一个初始化命令，可以自动创建一个 Taskfile模板，从而供用户进行修改和定制。</p><p>如下所示，为初始化的使用示例。<code>taskloop init</code>方法创建了一个 Taskfile模板，并定义了所有支持的属性，我们可以自定义任务，包括任务的路径、名称、执行规则等。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop init</span><br><span class="line">$ <span class="built_in">cat</span> Taskfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># env to set environment variables which are shared by all tasks defined in the Taskfile. &lt;Optional&gt;</span></span><br><span class="line"><span class="comment"># env &quot;ENV_NAME&quot;, &quot;ENV_VALUE&quot;</span></span><br><span class="line"></span><br><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="发布撤销">发布/撤销</h3><p>当我们完成了对 Taskfile的定义之后，可以进行发布。发布过程中，taskloop 会检查 Taskfile中的语法规则，如果不符合将抛出异常，并提示错误；如果符合规则，则完成发布。Taskfile将正式生效，后续的任务执行将以此为准。</p><p>如下所示，为发布的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop deploy</span><br><span class="line"></span><br><span class="line">                       (@&amp;/////%@@@@@@@@@@@@@<span class="comment">#</span></span><br><span class="line">                          @@&amp;@&amp;////////////////(@@<span class="comment">#</span></span><br><span class="line">                         /@(///////////////////////%@/</span><br><span class="line">                       *@////////////////////////////<span class="comment">#@,</span></span><br><span class="line">                      @&amp;///////////////////////////////@%</span><br><span class="line">                     @&amp;//////////////(@////@&amp;<span class="comment">#/////////(@</span></span><br><span class="line">                     @////////////@@  @////@    ,.@////@@</span><br><span class="line">                    /@//////////&amp;@  ,@@////@@@&amp;.  *///@@</span><br><span class="line">                    ,@/////////(@@@   @///&amp;@     /@@///@@</span><br><span class="line">                     @%////////@@     @@@&amp;           @@/@<span class="comment">#</span></span><br><span class="line">                      @<span class="comment">#///////@           ,</span></span><br><span class="line">                       @@//////@&amp;      @(//@</span><br><span class="line">                         @@/////%@    @////@</span><br><span class="line">                            @@/////<span class="comment">#@@@////@</span></span><br><span class="line">                                &amp;@@@&amp;<span class="comment">#((&amp;@@</span></span><br><span class="line">                          /&amp;<span class="comment">#         @///@@</span></span><br><span class="line">                       ,///,*.        @////@</span><br><span class="line">                   &amp;<span class="comment">#  %/,@           @@///@</span></span><br><span class="line">                 (, .*/&amp;*%/*%///&amp;       (@@@         ,*/////*.</span><br><span class="line">           %/<span class="comment">#@, ////&amp;  @  % .&amp;  /@%/(/    /#/#@(                 #@#/&amp;</span></span><br><span class="line">        (/&amp;               .           .////,                           &amp;//</span><br><span class="line">       &amp;(//@                         &amp;//////&amp;                         @///@</span><br><span class="line">         (@%//////<span class="comment">#&amp;@@@@@@@@@@%///////@@  @@///////%@@@@@@@@@@&amp;#//////#@#</span></span><br><span class="line">                %@@@@&amp;@@@@@&amp;&amp;@@@@/              /@@@@&amp;&amp;@@@@@&amp;@@@@&amp;</span><br><span class="line"></span><br><span class="line">                              Taskfile deploy success!</span><br></pre></td></tr></table></figure></p><p>当然，在某些情况下，我们需要撤销已经发布的Taskfile。此时，我们可以执行如下命令进行撤销。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-job-project</span><br><span class="line">$ taskloop undeploy</span><br><span class="line"></span><br><span class="line">Taskfile <span class="keyword">in</span> &lt;/Users/baochuquan/Github/taskloop&gt; has been undeployed successfully.</span><br></pre></td></tr></table></figure><h3 id="任务查看">任务查看</h3><p>为了便于查看当前已发布的任务，taskloop提供了一个命令方便用户进行查询。如下所示，为任务查看的使用示例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop list</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Tasks above are defined <span class="keyword">in</span> Taskfile of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">  &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt;</span><br><span class="line">    t.name        = haha</span><br><span class="line">    t.path        = ./test/Test01.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; specific: Aug</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; scope: between 25, 30</span><br><span class="line">    t.loop        = unit: loop; default rule</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br><span class="line">  &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt;</span><br><span class="line">    t.name        = baocq</span><br><span class="line">    t.path        = ./test/Test02.rb</span><br><span class="line">    t.year        = unit: year; default rule</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; default rule</span><br><span class="line">    t.minute      = unit: minute; interval: 1</span><br><span class="line">    t.loop        = unit: loop; loop: 3</span><br><span class="line">    t.start_point = unit: full; boundary: start from 2023-7-31 22:31:00</span><br><span class="line">    t.end_point   = unit: full; boundary: end to 2023-7-31 22:35:00</span><br><span class="line">  &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt;</span><br><span class="line">    t.name        = chuquan</span><br><span class="line">    t.path        = ./test/Test03.rb</span><br><span class="line">    t.year        = unit: year; specific: 2023</span><br><span class="line">    t.month       = unit: month; default rule</span><br><span class="line">    t.day         = unit: day; default rule</span><br><span class="line">    t.hour        = unit: hour; scope: after 22</span><br><span class="line">    t.minute      = unit: minute; interval: 10</span><br><span class="line">    t.loop        = unit: loop; loop: 1</span><br><span class="line">    t.start_point = unit: full; default rule</span><br><span class="line">    t.end_point   = unit: full; default rule</span><br></pre></td></tr></table></figure><h3 id="日志查看">日志查看</h3><p>为了解决 crontab 的日志查询问题，taskloop同样提供了一个命令支持查询不同维度的日志，包括：系统日志（即 taskloop运行日志）、任务日志。</p><p>如下所示，为查看系统日志的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --cron</span><br><span class="line"></span><br><span class="line">=============================</span><br><span class="line">Log of cron:</span><br><span class="line"></span><br><span class="line">Trigger Time: &lt;2023-08-03 08:24:00 +0800&gt;</span><br><span class="line">Checking: &lt;Task.name: haha, sha1: 637d1f5c6e6d1be22ed907eb3d223d858ca396d8&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: baocq, sha1: 7cc14c1bffcd559180d9906377bfaa41a4f9a980&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">Checking: &lt;Task.name: chuquan, sha1: d461e86c07d232ceebcd2d024ea4b4c33d0f7b4b&gt; does not meet the execution rules, taskloop will skip its execution.</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><p>如下所示，为查看任务日志的使用示例。 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ taskloop <span class="built_in">log</span> --task-name=baocq</span><br><span class="line">=============================</span><br><span class="line">Project of &lt;/Users/baochuquan/Github/taskloop&gt;</span><br><span class="line">Log of &lt;Task.name: haha&gt; above:</span><br><span class="line">&lt;Trigger Time: 2023-08-03 08:27:16 +0800&gt;</span><br><span class="line">Test0101</span><br><span class="line"></span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><h2 id="语法规则">语法规则</h2><p><code>taskloop init</code> 命令会创建一个 Taskfile 文件，我们可以在Taskfile 文件中自定义不同的任务与规则。这里，taskloop定义了一套语法规则，我们将基于如下所示的 Taskfile 模板进行介绍。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TaskLoop::Task.new <span class="keyword">do</span> |t|</span><br><span class="line">  t.name        = <span class="string">&#x27;TODO: task name. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.path        = <span class="string">&#x27;TODO: task job path. For example, t.path = &quot;./Job.sh&quot;. &lt;Required&gt;&#x27;</span></span><br><span class="line">  t.week        = <span class="string">&#x27;TODO: week rule. &lt;Optional&gt;&#x27;</span></span><br><span class="line">  t.year        = <span class="string">&quot;TODO: year rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.month       = <span class="string">&quot;TODO: month rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.day         = <span class="string">&quot;TODO: day rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.hour        = <span class="string">&quot;TODO: hour rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.minute      = <span class="string">&quot;TODO: minute rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.time        = <span class="string">&quot;TODO: time list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.date        = <span class="string">&quot;TODO: date list rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.loop        = <span class="string">&quot;TODO: loop count. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.start_point = <span class="string">&quot;TODO: start point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">  t.end_point   = <span class="string">&quot;TODO: end point boundary rule. &lt;Optional&gt;&quot;</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>模板中列出了任务支持的所有属性，首先有两个必要属性 <code>name</code>和 <code>path</code>。</p><ul><li><code>name</code>：用于指出任务的名称，同一个 Taskfile中不能有同名的任务，主要用于日志查询时指定名称。</li><li><code>path</code> 用于指出任务的路径，taskloop会根据此路径加载并执行任务脚本。</li></ul><p>模板中的其他属性均为非必要属性，用于描述执行规则。关于执行规则，taskloop中主要定义如下几种规则。</p><ul><li><strong>指定时间规则（Specific Rule）</strong><ul><li>指定时间规则用于指定特定的时间值，对应的语法是<code>at</code>。</li><li>支持指定时间规则的属性有<code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>，其中<code>week</code>、<code>month</code>、<code>day</code>属性需要使用预定义的符号，其余属性可以直接使用数值。<ul><li>对于<code>week</code>，需要使用星期符号，如：<code>:Sun</code>、<code>:Mon</code>等。</li><li>对于<code>month</code>，需要使用月份符号，如：<code>:Jan</code>、<code>:Feb</code>等。</li><li>对于<code>day</code>，需要使用表示月份中第几天的符号，如：<code>:day1</code>，<code>:day2</code>等。</li></ul></li><li>示例<ul><li><code>t.week = at :Mon, :Sub, :Tue</code></li><li><code>t.month = at :Feb, :Aug</code></li><li><code>t.day = at :day2, :day8, :day30, day:31</code></li><li><code>t.year = at 2023, 2024</code></li><li><code>t.hour = at 10, 11</code></li><li><code>t.minute = at 59</code></li></ul></li></ul></li><li><strong>时间范围规则（Scope Rule）</strong><ul><li>时间范围规则包含三种子规则，对应的语法分别是：<code>before</code>、<code>between</code>、<code>after</code>。<ul><li><code>before</code> 语法表示在小于等于某个值时执行。</li><li><code>between</code>语法表示在大于等于某个值，且小于等于另一个值时执行。</li><li><code>after</code> 语法表示在大于等于某个值时执行。</li></ul></li><li>支持时间范围规则的属性有<code>week</code>、<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li><li>示例<ul><li><code>t.year = before 2026</code></li><li><code>t.week = between :Mon, :Fri</code></li><li><code>t.hour = after 12</code></li></ul></li></ul></li><li><strong>时间间隔规则（Interval Rule）</strong><ul><li>时间间隔规则用于指定两次任务之间的时间间隔，对应的语法是<code>interval</code>。</li><li>支持时间间隔规则的属性有<code>year</code>、<code>month</code>、<code>day</code>、<code>hour</code>、<code>minute</code>。</li><li>示例<ul><li><code>t.minute = interval 5</code></li><li><code>t.day = interval 1</code></li></ul></li></ul></li><li><strong>循环次数规则（Loop Rule）</strong><ul><li>循环次数规则用于指定任务循环的次数，对应的语法是<code>loop</code>。</li><li>支持循环次数规则的属性只有 <code>loop</code>。</li><li>示例<ul><li><code>t.loop = loop 10</code></li></ul></li></ul></li><li><strong>时间列表规则（Time List Rule）</strong><ul><li>时间列表规则用于指定任务执行的时间列表，对应的语法是<code>time</code>。其与 <code>hour</code>、<code>minute</code>属性冲突，不能同时使用。</li><li>支持时间列表规则的属性只有 <code>time</code>。</li><li>示例<ul><li><code>t.time = time "10:00:00", "7:00:00"</code></li></ul></li></ul></li><li><strong>日期列表规则（Date List Rule）</strong><ul><li>日期列表规则用于指定执行任务的日期列表，对应的语法是<code>date</code>。其与<code>year</code>、<code>month</code>、<code>day</code>属性冲突，不能同时使用。</li><li>支持日期列表规则的属性只有 <code>date</code>。</li><li>示例<ul><li><code>t.date = date "2023-10-1, "2023-5-1</code></li></ul></li></ul></li><li><strong>执行边界规则（Boundary Rule）</strong><ul><li>执行边界规则包含两种子规则，对应的语法分别是 <code>from</code> 和<code>to</code>。<ul><li><code>from</code> 语法表示任务从某一个时刻开始执行，支持的属性只有<code>start_point</code>。</li><li><code>to</code> 语法表示任务在某一时刻之后不在执行，支持的属性只有<code>end_point</code>。</li></ul></li><li>示例<ul><li><code>t.start_point = "2023-10-1 10:00:00"</code></li><li><code>t.end_point = "2023-10-30 23:59:00</code></li></ul></li></ul></li></ul><h2 id="工作流程">工作流程</h2><p>taskloop 的工作流程可以分为三个步骤：</p><ul><li><strong>启动/关闭</strong></li><li><strong>初始化</strong></li><li><strong>发布/撤销</strong></li></ul><p>启动/关闭步骤是一个全局开关，对应分别有两个命令，如上所述。关于启动，一般只在最开始使用taskloop的时候使用启动命令。如果希望停止所有已注册任务的执行，则可以执行关闭命令。</p><p>taskloop建议用户能够使用一个目录统一管理所有的定时任务，当希望为这些定时任务创建定时规则时，可以在目录下执行初始化命令，从而生成一个Taskfile文件。之后，即可自定义定时规则。如果用户本地维护了多个目录管理定时任务，则需要在不同的目录下分别执行一次初始化命令，从而完成任务规则自定义。</p><p>发布/撤销步骤相对而言会比较频繁，当初始化并自定义 Taskfile之后，我们就可以执行发布命令，使得 Taskfile 真正在 taskloop中生效。当然，有时候我们会在发布后发现一些错误，我们可以修改后重新发布，或者为了避免产生副作用，可以执行撤销命令。注意，发布/撤销命令必须在Taskfile 的同级目录下执行。</p><h1 id="总结">总结</h1><p>本文简单介绍了一下我最近业余时间写的一个定时任务管理工具——taskloop。同时，解释了为什么做这个工具的原因（即解决crontab 的痛点）。</p><p>关于软件logo，我花了两晚设计了这样一个形象。两个圈组成一个莫比乌斯环，象征着循环。任务执行抽象为海豚跳圈，海豚在两个圈中循环穿越则象征着taskloop 在永不停止地运行任务。</p><p>忘了说，其实写这篇文章的另一个重要目的是为了推广一下我的作品，也希望有兴趣的朋友能够给一些意见，甚至可以一起参与软件的开发和完善。</p><h1 id="参考">参考</h1><ol type="1"><li><a href="https://github.com/baochuquan/taskloop">taskloop</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/taskloop-logo-white.png?x-oss-process=image/resize,w_800&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby" scheme="http://chuquan.me/categories/Ruby/"/>
    
    
    <category term="taskloop" scheme="http://chuquan.me/tags/taskloop/"/>
    
    <category term="cron" scheme="http://chuquan.me/tags/cron/"/>
    
    <category term="crontab" scheme="http://chuquan.me/tags/crontab/"/>
    
    <category term="定时任务" scheme="http://chuquan.me/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
</feed>
