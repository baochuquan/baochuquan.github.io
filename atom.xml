<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楚权的世界</title>
  
  <subtitle>Seek the wonder of life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chuquan.me/"/>
  <updated>2019-10-07T03:26:54.899Z</updated>
  <id>http://chuquan.me/</id>
  
  <author>
    <name>Bao Chuquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从比特币入门区块链</title>
    <link href="http://chuquan.me/2019/10/07/understand-bitcoin/"/>
    <id>http://chuquan.me/2019/10/07/understand-bitcoin/</id>
    <published>2019-10-07T03:20:49.000Z</published>
    <updated>2019-10-07T03:26:54.899Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin_logo.png?x-oss-process=image/resize,w_800" alt=""></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>2008 年 11 月 1 日，中本聪（Satoshi Nakamoto）在 metzdowd 的加密技术邮件列表发布比特币白皮书：<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">《BitCoin: A Peer-to-Peer Electronic Cash System》</a>，首次提出比特币（BitCoin，BTC）的概念。</p><p>2009 年 1 月 3 日，中本聪在位于芬兰赫尔辛基（Helsinki）的一个小型服务器上挖出了第一批 50 个比特币。至此，比特币电子现金系统正式诞生。</p><p>比特币是一个完全去中心化的电子现金系统，它不依赖于中央机构进行货币发行、结算、验证交易。<strong>区块链</strong> 则是支持比特币系统的核心技术。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>下面，我们以一个具体例子来介绍比特币的工作原理以及相关概念。</p><p>假如，有 A、B、C、D 四个人，它们之间发生了三笔交易：</p><ul><li>A 向 B 转账 10 比特币</li><li>B 向 C 转账 20 比特币</li><li>C 向 D 转账 30 比特币</li></ul><p>那么，通过在比特币网络中进行广播，比特币网络中的 <strong>所有节点</strong> 都将获得这一系列交易信息。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/bitcoin-example01.png?x-oss-process=image/resize,w_800" alt=""></p><p>这些交易信息最终会由 <strong>某个节点</strong> 负责组装到一个 <strong>区块</strong>（Block）中，并将该区块添加至 <strong>全局区块链</strong> 中。<strong>注意，每个节点都保存了完整的全局区块链</strong>。</p><p>这里，就产生了三个问题：</p><ul><li>节点为何工作？</li><li>如何选择节点？</li><li>如何验证交易内容的真实性？</li></ul><p>下面，我们依次来回答这几个问题，并引出相关概念。</p><h2 id="节点为何工作？"><a href="#节点为何工作？" class="headerlink" title="节点为何工作？"></a>节点为何工作？</h2><p>比特币网络的节点为什么要创建并添加区块？因为，这是有奖励的，奖励包含两部分：</p><ul><li>每比交易提供的手续费</li><li>系统提供的比特币奖励</li></ul><p>关于系统的奖励规则，系统规定：</p><ul><li>每向全局区块链中添加一个区块，系统会奖励 50 个比特币，每 4 年奖励减半。</li><li>平均每 10 分钟生成一个新的区块。</li></ul><p>由此，我们可以通过计算得出系统总共包含的比特币数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比特币总数 = ((60 分钟 × 24 小时 × 365 天 × 4 年) / 10 分钟) × 50 比特币 × (1 + 1/2 + (1/2)² + (1/2)³ ...) ≈ 2100 万</span><br></pre></td></tr></table></figure></p><h2 id="如何选择节点？"><a href="#如何选择节点？" class="headerlink" title="如何选择节点？"></a>如何选择节点？</h2><p>如何选择节点？因为比特币是一个典型的分布式系统，分布式系统则是通过 <strong>共识算法</strong>（Consensus Algorithm）来进行节点选择。</p><p>分布式系统的共识算法有很多，常见的有以下这些：</p><ul><li>Paxos</li><li>Raft</li><li>PoW（工作量证明，Proof-of-Work）</li><li>PBFT（practival Byzantine Fault Tolerance）</li><li>XFT（Cross Fault Tolerance）</li><li>…</li></ul><p>比特币系统采用的则是 <strong>工作量证明</strong> 共识算法。关于工作量证明的详细原理，我们需要先介绍哈希函数。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数可以对任意内容计算出一个长度相同的特征值。比特币区块链使用 <code>SHA256</code> 算法作为哈希函数，其哈希特征值长度为 256 位。无论原始内容是什么，最后都会计算出一个 256 位的二进制数值。如下所示，为字符串 <code>123</code> 基于 <code>SHA256</code> 算法的十六进制哈希值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA256(&quot;123&quot;) = 0xa8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0</span><br></pre></td></tr></table></figure></p><p>哈希函数具有一个重要特征：</p><ul><li><strong>正向计算容易，反向逆推困难</strong></li></ul><p>什么意思？以如下一道数学题为例，我们通过已知的 <code>x</code> 计算 <code>y</code> 的值是非常简单的。但是通过已知的 <code>y</code> 计算 <code>x</code> 的值则是非常困难的。所以，想要通过哈希值求解原始值只能通过暴力求解，挨个试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x³ * ln(ln(x)) + x² * sin(x) = y</span><br></pre></td></tr></table></figure></p><h3 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h3><p>工作量证明要做的事情其实就是 <strong>逆推哈希值</strong>。由于只能使用暴力求解，所以这是一个非常耗时的过程。不过，一旦某个节点在整个比特币网络中第一个计算出正确值，那么它将会获得丰富的奖励，所以工作量证明也被称为 <strong>挖矿</strong>（Mining）。</p><p>那么工作量证明究竟要解决一道什么样的难题呢？我们需要先从区块的结构说起。</p><p>如下图所示，为区块链的基本结构——区块。区块主要包含两部分：</p><ul><li><strong>区块头</strong>（Block Header）<ul><li>生成时间</li><li>当前区块体的哈希值</li><li>上一区块体的哈希值</li><li>. . .</li></ul></li><li><strong>区块体</strong>（Block Body）<ul><li>交易内容 </li></ul></li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-structure-of-one-block.png?x-oss-process=image/resize,w_800" alt=""></p><p>在了解了区块结构之后，我们再来看工作量证明到底要解决一道什么难题。题目如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHA256(字符串) -&gt; 符合某个条件的哈希值（小于某个目标值）</span><br></pre></td></tr></table></figure></p><p>其中，字符串由 <strong>当前区块头 + 当前区块体 + 生成时间 + 某个随机数</strong> 组成。求解字符串中的 <strong>某个随机数</strong>，使得最终的哈希值小于某个目标值（Target）。这里的 <strong>某个随机数</strong> 也被称为 <code>Nonce</code>。</p><p><code>Nonce</code> 是一个 32 位的二进制值，非常难猜的，目前只能通过穷举法一个个试错。</p><h3 id="难度系数"><a href="#难度系数" class="headerlink" title="难度系数"></a>难度系数</h3><p>比特币系统中，难度系数（Difficulty）可以控制区块的生成速度。难度系数可以决定上述目标值的大小。</p><p>目标值和难度系数的计算关系如下，可见难度系数越大，目标值越小，因此符合条件哈希值范围越小，难度则越大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标值 = 理论最大哈希值 / 难度系数</span><br></pre></td></tr></table></figure></p><h3 id="速度恒定"><a href="#速度恒定" class="headerlink" title="速度恒定"></a>速度恒定</h3><p>比特币系统将区块的生成速度定为 <strong>每 10 分钟生成 1 个区块</strong>。那么，这是怎么做到的呢？</p><p>其实本质上就是难度系数的动态调整。由于目标值决定了符合条件的值范围，所以我们能够计算出任意一个随机数符合条件的概率为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意一个随机数符合条件的概率 = 目标值 / 理论最大哈希值 = 1 / 难度系数</span><br></pre></td></tr></table></figure></p><p>那么，这又是如何做到对时间的控制呢？</p><p>假设，世界上有 10000 台矿机，每台矿机的计算速度是 20T/s，即每秒能够 20T 次哈希运算。因此可以计算出整个世界的算力是 2 × 10^17 次/s。那么 10 分钟的算力则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">十分钟的算力 = 10 × 60 × 2 × 10^17 = 1.2 × 10^20 次哈希运算</span><br></pre></td></tr></table></figure></p><p>因为 10 分钟内只能成功一次，所以我们可以得出以下等式，从而得出最终的难度系数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 分钟的算力 × 符合条件的概率 = 1 次</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line">1.2 × 10^20 × (1 / 难度系数) = 1</span><br><span class="line"></span><br><span class="line">求解 -&gt; 难度系数？</span><br></pre></td></tr></table></figure></p><p>由于全世界的算力一直都在变化，为了能够将产出速度控制在 10 分钟，比特币系统规定：难度系数每两周调整一次。如果这两周内，区块的平均生成速度是 9 分钟（意味着比法定速度快 10 %），则将难度系数调高 10 %。反之亦然。</p><h2 id="如何验证交易内容的真实性？"><a href="#如何验证交易内容的真实性？" class="headerlink" title="如何验证交易内容的真实性？"></a>如何验证交易内容的真实性？</h2><p>以示例为例，交易内容的真实性主要包含两个问题：</p><ul><li>A 向 B 转账 10 BTC 是否真的是 A 发出的消息？</li><li>A 是否真的有 10 BTC 以上资产？</li></ul><p>针对第一个问题，我们需要简单了解一下比特币的 <strong>账户地址</strong> 概念。</p><p>比特币用户在注册账户时，系统会自动生成一个随机数。利用随机数，系统可以生成一对非对称密钥（公钥+私钥）。比特币账户地址则是由公钥进行一系列哈希以及编码运算后生成的 160 位（20 字节）字符串。</p><p>用户 A 在发起一个交易时，会先对交易内容进行哈希运算，从而得到摘要（Digest）；然后再用私钥对摘要进行加密，从而得到密文。最后，广播到比特币网络的内容则是：交易内容 + 公钥 + 密文。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-verify01.png?x-oss-process=image/resize,w_800" alt=""></p><p>当比特币网络的其他节点收到消息后，会对它进行验证：</p><ol><li>对交易内容进行哈希运算，得到摘要 1</li><li>对密文使用公钥进行解密，得到摘要 2</li><li>判断摘要 1 和摘要 2 是否一致</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-verify02.png?x-oss-process=image/resize,w_800" alt=""></p><p>如果摘要 1 和摘要 2 一致，则证明交易内容是真实的，在广播过程中并未被篡改。那么如何证明消息的发起者也是 A 呢？毕竟，我们不能认可 B 发消息说 C 向 B 付款 10 BTC 这种内容。消息发起者必须是付款方。</p><p>事实上，比特币系统中是通过 <strong>签名脚本</strong> 和 <strong>输出脚本</strong> 在消息发出前就限制了 <strong>消息发起者必须是付款方</strong>。因此，其他节点收到广播消息时无需再次验证。</p><p>关于 <strong>签名脚本</strong> 和 <strong>输出脚本</strong>，我们后续再在其他文中在详细进行介绍。</p><p>至此，第一个问题得以解决。</p><p>针对第二个问题，A 是否真的有 10 BTC 以上的资产。</p><p>这个问题的验证非常简单，可以通过在全局区块链进行追溯，即可得以验证。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="经济博弈"><a href="#经济博弈" class="headerlink" title="经济博弈"></a>经济博弈</h3><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/blockchain-two-chain01.png?x-oss-process=image/resize,w_800" alt=""></p><p>假设，全局区块链有一个区块，其内部记载了 A 向 B 转账 100 BTC 的交易内容。然而，比特币网络中有一个恶意节点，该恶意节点希望对该区块的交易记录进行篡改，因此在该区块前开辟了一个分叉。那么它最终能得逞吗？</p><p>为了解释这个问题，我们需要先介绍比特币系统的 <strong>最长链原则</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最长链原则：所有节点默认信任全局区块链中最长的分支。</span><br></pre></td></tr></table></figure></p><p>根据最长链原则，除恶意节点以外的其他节点，都会信任区块链的最长分支。如果恶意节点希望其所在分支成为最长分支，那么它占据全局 51% 以上的算力，才可能战胜其他所有节点。这从经济学角度而言，它需要付出巨大的成本，却只能获得不大的收益，投入与产出严重不匹配。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>比特币是基于 <strong>区块链</strong> 技术的一种具体应用，也是一种典型的分布式系统。后面，我们有机会再学习一下分布式系统的一些基本概念和相关原理。</p><p>比特币也运用了大量密码学原理，后续有机会我们也来学习一下相关内容。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://bitcoin.org" target="_blank" rel="noopener">bitcoin</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/bitcoin_logo.png?x-oss-process=image/resize,w_800&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://chuquan.me/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="分布式系统" scheme="http://chuquan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="比特币" scheme="http://chuquan.me/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>源码解读——Masonry</title>
    <link href="http://chuquan.me/2019/10/02/understand-masonry/"/>
    <id>http://chuquan.me/2019/10/02/understand-masonry/</id>
    <published>2019-10-02T03:54:26.000Z</published>
    <updated>2019-10-02T04:05:43.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Masonry-概述"><a href="#Masonry-概述" class="headerlink" title="Masonry 概述"></a>Masonry 概述</h1><p>Masonry 是基于 Apple 的自动布局封装的一个轻量级布局框架。Masonry 通过一种链式的 DSL（Domain-Specific Language）来描述 <code>NSLayoutConstraint</code>。相比原生的自动布局语法，Masonry 提供了更为简便的语法来构造布局。Masonry 同时支持 iOS 和 Mac OS X。</p><p>关于原生的自动布局的详细内容，可以阅读另一篇文章——<a href="http://chuquan.me/2019/09/25/systematic-understand-ios-autolayout/">《系统理解 iOS 自动布局》</a>。</p><p>本文所分析的 Masonry 源码版本是 <code>7.4.2</code>。</p><h1 id="Auto-Layout-VS-Masonry"><a href="#Auto-Layout-VS-Masonry" class="headerlink" title="Auto Layout VS Masonry"></a>Auto Layout VS Masonry</h1><p>苹果提供的自动布局（Auto Layout）能够对视图进行灵活有效的布局。但是，使用原生的自动布局相关的语法创建约束的过程是非常冗长的，可读性也比较差。</p><p>如下所示代码，其作用是让一个子视图填充其父视图，其中子视图的每一边相对父视图缩进 10 像素。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *superview = <span class="keyword">self</span>.view;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">[superview addSubview:view1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIEdgeInsets</span> padding = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">[superview addConstraints:@[</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view1 constraints</span></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:padding.top],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeLeft</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeLeft</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:padding.left],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeBottom</span></span><br><span class="line">                                multiplier:<span class="number">1.0</span></span><br><span class="line">                                  constant:-padding.bottom],</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                    toItem:superview</span><br><span class="line">                                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                                multiplier:<span class="number">1</span></span><br><span class="line">                                  constant:-padding.right],</span><br><span class="line"></span><br><span class="line"> ]];</span><br></pre></td></tr></table></figure></p><p>由上可见，使用原生的自动布局语法，对于如此简单的一个布局，也是非常冗长的。如果使用 VFL（Visual Format Language）可以有效减少冗余，但是其 ASCII 类型语法使得编译器无法做类型检查，存在一定的安全隐患。</p><p>Masonry 的目标其实就是 <strong>为了解决原生自动布局语法冗长的问题</strong>。对于上述示例，使用 Masonry 只需要一下几行代码即可解决。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIEdgeInsets</span> padding = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(superview.mas_top).with.offset(padding.top); <span class="comment">//with is an optional semantic filler</span></span><br><span class="line">    make.left.equalTo(superview.mas_left).with.offset(padding.left);</span><br><span class="line">    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);</span><br><span class="line">    make.right.equalTo(superview.mas_right).with.offset(-padding.right);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>甚至还可以更加简单：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.equalTo(superview).with.insets(padding);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><h1 id="Masonry-架构"><a href="#Masonry-架构" class="headerlink" title="Masonry 架构"></a>Masonry 架构</h1><h2 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h2><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/masonry-overview.png?x-oss-process=image/resize,w_800" alt=""></p><p>Masonry 主要方法由上述例子就可一窥全貌。Masonry 主要通过对 <code>UIView</code>（<code>NSView</code>）、<code>NSArray</code>、<code>UIViewController</code> 进行分类扩展，从而提供自动布局的构建方法。相关方法定义在上图所示部分文件中：</p><ul><li><code>View+MASAddtions</code></li><li><code>NSArray+MASAddtions</code></li><li><code>ViewController+MASAddtions</code></li></ul><p>通过分类提供的自动布局构建方法主要有以下这些：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View+MASAddtions</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span>(<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="keyword">void</span>(<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSArray+Addtions</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span> (<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span> (<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="keyword">void</span> (<span class="built_in">NS_NOESCAPE</span> ^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="keyword">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedSpacing:(<span class="built_in">CGFloat</span>)fixedSpacing leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br><span class="line">- (<span class="keyword">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedItemLength:(<span class="built_in">CGFloat</span>)fixedItemLength leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br></pre></td></tr></table></figure></p><p>上述自动布局构建方法均使用一个<code>void(NS_NOESCAPE ^)(MASConstraintMaker *make)</code> 类型的 block 作为参数。的确，<code>MASConstraintMaker</code> 就是 Mansonry 框架中构建布局约束的核心。<code>MASConstraintMaker</code> 引用了 <code>MASConstraint</code> 的一系列方法及其子类（包括：<code>MASCompositeConstraint</code>、<code>MASViewConstraint</code>），从而实现约束的创建与添加。</p><p><code>MASConstraint</code> 则提供了一系列返回类型为 <code>MASConstraint</code> 的方法，从而实现了链式 DSL，使 Masonry 具备了简洁灵活的优点。</p><p>下面，我们依次来介绍 Masonry 框架中的几个重要类：</p><ul><li><code>MASLayoutConstraint</code></li><li><code>MASViewAttribute</code></li><li><code>MASConstraint</code></li><li><code>MAConstraintMaker</code></li></ul><h3 id="MASLayoutConstraint"><a href="#MASLayoutConstraint" class="headerlink" title="MASLayoutConstraint"></a>MASLayoutConstraint</h3><p><code>MASLayoutConstraint</code> 类继承自 <code>NSLayoutConstraint</code> 类。相比其父类，它就多了一个属性 <code>mas_key</code>。</p><p><code>MASLayoutConstraint</code> 用来表示 <strong>布局约束</strong>。</p><h3 id="MASViewAttribute"><a href="#MASViewAttribute" class="headerlink" title="MASViewAttribute"></a>MASViewAttribute</h3><p>我们知道在自动布局系统中，约束的本质是一个方程式：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.attribute1 = multiplier × item2.attribute2 + constant</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/view-formula.png?x-oss-process=image/resize,w_800" alt=""></p><p><code>MASViewAttribute</code> 就是约束方程式中一个 <code>item</code> 与 <code>attribute</code> 组成的单元。</p><p>如下所示便是 <code>MASViewAttribute</code> 定义的属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MASViewAttribute</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The view which the reciever relates to. Can be nil if item is not a view.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) MAS_VIEW *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The item which the reciever relates to.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> item;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The attribute which the reciever relates to</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> layoutAttribute;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>其中，关于 <code>NSLayoutAttribute</code> 枚举所包含的类型，详见 《<a href="http://chuquan.me/2019/09/25/systematic-understand-ios-autolayout/">系统理解 iOS 自动布局</a>》中 <strong>约束/约束规则/属性</strong> 小节。</p><h3 id="MASConstraint"><a href="#MASConstraint" class="headerlink" title="MASConstraint"></a>MASConstraint</h3><p><code>MASConstraint</code> 是一个抽象类，主要为其子类 <code>MASViewConstraint</code> 和 <code>MASCompositeConstraint</code> 声明了一些共有的方法。<code>MASConstraint</code> 为这些共有的方法实现了部分功能，底层的细节实现则由其子类决定。</p><p>根据约束方程式的组成，可将这些方法分为以下几类：</p><ul><li>属性操作方法（Attribute）</li><li>关系操作方法（Relationship）</li><li>倍数操作方法（Multiplier）</li><li>常量操作方法（Constant）</li></ul><p>除此之外，还有优先级操作方法。</p><p><strong>属性操作方法</strong></p><p>属性操作方法根据对应的 <code>NSLayoutAttribute</code> 枚举类型创建约束属性项。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint *)left;</span><br><span class="line">- (MASConstraint *)top;</span><br><span class="line">- (MASConstraint *)right;</span><br><span class="line">- (MASConstraint *)bottom;</span><br><span class="line">- (MASConstraint *)leading;</span><br><span class="line">- (MASConstraint *)trailing;</span><br><span class="line">- (MASConstraint *)width;</span><br><span class="line">- (MASConstraint *)height;</span><br><span class="line">- (MASConstraint *)centerX;</span><br><span class="line">- (MASConstraint *)centerY;</span><br><span class="line">- (MASConstraint *)baseline;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)firstBaseline;</span><br><span class="line">- (MASConstraint *)lastBaseline;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)leftMargin;</span><br><span class="line">- (MASConstraint *)rightMargin;</span><br><span class="line">- (MASConstraint *)topMargin;</span><br><span class="line">- (MASConstraint *)bottomMargin;</span><br><span class="line">- (MASConstraint *)leadingMargin;</span><br><span class="line">- (MASConstraint *)trailingMargin;</span><br><span class="line">- (MASConstraint *)centerXWithinMargins;</span><br><span class="line">- (MASConstraint *)centerYWithinMargins;</span><br></pre></td></tr></table></figure></p><p>这些操作方法内部都是通过一个抽象方法实现，须由子类具体实现，该方法为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span> __unused)layoutAttribute</span><br></pre></td></tr></table></figure></p><p><strong>关系操作方法</strong></p><p>关系操作方法根据 <code>NSLayoutRelation</code> 枚举类型创建约束关系项。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> attr))equalTo;</span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> attr))greaterThanOrEqualTo;</span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> attr))lessThanOrEqualTo;</span><br></pre></td></tr></table></figure></p><p>这些操作方法内部都是通过一个抽象方法实现，须由子类具体实现，该方法为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation;</span><br></pre></td></tr></table></figure></p><p><strong>倍数操作方法</strong></p><p>两个倍数操作方法都是抽象方法，须由子类具体实现。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> multiplier))multipliedBy;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> divider))dividedBy;</span><br></pre></td></tr></table></figure></p><p><strong>常量操作方法</strong></p><p>常量操作方法内部各自调用对应的 <code>setter</code> 方法，而这些 <code>setter</code> 方法都是抽象方法，须由子类具体实现。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(MASEdgeInsets insets))insets;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> inset))inset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGSize</span> offset))sizeOffset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGPoint</span> offset))centerOffset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span> offset))offset;</span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">NSValue</span> *value))valueOffset;</span><br></pre></td></tr></table></figure></p><p><strong>优先级操作方法</strong></p><p>后三个优先级操作方法根据 <code>NSLayoutPriority</code> 枚举类型设置约束优先级，其内部都是通过调用第一个优先级操作方法实现的，该方法为抽象方法，须子类具体实现。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(MASLayoutPriority priority))priority;</span><br><span class="line">- (MASConstraint * (^)())priorityLow;</span><br><span class="line">- (MASConstraint * (^)())priorityMedium;</span><br><span class="line">- (MASConstraint * (^)())priorityHigh;</span><br></pre></td></tr></table></figure></p><h4 id="MASViewConstraint"><a href="#MASViewConstraint" class="headerlink" title="MASViewConstraint"></a>MASViewConstraint</h4><p><code>MASViewConstraint</code> 是 <code>MASConstraint</code> 的子类，可以称之为 Masonry 中 <strong>最重要的类</strong>。</p><p><code>MASViewConstraint</code> 除了能够 <strong>完整表示约束方程式</strong> 之外，还存储了约束的 <strong>优先级</strong> 属性。我们来看一下其外部属性和内部属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *firstViewAttribute;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *secondViewAttribute;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Private</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) MASViewAttribute *secondViewAttribute;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MAS_VIEW *installedView;                <span class="comment">// 约束被添加到的位置（视图）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MASLayoutConstraint *layoutConstraint;  <span class="comment">// 约束</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSLayoutRelation</span> layoutRelation;      <span class="comment">// 关系</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) MASLayoutPriority layoutPriority;     <span class="comment">// 优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutMultiplier;             <span class="comment">// 倍数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutConstant;               <span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasLayoutRelation;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> mas_key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> useAnimator;</span><br></pre></td></tr></table></figure></p><p>我们再来看一下 <code>MASViewConstraint</code> 实现的父类抽象方法。</p><p>首先，属性操作方法所调用的一个抽象方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 必须是没有设置过布局关系，即 hasLayoutRelation 为 NO</span></span><br><span class="line">    <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@"Attributes should be chained before defining the constraint relation"</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>MASViewConstraint</code> 其实将该方法的具体实现交给了它的代理。</p><p>其次，关系操作方法所调用的一个抽象方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([attribute isKindOfClass:<span class="built_in">NSArray</span>.class]) &#123;</span><br><span class="line">            <span class="comment">// 必须是没有设置过布局关系，即 hasLayoutRelation 为 NO</span></span><br><span class="line">            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@"Redefinition of constraint relation"</span>);</span><br><span class="line">            <span class="comment">// 如果 attribute 是一组属性，则生成一组约束</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *children = <span class="built_in">NSMutableArray</span>.new;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> attr <span class="keyword">in</span> attribute) &#123;</span><br><span class="line">                MASViewConstraint *viewConstraint = [<span class="keyword">self</span> <span class="keyword">copy</span>];</span><br><span class="line">                viewConstraint.layoutRelation = relation;</span><br><span class="line">                viewConstraint.secondViewAttribute = attr;</span><br><span class="line">                [children addObject:viewConstraint];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将一组约束转换成组合约束，并将代理所持有对应的约束进行替换</span></span><br><span class="line">            MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">            compositeConstraint.delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">            [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">            <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation || <span class="keyword">self</span>.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:<span class="built_in">NSValue</span>.class], <span class="string">@"Redefinition of constraint relation"</span>);</span><br><span class="line">            <span class="comment">// 如果 attribute 是单个属性，则设置约束的第二项</span></span><br><span class="line">            <span class="keyword">self</span>.layoutRelation = relation;</span><br><span class="line">            <span class="keyword">self</span>.secondViewAttribute = attribute;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，针对 <code>attribute</code> 的不同，<code>equalToWithRelation</code> 方法实现了不同的逻辑。</p><p>接着，倍数操作方法所调用的两个抽象方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span>))multipliedBy &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="built_in">CGFloat</span> multiplier) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasBeenInstalled,</span><br><span class="line">                 <span class="string">@"Cannot modify constraint multiplier after it has been installed"</span>);</span><br><span class="line">        <span class="keyword">self</span>.layoutMultiplier = multiplier;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span>))dividedBy &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="built_in">CGFloat</span> divider) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasBeenInstalled,</span><br><span class="line">                 <span class="string">@"Cannot modify constraint multiplier after it has been installed"</span>);</span><br><span class="line">        <span class="keyword">self</span>.layoutMultiplier = <span class="number">1.0</span>/divider;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这两个方法本质上就是修改了 <code>MASViewConstraint</code> 的倍数属性 <code>layoutMultiplier</code>。</p><p>然后，常量操作方法所调用的几个抽象方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有约束方程式第一项的属性是：</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeLeft、NSLayoutAttributeLeading、</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeTop、NSLayoutAttributeBottom、</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeRight、NSLayoutAttributeTrailing </span></span><br><span class="line"><span class="comment">// 时，方法才会有效设置常量属性</span></span><br><span class="line">- (<span class="keyword">void</span>)setInsets:(MASEdgeInsets)insets &#123;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> layoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="keyword">switch</span> (layoutAttribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeLeading</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = insets.left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeTop</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = insets.top;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeBottom</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = -insets.bottom;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeTrailing</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = -insets.right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInsets 的特殊情况</span></span><br><span class="line">- (<span class="keyword">void</span>)setInset:(<span class="built_in">CGFloat</span>)inset &#123;</span><br><span class="line">    [<span class="keyword">self</span> setInsets:(MASEdgeInsets)&#123;.top = inset, .left = inset, .bottom = inset, .right = inset&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接设置常量属性</span></span><br><span class="line">- (<span class="keyword">void</span>)setOffset:(<span class="built_in">CGFloat</span>)offset &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstant = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有约束方程式第一项的属性是：</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeWidth、NSLayoutAttributeHeight</span></span><br><span class="line"><span class="comment">// 时，方法才会有效设置常量属性</span></span><br><span class="line">- (<span class="keyword">void</span>)setSizeOffset:(<span class="built_in">CGSize</span>)sizeOffset &#123;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> layoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="keyword">switch</span> (layoutAttribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeWidth</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = sizeOffset.width;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeHeight</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = sizeOffset.height;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有约束方程式第一项的属性是：</span></span><br><span class="line"><span class="comment">// NSLayoutAttributeCenterX、NSLayoutAttributeCenterY</span></span><br><span class="line"><span class="comment">// 时，方法才会有效设置常量属性</span></span><br><span class="line">- (<span class="keyword">void</span>)setCenterOffset:(<span class="built_in">CGPoint</span>)centerOffset &#123;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> layoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="keyword">switch</span> (layoutAttribute) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeCenterX</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = centerOffset.x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">NSLayoutAttributeCenterY</span>:</span><br><span class="line">            <span class="keyword">self</span>.layoutConstant = centerOffset.y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这些 <code>setter</code> 方法会根据 <code>MASViewConstraint</code> 已有的 <code>firstViewAttribute</code> 约束项的约束属性 <code>layoutAttribuet</code> 的类型来设置常量属性。当属性不匹配值，对常量属性的设置并不会生效。</p><p>最后，优先级操作方法的一个抽象方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(MASLayoutPriority))priority &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(MASLayoutPriority priority) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasBeenInstalled,</span><br><span class="line">                 <span class="string">@"Cannot modify constraint priority after it has been installed"</span>);</span><br><span class="line">        <span class="keyword">self</span>.layoutPriority = priority;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，该方法内部直接设置了 <code>MASViewConstraint</code> 的优先级属性 <code>layoutPriority</code>。</p><h4 id="MASCompositeConstraint"><a href="#MASCompositeConstraint" class="headerlink" title="MASCompositeConstraint"></a>MASCompositeConstraint</h4><p><code>MASCompositeConstraint</code> 也是 <code>MASConstraint</code> 的子类。与 <code>MASViewConstraint</code> 只表示一个约束不同，<code>MASCompositeConstraint</code> 可以表示一组约束。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MASCompositeConstraint</span> () &lt;<span class="title">MASConstraintDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> mas_key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *childConstraints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>其中，<code>childConstraints</code> 属性持有了一组约束。</p><p>我们再来看一下 <code>MASCompositeConstraint</code> 实现的父类抽象方法。</p><p>首先，属性操作方法所调用的一个抽象方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    [<span class="keyword">self</span> constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法调用了 <code>MASCompositeConstraint</code> 所实现的 <code>MASConstraintDelegate</code> 的一个方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;MASConstraintDelegate&gt; strongDelegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">    MASConstraint *newConstraint = [strongDelegate constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">    newConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.childConstraints addObject:newConstraint];</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，该方法内部将通过其代理新创建的普通约束或组合约束添加至 <code>MASCompositeConstraint</code> 的 <code>childConstraints</code> 数组中，并设置子约束的代理为 <code>MASCompositeConstraint</code> 的代理。</p><p>事实上，在 Masonry 中，下文将要提到的 <code>MASConstraintMaker</code> 充当了所有约束的最终代理，如下图所示。<code>MASCompositeConstraint</code> 只是充当了转接和补充的作用。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/relation-of-masconstraintmaker-and-masconstraint.png?x-oss-process=image/resize,w_800" alt=""></p><p>至于关系操作方法、倍数操作方法、常量操作方法、优先级操作方法所调用的抽象方法。<code>MASCompositeConstraint</code> 对此的实现基本相同，都是对 <code>childConstraints</code> 中的约束进行遍历设置。</p><h3 id="MASConstraintMaker"><a href="#MASConstraintMaker" class="headerlink" title="MASConstraintMaker"></a>MASConstraintMaker</h3><p><code>MASConstraintMaker</code> 是 Masonry 的核心。</p><p><code>MASConstraintMaker</code> 指定了构建布局的目标视图以及相关的约束。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MASConstraintMaker</span> () &lt;<span class="title">MASConstraintDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MAS_VIEW *view;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *constraints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>MASConstraintMaker</code> 提供了一系列只读的 <code>MASConstraint</code> 属性。这些属性在其 <code>getter</code> 方法内创建了对应 <code>NSLayoutAttribute</code> 枚举类型的约束项。这些属性包括以下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *firstBaseline;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *lastBaseline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leftMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *rightMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *topMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottomMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leadingMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailingMargin;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerXWithinMargins;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerYWithinMargins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *edges;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *size;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *center;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *(^attributes)(MASAttribute attrs);</span><br></pre></td></tr></table></figure></p><p>上面提到，<code>MASViewConstraint</code> 和 <code>MASCompositeConstraint</code> 都会利用其代理来创建并添加约束项，而它们的代理都是 <code>MASConstraintMaker</code>。那么，我们来看一下 <code>MASConstraintMaker</code> 对于 <code>MASConstraintDelegate</code> 的实现是怎么样的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)constraint:(MASConstraint *)constraint shouldBeReplacedWithConstraint:(MASConstraint *)replacementConstraint &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> index = [<span class="keyword">self</span>.constraints indexOfObject:constraint];</span><br><span class="line">    <span class="built_in">NSAssert</span>(index != <span class="built_in">NSNotFound</span>, <span class="string">@"Could not find constraint %@"</span>, constraint);</span><br><span class="line">    [<span class="keyword">self</span>.constraints replaceObjectAtIndex:index withObject:replacementConstraint];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 根据 约束属性 和 视图 创建一个约束单元</span></span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="comment">//创建约束，以约束单元作为约束的第一项</span></span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">// 如果是在已有约束的基础上再创建的约束，则将它们转换成一个 组合约束，并将原约束替换成该组合约束。</span></span><br><span class="line">        <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        <span class="comment">// 如果不是在已有约束的基础上再创建约束，则添加约束至列表</span></span><br><span class="line">        newConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先看 <code>constraint:shouldBeReplacedWithConstraint:</code> 方法，该方法的职责非常简单，就是在已有的约束中查找某个约束并进行替换。</p><p>我们再看<code>constraint:addConstraintWithLayoutAttribute:</code> 方法，该方法是被调用较多的一个方法，其职责主要就是创建并添加约束至 <code>constraints</code> 列表属性中。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>在了解了 Masonry 的基本组成之后，我们再通过一个示例来介绍一下 Masonry 的工作流程。</p><p>示例如下所示。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[view mas_makeConstraints::^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(@<span class="number">10</span>);</span><br><span class="line">    make.left.equalTo(superview.mas_left).offset(<span class="number">10</span>);</span><br><span class="line">    make.width.height.equalTo(@<span class="number">100</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p><p>首先执行分类方法 <code>mas_makeConstraints:</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法内部先设置 <code>translatesAutoresizingMaskIntoConstraints</code> 为 <code>NO</code>。因为，Autoresize Mask 和 Auto Layout 是两套布局系统，前者默认可以转换成后者。为了避免前者对自动布局系统产生干扰，这里需要关闭布局转换。</p><p>方法内部还会创建一个 <code>MASConstraintMaker</code> 实例，然后以此为参数调用 block 执行。</p><p><code>constraintMaker</code> 创建完约束后，在调用 <code>install</code> 方法将约束添加至正确的约束层级位置。<code>install</code> 方法的内部实现如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line">    <span class="comment">// 只有在 mas_remakeConstraints 时，removeExisting 才为 YES</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line">        <span class="comment">// 此时，需要先删除所有的约束</span></span><br><span class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加约束</span></span><br><span class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line">        <span class="comment">// 设置约束的 updateExisting 属性</span></span><br><span class="line">        <span class="comment">// 只有在 mas_updateConstraints 时，updateExisting 才为 YES</span></span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空 constraints 数组缓存</span></span><br><span class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>install</code> 方法内部会对 <code>constraints</code> 列表中的所有约束依次执行各自的 <code>install</code> 方法来添加约束。我们来看一下约束的 <code>install</code> 方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MASCompositeConstraint</span></span><br><span class="line">- (<span class="keyword">void</span>)install &#123;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> <span class="keyword">self</span>.childConstraints) &#123;</span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (<span class="keyword">void</span>)install &#123;</span><br><span class="line">    <span class="comment">// 约束是否已被添加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hasBeenInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果约束支持 isActive 方法，且 self.layoutConstraint 有值了</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> supportsActiveProperty] &amp;&amp; <span class="keyword">self</span>.layoutConstraint) &#123;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint.active = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span>.firstViewAttribute.view.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MAS_VIEW *firstLayoutItem = <span class="keyword">self</span>.firstViewAttribute.item;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> firstLayoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    MAS_VIEW *secondLayoutItem = <span class="keyword">self</span>.secondViewAttribute.item;</span><br><span class="line">    <span class="built_in">NSLayoutAttribute</span> secondLayoutAttribute = <span class="keyword">self</span>.secondViewAttribute.layoutAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alignment attributes must have a secondViewAttribute</span></span><br><span class="line">    <span class="comment">// therefore we assume that is refering to superview</span></span><br><span class="line">    <span class="comment">// eg make.left.equalTo(@10)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute &amp;&amp; !<span class="keyword">self</span>.secondViewAttribute) &#123;</span><br><span class="line">        secondLayoutItem = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">        secondLayoutAttribute = firstLayoutAttribute;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成一个 NSLayoutConstraint</span></span><br><span class="line">    MASLayoutConstraint *layoutConstraint</span><br><span class="line">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line">                                         constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line">    layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</span><br><span class="line">    layoutConstraint.mas_key = <span class="keyword">self</span>.mas_key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定约束layoutConstraint 的约束层级（即要被添加到的位置）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line">        MAS_VIEW *closestCommonSuperview = [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line">        <span class="built_in">NSAssert</span>(closestCommonSuperview,</span><br><span class="line">                 <span class="string">@"couldn't find a common superview for %@ and %@"</span>,</span><br><span class="line">                 <span class="keyword">self</span>.firstViewAttribute.view, <span class="keyword">self</span>.secondViewAttribute.view);</span><br><span class="line">        <span class="keyword">self</span>.installedView = closestCommonSuperview;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</span><br><span class="line">        existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existingConstraint) &#123;</span><br><span class="line">        <span class="comment">// just update the constant</span></span><br><span class="line">        <span class="comment">// 约束存在，则更新constant值</span></span><br><span class="line">        existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint = existingConstraint;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 约束不存在，则在该位置添加约束</span></span><br><span class="line">        [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</span><br><span class="line">        [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>无论是 <code>MASCompositeConstraint</code> 还是 <code>MASViewConstraint</code>，本质上还是调用 <code>MASViewConstraint</code> 的 <code>install</code> 方法。该方法根据 <code>MASViewConstraint</code> 的各个属性创建一个原生的约束（<code>NSLayoutConstraint</code> 类型），并在定位约束层级后，将约束添加到相应层级的视图上。</p><p>下面，我们再来看看执行 block 又发生了什么。</p><p>首先，看一下 <code>make.top.equalTo(@10);</code> 的执行流程。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MASConstraintMaker</span></span><br><span class="line">- (MASConstraint *)top &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeTop</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> constraint:<span class="literal">nil</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 根据 约束属性 和 视图 创建一个约束单元</span></span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="comment">//创建约束，以约束单元作为约束的第一项</span></span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        <span class="comment">// 如果不是在已有约束的基础上再创建约束，则添加约束至列表</span></span><br><span class="line">        newConstraint.delegate = <span class="keyword">self</span>;      <span class="comment">// 注意这一步，会对 make.top.left 这种情形产生关键影响，详见下文</span></span><br><span class="line">        [<span class="keyword">self</span>.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.top 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>))equalTo &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute) &#123;</span><br><span class="line">        <span class="comment">// attribute 可能是 @0 类似的值，也可能是 view.mas_width等这样的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([attribute isKindOfClass:<span class="built_in">NSArray</span>.class]) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation || <span class="keyword">self</span>.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:<span class="built_in">NSValue</span>.class], <span class="string">@"Redefinition of constraint relation"</span>);</span><br><span class="line">            <span class="keyword">self</span>.layoutRelation = relation;</span><br><span class="line">            <span class="keyword">self</span>.secondViewAttribute = attribute;   <span class="comment">// 设置约束第二项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSecondViewAttribute:(<span class="keyword">id</span>)secondViewAttribute &#123;</span><br><span class="line">    <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:<span class="built_in">NSValue</span>.class]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setLayoutConstantWithValue:secondViewAttribute];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        <span class="comment">// _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        <span class="comment">// _secondViewAttribute = secondViewAttribute;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NSAssert(NO, @"attempting to add unsupported attribute: %@", secondViewAttribute);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (<span class="keyword">void</span>)setLayoutConstantWithValue:(<span class="built_in">NSValue</span> *)value &#123;</span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:<span class="built_in">NSNumber</span>.class]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.offset = [(<span class="built_in">NSNumber</span> *)value doubleValue];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(value.objCType, <span class="keyword">@encode</span>(<span class="built_in">CGPoint</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CGPoint point;</span></span><br><span class="line">        <span class="comment">// [value getValue:&amp;point];</span></span><br><span class="line">        <span class="comment">// self.centerOffset = point;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(value.objCType, <span class="keyword">@encode</span>(<span class="built_in">CGSize</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// CGSize size;</span></span><br><span class="line">        <span class="comment">// [value getValue:&amp;size];</span></span><br><span class="line">        <span class="comment">// self.sizeOffset = size;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(value.objCType, <span class="keyword">@encode</span>(MASEdgeInsets)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// MASEdgeInsets insets;</span></span><br><span class="line">        <span class="comment">// [value getValue:&amp;insets];</span></span><br><span class="line">        <span class="comment">// self.insets = insets;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NSAssert(NO, @"attempting to set layout constant with unsupported value: %@", value);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (<span class="keyword">void</span>)setOffset:(<span class="built_in">CGFloat</span>)offset &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstant = offset;       <span class="comment">// 设置约束常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.top.equalTo(@10) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>然后，我们再看 <code>make.left.equalTo(superview.mas_left).offset(10);</code> 的执行流程。<br>其实，这个执行流程也就是执行 <code>equalTo</code> 内部的 <code>setSecondViewAttribute</code> 时有所不同。另外，<code>offset</code> 方法做了一步额外的操作。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (<span class="keyword">void</span>)setSecondViewAttribute:(<span class="keyword">id</span>)secondViewAttribute &#123;</span><br><span class="line">    <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:<span class="built_in">NSValue</span>.class]) &#123;</span><br><span class="line">        <span class="comment">// [self setLayoutConstantWithValue:secondViewAttribute];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        <span class="comment">// _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        _secondViewAttribute = secondViewAttribute;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// NSAssert(NO, @"attempting to add unsupported attribute: %@", secondViewAttribute);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.left.equalTo(superview.mas_left) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="built_in">CGFloat</span>))offset &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="built_in">CGFloat</span> offset)&#123;</span><br><span class="line">        <span class="keyword">self</span>.offset = offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setOffset:(<span class="built_in">CGFloat</span>)offset &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstant = offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.left.equalTo(superview.mas_left).offset(10) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></p><p>最后，我们再看 <code>make.width.height.equalTo(@100);</code> 的执行流程。<br>其实到 <code>make.width</code> 这一步与前面没有什么差别，再执行 <code>height</code> 时出现了转换。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint *)height &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeHeight</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASViewConstraint</span></span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@"Attributes should be chained before defining the constraint relation"</span>);</span><br><span class="line">    <span class="comment">// 见上述 make.top.equalTo(@10) 分析代码中的介绍，此时 self.delegate 早已被设置成了 NSConstraintMaker 了</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraintMaker</span></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    <span class="comment">// 根据 约束属性 和 视图 创建一个约束单元</span></span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    <span class="comment">// 创建约束，以约束单元作为约束的第一项</span></span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">// 如果是在已有约束的基础上再创建的约束，则将它们转换成一个 组合约束，并将原约束替换成该组合约束。</span></span><br><span class="line">        <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">// 这里会将原来 make.width 添加的约束 替换成一个 组合约束（宽度约束 + 高度约束）</span></span><br><span class="line">        [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        <span class="comment">// 返回组合约束</span></span><br><span class="line">        <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)constraint:(MASConstraint *)constraint shouldBeReplacedWithConstraint:(MASConstraint *)replacementConstraint &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> index = [<span class="keyword">self</span>.constraints indexOfObject:constraint];</span><br><span class="line">    <span class="built_in">NSAssert</span>(index != <span class="built_in">NSNotFound</span>, <span class="string">@"Could not find constraint %@"</span>, constraint);</span><br><span class="line">    [<span class="keyword">self</span>.constraints replaceObjectAtIndex:index withObject:replacementConstraint];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.width.height 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MASConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>))equalTo &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute) &#123;</span><br><span class="line">        <span class="comment">// attribute 可能是 @0 类似的值，也可能是 view.mas_width等这样的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MASCompositeConstraint</span></span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attr, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="comment">// CompositeConstraint 的 childConstraits 中每一项，调用 equalToWithRelation</span></span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> <span class="keyword">self</span>.childConstraints.copy) &#123;</span><br><span class="line">            constraint.equalToWithRelation(attr, relation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 至此，make.width.height.equalTo(@100) 执行完毕</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Masonry 巧妙利用了面向对象的继承、多态思想以及 block 的特性，从而实现了非常简便的链式 DSL，极大地提升了自动布局开发的效率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Masonry-概述&quot;&gt;&lt;a href=&quot;#Masonry-概述&quot; class=&quot;headerlink&quot; title=&quot;Masonry 概述&quot;&gt;&lt;/a&gt;Masonry 概述&lt;/h1&gt;&lt;p&gt;Masonry 是基于 Apple 的自动布局封装的一个轻量级布局框架。Ma
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Masonry" scheme="http://chuquan.me/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>系统理解 iOS 自动布局</title>
    <link href="http://chuquan.me/2019/09/25/systematic-understand-ios-autolayout/"/>
    <id>http://chuquan.me/2019/09/25/systematic-understand-ios-autolayout/</id>
    <published>2019-09-25T15:01:21.000Z</published>
    <updated>2019-09-25T15:09:13.628Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备阅读 Masonry 的源代码，学习一下其中的设计思想。然而，阅读了一部分之后，发现自己对 iOS 自动布局了解的不够系统，也不够深入。于是，准备好好学习学习 iOS 自动布局的基础知识。</p><p>下面是我对 iOS 布局系统的一些整理和总结，当然，自动布局是其中的重点。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>苹果在 iPhone 4 时推出了绝对布局，随着 iOS 设备不断增多，苹果在 iOS 6 时又推出了自动布局（Auto Layout）。在自动布局逐步完善的过程中，苹果也推出了诸如：Size Class、Stack View、UILayoutGuide 等技术，但是它们的本质都是基于自动布局。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>1997 年，Alan Boring，Kim Marriott，Peter Stuckey 等人在它们发表的论文《Solving Linear Arithmetic Constraints for User Interface Applications》中提出了解决布局问题的 <strong>Cassowary constraints-solving</strong> 算法实现。</p><p>2011 年，苹果将 Cassowary 算法应用到了自家的布局引擎 Auto Layout 中。</p><p><strong>Cassorwary</strong></p><blockquote><p>Cassowary 能够有效解析 <strong>线性等式系统</strong> 和 <strong>线性不等式系统</strong>，用来表示用户界面的相等关系和不等关系。基于此，Cassowary 开发了一种规则系统，可以通过 <strong>约束</strong> 来描述视图之间的关系。约束就是规则，能够表示出一个视图相对于另一个视图的位置。</p></blockquote><p>由于 Cassowary 算法的先进性，很多编程语言都实现了对应的库，如：JavaScript、.NET、Java、SmallTalk、C++。</p><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>Cassowary 的核心是基于 <strong>约束（Constraint）</strong> 来描述视图之间的关系。约束本质上就是一个方程式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.attribute1 = multiplier × item2.attribute2 + constant</span><br></pre></td></tr></table></figure><p>下面我们通过一个简单的约束来介绍约束方程式。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/view-formula.png?x-oss-process=image/resize,w_600" alt=""></p><p>该约束表示红色视图的左边界在蓝色视图的右边界再往右 8 个像素点。<strong>注意，这里的 <code>=</code> 并不是赋值的意思，而是相等的意思</strong>。</p><p>在自动布局系统中，约束不仅可以定义两个视图之间的关系，还可以定义单个视图的两个不同属性之间的关系，如：在视图的高度和宽度之间设置比例。<strong>一般而言，一个视图需要四个约束来决定其大小和位置</strong>。</p><h2 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h2><p>上述约束方程式主要描述了两个视图属性之间的关系。那么，我们来看一下 iOS 定义了哪些属性和关系。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>苹果使用 <code>NSLayoutAttribute</code> 类型的枚举值来表示布局属性，其主要包含以下这些属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutAttribute</span>) &#123;</span><br><span class="line">    <span class="comment">// 视图位置</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeft</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeRight</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTop</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeBottom</span>,</span><br><span class="line">    <span class="comment">// 视图前后</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeading</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTrailing</span>,</span><br><span class="line">    <span class="comment">// 视图宽高</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeWidth</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeHeight</span>,</span><br><span class="line">    <span class="comment">// 视图中心</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterX</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterY</span>,</span><br><span class="line">    <span class="comment">// 视图基线</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeLastBaseline</span>,</span><br><span class="line">    <span class="built_in">NSLayoutAttributeFirstBaseline</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    <span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 占位符，在与另一个约束的关系中没有用到某个属性时可以使用占位符</span></span><br><span class="line">    <span class="built_in">NSLayoutAttributeNotAnAttribute</span> = <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>值得注意的是，<code>NSLayoutAttribute</code> 有类似 <code>NSLayoutAttributeLeft</code> 和 <code>NSLayoutAttributeLeftMargin</code> 这样的枚举。两者的区别是：</p><ul><li><code>NSLayoutAttributeLeft</code> 表示视图的最左边；</li><li><code>NSLayoutAttributeLeftMargin</code> 表示视图的左边，距离最左边有多大的 margin 与视图的 <code>layoutMargins</code> 有关。</li></ul><p>关于 <code>layoutMargins</code> 我们会在下文提到。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/layout-attributes.png?x-oss-process=image/resize,w_600" alt=""></p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>苹果使用 <code>NSLayoutRelation</code> 类型的枚举值来表示属性关系，其主要包含以下这些关系：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutRelation</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLayoutRelationLessThanOrEqual</span> = <span class="number">-1</span>,</span><br><span class="line">    <span class="built_in">NSLayoutRelationEqual</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSLayoutRelationGreaterThanOrEqual</span> = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="约束层级"><a href="#约束层级" class="headerlink" title="约束层级"></a>约束层级</h2><p>约束描述两个视图之间的关系，但是前提是：两个视图必须属于同一个视图层级结构。<br>这种层级结构有两种：</p><ol><li>一个视图是另一个视图的视图</li><li>两个视图在一个窗口下有一个非 <code>nil</code> 的公共祖先视图。</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/constraints-hiecharcy.png?x-oss-process=image/resize,w_800" alt=""></p><h2 id="约束优先级"><a href="#约束优先级" class="headerlink" title="约束优先级"></a>约束优先级</h2><p>约束具有优先级。当布局引擎计算布局时，会按照优先级从高到低的顺序逐个计算。如果发现一个可选的约束无法被满足时，就会跳过这个约束，计算下一个约束。有时候，即使一个约束无法被正好适配，它依然可以影响布局。</p><p>苹果默认定义了 4 种优先级枚举值。除此之外，苹果允许创建其他的优先级，但是其范围必须在 1~1000 之间。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityRequired</span> = <span class="number">1000</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityDefaultHigh</span> = <span class="number">750</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityDefaultLow</span> = <span class="number">250</span>; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">UILayoutPriority</span> <span class="built_in">UILayoutPriorityFittingSizeLevel</span> = <span class="number">50</span>;</span><br></pre></td></tr></table></figure></p><h1 id="约束创建"><a href="#约束创建" class="headerlink" title="约束创建"></a>约束创建</h1><p>关于约束的创建，苹果提供了 Interface Build，可以实现以非编程的方式创建约束。但是在大型项目中，我们主要还是以编程的方式创建约束。</p><p>以编程方式创建约束的方式主要有三种：</p><ul><li><strong>约束构造器（NSLayoutConstraint）</strong></li><li><strong>布局锚点（Layout Anchors）</strong></li><li><strong>可视化格式语言（Visual Format Language, VFL）</strong></li></ul><p>下面我们依次进行介绍。</p><h2 id="NSLayoutConstraint"><a href="#NSLayoutConstraint" class="headerlink" title="NSLayoutConstraint"></a>NSLayoutConstraint</h2><p>苹果使用 <code>NSLayoutConstraint</code> 类型表示约束。<code>NSLayoutConstraint</code> 类提供了一个构造方法可以直接创建约束。构造方法的各个参数对应着约束方程式的各个项。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)constraintWithItem:(<span class="keyword">id</span>)view1 </span><br><span class="line">                         attribute:(<span class="built_in">NSLayoutAttribute</span>)attr1 </span><br><span class="line">                         relatedBy:(<span class="built_in">NSLayoutRelation</span>)relation </span><br><span class="line">                            toItem:(<span class="keyword">id</span>)view2 </span><br><span class="line">                         attribute:(<span class="built_in">NSLayoutAttribute</span>)attr2 </span><br><span class="line">                        multiplier:(<span class="built_in">CGFloat</span>)multiplier </span><br><span class="line">                          constant:(<span class="built_in">CGFloat</span>)c;</span><br></pre></td></tr></table></figure></p><h2 id="Layout-Anchors"><a href="#Layout-Anchors" class="headerlink" title="Layout Anchors"></a>Layout Anchors</h2><p>苹果使用 <code>NSLayoutAnchor</code> 类型表示布局锚点。在介绍 <code>NSLayoutAnchor</code> 之前，我们需要介绍一些其他的概念，如：<code>UILayoutGuide</code>（使用 <code>NSLayoutAnchor</code> 时会用到）。</p><h3 id="UILayoutGuide"><a href="#UILayoutGuide" class="headerlink" title="UILayoutGuide"></a>UILayoutGuide</h3><p><code>UILayoutGuide</code> 是一个虚拟的矩形区域，可以认为是一个透明的 <code>UIView</code>，但是它不会被添加到视图层级，也不会拦截消息调用，它只是用来与 Auto Layout 交互。比如：3 个 <code>UIView</code> 排一行，相互之间的间隔相同。那么中间的间隔就可以用 <code>UILayoutGuide</code> 代替。</p><p>在了解 <code>UILayoutGuide</code> 之后，我们需要了解 <code>UIView</code> 的两个属性（<code>UILayoutGuide</code> 类型的实例）：</p><ul><li><code>layoutMarginsGuide</code>：首次出现于 iOS 9</li><li><code>safeAreaLayoutGuide</code>：首次出现于 iOS 11</li></ul><h4 id="layoutMarginsGuide"><a href="#layoutMarginsGuide" class="headerlink" title="layoutMarginsGuide"></a>layoutMarginsGuide</h4><p><code>UIView</code> 有一个 <code>UIEdgeInsets</code> 类型的属性 <code>layoutMargins</code>，它表示一个视图的内容和它四个边界之间的空隙，如下图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/layout-margins-guide.png?x-oss-process=image/resize,w_600" alt=""></p><p><code>UIView</code> 的 <code>layoutMarginsGuide</code> 属性其实是 <code>layoutMargins</code> 的另一种表现形式，可用于创建布局约束。<code>layoutMarginsGuide</code> 是一个 <strong>只读</strong> 属性。</p><h4 id="safeAreaLayoutGuide"><a href="#safeAreaLayoutGuide" class="headerlink" title="safeAreaLayoutGuide"></a>safeAreaLayoutGuide</h4><p>在 iOS 11 时，苹果提出了 Safe Area 的概念。因为 iOS 11 搭载的 iPhone X 取消了 Home 键，要为操作保留一些空间，这正好把原来的 Navigation Bar, Status Bar, Tab Bar 包含在里面。<code>safeAreaLayoutGuide</code> 属性正是伴随 Safe Area 出现的。</p><p><code>safeAreaLayoutGuide</code> 属性和 <code>layoutMarginsGuide</code> 一样，也是 <strong>只读</strong> 属性，因为它们默认都已经设定了一个虚拟区域，我们可以直接基于此区域设置约束。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/safearea-layout-guide.png?x-oss-process=image/resize,w_600" alt=""></p><h3 id="NSLayoutAnchor"><a href="#NSLayoutAnchor" class="headerlink" title="NSLayoutAnchor"></a>NSLayoutAnchor</h3><p>在初步了解 <code>UILayoutGuide</code> 之后，我们再来看它所包含的成员。可以发现，<code>UILayoutGuide</code> 内部定义了一系列 <code>NSLayoutAnchor</code> 类型的成员。</p><p>事实上，<code>NSLayoutAnchor</code> 类可以通过一系列 API，创建 <code>NSLayoutConstraint</code> 类型的约束对象，来进行布局约束的设置，而不用 <strong>直接</strong> 和 <code>NSLayoutConstraint</code> 对象打交道。</p><p>通常，我们不会直接使用 <code>NSLayoutAnchor</code>，而是使用它的三个子类，如下：</p><ul><li><code>NSLayoutXAxisAnchor</code>：X 轴方向的锚点，用来创建水平方向的约束</li><li><code>NSLayoutYAxisAnchor</code>：Y 轴方向的锚点，用来创建垂直方向的约束</li><li><code>NSLayoutDimension</code>：尺寸相关的锚点，用来创建尺寸相关的约束</li></ul><p><code>UILayoutGuide</code> 的诸多锚点属性可以归纳为上述三种子类中的一种。</p><table><thead><tr><th style="text-align:center">X 轴方向的锚点属性</th><th style="text-align:center">Y 轴方向的锚点属性</th><th style="text-align:center">尺寸相关的锚点属性</th></tr></thead><tbody><tr><td style="text-align:center"><code>centerXAnchor</code></td><td style="text-align:center"><code>centerYAnchor</code></td><td style="text-align:center"><code>widthAnchor</code></td></tr><tr><td style="text-align:center"><code>leftAnchor</code></td><td style="text-align:center"><code>topAnchor</code></td><td style="text-align:center"><code>heightAnchor</code></td></tr><tr><td style="text-align:center"><code>rightAnchor</code></td><td style="text-align:center"><code>bottomAnchor</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>leadingAnchor</code></td><td style="text-align:center"><code>firstBaselineAnchor</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>trailingAnchor</code></td><td style="text-align:center"><code>lasBaselineAnchor</code></td></tr></tbody></table><blockquote><p><strong>注意</strong>：<br><code>leadingAnchor</code> 和 <code>leftAnchor</code>、<code>trailingAnchor</code> 和 <code>rightAnchor</code> 在大多数情况下效果是一样的，但还是存在本质区别：<code>leadingAnchor</code> 表示视图最前面的边界锚点，如果在英文等阅读顺序从左向右的国家，leading 就表示 left，但在阿拉伯语等阅读顺序从右向左的国家，leading 就表示 right。</p></blockquote><p>一个视图那么多的锚点属性（X 轴，Y 轴，尺寸）能够和另外一个视图对应的位置锚点和尺寸锚点交互，从而确定视图的位置和尺寸。视图之间的锚点关系可以通过 API 调用来创建约束。<strong>前提是：只有相同子类的锚点属性之间才能交互</strong>。即：</p><ul><li>X 轴方向的锚点属性只能与 X 轴方向的锚点属性交互；</li><li>Y 轴方向的锚点属性只能与 Y 轴方向的锚点属性交互；</li><li>尺寸锚点属性只能与尺寸锚点属性交互。</li></ul><p>下面我们对比一下两种创建约束的方式：</p><ol><li>使用 <code>NSLayoutConstraint</code> 直接创建约束</li><li>使用 <code>NSLayoutAnchor</code> 间接创建约束</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.Creating constraints using NSLayoutConstraint</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .leading,</span><br><span class="line">                   relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .leadingMargin,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .trailing,</span><br><span class="line">                   relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .trailingMargin,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Creating the same constraints using Layout Anchors</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br><span class="line"></span><br><span class="line">subview.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line">subview.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如下所示为 <code>NSLayoutAnchor</code> 提供的一些间接创建约束的方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 NSLayoutAnchor 的共有 API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutAnchor&lt;AnchorType&gt;)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutAnchor&lt;AnchorType&gt;, constant <span class="built_in">c</span>: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutXAxisAnchor 的 API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalToSystemSpacingAfter anchor: NSLayoutXAxisAnchor, multiplier: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anchorWithOffset</span><span class="params">(to otherAnchor: NSLayoutXAxisAnchor)</span></span> -&gt; <span class="type">NSLayoutDimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutYAxisAnchor 的 API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalToSystemSpacingBelow anchor: NSLayoutYAxisAnchor, multiplier: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anchorWithOffset</span><span class="params">(to otherAnchor: NSLayoutYAxisAnchor)</span></span> -&gt; <span class="type">NSLayoutDimension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutDimension 的 API</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutDimension, multiplier m: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutDimension, multiplier m: CGFloat, constant <span class="built_in">c</span>: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalToConstant <span class="built_in">c</span>: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><h2 id="VFL"><a href="#VFL" class="headerlink" title="VFL"></a>VFL</h2><p>VFL（Visual Format Language）是苹果推出的为了简化 Auto Layout 编码的 DSL（Domain-Specific Language）。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><table><thead><tr><th style="text-align:center">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">标准间隔</td><td style="text-align:center"><code>[button]-[textField]</code></td></tr><tr><td style="text-align:center">宽度约束</td><td style="text-align:center"><code>[button(&gt;=50)]</code></td></tr><tr><td style="text-align:center">与父视图的关系</td><td style="text-align:center"><code>丨-50-[purpleBox]-50-丨</code></td></tr><tr><td style="text-align:center">垂直布局</td><td style="text-align:center"><code>V:[topField]-10-[bottomField]</code></td></tr><tr><td style="text-align:center">Flush Views</td><td style="text-align:center"><code>[maroonView][blueView]</code></td></tr><tr><td style="text-align:center">优先级</td><td style="text-align:center"><code>[button(100@20)]</code></td></tr><tr><td style="text-align:center">宽度相等</td><td style="text-align:center"><code>[button(==button2)]</code></td></tr><tr><td style="text-align:center">Multiple Predicates</td><td style="text-align:center"><code>[flexibleButton(&gt;=70,&lt;=100)]</code></td></tr></tbody></table><p>注意，创建 VFL 语句描述时需要注意以下几点：</p><ul><li><code>H:</code> 和 <code>V:</code> 每次只能使用一个</li><li>视图变量名出现在方括号中，如：<code>[blueView]</code></li><li>语句的顺序：从上到下，从左到右</li><li>视图间隔以数字常量出现，如：<code>-10-</code></li><li><code>|</code> 表示父视图</li></ul><p><code>NSLayoutConstraint</code> 类提供了相关的 API 允许通过 VFL 语句创建约束。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSLayoutConstraint</span> *&gt; *)constraintsWithVisualFormat:(<span class="built_in">NSString</span> *)format </span><br><span class="line">                                                       options:(<span class="built_in">NSLayoutFormatOptions</span>)opts </span><br><span class="line">                                                       metrics:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)metrics </span><br><span class="line">                                                         views:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)views;</span><br></pre></td></tr></table></figure></p><p>其中，<code>format</code> 表示 VFL 语句；<code>options</code> 表示约束类型；<code>metrics</code> 表示 VFL 语句中用到的具体数值；<code>views</code> 表示 VFL 语句中用到的控件。</p><p>下面，我们来看一个使用 VFL 创建约束的例子。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *left = @<span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *top = @<span class="number">50</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *width = @<span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *height = @<span class="number">100</span>;</span><br><span class="line"><span class="built_in">NSDictionary</span> *views = <span class="built_in">NSDictionaryOfVariableBindings</span>(view1, view2);</span><br><span class="line"><span class="built_in">NSDictionary</span> *metrics = <span class="built_in">NSDictionaryOfVariableBindings</span>(left, top, width, height);</span><br><span class="line">[view1 addConstraints:[<span class="built_in">NSLayoutConstraint</span> constraintsWithVisualFormat:<span class="string">@"H:|-left-[view(&gt;=width)]"</span> options:<span class="number">0</span> metrics:metrics views:views]];</span><br></pre></td></tr></table></figure></p><h1 id="布局因素"><a href="#布局因素" class="headerlink" title="布局因素"></a>布局因素</h1><p>布局的构建主要由 <strong>布局引擎</strong>（Layout Engine）完成。毫无疑问，视图是构建布局的作用对象。约束作为自动布局的核心，是构建布局的重要依据。除此之外，布局引擎在构建布局时还会参考以下这些因素：</p><ul><li>约束优先级（Constraint Priorities）</li><li><strong>内容优先级</strong>（Content Priorities）</li><li><strong>固有内容尺寸</strong>（Intrinsic Content Size）</li><li><strong>尺寸约束</strong>（Sizing Constraints）</li><li>水平对齐（Horizontal Alignment）</li><li>垂直对齐（Vertical Alignment）</li><li>基线对齐（Baseline Alignment）</li><li>对齐矩形（Alignment Rect）</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/building-the-layout.png?x-oss-process=image/resize,w_800" alt=""></p><h2 id="尺寸约束"><a href="#尺寸约束" class="headerlink" title="尺寸约束"></a>尺寸约束</h2><p>事实上，在上文 <strong>约束创建</strong> 中创建的约束就已经包含了尺寸约束。这里的再次提到尺寸约束，主要是针对 Self-Sizing 的视图。</p><p>比如，我们可以通过自动布局自动计算 TableView 的 Cell 高度。不过，默认情况下未启用该功能。</p><p>默认情况下，TabelView 的 Cell 高度由协议声明的 <code>tableView:heightForRowAtIndexPath:</code> 方法确定。除此之外，我们可以通过对 TabeView 的两个属性赋值，从而启用 Self-Sizing 功能，如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.estimatedRowHeight = <span class="number">85.0</span></span><br><span class="line">tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span></span><br></pre></td></tr></table></figure></p><p>接下来，我们需要在 TableView 的 Cell 的 <code>contentView</code> 中进行布局。为了能让布局引擎自动计算出 Cell 的高度，我们必须对 <code>contentView</code> 的子视图在垂直方向上定义一系列完善的约束，尤其是高度约束。在布局引擎计算高度过程中，它会优先使用尺寸约束，其次它会使用固有内容尺寸。</p><h2 id="固有内容尺寸-amp-内容优先级"><a href="#固有内容尺寸-amp-内容优先级" class="headerlink" title="固有内容尺寸 &amp; 内容优先级"></a>固有内容尺寸 &amp; 内容优先级</h2><p>iOS 中有部分视图具有固有内容尺寸（intrinsic content size），固有内容尺寸就是视图内容和边距所占据的尺寸。比如，<code>UIButton</code> 的固有内容尺寸等于 Title 的尺寸加上内容边距（margin）。</p><p>具有固有内容尺寸的视图有以下这些：</p><table><thead><tr><th style="text-align:center">View</th><th style="text-align:center">Intrinsic Content Size</th></tr></thead><tbody><tr><td style="text-align:center">Sliders</td><td style="text-align:center">Defines only the width (iOS).Defines the width, the height, or both—depending on the slider’s type (OS X).</td></tr><tr><td style="text-align:center">Labels, buttons, switches, and text fields</td><td style="text-align:center">Defines both the height and the width.</td></tr><tr><td style="text-align:center">Text views and image views</td><td style="text-align:center">Intrinsic content size can vary.</td></tr></tbody></table><p>固有内容尺寸的大小受很多因素的影响。以 <code>UITextView</code> 为例，其固有内容尺寸的大小取决内容、是否启用了滚动、以及应用于 <code>UITextView</code> 的其他约束。如果可以滚动，则没有固有内容尺寸，如果不可滚动，则取决于所有文字的尺寸。</p><p>固有内容尺寸的大小还受内容优先级的影响，内容优先级有以下两个方面：</p><ul><li><strong><code>Content Hugging Priority</code></strong></li><li><strong><code>Content Compression Resistance Priority</code></strong></li></ul><p><code>Content Hugging Priority</code>：表示一个视图抗拉伸的优先级，数值越高优先级越高，越不容易被拉伸。</p><p><code>Content Compressing Priority</code>：表示一个视图抗压缩的优先级，数值越高优先级越高，越不容易被压缩。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/intrinsic_content_size.png?x-oss-process=image/resize,w_600" alt=""></p><p>默认情况下，视图的 <code>Content Hugging Priority</code> 值是 <code>250</code>，<code>Content Compression Resistance Priority</code> 值是 <code>750</code>。因此，拉伸视图比压缩视图更容易。</p><h3 id="Intrinsic-Content-Size-与-Fitting-Size-的关系"><a href="#Intrinsic-Content-Size-与-Fitting-Size-的关系" class="headerlink" title="Intrinsic Content Size 与 Fitting Size 的关系"></a>Intrinsic Content Size 与 Fitting Size 的关系</h3><p>Intrinsic Content Size 是布局引擎的输入，基于此可以生成约束，并最终生成布局； Fitting Size 则相反，它是布局引擎的输出，是基于约束生成的布局结果。</p><h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><p>对齐方式有三种类型：</p><ul><li>水平对齐</li><li>垂直对齐</li><li>基线对齐</li></ul><p>对于前两者，通过前文的描述我们也算是有所了解了。水平对齐，用于在 X 轴上产生约束；垂直对齐，用于在 Y 轴上产生约束。</p><p>基线对齐则是文本专有的一种专有的对齐方式。基线对齐包括 <code>firstBaseline</code> 和 <code>lastBaseline</code> 两种对齐方式。如下所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/aligning-baseline.png?x-oss-process=image/resize,w_800" alt=""></p><h2 id="对齐矩形"><a href="#对齐矩形" class="headerlink" title="对齐矩形"></a>对齐矩形</h2><p>在自动布局中，我们可能会认为约束是使用 <code>frame</code> 来确定视图的大小和位置的，但实际上，它使用的是 <strong>对齐矩形</strong>（alignment rect）。在大多数情况下，<code>frame</code> 和 <code>alignment rect</code> 是相等的，所以我们这么理解也没什么不对。</p><p>那么为什么是使用 <code>alignment rect</code>，而不是 <code>frame</code> 呢？</p><p>有时候，我们在创建复杂视图时，可能会添加各种装饰元素，如：阴影，角标等。为了降低开发成本，我们会直接使用设计师给的切图。如下所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/alignment-rect.png?x-oss-process=image/resize,w_800" alt=""></p><p>其中，(a) 是设计师给的切图，(c) 是这个图的 <code>frame</code>。显然，我们在布局时，不想将阴影和角标考虑进入（视图的 <code>center</code> 和底边、右边都发生了偏移），而只考虑中间的核心部分，如图 (b) 中框出的矩形所示。</p><p>对齐矩形就是用来处理这种情况的。<code>UIView</code> 提供了方法可以实现从 <code>frame</code> 得到 <code>alignment rect</code> 以及从 <code>alignment rect</code> 得到 <code>frame</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The alignment rectangle for the specified frame.</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)alignmentRectForFrame:(<span class="built_in">CGRect</span>)frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The frame for the specified alignment rectangle.</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)frameForAlignmentRect:(<span class="built_in">CGRect</span>)alignmentRect;</span><br></pre></td></tr></table></figure></p><p>此外，系统还提供了一个简便方法，有 <code>UIEdgeInsets</code> 指定 <code>frame</code> 和 <code>alignment rect</code> 的关系。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The insets from the view’s frame that define its alignment rectangle.</span></span><br><span class="line">- (<span class="built_in">UIEdgeInsets</span>)alignmentRectInsets;</span><br></pre></td></tr></table></figure></p><p>如果希望 <code>alignment rect</code> 比 <code>frame</code> 的下边多 <code>10</code> 个点，可以这些写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIEdgeInsets</span>)alignmentRectInsets &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">.0</span>, <span class="number">.0</span>, <span class="number">-10.0</span>, <span class="number">.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="布局渲染"><a href="#布局渲染" class="headerlink" title="布局渲染"></a>布局渲染</h1><p>iOS 的布局渲染可以分为三个阶段，如下所示：</p><ol><li><strong>约束更新</strong>（Constraints Update）</li><li><strong>布局更新</strong>（Layout Update）</li><li><strong>显示重绘</strong>（Display Redraw）</li></ol><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/the-render-loop.png?x-oss-process=image/resize,w_800" alt=""></p><p>其中，每一步都是依赖前一步操作。显示重绘依赖布局更新，布局更新依赖约束更新。</p><h2 id="约束更新"><a href="#约束更新" class="headerlink" title="约束更新"></a>约束更新</h2><p>约束更新是 <strong>自下而上</strong>（从子视图到父视图）进行的。我们可以通过调用 <code>setNeedsUpdateConstraints</code> 来触发约束更新。当然，我们对布局因素（约束/内容优先级、约束、固有内容尺寸…）作出的任何修改都会 <strong>自动触发</strong> <code>setNeedsUpdateConstraints</code> 方法。</p><p>对于自定义视图，我们可以在约束更新阶段重写 <code>updateConstraints</code> 来为视图增加需要的本地约束。</p><h2 id="布局更新"><a href="#布局更新" class="headerlink" title="布局更新"></a>布局更新</h2><p>布局更新是 <strong>自上而下</strong>（从父视图到子视图）进行的。事实上，布局更新操作是通过设置 <code>frame</code>（OS X ）或 <code>center</code> 和 <code>bounds</code>（iOS）将布局引擎的计算结果应用到视图上。我们可以通过条用 <code>setNeedsLayout</code> 来触发布局更新。这并不会立刻应用布局，而是延迟进行处理。因为所有的布局请求将会被合并到一个布局操作中。这种延迟处理的过程被称为 <code>Deferred Layout Pass</code>。</p><p>我们可以调用 <code>layoutIfNeeded</code>（iOS） 或 <code>layoutSubtreeIfNeeded</code>（OS X）强制系统立即更新视图树的布局。如果我们下一步的操作依赖于更新后视图的 <code>frame</code>，这将非常有用。</p><p>对于自定义视图，我们可以布局更新阶段重写 <code>layoutSubviews</code>（iOS）或 <code>layout</code>（OS X）来获取控制布局变化的所有权。</p><h2 id="显示重绘"><a href="#显示重绘" class="headerlink" title="显示重绘"></a>显示重绘</h2><p>显示重绘时 <strong>自上而下</strong>（从父视图到子视图）进行的。我们可以通过调用 <code>setNeedsDisplay</code> 来触发显示重绘，这回导致所有的调用都被合并到一起延迟重绘。</p><p>对于自定义视图，我们可以在显示重绘阶段重新 <code>drawRect:</code> 来获取自显示过程的所有权。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>要注意的是，这三个阶段并不是单向的。基于约束的布局是一个迭代的过程。布局更新可以基于之前的布局来对约束作出修改，而这将再次触发约束更新，并紧接另一个布局更新。这可以被用来创建高级的自定义视图布局。但是如果我们每一次调用的自定义 <code>layoutSubviws</code> 都会导致另一个布局操作的话，将会陷入无限循环中。</p><h1 id="不同版本-iOS-的自动布局"><a href="#不同版本-iOS-的自动布局" class="headerlink" title="不同版本 iOS 的自动布局"></a>不同版本 iOS 的自动布局</h1><h2 id="iOS-6"><a href="#iOS-6" class="headerlink" title="iOS 6"></a>iOS 6</h2><ul><li>苹果在这个版本引入了自动布局，具有了所有核心功能。</li></ul><h2 id="iOS-7"><a href="#iOS-7" class="headerlink" title="iOS 7"></a>iOS 7</h2><ul><li>NavigationBar、TabBar、ToolBar 的 <code>translucent</code> 属性默认为 <code>YES</code>。当前 ViewController 的高度是整个屏幕的高度，为了确保不被这些 Bar 覆盖，可以在布局中使用 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> 属性。</li></ul><h2 id="iOS-8"><a href="#iOS-8" class="headerlink" title="iOS 8"></a>iOS 8</h2><ul><li>Self-Sizing Cells。传送门: <a href="https://www.appcoda.com/self-sizing-cells/" target="_blank" rel="noopener">https://www.appcoda.com/self-sizing-cells/</a></li><li><code>UIViewController</code> 新增两个方法，用来处理 <code>UITraitEnvironment</code> 协议。UIKit 里有 <code>UIScreen</code>、<code>UIViewController</code>、<code>UIPresentationController</code> 支持该协议。当视图 traitCollection 改变时，<code>UIViewController</code> 可以捕获到这个消息进行处理。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setOverrideTraitCollection:(<span class="built_in">UITraitCollection</span> *)collection forChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="built_in">UITraitCollection</span> *)overrideTraitCollectionForChildViewController:(<span class="built_in">UIViewController</span> *)childViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure><ul><li><p>Size Class。<code>UIViewController</code> 提供了一组新协议支持 <code>UIContentContainer</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)systemLayoutFittingSizeDidChangeForChildContentContainer:(<span class="keyword">id</span> )container <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeForChildContentContainer:(<span class="keyword">id</span> )container withParentContainerSize:(<span class="built_in">CGSize</span>)parentSize <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)willTransitionToTraitCollection:(<span class="built_in">UITraitCollection</span> *)newCollection withTransitionCoordinator:(<span class="keyword">id</span> )coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure></li><li><p><code>UIView</code> 的 margin 新增了 3 个 API，<code>NSLayoutMargins</code> 可以定义视图之间的距离。只对自动布局有效，并且默认值为 <code>{8, 8, 8, 8}</code>。<code>NSLayoutAttribute</code> 的枚举值也有相应的更新。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIView的3个Margin相关API</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> layoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> preservesSuperviewLayoutMargins <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)layoutMarginsDidChange <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSLayoutAttribute的枚举值更新</span></span><br><span class="line"><span class="built_in">NSLayoutAttributeLeftMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeRightMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeTopMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeBottomMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeLeadingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeTrailingMargin</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeCenterXWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br><span class="line"><span class="built_in">NSLayoutAttributeCenterYWithinMargins</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</span><br></pre></td></tr></table></figure></li></ul><h2 id="iOS-9"><a href="#iOS-9" class="headerlink" title="iOS 9"></a>iOS 9</h2><ul><li><code>UIStackView</code>：提供了更加简单的自动布局方法，如：alignment 的 fill，leading，center，trailing。distribution 的 fill，fill equally，fill proportionally，equal spacing。</li><li><code>NSLayoutAnchor</code> API<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLayoutConstraint</span> *constraint = [view1.leadingAnchor constraintEqualToAnchor:view2.topAnchor];</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://constraints.cs.washington.edu/solvers/uist97.html" target="_blank" rel="noopener">Solving Linear Arithmetic Constraints for User Interface Applications</a></li><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener">Visual Format Language</a></li><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" target="_blank" rel="noopener">Understanding Auto Layout</a></li><li><a href="https://peteruncle.com/2018/01/28/NSLayoutAnchor%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">NSLayoutAnchor基础知识</a></li><li><a href="https://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/" target="_blank" rel="noopener">深入剖析Auto Layout，分析iOS各版本新增特性</a></li><li><a href="https://peteruncle.com/2018/01/08/iOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">iOS 自动布局基础知识</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/218/" target="_blank" rel="noopener">WWDC 2015 session 218 Mysteries of Auto Layout Part1</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener">WWDC 2015 session 219 Mysteries of Auto Layout Part2</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/220" target="_blank" rel="noopener">WWDC 2018 session 220 High Performance Auto Layout</a></li><li><a href="https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="noopener">Advanced Auto Layout Toolbox</a></li><li><a href="http://www.pluto-y.com/wwdc-2015-mystries-of-auto-layout/" target="_blank" rel="noopener">WWDC 2015 - 揭开AutoLayout的神秘面纱(Mysteries Of Auto Layout)</a></li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol><li><a href="https://juejin.im/entry/578354df1532bc005f5c1266" target="_blank" rel="noopener">iOS 利用 AutoLayout 实现 view 间隔自动调整</a></li><li><a href="https://www.cnblogs.com/lisa090818/p/4303426.html" target="_blank" rel="noopener">ios auto layout demystified (一)</a></li><li><a href="https://objccn.io/issue-3-5/" target="_blank" rel="noopener">先进的自动布局工具箱</a></li><li><a href="https://samingzhong.github.io/2016/08/30/UIKit/%E5%85%B3%E4%BA%8EUIView%E7%9A%84translatesAutoresizingMaskIntoConstraints%20%E5%B1%9E%E6%80%A7/" target="_blank" rel="noopener">关于UIView的translatesAutoresizingMaskIntoConstraints属性</a></li><li><a href="https://github.com/ming1016/study/wiki/Masonry" target="_blank" rel="noopener">Masonry</a></li><li><a href="https://segmentfault.com/a/1190000015300896" target="_blank" rel="noopener">iOS 布局渲染——UIView 方法调用时机</a></li><li><a href="https://peteruncle.com/2017/08/09/UIStackView%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">UIStackView基础知识</a></li></ol><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近准备阅读 Masonry 的源代码，学习一下其中的设计思想。然而，阅读了一部分之后，发现自己对 iOS 自动布局了解的不够系统，也不够深入。于是，准备好好学习学习 iOS 自动布局的基础知识。&lt;/p&gt;
&lt;p&gt;下面是我对 iOS 布局系统的一些整理和总结，当然，自动布局是
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="自动布局" scheme="http://chuquan.me/tags/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>二战欧洲东线战场战线动画--苏德战场</title>
    <link href="http://chuquan.me/2019/09/07/world-war-2-su-de/"/>
    <id>http://chuquan.me/2019/09/07/world-war-2-su-de/</id>
    <published>2019-09-07T15:13:42.000Z</published>
    <updated>2019-09-25T15:14:52.775Z</updated>
    
    <content type="html"><![CDATA[<p>最近在网上看到一组视频，介绍二战时期苏德战场的战线动画演示过程。看了之后，对苏德战场有了更加深刻的理解。特此收藏。</p><h1 id="1941年"><a href="#1941年" class="headerlink" title="1941年"></a>1941年</h1><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1941.mp4" type="video/mp4" controls="controls" width="60%" height="60%"></video></div><h1 id="1942年"><a href="#1942年" class="headerlink" title="1942年"></a>1942年</h1><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1942.mp4" type="video/mp4" controls="controls" width="60%" height="60%"></video></div><h1 id="1943年-1944年"><a href="#1943年-1944年" class="headerlink" title="1943年/1944年"></a>1943年/1944年</h1><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1943-to-1944.mp4" type="video/mp4" controls="controls" width="60%" height="60%"></video></div><h1 id="1944年-1945年"><a href="#1944年-1945年" class="headerlink" title="1944年/1945年"></a>1944年/1945年</h1><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/videos/world-war-2-sude-1944-to-1945.mp4" type="video/mp4" controls="controls" width="60%" height="60%"></video></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在网上看到一组视频，介绍二战时期苏德战场的战线动画演示过程。看了之后，对苏德战场有了更加深刻的理解。特此收藏。&lt;/p&gt;
&lt;h1 id=&quot;1941年&quot;&gt;&lt;a href=&quot;#1941年&quot; class=&quot;headerlink&quot; title=&quot;1941年&quot;&gt;&lt;/a&gt;1941年&lt;
      
    
    </summary>
    
      <category term="收录" scheme="http://chuquan.me/categories/%E6%94%B6%E5%BD%95/"/>
    
    
      <category term="二战" scheme="http://chuquan.me/tags/%E4%BA%8C%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS 网络(3)——YTKNetwork</title>
    <link href="http://chuquan.me/2019/08/20/ios-network-ytknetwork/"/>
    <id>http://chuquan.me/2019/08/20/ios-network-ytknetwork/</id>
    <published>2019-08-20T15:57:44.000Z</published>
    <updated>2019-10-02T09:39:31.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意：在阅读本文之前建议先阅读<a href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/">《iOS 网络——NSURLSession》</a>和<a href="http://chuquan.me/2019/08/06/ios-network-afnetworking/">《iOS 网络——AFNetworking》</a>。</p></blockquote><p>在<a href="http://chuquan.me/2019/08/06/ios-network-afnetworking/">《iOS 网络——AFNetworking》</a>一文中我们介绍了基于 <code>NSURLSession</code> 进行封装的 AFNetworking 的核心功能原理。本文，我们进一步介绍基于 AFNetworking 进行封装的 YTKNetwork 开源框架。本文，我们通过阅读 YTKNetwork 源代码（版本号：<code>2.0.4</code>）。</p><h1 id="YTKNetwork-概述"><a href="#YTKNetwork-概述" class="headerlink" title="YTKNetwork 概述"></a>YTKNetwork 概述</h1><p>YTKNetwork 是猿题库技术团队开源的一个网络请求框架，内部封装了 AFNetworking。YTKNetwork 实现了一套高层级的 API，提供更高层次的网络访问抽象。目前，猿题库公司的所有产品的 iOS 客户端都使用了 YTKNetwork，包括：猿题库、小猿搜题、猿辅导、小猿口算、斑马系列等。</p><h1 id="YTKNetwork-架构"><a href="#YTKNetwork-架构" class="headerlink" title="YTKNetwork 架构"></a>YTKNetwork 架构</h1><p>YTKNetwork 开源框架主要包含 3 个部分：</p><ul><li>YTKNetwork 核心功能</li><li>YTKNetwork 链式请求</li><li>YTKNetwork 批量请求</li></ul><p>其中，链式请求和批量请求都是基于 YTKNetwork 的核心功能实现的。下面我们分别进行介绍。</p><h2 id="YTKNetwork-核心功能"><a href="#YTKNetwork-核心功能" class="headerlink" title="YTKNetwork 核心功能"></a>YTKNetwork 核心功能</h2><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-overview.png?x-oss-process=image/resize,w_800" alt=""></div><p>上图所示为 YTKNetwork 核心功能的类的引用关系示意图。YTKNetwork 核心功能的基本思想是：</p><ul><li><strong>把每一个网络请求封装成一个对象，每个请求对象继承自 <code>YTKBaseRequest</code> 类</strong>。</li><li><strong>使用 <code>YTKNetworkAgent</code> 单例对象持有一个 <code>AFHTTPSessionManager</code> 对象来管理所有请求对象</strong>。</li></ul><p>YTKNetwork 核心功能主要涉及到 3 个类：</p><ul><li><code>YTKBaseRequest</code></li><li><code>YTKNetworkConfig</code></li><li><code>YTKNetworkAgent</code></li></ul><p>下面我们分别进行介绍。</p><h3 id="YTKBaseRequest"><a href="#YTKBaseRequest" class="headerlink" title="YTKBaseRequest"></a>YTKBaseRequest</h3><p><code>YTKBaseRequest</code> 类用于表示一个请求对象，它提供了一系列属性来充分表示一个网络请求。我们可以看一下它所定义的属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBaseRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/// 请求相关属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLSessionTask</span> *requestTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *currentRequest;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *originalRequest;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSHTTPURLResponse</span> *response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 响应相关属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> responseStatusCode;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *responseHeaders;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *responseData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *responseString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> responseObject;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span> responseJSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 异常</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 状态</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 标识符，默认是 0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> tag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 附加信息，默认是 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;YTKRequestDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 成功/失败回调</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock successCompletionBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock failureCompletionBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于在 POST 请求时构建 HTTP 主体。默认是 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFConstructingBlock constructingBodyBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于下载任务时指定本地下载路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *resumableDownloadPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于跟踪下载进度的回调</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFURLSessionTaskProgressBlock resumableDownloadProgressBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YTKRequestPriority requestPriority;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// YTKRequestAccessory 是一个协议，声明了三个方法，允许开发者分别在请求执行的三个阶段(start、willStop、didStop)调用。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>事实上，<code>YTKBaseRequest</code> 类就是围绕 <code>NSURLSessionTask</code> 类进行封装的， <code>requestTask</code> 是它最重要的属性。<code>YTKBaseRequest</code> 的其他多个属性都源自于 <code>requestTask</code> 的属性。如：</p><ul><li><code>currentRequest</code>：即 <code>requestTask.currentRequest</code> </li><li><code>originalRequest</code>：即 <code>requestTask.originalRequest</code></li><li><code>response</code>：即 <code>requestTask.response</code></li><li><code>responseHeaders</code>：即 <code>requestTask.allHeaderFields</code></li><li><code>responseStatusCode</code>：即 <code>requestTask.statusCode</code></li></ul><p><code>YTKBaseRequest</code> 提供了高层级的网络抽象，体现在提供了一些高层级的配置方法，并允许用户通过覆写这些方法来进行自定义配置。一些常用的配置方法包括如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Base URL，因为一个应用程序中的网络请求的 BaseURL 几乎都是相同的。</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)baseUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求的 URL 路径</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 网络请求的超时间隔。默认 60 秒</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)requestTimeoutInterval &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HTTP 请求方法。默认是 GET</span></span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestMethodGET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求序列化器类型。默认是 HTTP</span></span><br><span class="line">- (YTKRequestSerializerType)requestSerializerType &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestSerializerTypeHTTP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 响应序列化器类型。默认是 JSON</span></span><br><span class="line">- (YTKResponseSerializerType)responseSerializerType &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKResponseSerializerTypeJSON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求参数对象，会根据配置的请求序列化器进行编码。</span></span><br><span class="line">- (<span class="keyword">id</span>)requestArgument &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否允许蜂窝网络。默认 YES</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)allowsCellularAccess &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否使用 CDN。默认 NO</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)useCDN &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CDN URL。根据 useCDN 决定是否使用。</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cdnUrl &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>关于 <code>YTKBaseRequest</code> 对象的执行，它也提供了几个简单的方法以供开发者使用，如下所示。通过 <code>start</code> 方法，我们可以发现 <code>YTKBaseRequest</code> 被加入到了 <code>YTKNetworkAgent</code> 单例中。可见 <code>YTKNetworkAgent</code> 管理了多个 <code>YTKBaseRequest</code> 对象。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// YTKBaseRequest 开始执行</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">// 执行 YTKRequestAccessory 协议定义的 requestWillStart: 方法。</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">    <span class="comment">// 将请求对象加入 YTKNetworkAgent 单例</span></span><br><span class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// YTKBaseRequest 停止执行</span></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="comment">// 执行 YTKRequestAccessory 协议定义的 requestWillStop: 方法。</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 执行 YTKRequestAccessory 协议定义的 requestDidStop: 方法。</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 一个便利方法。执行 YTKBaseRequest。</span></span><br><span class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    [<span class="keyword">self</span> start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="YTKNetworkConfig"><a href="#YTKNetworkConfig" class="headerlink" title="YTKNetworkConfig"></a>YTKNetworkConfig</h3><p><code>YTKNetworkConfig</code> 是用于 <code>YTKNetworkAgent</code> 初始化的配置对象，是一个 <strong>单例</strong>。</p><p><code>YTKNetworkConfig</code> 主要包含以下属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKNetworkConfig</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求的 Base URL。默认是 ""</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *baseUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  CDN URL. 默认是 ""</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *cdnUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// URL 过滤器。YTKUrlFilterProtocol 声明的 filterUrl:withRequest: 方法会返回最终被使用的 URL</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKUrlFilterProtocol&gt;&gt; *urlFilters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缓存路径过滤器。YTKCacheDirPathFilterProtocol 声明的 filterCacheDirPath:withRequest: 方法会返回最终被使用的缓存路径。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *cacheDirPathFilters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 安全策略。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否打印调试日志信息。默认是 NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> debugLogEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 会话配置对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionConfiguration</span>* sessionConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>YTKNetworkConfig</code> 持有了一个 <code>NSURLSessionConfiguration</code> 类型的属性 <code>sessionConfiguration</code>，用于 <code>YTKNetworkAgent</code> 中初始化 <code>AFHTTPSessionManager</code>（本质上是用于初始化 <code>NSURLSession</code>）。</p><h3 id="YTKNetworkAgent"><a href="#YTKNetworkAgent" class="headerlink" title="YTKNetworkAgent"></a>YTKNetworkAgent</h3><p><code>YTKNetworkAgent</code> 的内部结构如下图所示。下面我们将以该图为指导进行介绍。</p><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-ytknetworkagent.png?x-oss-process=image/resize,w_800" alt=""></div><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>YTKNetworkAgent</code> 初始化过程会使用 <code>YTKNetworkConfig</code> 单例对象（配置对象）。使用配置对象的会话配置对象 <code>sessionConfiguration</code> 初始化会话管理器 <code>AFHTTPSessionManager</code>。</p><p><code>YTKNetwork</code> 框架默认只能使用 <code>YTKNetworkAgent</code> 单例对象。</p><h4 id="添加并执行请求"><a href="#添加并执行请求" class="headerlink" title="添加并执行请求"></a>添加并执行请求</h4><p><code>YTKNetworkAgent</code> 提供了 <code>addRequest:</code> 方法来添加并执行请求对象。我们可以来看一下其内部实现。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化请求对象的关键属性 requestTask，即任务对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</span><br><span class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</span><br><span class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="comment">// 完成回调</span></span><br><span class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认方式</span></span><br><span class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求序列化异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@"requestTask should not be nil"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求优先级</span></span><br><span class="line">    <span class="comment">// !!Available on iOS 8 +</span></span><br><span class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</span><br><span class="line">                <span class="comment">/*!!fall through*/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YTKLog(<span class="string">@"Add request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line">    <span class="comment">// 将 请求对象 加入记录表</span></span><br><span class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</span><br><span class="line">    <span class="comment">// 执行请求，即执行任务对象</span></span><br><span class="line">    [request.requestTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>addRequest:</code> 方法内部会做一下几个步骤的工作：</p><ol><li>初始化请求对象的关键属性 <code>requestTask</code>，即任务对象。</li><li>设置请求优先级</li><li>以任务对象的 <code>taskIdentifier</code> 为键，请求对象为值，建立映射关系，存入 <strong>记录表</strong>（即上图中的 <code>_requestRecord</code>，后文还会提到）。</li><li>执行请求，本质上是执行任务对象。</li></ol><p>我们重点看一下第 1 步。这一步默认调用了 <code>sessionTaskForRequest:error:</code> 方法进行初始化。该方法内部实现如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 获取请求方法</span></span><br><span class="line">    YTKRequestMethod method = [request requestMethod];</span><br><span class="line">    <span class="comment">// 获取请求URL</span></span><br><span class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">    <span class="keyword">id</span> param = request.requestArgument;</span><br><span class="line">    <span class="comment">// 获取 HTTP 主体</span></span><br><span class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</span><br><span class="line">    <span class="comment">// 获取请求序列化器</span></span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据请求方法以及下载路径值，初始化相应的任务对象</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</span><br><span class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"HEAD"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PUT"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"DELETE"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PATCH"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>sessionTaskForRequest:error:</code> 方法会根据请求对象的 <code>requestMethod</code> 初始化相应的任务对象。以 <code>POST</code> 请求为例，这里最终会调用 <code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:constructingBodyWithBlock:error:</code> 方法。其内部实现如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个 URLRequest 对象</span></span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 URLRequest 对象，初始化任务对象，并返回该任务对象</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [_manager dataTaskWithRequest:request</span><br><span class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                <span class="comment">// 设置完成回调</span></span><br><span class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</span><br><span class="line">                           &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:constructingBodyWithBlock:error:</code> 方法根据入参初始化一个 URLRequest 对象，并使用该对象初始化一个任务对象，并返回该任务对象。</p><h4 id="完成回调"><a href="#完成回调" class="headerlink" title="完成回调"></a>完成回调</h4><p>上述 <code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:constructingBodyWithBlock:error:</code> 方法中，初始化任务对象时会设置完成回调。</p><p>我们来看看完成回调做了什么工作。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    Lock();</span><br><span class="line">    <span class="comment">// 根据任务对象的 taskIdentifier 从记录表中获取请求对象。</span></span><br><span class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</span><br><span class="line">    Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YTKLog(<span class="string">@"Finished Request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *requestError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> succeed = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的响应序列化器，序列化响应数据</span></span><br><span class="line">    request.responseObject = responseObject;</span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        request.responseData = responseObject;</span><br><span class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (request.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Default serializer. Do nothing.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                request.responseJSONObject = request.responseObject;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查请求是否成功，并获取请求异常</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = error;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = serializationError;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</span><br><span class="line">        requestError = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用请求成功处理 或 调用请求失败处理</span></span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从记录表中删除请求对象</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个回调中，主要做了一下几个工作：</p><ol><li>根据任务对象的 <code>taskIdentifier</code> 从记录表 <code>_requestRecord</code> 中获取请求对象。</li><li>对于获取到的请求对象，根据不同的响应序列化器，序列化响应数据。</li><li>检查请求是否成功，并获取请求异常。</li><li>调用请求成功处理 或 调用请求失败处理</li><li>从记录表中删除请求对象。</li></ol><p>其中第 4 步，无论是成功回调还是失败回调，都会依次调用代理对象实现的 <code>requestFinished:</code> 或 <code>requestFailed</code>，以及请求对象的 <code>successCompletionBlock</code> 或 <code>failureCompletionBlock</code>。</p><h4 id="下载任务与缓存"><a href="#下载任务与缓存" class="headerlink" title="下载任务与缓存"></a>下载任务与缓存</h4><p>关于下载任务，我们先来看一下上述 <code>sessionTaskForRequest:error:</code> 方法中，当请求对象的请求类型是 <code>YTKRequestMethodGET</code> 且设置了请求对象的 <code>resumableDownloadPath</code> 属性时，会调用 <code>downloadTaskWithDownloadPath:requestSerializer:URLString:parameters:progress:error:</code> 方法。该方法的具体实现如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithDownloadPath:(<span class="built_in">NSString</span> *)downloadPath</span><br><span class="line">                                         requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 使用请求参数、请求URL、请求类型，初始化 URLRequest 对象</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *urlRequest = [requestSerializer requestWithMethod:<span class="string">@"GET"</span> URLString:URLString parameters:parameters error:error];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *downloadTargetPath;</span><br><span class="line">    <span class="comment">// 检查 resumableDownloadPath 指定的下载存储路径是否是目录</span></span><br><span class="line">    <span class="built_in">BOOL</span> isDirectory;</span><br><span class="line">    <span class="keyword">if</span>(![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadPath isDirectory:&amp;isDirectory]) &#123;</span><br><span class="line">        isDirectory = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理下载存储路径，确保不是目录，而是文件</span></span><br><span class="line">    <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *fileName = [urlRequest.URL lastPathComponent];</span><br><span class="line">        downloadTargetPath = [<span class="built_in">NSString</span> pathWithComponents:@[downloadPath, fileName]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downloadTargetPath = downloadPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理该路径原有的文件</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadTargetPath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:downloadTargetPath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查未完成下载暂存路径是否有数据 并 读取此路径暂存的数据</span></span><br><span class="line">    <span class="built_in">BOOL</span> resumeDataFileExists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath].path];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath]];</span><br><span class="line">    <span class="built_in">BOOL</span> resumeDataIsValid = [YTKNetworkUtils validateResumeData:data];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> canBeResumed = resumeDataFileExists &amp;&amp; resumeDataIsValid;</span><br><span class="line">    <span class="built_in">BOOL</span> resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (canBeResumed) &#123;</span><br><span class="line">        <span class="comment">// 对于可恢复的下载请求，使用已下载的数据初始化一个下载任务，继续发起下载请求。</span></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            downloadTask = [_manager downloadTaskWithResumeData:data progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">            &#125; completionHandler:</span><br><span class="line">                            ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                                [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                            &#125;];</span><br><span class="line">            resumeSucceeded = <span class="literal">YES</span>;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            YTKLog(<span class="string">@"Resume download failed, reason = %@"</span>, exception.reason);</span><br><span class="line">            resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!resumeSucceeded) &#123;</span><br><span class="line">        <span class="comment">// 如果尝试继续下载失败，则创建一个下载任务，重新开始发起下载请求。</span></span><br><span class="line">        downloadTask = [_manager downloadTaskWithRequest:urlRequest progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">            <span class="comment">// 指定下载的存储路径</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">        &#125; completionHandler:</span><br><span class="line">                        ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                            [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下载任务的创建过程中，有三个关键步骤：</p><ol><li>确保下载存储路径是文件路径，而非目录路径。</li><li>读取 <strong>未完成下载暂存路径</strong> 的数据，并判断是否可继续下载。</li><li>如果可以继续下载，则创建请求继续下载；否则，创建请求重新下载。</li></ol><p>从上面代码中，我们可以知道下载存储路径有两种可能： </p><ol><li><code>resumableDownloadPath</code></li><li><code>resumableDownloadPath</code> + <code>filename</code> </li></ol><p>那么未完成下载暂存路径是什么呢？我们来看代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)incompleteDownloadTempCacheFolder &#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> new];</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cacheFolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cacheFolder) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *cacheDir = <span class="built_in">NSTemporaryDirectory</span>();</span><br><span class="line">        cacheFolder = [cacheDir stringByAppendingPathComponent:kYTKNetworkIncompleteDownloadFolderName];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span>(![fileManager createDirectoryAtPath:cacheFolder withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:&amp;error]) &#123;</span><br><span class="line">        YTKLog(<span class="string">@"Failed to create cache directory at %@"</span>, cacheFolder);</span><br><span class="line">        cacheFolder = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheFolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)incompleteDownloadTempPathForDownloadPath:(<span class="built_in">NSString</span> *)downloadPath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *tempPath = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *md5URLString = [YTKNetworkUtils md5StringFromString:downloadPath];</span><br><span class="line">    tempPath = [[<span class="keyword">self</span> incompleteDownloadTempCacheFolder] stringByAppendingPathComponent:md5URLString];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:tempPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码，可以看出未完成下载暂存路径其实就是：  </p><ul><li><code>NSTemporaryDirectory()</code> + 下载存储路径目录的 md5 值</li></ul><p>注意，<code>NSTemporaryDirectory()</code> 目录就是 UNIX 中的 <code>/tmp</code> 目录，该目录下的文件会在系统重启后被清空。</p><h2 id="YTKNetwork-链式请求"><a href="#YTKNetwork-链式请求" class="headerlink" title="YTKNetwork 链式请求"></a>YTKNetwork 链式请求</h2><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-chain-overview.png?x-oss-process=image/resize,w_800" alt=""></div><p>链式请求主要是通过 YTKNetwork 提供的两个类，并结合 YTKNetwork 核心功能实现的。这两类分别是：</p><ul><li><code>YTKChainRequest</code></li><li><code>YTKChainRequestAgent</code></li></ul><p>下面，我们分别介绍一下 <code>YTKChainRequest</code> 和 <code>YTKChainRequestAgent</code>。</p><h3 id="YTKChainRequest"><a href="#YTKChainRequest" class="headerlink" title="YTKChainRequest"></a>YTKChainRequest</h3><p><code>YTKChainRequest</code> 继承自 <code>NSObject</code>，主要包含一下这些属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 公开属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKChainRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代理对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;YTKChainRequestDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// YTKRequestAccessory 是一个协议，声明了三个方法，允许开发者分别在请求执行的三个阶段(start、willStop、didStop)调用。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="keyword">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// ------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 私有属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKChainRequest</span>()&lt;<span class="title">YTKRequestDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 链式请求队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>&lt;YTKBaseRequest *&gt; *requestArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 链式请求回调队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>&lt;YTKChainCallback&gt; *requestCallbackArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> nextRequestIndex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) YTKChainCallback emptyCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>YTKChainRequest</code> 提供了 4 个方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 获取链式请求队列</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;YTKBaseRequest *&gt; *)requestArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加实现了 YTKRequestAccessory 协议的对象</span></span><br><span class="line">- (<span class="keyword">void</span>)addAccessory:(<span class="keyword">id</span>&lt;YTKRequestAccessory&gt;)accessory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开始执行链式请求</span></span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 停止执行链式请求</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 向链式请求队列中添加请求</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request callback:(<span class="keyword">nullable</span> YTKChainCallback)callback;</span><br></pre></td></tr></table></figure></p><p>我们通过源代码来看一下其中比较关键的 <code>start</code> 方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">// 判断链式请求是否已经启动</span></span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@"Error! Chain request has already started."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式请求队列非空，则开始执行请求</span></span><br><span class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">        [<span class="keyword">self</span> startNextRequest];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        YTKLog(<span class="string">@"Error! Chain request array is empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>start</code> 方法内部首先判断链式请求是否已经启动，这是通过请求索引 <code>_nextRequestIndex</code> 来判断的。如果链式请求未启动，则开始执行链式请求，这里调用了一个关键的方法 <code>startNextRequest</code>。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)startNextRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</span><br><span class="line">        _nextRequestIndex++;</span><br><span class="line">        request.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">        [request start];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每调用一次 <code>startNextRequest</code>，会移动请求索引、设置请求代理并执行。</p><p>链式请求中的每一个请求 <code>YTKBaseRequest</code> 的代理都是链式请求 <code>YTKChainRequest</code>。<code>YTKChainRequest</code> 实现了 <code>YTKRequestDelegate</code> 协议。每一个请求执行完成后，开始执行下一个请求。如果有一个请求失败，即整个链式请求失败。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</span><br><span class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</span><br><span class="line">    callback(<span class="keyword">self</span>, request);</span><br><span class="line">    <span class="comment">// 执行下一个请求</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</span><br><span class="line">            <span class="comment">// 所有请求执行完毕，调用代理方法 chainRequestFinished:</span></span><br><span class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</span><br><span class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</span><br><span class="line">        <span class="comment">// 有一个请求失败，即调用 chainRequestFailed:</span></span><br><span class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="YTKChainRequestAgent"><a href="#YTKChainRequestAgent" class="headerlink" title="YTKChainRequestAgent"></a>YTKChainRequestAgent</h3><p><code>YTKChainRequestAgent</code> 的作用非常简单，就是作为一个单例，持有多个链式请求。<code>YTKChainRequestAgent</code> 提供的方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (YTKChainRequestAgent *)sharedAgent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加链式请求</span></span><br><span class="line">- (<span class="keyword">void</span>)addChainRequest:(YTKChainRequest *)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 移除链式请求</span></span><br><span class="line">- (<span class="keyword">void</span>)removeChainRequest:(YTKChainRequest *)request;</span><br></pre></td></tr></table></figure></p><h2 id="YTKNetwork-批量请求"><a href="#YTKNetwork-批量请求" class="headerlink" title="YTKNetwork 批量请求"></a>YTKNetwork 批量请求</h2><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ytknetwork-batch-overview.png?x-oss-process=image/resize,w_800" alt=""></div><p><code>YTKNetwork</code> 批量请求的实现原理其实与链式请求的实现原理是一样的，也提供了两个类：</p><ul><li><code>YTKBatchRequest</code></li><li><code>YTKBatchRequestAgent</code></li></ul><p>不同之处在于，<code>YTKBatchRequest</code> 中的单个请求并不是 <code>YTKBaseRequest</code> 请求，而是它的子类 <code>YTKRequest</code>。</p><p>我们来看看 <code>YTKRequest</code> 在父类 <code>YTKBaseRequest</code> 的基础上做了些什么。</p><h3 id="YTKRequest"><a href="#YTKRequest" class="headerlink" title="YTKRequest"></a>YTKRequest</h3><p>首先，我们来看一下 <code>YTKRequest</code> 所提供的外部属性和方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKRequest</span> : <span class="title">YTKBaseRequest</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否忽略缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> ignoreCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 请求响应数据是否来自本地缓存</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error;</span><br><span class="line"><span class="comment">/// 请求不使用缓存数据</span></span><br><span class="line">- (<span class="keyword">void</span>)startWithoutCache;</span><br><span class="line"><span class="comment">/// 将响应数据保存至缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Subclass Override</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缓存时间</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds;</span><br><span class="line"><span class="comment">/// 缓存版本</span></span><br><span class="line">- (<span class="keyword">long</span> <span class="keyword">long</span>)cacheVersion;</span><br><span class="line"><span class="comment">/// 缓存敏感数据，用于验证缓存是否失效</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)cacheSensitiveData;</span><br><span class="line"><span class="comment">/// 是否异步写入缓存</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)writeCacheAsynchronously;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>很明显，<code>YTKRequest</code> 在父类的基础上支持了本地缓存功能。</p><h4 id="缓存目录"><a href="#缓存目录" class="headerlink" title="缓存目录"></a>缓存目录</h4><p>我们来重点看一下 <code>YTKRequest</code> 中相关的缓存目录。首先来看以下几个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@"LazyRequestCache"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter cache base path</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    <span class="keyword">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</span><br><span class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Method:%ld Host:%@ Url:%@ Argument:%@"</span>,</span><br><span class="line">                             (<span class="keyword">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    <span class="keyword">return</span> cacheFileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.metadata"</span>, [<span class="keyword">self</span> cacheFileName]];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下，<code>cacheBasePath</code> 方法返回的基本路径是：<code>/Library/LazyRequestCache</code>。</p><p><code>cacheFileName</code> 方法则根据请求的基本信息生成缓存的文件名：<code>Method:xxx Host:xxx Url:xxx Argument:xxx</code>，并使用 md5 进行编码。</p><p><code>cacheFilePath</code> 则是请求数据的完整存储路径：<code>/Library/LazyRequestCache/</code> + md5(<code>Method:xxx Host:xxx Url:xxx Argument:xxx</code>)。</p><p><code>cacheMetadataFilePath</code> 则存储了缓存元数据，其路径是：<code>cacheFilePath</code> + <code>.medata</code>。</p><p>缓存元数据使用 <code>YTKCacheMetaData</code> 对象表示，其定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">long</span> <span class="keyword">long</span> version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>YTKCacheMetaData</code> 主要用户验证缓存是否有效。验证方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// Date</span></span><br><span class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Version</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</span><br><span class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sensitive data</span></span><br><span class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</span><br><span class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></span><br><span class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// App version</span></span><br><span class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>YTKNetwork 设计原理非常简单，仅仅是对 AFNetworking 做了一个简单的封装，提供了面向对象的使用方法，使用起来也是非常简单。不过也存在缺点，就是每一个请求都需要定义一个类。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注意：在阅读本文之前建议先阅读&lt;a href=&quot;http://chuquan.me/2019/07/21/ios-network-nsurlsession/&quot;&gt;《iOS 网络——NSURLSession》&lt;/a&gt;和&lt;a href=&quot;http://c
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="YTKNetwork" scheme="http://chuquan.me/tags/YTKNetwork/"/>
    
      <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS 网络(2)——AFNetworking</title>
    <link href="http://chuquan.me/2019/08/06/ios-network-afnetworking/"/>
    <id>http://chuquan.me/2019/08/06/ios-network-afnetworking/</id>
    <published>2019-08-06T15:27:50.000Z</published>
    <updated>2019-10-02T09:39:12.303Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/">《iOS 网络——NSURLSession》</a>中，我们介绍了 <code>NSURLSession</code> 的架构及工作原理。本文，我们通过阅读 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a> 源代码（版本号：<code>2.6.3</code>），来介绍其设计架构。</p><h1 id="AFNetwoking-概述"><a href="#AFNetwoking-概述" class="headerlink" title="AFNetwoking 概述"></a>AFNetwoking 概述</h1><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/afnetworking-logo.png?x-oss-process=image/resize,w_800" alt=""></div><p>AFNetworking 是一套适用于 iOS、macOS、watchOS、tvOS 的网络库。AFNetworking 2.0 之后的版本构建在基于 <code>NSURLSession</code> 的 Foundation URL 加载系统之上。AFNetworking 扩展了 Cocoa 内置的强大的高级网络抽象，采用模块化设计，功能丰富，是最广泛使用的开源项目之一。</p><h1 id="AFNetworking-架构"><a href="#AFNetworking-架构" class="headerlink" title="AFNetworking 架构"></a>AFNetworking 架构</h1><p>AFNetworking 框架主要包含两部分：</p><ul><li>AFNetworking 核心功能</li><li>UIKit+AFNetworking 分类功能</li></ul><p>这里我们主要介绍 AFNetworking 的核心功能，其整体的架构如下图所示。AFNetworking 主要包含了 6 个类：</p><ul><li><strong><code>AFURLSessionManager</code></strong>：AFNetworking 的核心类。</li><li><strong><code>AFHTTPSessionManager</code></strong>：<code>AFURLSessionManager</code> 的子类，主要用于 HTTP 请求。</li><li><strong><code>AFURLRequestSerialization</code></strong>：请求序列化器，用于将参数编码为查询字符串、HTTP 正文，并根据需要设置合适的 HTTP 头部字段。</li><li><strong><code>AFURLResponseSerialization</code></strong>：响应序列化器，用于将数据解码为对象，还可以对传入的响应和数据进行验证。</li><li><strong><code>AFSecurityPolicy</code></strong>：通过安全连接评估服务器对固定的 X.509 证书和公钥的信任。</li><li><strong><code>AFNetworkReachabilityManager</code></strong>：监视网络可达性。</li></ul><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/afnetwoking-overview.png?x-oss-process=image/resize,w_800" alt=""></div><p>下面我们来介绍一下 AFNetworking 的核心——<code>AFURLSessionManager</code>。</p><h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p>下图所示为 <code>AFURLSessionManager</code> 的内部结构。下面，我们将以该结构图为指导，介绍 <code>AFURLSessionManager</code> 的工作原理。</p><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/afnetwoking-afurlsessionmanager.png?x-oss-process=image/resize,w_800" alt=""></div><h3 id="持有属性"><a href="#持有属性" class="headerlink" title="持有属性"></a>持有属性</h3><p>我们首先浏览一下 <code>AFURLSessionManager</code> 所持有的属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 外部公开的属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span></span></span><br><span class="line"><span class="comment">/// 管理的 Session</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSession</span> *session;</span><br><span class="line"><span class="comment">/// 代理回调执行的队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"><span class="comment">/// 使用 dataTaskWithRequest:success:failure: 创建，使用 GET 或 POST 执行的 data task 的响应。默认值是 AFJSONResponseSerializer</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"><span class="comment">/// Session 使用的安全策略，用于评估服务器对安全连接的信任程度。AFURLSessionManager 使用默认策略 defaultPolicy</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"><span class="comment">/// 网络可达性管理器。AFURLSessionManager 默认使用 sharedManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFNetworkReachabilityManager *reachabilityManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的所有类型的任务，如：data，upload，download 等</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionTask</span> *&gt; *tasks;</span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的 data 任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDataTask</span> *&gt; *dataTasks;</span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的 upload 任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionUploadTask</span> *&gt; *uploadTasks;</span><br><span class="line"><span class="comment">/// 被管理 session 当前运行的 download 任务</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLSessionDownloadTask</span> *&gt; *downloadTasks;</span><br><span class="line"><span class="comment">/// completionBlock 执行所在的队列。如果是 NULL，则在主线程执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> completionQueue;</span><br><span class="line"><span class="comment">/// completionBlock 执行所在的 group。如果是 NULL，则在一个私有的 group 中执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) dispatch_group_t completionGroup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 内部私有的属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLSessionManager</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *operationQueue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *mutableTaskDelegatesKeyedByTaskIdentifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *taskDescriptionForSessionTasks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> *lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession AF_API_UNAVAILABLE(macos);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="meta">#if AF_CAN_INCLUDE_SESSION_TASK_METRICS</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidFinishCollectingMetricsBlock taskDidFinishCollectingMetrics;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先，<code>AFURLSessionManager</code> 对象持有一个 <code>NSURLSessionConfiguration</code> 对象（会话配置对象）。使用会话配置对象即可初始化并持有一个 <code>NSURLSession</code> 对象（会话对象）。会话对象的初始化过程如下代码所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_session) &#123;</span><br><span class="line">            _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，初始化会话对象后，<strong>会话对象将 <code>AFURLSessionManager</code> 设置成自己的代理</strong>。因此，<code>AFURLSessionManager</code> 需要实现相关协议所声明的那些方法。这些协议有：</p><ul><li><code>NSURLSessionDelegate</code></li><li><code>NSURLSessionTaskDelegate</code></li><li><code>NSURLSessionDataDelegate</code></li><li><code>NSURLSessionDownloadDelegate</code></li></ul><p>为了能够让开发者实现自定义处理会话级事件和任务级事件，<code>AFURLSessionManager</code> 提供了大量设置回调的方法，基本可以覆盖到协议所声明的每一个方法。这些回调被 <code>AFURLSessionManager</code> 在内部持有，只有在对应的协议方法被调用时，回调方法才会被执行。</p><h3 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h3><p><code>AFURLSessionManager</code> 作为会话对象的代理，基本可以处理所有任务对象。但是，对于上传任务、下载任务进行进度管理，使用 <code>AFURLSessionManager</code> 来管理是较为繁琐的，也是不合理的。主要有以下几点原因：</p><ul><li>在上传任务和下载任务的整个生命周期中都需要持有一个进度对象 <code>NSProgress</code>。</li><li>在下载任务的整个生命周期中还需要持有一个接收数据对象，用于持续接收数据。</li><li><code>AFURLSessionManager</code> 主要用于管理会话，根据职责单一原则，它不应该管理任务对象的具体细节。</li></ul><p>因此，AFNetworking 提供了 <code>AFURLSessionManagerTaskDelegate</code> 这样一个类来管理特定任务的进度、数据。</p><p><code>AFURLSessionManager</code> 内部维护了一个可变字典属性 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code>，以任务对象的标识符 <code>taskIdentifier</code> 作为键，以 <code>AFURLSessionManagerTaskDelegate</code> 对象作为值。在初始化任务对象时，就绑定一个 <code>AFURLSessionManagerTaskDelegate</code> 对象，以处理进度、下载数据。具体代码如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据特定 request 创建一个 NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建任务对象</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为任务对象设置代理对象、上传进度回调、下载进度回调、完成回调</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个 AFURLSessionManagerTaskDelegate 对象，用以处理进度、下载数据</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来标识任务对象所属的 SessionManager</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 NSURLSessionTask &lt;-&gt; AFURLSessionManagerTaskDelegate 的映射关系</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AFURLSessionManagerTaskDelegate</code> 主要实现了以下这些协议方法。在这些方法内实现进度管理、下载管理。<code>AFURLSessionManager</code> 虽然也实现了这些协议，但是最终还是会调用 <code>AFURLSessionManagerTaskDelegate</code> 中的实现。</p><ul><li><code>NSURLSessionTaskDelegate</code><ul><li><code>URLSession:task:didCompleteWithError:</code></li><li><code>URLSession:task:didFinishCollectingMetrics:</code></li></ul></li><li><code>NSURLSessionDataDelegate</code><ul><li><code>URLSession:dataTask:didReceiveData:</code></li><li><code>URLSession:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code></li></ul></li></ul><h3 id="通知转发"><a href="#通知转发" class="headerlink" title="通知转发"></a>通知转发</h3><p><code>NSURLSession</code> 定义了一系列通知，为了提供更完美的封装，<code>AFURLSessionManager</code> 捕获了这些通知，将它们转换成自己所定义的通知后，再进行转发。</p><p>这里，就用到了任务对象的 <code>taskDescription</code> 属性。<code>taskDescription</code> 属性描述了该任务对象所属的 Session Manager。因为应用程序中可能会初始化多个 <code>AFURLSessionManager</code>。Session Manager 只有在捕获到它所管理的任务对象发出的通知后才会进行封装和转发。如：</p><ul><li><code>AFNetworkingTaskDidResumeNotification</code></li><li><code>AFNetworkingTaskDidSuspendNotification</code></li></ul><h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>接下来，我们再来介绍一下 <code>AFURLSessionManager</code> 的子类——<code>AFHTTPSessionManager</code>。</p><p>首先，我们来看一下 <code>AFHTTPSessionManager</code> 所特有的属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFHTTPSessionManager</span> : <span class="title">AFURLSessionManager</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURL</span> *baseURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFSecurityPolicy *securityPolicy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>由于，<code>AFHTTPSessionManager</code> 主要用于 HTTP 请求，所以它为 HTTP 请求提供了一个请求序列化器和一个响应序列化器，并分别设置默认值为 HTTP 和 JSON。</p><p>除此之外，<code>AFHTTPSessionManager</code> 还封装了 <code>AFURLSessionManager</code> 的一些复杂的任务对象初始化方法，并提供了一些非常简单的便利方法，用以提供各种 HTTP 请求。如下所示：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                               headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                              progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgress</span><br><span class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)HEAD:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line">                                </span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">              constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                               progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgress</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line">                                </span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)PUT:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                               headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)PATCH:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                              parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                 headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                 success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                                 failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)DELETE:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                               parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                  headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                  success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                                  failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总而言之，AFNetworking 实际上只是对 NSURLSession 高度地封装, 提供一些简单易用的 API 方便我们在 iOS 开发中发出网络请求并在其上更快地构建网络层组件并提供合理的接口。</p><p>后面，有机会我们继续深入了解一下 AFNetworking 的其他辅助类以及分类功能。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></li><li><a href="https://draveness.me/afnetworking1" target="_blank" rel="noopener">AFNetworking 概述（一）</a></li></ol><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;a href=&quot;http://chuquan.me/2019/07/21/ios-network-nsurlsession/&quot;&gt;《iOS 网络——NSURLSession》&lt;/a&gt;中，我们介绍了 &lt;code&gt;NSURLSession&lt;/code&gt; 的架构及工作原理。本
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="源码解读" scheme="http://chuquan.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="AFNetworking" scheme="http://chuquan.me/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>iOS 网络(1)——NSURLSession</title>
    <link href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/"/>
    <id>http://chuquan.me/2019/07/21/ios-network-nsurlsession/</id>
    <published>2019-07-21T15:45:17.000Z</published>
    <updated>2019-08-31T00:52:29.771Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司针对刚入职的应届毕业生开展了一个的“新牛计划”，目的是让他们能够在一个月的时间内从零基础成长为 iOS 开发新手。</p><p>在这个过程中，我们需要承担讲师的角色。因此，我们对 iOS 开发的知识体系进行了划分，而我则负责讲解其中的 GCD 和网络相关部分。为此，我也算是学习了一下 iOS<br>开发所涉及到的一些网络知识，也学习了一些开源框架，包括：AFNetworking、YTKNetwork、CocoaAsyncSocket。这里，我首先对 NSURLSession 做一些相关总结。后续，将陆续贴出相关开源框架的学习心得。</p><h1 id="NSURLSession-概述"><a href="#NSURLSession-概述" class="headerlink" title="NSURLSession 概述"></a>NSURLSession 概述</h1><p>WWDC 2013，苹果对基于 <code>NSURLConnection</code> 的 Foundation URL 加载系统进行了重构，推出了新一代基于 <code>NSURLSession</code> 的 Foundation URL 加载系统，并将其首先应用在了 iOS 7 和 Mac OS X 10.9 Mavericks 系统之中。</p><h1 id="NSURLSession-架构"><a href="#NSURLSession-架构" class="headerlink" title="NSURLSession 架构"></a>NSURLSession 架构</h1><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsession-overview.png?x-oss-process=image/resize,w_600" alt=""></div><p><code>NSURLSession</code> 这个名字，实际上是指代 Foundation 框架的 URL 加载系统中一些列相关的类和协议。上图所示为 <code>NSURLSession</code> 的系统架构图，主要由三个类构成：</p><ul><li><strong><code>NSURLSession</code></strong><ul><li>负责请求/响应的关键对象，使用 <code>NSURLSessionConfiguration</code> 配置对象进行创建。</li><li>在请求/响应的执行过程中调用 <code>NSURLSessionTaskDelegate</code> 所定义的各种代理方法。</li></ul></li><li><strong><code>NSURLSessionConfiguration</code></strong><ul><li>用于对 <code>NSURLSession</code> 对象进行初始化，可以配置 <strong>可用网络</strong>、<strong>Cookie</strong>、<strong>安全性</strong>、<strong>缓存策略</strong>、<strong>自定义协议</strong>、<strong>启动事件</strong> 等选项，以及用于移动设备优化的相关选项。</li><li>几乎可以配置任何选项。</li></ul></li><li><strong><code>NSURLSessionTask</code></strong><ul><li>一个抽象类，其子类可以创建不同类型的任务（Task），如：下载、上传、获取数据（如：JSON 或 XML）。</li><li>在特定 URL Session 中执行。</li></ul></li></ul><p>结合上述系统结构图，我们可以将 <code>NSURLSession</code> 中的类分为以下 6 种（如下图所示）：</p><ul><li><strong>URL 加载</strong>（URL Loading）</li><li><strong>配置管理</strong>（Configuration Management）</li><li><strong>缓存管理</strong>（Cache Policy）</li><li><strong>Cookie 存储</strong>（Cookie Storage）</li><li><strong>认证和证书</strong>（Authentication and Credentials）</li><li><strong>协议支持</strong>（Protocol Support）</li></ul><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/url-loading-system-classes.png?x-oss-process=image/resize,w_600" alt=""></div><p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据 <strong>缓存策略（Cache Policy）</strong> 以及 <strong>可用性（availability）</strong> 的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应，以便将来的请求可以使用。</p><p>在一个请求被发送到服务器过程中，服务器可能会发出 <strong>鉴权查询（Authorization Challenge）</strong>，这可以由共享的 Cookie 或 <strong>证书存储（Credential Storage）</strong> 来自动响应，或者由被委托对象来响应。此外，发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要时改变其加载行为。</p><p>下面我们依次来详细介绍 URL 加载系统中的 3 个主要类： <code>NSURLSessionTask</code>、<code>NSURLSession</code>、<code>NSURLSessonConfiguration</code>。在 <code>NSURLSessionConfiguration</code> 中，我们将对缓存策略、Cookie 存储、自定义协议等内容稍作介绍。</p><h2 id="NSURLSessionTask"><a href="#NSURLSessionTask" class="headerlink" title="NSURLSessionTask"></a>NSURLSessionTask</h2><p><code>NSURLSessionTask</code> 是一个抽象类，其包含如下 3 个实体子类。这 3 个子类封装了 3 个最基本的网络任务：<strong>获取数据</strong>（如：JSON 或 XML）、<strong>上传文件</strong>、<strong>下载文件</strong>。</p><ul><li><code>NSURLSessionDataTask</code></li><li><code>NSURLSessionUploadTask</code></li><li><code>NSURLSessionDownloadTask</code></li></ul><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-class.png?x-oss-process=image/resize,w_600" alt=""></div><p>上图所示为这些类之间的继承关系。对于 <code>NSURLSessionDataTask</code>，服务器会有响应数据；而对于上传请求，服务器也会有响应数据，所以 <code>NSURLSessionUploadTask</code> 继承自 <code>NSURLSessionDataTask</code>。<code>NSURLSessionDownloadTask</code> 完成时，会带回已下载文件的一个临时的文件路径。</p><p>关于 <code>NSURLSessionTask</code> 的数据返回方式，主要有两种方式：</p><ul><li><strong><code>completionHandler</code> 回调</strong></li><li><strong><code>NSURLSessionDelegate</code> 代理</strong></li></ul><p>通过 <code>completionHandler</code> 回调将会创建一个隐式的代理（delegate），从而替代该 Task 原来的代理 —— Session。</p><p>对于需要 override 原有 Session Task 的代理的默认行为的情况，我们需要使用不带 <code>completionHandler</code> 版本。</p><p>需要注意的是，<code>NSURLSessionTask</code> 及其子类都有着各自的代理协议，它们之间也存在着如下图所示的继承关系。</p><div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/urlsessiontask-delegate.png?x-oss-process=image/resize,w_600" alt=""></div><ul><li><code>NSURLSessionDelegate</code>：定义了网络请求最基础的代理方法。作为所有代理的基类。</li><li><code>NSURLSessionTaskDelegate</code>：定义了网络请求任务相关的代理方法。</li><li><code>NSURLSessionDownloadDelegate</code>：定义了下载任务相关的代理方法，如：下载进度等</li><li><code>NSURLSessionDataDelegate</code>：定义了普通数据任务和上传任务相关的代理方法。</li></ul><p>下面简要介绍一下这三个子类。</p><h3 id="NSURLSessionDataTask"><a href="#NSURLSessionDataTask" class="headerlink" title="NSURLSessionDataTask"></a>NSURLSessionDataTask</h3><p><code>NSURLSessionDataTask</code> 主要用于 <strong>读取服务端的简单数据</strong>，如：JSON、XML 数据。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSURL 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure></p><p><strong>CompletionHandler</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p><h3 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h3><p><code>NSURLSessionUploadTask</code> 主要用于 <strong>向服务器发送文件类型的数据</strong>。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建，上传时指定文件源</span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建，上传时指定数据源   </span></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br></pre></td></tr></table></figure></p><p><strong>CompletionHandler</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p><h3 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h3><p><code>NSURLSessionDownloadTask</code> 主要用于 <strong>文件下载</strong>，它针对大文件的网络请求做了更多的处理，如：下载进度、断点续传等。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSURLRequest 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request;    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 NSURL 对象创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url;    </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用之前已经下载的数据来创建</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData;</span><br></pre></td></tr></table></figure></p><p><strong>CompletionHandler</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="built_in">NSURL</span> *)url completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="built_in">NSData</span> *)resumeData completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURL</span> *location, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error))completionHandler;</span><br></pre></td></tr></table></figure></p><h2 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h2><p><code>NSURLSession</code> 是负责请求/响应的关键对象，使用 <code>NSURLSessionConfiguration</code> 配置对象进行创建。</p><p><code>NSURLSession</code> 本身并不会进行请求，而是通过创建 Task 的形式来进行网络请求。同一个 <code>NSURLSession</code> 可以创建多个 Task，并且这些 Task 之间的 Cache 和 Cookie 是共享的。</p><p><code>NSURLSession</code> 在管理请求/响应的过程中会调用相关的代理方法。这些代理方法主要分两类：</p><ul><li><strong>Session 的委托对象实现的代理方法（<code>NSURLSessionDelegate</code> 定义的方法）</strong><ul><li>主要用于处理连接层问题，如：服务器信任、客户端证书认证、NTLM 和 Kerberos 协议等问题</li></ul></li><li><strong>Task 的委托对象实现的代理方法（<code>NSURLSessionTaskDelegate</code> 及其子协议定义的方法）</strong><ul><li>主要用于处理以网络请求为基础的问题，如：Basic，Digest，<strong>代理身份验证（Proxy Authentication）</strong> 等。</li></ul></li></ul><h2 id="NSURLSessionConfiguration"><a href="#NSURLSessionConfiguration" class="headerlink" title="NSURLSessionConfiguration"></a>NSURLSessionConfiguration</h2><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 进行初始化。</p><p><code>NSURLSessionConfiguration</code> 对以前 <code>NSMutableURLRequest</code> 所提供的网络请求层的设置选项进行了扩充，提供给开发者相当大的灵活性和控制权。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，可以发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何想要进行配置的选项。</p><p><code>NSURLSession</code> 在初始化时会把配置它的 <code>NSURLSessionConfiguration</code> 对象进行一次深拷贝，并保存到自己的 <code>configuration</code> 属性中，而且这个属性是只读的。也就是说，<code>configuration</code> 只在初始化时被读取一次，之后都是不会变化的。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>NSURLSessionConfiguration</code> 有三个类工厂方法：</p><ul><li><strong><code>+ defaultSessionConfiguration</code></strong><ul><li>返回一个标准的配置，具有共享 <code>NSHTTPCookieStorage</code>、共享 <code>NSURLCache</code>、共享 <code>NSURLCredentialStorage</code>。</li></ul></li><li><strong><code>+ ephemeralSessionConfiguration</code></strong><ul><li>返回一个预设的配置，该配置中不会对缓存、Cookie和证书进行持久性存储。这对于实现类似秘密浏览这种功能来说是很理想的。</li></ul></li><li><strong><code>+ backgroundSessionConfiguration:(NSString *)identifier</code></strong><ul><li>创建一个后台 Session。后台 Session 不同于普通 Session，后台 Session 可以在应用程序挂起、退出或崩溃的情况下进行上传/下载任务。初始化时指定的标识符，可用于向任何可能在进程外恢复后台传输的 <strong>守护进程（daemon）</strong> 提供上下文。</li></ul></li></ul><h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p><code>NSURLSessionConfiguration</code> 拥有数十个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。</p><h4 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *HTTPAdditionalHeaders</span><br></pre></td></tr></table></figure><p><code>HTTPAdditionalHeaders</code> 为基于 configuration 的 Session 生成的所有 Task 中的 <code>NSRULRequest</code> 对象添加额外的请求头部字段。默认为空。</p><p><code>NSURLSession</code> 默认为 <code>NSURLRequest</code> 对象添加了如下请求头部字段：</p><ul><li><code>Authorization</code></li><li><code>Connection</code></li><li><code>Host</code></li><li><code>Proxy-Authenticate</code></li><li><code>Proxy-Authorization</code></li><li><code>WWW-Authenticate</code></li></ul><p>如果在 <code>HTTPAdditionalHeaders</code> 自定义的头部字段与 <code>NSURLRequest</code> 对象重复了，则优先使用 <code>NSURLRequest</code> 对象中的请求头部字段。</p><p>利用 <code>HTTPAddtionalHeaders</code> 可以添加如下这些请求头部字段：</p><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>User-Agent</code></li><li>…</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType</span><br></pre></td></tr></table></figure><p>指定网络传输类型。可以让操作系统快速响应，提高传输质量，延长电池寿命等。大多数应用程序都不需要设置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> allowsCellularAccess</span><br></pre></td></tr></table></figure><p>是否使用蜂窝网络。默认是 <code>YES</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForRequest</span><br></pre></td></tr></table></figure><p>指定请求的超时间隔。默认为 60s。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForResource</span><br></pre></td></tr></table></figure><p>指定资源的超时间隔。默认是7天。</p><h4 id="Cookie-策略"><a href="#Cookie-策略" class="headerlink" title="Cookie 策略"></a>Cookie 策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSHTTPCookieStorage</span> *HTTPCookieStorage;</span><br></pre></td></tr></table></figure><p>存储了 Session 所使用的 Cookie。默认情况下会使用 <code>NSHTTPCookieStorage</code> 的 <code>+ sharedHTTPCookieStorage</code> 单例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> HTTPShouldSetCookies;</span><br></pre></td></tr></table></figure><p>指定了请求是否应该使用 Session 存储的 Cookie，即 <code>HTTPCookieStorage</code> 属性的值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSHTTPCookieAcceptPolicy</span> HTTPCookieAcceptPolicy;</span><br></pre></td></tr></table></figure><p>决定了什么情况下 Session 应该接受从服务器发出的 Cookie。</p><h4 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSURLCredentialStorage</span> *URLCredentialStorage;</span><br></pre></td></tr></table></figure><p>存储了 Session 所使用的证书。默认情况下会使用 <code>NSURLCredentialStorage</code> 的 <code>+ sharedCredentialStorage</code> 单例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMaximumSupportedProtocol;</span><br><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMinimumSupportedProtocol;</span><br></pre></td></tr></table></figure><p>两者确定 Session 是否支持 SSL 协议。</p><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="built_in">NSURLCache</span> *URLCache;</span><br></pre></td></tr></table></figure><p>Session 使用的缓存。默认情况下会使用 <code>NSURLCache</code> 的 <code>+ sharedURLCache</code> 单例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestCachePolicy</span> requestCachePolicy;</span><br></pre></td></tr></table></figure><p>指定了一个请求的缓存响应应该在什么时候返回。</p><h4 id="后台传输"><a href="#后台传输" class="headerlink" title="后台传输"></a>后台传输</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *identifier</span><br></pre></td></tr></table></figure><p>仅当使用 <code>backgroundSessionConfigurationWithIdentifier:</code> 方法创建配置对象时，才会设置此属性的值。<code>identifier</code> 唯一标识 <strong>后台会话</strong> 对象。</p><p>如果应用程序在后台任务进行传输时终止，可以使用 <code>identifier</code> 在应用程序重新启动时，重新创建 <code>configuration</code> 和 <code>session</code> 对象与 之前传输进行关联。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> sessionSendsLaunchEvents;</span><br></pre></td></tr></table></figure><p>设置传输结束时是否应该在后台恢复或启动应用程序。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">getter</span>=isDiscretionary) <span class="built_in">BOOL</span> discretionary;</span><br></pre></td></tr></table></figure><p>设置后台 Task 是否可以由系统进行调度，从而获得最佳性能。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldUseExtendedBackgroundIdleMode;</span><br></pre></td></tr></table></figure><p>设置应用程序切换至后台时是否保持打开 TCP 连接。</p><h4 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;Class&gt; *protocolClasses;</span><br></pre></td></tr></table></figure><p>用来配置特定某个 Session 所使用的自定义协议（该协议是 <code>NSURLProtocol</code> 的子类）的数组。</p><h4 id="多路径-TCP"><a href="#多路径-TCP" class="headerlink" title="多路径 TCP"></a>多路径 TCP</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLSessionMultipathServiceType</span> multipathServiceType;</span><br></pre></td></tr></table></figure><p>指定通过 Wi-Fi 和 蜂窝网络传输数据的多路径 TCP 的连接策略。</p><h4 id="HTTP-策略与代理"><a href="#HTTP-策略与代理" class="headerlink" title="HTTP 策略与代理"></a>HTTP 策略与代理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> HTTPMaximumConnectionsPerHost;</span><br></pre></td></tr></table></figure><p>用于限制连接到特定主机的数量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> HTTPShouldUsePipelining;</span><br></pre></td></tr></table></figure><p>用于开启 HTTP 流水线（HTTP pipelining），可以显着减少请求的加载时间，但是由于没有被服务器广泛支持，默认是 <code>NO</code> 的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *connectionProxyDictionary;</span><br></pre></td></tr></table></figure><p>指定了 Session 连接中的代理服务器</p><h1 id="NSURLSession-使用"><a href="#NSURLSession-使用" class="headerlink" title="NSURLSession 使用"></a>NSURLSession 使用</h1><p><code>NSURLSession</code> 的使用有如下几个步骤：</p><ol><li>创建会话：基于 <code>NSURLSessionConfiguration</code> 对象创建 <code>NSURLSession</code> 对象</li><li>创建任务：基于 <code>NSURLSession</code> 对象创建 <code>NSURLSessionTask</code> 对象</li><li>执行任务：执行 <code>NSURLSessionTask</code> 对象</li></ol><h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p>会话的创建方式有三种：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接创建，使用默认的 NSURLSessionConfiguration 配置</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置后创建，先初始化一个 NSURLSessionConfiguration 对象</span></span><br><span class="line">[<span class="built_in">NSURLSession</span> sessionWithConfiguration:defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置加代理获得</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]</span><br><span class="line">                                                      delegate:<span class="keyword">self</span></span><br><span class="line">                                                 delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br></pre></td></tr></table></figure></p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>任务的创建在上文介绍 <strong><code>NSURLSessionTask</code></strong> 时已经提到。这里不做赘述。</p><h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建会话</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建任务</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.xxx.com/login?username=myName&amp;pwd=myPsd"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">// 打印解析后的json数据</span></span><br><span class="line">    <span class="comment">// NSLog(@"%@", [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行任务</span></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建会话</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建任务</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.xxx.com/login"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建请求对象里面包含请求体</span></span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line">request.HTTPBody = [<span class="string">@"username=myName&amp;pwd=myPsd"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">// 打印解析后的json数据</span></span><br><span class="line">    <span class="comment">// NSLog(@"%@", [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span></span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行任务</span></span><br><span class="line"> [task resume];</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 <code>NSURLConnection</code> 进行深思熟虑后的一个自然而然的进化。尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 <code>NSURLSession</code> 仍然是实现更高级别网络功能的一个强大的基础框架。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc" target="_blank" rel="noopener">URL Loading System</a></li><li><a href="https://juejin.im/post/5a69f8366fb9a01cb42c90bc" target="_blank" rel="noopener">URL Loading System 概览</a></li><li><a href="https://juejin.im/entry/58aacabcac502e006973ce03" target="_blank" rel="noopener">iOS NSURLSession 详解</a></li><li><a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started" target="_blank" rel="noopener">URLSession Tutorial: Getting Started</a></li><li><a href="https://developer.apple.com/documentation/foundation/nsmutableurlrequest?language=objc" target="_blank" rel="noopener">NSMutableURLRequest</a></li><li><a href="https://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a></li><li><a href="https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/" target="_blank" rel="noopener">From NSURLConnection to NSURLSession</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司针对刚入职的应届毕业生开展了一个的“新牛计划”，目的是让他们能够在一个月的时间内从零基础成长为 iOS 开发新手。&lt;/p&gt;
&lt;p&gt;在这个过程中，我们需要承担讲师的角色。因此，我们对 iOS 开发的知识体系进行了划分，而我则负责讲解其中的 GCD 和网络相关部分。为此
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="NSURLSession" scheme="http://chuquan.me/tags/NSURLSession/"/>
    
  </entry>
  
  <entry>
    <title>澳洲自驾游</title>
    <link href="http://chuquan.me/2019/07/11/australia-from-sydeny-to-brisbane/"/>
    <id>http://chuquan.me/2019/07/11/australia-from-sydeny-to-brisbane/</id>
    <published>2019-07-11T13:21:36.000Z</published>
    <updated>2019-09-07T15:25:21.017Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight216.jpg?x-oss-process=image/resize,w_600" alt=""></div><a id="more"></a><p>今年的年度旅游，我们部门分成了多个团体自行安排旅游。我们 8 个人（@社会瑞哥、@海侠、@捧鹏、@拢龙、@佳欣、@底迪、@雪洁、@我）组成了一个澳洲团（自诩：卢瑟天团），来了一次自驾游：从悉尼到布里斯班。</p><p>这次行程基本都是 @佳欣 安排，我差不多全程属于放空状态，有时甚至连自己在哪里都不知道。8 人自驾游租了两辆 SUV，司机分别是 @社会瑞哥、@捧鹏。</p><p>出游前，我就计划这次旅行尝试一下做旅拍。为此，我刷了一些 YouTube 上的大神们的作品，如：KOLD。大神们的作品对我这种菜鸟新手来说难度太高，实际操作起来非常困难。于是我又刷了一些入门级拍摄技巧的视频教程，如：HeyDrones。为此，我还租了GoPro 7 Hero Black 运动相机和 Mavic Air 无人机。</p><p>关于 GoPro 和无人机的使用体验。我全程基本都是在用 GoPro 进行视频拍摄，性价比特别高。无人机使用相对就少了很多，首先续航时间短，只有20分钟，实际电池电量剩 20% 时就提示自动返航了。另外，再加上天气、限飞、周围环境等因素，体验并不是很好。不过，无人机拍出来的效果的确逼格提升了不少。所以，还是逃不出“真香”定理，不出意外，以后旅游我还会带上无人机。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>From 北京 to 深圳，From 深圳 to 悉尼。</p><p>在北京飞深圳的航班上，看到一团云挺好看，顺手拍了张照片。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight191.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>深圳机场的晚霞还是挺好看的。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight194.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>从深圳起飞，拍了张深圳上空照片（很难得的角度）。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight193.jpg?x-oss-process=image/resize,w_400" alt=""></p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>飞机上一觉醒来便是凌晨，转头便看到了日月同辉前的一幕美景。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight197.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>抵达悉尼机场，第一个任务便是租车。然后便是前往悉尼歌剧院。可能是大家很疲惫吧，只是在歌剧院脚下拍了些照片，没有人提出去对岸拍它的全景。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight199.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight200.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_3898.JPG?x-oss-process=image/resize,w_600" alt=""></p><p>然后就是逛了下歌剧院旁边的皇家植物园。<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight202.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>汉堡王之后，就驱车两小时去山里找我们的爱彼迎民宿。刚进入别墅时，我们所有人都是刘姥姥进大观园的状态。别墅建在山坡上，一种后战争（Post War）风格的建筑，自带车库，露天大阳台（配有烧烤架），二层有小花园，三层有大花园。@地址：22 Bildera Place, Grays Point, 新南威尔士州 2232。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight207.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight206.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight209.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>旅行的开始总是兴奋的。是晚，便来了一次自制火锅。晚餐过后便是拍照时间，山寨了一次“我爱我家”的经典场景。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_4305.JPG?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>前一晚，玩桌游差不多到凌晨 2：00。这一天是预料中的晚起，下午出门去悉尼大学。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight219.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight217.jpg?x-oss-process=image/resize,w_600" alt=""><br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight214.jpg?x-oss-process=image/resize,w_600" alt=""></p><p>差不多逛到一般吧，@拢龙 便叫我去打球。商场的车库后面，有一个街头篮球场。和当地人来了次比赛，5 VS 6，对方 3 男 3 女。比赛以一个女生膝盖受伤而告终。不过不得不感慨，澳洲人的身体素质是真好，这个场地就有两人能扣篮…</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/IMG_3951.JPG?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>这天开始挪地方，先是驱车去了猎人谷参观了当地历史最悠久的酒庄 Audery Wikinson。可惜季节不是很好，并没有看到满山的葡萄，不过惊喜的是，遇到了野生的袋鼠。</p><p>参观结束便是驱车前往预订的一个位于富人社区的爱彼迎民宿，自带泳池的那种。@地址：68 O’Shea Circuit，赛斯诺克，新南威尔士州 2325。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/FullSizeRender.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>按计划前往斯蒂芬斯港转了一圈。当晚入住一个平民民宿。@地址：1315 Lemon Tree Passage Road，Lemon。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight243.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight220.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight226.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>自驾 5 小时，抵达汽车旅馆。旅馆也有泳池，可惜天气太冷，有没尝试。@地址：阿曲亚吉汽车旅馆 49 Park Beach Road，科夫斯港，2450。</p><p>Check In 之后，我和 @拢龙 便按计划去找篮球场打球。可惜当地的篮球馆很早就关门了。我们好不容易找到一个室外场，装了下逼，拍了些照。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight224.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>驱车三小时去拜伦湾，原本打算跳伞，然而下雨了…于是乎前往下一个目的地——拜伦角灯塔。这天是阴雨天，灯塔附近的风浪非常大，我们摆拍了一些照片后就离开了。</p><p>在拜伦湾小镇吃了个午饭后，我们就去酒店办理入住。@地址：发现假日酒店 399 Ewingsdale Road，拜伦湾，2481。</p><p>这个公园酒店很大，就如其名字一样，是一个大公园，内部有很多房车式的独栋小房子，就是游客的住所。</p><p>行李整顿完毕之后，闲逛了下公园，遇到一群小孩，拍了短视频。</p><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Videoleap-216A7632-23B2-4CF2-A02C-8B5E675A75B1.MOV" type="video/mov" controls="controls" width="60%" height="60%"></video></div><p>之后，我们又是去找篮球馆。我们找到一个高级篮球馆。这个篮球馆每周工作日晚上都会举行比赛，周六下午才对外开放。据我们了解，拜伦湾当地有十二支业余球队，每支球队都由少年、青年、老年不同年龄段的人组成。篮球水平在业余中属于比较高的水平，有不少能扣篮的人。至此，我们算是了解到了澳洲民间篮球的真实水平了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight233.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight234.jpg?x-oss-process=image/resize,w_600" alt=""></p><h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><p>前往布里斯班，中途经过黄金海岸。季节不适，风浪很大，稍作逗留便离开了。</p><p>然后前往市中心，入住了当地一家酒店。@地址：Hotel Grand Chancellor</p><p>当天晚上就是代购，各种买买买。</p><h1 id="Day-9"><a href="#Day-9" class="headerlink" title="Day 9"></a>Day 9</h1><p>驱车去龙伯考拉动物园，看了些动物表演，包括：飞禽、牧羊犬。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight231.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight232.jpg?x-oss-process=image/resize,w_600" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight230.jpg?x-oss-process=image/resize,w_800" alt=""></p><h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><p>From 布里斯班 to 广州，From 广州 to 北京。</p><div align="center"><video src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Videoleap-3169FC88-2225-42CC-B360-4EC21496D948.MOV" type="video/mov" controls="controls" width="60%" height="60%"></video></div><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/Australia/Enlight216.jpg?x-oss-process=image/resize,w_600&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="澳大利亚" scheme="http://chuquan.me/tags/%E6%BE%B3%E5%A4%A7%E5%88%A9%E4%BA%9A/"/>
    
      <category term="悉尼" scheme="http://chuquan.me/tags/%E6%82%89%E5%B0%BC/"/>
    
      <category term="布里斯班" scheme="http://chuquan.me/tags/%E5%B8%83%E9%87%8C%E6%96%AF%E7%8F%AD/"/>
    
      <category term="自驾游" scheme="http://chuquan.me/tags/%E8%87%AA%E9%A9%BE%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控(2)——卡顿</title>
    <link href="http://chuquan.me/2019/06/17/ios-performance-monitor-caton/"/>
    <id>http://chuquan.me/2019/06/17/ios-performance-monitor-caton/</id>
    <published>2019-06-16T16:35:07.000Z</published>
    <updated>2019-06-17T03:12:00.674Z</updated>
    
    <content type="html"><![CDATA[<p>前文 <a href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">iOS 性能监控(1)——CPU、Memory、FPS</a> 探讨了 iOS 中进行线上监控 CPU、Memory、FPS 等指标的原理以及具体实现方法。本文则继续探讨如何在 iOS 中进行线上监控卡顿的原理及实现。</p><h1 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h1><h2 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h2><p>那么为什么会出现卡顿呢？为了解释这个问题首先需要了解一下屏幕图像的显示原理。首先从 CRT 显示器原理说起，如下图所示。CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，显示器会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 <strong>HSync</strong>；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 <strong>VSync</strong>。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。虽然现在的显示器基本都是液晶显示屏了，但其原理基本一致。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-screen-scan.png?x-oss-process=image/resize,w_400" alt=""></p><p>下图所示为常见的 CPU、GPU、显示器工作方式。CPU 计算好显示内容（如：视图的创建、布局计算、图片解码、文本绘制）提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-renderIng-gpu-internal-structure.png?x-oss-process=image/resize,w_500" alt=""></p><p>最简单的情况下，帧缓冲区只有一个。此时，帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，GPU 通常会引入两个缓冲区，即 <strong>双缓冲机制</strong>。事实上，iPhone 使用的就是双缓冲机制。在这种情况下，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/gpu-double-buffer.png?x-oss-process=image/resize,w_800" alt=""></p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-vsync-off.jpg?x-oss-process=image/resize,w_500" alt=""></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。当 CPU 和 GPU 计算量比较大时，一旦它们的完成时间错过了下一次 C-Sync 的到来（通常是 1000/6=16.67ms），这样就会出现显示屏还是之前帧的内容，这就是界面卡顿的原因。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios_frame_drop.png?x-oss-process=image/resize,w_500" alt=""></p><h2 id="FPS-卡顿监控方案"><a href="#FPS-卡顿监控方案" class="headerlink" title="FPS 卡顿监控方案"></a>FPS 卡顿监控方案</h2><p>FPS 卡顿监控方案的原理是 <strong>通过一段连续的 FPS 计算丢帧率来衡量当前页面绘制的质量</strong>。</p><p>具体实现方式可以通过 <a href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/">iOS 性能监控(1)——CPU、Memory、FPS</a> 一文中的 FPS 监控方法进行 FPS 数据采集，然后处理数据。这里不做多余的介绍。</p><h2 id="主线程卡顿监控方案"><a href="#主线程卡顿监控方案" class="headerlink" title="主线程卡顿监控方案"></a>主线程卡顿监控方案</h2><p>主线程卡顿监控方案的原理是 <strong>通过子线程监控主线程的 RunLoop，判断两个状态区域之间的耗时是否达到一定阈值</strong>。因为主线程绝大部分计算或绘制任务都是以 RunLoop 为单位发生。单次 RunLoop 如果时长超过 16ms，就会导致 UI 体验的卡顿。</p><p>美团的移动端性能监控方案 Hertz 采用的就是这种方式。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-performance-monitor-caton01.png?x-oss-process=image/resize,w_500" alt=""></p><p>首先我们需要了解一下 RunLoop 的原理。</p><h3 id="RunLoop-定义"><a href="#RunLoop-定义" class="headerlink" title="RunLoop 定义"></a>RunLoop 定义</h3><p>RunLoop 是 iOS 事件响应与任务处理最核心的机制。当有持续的异步任务需求时，我们会创建一个独立的生命周期可控的线程。<strong>RunLoop 就是控制线程生命周期并接收事件进行处理的机制</strong>。</p><h3 id="RunLoop-机制"><a href="#RunLoop-机制" class="headerlink" title="RunLoop 机制"></a>RunLoop 机制</h3><p><strong>主线程（有 RunLoop 的线程）几乎所有函数都从以下六个函数之一的函数调起：</strong></p><ol><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</code><ul><li>CFRunloop is calling out to an abserver callback function</li><li>用于向外部报告 RunLoop 当前状态的改变，框架中很多机制都由 RunLoopObserver 触发，如：CAAnimation</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</code><ul><li>CFRunloop is calling out to a block</li><li>消息通知、非延迟的 perform、dispatch 调用、block 回调、KVO</li></ul></li><li><code>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</code><ul><li>CFRunloop is servicing the main dispatch queue</li><li>执行主队列上的任务</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</code><ul><li>CFRunloop is calling out to a timer callback function</li><li>基于定时器的延迟的 perfrom，dispatch 调用</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</code><ul><li>CFRunloop is calling out to a source 0 perform function</li><li>处理 App 内部事件、App自己负责管理（触发），如：<code>UIEvent</code>、<code>CFSocket</code>。普通函数调用，系统调用</li></ul></li><li><code>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</code><ul><li>CFRunloop is calling out to a source 1 perform function</li><li>由 RunLoop 和内核管理，Mach port 驱动，如：<code>CFMachPort</code>、<code>CFMessagePort</code></li></ul></li></ol><h3 id="RunLoop-运行时"><a href="#RunLoop-运行时" class="headerlink" title="RunLoop 运行时"></a>RunLoop 运行时</h3><p>如下所示为 <code>CFRunLoop</code> 源码中的核心方法 <code>CFRunLoopRun</code> 简化后的主要逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">int32_t __CFRunLoopRun() &#123;</span><br><span class="line">    // 1. 通知 Observers：即将进入 RunLoop</span><br><span class="line">    __CFRunLoopDoObservers(KCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        // 2. 通知Observers：即将要处理 timer</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</span><br><span class="line">        // 3. 通知Observers：即将要处理 source</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        // 处理非延迟的主线程调用</span><br><span class="line">        __CFRunLoopDoBlocks();</span><br><span class="line">        // 处理 UIEvent 事件</span><br><span class="line">        __CFRunLoopDoSource0();</span><br><span class="line">    </span><br><span class="line">        // GCD dispatch main queue</span><br><span class="line">        CheckIfExistMessagesInMainDispatchQueue();</span><br><span class="line">    </span><br><span class="line">        // 4. 通知 Observers：即将进入休眠等待</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        // 等待内核mach_msg事件</span><br><span class="line">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</span><br><span class="line">        </span><br><span class="line">        // mach_msg_trap</span><br><span class="line">        // 休眠中 Zzz...</span><br><span class="line">        // Received mach_msg, wake up</span><br><span class="line">        </span><br><span class="line">        // 5. 通知 Observers：从休眠等待中醒来</span><br><span class="line">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        if (wakeUpPort == timerPort) &#123;</span><br><span class="line">            // 处理因timer的唤醒</span><br><span class="line">            __CFRunLoopDoTimers();</span><br><span class="line">        &#125; else if (wakeUpPort == mainDispatchQueuePort) &#123;</span><br><span class="line">            // 处理异步方法唤醒，如：dispatch_async</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // UI 刷新，动画显示</span><br><span class="line">            __CFRunLoopDoSource1();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 再次确保是否有同步的方法需要调用</span><br><span class="line">        __CFRunLoopDoBlocks()</span><br><span class="line">    &#125; while(!stop &amp;&amp; !timeout);</span><br><span class="line">    </span><br><span class="line">    // 6. 通知 Observers：即将退出runloop</span><br><span class="line">    __CFRunLoopDoObservers(CFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RunLoop 在运行时一直在向外部报告当前状态的更新，其状态定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry ,           // 进入 loop</span><br><span class="line">    kCFRunLoopBeforeTimers ,    // 触发 Timer 回调</span><br><span class="line">    kCFRunLoopBeforeSources ,   // 触发 Source0 回调</span><br><span class="line">    kCFRunLoopBeforeWaiting ,   // 等待 mach_port 消息</span><br><span class="line">    kCFRunLoopAfterWaiting ,    // 接收 mach_port 消息</span><br><span class="line">    kCFRunLoopExit ,            // 退出 loop</span><br><span class="line">    kCFRunLoopAllActivities     // loop 所有状态改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 RunLoop 运行逻辑中，不难发现 NSRunLoop 调用方法主要在于两个状态区间：</p><ul><li><code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopBeforeWaiting</code> 之间</li><li><code>kCFRunLoopAfterWaiting</code> 之后</li></ul><p><strong>如果这两个时间内耗时太久而无法进入下一步，可以线程受阻。如果这个线程时主线程，表现出来就是出现了卡顿。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以通过 <code>CFRunLoopObserverRef</code> 实时获取 <code>NSRunLoop</code> 的状态。具体使用方法如下：</p><p>首先创建一个 <code>CFRunLoopObserverContext</code> 观察者 <code>observer</code>。然后将观察者 <code>observer</code> 添加到主线程 RunLoop 的 <code>kCFRunLoopCommonModes</code> 模式下进行观察。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerObserver &#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。为了让计算更精确，需要让子线程更及时的获知主线程 RunLoop 状态变化，<code>dispatch_semaphore_t</code> 是一个不错的选择。另外，卡顿需要覆盖多次连续短时间卡顿和单次长时间卡顿两种情景，所以判定条件也需要做适当优化。优化后的代码实现如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerObserver &#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            0,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    // 创建信号</span><br><span class="line">    semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    // 在子线程监控时长</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        while (YES) &#123;</span><br><span class="line">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">            if (st != 0) &#123;</span><br><span class="line">                if (activity == kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    if (++timeoutCount &lt; 5)</span><br><span class="line">                        continue;</span><br><span class="line">                    </span><br><span class="line">                    NSLog(@&quot;好像有点儿卡哦&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    </span><br><span class="line">    // 记录状态值</span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">    </span><br><span class="line">    // 发送信号</span><br><span class="line">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检测到卡顿时应该立刻获取卡顿的方法堆栈信息，并推送至服务端共开发者分析，从而解决卡顿问题。</p><p>获取堆栈信息的一种方法是：<strong>直接调用系统函数</strong>。这种方法的优点是 <strong>性能消耗小</strong>。缺点是 <strong>它只能够获取简单的信息，无法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限</strong>。</p><p>直接调用系统函数的主要思路是：用 <code>signal</code> 进行错误信息获取。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static int s_fatal_signals[] = &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);</span><br><span class="line"></span><br><span class="line">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class="line">    NSArray *exceptionArray = [exception callStackSymbols];     // 得到当前调用栈信息</span><br><span class="line">    NSString *exceptionReason = [exception reason];             // 非常重要，就是崩溃的原因</span><br><span class="line">    NSString *exceptionName = [exception name];                 // 异常类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void SignalHandler(int code) &#123;</span><br><span class="line">    NSLog(@&quot;signal handler = %d&quot;,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitCrashReport() &#123;</span><br><span class="line">    // 系统错误信号捕获</span><br><span class="line">    for (int i = 0; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //oc 未捕获异常的捕获</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取堆栈信息的另一种方法是：<strong>直接使用 PLCrashReporter 第三方开源库</strong>。这种方法的优点是 <strong>能够定位到问题代码的具体位置，而且性能消耗也不大</strong>。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD     </span><br><span class="line">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</span><br><span class="line">PLCrashReporter *reporter = [[PLCrashReporter alloc] initWithConfiguration:config];</span><br><span class="line"></span><br><span class="line">// 获取数据</span><br><span class="line">NSData *lagData = [reporter generateLiveReport];</span><br><span class="line"></span><br><span class="line">// 转换成 PLCrashReport 对象</span><br><span class="line">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line"></span><br><span class="line">// 进行字符串格式化处理</span><br><span class="line">NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"></span><br><span class="line">// 将字符串上传服务器</span><br><span class="line">NSLog(@&quot;lag happen, detail below: \n %@&quot;,lagReportString);</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">计算机那些事(8)——图形图像渲染原理</a></li><li><a href="http://chuquan.me/2018/10/06/understand-ios-runloop/">Run Loop 原理详解</a></li><li><a href="https://wereadteam.github.io/2016/05/03/WeRead-Performance/" target="_blank" rel="noopener">微信读书 iOS 性能优化总结</a></li><li><a href="http://www.tanhao.me/code/151113.html/" target="_blank" rel="noopener">iOS 实时卡顿监控</a></li><li><a href="https://opensource.apple.com/source/CF/CF-1152.14/CFRunLoop.c.auto.html" target="_blank" rel="noopener">CFRunLoop.c</a></li><li><a href="https://juejin.im/post/5a94e9185188257a780dde61" target="_blank" rel="noopener">RunLoop刨根问底</a></li><li><a href="https://www.cnblogs.com/zy1987/p/4582466.html" target="_blank" rel="noopener">RunLoop 原理和核心机制</a></li><li><a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前文 &lt;a href=&quot;http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/&quot;&gt;iOS 性能监控(1)——CPU、Memory、FPS&lt;/a&gt; 探讨了 iOS 中进行线上监控 CPU、Memory
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="卡顿" scheme="http://chuquan.me/tags/%E5%8D%A1%E9%A1%BF/"/>
    
      <category term="性能监控" scheme="http://chuquan.me/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控(1)——CPU、Memory、FPS</title>
    <link href="http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/"/>
    <id>http://chuquan.me/2019/06/10/ios-performance-monitor-cpu-mem-fps/</id>
    <published>2019-06-09T16:07:17.000Z</published>
    <updated>2019-06-09T16:09:01.759Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，在公司的 App 中集成了一个性能监视器，效果如下所示。在这个过程中，扒了一些性能监测开源框架的源码，并学习了其中的原理。本文就对此做一些简要的总结。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-performance-monitor.gif?x-oss-process=image/resize,w_400" alt=""></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通常情况下，App 的性能问题并不会导致 App 不可用，但是会潜在地影响用户体验。比如：CPU 占用率过高会导致电量消耗过快，手机发热等问题。为了能够主动、高效地发现性能问题，避免 App 质量进入无人监控的状态，我们需要对 App 的性能进行监控。目前，对 App 的性能监控，主要分为 <strong>线下</strong> 和 <strong>线上</strong> 两种监控维度。</p><h1 id="线下性能监控"><a href="#线下性能监控" class="headerlink" title="线下性能监控"></a>线下性能监控</h1><p>关于线下性能监控，Xcode 内置提供了一个性能分析工具 Instruments。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/xcode-instruments-overview.jpeg?x-oss-process=image/resize,w_600" alt=""></p><p>Instruments 集成了非常多的性能检测工具，如：Leaks 可以用来监控内存泄露问题；Energy Log 可以用来监控耗电量。下图所示为 Instruments 中包含的各种性能检测工具。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/xcode-instruments-tools.jpeg?x-oss-process=image/resize,w_600" alt=""></p><p>通常，我们会在提审前使用 Instruments 对 App 进行线下的性能分析。</p><h1 id="线上性能监控"><a href="#线上性能监控" class="headerlink" title="线上性能监控"></a>线上性能监控</h1><p>线上监控一般需要遵循两个原则：</p><ol><li>监控代码与业务代码解耦</li><li>采用性能消耗最小的性能监控方案</li></ol><p>线上性能监控，主要集中在对 CPU 使用率、内存、FPS 帧率等方面的监控。下面分别介绍其各自的监控方法及原理。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU 占用率的采集原理其实很简单：<strong>App 作为进程运行时会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU 使用率的总和，就是当前 App 对 CPU 的占用率</strong>。</p><h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，XNU（X is not UNIX） 是 Darwin 的内核，一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，如文件操作和设备访问，都是由 BSD 层实现。</p><p>事实上，Mach 并不能识别 UNIX 中的所有进程，而是采用一种稍微不同的方式，使用了比进程更轻量级的概念：<strong>任务（Task）</strong>。经典的 UNIX 采用了自上而下的方式：最基本的对象是进程，然后进一步划分为一个或多个线程；Mach 则采用了自底向上的方式：最基本的单元是线程，一个或多个线程包含在一个任务中。</p><p><strong>线程</strong></p><ul><li>线程定义了 Mach 中最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据，其从设计上提供了调度所需要的大量信息。</li></ul><p><strong>任务</strong></p><ul><li>任务是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此，资源的共享实际上相当于允许对对应端口进行访问。</li></ul><p>严格来说，Mach 的任务并不是hi操作系统中所谓的进程，因为 Mach 作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。在 BSD 模型中，这两个概念有一对一的简单映射，每个 BSD 进程（即 OS X 进程）都在底层关联了一个 Mach 任务对象。实现这种映射的方法是指定一个透明的指针 <code>bsd_info</code>，Mach 对 <code>bsd_info</code> 完全无知。Mach 将内核也用任务表示（全局范围称为 <code>kernel_task</code>），尽管该任务没有对应的 PID，但可以想象 PID 为 0。</p><p>下图所示为权威著作《OS X Internal: A System Approach》中提供的 Mach OS X 中进程子系统组成的概念图。与 Mac OS X 类似，iOS 的线程技术也是基于 Mach 线程技术实现的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/mach-task-thread-system.png?x-oss-process=image/resize,w_800" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>上述提到线程表示的是底层的机器寄存器状态以及各种给调度统计数据。再来看 Mach 层中的 <code>thread_basic_info</code> 结构体的定义，其成员信息也证实了这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct thread_basic_info &#123;</span><br><span class="line">        time_value_t    user_time;      // 用户运行时长</span><br><span class="line">        time_value_t    system_time;    // 系统运行时长</span><br><span class="line">        integer_t       cpu_usage;      // CPU 使用率</span><br><span class="line">        policy_t        policy;         // 调度策略</span><br><span class="line">        integer_t       run_state;      // 运行状态</span><br><span class="line">        integer_t       flags;          // 各种标记</span><br><span class="line">        integer_t       suspend_count;  // 暂停线程的计数</span><br><span class="line">        integer_t       sleep_time;     // 休眠时间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>每个线程都有这个结构体，所以我们只需要定时去遍历每个线程，累加每个线程的 <code>cpu_usage</code> 字段的值，就可以得到当前 App 所在进程的 CPU 使用率。</p><p>如下所示为 <strong>CPU 占用率</strong> 的代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 获取 CPU 使用率</span><br><span class="line">+ (CGFloat)cpuUsageForApp &#123;</span><br><span class="line">    kern_return_t           kr;</span><br><span class="line">    thread_array_t          thread_list;</span><br><span class="line">    mach_msg_type_number_t  thread_count;</span><br><span class="line">    thread_info_data_t      thinfo;</span><br><span class="line">    mach_msg_type_number_t  thread_info_count;</span><br><span class="line">    thread_basic_info_t     basic_info_th;</span><br><span class="line"></span><br><span class="line">    // 根据当前 task 获取所有线程</span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    if (kr != KERN_SUCCESS)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    float total_cpu_usage = 0;</span><br><span class="line">    // 遍历所有线程</span><br><span class="line">    for (int i = 0; i &lt; thread_count; i++) &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        // 获取每一个线程信息</span><br><span class="line">        kr = thread_info(thread_list[i], THREAD_BASIC_INFO, (thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">        if (kr != KERN_SUCCESS)</span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">        basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line">        if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            // cpu_usage : Scaled cpu usage percentage. The scale factor is TH_USAGE_SCALE.</span><br><span class="line">            // 宏定义 TH_USAGE_SCALE 返回 CPU 处理总频率：</span><br><span class="line">            total_cpu_usage += basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注意方法最后要调用 vm_deallocate，防止出现内存泄漏</span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">    return total_cpu_usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用 <code>task_threads</code> API 调用获取指定的 task 的线程列表。<code>task_threads</code> 将 <code>target_task</code> 任务中的所有线程保存在 <code>act_list</code> 数组中，数组包含 <code>act_listCnt</code> 个条目。上述源码中，在调用 <code>task_threads</code> API 时，<code>target_task</code> 参数传入的是 <code>mach_task_self()</code>，表示获取当前的 Mach task。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t task_threads</span><br><span class="line">(</span><br><span class="line">task_t target_task,</span><br><span class="line">thread_act_array_t *act_list,</span><br><span class="line">mach_msg_type_number_t *act_listCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>在获取到线程列表后，代码中使用 <code>thread_info</code> API 调用获取指定线程的线程信息。<code>thread_info</code> 查询 <code>flavor</code> 指定的线程信息，将信息返回到长度为 <code>thread_info_outCnt</code> 字节的 <code>thread_info_out</code> 缓存区中。上述源码，在调用 <code>thread_info</code> API 时，<code>flavor</code> 参数传入的是 <code>THREAD_BASIC_INFO</code>，使用这个类型会返回线程的基本信息，即 <code>thread_basic_info_t</code> 结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t thread_info</span><br><span class="line">(</span><br><span class="line">thread_act_t target_act,</span><br><span class="line">thread_flavor_t flavor,</span><br><span class="line">thread_info_t thread_info_out,</span><br><span class="line">mach_msg_type_number_t *thread_info_outCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>上述源码的最后，使用 <code>vm_deallocate</code> API 以防止出现内存泄露。</p><p>使用该方法采集到的 CPU 数据与腾讯的 GT、Instruments 数据接近。事实上，GT 也是采用这种方法采集 CPU 数据。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>通过上述 CPU 占用率监控原理，我们可以联想：内存使用情况是否也可以通过类似的方式获取到呢？答案是肯定的。</p><h3 id="相关系统原理-1"><a href="#相关系统原理-1" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>内存是有限且系统共享的资源，一个程序占用越多，系统和其他程序所能用的就越少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也会占用一定的内存资源。减少内存占用也能同时减少其对 CPU 时间维度上的消耗，从而使不仅使 App 以及整个系统也都能表现的更好。</p><p>MacOS 和 iOS 都采用了虚拟内存技术来突破物理内存的大小限制，每个进程都有一段由多个大小相同的页（Page）所构成的逻辑地址空间。处理器和内存管理单元（MMU，Memory Management Unit）维护着由逻辑地址到物理地址的 <strong>页面映射表</strong>（简称 <strong>页表</strong>），当程序访问逻辑内存地址时，由 MMU 根据页表将逻辑地址转换为真实的物理地址。在早期的苹果设备中，每个页的大小为 4KB；基于 A7 和 A8 处理器的系统为 64 位程序提供了 16KB 的虚拟内存分页和 4KB 的物理内存分页；在 A9 之后，虚拟内存和物理内存的分页大小都达到了 16KB。</p><p>虚拟内存分页（Virtual Page，VP）有两种类型：</p><ol><li>Clean：指能够被系统清理出内存且在需要时能重新加载的数据，包括：<ul><li>内存映射文件</li><li>Frameworks 中的 __DATA_CONST 部分</li><li>应用的二进制可执行文件</li></ul></li><li>Dirty：指不能被系统回收的内存占用，包括：<ul><li>所有堆上的对象</li><li>图片解码缓冲数据</li><li>Framework 中的 <strong>DATA 和 </strong>DATA_DIRTY 部分</li></ul></li></ol><p>由于内存容量和读写寿命的限制，iOS 上没有 Disk Swap 机制，取而代之使用 <strong>Compressed Memory</strong> 技术。 Disk Swap 是指在 macOS 以及一些其他桌面操作系统中，当内存可用资源紧张时，系统将内存中的内容写入磁盘中的backing store（Swapping out），并且在需要访问时从磁盘中再读入 RAM（Swapping in）。与大多数 UNIX 系统不同的是，macOS 没有预先分配磁盘中的一部分作为 backing store，而是利用引导分区所有可用的磁盘空间。</p><p>苹果最初只是公开了从 OS X Mavericks 开始使用 Compressed Memory 技术，但 iOS 系统也从 iOS 7 开始悄悄地使用。</p><p>Compressed Memory 技术在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，其特点可以归结为：</p><ul><li>减少了不活跃内存占用</li><li>改善电源效率，通过压缩减少磁盘 IO 带来的损耗</li><li>压缩/解压非常快，能够尽可能减少 CPU 的时间开销</li><li>支持多核操作</li></ul><p>本质上，Compressed Memory 也是 Dirty Memory。因此，<strong>memory footprint = dirty size + compressed size</strong>，这也是我们需要并且能够尝试去减少的内存占用。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>在 <code>/usr/include/mach/task_info.h</code> 中，我们可以看到 <code>mach_task_basic_info</code> 和 <code>task_basic_info</code> 结构体的定义，分别如下所示。事实上，苹果公司已经不建议再使用 <code>task_basic_info</code> 结构体了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define MACH_TASK_BASIC_INFO     20         /* always 64-bit basic info */</span><br><span class="line">struct mach_task_basic_info &#123;</span><br><span class="line">        mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">        mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">        mach_vm_size_t  resident_size_max;  /* maximum resident memory size (bytes) */</span><br><span class="line">        time_value_t    user_time;          /* total user run time for</span><br><span class="line">                                               terminated threads */</span><br><span class="line">        time_value_t    system_time;        /* total system run time for</span><br><span class="line">                                               terminated threads */</span><br><span class="line">        policy_t        policy;             /* default policy for new threads */</span><br><span class="line">        integer_t       suspend_count;      /* suspend count for task */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* localized structure - cannot be safely passed between tasks of differing sizes */</span><br><span class="line">/* Don&apos;t use this, use MACH_TASK_BASIC_INFO instead */</span><br><span class="line">struct task_basic_info &#123;</span><br><span class="line">        integer_t       suspend_count;  /* suspend count for task */</span><br><span class="line">        vm_size_t       virtual_size;   /* virtual memory size (bytes) */</span><br><span class="line">        vm_size_t       resident_size;  /* resident memory size (bytes) */</span><br><span class="line">        time_value_t    user_time;      /* total user run time for</span><br><span class="line">                                           terminated threads */</span><br><span class="line">        time_value_t    system_time;    /* total system run time for</span><br><span class="line">                                           terminated threads */</span><br><span class="line">policy_tpolicy;/* default policy for new threads */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mach_task_basic_info</code> 结构体存储了 Mach task 的内存使用信息，其中 <code>resident_size</code> 是 App 使用的驻留内存大小，<code>virtual_size</code> 是 App 使用的虚拟内存大小。</p><p>如下所示为内存使用情况的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 当前 app 内存使用量</span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    struct mach_task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">kern_return_t kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t) &amp;info, &amp;count);</span><br><span class="line">if (kr == KERN_SUCCESS) &#123;</span><br><span class="line">return info.resident_size;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，我用 <strong>通过此方法获取到的内存信息与 Instruments 中的 Activity Monitor 采集到的内存信息进行比较，发现前者要多出将近 100MB</strong>。经过调研发现，苹果使用了上述的 Compressed Memory，我猜测：<code>resident_size</code> 可能是将 Compressed Memory 解压后所统计到的一个数值。<strong>真实的物理内存的值应该是 <code>task_vm_info</code> 结构体中的 <code>pyhs_footprint</code> 成员的值</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_VM_INFO            22</span><br><span class="line">#define TASK_VM_INFO_PURGEABLE  23</span><br><span class="line">struct task_vm_info &#123;</span><br><span class="line">mach_vm_size_t  virtual_size;       /* virtual memory size (bytes) */</span><br><span class="line">integer_t       region_count;       /* number of memory regions */</span><br><span class="line">integer_t       page_size;</span><br><span class="line">mach_vm_size_t  resident_size;      /* resident memory size (bytes) */</span><br><span class="line">mach_vm_size_t  resident_size_peak; /* peak resident size (bytes) */</span><br><span class="line"></span><br><span class="line">mach_vm_size_t  device;</span><br><span class="line">mach_vm_size_t  device_peak;</span><br><span class="line">mach_vm_size_t  internal;</span><br><span class="line">mach_vm_size_t  internal_peak;</span><br><span class="line">mach_vm_size_t  external;</span><br><span class="line">mach_vm_size_t  external_peak;</span><br><span class="line">mach_vm_size_t  reusable;</span><br><span class="line">mach_vm_size_t  reusable_peak;</span><br><span class="line">mach_vm_size_t  purgeable_volatile_pmap;</span><br><span class="line">mach_vm_size_t  purgeable_volatile_resident;</span><br><span class="line">mach_vm_size_t  purgeable_volatile_virtual;</span><br><span class="line">mach_vm_size_t  compressed;</span><br><span class="line">mach_vm_size_t  compressed_peak;</span><br><span class="line">mach_vm_size_t  compressed_lifetime;</span><br><span class="line"></span><br><span class="line">/* added for rev1 */</span><br><span class="line">mach_vm_size_t  phys_footprint;</span><br><span class="line"></span><br><span class="line">/* added for rev2 */</span><br><span class="line">mach_vm_address_t       min_address;</span><br><span class="line">mach_vm_address_t       max_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>因此，正确的内存使用情况的代码实现应该如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 当前 app 内存使用量</span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    task_vm_info_data_t vmInfo;</span><br><span class="line">    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">    kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);</span><br><span class="line">    if (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">        int64_t memoryUsageInByte = (int64_t) vmInfo.phys_footprint;</span><br><span class="line">        return memoryUsageInByte / 1024 / 1024;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h2><p>FPS（Frames Per Second）是指画面每秒传输的帧数。每秒帧数越多，所显示的动画就越流畅，一般只要保持 FPS 在 50-60，App 就会有流畅的体验，反之会感觉到卡顿。</p><h3 id="相关系统原理-2"><a href="#相关系统原理-2" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p><code>CADisplayLink</code> 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。</p><p>一旦 <code>CADisplayLink</code> 以特定的模式注册到 <code>runloop</code> 之后，每当屏幕需要刷新时，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，此时 <code>target</code> 可以读取到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。如：一个视频应用使用时间戳来计算下一帧要显示的视频数据。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>现阶段，常用的 FPS 监控几乎都是基于 <code>CADisplayLink</code> 实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// swift</span><br><span class="line">final class FPSMonitor: NSObject &#123;</span><br><span class="line">    private var timer: Timer?</span><br><span class="line">    private var link: CADisplayLink?</span><br><span class="line">    private var count: UInt = 0</span><br><span class="line">    private var lastTime: TimeInterval = 0</span><br><span class="line"></span><br><span class="line">    func enableMonitor() &#123;</span><br><span class="line">        if link == nil &#123;</span><br><span class="line">            link = CADisplayLink(target: self, selector: #selector(fpsInfoCalculate(_:)))</span><br><span class="line">            link?.add(to: RunLoop.main, forMode: .common)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            link?.isPaused = false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func disableMonitor() &#123;</span><br><span class="line">        if let link = link &#123;</span><br><span class="line">            link.isPaused = true</span><br><span class="line">            link.invalidate()</span><br><span class="line">            self.link = nil</span><br><span class="line">            lastTime = 0</span><br><span class="line">            count = 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc</span><br><span class="line">    func fpsInfoCalculate(_ link: CADisplayLink) &#123;</span><br><span class="line">        if lastTime == 0 &#123;</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        count += 1</span><br><span class="line">        let delta = link.timestamp - lastTime</span><br><span class="line">        if delta &gt;= 1 &#123;</span><br><span class="line">            // 间隔超过 1 秒</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            let fps = Double(count) / delta</span><br><span class="line">            count = 0</span><br><span class="line"></span><br><span class="line">            let intFps = Int(fps + 0.5)</span><br><span class="line">            print(&quot;帧率：\(intFps)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CADisplayLink</code> 实现的 FPS 在生产场景中只有指导意义，不能代表真实的 FPS。因为基于 <code>CADisplayLink</code> 实现的 FPS 无法完全检测出当前 <strong>Core Animation</strong> 的性能情况，只能检测出当前 <strong>RunLoop</strong> 的帧率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/aozhimin/iOS-Monitor-Platform" target="_blank" rel="noopener">iOS 性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a></li><li><a href="">深入解析Mac OS X 与 iOS 操作系统</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="noopener">WWDC 2018 Session 416 iOS Memory Deep Dive</a></li><li><a href="https://techblog.toutiao.com/2018/06/19/untitled-40/" target="_blank" rel="noopener">[ WWDC2018 ] - 深入解析iOS内存 iOS Memory Deep Dive</a></li><li><a href="https://github.com/WebKit/webkit/blob/52bc6f0a96a062cb0eb76e9a81497183dc87c268/Source/WTF/wtf/cocoa/MemoryFootprintCocoa.cpp" target="_blank" rel="noopener">WebKit MemoryFootprintCocoa</a></li><li><a href="http://newosxbook.com/articles/MemoryPressure.html" target="_blank" rel="noopener">Handling low memory conditions in iOS and Mavericks</a></li><li><a href="https://developer.apple.com/library/archive/technotes/tn2434/_index.html" target="_blank" rel="noopener">Minimizing your app’s Memory Footprint</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" target="_blank" rel="noopener">About the Virtual Memory System</a></li><li><a href="https://zhuanlan.zhihu.com/p/49829766" target="_blank" rel="noopener">iOS 内存管理研究</a></li><li><a href="https://juejin.im/entry/5bbda00ef265da0ac446c970" target="_blank" rel="noopener">iOS Memory Deep Dive</a></li><li><a href="https://zhuanlan.zhihu.com/p/34348398" target="_blank" rel="noopener">深入理解 CADisplayLink 和 NSTimer</a></li><li><a href="https://www.jianshu.com/p/c35a81c3b9eb" target="_blank" rel="noopener">CADisplayLink</a></li><li><a href="https://opensource.apple.com/source/CF/CF-1152.14/CFRunLoop.c.auto.html" target="_blank" rel="noopener">CFRunLoop.c</a></li><li><a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">计算机那些事(8)——图形图像渲染原理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间，在公司的 App 中集成了一个性能监视器，效果如下所示。在这个过程中，扒了一些性能监测开源框架的源码，并学习了其中的原理。本文就对此做一些简要的总结。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-sha
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="性能监控" scheme="http://chuquan.me/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="iOS" scheme="http://chuquan.me/tags/iOS/"/>
    
      <category term="CPU" scheme="http://chuquan.me/tags/CPU/"/>
    
      <category term="Memory" scheme="http://chuquan.me/tags/Memory/"/>
    
      <category term="FPS" scheme="http://chuquan.me/tags/FPS/"/>
    
  </entry>
  
  <entry>
    <title>计算机那些事(1)——硬盘</title>
    <link href="http://chuquan.me/2019/04/05/linux-disk-introduce/"/>
    <id>http://chuquan.me/2019/04/05/linux-disk-introduce/</id>
    <published>2019-04-05T08:42:00.000Z</published>
    <updated>2019-04-06T07:39:09.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬盘接口"><a href="#硬盘接口" class="headerlink" title="硬盘接口"></a>硬盘接口</h1><p>常见的硬盘接口有：<strong>IDE</strong> 、<strong>SATA</strong>、<strong>SAS</strong>、<strong>USB</strong>、<strong>SCSI</strong>，其中 SATA 是目前的主流接口，IDE 则几乎不再使用。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/disk-interfaces.png" alt=""></p><h1 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h1><p>计算机的各种硬件设备在 Linux 中都有对应的设备文件，甚至不同的接口也对应着不同的设备文件，从而使用不同的驱动程序来操作硬件设备。对于硬盘，实体设备的文件名一般是 <code>/dev/sd[a-]</code>；虚拟设备（虚拟机中的硬盘）的文件名一般是 <code>/dev/vd[a-]</code>。</p><p>有时，系统中会有 <code>/dev/sda</code>、<code>/dev/sdb</code>…等设备文件，它们之间又是什么关系呢？实际上，<code>/dev/sd[a-]</code> 是 SATA/USB/SAS 等硬盘接口对应的设备文件，这类接口都使用 SCSI 模块作为驱动程序。<code>a</code>、<code>b</code>、<code>c</code>…则是按系统检测到的顺序来排列的，与实际插槽顺序无关。</p><p>我们知道硬盘是可以被分区成多个分区（partition），如在 Windows 中可以将一块硬盘分区成 <code>C:</code>、<code>D:</code>、<code>E:</code> 盘。那么，不同的分区是否也有对应的设备文件呢？</p><h1 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h1><p>提到分区，我们需要先了解一下硬盘的结构。不同寻址方式的硬盘，其结构也不同。硬盘的寻址方式主要有两种：</p><ul><li><strong>CHS 寻址方式</strong>：由柱面数（Cylinders）、磁头数（Headers）、扇区数（Sectors）组成 3D 参数，简称 CHS 寻址方式，硬盘容量相对较小。如传统的机械硬盘（Hard Disk Drive，HDD）。</li><li><strong>LBA 寻址方式</strong>：线性寻址，以逻辑区块为单位进行寻址，全称为 Logic Block Address（即扇区的逻辑块地址），硬盘容量相对较大。如固态硬盘（Solid State Disk，SSD）</li></ul><h2 id="CHS-寻址方式"><a href="#CHS-寻址方式" class="headerlink" title="CHS 寻址方式"></a>CHS 寻址方式</h2><p>如下图所为 CHS 寻址方式的硬盘结构，硬盘主要由盘片、机械手臂、磁头、主轴马达组成。盘片是数据存储的媒介，圆形，通过机械手臂读写数据，盘片需要转动才能够让机械手臂读写。因此，可以将盘片同心圆分割成一个个的小区块，这些区块组成一个圆形，可以让机械手臂的磁头进行读写。这个小区块就是硬盘的最小物理存储单位，即 <strong>扇区（sector）</strong>。位于同一个同心圆上的扇区组成的圆环，即 <strong>磁道（track）</strong>。硬盘中可能包含多个盘片，在所有盘片上的同一个磁道组成了所谓的 <strong>柱面（cylinder）</strong>，柱面是文件系统的最小单位，也是分区的最小单位。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-structure.png?x-oss-process=image/resize,w_800" alt=""></p><h2 id="LBA-寻址方式"><a href="#LBA-寻址方式" class="headerlink" title="LBA 寻址方式"></a>LBA 寻址方式</h2><p>LBA 寻址方式的硬盘使用集成电路代替物理旋转磁盘，主要由主控与闪存芯片组成。数据的读写速度远远高于 CHS 寻址方式的硬盘。</p><h1 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h1><p>了解了硬盘结构，再来看硬盘分区。</p><p>关于硬盘分区，首先思考一个问题：为什么要分区？其实主要有两个原因：</p><ol><li>数据的安全性。由于每个分区的数据是独立的，使得数据更加安全。</li><li>访存的高效性。对于 CHS 寻址方式的硬盘，由于分区将数据集中在某个柱面的区段，如第一个分区位于柱面号 1~100。当需要对该分区进行访存时，硬盘只会在 1~100 柱面范围内进行操作，从而提升了数据的访存性能。</li></ol><p>既然硬盘能被分区，那么其分区信息是如何保存的呢？答案就是分区表。但是对于不同寻址方式的硬盘，其分区表的格式也不同，主要有两种：</p><ul><li><strong>MBR 分区表</strong>：多用于 CHS 寻址方式的硬盘</li><li><strong>GUID 分区表</strong>：多用于 LBA 寻址方式的硬盘</li></ul><p>分区表有存储在哪里呢？和绝大多数文件将自身的基本描述信息放在文件的开头类似，分区表作为硬盘的基本信息，同样保存在硬盘最前面的存储区域。</p><p>下面分别介绍 MBR 分区表和 GUID 分区表。</p><h2 id="MBR-分区表"><a href="#MBR-分区表" class="headerlink" title="MBR 分区表"></a><strong>MBR 分区表</strong></h2><p>MBR 分区表保存在硬盘的 <strong>第一个扇区</strong>，由于第一个扇区主要记录了两个重要信息，也称为 <strong>主引导记录区（Master Boot Record，MBR）</strong>。这两个信息分别是：</p><ul><li><strong>MBR 分区表</strong>：记录整个硬盘的分区信息，容量为 64 Bytes。</li><li><strong>引导程序（Boot Loader）</strong>：容量为 446 Bytes。</li></ul><h3 id="MBR-分区表-1"><a href="#MBR-分区表-1" class="headerlink" title="MBR 分区表"></a>MBR 分区表</h3><p>分区表占据了 MBR 64 Bytes 的空间，最多只能记录 4 组分区信息，每组分区信息记录了该分区的 <strong>起始与结束的柱面号</strong>，这 4 组分区信息称为 <strong>主要分区（primary partition）</strong> 或 <strong>延伸分区（extended partition）</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-partition-table.png?x-oss-process=image/resize,w_800" alt=""></p><p>假设上述硬盘的设备文件名为 <code>/dev/sda</code>，则这四个分区在 Linux 中的设备文件名如下所示，重点在于文件名后面会再接一个数字，这个数字与分区在硬盘中的位置有关。</p><ul><li>P1：<code>/dev/sda1</code></li><li>P2：<code>/dev/sda2</code></li><li>P3：<code>/dev/sda3</code></li><li>P4：<code>/dev/sda4</code></li></ul><p>由于分区表只有 64 Bytes，最多只能记录 4 组分区信息，那么是否意味着一个硬盘最多只能分割成 4 个分区呢？当然不是！<strong>虽然第一个扇区的分区表只能记录 4 组分区信息，但是利用其中的延伸分区信息进一步索引到一个新的分区表，从而记录更多分区信息</strong>。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-partition-table-extend.png?x-oss-process=image/resize,w_800" alt=""></p><p>上图所示，硬盘第一个扇区中的四个分区记录仅仅使用了两个，P1 为 <strong>主要分区</strong>，P2 为 <strong>延伸分区</strong>。延伸分区的目的是使用额外的扇区来记录分区信息。通过延伸分区所指向的那个区块继续记录分区信息。上图延伸分区索引的分区表继续分出了 5 个分区，这 5 个有延伸分区分出来的分区，称为 <strong>逻辑分区（logical partition）</strong>。</p><p>同理，上图中的分区在 Linux 中的设备文件名如下所示。其中的 <code>/dev/sda3</code> 和 <code>/dev/sda4</code> 则保留给主要分区和延伸分区了，所以逻辑分区的设备文件名从 5 开始。</p><ul><li>P1：<code>/dev/sda1</code></li><li>P2：<code>/dev/sda2</code></li><li>L1：<code>/dev/sda5</code></li><li>L2：<code>/dev/sda6</code></li><li>L3：<code>/dev/sda7</code></li><li>L4：<code>/dev/sda8</code></li><li>L5：<code>/dev/sda9</code></li></ul><blockquote><p>MBR 主要分区、延伸分区、逻辑分区的特性</p><ul><li>主要分区与延伸分区最多可以有 4 个（硬盘的限制）</li><li>延伸分区最多只有一个（操作系统的限制）</li><li>逻辑分区是由延伸分区持续分割出来的分区</li><li>主要分区和逻辑分区可以被格式化；延伸分区不能被格式化</li><li>逻辑分区的数量上限由操作系统决定</li></ul></blockquote><h3 id="引导程序（Boot-Loader）"><a href="#引导程序（Boot-Loader）" class="headerlink" title="引导程序（Boot Loader）"></a>引导程序（Boot Loader）</h3><p>Boot loader 是操作系统安装在 MBR 中的一套软件，但 MRB 仅仅提供 446 Bytes 的空间给 boot loader，所以 boot loader 是极其精简的。其主要完成以下任务：</p><ol><li>提供菜单：用户可以选择不同的开机项目</li><li>载入核心文件：直接指向可开机的程序区段来启动操作系统</li><li>转交其他 loader：将开机管理功能转交给其他 loader 负责，主要用于多系统引导。</li></ol><p>对于第 3 项，表示计算机系统中可能具有两个以上的 boot loader。事实上，boot loader 不仅可以安装在 MBR 中，还可以安装在每个分区的 <strong>开机扇区（boot sector）</strong> 中。</p><p>假设 MBR 中安装的是可以识别 Windows/Linux 的 boot loader，那么整个流程如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-boot-loader.png?x-oss-process=image/resize,w_800" alt=""></p><p>由上图可知，MBR 的 boot loader 提供两个菜单选项：选项 1（M1）可以直接载入 Windows 的核心文件进行开机；选项二（M2）可以将开机管理任务交给第二个分区的开机扇区（boot sector）。如果用户选择选项 2，第二分区的开机扇区中的 boot loader 将会载入 Linux 的核心文件进行开机。</p><blockquote><p>关于多系统安装<br>Linux 安装时，可以将 boot loader 安装在 MBR 或其他分区的开机扇区，Linux 的 boot loader 可以手动设置菜单（即上图的 M1、M2），因此可在 Linux 的 boot loader 中加入 Windows 开机的选项<br>Windows 安装时，其安装程序会主动覆盖 MBR 以及自己所在分区的开机扇区，并且没有选择的机会，也没有让用户自己选择的菜单的功能<br>结论：安装多系统时应该先安装 Windows 系统</p></blockquote><h2 id="GUID-分区表"><a href="#GUID-分区表" class="headerlink" title="GUID 分区表"></a>GUID 分区表</h2><p>MBR 主要有以下限制：</p><ul><li>操作系统无法寻址容量超过 2.2TB 的磁盘</li><li>MBR 只有一个区块，若被破坏后，很难对数据进行恢复</li><li>MBR 的引导程序所能使用空间只有 446 Byte，无法容纳更多的代码</li></ul><p>GUID 则解决了 MBR 的这些问题。</p><p>下图所示为 GUID 的结构示意图。与 MBR 使用扇区作为寻址单位不同，GUID 使用 <strong>逻辑区块（Logical Block）</strong> 作为寻址单位，即采用 LBA（Logical Block Address）寻址方式。MRB 仅使用第一个扇区 512 Bytes 的空间记录分区信息，GUID 则使用 34 个 LBA 区块（每个区块容量默认为 512 Bytes）记录分区信息。MBR 仅有一个扇区保存分区信息，GUID 除了使用硬盘前 34 个 LBA，还是用最后 33 个 LBA 作为备份。</p><p>这里有个疑问：为何前面使用 34 个 LBA，后面使用 33 个 LBA。因为第一个 LBA（LBA0）是用来兼容 MBR 的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/disk-guid-partition-table.png?x-oss-process=image/resize,w_800" alt=""></p><h3 id="LBA0（MBR-兼容区块）"><a href="#LBA0（MBR-兼容区块）" class="headerlink" title="LBA0（MBR 兼容区块）"></a>LBA0（MBR 兼容区块）</h3><p>LBA0 为了兼容 MBR，该区块也分为两个部分，分别用于存储 MBR 分区表和引导程序。因为LBA0 是针对 MBR 兼容模式，因此其分区表中仅仅存放一个特殊标志的分区表信息，用来标识此硬盘为 LBA 寻址方式。</p><h3 id="LBA1（GUID-分区表表头）"><a href="#LBA1（GUID-分区表表头）" class="headerlink" title="LBA1（GUID 分区表表头）"></a>LBA1（GUID 分区表表头）</h3><p>LBA1 记录了分区表本身的位置和大小，同时记录了备份分区表的位置（即最后 33 个 LBA）。此外还存放了分区表的校验码（CRC32），表示硬盘的完整性。</p><h3 id="LBA2-33（分区表表项）"><a href="#LBA2-33（分区表表项）" class="headerlink" title="LBA2~33（分区表表项）"></a>LBA2~33（分区表表项）</h3><p>从 LBA2 开始，每个 LBA 都可以记录 4 组分区信息。默认情况下，总共可以有 4 <em> 32 = 128 组分区信息。因为每个 LBA 有 512 Bytes，所以每组分区信息可使用 128 Bytes 的空间。这 128 Bytes 的分区信息中，分别提供了 64 Bits 用于记录分区对应的 <strong>起始/结束</strong> 区块号。因此，GUID 能够支持的硬盘的最大容量为 `2^64 </em> 512Byte = 233 TB` </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/petershina/article/details/8330171" target="_blank" rel="noopener">硬盘寻址方式</a></li><li><a href="https://blog.csdn.net/Lyon_yong/article/details/79178794" target="_blank" rel="noopener">SSD固态硬盘的结构和基本工作原理概述</a></li><li>《鸟哥的 Linux 私房菜——基础学习篇》</li><li>《Linux 系统架构和应用技巧》</li><li>《Linux 系统架构与目录解析》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;硬盘接口&quot;&gt;&lt;a href=&quot;#硬盘接口&quot; class=&quot;headerlink&quot; title=&quot;硬盘接口&quot;&gt;&lt;/a&gt;硬盘接口&lt;/h1&gt;&lt;p&gt;常见的硬盘接口有：&lt;strong&gt;IDE&lt;/strong&gt; 、&lt;strong&gt;SATA&lt;/strong&gt;、&lt;strong&gt;S
      
    
    </summary>
    
      <category term="计算机原理" scheme="http://chuquan.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="磁盘" scheme="http://chuquan.me/tags/%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>IP 协议相关技术</title>
    <link href="http://chuquan.me/2019/03/09/ip-protocols/"/>
    <id>http://chuquan.me/2019/03/09/ip-protocols/</id>
    <published>2019-03-09T11:16:51.000Z</published>
    <updated>2019-03-09T11:19:47.719Z</updated>
    
    <content type="html"><![CDATA[<p>IP（Internet Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP 是无法实现通信的，还必须具有解析主机名、MAC 地址以及数据包在发送过程中异常情况处理等功能。</p><p>下文将详细介绍 IP 的各种辅助技术，主要包括：</p><ul><li>DNS</li><li>ARP</li><li>DHCP</li><li>NAT</li><li>Mobile IP</li></ul><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>通常来说，我们在访问某个网站时不会直接使用 IP 地址，而是使用类似于 <code>www.chuquan.me</code> 这样的域名进行访问。为什么使用域名就能访问目标地址？因为有 DNS（Domain Name System）的支持，其可以将域名转换为具体的 IP 地址。</p><h2 id="DNS-的产生"><a href="#DNS-的产生" class="headerlink" title="DNS 的产生"></a>DNS 的产生</h2><p>在互联网的起源 ARPANET 中，起初由互联网信息中心（SRI-NIC）整体管理一份 hosts 文件，记录 ARPANET 网中所有计算机的 IP 地址。由于主机的 IP 地址可以变更，所以其他计算机也需要定期下载最新的 hosts 文件才能正常使用网络。</p><p>随着网络规模的扩大，这种集中管理方式的可行性及可靠性均逐渐下降。于是，诞生了一个可以有效管理主机名和 IP 地址之间对应关系的系统，即 DNS 系统。在 DNS 系统中，主机的管理机构维护了一个用来表示组织内部主机名和 IP 地址映射关系的数据库。当用户在应用（如浏览器）中输入主机名（域名）时，DNS 会自动检索数据库，并返回对应的 IP 地址。</p><h2 id="域名的构成"><a href="#域名的构成" class="headerlink" title="域名的构成"></a>域名的构成</h2><p>域名是为了标识主机名和组织机构名的一个具有分层结构的字符串。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pku.edu.cn</span><br></pre></td></tr></table></figure></p><p>其中，<code>pku</code> 表示北京大学（Peking University）固有的域名；<code>edu</code> 表示教育相关结构；<code>cn</code> 表示中国。</p><p>域名的分层如下图所示，各级分层构成一个树形结构，顶点 root 是树的根节点，根节点的下一层称为第 1 层域名，又称 <strong>顶级域名</strong>，如：<code>cn</code>、<code>jp</code> 等国别顶级域名，<code>com</code>、<code>org</code> 等特定领域域名。顶级域名的下一层称为第 2 层域名，如：<code>ac</code>、<code>co</code> 等表示不同组织结构的属性域名，<code>beijing</code> 等表示地域的通用域名。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-hierachy.png" alt=""></p><ul><li><strong>域名服务器</strong><br>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。其所管理的分层称为 <code>ZONE</code>。如图所示，每层都有一个域名服务器。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system.png" alt=""></p><p>DNS 分层结构的根节点设置的 DNS 称为 <strong>根域名服务器</strong>。根域名服务器中注册了 <strong>顶级域名服务器</strong> 的 IP 地址。顶级域名服务器中则注册了第 2 层域名服务器的 IP 地址，以此类推，构成一个分层系统。如果域名服务器宕机，则针对该域的 DNS 查询就会失败。因此为了提高容灾能力，一般会设置至少两个以上的域名服务器。一旦第一个域名服务器无法查询，就会自动转到第二个甚至第三个域名服务器上进行。</p><ul><li><strong>解析器</strong><br>进行 DNS 查询的主机和软件称为 <strong>DNS 解析器</strong>。用户所使用的工作站或个人电脑都属于解析器。<strong>一个解析器至少要注册一个以上域名服务器的 IP 地址</strong>。通常，至少包括组织内部的域名服务器的 IP 地址。</li></ul><h2 id="DNS-工作原理"><a href="#DNS-工作原理" class="headerlink" title="DNS 工作原理"></a>DNS 工作原理</h2><p>那么 DNS 的工作原理是什么呢？假设 <code>yuanfudao.com</code> 域中的主机 A 访问网站 <code>pku.edu.cn</code>，该过程的 DNS 查询流程如图所示。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dns-system-query.png" alt=""></p><p>解析器为了获取 IP 地址，向域名服务器进行查询。接收到查询请求的域名服务器首先在自己的数据库进行查找。如果有该域名对应的 IP 地址就返回。如果没有，则域名服务器再向上一层域名服务器进行查询，依次类推，直到根域名服务器。然后根节点遍历，直到找到指定的域名服务器，并由该域名服务器返回对应的 IP 地址。</p><p>解析器和域名服务器通过将查询结果进行缓存来提高查询性能。</p><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>通过 DNS 确定了目标域名的 IP 地址之后，就可以向该目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时有必要了解每个 IP 地址对应的 MAC 地址。</p><p>ARP（Address Resolution Protocol）是一种解决地址问题的协议。ARP 以目标 IP 地址为线索，确定下一个应该接收数据分包的网络设备的 MAC 地址。如果目标主机不在同一个链路上，可以通过 ARP 查找下一跳路由器的 MAC 地址。</p><blockquote><p>ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以使用 ICMPv6 替代 ARP 发送邻居探索消息。</p></blockquote><h2 id="ARP-工作原理"><a href="#ARP-工作原理" class="headerlink" title="ARP 工作原理"></a>ARP 工作原理</h2><p>ARP 是如果确定 MAC 地址的呢？事实上，ARP 主要通过 <strong>ARP 请求</strong> 与 <strong>ARP 响应</strong> 两种类型的包来确定 MAC 地址的。</p><p>如图所示，主机 A 向同一链路上的主机 B 发送 IP 包，主机 A 的 IP 地址为 <code>172.20.1.1</code>，主机 B 的 IP 地址为 <code>172.20.1.2</code>，它们互不知道对方的 MAC 地址。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/arp-protocol.png" alt=""></p><p>主机 A 为了确定主机 B 的 MAC 地址，先通过广播发送一个 ARP 请求包，请求包中包含了主机 B 的IP 地址 <code>172.20.1.2</code>。由于广播的包可以被同一个链路上的所有主机或路由器接收，因此 ARP 包的请求包也会被同一链路上所有的主机和路由器进行解析。如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，则该节点就将自己的 MAC 地址存入 ARP 响应包并返回给主机 A。</p><p>如果每发送一个 IP 数据报都要进行一次 ARP 请求以此确定 MAC 地址，那么将会产生大量不必要的网络流量。为此，通常会将 IP 与 MAC 地址的映射关系缓存在一个 <strong>ARP 缓存表</strong> 中。除了 ARP 请求发送端可以缓存发送端 MAC 地址，接收端也可以从 ARP 请求包获取发送端主机的 IP 地址及其 MAC 地址并将其进行缓存。</p><p>不过，MAC 地址的缓存是有一定的期限的。超出期限之后，缓存的内容将被清除。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>RARP（Reverse Address Resolution Protocol）是一种根据 MAC 地址定位 IP 地址的协议。例如：将打印机服务器等小型嵌入式设备接入到网络时就会用到。</p><p>通常，我们使用个人电脑设置 IP 地址时，可以通过 DHCP 自动分配获取 IP 地址。但是对于嵌入式设备，会遇到没有任何输入接口或无法通过 DHCP 动态获取 IP 地址的情况。在这种情况下，一般使用 RARP。为此，需要架设一台 RARP 服务器，然后再接入该设备到网络，启动设备时，设备会发送一条类似于“我的 MAC 地址是 xxx，我的 IP 地址是什么”的请求信息。RARP 服务器接收到请求消息之后，返回类似于“MAC 地址为 xxx 的设备，IP 地址为 xxx”的信息。设备根据该应答信息设置自己的 IP 地址。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/rarp-protocol.png" alt=""></p><h2 id="代理-ARP"><a href="#代理-ARP" class="headerlink" title="代理 ARP"></a>代理 ARP</h2><p>通常 ARP 包会被路由器隔离，但是采用代理 ARP（Proxy ARP）的路由器可以将 ARP 请求转发给邻近的网段。因此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><p>在目前的 TCP/IP 网络中，一般情况下用路由器链接多个网络时，会在各个网段上定义各自的子网，从而进行路由控制。然而，对于那些不支持设定子网掩码的老设备，不适用代理 ARP，有时就无法更好地使用网络。</p><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>每一台主机在接入网络时都需要设置 IP 地址，尤其是对于移动设备，每移动到一个新的地方，都需要重新设置 IP 地址。</p><p>DHCP（Dynamic Host Configuration Protocol）就是一种可以实现自动设置 IP 地址、统一管理 IP 地址分配的协议。通过 DHCP，计算机只要连接到网络就可以进行 TCP/IP 通信。</p><h2 id="DHCP-工作原理"><a href="#DHCP-工作原理" class="headerlink" title="DHCP 工作原理"></a>DHCP 工作原理</h2><p>使用 DHCP 之前，需要先架设一台 DHCP 服务器。然后将 DHCP 所要分配的 IP 地址、子网掩码、路由控制信息、DNS 服务器地址等设置到服务器上。</p><p>从 DHCP 获取 IP 地址的过程主要分为两个步骤：</p><ul><li><strong>DHCP 请求</strong>：客户端广播发送 DHCP 发现包，请求设置 IP 地址和子网掩码。DHCP 服务器收到请求后返回 DHCP 提供包，通知可以使用的网络设置。</li><li><strong>DHCP 确认</strong>：客户端再次广播发送 DHCP 请求包，通知想要使用前一次 DHCP 提供包中的网络设置，以确保在 DHCP 服务器上重复设置也可以正常工作。</li></ul><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-protocol.png" alt=""></p><p>当 DHCP 服务器遇到故障时，将导致无法自动分配 IP 地址，从而导致网段内所有主机之间无法进行 TCP/IP 通信。为了提高网络的可靠性，通常会架设两台以上的 DHCP 服务器。由于每个 DHCP 服务器内部都记录着 IP 地址的分配信息，因此可能会导致不同 DHCP 服务器分配的 IP 地址产生冲突。</p><p>为了检查所要分配的 IP 地址以及已分配的 IP 地址是否可用，DHCP 服务器或 DHCP 客户端必须具有以下功能：</p><ul><li><strong>DHCP 服务器</strong>：在分配 IP 地址前发送 ICMP 回送请求包，确认没有返回应答。</li><li><strong>DHCP 客户端</strong>：针对从 DHCP 获取到的 IP 地址发送 ARP 请求包，确认没有返回应答。</li></ul><h2 id="DHCP-中继代理"><a href="#DHCP-中继代理" class="headerlink" title="DHCP 中继代理"></a>DHCP 中继代理</h2><p>家庭网络大多只有一个以太网（无线 LAN）的网段，与其连接的主机台数也不会很多。因此，只需要一台 DHCP 服务器就能应对 IP 地址分配的需求，而大多数情况下都由 <strong>宽带路由器</strong> 充当 DHCP 的角色。</p><p>相比之下，一个企业或学校的网络环境中，一般会有多个以太网（无线 LAN）的网段。在这种情况下，如果针对每个网段都设置 DHCP 服务器，则将是一个浩大的工程。即使路由器可以分担 DHCP 的功能，如果网络中有 100 个路由器，就要为 100 个路由器设置它们各自可分配 IP 地址的范围，并对这些范围进行后续的更新维护，这是极其难以管理的。</p><p>因此，在这类网络环境中，往往需要 DHCP 统一管理，具体方法可以使用 DHCP 中继代理实现。</p><p>这种方法需要在每个网段设置一个 DHCP 中继代理。它可以设置 DHCP 服务器的 IP 地址，从而可以在 DHCP 服务器上为每个网段注册 IP 地址的分配范围。</p><p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，DHCP 中继代理收到广播的请求包后，以单播的方式发给 DHCP 服务器。服务器收到包后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端。由此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理的 IP 地址。 </p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/dhcp-agent-protocol.png" alt=""></p><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时使用全局 IP 地址的技术。NAT 主要是为了应对 IPv4 日渐枯竭而开发的技术。</p><h2 id="NAT-工作原理"><a href="#NAT-工作原理" class="headerlink" title="NAT 工作原理"></a>NAT 工作原理</h2><p>如下图所示，以 <code>10.0.0.10</code> 的主机与 <code>163.221.120.9</code> 的主机进行通信为例。局域网中的主机发起请求时，NAT 路由器会将发送源地址从 <code>10.0.0.10</code> 转换为全局的 IP 地址 <code>202.244.174.37</code> 后再发送数据。反之，当数据从地址 <code>163.221.120.9</code> 发送过来时，目标地址 <code>202.244.174.37</code> 先被转换成私有 IP 地址 <code>10.0.0.10</code> 后再被转发。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/nat-protocol.png" alt=""></p><p>NAT 路由器内部有一个自动生成的用来转换地址的表。当 <code>10.0.0.10</code> 向 <code>163.221.120.9</code> 发送第一个数据包时生成这张表，并按照表中的映射关系进行处理。</p><h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><p>NAPT（Network Address Port Translator）是 NAT 的升级版，不仅可以转换 IP 地址，还可以转换 TCP、UDP 端口号，可以实现用一个全局 IP 地址与多个主机的通信。</p><p>如下图所示，主机 <code>163.221.120.9</code> 的端口号是 <code>80</code>，LAN 中有两个客户端 <code>10.0.0.10</code> 和 <code>10.0.0.11</code> 同时进行通信，并且两个客户端的本地端口都是 <code>1025</code>。此时，仅仅将 IP 地址为路由器的全局地址 <code>202.244.174.37</code> 将无法区分两个客户端。因此，只要将 <code>10.0.0.11</code> 的端口号转换为 <code>1026</code> 就可以进行区分。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/napt-protocol.png" alt=""></p><p>类似于 NAT，NAPT 路由器也会生成自动一个转换表。如：在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包发出后就会生成转换表。断开 TCP 连接时的 FIN 包发出后就会被删除。</p><h1 id="Mobile-IP"><a href="#Mobile-IP" class="headerlink" title="Mobile IP"></a>Mobile IP</h1><p>在与移动设备进行通信时，所连接的子网一旦发生变化，则无法通过 TCP 继续通信。因为 TCP 是面向连接的协议，自始至终都需要发送端和接收端主机的 IP 地址保持不变。类似的，UDP 也无法继续通信。</p><p>Mobile IP 技术就是为了解决所连接的子网发生变化时继续保持通信的需求。</p><h2 id="Mobile-IP-工作原理"><a href="#Mobile-IP-工作原理" class="headerlink" title="Mobile IP 工作原理"></a>Mobile IP 工作原理</h2><p><strong>基本概念</strong></p><ul><li><strong>移动节点</strong>（MN，Mobile Node）：从一个网络切换到另一个网络的设备，如：手机从一个网络切换到另一个网络。</li><li><strong>对等节点</strong>（CN，Correspondent Node）：与移动节点通信的设备。</li><li><strong>归属地址</strong>（Permanent Address）：一个固定的 IP 地址，如同一个人的户籍，即使移动了也不会改变。</li><li><strong>转交地址</strong>（CoA：Care-of-Address）：设备移动当前所处网络予以分配的 IP 地址。</li><li><strong>归属代理</strong>（HA：Home Agent）：暂时认为是移动设备当前所处网络的路由器。</li><li><strong>外地代理</strong>（FA：Foreign Agent）：暂时认为是移动设备归属网络的路由器。</li></ul><p>如下图所示，为 Mobile IP 的工作原理。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/mobile-ip-protocol.png" alt=""></p><p>当移动节点接入切换至另一个网络时，首先请求外地代理为它服务，并向归属代理注册转交地址。</p><p>当对等节点向移动节点的归属地址发送分组数据时，归属代理能够截获该分组，并将该分组转发给移动节点最新注册的转交地址。外地代理收到分组数据后，转发给转交地址对应的设备，即移动节点。移动节点可以直接响应对等节点。</p><p>注意，归属代理和外地代理之间的通信是通过 IP 隧道实现的。因为归属代理会将对等节点的原始分组数据进行封装，再由外地代理进行拆封。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《图解 TCP/IP》</li><li>Mobile IP 基本知识, NC &amp; IS</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IP（Internet Protocol）旨在让最终目标主机收到数据包，但是这一过程中仅仅有 IP 是无法实现通信的，还必须具有解析主机名、MAC 地址以及数据包在发送过程中异常情况处理等功能。&lt;/p&gt;
&lt;p&gt;下文将详细介绍 IP 的各种辅助技术，主要包括：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="网络" scheme="http://chuquan.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IP" scheme="http://chuquan.me/tags/IP/"/>
    
      <category term="DHCP" scheme="http://chuquan.me/tags/DHCP/"/>
    
      <category term="DNS" scheme="http://chuquan.me/tags/DNS/"/>
    
      <category term="ARP" scheme="http://chuquan.me/tags/ARP/"/>
    
      <category term="Mobile IP" scheme="http://chuquan.me/tags/Mobile-IP/"/>
    
      <category term="NAT" scheme="http://chuquan.me/tags/NAT/"/>
    
  </entry>
  
  <entry>
    <title>OSI 模型与 TCP-IP 协议详解</title>
    <link href="http://chuquan.me/2019/03/02/osi-tcp-ip-introduce/"/>
    <id>http://chuquan.me/2019/03/02/osi-tcp-ip-introduce/</id>
    <published>2019-03-02T07:03:12.000Z</published>
    <updated>2019-03-02T07:09:35.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p>在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着异构机型之间通信的需求不断增加，通信技术的标准化也随之展开。于是，ISO（International Organization for Standard）制定了一个国际标准 OSI（Open System Interconnection），即广为人知的 OSI 参考模型，作为标准化通信技术的设计准则。</p><p>OSI 参考模型将通信协议中必要的功能分层了 7 层。每个分层接收下一层提供的特定服务，并负责为上一层提供特定的服务。这些功能上相对独立的分层可以构造一个扩展性和灵活性都较强的系统。</p><p>下表所示为 OSI 参考模型及其各个分层的职责。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi.png?x-oss-process=image/resize,w_570" alt=""></p><ul><li><p><strong>应用层</strong>：主要负责为应用程序提供服务并规定应用程序中通信相关的细节。在该层实现的协议有：文件传输、电子邮件、远程登录等协议。</p></li><li><p><strong>表示层</strong>：主要负责数据格式的转换。将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。</p></li><li><p><strong>会话层</strong>：主要负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p></li><li><p><strong>传输层</strong>：主要负责进行可靠传输。只在通信双方节点上进行处理，而无需在路由器上处理。</p></li><li><p><strong>网络层</strong>：主要负责寻址和路由选择，从而将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某个地址。</p></li><li><p><strong>数据链路层</strong>：主要负责物理层面上互连的、节点之间的通信传输。将 0、1 序列划分为具有意义的数据帧传送给对端（数据帧的生成与接收）。如与 1 个以太网相连的 2 个节点之间的通信。</p></li><li><p><strong>物理层</strong>：主要负责 0、1 比特流（0、1 序列）与电压的高低、光的闪灭之间的互换。</p></li></ul><h1 id="OSI-参考模型通信示例"><a href="#OSI-参考模型通信示例" class="headerlink" title="OSI 参考模型通信示例"></a>OSI 参考模型通信示例</h1><p>下面举例说明 OSI 参考模型的功能。假设使用主机 A 的用户向使用主机 B 的用户发送一封邮件。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email01.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>用户 A 在主机 A 上新建一封邮件，指定收件人为 B，并输入邮件内容为 “早上好”。用户确认发送时，开始进入应用层协议的处理。该协议在传送数据的前端附加一个首部信息。主机 B 在收到主机 A 发送至的数据后，分析其数据首部与数据正文，并将邮件存入本地。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email02.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层会将数据从“某个计算机特定的数据格式”转换为“网络通用的标准数据格式”后再发送出去。接收端主机收到数据以后将这些网络标准格式的数据恢复成“该计算机特有的数据格式”，然后在进行相应的处理。</p><p>此例中，“早上好”这段文字根据编码格式被转换成了“统一的网络数据格式”。由于文字的编码格式非常多，如：UTF-8、UTF-16、Unicode 等，如果未能按照特定格式编码，那么在接收端收到的邮件可能就是乱码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email03.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>假如用户 A 新建了 5 封邮件准备发送给用户 B。这 5 封邮件的发送顺序可以有多种：</p><ul><li>每发一封邮件时建立一次连接，随后断开连接</li><li>一旦建立连接后，将 5 封邮件连续发送给对方</li><li>同时建立 5 个连接，将 5 封邮件同时发送给对方</li></ul><p>会话层的主要责任就是决定采用何种连接方式。</p><p>类似应用层、表示层，会话层在其收到的数据前端附加首部之后再转发给下一层。这些首部中 <strong>记录着数据传送顺序的信息</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email04.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>会话层只对何时建立连接、何时发送数据等问题进行管理，并不具备实际传输数据的功能。真正负责在网络上传输数据的是会话层以下的分层。</p><p>主机 A 确保与主机 B 之间的通信并准备发送数据。该过程称为“建立连接”。连接建立后即可使主机 A 发送的邮件到达主机 B。传输结束之后，有必要将连接断开。</p><p>上述两个主机之间创建逻辑上的通信连接是传输层的主要作用。此外，传输层为确保数据到达目标地址，会在通信两端的主机之间进行确认，如果数据没有到达，则负责进行重发。</p><p>示例中，如果主机 A 将“早上好”发送给主机 B，由于网络异常等原因导致只有部分数据到达目标地址。假设主机 B 只收到“早上”这部分数据，那么它会将没有收到“早上”之后那部分数据的事实告诉主机 A，主机 A 得知后会将“好”重新发送给主机 B，并再次确认对端是否收到。</p><p>因此，保证数据传输的可靠性是传输层的一个重要作用。为了确保可靠性，传输层也会对所要传输的数据附加首部以识别这一分层的数据。然而，实际上将数据传输给对端的处理是由网络层完成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email05.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的作用是在网络与网络互连的环境中，将数据从发送端主机发送到接收端主机。如图所示，两端主机之间虽然有众多数据链路，但是能够将数据从主机 A 发送到主机 B 也都是网络层的功劳。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email06.png?x-oss-process=image/resize,w_600" alt=""></p><p>网络层的数据发送通过目标地址选择对应的计算机，因此目标地址是网络中唯一指定的序号，类似于电话号码。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-osi-email07.png?x-oss-process=image/resize,w_600" alt=""></p><h2 id="数据链路层、物理层"><a href="#数据链路层、物理层" class="headerlink" title="数据链路层、物理层"></a>数据链路层、物理层</h2><p>通信传输本质上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过介质互连的设备之间进行数据处理。</p><p>物理层则将数据的 0、1 转换为电压和脉冲光传输给物理的传输介质，而<strong>相互直连的设备之间使用地址实现传输</strong>。这种地址被称为 <strong>MAC</strong> 地址。<strong>采用 MAC 地址，目的是为了识别连接同一传输介质上的设备</strong>。物理层会将包含 MAC 地址的信息的首部附加到同网络层转发过来的数据上，并将其发送到网络中。</p><p>网络层与数据链路层都是基于目标地址将数据发送给接收端，其区别在于：</p><ul><li><strong>网络层负责将整个数据发送给最终的目标地址</strong></li><li><strong>数据链路层只负责发送一个分段内的数据</strong></li></ul><p>详见上图。</p><h1 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h1><h2 id="TCP-IP-的含义"><a href="#TCP-IP-的含义" class="headerlink" title="TCP/IP 的含义"></a>TCP/IP 的含义</h2><p>从字面上看，有人可能会认为 TCP/IP 是指 TCP 与 IP 两种协议。虽然实际中的确有这两种协议，但是在很多情况下，它泛指 IP、ICMP、TCP、UDP、TELNET、FTP、HTTP 等协议群，所以有时也称 TCP/IP 为 <strong>网际协议族</strong>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-protocols.png" alt=""></p><h2 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h2><p><strong>包、帧、数据报、段、消息</strong> 等五个术语都用来表述数据的单位，其区别在于：</p><ul><li>包：全能性术语</li><li>帧：表示数据链路层中包的单位</li><li>数据报：表示 IP 和 UDP 等网络层以上分层中包的单位</li><li>段：表示 TCP 数据流中的信息</li><li>消息：表示应用层中数据的单位</li></ul><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上层传来的数据。在数据包的首部，明确标明了协议应该如何读取数据。通过解析首部，能够了解该协议必要的信息以及要处理的内容。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-data-header.png" alt=""></p><h2 id="TCP-IP-与-OSI-参考模型"><a href="#TCP-IP-与-OSI-参考模型" class="headerlink" title="TCP/IP 与 OSI 参考模型"></a>TCP/IP 与 OSI 参考模型</h2><p>关于 TCP/IP 与 OSI 参考模型的关系，我们可以认为 TCP/IP 是对 OSI 参考模型的一种具体实现。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-ois-compare.png" alt=""></p><ul><li><p><strong>硬件（物理层）</strong></p><ul><li>TCP/IP 的最底层是负责数据传输的硬件，如以太网或电话线路等物理层的设备。物理层所使用的传输媒介不同（如使用网线或无线），网络的带宽、可靠性、安全性、延迟等都会有所不同。</li></ul></li><li><p><strong>网络接口层（数据链路层）</strong></p><ul><li>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层，可认为是让 NIC（网卡）正常工作的驱动程序。</li></ul></li><li><p><strong>互联网层（网络层）</strong></p><ul><li>互联网层使用 IP 协议，对应 OSI 模型中的第 3 层网络层。IP 协议基于 IP 地址转发分组数据包。</li><li>TCP/IP 分层中的互联网层与传输层的功能通常由操作系统实现。尤其是路由器，它必须实现通过互联网曾转发分组数据包的功能。连接互联网的所有主机和路由器都必须实现 IP 的功能。</li></ul></li></ul><blockquote><p><strong>为什么要分组？</strong><br>首先需要明确一个事实：一台计算机在收发数据时会独占其所在的整条通信线路。如果一条线路上连接了多台计算机，当计算机相互之间进行数据传输时，则需要等待线路中没有其他计算机占用时才能进行数据传输。如果某台计算机占用线路之后传输大量数据，则其他计算机始终保持等待状态。极端情况下根本无法进行通信。<br>采用分组（交换）技术，数据会被分成更小的单元，所有的计算机就可以并发收发数据，从而提高了通信线路的利用率。</p><p><strong>IP</strong><br>IP 是跨越网络传送数据包，使整个互联网都能收到数据的协议，这个过程中使用 IP 地址作为主机的标识。<br>IP 还隐含着数据链路的功能。通过 IP，相互通信的主机之间无论经过怎样的底层数据链路都能够实现通信。<br>IP 是分组交换的一种协议，但其并不具备重发机制。即使分组数据包未能达到对端主机也不会重发，属于非可靠传输协议。  </p><p><strong>ICMP</strong><br>IP 数据包在发送途中一旦出现异常导致无法到达对端目标地址时，需要向发送端发送一个异常通知。ICMP 就是为这一功能而定制的，常用于 <strong>诊断网络的健康状况</strong>。  </p><p><strong>ARP</strong><br>从分组数据包的 IP 地址中解析出物理地址（MAC 地址）的一种协议。</p></blockquote><ul><li><strong>传输层</strong><ul><li>传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部，通常同时运行着多个程序。为了识</li><li>别哪些程序之间在进行通信，使用 <strong>端口号</strong> 进行区分。</li></ul></li></ul><blockquote><p><strong>TCP</strong><br>TCP 是一种面向有连接的传输层协议。它可以保证两端通信主机之间的通信可达。TCP 能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外，TCP 还能够有效利用带宽，缓解网络拥堵。<br> 为了建立和断开连接，TCP 需要进行 3 次握手，4 次挥手，从而会导致网络流量的浪费。</p><p><strong>UDP</strong><br>UDP 是一种面向无连接的传输层协议。UDP 不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。<br>UDP 常用语分组数据较少或多播、广播通信以及视频通信等多媒体领域。  </p></blockquote><ul><li><strong>应用层（会话层以上分层）</strong><ul><li>TCP/IP 协议分层模型将 OSI 参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。这些功能有时由一个单一的程序实现，有时也可能会由多个程序实现。</li></ul></li></ul><h1 id="TCP-IP-协议分层模型通信示例"><a href="#TCP-IP-协议分层模型通信示例" class="headerlink" title="TCP/IP 协议分层模型通信示例"></a>TCP/IP 协议分层模型通信示例</h1><p>这里继续以上述电子邮件收发的示例来介绍 TCP/IP 协议分层模型的通信过程。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/tcp-ip-example.png" alt=""></p><p>邮件收发过程可分为个主要步骤：</p><ul><li>发送数据包（发送端）</li><li>接收数据包（接收端）</li></ul><h2 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h2><h3 id="应用程序处理"><a href="#应用程序处理" class="headerlink" title="应用程序处理"></a>应用程序处理</h3><p>应用程序在发送邮件那一刻建立 TCP 连接，从而利用该 TCP 连接发送数据。该过程首先将应用层发来的数据发送至下一层的 TCP，再做实际的转发处理。</p><h3 id="TCP-模块处理"><a href="#TCP-模块处理" class="headerlink" title="TCP 模块处理"></a>TCP 模块处理</h3><p>TCP 根据应用程序的指示，负责建立连接、发送数据、断开连接。TCP 会在应用层数据前端附加一个 TCP 首部，其中包括：<strong>源端口号</strong> 和 <strong>目标端口号</strong>（用以识别发送主机和接收主机上的应用）、<strong>序号</strong>（用以标识发送包中哪部分是数据）、<strong>校验和</strong>（用以判断数据是否被损坏）。</p><h3 id="IP-模块处理"><a href="#IP-模块处理" class="headerlink" title="IP 模块处理"></a>IP 模块处理</h3><p>IP 将 TCP 传来的 TCP 首部和 TCP 数据合起来作为自己的数据，并在数据前端附加一个 IP 首部，其中包括：接收端 IP 地址和发送端 IP 地址。</p><p>IP 包生成后，根据路由控制表决定接收此 IP 包的路由器或主机。随后，IP 包将被发送给连接到这些路由器或主机网络接口的驱动程序，以实现真正发送数据。</p><p>如果尚且不知道接收端的 MAC 地址，可利用 ARP 查找。只要知道了对端的 MAC 地址，就可将 MAC 地址和 IP 地址交给以太网的驱动程序，实现数据传输。</p><h3 id="网络接口（以太网驱动）处理"><a href="#网络接口（以太网驱动）处理" class="headerlink" title="网络接口（以太网驱动）处理"></a>网络接口（以太网驱动）处理</h3><p>以太网驱动会将 IP 传来的 IP 包的前端附加上以太网首部并进行发送处理。以太网首部包含：接收端 MAC 地址、发送端 MAC 地址、标志以太网类型的以太网数据的协议。由此产生的以太网数据包将被发送至物理层传输给接收端。</p><h2 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h2><p>数据包的接收流程是发送流程的逆序过程。</p><h3 id="网络接口（以太网驱动）处理-1"><a href="#网络接口（以太网驱动）处理-1" class="headerlink" title="网络接口（以太网驱动）处理"></a>网络接口（以太网驱动）处理</h3><p><strong>主机收到以太网包后，先从以太网包首部找到 MAC 地址判断是否为发给自己的包。如果不是则丢弃。</strong></p><p>如果确认是发给自己的包，则查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。示例中数据的协议类型是 IP，因此将数据传送给处理 IP 的子程序（如果是 ARP，则把数据传给处理 ARP 的子程序）。如果无法识别协议类型，则丢弃数据。</p><h3 id="IP-模块处理-1"><a href="#IP-模块处理-1" class="headerlink" title="IP 模块处理"></a>IP 模块处理</h3><p>IP 模块收到 IP 包首部以数据部分后，也做类似处理。<strong>如果判断首部中的 IP 地址与自己的 IP 地址匹配，则接收数据并从中查找上一层的协议</strong>。如果上一层协议为 TCP，则传给 TCP 处理；如果上一层协议为 UDP，则传给 UDP 处理；<strong>对于路由器，接收端 IP 地址往往不是自己的 IP 地址，此时会根据路由控制表，查询应送达的主机或路由器以后再转发数据</strong>。</p><h3 id="TCP-模块处理-1"><a href="#TCP-模块处理-1" class="headerlink" title="TCP 模块处理"></a>TCP 模块处理</h3><p>TCP 模块会先计算校验和以确认数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。</p><p>数据接收完毕后，接收端则发送一个“确认回执”给发送端。如果回执消息未能达到发送端，发送端会认为接收端没有接收到数据而一直重复发送。</p><p>数据被完整接收后，会传给由端口号识别的应用程序。</p><h3 id="应用程序处理-1"><a href="#应用程序处理-1" class="headerlink" title="应用程序处理"></a>应用程序处理</h3><p>接收端应用程序通过解析数据可最终获取到邮件的具体内容。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI 模型-维基百科</a></li><li>《图解 TCP/IP》</li><li>《TCP/IP 详解》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OSI-参考模型&quot;&gt;&lt;a href=&quot;#OSI-参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI 参考模型&quot;&gt;&lt;/a&gt;OSI 参考模型&lt;/h1&gt;&lt;p&gt;在计算机通信诞生之初，标准化和系统化并未得到足够的重视，各大厂商竞相研发各自的通信技术。随着
      
    
    </summary>
    
      <category term="网络" scheme="http://chuquan.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="IP" scheme="http://chuquan.me/tags/IP/"/>
    
      <category term="OSI" scheme="http://chuquan.me/tags/OSI/"/>
    
      <category term="TCP" scheme="http://chuquan.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://chuquan.me/2018/12/31/2018-summary/"/>
    <id>http://chuquan.me/2018/12/31/2018-summary/</id>
    <published>2018-12-31T08:07:42.000Z</published>
    <updated>2018-12-31T08:13:31.940Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600" alt=""></div><a id="more"></a><p>又到了年末总结的时候了…回望年初立下的 Flag，不知道倒下了多少，扶都扶不起来。</p><p>简单总结一下这一年吧..</p><h2 id="关于运动"><a href="#关于运动" class="headerlink" title="关于运动"></a>关于运动</h2><p>从 7 月份至 10 月份，在这 4 个月期间，每周末去自学游泳。从旱鸭子状态开始，依次掌握了蛙泳，狗刨，自由泳，仰泳，蝶泳。目前，蝶泳还不是非常协调，有待进一步强化练习。毕竟，蝶泳是所用泳姿中门槛最高的一种，无论是在力量方面还是协调性方面。</p><p>当然，完全靠自己摸索来学习游泳是一个很漫长的过程。为了加快我的学习进入，在学游泳期间，我坚持观看 YouTube 上易梦觉教练的一些游泳教学视频，学习一些游泳的技巧。</p><p>年底的时候，开始教妹子学游泳，目前蛙泳差不多已经会了。</p><p>除了游泳，今年在周末的时间还有一部分给了篮球。自从 3 月份那会儿在高家园附近的社科院里发现了一个室外篮球场后，在 7 月份之前几乎每周末都会去打一次球。</p><p>总体来说，今年的运动量增加了不少，同时掌握了游泳这个新技能。</p><h2 id="关于旅行"><a href="#关于旅行" class="headerlink" title="关于旅行"></a>关于旅行</h2><p>今年 10 月底，随公司一起去俄罗斯玩了一周。<a href="http://chuquan.me/2018/11/03/st-petersburg/">游记传送门</a></p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>年初的时候，刚刚开始接手模块级的 iOS 开发任务，那时候还不是非常娴熟。经过这一年的锻炼，已经能够 carry 任何需求了。</p><p>这一年里，公司的工作节奏依然比较快的，毕竟走的是 Scrum 的项目管理模式，需求迭代很快，并且研发人员相对产品经理较少。为了解决研发人员不足的问题，从年初就开始不停地招人。到年底，我们整个研发组从原来的 15 人左右增至 30 多人。公司整体的人员也增涨了不少，去年入职时只有 500 人左右，此刻已经有了 2800 多人了。在全球经济如此不景气，各个公司都不断裁员的背景下，我司还在不断地扩招，不禁感慨教育行业的优越性[手动捂脸]。</p><p>6 月份，公司给我们调了一次薪水，发了期权，虽然不是很多，但符合预期。</p><h2 id="关于技术"><a href="#关于技术" class="headerlink" title="关于技术"></a>关于技术</h2><p>今年来了几位有着丰富工作经验的同事，在他们的积极推动下，我们的搜题和口算的项目也开始引入了一些新的技术框架。口算目前基本已经在使用 Swift 进行开发了，并已经在使用函数响应式编程框架 RxSwift。搜题方面由于历史原因，虽然引入了 RxSwift，但还没有开始全面使用。</p><p>去年立下的关于阅读开源框架的 Flag，今年只是阅读了一些公司内部的框架，如：YTKFrog、YTKRouterManager、YTKResourceSync 等，关于阅读开源框架这个 Flag，希望明年能够重视。</p><h2 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h2><p>今年上半年，我又重新看了一遍《程序员的自我修养——装载、链接与库》，然后写了几篇博客。从中我发现了一种相比以前更加高效的吸收知识、提高阅读效率的方法——写博客。为什么呢？因为我们看完一本书时，其实有效的知识吸收程度并不高，写博客能够让我们加强对关心的主题的理解。写博客的过程中，需要我们不断地重新翻看书中的一些要点，甚至查阅其他书籍、博客，从而加强我们对它的理解。后来我写的几篇博客：<a href="http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/">《计算机那些事(7)——图形图像渲染原理》</a>、<a href="http://chuquan.me/2018/09/25/ios-graphics-render-principle/">iOS 图像渲染原理</a> 都是按照同样的方式做的，受益匪浅。后一篇文章甚至被 CocoaChina 社区转载了，虽然没有稿费，但还是非常开心。</p><p>年末的时候，我开始对编程语言、编程范式起了兴趣。依次看了几本书：《七周七语言》、《函数式编程思维》、《函数式 Swift》。希望新的一年能够继续深入研究编程语言，能够产出几篇博文。</p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p>Flag 还是要立起来的，毕竟明年年底要是要给自己打打脸，清醒地认清自我。</p><ol><li>深入研究编程语言，包括编程范式、实现模式、DSL 等。先列一些书单：<ul><li>《类型和程序设计语言》</li><li>《自制编程语言》</li><li>《领域特定语言》</li><li>《编程语言实现模式》</li><li>…</li></ul></li><li>掌握一些其他的编程语言。</li><li>副业搞起来，通过专利代理人资格考试</li><li>横向发展，学习 Android 开发。</li><li>提升 Linux 基本技能</li><li>做一个全栈项目</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/zaishuiyifang.jpeg?x-oss-process=image/resize,w_600&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="生活" scheme="http://chuquan.me/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://chuquan.me/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>KVO 原理详解</title>
    <link href="http://chuquan.me/2018/12/12/kvo-principle/"/>
    <id>http://chuquan.me/2018/12/12/kvo-principle/</id>
    <published>2018-12-12T13:41:59.000Z</published>
    <updated>2019-07-29T14:18:49.498Z</updated>
    
    <content type="html"><![CDATA[<p>KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。<a href="https://github.com/baochuquan/BAOStudy" target="_blank" rel="noopener">源码地址</a></p><h1 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> setupSubviews];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = <span class="number">1</span>;</span><br><span class="line">    p1.age = <span class="number">2</span>;</span><br><span class="line">    p2.age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self 监听 p1 的 age 属性</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupSubviews &#123;</span><br><span class="line">    [<span class="keyword">self</span> setupHeaderView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupHeaderView &#123;</span><br><span class="line">    <span class="keyword">self</span>.headerView.title = <span class="string">@"KVO"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到 %@ 的 %@ 改变了 %@"</span>, object, keyPath,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例对 <code>p1</code> 进行了 KVO 监听，当 <code>p1</code> 发生改变，即调用 <code>observeValueForKeyPath</code> 方法，从而打印以下信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">监听到 &lt;BAOPerson: 0x600003750200&gt; 的 age 改变了 &#123;</span><br><span class="line">    kind = 1;</span><br><span class="line">    new = 10;</span><br><span class="line">    old = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="KVO-实现原理"><a href="#KVO-实现原理" class="headerlink" title="KVO 实现原理"></a>KVO 实现原理</h1><p>通过上述代码可以发现，一旦 <code>age</code> 属性的值发生改变，就会通知到监听者。我们知道赋值操作都是调用 <code>set</code> 方法，我们可以重写 <code>BAOPerson</code> 类中 <code>age</code> 的 <code>set</code> 方法，观察 KVO 是否是在 <code>set</code> 方法内部做了一些操作来通知监听者。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"override setAge"</span>);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现即使重写了 <code>set</code> 方法，<code>p1</code> 除了调用 <code>set</code> 方法之外还会执行监听者的 <code>observeValueForKeyPath</code> 方法。</p><p>根据上述实验推测：KVO 在运行时对 <code>p1</code> 对象进行了改动，使 <code>p1</code> 对象在调用 <code>setAge</code> 方法时做了一些额外的操作。所以问题出在对象身上，两个对象可能本质上并不一样。下面我们来探索一下 KVO 内部是如何实现的。</p><h1 id="KVO-实现分析"><a href="#KVO-实现分析" class="headerlink" title="KVO 实现分析"></a>KVO 实现分析</h1><p>首先分别在添加 KVO 前后打上断点，以观察添加 KVO 前后 <code>p1</code> 对象有何不同。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-before-after-add-observe.png?x-oss-process=image/resize,w_600" alt=""></p><p>通过打印对象的 <code>isa</code> 指针，我们发现，<code>p1</code> 对象的 <code>isa</code> 指针由之前的指向类对象 <code>BAOPerson</code> 变成了指向类对象 <code>NSKVONotifying_BAOPerson</code>。相应地，<code>p2</code> 对象没有改变。因此我们可以推测，<code>p1</code> 对象的 <code>isa</code> 发生改变后，其执行的 <code>setAge</code> 也发生了改变。</p><p>我们知道，<code>p2</code> 在调用 <code>setAge</code> 方法时，首先会通过 <code>p2</code> 对象的 <code>isa</code> 指针找到 <code>BAOPerson</code> 类对象，然后在类对象中找到 <code>setAge</code> 方法，最终找到方法对应的实现。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo001.png?x-oss-process=image/resize,w_600" alt=""></p><p>但是，<code>p1</code> 对象的 <code>isa</code> 在添加 KVO 之后已经指向了 <code>NSKVONotifying_BAOPerson</code> 类对象，<code>NSKVONotifying_BAOPerson</code> 则是 <code>BAOPerson</code> 的子类。<code>NSKVONotifying_BAOPerson</code> 是 runtime 在运行时生成的。因此，<code>p1</code> 对象在调用 <code>setAge</code> 方法时必然会根据 <code>p1</code> 的 <code>isa</code> 找到 <code>NSKVONotifying_BAOPerson</code>，并在 <code>NSKVONotifying_BAOPerson</code> 中找到 <code>setAge</code> 方法及其实现。</p><p>经查阅资料了解到，<code>NSKVONotifying_BAOPerson</code> 中的 <code>setAge</code> 方法中其实调用了 Foundation 框架中 C 语言函数 <code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code> 内部的操作大致是：首先调用 <code>willChangeValueForKey</code> 方法，然后调用父类的 <code>setAge</code> 方法对成员变量赋值，最后调用 <code>didChangeValueForKey</code> 方法。<code>didChangeValueForKey</code> 方法中会调用监听者的监听方法，最终调用监听者的 <code>observeValueForKeyPath</code> 方法。</p><h1 id="KVO-原理验证"><a href="#KVO-原理验证" class="headerlink" title="KVO 原理验证"></a>KVO 原理验证</h1><p>前面我们已经通过断点打印 <code>isa</code> 指针的方式验证了：<code>p1</code> 对象在添加 KVO 后，其 <code>isa</code> 指针会指向一个通过 runtime 创建的 <code>BAOPerson</code> 的子类 <code>NSKVONotifying_BAOPerson</code>。</p><p>下面我们可以通过打印方法实现的地址来看一下 <code>p1</code> 和 <code>p2</code> 的 <code>setAge</code> 方法实现的地址在添加 KVO 前后有什么变化。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过methodForSelector找到方法实现的地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加 KVO 之前 - p1 = %p, p2 = %p"</span>, [p1 methodForSelector: <span class="keyword">@selector</span>(setAge:)], [p2 methodForSelector: <span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"添加 KVO 之后 - p1 = %p, p2 = %p"</span>, [p1 methodForSelector: <span class="keyword">@selector</span>(setAge:)], [p2 methodForSelector: <span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-name-before-after.png?x-oss-process=image/resize,w_800" alt=""></p><p>执行上述代码，可以发现：在添加 KVO 之前，<code>p1</code> 和 <code>p2</code> 的 <code>setAge</code> 方法实现的地址是相同的；在添加 KVO 之后， <code>p1</code> 的 <code>setAge</code> 方法实现的地址发生了改变。通过打印方法实现可以证明，<code>p1</code> 的 <code>setAge</code> 方法的实现由 <code>BAOPerson</code> 类方法中的 <code>setAge</code> 方法转换成了 Foundation 框架中的 C 函数 <code>_NSSetIntValueAndNotify</code>。</p><p>事实上，Foundation 框架中很多例如 <code>_NSSetBoolValueAndNotify</code>、<code>_NSSetCharValueAndNotify</code>、<code>_NSSetFloatValueAndNotify</code>、<code>_NSSetLongValueAndNotify</code> 等函数。</p><p>为了查看 Foundation 框架中的相关函数，我们找到 Foundation 文件，通过命令行查询：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm Foundation | grep ValueAndNotify</span><br></pre></td></tr></table></figure></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-value-and-notify-methods.png?x-oss-process=image/resize,w_600" alt=""></p><h1 id="中间类内部结构"><a href="#中间类内部结构" class="headerlink" title="中间类内部结构"></a>中间类内部结构</h1><p><code>NSKVONotifying_BAOPerson</code> 作为 <code>BAOPerson</code> 的子类，其 <code>superclass</code> 指针指向 <code>BAOPerson</code> 类，其内部对 <code>setAge</code> 方法做了单独的实现，那么 <code>NSKVONotifying_BAOPerson</code> 同 <code>BAOPerson</code> 类的差别可能就在于其内存储的对象方法及实现不同。我们通过 runtime 分别打印 <code>BAOPerson</code> 类对象和 <code>NSKVONotifying_BAOPerson</code> 类对象内存储的对象方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    BAOPerson *p1 = [[BAOPerson alloc] init];</span><br><span class="line">    BAOPerson *p2 = [[BAOPerson alloc] init];</span><br><span class="line">    p1.age = <span class="number">1</span>;</span><br><span class="line">    p1.age = <span class="number">2</span>;</span><br><span class="line">    p2.age = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p2)];</span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p1)];</span><br><span class="line">    </span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printMethods:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [methodNames appendFormat:<span class="string">@"%@ - "</span>, cls];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        <span class="built_in">NSString</span> *methodName  = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line"></span><br><span class="line">        [methodNames appendString:methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@" "</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的打印结果如下：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-method-in-middle-class.png?x-oss-process=image/resize,w_800" alt=""></p><p>可以发现，<code>NSKVONotifying_BAOPerson</code> 中有 4 个对象方法，分别是:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setAge:</span><br><span class="line"><span class="keyword">class</span></span><br><span class="line">dealloc</span><br><span class="line">_isKVOA</span><br></pre></td></tr></table></figure></p><p><code>NSKVONotifying_BAOPerson</code> 重写 <code>class</code> 方法是为了隐藏 <code>NSKVONotifying_BAOPerson</code> 不被外界看到。我们在 <code>p1</code> 添加 KVO 之后，分别打印 <code>p1</code> 和 <code>p2</code> 对象的 <code>class</code>，可以发现它们都返回 <code>BAOPerson</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, [p1 <span class="keyword">class</span>], [p2 <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// 打印结果 BAOPerson, BAOPerson</span></span><br></pre></td></tr></table></figure><p>综上，我们可以画出 <code>NSKVONotifying_BAOPerson</code> 的内部结构及方法调用顺序。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-kvo002.png?x-oss-process=image/resize,w_600" alt=""></p><h1 id="验证-didChangeValueForKey-内部调用-observeValueForKeyPath-ofObject-change-context-方法"><a href="#验证-didChangeValueForKey-内部调用-observeValueForKeyPath-ofObject-change-context-方法" class="headerlink" title="验证 didChangeValueForKey: 内部调用 observeValueForKeyPath:ofObject:change:context: 方法"></a>验证 <code>didChangeValueForKey:</code> 内部调用 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法</h1><p>在 <code>BAOPerson</code> 类中重写 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，模拟它们的实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSInteger</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"override setAge"</span>);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey: - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey: - end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey: - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey: - end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行上述代码，可以确定是在 <code>didChangeValueForKey:</code> 方法内部调用了监听者的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-kvo-did-change-value-for-key.png?x-oss-process=image/resize,w_600" alt=""></p><p>根据上述原理，可以通过调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 来手动触发 KVO。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5adab70cf265da0b736d37a8" target="_blank" rel="noopener">iOS底层原理总结 - 探寻KVO本质</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KVO（Key-Value Observing）是 iOS 开发中常用的一种用于监听某个对象属性值变化的技术。下文将以一段示例代码来分析 KVO 的底层原理。&lt;a href=&quot;https://github.com/baochuquan/BAOStudy&quot; target=&quot;_
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="KVO" scheme="http://chuquan.me/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>GCD 原理详解</title>
    <link href="http://chuquan.me/2018/12/01/gcd-introduce/"/>
    <id>http://chuquan.me/2018/12/01/gcd-introduce/</id>
    <published>2018-12-01T12:55:11.000Z</published>
    <updated>2018-12-01T14:07:37.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h1><p>GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。</p><h1 id="GCD-基本概念"><a href="#GCD-基本概念" class="headerlink" title="GCD 基本概念"></a>GCD 基本概念</h1><p>GCD 主要包含两个核心概念：<strong>任务</strong> 和 <strong>队列</strong>。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p><strong>任务</strong>：即要在线程中执行的那段代码。GCD 将任务定义在 block 中。</p><p>任务的执行主要有两种方式：<strong>同步执行（sync）</strong> 和 <strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列中的任务执行结束，是否具备开启新线程的能力</strong>。因此，根据任务的执行方式可以将任务分成两种类型：</p><p><strong>同步任务（sync）</strong></p><ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul><p><strong>异步任务（async）</strong></p><ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul><blockquote><p>注意： <strong>异步任务（async）</strong> 虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（Dispatch Queue）</strong>：即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic07.png" alt=""></p><p>在 GCD 中有两种队列：<strong>串行队列</strong> 和 <strong>并发队列</strong>。两者的主要区别是：<strong>执行顺序不同，开启线程数不同</strong>。</p><p><strong>串行队列</strong></p><ul><li>每次只有一个任务被执行。（只开启一个线程，一个任务执行完毕后，在执行下一个任务）<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic08.png" alt=""></li></ul><p><strong>并发队列</strong></p><ul><li>允许多个任务（同时）执行。（可以开启多个线程，并同时执行任务）<br><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic09.png" alt=""></li></ul><blockquote><p>注意：<strong>并发队列</strong> 的并发功能只有在异步（dispatch_async）函数下才有效。</p></blockquote><h1 id="GCD-使用方法"><a href="#GCD-使用方法" class="headerlink" title="GCD 使用方法"></a>GCD 使用方法</h1><p>GCD 的使用主要包含两个步骤：</p><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统会根据任务类型执行任务（同步执行或异步执行）</li></ol><h2 id="队列的创建-获取"><a href="#队列的创建-获取" class="headerlink" title="队列的创建/获取"></a>队列的创建/获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t</span><br><span class="line">dispatch_queue_create(const char *_Nullable label,</span><br><span class="line">dispatch_queue_attr_t _Nullable attr)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>label</code>：表示队列的唯一标识符，用于 DEBUG，可为空。</li><li><code>attr</code>：表示队列的类型。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列；<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">// 并发队列的创建方法</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><hr><p>对于串行队列，GCD 提供了一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。</p><ul><li><strong>所有放在主队列的任务，都会在主线程执行</strong>。</li><li>可使用 <code>dispatch_get_main_queue()</code> 获取主队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></li></ul><hr><p>对于并发队列，GCD 默认提供了 <strong>全局并发队列（Global Dispatch Queue）</strong>。</p><ul><li>可使用 <code>dispatch_get_global_queue</code> 获取全局并发队列。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 全局并发队列的获取方法</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure></li></ul><p>GCD 提供了 4 个 <strong>全局并发队列</strong>，分别对应不同的优先级。</p><ul><li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li><li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li><li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li><li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台队列</li></ul><h2 id="任务的创建"><a href="#任务的创建" class="headerlink" title="任务的创建"></a>任务的创建</h2><p>GCD 提供了同步执行任务的创建方法 <code>dispatch_sync</code> 和异步执行任务创建方法 <code>dispatch_async</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同步任务创建方法</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    // 这里放同步执行任务代码</span><br><span class="line">&#125;);</span><br><span class="line">// 异步任务创建方法</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 这里放异步执行任务代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="GCD-使用组合"><a href="#GCD-使用组合" class="headerlink" title="GCD 使用组合"></a>GCD 使用组合</h1><p>GCD 有两种队列（串行队列/并发队列），两种任务（同步任务/异步任务），可以得到 4 种不同的使用组合。</p><blockquote><ol><li>同步任务 + 并发队列</li><li>异步任务 + 并发队列</li><li>同步任务 + 串行队列</li><li>异步任务 + 串行队列</li></ol></blockquote><p>实际上，前文还提到两种特殊的队列：全局并发队列、主队列。全局并发队列可作为普通并发队列使用。但是主队列比较特殊，因此又得到 2 种组合：</p><blockquote><ol><li>同步任务 + 主队列</li><li>异步任务 + 主队列</li></ol></blockquote><h2 id="同步执行-并发队列"><a href="#同步执行-并发队列" class="headerlink" title="同步执行 + 并发队列"></a>同步执行 + 并发队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 并发队列</span><br><span class="line"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);          // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic01.png" alt=""></p><p>上图所示为 <code>同步任务 + 并发队列</code> 的工作原理。</p><ul><li><code>syncConcurrent</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至并行队列，并行队列允许多任务同时执行，但由于加入的队列是同步任务，不会开启新线程，在主线程执行。</li><li><code>syncConcurrent</code> 会被同步任务阻塞。</li></ul><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---begin</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x60000068ee80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">syncConcurrent---end</span><br></pre></td></tr></table></figure></p><h2 id="异步任务-并发队列"><a href="#异步任务-并发队列" class="headerlink" title="异步任务 + 并发队列"></a>异步任务 + 并发队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 并发队列</span><br><span class="line"> * 特点：可以开启多个线程，任务交替（同时）执行。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncConcurrent &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic02.png" alt=""></p><p>上图所示为 <code>异步任务 + 并行队列</code> 的工作原理。</p><ul><li><code>asyncConcurrent</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至并行队列，并行队列允许多任务同时执行，且异步任务可以开启新线程，因此每个异步任务都能启动一个独立的线程执行。</li><li><code>asyncConcurrent</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600003e6d580&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncConcurrent---begin</span><br><span class="line">asyncConcurrent---end</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600003ecce40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003eccec0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600003ec2a80&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步任务-串行队列"><a href="#同步任务-串行队列" class="headerlink" title="同步任务 + 串行队列"></a>同步任务 + 串行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 串行队列</span><br><span class="line"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic03.png" alt=""></p><p>上图所示为 <code>同步任务 + 串行队列</code> 的工作原理。</p><ul><li><code>syncSerial</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至串行队列，串行队列不允许多任务同时执行，因此同步任务在当前线程执行（主线程）。</li><li><code>syncSerial</code> 会被同步任务阻塞。</li></ul><h2 id="异步任务-串行队列"><a href="#异步任务-串行队列" class="headerlink" title="异步任务 + 串行队列"></a>异步任务 + 串行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 串行队列</span><br><span class="line"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)asyncSerial &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;me.chuquan.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic04.png" alt=""></p><p>上图所示为 <code>异步任务 + 串行队列</code> 的工作原理。</p><ul><li><code>asyncSerial</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至串行队列，异步任务能开启新线程，但是串行队列不允许多任务，所以只能开启一条新线程。</li><li><code>asyncSerial</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x600001ef5d00&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncSerial---begin</span><br><span class="line">asyncSerial---end</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600001e5a740&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同步任务-主队列"><a href="#同步任务-主队列" class="headerlink" title="同步任务 + 主队列"></a>同步任务 + 主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 同步任务 + 主队列</span><br><span class="line"> * 特点(主线程调用)：互等卡主不执行。</span><br><span class="line"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span><br><span class="line"> */</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic05.png" alt=""></p><p>上图所示为 <code>同步任务 + 主队列</code> 的工作原理。</p><ul><li><code>syncMain</code> 被添加至主队列中，在主线程执行。</li><li>同步任务被添加至主队列，同步任务不会开启新线程，且主队列（属于串行队列）中的任务只能在主线程执行。</li><li><code>syncMain</code> 会被同步任务阻塞。但是需要注意的是 <code>syncMain</code> 和同步任务均在主队列中，同步任务需要等待 <code>syncMain</code> 执行完毕，因此产生死锁。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">崩溃</span><br></pre></td></tr></table></figure></p><p>对于这种情况，可以将 <code>syncMain</code> 放置新线程执行以避免产生死锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure></p><h2 id="异步任务-主队列"><a href="#异步任务-主队列" class="headerlink" title="异步任务 + 主队列"></a>异步任务 + 主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 异步任务 + 主队列</span><br><span class="line"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)asyncMain &#123;</span><br><span class="line">    NSLog(@&quot;currentThread---%@&quot;, [NSThread currentThread]);     // 打印当前线程</span><br><span class="line">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务1</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务2</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加任务3</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic06.png" alt=""></p><p>上图所示为 <code>异步任务 + 主队列</code> 的工作原理。</p><ul><li><code>asyncMain</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至主队列，异步任务能开启新线程，但是主队列（属于串行队列）中的任务只能在主线程执行。</li><li><code>asyncMain</code> 不会被异步任务阻塞。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentThread---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">asyncMain---begin</span><br><span class="line">asyncMain---end</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">1---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">3---&lt;NSThread: 0x6000014d3700&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p><h1 id="GCD-应用"><a href="#GCD-应用" class="headerlink" title="GCD 应用"></a>GCD 应用</h1><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication &#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];                  // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);         // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/ios-gcd-basic10.png" alt=""></p><p>上图所示为线程间通信的工作原理。</p><ul><li><code>communication</code> 被添加至主队列中，在主线程执行。</li><li>异步任务被添加至全局队列（并行队列），异步任务能开启新线程，因此异步任务在新线程执行。</li><li><code>communication</code> 不会被异步任务阻塞。</li><li>当异步任务执行完成后，再将一个异步任务添加至主队列，主队列中的任务都在主线程执行，所以该异步任务在主线程执行。从而达到线程间通信的目的。</li></ul><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x60000227ec80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000022ddd00&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://juejin.im/post/5a90de68f265da4e9b592b40" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a></li><li><a href="https://www.jianshu.com/p/fbe6a654604c" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCD-简介&quot;&gt;&lt;a href=&quot;#GCD-简介&quot; class=&quot;headerlink&quot; title=&quot;GCD 简介&quot;&gt;&lt;/a&gt;GCD 简介&lt;/h1&gt;&lt;p&gt;GCD（Grand Central Dispatch）是 Apple 开发的一个多核编程的解决方法。它主要用
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="GCD" scheme="http://chuquan.me/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 关联对象与 Method Swizzling</title>
    <link href="http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/"/>
    <id>http://chuquan.me/2018/11/23/oc-associate-object-and-method-swizzling/</id>
    <published>2018-11-23T11:39:37.000Z</published>
    <updated>2018-11-23T11:44:54.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h1><p>关联对象，顾名思义，即通过唯一键（<code>key</code>）连接（关联）至某个类的实例上的对象。</p><p>那么什么时候会用到关联对象呢？</p><p>比如，我们需要对内置类 <code>NSArray</code> 添加一个属性（不使用继承）。如何解决？分类似乎只能添加方法。当我们了解关联对象后，就可以轻松实现。</p><h2 id="关联对象基础"><a href="#关联对象基础" class="headerlink" title="关联对象基础"></a>关联对象基础</h2><h3 id="设置关联对象"><a href="#设置关联对象" class="headerlink" title="设置关联对象"></a>设置关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是 <code>self</code></li><li><code>key</code>: 唯一键，在获取值时通过该键获取，通常是使用 <code>static const void *</code> 来声明</li><li><code>value</code>: 关联所设置的值</li><li><code>policy</code>: 内存管理策略</li></ul><h4 id="内存管理策略"><a href="#内存管理策略" class="headerlink" title="内存管理策略"></a>内存管理策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy)&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,             // 表示弱引用关联，通常是基本数据类型</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,   // 表示强引用关联对象，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,     // 表示关联对象copy，是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,         // 表示强引用关联对象，不是线程安全的</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403            // 表示关联对象copy，不是线程安全的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象释放时，会根据设置关联对象时采用的策略来决定是否释放关联对象。当策略为 <code>RETAIN/COPY</code> 时，释放关联对象。当策略为 <code>ASSIGN</code> 时，不释放关联对象。</p><h3 id="获取关联对象"><a href="#获取关联对象" class="headerlink" title="获取关联对象"></a>获取关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>object</code>: 与谁关联，通常是传 <code>self</code>，在设置关联时所指定的与哪个对象关联的那个对象</li><li><code>key</code>: 唯一键，在设置关联值所指定的键</li></ul><h3 id="取消关联对象"><a href="#取消关联对象" class="headerlink" title="取消关联对象"></a>取消关联对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure><p>取消对象的所有关联对象。如果要取消指定的关联对象，可使用 <code>setAssociatedObject</code> 设置为 <code>nil</code> 来实现。</p><h2 id="关联对象应用"><a href="#关联对象应用" class="headerlink" title="关联对象应用"></a>关联对象应用</h2><p>给 <code>UIViewController</code> 添加一个是否需要登录的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL needToLogin;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const char *ViewControllerNeedToLoginKey = &quot;ViewControllerNeedToLoginKey&quot;;</span><br><span class="line"></span><br><span class="line">- (void)setNeedToLogin:(BOOL)needToLogin &#123;</span><br><span class="line">    objc_setAssociatedObject(self, ViewControllerNeedToLoginKey, @(needToLogin), OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)needToLogin &#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, ViewControllerNeedToLoginKey) boolValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><p>Method Swizzling，顾名思义，就是将两个方法的实现交换。</p><p>那么什么时候会用到 Method Swizzling 呢？</p><p>比如，在开发中，我们可能会遇到系统提供的 API 不能满足实际需求。我们希望能够修改它以达到期望的效果。</p><h2 id="Method-Swizzling-原理"><a href="#Method-Swizzling-原理" class="headerlink" title="Method Swizzling 原理"></a>Method Swizzling 原理</h2><p>Method Swizzling 的实现充分利用了 <a href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/">Objective-C runtime 动态绑定机制</a>。</p><p>在 Objective-C 中调用方法，其实是向一个对象发送消息，而查找消息的唯一依据是方法名 <code>selector</code>。每个类都有一个方法列表 <code>objc_method_list</code>，存放着其所有的方法 <code>objc_method</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法 <code>objc_method</code> 保存了方法名（<code>SEL</code>）和方法实现（<code>IMP</code>）的映射关系。Method Swizzling 其实就是重置了 <code>SEL</code> 和 <code>IMP</code> 的映射关系。如下图所示：</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-method-swizzling.png" alt=""></p><h2 id="Method-Swizzling-基础"><a href="#Method-Swizzling-基础" class="headerlink" title="Method Swizzling 基础"></a>Method Swizzling 基础</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method _Nullable class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 方法名</li></ul><h3 id="获取方法实现"><a href="#获取方法实现" class="headerlink" title="获取方法实现"></a>获取方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nonnull class_getMethodImplementation(Class _Nullable cls, SEL _Nonnull name)</span><br></pre></td></tr></table></figure><h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 要添加方法的方法名</li><li><code>imp</code>: 要添加方法的方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP _Nullable class_replaceMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cls</code>: 目标类</li><li><code>name</code>: 目标方法的方法名</li><li><code>imp</code>: 方法的新方法实现</li><li><code>types</code>: 方法实现的编码类型</li></ul><h3 id="交换方法实现"><a href="#交换方法实现" class="headerlink" title="交换方法实现"></a>交换方法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2)</span><br></pre></td></tr></table></figure><h3 id="获取方法的编码类型"><a href="#获取方法的编码类型" class="headerlink" title="获取方法的编码类型"></a>获取方法的编码类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * _Nullable method_getTypeEncoding(Method _Nonnull m)</span><br></pre></td></tr></table></figure><h2 id="Method-Swizzling-应用"><a href="#Method-Swizzling-应用" class="headerlink" title="Method Swizzling 应用"></a>Method Swizzling 应用</h2><p>通过分类允许 <code>NSObject</code> 对任意两个方法进行 Method Swizzling。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError **)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (Swizzle)</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSEL);</span><br><span class="line">    if (originalMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method targetMethod = class_getInstanceMethod(self, targetSEL);</span><br><span class="line">    if (targetMethod == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_addMethod(self, originalSEL, class_getMethodImplementation(self, originalSEL), method_getTypeEncoding(originalMethod));</span><br><span class="line">    class_addMethod(self, targetSEL, class_getMethodImplementation(self, targetSEL), method_getTypeEncoding(targetMethod));</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod(self, originalSEL), class_getInstanceMethod(self, targetSEL));</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)originalSEL withMethod:(SEL)targetSEL error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    Class metaClass = object_getClass((id)self);</span><br><span class="line">    return [metaClass swizzleMethod:originalSEL withMethod:targetSEL error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/c68cc81ef763" target="_blank" rel="noopener">iOS runtime实战应用：关联对象</a></li><li><a href="https://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联对象&quot;&gt;&lt;a href=&quot;#关联对象&quot; class=&quot;headerlink&quot; title=&quot;关联对象&quot;&gt;&lt;/a&gt;关联对象&lt;/h1&gt;&lt;p&gt;关联对象，顾名思义，即通过唯一键（&lt;code&gt;key&lt;/code&gt;）连接（关联）至某个类的实例上的对象。&lt;/p&gt;
&lt;p&gt;那么
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="关联对象" scheme="http://chuquan.me/tags/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="Method Swizzling" scheme="http://chuquan.me/tags/Method-Swizzling/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯·圣彼得堡之旅</title>
    <link href="http://chuquan.me/2018/11/03/st-petersburg/"/>
    <id>http://chuquan.me/2018/11/03/st-petersburg/</id>
    <published>2018-11-03T13:00:47.000Z</published>
    <updated>2018-11-20T14:18:45.563Z</updated>
    
    <content type="html"><![CDATA[<div align="center"><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400" alt=""></div><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5261430&auto=1&height=66"></iframe><p>盼了一年，终于盼来了公司的年度旅行。经过两轮的投票角逐，圣彼得堡众望所归！旅行时间计划是 10 月 27 日~ 11 月1 日，总共 6 天。我们此次行程总共 29 人，走团签，使用公司的旅行基金，每个人额外补贴 1020 元。</p><p>出发前两天，我花了两个晚上做了一下圣彼得堡的旅行攻略。首先，定位各个推荐景点和餐厅的位置，做到心里有点逼数。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg003.png?x-oss-process=image/resize,w_800" alt=""></p><p>然后，综合日期、天气、距离、开/闭馆等情况（圣彼得堡有不少景点会周期性地选择闭馆），做了一个大致的行程计划。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg002.png?x-oss-process=image/resize,w_500" alt=""></p><h1 id="Day-1（周六）"><a href="#Day-1（周六）" class="headerlink" title="Day 1（周六）"></a>Day 1（周六）</h1><p>前一天周五，我们照常上班，部分人（包括我）选择在公司一直待到凌晨，然后一起打车去机场。服务器一帮人去附近的网吧开黑，客户端则在公司打升级，玩任天堂游戏。我在 B 站上看了几个关于圣彼得堡的纪录片。对我来说，旅行中很大一部分乐趣是源自于旅行前的准备工作。</p><p>北京时间凌晨五点，我们从 T3 航站楼启程飞往新西伯利亚。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg004.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg008.png?x-oss-process=image/resize,w_800" alt=""></p><p>经过四个半小时的飞行，飞越了数千公里的冰川，最终抵达新西伯利亚。降落前，从新西伯利亚上空俯瞰整个城市，第一感觉便是衰败。这与我的预期完全不符，心里难免有一些失落。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg005.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg006.png?x-oss-process=image/resize,w_800" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg007.png?x-oss-process=image/resize,w_500" alt=""></p><p>在新西伯利亚机场转机等待了近2个小时，我们踏上了飞往圣彼得堡的行程。经历四个半小时，飞机成功降落于圣彼得堡普尔科沃机场，机舱里响起来热烈的掌声。</p><p>导游和大巴早已在机场等候多时，安置好行李后，我们从机场出发。沿着机场高速，经过跨海大桥，最终抵达我们位于瓦西里岛上的 Park inn 酒店。安排完入住后已经差不多下午2点多了。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg009.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg010.png" alt=""></p><p>在客房稍事休息，洗漱一下，我们（@大龙哥，@邱老师，@张成）便出门去逛附近的超市。买了烤鸡、黄瓜、香蕉、面包、啤酒、果汁，然后便是回酒店嗨。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg011.png" alt=""></p><p>来圣彼得堡之前，我听说酒店有游泳池。于是晚上一闲下来，便在酒店一楼大厅瞎转，找游泳池。大厅绕了一圈，一对青年毛子情侣看到了我，小哥立马过来跟我尬聊了起来。小哥用带卷舌的英语，我用蹩脚的 Chinglish。聊了二十分钟，我还是没明白他到底想表达什么。。。</p><h1 id="Day-2（周日）"><a href="#Day-2（周日）" class="headerlink" title="Day 2（周日）"></a>Day 2（周日）</h1><p>一大早起来，打开窗帘，外面已然是白茫茫一片。天气与预期一样，那么计划也是一样。今天行程是冬宫。</p><p>来圣彼得堡之前，我们便以在飞猪上购买了电子票。冬宫早上10点半开放，我们分了好几拨，早早便抵达了冬宫快速通道门口。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg012.png" alt=""></p><p>我们差不多画了5个小时的时间走马观花地逛了一遍冬宫。一楼是古埃及相关的展厅，我没怎么逛。二楼是沙俄以及西方中世纪的一些展品。三楼主要东方的一些展品。二楼的展品尤为绚烂，其中包括两幅达芬奇的真迹（世界仅存14副真迹）。果然不愧为世界四大博物馆，不禁感慨如果圆明园未毁，也许可以与其相媲美。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg013.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg016.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg017.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg015.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg014.png" alt=""></p><p>逛完冬宫差不多已经下午三点半了，早已饥渴难耐，我们打车去附近一家小餐厅Varvara。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg018.png" alt=""></p><p>简餐过后，我们沿着涅瓦大街闲逛，欣赏一下沿途的风景。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg019.png" alt=""></p><h1 id="Day3（周一）"><a href="#Day3（周一）" class="headerlink" title="Day3（周一）"></a>Day3（周一）</h1><p>今天计划的第一站是圣以撒大教堂。刚刚抵达圣以撒大教堂，便遇到一群当地的小孩，冲着我们喊“你好”。尴尬的是我们居然不知道“你好”用俄语怎么说，只能也挥手喊着“你好”予以回应。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg020.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg021.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg022.png" alt=""></p><p>圣以撒大教堂可以允许游客登顶观光，俯瞰整个圣彼得堡。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg023.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg026.png" alt=""></p><p>与圣以撒大教堂合完影之后，我们便步行向北前往十二月党人广场，广场的中央是彼得大帝青铜骑士像。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg024.png" alt=""></p><p>在广场逗留了一会儿，大家分头行动，我们（@邱老师，@大龙哥，@刘杨）决定去救世主滴血大教堂。抵达滴血大教堂，有一些一行，教堂的洋葱头正在维修，据说从去年至今一直在维修。不过教堂的内饰真的是美轮美奂，所有的壁画都是用指甲大小的马赛克拼接而成的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg027.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg025.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg028.png?x-oss-process=image/resize,w_500" alt=""></p><p>救世主滴血大教堂参观完毕，我们（@吴迪，@海侠，@大龙哥，@邱老师，@刘杨）来到了涅瓦大街吃午餐。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg030.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg029.png" alt=""></p><p>吃完饭，我们在旁边的纪念品店里逛了一会儿，然后他们准备去商场购物。而我则打算去马路对面的喀山大教堂去拍照。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg032.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg031.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg034.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg033.png?x-oss-process=image/resize,w_500" alt=""></p><p>拍完照，我便独自向我们约定的商场步行而去，与大家汇合。</p><h1 id="Day4（周二）"><a href="#Day4（周二）" class="headerlink" title="Day4（周二）"></a>Day4（周二）</h1><p>雪后第一天尤其寒冷，今天的计划则是去彼得保罗要塞观光。彼得堡罗要塞其实就是一个小岛，岛上有监狱（曾关押过高尔基）、教堂（埋葬了历代沙皇）、博物馆，我们也是挨个儿参观了一遍。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg035.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg037.png?x-oss-process=image/resize,w_500" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg036.png" alt=""></p><p>差不多下午一点参观完各个景点，我们在一个小博物馆里逗留了一会儿，然后决定去岛上的一家推荐餐厅。餐厅位于小岛的西边，迎着涅瓦河。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg039.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg038.png" alt=""></p><p>餐后，大家决定一起去看阿芙乐尔号巡洋舰。在路上顶着寒风大概走了半个小时终于到了阿芙乐尔号巡洋舰的地址。参观的总体感觉是比较坑，门票大约70元人民币，比冬宫还贵。里面只有一个小小的博物馆而已。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg040.png" alt=""></p><h1 id="Day5（周三）"><a href="#Day5（周三）" class="headerlink" title="Day5（周三）"></a>Day5（周三）</h1><p>昨天在去往阿芙乐尔号的路上简直被吹成了傻逼，对于今天去叶卡捷琳娜宫的计划我有些犹豫。“既然都来了，就去看看吧”这样的念头促成我又做了一次傻逼的决定。叶卡捷琳娜宫只在下午一点后对散客开放，并且每15分钟放入20来人。我们上午到叶宫，在前面的花园里逛了一圈。差不多下午一点，到叶宫入口排队。寒风中吹了近两个小时才进入叶宫。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg041.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg042.png" alt=""></p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg043.png" alt=""></p><p>说实话，叶宫真心无法与冬宫相比，除了琥珀宫，里面基本都是些宴会大厅。另外，加上这几天的行程，基本已经属于审美疲劳状态。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg044.png" alt=""></p><h1 id="Day5（周四）"><a href="#Day5（周四）" class="headerlink" title="Day5（周四）"></a>Day5（周四）</h1><p>早上10:20在酒店大厅集合去机场。第一次来俄罗斯，并且是有如此浓厚艺术气息的圣彼得堡，虽然旅程很短暂，但是内心很满足。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/st-petersburg/st-petersburg001.png?x-oss-process=image/resize,w_400&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="旅行" scheme="http://chuquan.me/categories/%E6%97%85%E8%A1%8C/"/>
    
    
      <category term="游记" scheme="http://chuquan.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="自由行" scheme="http://chuquan.me/tags/%E8%87%AA%E7%94%B1%E8%A1%8C/"/>
    
      <category term="俄罗斯" scheme="http://chuquan.me/tags/%E4%BF%84%E7%BD%97%E6%96%AF/"/>
    
      <category term="圣彼得堡" scheme="http://chuquan.me/tags/%E5%9C%A3%E5%BD%BC%E5%BE%97%E5%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 消息传递与转发</title>
    <link href="http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/"/>
    <id>http://chuquan.me/2018/10/20/ios-runtime-message-sending-and-forwarding/</id>
    <published>2018-10-20T09:15:32.000Z</published>
    <updated>2018-11-27T13:04:22.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，在 C 语言的基础上实现了面向对象的功能。在 runtime 中，对象用结构体表示，方法用函数表示。</p><p>C 语言是一门静态语言，其在编译时决定调用哪个函数。而 Objective-C 则是一门动态语言，其在编译时不能决定最终执行时调用哪个函数（Objective-C 中函数调用称为消息传递）。Objective-C 的这种动态绑定机制正是通过 runtime 这样一个中间层实现的。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/oc-runtime-hierachry.png?x-oss-process=image/resize,w_300" alt=""></p><p>为了分析 runtime 是如何进行动态绑定，我们首先需要了解一下 Objective-C 中类与对象等基本结构在 C 语言层面是如何实现的。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Objective-C-类"><a href="#Objective-C-类" class="headerlink" title="Objective-C 类"></a>Objective-C 类</h2><p>Objective-C 类是由 <code>Class</code> 类型表示的，它本质上是一个指向 <code>objc_class</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line"></span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure></p><h2 id="Objective-C-对象"><a href="#Objective-C-对象" class="headerlink" title="Objective-C 对象"></a>Objective-C 对象</h2><p>Objective-C 对象是由 <code>id</code> 类型表示的，它本质上是一个指向 <code>objc_object</code> 结构体的指针。如下所示为 <code>objc/objc.h</code> 中关于对象的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>objc_object</code> 结构体中只有一个成员，即指向其类的 <code>isa</code> 指针。<strong>当向一个 Objective-C 对象发送消息时，runtime 会根据实例对象的 <code>isa</code> 指针找到其所属的类。Runtime 会在类的方法列表以及父类的方法列表中去寻找与消息对应的 <code>selector</code> 指向的方法，找到后即运行该方法。</strong></p><h2 id="Objective-C-元类（meta-class）"><a href="#Objective-C-元类（meta-class）" class="headerlink" title="Objective-C 元类（meta class）"></a>Objective-C 元类（meta class）</h2><p><code>meta-class</code> 是一个<strong>类对象的类</strong>。在 Objective-C 中，所有的类本身也是一个对象。事实上，在很多原型编程语言也采用这种“万物皆对象”的设计思想，如：Io。</p><p>通过向该对象发送消息，即可实现对类方法的调用。前提是类的 <code>isa</code> 指针必须指向一个包含这些类方法的 <code>objc_class</code> 结构体。<code>meta-class</code> 中存储着一个类的所有类方法。所以，类对象的 <code>isa</code> 指针指向的就是 <code>meta-class</code>。</p><ul><li><strong>当向一个对象发送消息时，runtime 会在这个对象所属的类的方法列表中查找方法。</strong></li><li><strong>当向一个类发送消息时，runtime 会在这个类的 meta-class 的方法列表中查找。</strong></li></ul><p>思考一下，<code>meta-class</code> 也是一个类，也可以向它发送一个消息，那么它的 <code>isa</code> 又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C 的设计者让所有的 <code>meta-class</code> 的 <code>isa</code> 指向基类的 <code>meta-class</code>，以此作为它们的所属类。</p><p>下图所示，为 Objective-C 对象在内存中的引用关系图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-time-message-send.png" alt=""></p><h2 id="Objective-C-方法"><a href="#Objective-C-方法" class="headerlink" title="Objective-C 方法"></a>Objective-C 方法</h2><p>方法实际上是一个指向 <code>objc_method</code> 结构体的指针。如下所示为 <code>objc/runtime.h</code> 中关于方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line"></span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结构体中包含成员 <code>SEL</code> 和 <code>IMP</code>，两者将方法的名字与实现进行了绑定。通过 <code>SEL</code>，可以找到对应的 <code>IMP</code>，从而调用方法的具体实现。</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>SEL</code> 又称选择器，是一个指向 <code>objc_selector</code> 结构体的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>方法的 <code>selector</code> 用于表示运行时方法的名字。<strong>Objective-C 在编译时，会根据方法的名字（不包括参数）生成一个唯一的整型标识（ <code>Int</code> 类型的地址），即 <code>SEL</code>。</strong></p><p>由于一个类的方法列表中不能存在两个相同的 <code>SEL</code>，所以 Objective-C 不支持重载。但是不同类之间可以存在相同的 <code>SEL</code>，因为不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中去根据 <code>selector</code> 去寻找自己对应的 <code>IMP</code>。</p><p>通过下面三种方法可以获取 <code>SEL</code>：</p><ul><li><code>sel_registerName</code> 函数</li><li>Objective-C 编译器提供的 <code>@selector()</code> 方法</li><li><code>NSSeletorFromString()</code> 方法</li></ul><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code> 本质上就是一个函数指针，指向方法实现的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL,...);</span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><code>id</code>：指向 <code>self</code> 的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针）</li><li><code>SEL</code>：方法选择器</li><li><code>...</code>：方法的参数列表</li></ul><p><code>SEL</code> 与 <code>IMP</code> 的关系类似于哈希表中 <code>key</code> 与 <code>value</code> 的关系。采用这种哈希映射的方式可以加快方法的查找速度。</p><h1 id="消息传递（方法调用）"><a href="#消息传递（方法调用）" class="headerlink" title="消息传递（方法调用）"></a>消息传递（方法调用）</h1><p>在 Objective-C 中，<strong>消息直到运行时才绑定到方法实现上</strong>。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息函数的调用，即 <code>objc_msgSend</code>。这个函数将消息接收者和方法名作为主要参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)                    // 不带参数</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)    // 带参数</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 通过以下几个步骤实现了动态绑定机制。</p><ul><li>首先，获取 <code>selector</code> 指向的方法实现。由于相同的方法可能在不同的类中有着不同的实现，因此根据 <code>receiver</code> 所属的类进行判断。</li><li>其次，传递 <code>receiver</code> 对象、方法指定的参数来调用方法实现。</li><li>最后，返回方法实现的返回值。</li></ul><p>消息传递的关键在于前文讨论过的 <code>objc_class</code> 结构体，其有两个关键的字段：</p><ul><li><code>isa</code>：指向父类的指针</li><li><code>methodLists</code>: 类的方法分发表（<code>dispatch table</code>）</li></ul><p>当创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 <code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承链。</p><p>下图所示为消息传递过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/oc-messaging-framework.png" alt=""></p><ul><li>当消息传递给一个对象时，首先从运行时系统缓存 <code>objc_cache</code> 中进行查找。如果找到，则执行。否则，继续执行下面步骤。</li><li><code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法分发表 <code>methodLists</code> 中查找方法的 <code>selector</code>。如果未找到，将沿着类的 <code>isa</code> 找到其父类，并在父类的分发表 <code>methodLists</code> 中继续查找。</li><li>以此类推，一直沿着类的继承链追溯至 <code>NSObject</code> 类。一旦找到 <code>selector</code>，传入相应的参数来执行方法的具体实现，并将该方法加入缓存 <code>objc_cache</code> 。如果最后仍然没有找到 <code>selector</code>，则会进入<strong>消息转发</strong>流程（下文将进行介绍）。</li></ul><h1 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h1><p>当一个对象能接收一个消息时，会走正常的消息传递流程。当一个对象无法接收某一消息时，会发生什么呢？默认情况下，如果以 <code>[object message]</code> 的形式调用方法，如果 <code>object</code> 无法响应 <code>message</code> 消息时，编译器会报错。如果是以 <code>performSeletor:</code> 的形式调用方法，则需要等到运行时才能确定 <code>object</code> 是否能接收 <code>message</code> 消息。如果不能，则程序崩溃。</p><p>对于后者，当不确定一个对象是否能接收某个消息时，可以调用 <code>respondsToSelector:</code> 来进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，当一个对象无法接收某一消息时，就会启动所谓“消息转发（message forwarding）”机制。通过消息转发机制，我们可以告诉对象如何处理未知的消息。</p><p>消息转发机制大致可分为三个步骤：</p><ul><li>动态方法解析（Dynamic Method Resolution）</li><li>备用接收者</li><li>完整消息转发</li></ul><p>下图所示为消息转发过程的示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/daily-images/ios-message-forwarding.png" alt=""></p><h2 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h2><p>对象在接收到未知的消息时，首先会调用所属类的类方法 <code>+resolveClassMethod:</code> 或实例方法 <code>+resolveInstanceMethod:</code>。</p><p>在这两个方法中，我们可以为未知消息新增一个“处理方法”，通过运行时 <code>class_addMethod</code> 函数动态添加到类中。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // 方法实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方案更多的是为了实现@dynamic属性。</p><h2 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h2><p>如果在上一步无法处理消息，则 runtime 会继续调用 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法。</p><p>如果一个对象实现了这个方法，并返回一个非 <code>nil</code>（也不能是 <code>self</code>） 的对象，则这个对象会称为消息的新接收者，消息会被分发到这个对象。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSString * selString = NSStringFromSelector(aSelector);</span><br><span class="line">    if ([selString isEqualToString:@&quot;walk&quot;]) &#123;</span><br><span class="line">        return self.otherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p><h2 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h2><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。<br>这步调用 <code>methodSignatureForSelector</code> 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 <code>nil</code>，则说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;testInstanceMethod&quot;])&#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjcTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;  </span><br><span class="line">    return [super methodSignatureForSelector: aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回 <code>methodSignature</code>，则进入 <code>forwardInvocation</code>。对象会创建一个表示消息的 <code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在 <code>anInvocation</code> 中，包括 <code>selector</code>，<code>target</code>，参数。在这个方法中可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvovation:(NSInvocation)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    [anInvocation setSelector:@selector(run)];</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以利用备用接受者和完整消息转发实现对接受消息对象的转移，可以实现“多重继承”的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">Objective-C Runtime · 笔试面试知识整理</a></li><li><a href="https://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></li><li><a href="https://www.jianshu.com/p/f493bc6a949e" target="_blank" rel="noopener">iOS内功篇：runtime</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Objective-C 本质上是一种基于 C 语言的领域特定语言。Objective-C 通过一个用 C 语言和汇编实现的 runtime，
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://chuquan.me/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://chuquan.me/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Run Loop 原理详解</title>
    <link href="http://chuquan.me/2018/10/06/understand-ios-runloop/"/>
    <id>http://chuquan.me/2018/10/06/understand-ios-runloop/</id>
    <published>2018-10-06T12:08:25.000Z</published>
    <updated>2019-06-16T12:39:13.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><p>通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或框架中，需要实现一种这样机制：线程能够随时处理事件或消息，并且不会在执行完成后退出。这种机制称为 Event Loop，其一般逻辑吐下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function main</span><br><span class="line">    initialize()</span><br><span class="line">    while message != quit</span><br><span class="line">        message := get_next_message()</span><br><span class="line">        process_message(message)</span><br><span class="line">    end while</span><br><span class="line">end function</span><br></pre></td></tr></table></figure><p>Event Loop 在很多系统或框架中都有对应的实现，如 Node.js 的事件处理，Windows 程序的消息循环，OSX/iOS 中的 RunLoop。实现这种机制的关键在于：如何管理事件/消息，如何让线程在没有处理任务时休眠以避免资源占用，如何在事件/消息到来时唤醒。</p><h1 id="Run-Loop"><a href="#Run-Loop" class="headerlink" title="Run Loop"></a>Run Loop</h1><p>Run Loop 是 OSX/iOS 平台下对 Event Loop 机制的一种实现。当没有事件/消息时，Run Loop 进入休眠状态。当有事件/消息时，Run Loop 调用对应的 Handler 进行处理。如下图所示为 Run Loop 的工作模式示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop.png" alt=""></p><p>由上图可知，Run Loop 从 <strong>Input sources</strong> 和 <strong>Timer sources</strong> 接收事件，然后在线程中处理。</p><p>Run Loop 本质上就是一个对象，其管理需要处理的事件/消息，并提供一个入口函数来执行上面 Event Loop 的逻辑。线程执行该函数后，会一直处于其内部的“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环中，直到循环结束（比如传入 <code>quit</code> 的消息），函数返回。</p><p>OSX/iOS 中提供了两种 Run Loop 的实现：</p><ul><li><code>CFRunLoopRef</code>：CoreFoundation 框架对于 Run Loop 的实现，其提供纯 C 函数的 API（线程安全）。</li><li><code>NSRunLoop</code>：基于 <code>CFRunLoopRef</code> 的封装，其提供面向对象的 API（非线程安全）。</li></ul><h1 id="Run-Loop-与线程"><a href="#Run-Loop-与线程" class="headerlink" title="Run Loop 与线程"></a>Run Loop 与线程</h1><p>Run Loop 和线程是一一对应的。每个线程（包括主线程）都有一个对应的 Run Loop 对象。Run Loop 对象的创建发生在第一次获取时（如果不主动获取，它一直都不会被创建）；Run Loop 对象的销毁发生在线程结束时。</p><p>用户无法创建 Run Loop 对象，但可以获取系统提供的 Run Loop 对象。注意：<strong>只能在一个线程的内部获取其 Run Loop 对象，主线程不受限制</strong>。</p><p>关于 Run Loop 的启动，主线程的 Run Loop 在应用启动时自动启动，其他线程的 Run Loop 默认不会自动启动，需手动启动。</p><h1 id="Run-Loop-Source"><a href="#Run-Loop-Source" class="headerlink" title="Run Loop Source"></a>Run Loop Source</h1><p>从上面 Run Loop 工作模式示意图中可知，Run Loop 有两种接收事件的渠道：Input Source、Timer Source。</p><h2 id="Input-Source"><a href="#Input-Source" class="headerlink" title="Input Source"></a>Input Source</h2><p>Input Source 可分为两类：</p><ul><li><code>Custom Input Sources</code>（<code>Source0</code>）：用户自定义的事件，不会主动触发事件，也不会主动唤醒 Run Loop 的线程。如：<code>UIEvent</code>、<code>CFSocket</code>、普通函数调用、系统调用等。</li><li><code>Port-Based Sources</code>（<code>Source1</code>）：系统底层的 Port 事件（Mac Port），如 <code>CFMachPort</code>，<code>CFMessagePort</code>。一般用于通过内核和其他线程相互发送消息，应用层很少使用。这种 Source 可以主动唤醒 Run Loop 的线程。</li></ul><h2 id="Timer-Source"><a href="#Timer-Source" class="headerlink" title="Timer Source"></a>Timer Source</h2><p>Timer Source 即定时器事件。本质上仍然属于 <code>Port-Based Source</code>，所有的 Timer 都共用一个端口“Mode Timer Port”。</p><h1 id="Run-Loop-Observer"><a href="#Run-Loop-Observer" class="headerlink" title="Run Loop Observer"></a>Run Loop Observer</h1><p>Run Loop 通过监控 Source 来决定是否执行处理程序。而 Runloop Observer 则监控 Runloop 本身的状态。 Runloop Observer 可监控的 runloop 事件如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0),   // 即将进入 Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1),   // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),   // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),   // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6),   // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7),   // 即将退出 Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Run-Loop-Mode"><a href="#Run-Loop-Mode" class="headerlink" title="Run Loop Mode"></a>Run Loop Mode</h1><p>Run Loop Mode 即 Run Loop 工作模式。苹果文档中定义了 5 种 Mode：</p><ul><li><code>NSDefaultRunLoopMode</code></li><li><code>NSConnectionReplyMode</code></li><li><code>NSModalPanelRunLoopMode</code></li><li><code>NSEventTrackingRunLoopMode</code></li><li><code>NSRunLoopCommonModes</code></li></ul><p>iOS 中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和 <code>NSRunLoopCommonModes</code>。 <code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认包括 <code>NSDefaultRunLoopMode</code> 和 <code>NSEventTrackingRunLoopMode</code>。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-mode.png" alt=""></p><p>一个 Run Loop 可以包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。Run Loop 在某个时刻只能工作在一个 Mode 下，处理该 Mode 中的 Source/Timer/Observer。如果需要切换 Mode，只能退出 Run Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，使其互不影响。</p><p>如下所示为 Run Loop Mode 和 Run Loop 的部分源码定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">  </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Source/Timer/Observer 被统称为 <code>Mode Item</code>，一个 Item 可以被同时加入多个 Mode。但一个 Item 被重复加入同一个 Mode 时是不会有效果的。如果一个 Mode 中一个 Item 都没有，则 Run Loop 会直接退出，不进入“<code>接受消息</code>-&gt;<code>等待</code>-&gt;<code>处理</code>”循环。</p><h2 id="Common-Mode"><a href="#Common-Mode" class="headerlink" title="Common Mode"></a>Common Mode</h2><p>一个 Mode 可以将自己标记为 <code>Common</code>（通过将其 Mode Name 添加到 Run Loop 的 <code>_commonModes</code> 中）。<strong>每当 Run Loop 内容发生变化，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode 里</strong>。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>主线程的 Run Loop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为 <code>Common</code>。<code>kCFRunLoopDefaultMode</code> 是 App 平时所处的状态，<code>UITrackingRunLoopMode</code> 是追踪 ScrollView 滑动时的状态。当创建一个 Timer 并加到 <code>kCFRunLoopDefaultMode</code> 时，Timer 会得到重复回调，但此时滑动 TableView 时，Run Loop 会将 Mode 切换为 <code>UITrackingRunLoopMode</code>。这是系统为了保持滑动流畅而做出的 Mode 切换。但这会导致 Timer 不被回调。</p><p>为了让 Timer 能在这两种 Mode 下都能得到回调，有 3 种解决方案：</p><ol><li>将 Timer 分别加入两种 Mode</li><li>将 Timer 加入 Run Loop 的 <code>_commonModeItems</code> 中。因为，Run Loop 发生变化时，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 <code>Common</code> 标记的所有 Mode 里。</li><li>在另一个线程执行和处理 Timer 事件，然后在主线程更新 UI。</li></ol><h1 id="Run-Loop-工作流程"><a href="#Run-Loop-工作流程" class="headerlink" title="Run Loop 工作流程"></a>Run Loop 工作流程</h1><p>下图所示为 Run Loop 工作流程示意图。</p><p><img src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/blog-images/ios-runloop-internal-logic.png" alt=""></p><p>如下所示为 Run Loop 工作流程的核心代码整理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">     </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">     </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">  </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// ? 一个基于 port 的Source 的事件。</span><br><span class="line">            /// ? 一个 Timer 到时间了</span><br><span class="line">            /// ? RunLoop 自身的超时时间到了</span><br><span class="line">            /// ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">             </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其内部是一个 do-while 循环。当调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于-Run-Loop-的系统功能"><a href="#基于-Run-Loop-的系统功能" class="headerlink" title="基于 Run Loop 的系统功能"></a>基于 Run Loop 的系统功能</h1><p>如下所示为 App 启动后 Run Loop 的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>modes</code> 成员的状态可知，系统默认注册了 5 个 Mode：</p><ul><li><code>kCFRunLoopDefaultMode</code>：App 的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li><code>UITrackingRunLoopMode</code>：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li><code>UIInitializationRunLoopMode</code>：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。</li><li><code>GSEventReceiveRunLoopMode</code>：接收系统事件的内部 Mode，通常用不到。</li><li><code>kCFRunLoopCommonModes</code>：占位的 Mode，无实际作用。</li></ul><h2 id="AutoReleasePool"><a href="#AutoReleasePool" class="headerlink" title="AutoReleasePool"></a>AutoReleasePool</h2><p>App 启动后，系统在主线程 Run Loop 中注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p><p>第一个 Observer 监听了一个事件：</p><ul><li><strong>kCFRunLoopEntry</strong>（即将进入 Loop）：调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是 -2147483647，优先级最高，保证在其他所有回调之前创建。</li></ul><p>第二个 Observer 监听了两个事件： </p><ul><li><strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）：调用 <code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧池并创建新池。</li><li><strong>kCFRunLoopExit</strong>（即将退出 Loop）：调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。其 order 是 2147483647，优先级最低，保证在其他所有回调之后释放。</li></ul><p>事件回调、Timer 回调一般在主线程执行。这些回调会被 Run Loop 创建的 AutoreleasePool 所环绕，所以不会出现内存泄漏，开发者也不必显式创建自动释放池。</p><h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个 Source1（Mach Port）用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键（锁屏/静音等）、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括：识别 UIGesture、处理屏幕旋转、发送给 UIWindow 等。在此回调中完成的事件包括：UIButton 点击、touchesBegin/Move/End/Cancel 事件等。</p><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠）事件，这个 Observer 的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p><p>当有 UIGestureRecognizer 的变化（创建/销毁/状态改变）时，这个回调都会进行相应处理。</p><h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>（即将进入休眠） 和 <strong>kCFRunLoopExit</strong>（即将退出 Loop），回调执行的函数会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是 CFRunLoopTimerRef。一个 NSTimer 注册到 Run Loop 后，Run Loop 会为其重复的时间点注册事件。例如 10:00, 10:10, 10:20 这几个时间点。Run Loop为了节省资源，并不会在非常准确的时间点回调 Timer。Timer 有个属性叫做 Tolerance（宽容度），标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p><h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">Run Loops</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></li><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runloop.html" target="_blank" rel="noopener">RunLoop</a></li><li><a href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/" target="_blank" rel="noopener">@autoreleasepool-内存的分配与释放</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Event-Loop&quot;&gt;&lt;a href=&quot;#Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;Event Loop&quot;&gt;&lt;/a&gt;Event Loop&lt;/h1&gt;&lt;p&gt;通常，一个线程一次只能执行一个任务，任务完成后线程就会退出。但是在很多系统或
      
    
    </summary>
    
      <category term="iOS" scheme="http://chuquan.me/categories/iOS/"/>
    
    
      <category term="Run Loop" scheme="http://chuquan.me/tags/Run-Loop/"/>
    
  </entry>
  
</feed>
