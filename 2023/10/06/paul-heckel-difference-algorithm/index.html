<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/chu.icon">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/chu.icon">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chuquan.me","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前一篇 文章 我们介绍了 Myers 差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit 等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——Paul Heckel 差分算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="Paul Heckel 差分算法">
<meta property="og:url" content="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/index.html">
<meta property="og:site_name" content="楚权的世界">
<meta property="og:description" content="前一篇 文章 我们介绍了 Myers 差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit 等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——Paul Heckel 差分算法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-06T14:01:00.000Z">
<meta property="article:modified_time" content="2023-10-07T00:13:19.803Z">
<meta property="article:author" content="Bao Chuquan">
<meta property="article:tag" content="差分算法">
<meta property="article:tag" content="Paul Heckel">
<meta property="article:tag" content="IGListKit">
<meta property="article:tag" content="IGListDiff">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/","path":"2023/10/06/paul-heckel-difference-algorithm/","title":"Paul Heckel 差分算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Paul Heckel 差分算法 | 楚权的世界</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?030cf08d5b27d756fa9aeecb1130fe13"></script>






<link rel="dns-prefetch" href="https://vercel.chuquan.me">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="楚权的世界" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>
  <a href="https://github.com/baochuquan"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_orange_ff7600.png?resize=149%2C149" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>
  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">楚权的世界</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Seek the wonder of life.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">解决什么问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">算法原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">2.1.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="nav-number">3.1.</span> <span class="nav-text">构建阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%B1%BB%E5%9E%8B%E7%AD%9B%E9%80%89"><span class="nav-number">3.2.</span> <span class="nav-text">移动类型筛选</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E9%A1%B9%E7%AD%9B%E9%80%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">唯一项筛选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E9%A1%B9%E7%AD%9B%E9%80%89"><span class="nav-number">3.2.2.</span> <span class="nav-text">重复项筛选</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E8%BE%93%E5%87%BA"><span class="nav-number">3.3.</span> <span class="nav-text">分析输出</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%BC%BA%E9%99%B7"><span class="nav-number">4.</span> <span class="nav-text">算法缺陷</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">算法应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95"><span class="nav-number">5.1.</span> <span class="nav-text">类型扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iglistdiff"><span class="nav-number">5.2.</span> <span class="nav-text">IGListDiff</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="nav-number">5.2.2.</span> <span class="nav-text">核心逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%98%B6%E6%AE%B5-1"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">构建阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E7%A7%BB%E5%8A%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9B%B4%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">标记移动类型和更新类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">格式化输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93"><span class="nav-number">5.2.3.</span> <span class="nav-text">优化小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bao Chuquan"
      src="/images/SlamDunk.png">
  <p class="site-author-name" itemprop="name">Bao Chuquan</p>
  <div class="site-description" itemprop="description">积累，沉淀，吸收，转换</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">151</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">381</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/baochuquan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;baochuquan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:baochuquan@gmail.com" title="E-Mail → mailto:baochuquan@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/baochuquan" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;baochuquan" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Baochuquan" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Baochuquan" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuquan.me/2023/10/06/paul-heckel-difference-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/SlamDunk.png">
      <meta itemprop="name" content="Bao Chuquan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="楚权的世界">
      <meta itemprop="description" content="积累，沉淀，吸收，转换">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Paul Heckel 差分算法 | 楚权的世界">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Paul Heckel 差分算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-06 22:01:00" itemprop="dateCreated datePublished" datetime="2023-10-06T22:01:00+08:00">2023-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-07 08:13:19" itemprop="dateModified" datetime="2023-10-07T08:13:19+08:00">2023-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/10/06/paul-heckel-difference-algorithm/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/10/06/paul-heckel-difference-algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>前一篇 <a
href="http://chuquan.me/2023/09/13/myers-difference-algorithm/">文章</a>
我们介绍了 Myers
差分算法，其主要应用在版本控制系统，用于比较不同版本的源代码，比如：git、svn、gerrit
等。本文，我们再来介绍一下 UI 框架中常用于数据差异检测的算法——Paul
Heckel 差分算法。</p>
<span id="more"></span>
<h1 id="解决什么问题">解决什么问题？</h1>
<p>通过前一篇文章，我们知道 Myers 差分算法主要用于
<strong>解决特定设定下的最小编辑距离问题</strong>，即：当编辑操作只支持
<strong>插入</strong> 和 <strong>删除</strong> 时，计算一个文件从
<code>A</code> 状态转换成 <code>B</code>
状态所需的最少编辑次数（或编辑方式）。算法特别适用于对编辑次数敏感，但是对速度和内存不敏感的系统，比如版本控制系统。</p>
<p>对比而言，Paul Heckel 差分算法则主要用于
<strong>解决最小化差异问题</strong>，即：当一个文件从 <code>A</code>
状态转换成 <code>B</code>
状态时，两种状态之间的数据差异。算法会为每一项差异定义一个对应的类型（操作），比如：删除、插入、移动等，其侧重点在于最小化差异，而不是最小化编辑。Paul
Heckel 差分算法特别适合对计算速度敏感，但是对于
<strong>差异不敏感</strong> 的系统，比如实时数据分析系统，UI
框架数据差分。</p>
<h1 id="算法原理">算法原理</h1>
<h2 id="核心思想">核心思想</h2>
<p>Paul Heckel
算法使用三种类型来表示两个文件之间的差异结果，分别是：<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。基于此，算法的核心思路其实非常简单，分别是：</p>
<ul>
<li><strong>确定旧文件中待删除的行</strong></li>
<li><strong>确定新文件中待插入的行</strong></li>
<li><strong>确定旧文件至新文件中待移动的行，并记录行号关系（旧文件行号、新文件行号）</strong></li>
</ul>
<h2 id="数据结构">数据结构</h2>
<p>很显然，根据算法的核心思想，新旧两个文件中的所有行最终都将被分类为三种类型（如果行的内容和位置都没有变化，则分类为移动类型，只不过移动的行号保持不变而已）。</p>
<p>Paul Heckel 差分算法使用两个数组 <code>NA</code>（New Array）和
<code>OA</code>（Old
Array）分别记录新旧两个文件的每一行的信息。数组元素分为两种类型：<strong>指针</strong>
或
<strong>行号</strong>。通过这种方式，我们可以对新旧两个文件中的所有行进行分类：</p>
<ul>
<li>当旧文件中某一行在 <code>OA</code>
中对应的元素为指针时，表示这一行是待删除的。</li>
<li>当新文件中某一行在 <code>NA</code>
中对应的元素为指针时，表示这一行是待插入的。</li>
<li>当新文件（旧文件）中某一行在
<code>NA</code>（<code>OA</code>）中对应的元素为行号时，表示这一行是待移动的。行号记录了它在旧文件（新文件）的位置。两两配对。</li>
</ul>
<p>这里提到了数组元素可能是指针类型，那么它到底指向什么类型的数据呢？事实上，这是
Paul Heckel 算法预定义的一种数据类型，这里我们称之为 entry 类型。entry
的定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">entry</span> &#123;</span><br><span class="line">    <span class="type">int</span> oc;         <span class="comment">// old count. 记录该行在旧文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> nc;         <span class="comment">// new count. 记录该行在新文件中出现的次数</span></span><br><span class="line">    <span class="type">int</span> olno;       <span class="comment">// old line number. 记录该行在旧文件中的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，为了方便快速查找某一行所对应的
entry，这里还定义了一个哈希表，算法中称为 <strong>符号表（Symbol
Table）</strong>，其中 Key 为行内容，Value 为 entry。</p>
<p>如下所示，为算法所定义的相关数据结构。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-01.png?x-oss-process=image/resize,w_800" /></p>
<h1 id="算法实现">算法实现</h1>
<p>算法的实现主要分为三个部分，分别是：</p>
<ul>
<li>构建阶段</li>
<li>移动类型筛选</li>
<li>分析输出</li>
</ul>
<p>下面依次进行介绍。</p>
<h2 id="构建阶段">构建阶段</h2>
<p>在构建阶段，将遍历新文件和旧文件的每一行，同时构建数组、符号表表项（Key
为行内容，Value 为 Entry）。</p>
<ul>
<li>对于新文件，在构建 Entry 时，对 <code>nc</code> 字段加 1。</li>
<li>对于旧文件，在构建 Entry 时，对 <code>oc</code> 字段加 1，并设置
<code>olno</code> 为当前的行号。</li>
</ul>
<p>在构建数组（ <code>NA</code> 和 <code>OA</code>
）时，其元素均为指针类型，指向当前行对应在符号表中的 entry。</p>
<p>很显然，构建阶段需要进行两次遍历，其对应在论文中分别是 Pass 1 和 Pass
2。</p>
<h2 id="移动类型筛选">移动类型筛选</h2>
<p>在构建阶段完成后，数组 <code>NA</code> 和 <code>OA</code>
中的所有元素都是指针类型，指向符号表中的某个
entry。接下来，只要我们把属于 <strong>移动</strong>
类型的行筛选出来，也就是把数组中的某些元素修改为行号，即可完成对三种类型的分类。</p>
<p>在继续介绍之前，我们先说明一种常见的情况：<strong>一个文件中行内容可能是唯一项，也可能是重复项</strong>。比如，在下图所示的两个文件中，<code>THE</code>
在新旧两个文件中都重复出现了两次，<code>A</code>、<code>MASS</code>、<code>OF</code>
等内容在各自的文件中都是唯一项。对此，算法的处理方式也有所不同。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-03.png?x-oss-process=image/resize,w_800" /></p>
<h3 id="唯一项筛选">唯一项筛选</h3>
<p>对于唯一项，很显然，如果符合移动类型的话，行所对应的 entry 中的
<code>oc</code> 和 <code>nc</code> 的值均为
1，表示它们在新旧文件中各自只出现了一次。</p>
<p>由于移动类型是对等的，所以我们只需要遍历 <code>NA</code>
数组就可以找到所有唯一项的移动类型。具体的做法是：</p>
<ul>
<li>遍历 <code>NA</code> 数组，根据元素（指针类型）找到对应的
entry。</li>
<li>判断 entry 的 <code>oc</code> 和 <code>nc</code> 字段是否均为 1。
<ul>
<li>如果符合条件，则将 <code>NA</code>
对应的位置的元素设置成行号类型，值为
<code>olno</code>（即该行对应在旧文件中的位置）；同时将 <code>OA</code>
的 <code>olno</code> 位置的元素设置成行号类型，值为
<code>i</code>（即当前遍历到的行号）。此时，两者实现了移动匹配（各自记录了彼此的位置）。</li>
<li>如果不符合条件，则将继续遍历 <code>NA</code>。</li>
</ul></li>
</ul>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-04.png?x-oss-process=image/resize,w_800" /></p>
<p>在遍历完成后，数组 <code>NA</code> 和 <code>OA</code>
中均可能有一部分元素变成了行号类型，值为对方的某个行号。本轮遍历对应在论文中是
Pass 3。</p>
<h3 id="重复项筛选">重复项筛选</h3>
<p>对于重复项，算法采用了一种模糊处理的方式。这里主要遵循了下面这个设定：</p>
<blockquote>
<p>If a line has been found to be unaltered, and the lines immediately
adjacent to it in both files are identical, then these lines must be the
same line. This information can be used to find blocks of unchanged
lines.</p>
<p>译：如果某一行没有发生改变，并且在新旧两个文件中与它紧邻的行都是相同的，那么这些行必须是相同的行。这个信息可以用来找到未改变的行块。</p>
</blockquote>
<p>上述设定需要寻找某一行前后邻近的行，很显然，需要进行两次遍历，分别是正向遍历和反向遍历。同样，这里只需要遍历
<code>NA</code> 即可。</p>
<p>对于正向遍历，会进行以下处理：</p>
<ul>
<li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当
<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示
<code>NA[i]</code> 指向 <code>OA[j]</code>）
<ul>
<li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>
类型的行，那么继续判断 <code>NA[i+1]</code> 是否与 <code>OA[j+1]</code>
指向同一个 entry。
<ul>
<li>如果是，则将 <code>NA[i+1]</code> 的元素设置成行号类型，值为
<code>j+1</code>；将 <code>OA[j+1]</code> 的元素设置成行号类型，值为
<code>i+1</code>。</li>
</ul></li>
</ul></li>
<li>此外其他情况均继续遍历 <code>NA</code>。</li>
</ul>
<p>对于反向遍历，其处理与正向遍历类似，只不过方向相反：</p>
<ul>
<li>判断 <code>NA[i]</code> 是否指向 <code>OA[j]</code>（当
<code>NA[i]</code> 的元素为行号时，且行号为 <code>j</code>，即表示
<code>NA[i]</code> 指向 <code>OA[j]</code>）
<ul>
<li>如果是，则表示当前行是已发现的属于 <strong>移动</strong>
类型的行，那么继续判断 <code>NA[i-1]</code> 是否与 <code>OA[j-1]</code>
指向同一个 entry。
<ul>
<li>如果是，则将 <code>NA[i-1]</code> 的元素设置成行号类型，值为
<code>j-1</code>；将 <code>OA[j-1]</code> 的元素设置成行号类型，值为
<code>i-1</code>。</li>
</ul></li>
</ul></li>
<li>此外其他情况均继续遍历 <code>NA</code>。</li>
</ul>
<p>经过这一番操作后，算法会处理筛选出重复项，下图所示红色标识。这些重复项的
<strong>移动</strong> 类型，可以与某些唯一项连成
<strong>移动块</strong>。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-02.png?x-oss-process=image/resize,w_800" /></p>
<p>重复项的筛选，经历了两次遍历，分别对应论文中的 Pass 4 和 Pass 5。</p>
<h2 id="分析输出">分析输出</h2>
<p>经过上述一系列处理之后，数组 <code>NA</code> 和 <code>OA</code>
将所有行分成了三种类型，分别是
<strong>删除</strong>、<strong>插入</strong>、<strong>移动</strong>。根据这些信息，我们可以遍历
<code>NA</code> 和
<code>OA</code>，输出差异的分析结果。这一步，对应在论文中则是 Pass
6。</p>
<h1 id="算法缺陷">算法缺陷</h1>
<p>至此，仔细的同学可能会发现，在重复项筛选的过程中，算法会遗漏一部分属于
<strong>移动</strong> 类型的行，而将它们误判为 <strong>删除</strong> 或
<strong>插入</strong> 类型。</p>
<p>如下所示为算法误判的一个例子。我们将新文件中的第一个 <code>THE</code>
前后相邻的两个行改成两个唯一项 <code>UNIQUE1</code> 和
<code>UNIQUE2</code>。由于旧文件中不存在 <code>UNIQUE1</code> 和
<code>UNIQUE2</code>，所以它们是属于插入类型的项。此时，我们再看上述
Pass 4 和 Pass 5 的执行逻辑，可以看出新文件中的第一个 <code>THE</code>
并不会并筛选为移动类型，而是被错误地认为是插入类型。所以说，Paul Heckel
算法对于重复项的处理采用了一种模糊处理的方式。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-05.png?x-oss-process=image/resize,w_800" /></p>
<p>事实上，这也是 Paul Heckel
差分算法的特点，它牺牲了一部分差异精准度，换来了更快的分析速度。这也是为什么我们在「解决了什么问题」这一节中说
Paul Heckel 算法适合速度敏感、差异不敏感的系统。</p>
<h1 id="算法应用">算法应用</h1>
<p>基于 Paul Heckel 算法变种的差分算法应用其实非常多，在 iOS
开发中就有很多相关的框架，比如：IGListKit、DifferenceKit、RxDataSources、FlexibleDiff、DeepDiff
等。下面，我们来看看 IGListKit 是如何应用并优化 Paul Heckel
差分算法的。</p>
<h2 id="类型扩展">类型扩展</h2>
<p>由于绝大多数应用都对 Paul Heckel
算法进行了一定程度的优化，因此，我们必须要先了解它们到底优化了什么。</p>
<p>事实上，原始的 Paul Heckel 算法只对 <strong>位置</strong> 和
<strong>内容</strong> 两个维度进行差分检测（符号表的 Key
和数据判等都是基于 <strong>内容</strong>），从而产生 3
种分类，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">位置</th>
<th style="text-align: left;">内容</th>
<th style="text-align: left;">分类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move（起始位置不变）</td>
</tr>
<tr class="even">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="odd">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move</td>
</tr>
<tr class="even">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
</tbody>
</table>
<p>但是在实际应用中，为了支持更加复杂多变的场景，一般会额外支持
<strong>标识</strong> 或 <strong>ID</strong> 的维度。此时，算法将基于
<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong>
三个维度进行差分检测（符号表的 Key 基于
<strong>标识</strong>，数据判等基于 <strong>内容</strong>），对此将产生
4 种分类，如下表所示。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">标识（ID）</th>
<th style="text-align: left;">位置</th>
<th style="text-align: left;">内容</th>
<th style="text-align: left;">分类</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move（起始位置不变）</td>
</tr>
<tr class="even">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">update</td>
</tr>
<tr class="odd">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">move</td>
</tr>
<tr class="even">
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">update &amp; move</td>
</tr>
<tr class="odd">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="even">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="odd">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">相同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
<tr class="even">
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">不同</td>
<td style="text-align: left;">insert/delete</td>
</tr>
</tbody>
</table>
<h2 id="iglistdiff">IGListDiff</h2>
<h3 id="数据结构-1">数据结构</h3>
<p>在数据结构定义上，IGListDiff
与原始算法类似，也定义了一个符号表和两个数组，如下图所示。</p>
<p><img
src="https://chuquan-public-r-001.oss-cn-shanghai.aliyuncs.com/sketch-images/paul-heckel-06.png?x-oss-process=image/resize,w_800" /></p>
<p>对于符号表，IGListDiff 使用数据的标识（ID）作为 Key，以
<code>IGListEntry</code> 作为 Value。<code>IGListEntry</code>
的定义如下所示，很显然，它与原始算法中的 <code>entry</code>
结构非常类似：</p>
<ul>
<li><code>oldCounter</code> 和 <code>newCounter</code> 对应的是
<code>oc</code> 和 <code>nc</code> 字段。</li>
<li><code>oldIndex</code> 对应
<code>olno</code>，但是它支持记录多个位置信息，支持处理重复项。<code>olno</code>
只能记录一个位置。</li>
<li><code>IGListEntry</code> 额外还有一个 <code>updated</code>
字段，用于标记扩展的 <strong>更新</strong>（update）类型。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Used to track data stats while diffing.</span></span><br><span class="line"><span class="keyword">struct</span> IGListEntry &#123;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the old array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> oldCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The number of times the data occurs in the new array</span></span><br><span class="line">    <span class="built_in">NSInteger</span> newCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// The indexes of the data in the old array</span></span><br><span class="line">    stack&lt;<span class="built_in">NSInteger</span>&gt; oldIndexes;</span><br><span class="line">    <span class="comment">/// Flag marking if the data has been updated between arrays by checking the isEqual: method</span></span><br><span class="line">    <span class="type">BOOL</span> updated = <span class="literal">NO</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于两个数组，IGListDiff
同样具备，区别在于元素的表示形式。在原始算法中，<code>NA</code> 和
<code>OA</code> 数组存储的元素可能是指针或行号，而 IGListDiff 则使用
<code>IGListRecord</code>
类型来记录两种信息，其定义如下所示。其中，<code>entry</code>
用于存储指针，<code>index</code> 用于存储行号。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Track both the entry and algorithm index. Default the index to NSNotFound</span></span><br><span class="line"><span class="keyword">struct</span> IGListRecord &#123;</span><br><span class="line">    IGListEntry *entry;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">NSInteger</span> index;</span><br><span class="line"></span><br><span class="line">    IGListRecord() &#123;</span><br><span class="line">        entry = <span class="literal">NULL</span>;</span><br><span class="line">        index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除此之外，IGListDiff 定义一个 <code>IGListDiffable</code>
协议，所有希望调用 IGListDiff 差分算法的数据都必须支持该协议。如下所示为
<code>IGListDiffable</code> 的定义。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListDiffable)</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListDiffable</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns a key that uniquely identifies the object.</span></span><br><span class="line"><span class="comment"> @return A key that can be used to uniquely identify the object.</span></span><br><span class="line"><span class="comment"> @note Two objects may share the same identifier, but are not equal. A common pattern is to use the `NSObject` category for automatic conformance. However this means that objects will be identified on their pointer value so finding updates becomes impossible.</span></span><br><span class="line"><span class="comment"> @warning This value should never be mutated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;)diffIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Returns whether the receiver and a given object are equal.</span></span><br><span class="line"><span class="comment"> @param object The object to be compared to the receiver.</span></span><br><span class="line"><span class="comment"> @return `YES` if the receiver and object are equal, otherwise `NO`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToDiffableObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;IGListDiffable&gt;)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>算法会使用数据的 <code>diffIdentifier</code>
作为标识（ID），符号表也将以此为 Key 记录对应的 entry。另一个协议方法
<code>isEqualToDiffableObject:</code> 则用于进行内容判等。</p>
<p>关于输出，原始算法并没有做相关说明。对此，IGListDiff
自定义了两种输出结构，分别是 <code>IGListIndexSetResult</code> 和
<code>IGListIndexPathResult</code>，如下所示。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexPathResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexPathResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The index paths inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *inserts;</span><br><span class="line"><span class="comment">// The index paths deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *deletes;</span><br><span class="line"><span class="comment">// The index paths in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *updates;</span><br><span class="line"><span class="comment">// The moves from an index path in the old collection to an index path in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndexPath *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_SWIFT_NAME</span>(ListIndexSetResult)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListIndexSetResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// The indexes inserted into the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *inserts;</span><br><span class="line"><span class="comment">// The indexes deleted from the old collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *deletes;</span><br><span class="line"><span class="comment">// The indexes in the old collection that need updated.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSIndexSet</span> *updates;</span><br><span class="line"><span class="comment">// The moves from an index in the old collection to an index in the new collection.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;IGListMoveIndex *&gt; *moves;</span><br><span class="line"><span class="comment">// A Read-only boolean that indicates whether the result has any changes or not. `YES` if the result has changes, `NO` otherwise.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasChanges;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>两者均携带了所有差异数据的位置信息，包括：插入、删除、更新、移动。区别则在于
<code>IGListIndexPathResult</code> 用于表示位置信息的类型是
<code>NSIndexPath</code> 类型，适用于 iOS
中的列表数据，<code>IGListIndexSetResult</code> 用于表示位置信息的类型是
<code>NSInteger</code> 类型，更适合通用的数组数据。</p>
<h3 id="核心逻辑">核心逻辑</h3>
<p>IGListDiff 中 <code>IGListDiff.m</code> 文件的
<code>IGListDiffing</code>
方法实现了差分算法的核心逻辑，大概可分为三个步骤：</p>
<ul>
<li><strong>构建阶段</strong></li>
<li><strong>标记移动类型和更新类型</strong></li>
<li><strong>格式化输出</strong></li>
</ul>
<h4 id="构建阶段-1">构建阶段</h4>
<p>在构建阶段，IGListDiff
分别正向遍历新数据和反向遍历旧数据，从而构建数组元素
<code>NA</code>、<code>OA</code>、符号表，这一点与原始算法类似。这里反向遍历旧数据是因为这里使用栈来记录所有的
<code>olno</code>，以便后续正向地出栈旧数据的位置信息。具体代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt;, IGListEntry, IGListHashID, IGListEqualID&gt; table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 1</span></span><br><span class="line"><span class="comment">// create an entry for every item in the new array</span></span><br><span class="line"><span class="comment">// increment its new count for each occurence</span></span><br><span class="line">vector&lt;IGListRecord&gt; newResultsArray(newCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(newArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.newCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add NSNotFound for each occurence of the item in the new array</span></span><br><span class="line">    entry.oldIndexes.push(<span class="built_in">NSNotFound</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    newResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 2</span></span><br><span class="line"><span class="comment">// update or create an entry for every item in the old array</span></span><br><span class="line"><span class="comment">// increment its old count for each occurence</span></span><br><span class="line"><span class="comment">// record the original index of the item in the old array</span></span><br><span class="line"><span class="comment">// MUST be done in descending order to respect the oldIndexes stack construction</span></span><br><span class="line">vector&lt;IGListRecord&gt; oldResultsArray(oldCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; key = IGListTableKey(oldArray[i]);</span><br><span class="line">    IGListEntry &amp;entry = table[key];</span><br><span class="line">    entry.oldCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push the original indices where the item occurred onto the index stack</span></span><br><span class="line">    entry.oldIndexes.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// note: the entry is just a pointer to the entry which is stack-allocated in the table</span></span><br><span class="line">    oldResultsArray[i].entry = &amp;entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标记移动类型和更新类型">标记移动类型和更新类型</h4>
<p>构建完成之后，开始对移动类型和更新类型进行标记，具体如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pass 3</span></span><br><span class="line"><span class="comment">// handle data that occurs in both arrays</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    IGListEntry *entry = newResultsArray[i].entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// grab and pop the top original index. if the item was inserted this will be NSNotFound</span></span><br><span class="line">    <span class="built_in">NSCAssert</span>(!entry-&gt;oldIndexes.empty(), <span class="string">@&quot;Old indexes is empty while iterating new item %li. Should have NSNotFound&quot;</span>, (<span class="type">long</span>)i);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> originalIndex = entry-&gt;oldIndexes.top();</span><br><span class="line">    entry-&gt;oldIndexes.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// originalIndex 存在表示「标识相同」。这里判断 originalIndex &lt; oldCount 应该是为了做越界保护。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex &lt; oldCount) &#123;</span><br><span class="line">        <span class="comment">// 对于「内容不同」的项，将其标记为更新类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; n = newArray[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="type">id</span>&lt;IGListDiffable&gt; o = oldArray[originalIndex];</span><br><span class="line">        <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffPointerPersonality:</span><br><span class="line">                <span class="comment">// 基于指针判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IGListDiffEquality:</span><br><span class="line">                <span class="comment">// 基于指针 + 内容判断</span></span><br><span class="line">                <span class="keyword">if</span> (n != o &amp;&amp; ![n isEqualToDiffableObject:o]) &#123;</span><br><span class="line">                    <span class="comment">// 如果指针不同，并且内容不同，则表示更新类型</span></span><br><span class="line">                    entry-&gt;updated = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0 表示新旧数据均存在</span></span><br><span class="line">    <span class="comment">// originalIndex != NSNotFound 的是为了让新旧数据两两匹配，因为 oldIndexes 随着遍历的迭代，始终在出栈。</span></span><br><span class="line">    <span class="keyword">if</span> (originalIndex != <span class="built_in">NSNotFound</span></span><br><span class="line">        &amp;&amp; entry-&gt;newCounter &gt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; entry-&gt;oldCounter &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 对于「内容相同」的项，交换记录其在对方数组中的位置，表示移动类型</span></span><br><span class="line">        newResultsArray[i].index = originalIndex;</span><br><span class="line">        oldResultsArray[originalIndex].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出，每次迭代会从根据 <code>NA</code> 数组元素
<code>IGListRecord</code> 的 <code>entry</code> 字段索引到符号表中对应的
<code>IGListEntry</code>。然后从 <code>IGListEntry</code> 的
<code>oldIndexes</code> 字段出栈一个旧文件中存在的位置。</p>
<p>如果 <code>originalIndex</code> 存在，则表示 <code>NA</code> 和
<code>OA</code> 均存在，此时进一步判断内容，如果内容发生了变化则标记
<code>updated</code> 字段为
<code>YES</code>。判断内容变化的方式有两种，用户可以选择配置：</p>
<ul>
<li><strong>基于指针判断</strong>：如果指针不同，则表示数据发生了变化</li>
<li><strong>基于指针+内容判断</strong>：如果指针不同，并且内容不同，则表示数据发生了变化</li>
</ul>
<p>在遍历过程中，还会记录移动类型的位置信息。它的前提条件包含两部分：</p>
<ul>
<li><code>newCounter &gt; 0 &amp;&amp; oldCounter &gt; 0</code>：表示新旧数据均存在</li>
<li><code>originalIndex != NSNotFound</code>：表示新旧数据可以进行移动类型的匹配，每一次匹配，<code>oldIndexes</code>
都会出栈一次，消耗一次对等的匹配。举个例子：
<ul>
<li>如果 <code>newCounter = 3</code>，<code>oldCounter = 2</code>
时，<code>NA</code>
中第三个数据会被归为插入类型，前两个数据会被归为移动类型。</li>
<li>如果 <code>newCounter = 2</code>，<code>oldCounter = 3</code>
时，<code>OA</code>
中的第三个数据会被归为删除类型，前两个数据会被归为移动类型。</li>
</ul></li>
</ul>
<h4 id="格式化输出">格式化输出</h4>
<p>首先，遍历 <code>OA</code>
数组，确定删除类型，具体代码如下所示。数组元素的 <code>index</code>
类型为 <code>NSNotFound</code> 类似于原始算法中 <code>OA</code>
元素的类型为指针。当符合这个条件时，表示数据类型为删除类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterate old array records checking for deletes</span></span><br><span class="line"><span class="comment">// incremement offset for each delete</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">    deleteOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = oldResultsArray[i];</span><br><span class="line">    <span class="comment">// if the record index in the new array doesn&#x27;t exist, its a delete</span></span><br><span class="line">    <span class="comment">// 对 OA 中的删除项进行分类</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，遍历 <code>NA</code>
数组，确定插入、更新、移动等类型，具体代码如下所示。数组元素的
<code>index</code> 类型为 <code>NSNotFound</code> 类似于原始算法中
<code>NA</code>
元素的类型为指针。当符合这个条件时，表示数据类型为插入类型。否则，均属于移动类型。</p>
<p>这里由于 IGListDiff 额外扩展了一个 <code>updated</code>
字段，所以有一部分元素为同时标记为更新类型。这一点其实很容易理解，当新旧数据中有一个数据标识相同，但是位置不同，且内容不同，我们可以认为它做了一次移动操作修改了位置，又做了一次更新操作修改了内容。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; newCount; i++) &#123;</span><br><span class="line">    insertOffsets[i] = runningOffset;</span><br><span class="line">    <span class="keyword">const</span> IGListRecord record = newResultsArray[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> oldIndex = record.index;</span><br><span class="line">    <span class="comment">// add to inserts if the opposing index is NSNotFound</span></span><br><span class="line">    <span class="keyword">if</span> (record.index == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定插入类型</span></span><br><span class="line">        addIndexToCollection(returnIndexPaths, mInserts, toSection, i);</span><br><span class="line">        runningOffset++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// note that an entry can be updated /and/ moved</span></span><br><span class="line">        <span class="keyword">if</span> (record.entry-&gt;updated) &#123;</span><br><span class="line">            <span class="comment">// 确定更新类型</span></span><br><span class="line">            addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate the offset and determine if there was a move</span></span><br><span class="line">        <span class="comment">// if the indexes match, ignore the index</span></span><br><span class="line">        <span class="comment">// 确定移动类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> insertOffset = insertOffsets[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> deleteOffset = deleteOffsets[oldIndex];</span><br><span class="line">        <span class="keyword">if</span> ((oldIndex - deleteOffset + insertOffset) != i) &#123;</span><br><span class="line">            <span class="type">id</span> move;</span><br><span class="line">            <span class="keyword">if</span> (returnIndexPaths) &#123;</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *from = [<span class="built_in">NSIndexPath</span> indexPathForItem:oldIndex inSection:fromSection];</span><br><span class="line">                <span class="built_in">NSIndexPath</span> *to = [<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:toSection];</span><br><span class="line">                move = [[IGListMoveIndexPath alloc] initWithFrom:from to:to];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                move = [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i];</span><br><span class="line">            &#125;</span><br><span class="line">            [mMoves addObject:move];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addIndexToMap(returnIndexPaths, toSection, i, newArray[i], newMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化小结">优化小结</h3>
<p>整体而言，IGListDiff 在 Paul Heckel
差分算法的基础上扩展了差分类型，从原来的
<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong> 3
种类型扩展成
<strong>插入</strong>、<strong>删除</strong>、<strong>移动</strong>、<strong>更新</strong>
4 种类型。类型的扩展本质上是通过增加检测维度实现的，Paul Heckel
差分算法只支持 <strong>位置</strong>、<strong>内容</strong> 2
个维度进行检测，而 IGListDiff 则支持
<strong>标识</strong>、<strong>位置</strong>、<strong>内容</strong> 3
个维度进行检测。</p>
<p>此外，IGListDiff 实现了精准检测，而 Paul Heckel
算法实现的是模糊处理，会存在移动类型误判为插入或删除等情况。这种精准检测的能力，适用于对差异敏感的系统，使得算法的应用场景进一步扩大。</p>
<h1 id="总结">总结</h1>
<p>本文首先介绍了原始的 Paul Heckel 差分算法的实现原理。原始的 Paul
Heckel 差分算法基于位置、内容 2
个维度进行差分检测，支持检测插入、删除、移动等 3
种类型。但是，其实现的是一种模糊处理的差分检测，会存在将移动类型归为插入或删除的情况。</p>
<p>其次，我们介绍了 IGListKit 中的 IGListDiff 模块，其在 Paul Heckel
差分算法的基础上进行了优化，基于标识、位置、内容 3
个维度进行差分检测，支持检测插入、删除、移动、更新等 4
种类型。IGListDiff 实现了一种精确分析的差分算法，这更符合我们在 UI
框架中对于数据差异精准检测的需求。</p>
<p>通过上文的介绍，我们可以举一反三猜想地其他应用是如何实现数据差分检测的。对此，如果你感兴趣的话，可以研究一个其他的框架，来印证一下你的猜想，甚至可以考虑自己实现差分算法。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://dl.acm.org/doi/pdf/10.1145/359460.359467">A
Technique for Isolating Differences Between Files</a>. Paul Heckel.</li>
<li><a href="https://gist.github.com/ndarville/3166060">Isolating
Differences Between Files</a></li>
<li><a href="https://github.com/Instagram/IGListKit">IGListKit</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Bao Chuquan 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="Bao Chuquan 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/" rel="tag"># 差分算法</a>
              <a href="/tags/Paul-Heckel/" rel="tag"># Paul Heckel</a>
              <a href="/tags/IGListKit/" rel="tag"># IGListKit</a>
              <a href="/tags/IGListDiff/" rel="tag"># IGListDiff</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/16/about-blog-upgrade/" rel="prev" title="关于本次博客升级">
                  <i class="fa fa-angle-left"></i> 关于本次博客升级
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/21/sketch-cheat-sheet/" rel="next" title="Sketch Cheat Sheet">
                  Sketch Cheat Sheet <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">true</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
  <div>
     <a href="https://beian.miit.gov.cn/" target="_blank">浙ICP备16031766号-1</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://vercel.chuquan.me","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"(发表评论)","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"dark":"body.darkmode--activated","visitor":true,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2023/10/06/paul-heckel-difference-algorithm/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<script src="/live2dwlib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dwassets/tororo.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
